{"sha": "5d8f59f4b1473217c2de7e02330b5aaae70a1668", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkOGY1OWY0YjE0NzMyMTdjMmRlN2UwMjMzMGI1YWFhZTcwYTE2Njg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-04T20:10:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-04T20:10:54Z"}, "message": "Auto merge of #61407 - phansch:annotate_snippet_refactoring1, r=oli-obk\n\nAdd new diagnostic writer using annotate-snippet library\n\nThis adds a new diagnostic writer `AnnotateRsEmitterWriter` that uses\nthe [`annotate-snippet`][as] library to print out the human readable\ndiagnostics.\n\nThe goal of #59346 is to eventually switch over to using the library instead of\nmaintaining our own diagnostics output.\n\nThis PR does **not** add all the required features to the new\ndiagnostics writer. It is only meant as a starting point so that other\npeople can start contributing as well.\n\nThere are some FIXMEs in `librustc_errors/annotate_rs_emitter.rs` that\npoint at yet to be implemented features of the new diagnostic emitter, however\nthose are most likely not exhaustive.\n\n[as]: https://github.com/rust-lang/annotate-snippets-rs", "tree": {"sha": "4164baf6973e9453f21cf9665b8aef4007f5b9cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4164baf6973e9453f21cf9665b8aef4007f5b9cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d8f59f4b1473217c2de7e02330b5aaae70a1668", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d8f59f4b1473217c2de7e02330b5aaae70a1668", "html_url": "https://github.com/rust-lang/rust/commit/5d8f59f4b1473217c2de7e02330b5aaae70a1668", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d8f59f4b1473217c2de7e02330b5aaae70a1668/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97c9437585edafb59dc24701578dc0f20756178c", "url": "https://api.github.com/repos/rust-lang/rust/commits/97c9437585edafb59dc24701578dc0f20756178c", "html_url": "https://github.com/rust-lang/rust/commit/97c9437585edafb59dc24701578dc0f20756178c"}, {"sha": "bfe5d9796b38fdecab6cd7afd28e0a7f23e4915a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfe5d9796b38fdecab6cd7afd28e0a7f23e4915a", "html_url": "https://github.com/rust-lang/rust/commit/bfe5d9796b38fdecab6cd7afd28e0a7f23e4915a"}], "stats": {"total": 283, "additions": 267, "deletions": 16}, "files": [{"sha": "5293391a0715525312c21720efd8381caa2b70bd", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d8f59f4b1473217c2de7e02330b5aaae70a1668/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5d8f59f4b1473217c2de7e02330b5aaae70a1668/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5d8f59f4b1473217c2de7e02330b5aaae70a1668", "patch": "@@ -2789,6 +2789,7 @@ dependencies = [\n name = \"rustc_errors\"\n version = \"0.0.0\"\n dependencies = [\n+ \"annotate-snippets 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\","}, {"sha": "6a35906d20c2f531dbd9a011d3c74a0652c2523b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5d8f59f4b1473217c2de7e02330b5aaae70a1668", "patch": "@@ -2002,6 +2002,9 @@ pub fn build_session_options_and_crate_config(\n         match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n             None |\n             Some(\"human\") => ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(color)),\n+            Some(\"human-annotate-rs\") => {\n+                ErrorOutputType::HumanReadable(HumanReadableErrorType::AnnotateRs(color))\n+            },\n             Some(\"json\") => ErrorOutputType::Json { pretty: false, json_rendered },\n             Some(\"pretty-json\") => ErrorOutputType::Json { pretty: true, json_rendered },\n             Some(\"short\") => ErrorOutputType::HumanReadable(HumanReadableErrorType::Short(color)),\n@@ -2038,6 +2041,13 @@ pub fn build_session_options_and_crate_config(\n                 \"--error-format=pretty-json is unstable\",\n             );\n         }\n+        if let ErrorOutputType::HumanReadable(HumanReadableErrorType::AnnotateRs(_)) =\n+            error_format {\n+            early_error(\n+                ErrorOutputType::Json { pretty: false, json_rendered },\n+                \"--error-format=human-annotate-rs is unstable\",\n+            );\n+        }\n     }\n \n     if debugging_opts.pgo_gen.enabled() && debugging_opts.pgo_use.is_some() {"}, {"sha": "b3a9d764b1db01cc4b9766187f253eaf802815c0", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=5d8f59f4b1473217c2de7e02330b5aaae70a1668", "patch": "@@ -23,6 +23,8 @@ use rustc_data_structures::sync::{\n \n use errors::{DiagnosticBuilder, DiagnosticId, Applicability};\n use errors::emitter::{Emitter, EmitterWriter};\n+use errors::emitter::HumanReadableErrorType;\n+use errors::annotate_rs_emitter::{AnnotateRsEmitterWriter};\n use syntax::ast::{self, NodeId};\n use syntax::edition::Edition;\n use syntax::feature_gate::{self, AttributeType};\n@@ -1031,22 +1033,31 @@ fn default_emitter(\n     match (sopts.error_format, emitter_dest) {\n         (config::ErrorOutputType::HumanReadable(kind), dst) => {\n             let (short, color_config) = kind.unzip();\n-            let emitter = match dst {\n-                None => EmitterWriter::stderr(\n-                    color_config,\n-                    Some(source_map.clone()),\n-                    short,\n-                    sopts.debugging_opts.teach,\n-                ),\n-                Some(dst) => EmitterWriter::new(\n-                    dst,\n+\n+            if let HumanReadableErrorType::AnnotateRs(_) = kind {\n+                let emitter = AnnotateRsEmitterWriter::new(\n                     Some(source_map.clone()),\n                     short,\n-                    false, // no teach messages when writing to a buffer\n-                    false, // no colors when writing to a buffer\n-                ),\n-            };\n-            Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing))\n+                );\n+                Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing))\n+            } else {\n+                let emitter = match dst {\n+                    None => EmitterWriter::stderr(\n+                        color_config,\n+                        Some(source_map.clone()),\n+                        short,\n+                        sopts.debugging_opts.teach,\n+                    ),\n+                    Some(dst) => EmitterWriter::new(\n+                        dst,\n+                        Some(source_map.clone()),\n+                        short,\n+                        false, // no teach messages when writing to a buffer\n+                        false, // no colors when writing to a buffer\n+                    ),\n+                };\n+                Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing))\n+            }\n         },\n         (config::ErrorOutputType::Json { pretty, json_rendered }, None) => Box::new(\n             JsonEmitter::stderr("}, {"sha": "3689a463a5c84a86c4be5f87bdf3d758c336d7eb", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=5d8f59f4b1473217c2de7e02330b5aaae70a1668", "patch": "@@ -18,3 +18,4 @@ rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n unicode-width = \"0.1.4\"\n atty = \"0.2\"\n termcolor = \"1.0\"\n+annotate-snippets = \"0.5.0\""}, {"sha": "de42389de74ba2c58b331a96490b3e7df0420df4", "filename": "src/librustc_errors/annotate_rs_emitter.rs", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Flibrustc_errors%2Fannotate_rs_emitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Flibrustc_errors%2Fannotate_rs_emitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_rs_emitter.rs?ref=5d8f59f4b1473217c2de7e02330b5aaae70a1668", "patch": "@@ -0,0 +1,212 @@\n+/// Emit diagnostics using the `annotate-snippets` library\n+///\n+/// This is the equivalent of `./emitter.rs` but making use of the\n+/// [`annotate-snippets`][annotate_snippets] library instead of building the output ourselves.\n+///\n+/// [annotate_snippets]: https://docs.rs/crate/annotate-snippets/\n+\n+use syntax_pos::{SourceFile, MultiSpan, Loc};\n+use crate::{\n+    Level, CodeSuggestion, DiagnosticBuilder, Emitter,\n+    SourceMapperDyn, SubDiagnostic, DiagnosticId\n+};\n+use crate::emitter::FileWithAnnotatedLines;\n+use rustc_data_structures::sync::Lrc;\n+use crate::snippet::Line;\n+use annotate_snippets::snippet::*;\n+use annotate_snippets::display_list::DisplayList;\n+use annotate_snippets::formatter::DisplayListFormatter;\n+\n+\n+/// Generates diagnostics using annotate-rs\n+pub struct AnnotateRsEmitterWriter {\n+    source_map: Option<Lrc<SourceMapperDyn>>,\n+    /// If true, hides the longer explanation text\n+    short_message: bool,\n+    /// If true, will normalize line numbers with LL to prevent noise in UI test diffs.\n+    ui_testing: bool,\n+}\n+\n+impl Emitter for AnnotateRsEmitterWriter {\n+    /// The entry point for the diagnostics generation\n+    fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n+        let primary_span = db.span.clone();\n+        let children = db.children.clone();\n+        // FIXME(#59346): Collect suggestions (see emitter.rs)\n+        let suggestions: &[_] = &[];\n+\n+        // FIXME(#59346): Add `fix_multispans_in_std_macros` function from emitter.rs\n+\n+        self.emit_messages_default(&db.level,\n+                                   db.message(),\n+                                   &db.code,\n+                                   &primary_span,\n+                                   &children,\n+                                   &suggestions);\n+    }\n+\n+    fn should_show_explain(&self) -> bool {\n+        !self.short_message\n+    }\n+}\n+\n+/// Collects all the data needed to generate the data structures needed for the\n+/// `annotate-snippets` library.\n+struct DiagnosticConverter<'a> {\n+    source_map: Option<Lrc<SourceMapperDyn>>,\n+    level: Level,\n+    message: String,\n+    code: Option<DiagnosticId>,\n+    msp: MultiSpan,\n+    #[allow(dead_code)]\n+    children: &'a [SubDiagnostic],\n+    #[allow(dead_code)]\n+    suggestions: &'a [CodeSuggestion]\n+}\n+\n+impl<'a>  DiagnosticConverter<'a> {\n+    /// Turns rustc Diagnostic information into a `annotate_snippets::snippet::Snippet`.\n+    fn to_annotation_snippet(&self) -> Option<Snippet> {\n+        if let Some(source_map) = &self.source_map {\n+            // Make sure our primary file comes first\n+            let primary_lo = if let Some(ref primary_span) =\n+                self.msp.primary_span().as_ref() {\n+                source_map.lookup_char_pos(primary_span.lo())\n+            } else {\n+                // FIXME(#59346): Not sure when this is the case and what\n+                // should be done if it happens\n+                return None\n+            };\n+            let annotated_files = FileWithAnnotatedLines::collect_annotations(\n+                &self.msp,\n+                &self.source_map\n+            );\n+            let slices = self.slices_for_files(annotated_files, primary_lo);\n+\n+            Some(Snippet {\n+                title: Some(Annotation {\n+                    label: Some(self.message.to_string()),\n+                    id: self.code.clone().map(|c| {\n+                        match c {\n+                            DiagnosticId::Error(val) | DiagnosticId::Lint(val) => val\n+                        }\n+                    }),\n+                    annotation_type: Self::annotation_type_for_level(self.level),\n+                }),\n+                footer: vec![],\n+                slices: slices,\n+            })\n+        } else {\n+            // FIXME(#59346): Is it ok to return None if there's no source_map?\n+            None\n+        }\n+    }\n+\n+    fn slices_for_files(\n+        &self,\n+        annotated_files: Vec<FileWithAnnotatedLines>,\n+        primary_lo: Loc\n+    ) -> Vec<Slice> {\n+        // FIXME(#59346): Provide a test case where `annotated_files` is > 1\n+        annotated_files.iter().flat_map(|annotated_file| {\n+            annotated_file.lines.iter().map(|line| {\n+                let line_source = Self::source_string(annotated_file.file.clone(), &line);\n+                Slice {\n+                    source: line_source,\n+                    line_start: line.line_index,\n+                    origin: Some(primary_lo.file.name.to_string()),\n+                    // FIXME(#59346): Not really sure when `fold` should be true or false\n+                    fold: false,\n+                    annotations: line.annotations.iter().map(|a| {\n+                        self.annotation_to_source_annotation(a.clone())\n+                    }).collect(),\n+                }\n+            }).collect::<Vec<Slice>>()\n+        }).collect::<Vec<Slice>>()\n+    }\n+\n+    /// Turns a `crate::snippet::Annotation` into a `SourceAnnotation`\n+    fn annotation_to_source_annotation(\n+        &self,\n+        annotation: crate::snippet::Annotation\n+    ) -> SourceAnnotation {\n+        SourceAnnotation {\n+            range: (annotation.start_col, annotation.end_col),\n+            label: annotation.label.unwrap_or(\"\".to_string()),\n+            annotation_type: Self::annotation_type_for_level(self.level)\n+        }\n+    }\n+\n+    /// Provides the source string for the given `line` of `file`\n+    fn source_string(\n+        file: Lrc<SourceFile>,\n+        line: &Line\n+    ) -> String {\n+        file.get_line(line.line_index - 1).map(|a| a.to_string()).unwrap_or(String::new())\n+    }\n+\n+    /// Maps `Diagnostic::Level` to `snippet::AnnotationType`\n+    fn annotation_type_for_level(level: Level) -> AnnotationType {\n+        match level {\n+            Level::Bug | Level::Fatal | Level::PhaseFatal | Level::Error => AnnotationType::Error,\n+            Level::Warning => AnnotationType::Warning,\n+            Level::Note => AnnotationType::Note,\n+            Level::Help => AnnotationType::Help,\n+            // FIXME(#59346): Not sure how to map these two levels\n+            Level::Cancelled | Level::FailureNote => AnnotationType::Error\n+        }\n+    }\n+}\n+\n+impl AnnotateRsEmitterWriter {\n+    pub fn new(\n+        source_map: Option<Lrc<SourceMapperDyn>>,\n+        short_message: bool\n+    ) -> Self {\n+        Self {\n+            source_map,\n+            short_message,\n+            ui_testing: false,\n+        }\n+    }\n+\n+    /// Allows to modify `Self` to enable or disable the `ui_testing` flag.\n+    ///\n+    /// If this is set to true, line numbers will be normalized as `LL` in the output.\n+    // FIXME(#59346): This method is used via the public interface, but setting the `ui_testing`\n+    // flag currently does not anonymize line numbers. We would have to add the `maybe_anonymized`\n+    // method from `emitter.rs` and implement rust-lang/annotate-snippets-rs#2 in order to\n+    // anonymize line numbers.\n+    pub fn ui_testing(mut self, ui_testing: bool) -> Self {\n+        self.ui_testing = ui_testing;\n+        self\n+    }\n+\n+    fn emit_messages_default(\n+        &mut self,\n+        level: &Level,\n+        message: String,\n+        code: &Option<DiagnosticId>,\n+        msp: &MultiSpan,\n+        children: &[SubDiagnostic],\n+        suggestions: &[CodeSuggestion]\n+    ) {\n+        let converter = DiagnosticConverter {\n+            source_map: self.source_map.clone(),\n+            level: level.clone(),\n+            message: message.clone(),\n+            code: code.clone(),\n+            msp: msp.clone(),\n+            children,\n+            suggestions\n+        };\n+        if let Some(snippet) = converter.to_annotation_snippet() {\n+            let dl = DisplayList::from(snippet);\n+            let dlf = DisplayListFormatter::new(true);\n+            // FIXME(#59346): Figure out if we can _always_ print to stderr or not.\n+            // `emitter.rs` has the `Destination` enum that lists various possible output\n+            // destinations.\n+            eprintln!(\"{}\", dlf.format(&dl));\n+        };\n+    }\n+}"}, {"sha": "fcc0358ea7c11332065e126080f88ffba7da1eb7", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=5d8f59f4b1473217c2de7e02330b5aaae70a1668", "patch": "@@ -24,6 +24,7 @@ use termcolor::{WriteColor, Color, Buffer};\n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum HumanReadableErrorType {\n     Default(ColorConfig),\n+    AnnotateRs(ColorConfig),\n     Short(ColorConfig),\n }\n \n@@ -33,6 +34,7 @@ impl HumanReadableErrorType {\n         match self {\n             HumanReadableErrorType::Default(cc) => (false, cc),\n             HumanReadableErrorType::Short(cc) => (true, cc),\n+            HumanReadableErrorType::AnnotateRs(cc) => (false, cc),\n         }\n     }\n     pub fn new_emitter(\n@@ -173,8 +175,8 @@ pub struct EmitterWriter {\n \n #[derive(Debug)]\n pub struct FileWithAnnotatedLines {\n-    file: Lrc<SourceFile>,\n-    lines: Vec<Line>,\n+    pub file: Lrc<SourceFile>,\n+    pub lines: Vec<Line>,\n     multiline_depth: usize,\n }\n "}, {"sha": "7bc7d0ddaf243090a3f768a2ee6ea6888e2a8135", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=5d8f59f4b1473217c2de7e02330b5aaae70a1668", "patch": "@@ -33,6 +33,7 @@ use termcolor::{ColorSpec, Color};\n mod diagnostic;\n mod diagnostic_builder;\n pub mod emitter;\n+pub mod annotate_rs_emitter;\n mod snippet;\n pub mod registry;\n mod styled_buffer;"}, {"sha": "d0814a9537d0c755478c69b1ee806d9c15346f46", "filename": "src/test/ui/annotate-snippet/missing-type.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.rs?ref=5d8f59f4b1473217c2de7e02330b5aaae70a1668", "patch": "@@ -0,0 +1,5 @@\n+// compile-flags: --error-format human-annotate-rs\n+\n+pub fn main() {\n+    let x: Iter; //~ ERROR cannot find type `Iter` in this scope\n+}"}, {"sha": "8857ae7d850344954fb3d9de13bc4c5f84f225ed", "filename": "src/test/ui/annotate-snippet/missing-type.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr?ref=5d8f59f4b1473217c2de7e02330b5aaae70a1668", "patch": "@@ -0,0 +1,6 @@\n+error[E0412]: cannot find type `Iter` in this scope\n+ --> $DIR/missing-type.rs:4:11\n+  |\n+4 |     let x: Iter;\n+  |            ^^^^ not found in this scope\n+  |"}, {"sha": "11f37b27188694e9d13504671f310d2082724673", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8f59f4b1473217c2de7e02330b5aaae70a1668/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=5d8f59f4b1473217c2de7e02330b5aaae70a1668", "patch": "@@ -62,6 +62,8 @@ const WHITELIST_CRATES: &[CrateVersion<'_>] = &[\n const WHITELIST: &[Crate<'_>] = &[\n     Crate(\"adler32\"),\n     Crate(\"aho-corasick\"),\n+    Crate(\"annotate-snippets\"),\n+    Crate(\"ansi_term\"),\n     Crate(\"arrayvec\"),\n     Crate(\"atty\"),\n     Crate(\"autocfg\"),"}]}