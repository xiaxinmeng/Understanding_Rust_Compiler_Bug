{"sha": "79854395caef3a5cda5ff6b0015d49c303eec93e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ODU0Mzk1Y2FlZjNhNWNkYTVmZjZiMDAxNWQ0OWMzMDNlZWM5M2U=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-15T09:15:02Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-26T23:23:07Z"}, "message": "Introduce `CfgFolder` trait", "tree": {"sha": "c4303bfcb98ab975be2d0458bd00bb94af577d92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4303bfcb98ab975be2d0458bd00bb94af577d92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79854395caef3a5cda5ff6b0015d49c303eec93e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79854395caef3a5cda5ff6b0015d49c303eec93e", "html_url": "https://github.com/rust-lang/rust/commit/79854395caef3a5cda5ff6b0015d49c303eec93e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79854395caef3a5cda5ff6b0015d49c303eec93e/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a42e46eec5590314b64bb82027a22d66545e627", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a42e46eec5590314b64bb82027a22d66545e627", "html_url": "https://github.com/rust-lang/rust/commit/7a42e46eec5590314b64bb82027a22d66545e627"}], "stats": {"total": 51, "additions": 32, "deletions": 19}, "files": [{"sha": "54f3feee96ca78b998a9c8dfa48c26974cbebeeb", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 32, "deletions": 19, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/79854395caef3a5cda5ff6b0015d49c303eec93e/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79854395caef3a5cda5ff6b0015d49c303eec93e/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=79854395caef3a5cda5ff6b0015d49c303eec93e", "patch": "@@ -19,13 +19,31 @@ use ptr::P;\n \n use util::small_vector::SmallVector;\n \n+pub trait CfgFolder: fold::Folder {\n+    fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool;\n+    fn visit_unconfigurable_expr(&mut self, _expr: &ast::Expr) {}\n+}\n+\n /// A folder that strips out items that do not belong in the current\n /// configuration.\n struct Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n     in_cfg: F,\n     diagnostic: &'a Handler,\n }\n \n+impl<'a, F: FnMut(&[ast::Attribute]) -> bool> CfgFolder for Context<'a, F> {\n+    fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool {\n+        (self.in_cfg)(attrs)\n+    }\n+\n+    fn visit_unconfigurable_expr(&mut self, expr: &ast::Expr) {\n+        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n+            let msg = \"removing an expression is not supported in this position\";\n+            self.diagnostic.span_err(attr.span, msg);\n+        }\n+    }\n+}\n+\n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n pub fn strip_unconfigured_items(diagnostic: &Handler, krate: ast::Crate,\n@@ -48,12 +66,12 @@ pub fn strip_unconfigured_items(diagnostic: &Handler, krate: ast::Crate,\n                 })\n }\n \n-impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n+impl<T: CfgFolder> fold::Folder for T {\n     fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         ast::ForeignMod {\n             abi: foreign_mod.abi,\n             items: foreign_mod.items.into_iter().filter(|item| {\n-                (self.in_cfg)(&item.attrs)\n+                self.in_cfg(&item.attrs)\n             }).collect(),\n         }\n     }\n@@ -62,12 +80,12 @@ impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) ->\n         let fold_struct = |this: &mut Self, vdata| match vdata {\n             ast::VariantData::Struct(fields, id) => {\n                 ast::VariantData::Struct(fields.into_iter().filter(|m| {\n-                    (this.in_cfg)(&m.attrs)\n+                    this.in_cfg(&m.attrs)\n                 }).collect(), id)\n             }\n             ast::VariantData::Tuple(fields, id) => {\n                 ast::VariantData::Tuple(fields.into_iter().filter(|m| {\n-                    (this.in_cfg)(&m.attrs)\n+                    this.in_cfg(&m.attrs)\n                 }).collect(), id)\n             }\n             ast::VariantData::Unit(id) => ast::VariantData::Unit(id)\n@@ -76,13 +94,13 @@ impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) ->\n         let item = match item {\n             ast::ItemKind::Impl(u, o, a, b, c, impl_items) => {\n                 let impl_items = impl_items.into_iter()\n-                                           .filter(|ii| (self.in_cfg)(&ii.attrs))\n+                                           .filter(|ii| self.in_cfg(&ii.attrs))\n                                            .collect();\n                 ast::ItemKind::Impl(u, o, a, b, c, impl_items)\n             }\n             ast::ItemKind::Trait(u, a, b, methods) => {\n                 let methods = methods.into_iter()\n-                                     .filter(|ti| (self.in_cfg)(&ti.attrs))\n+                                     .filter(|ti| self.in_cfg(&ti.attrs))\n                                      .collect();\n                 ast::ItemKind::Trait(u, a, b, methods)\n             }\n@@ -91,7 +109,7 @@ impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) ->\n             }\n             ast::ItemKind::Enum(def, generics) => {\n                 let variants = def.variants.into_iter().filter_map(|v| {\n-                    if !(self.in_cfg)(&v.node.attrs) {\n+                    if !self.in_cfg(&v.node.attrs) {\n                         None\n                     } else {\n                         Some(Spanned {\n@@ -123,23 +141,20 @@ impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) ->\n         //\n         // NB: This is intentionally not part of the fold_expr() function\n         //     in order for fold_opt_expr() to be able to avoid this check\n-        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n-            self.diagnostic.span_err(attr.span,\n-                \"removing an expression is not supported in this position\");\n-        }\n+        self.visit_unconfigurable_expr(&expr);\n         fold_expr(self, expr)\n     }\n \n     fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        if (self.in_cfg)(expr.attrs()) {\n+        if self.in_cfg(expr.attrs()) {\n             Some(fold_expr(self, expr))\n         } else {\n             None\n         }\n     }\n \n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n-        if (self.in_cfg)(stmt.node.attrs()) {\n+        if self.in_cfg(stmt.node.attrs()) {\n             fold::noop_fold_stmt(stmt, self)\n         } else {\n             SmallVector::zero()\n@@ -151,7 +166,7 @@ impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) ->\n     }\n \n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        if (self.in_cfg)(&item.attrs) {\n+        if self.in_cfg(&item.attrs) {\n             SmallVector::one(item.map(|i| self.fold_item_simple(i)))\n         } else {\n             SmallVector::zero()\n@@ -170,23 +185,21 @@ pub fn strip_items<'a, F>(diagnostic: &'a Handler,\n     ctxt.fold_crate(krate)\n }\n \n-fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n+fn fold_expr<F: CfgFolder>(folder: &mut F, expr: P<ast::Expr>) -> P<ast::Expr> {\n     expr.map(|ast::Expr {id, span, node, attrs}| {\n         fold::noop_fold_expr(ast::Expr {\n             id: id,\n             node: match node {\n                 ast::ExprKind::Match(m, arms) => {\n                     ast::ExprKind::Match(m, arms.into_iter()\n-                                        .filter(|a| (cx.in_cfg)(&a.attrs))\n+                                        .filter(|a| folder.in_cfg(&a.attrs))\n                                         .collect())\n                 }\n                 _ => node\n             },\n             span: span,\n             attrs: attrs,\n-        }, cx)\n+        }, folder)\n     })\n }\n "}]}