{"sha": "52a31f7a00095d99a1f56542f093b92d78ba1be3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYTMxZjdhMDAwOTVkOTlhMWY1NjU0MmYwOTNiOTJkNzhiYTFiZTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-10-19T11:47:32Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-10-19T11:47:32Z"}, "message": "some more Rc tweaks", "tree": {"sha": "ebcf580fbc2208fee2dbbb8c3e4f4f917660ac2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebcf580fbc2208fee2dbbb8c3e4f4f917660ac2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52a31f7a00095d99a1f56542f093b92d78ba1be3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52a31f7a00095d99a1f56542f093b92d78ba1be3", "html_url": "https://github.com/rust-lang/rust/commit/52a31f7a00095d99a1f56542f093b92d78ba1be3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52a31f7a00095d99a1f56542f093b92d78ba1be3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "696cba6e25fc7a8ee90e4db00f4df89dfe963d8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/696cba6e25fc7a8ee90e4db00f4df89dfe963d8e", "html_url": "https://github.com/rust-lang/rust/commit/696cba6e25fc7a8ee90e4db00f4df89dfe963d8e"}], "stats": {"total": 22, "additions": 12, "deletions": 10}, "files": [{"sha": "f1c4c32e116ea74dcc59bec6eb349841517662b4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/52a31f7a00095d99a1f56542f093b92d78ba1be3/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52a31f7a00095d99a1f56542f093b92d78ba1be3/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=52a31f7a00095d99a1f56542f093b92d78ba1be3", "patch": "@@ -25,7 +25,7 @@\n //! to an [`Rc`], but this will return [`None`] if the value stored in the allocation has\n //! already been dropped. In other words, `Weak` pointers do not keep the value\n //! inside the allocation alive; however, they *do* keep the allocation\n-//! (the backing store for the value) alive.\n+//! (the backing store for the inner value) alive.\n //!\n //! A cycle between [`Rc`] pointers will never be deallocated. For this reason,\n //! [`Weak`] is used to break cycles. For example, a tree could have strong\n@@ -44,8 +44,8 @@\n //! Rc::downgrade(&my_rc);\n //! ```\n //!\n-//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the allocation may have\n-//! already been destroyed.\n+//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the inner value may have\n+//! already been dropped.\n //!\n //! # Cloning references\n //!\n@@ -449,7 +449,7 @@ impl<T> Rc<mem::MaybeUninit<T>> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -488,7 +488,7 @@ impl<T> Rc<[mem::MaybeUninit<T>]> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -883,7 +883,7 @@ impl Rc<dyn Any> {\n \n impl<T: ?Sized> Rc<T> {\n     /// Allocates an `RcBox<T>` with sufficient space for\n-    /// a possibly-unsized value where the value has the layout provided.\n+    /// a possibly-unsized inner value where the value has the layout provided.\n     ///\n     /// The function `mem_to_rcbox` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n@@ -913,7 +913,7 @@ impl<T: ?Sized> Rc<T> {\n         inner\n     }\n \n-    /// Allocates an `RcBox<T>` with sufficient space for an unsized value\n+    /// Allocates an `RcBox<T>` with sufficient space for an unsized inner value\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n         Self::allocate_for_layout(\n@@ -1177,6 +1177,8 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n /// store large values, that are slow to clone, but also heavy to check for equality, causing this\n /// cost to pay off more easily. It's also more likely to have two `Rc` clones, that point to\n /// the same value, than two `&T`s.\n+///\n+/// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n     #[inline]\n@@ -1759,10 +1761,10 @@ pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Attempts to upgrade the `Weak` pointer to an [`Rc`], extending\n-    /// the lifetime of the allocation if successful.\n+    /// Attempts to upgrade the `Weak` pointer to an [`Rc`], delaying\n+    /// dropping of the inner value if successful.\n     ///\n-    /// Returns [`None`] if the value stored in the allocation has since been dropped.\n+    /// Returns [`None`] if the inner value has since been dropped.\n     ///\n     /// [`Rc`]: struct.Rc.html\n     /// [`None`]: ../../std/option/enum.Option.html"}]}