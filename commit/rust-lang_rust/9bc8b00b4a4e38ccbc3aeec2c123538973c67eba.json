{"sha": "9bc8b00b4a4e38ccbc3aeec2c123538973c67eba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYzhiMDBiNGE0ZTM4Y2NiYzNhZWVjMmMxMjM1Mzg5NzNjNjdlYmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-13T17:48:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-13T17:48:41Z"}, "message": "Auto merge of #80718 - tmiasko:skip-opt-mir, r=oli-obk\n\nConsistently avoid constructing optimized MIR when not doing codegen\n\nThe optimized MIR for closures is being encoded unconditionally, while\nbeing unnecessary for cargo check. This turns out to be especially\ncostly with MIR inlining enabled, since it triggers computation of\noptimized MIR for all callees that are being examined for inlining\npurposes https://github.com/rust-lang/rust/pull/77307#issuecomment-751915450.\n\nSkip encoding of optimized MIR for closures, enum constructors, struct\nconstructors, and trait fns when not doing codegen, like it is already\ndone for other items since 49433.", "tree": {"sha": "d18339eb142ba6c65939963d157f9db45e72ae37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d18339eb142ba6c65939963d157f9db45e72ae37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bc8b00b4a4e38ccbc3aeec2c123538973c67eba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bc8b00b4a4e38ccbc3aeec2c123538973c67eba", "html_url": "https://github.com/rust-lang/rust/commit/9bc8b00b4a4e38ccbc3aeec2c123538973c67eba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bc8b00b4a4e38ccbc3aeec2c123538973c67eba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd2df74902fa98bcb71f85fd548c3eb399e6a96a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd2df74902fa98bcb71f85fd548c3eb399e6a96a", "html_url": "https://github.com/rust-lang/rust/commit/fd2df74902fa98bcb71f85fd548c3eb399e6a96a"}, {"sha": "16857317a6fb5bc966a0840c21d8000c2cd052ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/16857317a6fb5bc966a0840c21d8000c2cd052ca", "html_url": "https://github.com/rust-lang/rust/commit/16857317a6fb5bc966a0840c21d8000c2cd052ca"}], "stats": {"total": 71, "additions": 39, "deletions": 32}, "files": [{"sha": "d8d222dccf4ead7700d4ee8d7df2ed87d3d0d2bc", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9bc8b00b4a4e38ccbc3aeec2c123538973c67eba/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc8b00b4a4e38ccbc3aeec2c123538973c67eba/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=9bc8b00b4a4e38ccbc3aeec2c123538973c67eba", "patch": "@@ -66,6 +66,11 @@ pub(super) struct EncodeContext<'a, 'tcx> {\n     required_source_files: Option<GrowableBitSet<usize>>,\n     is_proc_macro: bool,\n     hygiene_ctxt: &'a HygieneEncodeContext,\n+\n+    // Determines if MIR used for code generation will be included in the crate\n+    // metadata. When emitting only metadata (e.g., cargo check), we can avoid\n+    // generating optimized MIR altogether.\n+    emit_codegen_mir: bool,\n }\n \n /// If the current crate is a proc-macro, returns early with `Lazy:empty()`.\n@@ -787,9 +792,11 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_generics(def_id);\n         self.encode_explicit_predicates(def_id);\n         self.encode_inferred_outlives(def_id);\n+        let opt_mir = tcx.sess.opts.debugging_opts.always_encode_mir || self.emit_codegen_mir;\n+        if opt_mir {\n+            self.encode_optimized_mir(def_id.expect_local());\n+        }\n         self.encode_mir_for_ctfe(def_id.expect_local());\n-        self.encode_optimized_mir(def_id.expect_local());\n-        self.encode_promoted_mir(def_id.expect_local());\n     }\n \n     fn encode_info_for_mod(&mut self, id: hir::HirId, md: &hir::Mod<'_>, attrs: &[ast::Attribute]) {\n@@ -895,9 +902,11 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_generics(def_id);\n         self.encode_explicit_predicates(def_id);\n         self.encode_inferred_outlives(def_id);\n-        self.encode_optimized_mir(def_id.expect_local());\n+        let opt_mir = tcx.sess.opts.debugging_opts.always_encode_mir || self.emit_codegen_mir;\n+        if opt_mir {\n+            self.encode_optimized_mir(def_id.expect_local());\n+        }\n         self.encode_mir_for_ctfe(def_id.expect_local());\n-        self.encode_promoted_mir(def_id.expect_local());\n     }\n \n     fn encode_generics(&mut self, def_id: DefId) {\n@@ -1024,17 +1033,23 @@ impl EncodeContext<'a, 'tcx> {\n                 }\n             }\n             ty::AssocKind::Fn => {\n-                if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id.expect_local()) {\n-                    self.encode_optimized_mir(def_id.expect_local());\n-                    self.encode_promoted_mir(def_id.expect_local());\n+                let opt_mir =\n+                    tcx.sess.opts.debugging_opts.always_encode_mir || self.emit_codegen_mir;\n+                if opt_mir {\n+                    if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id.expect_local()) {\n+                        self.encode_optimized_mir(def_id.expect_local());\n+                        self.encode_promoted_mir(def_id.expect_local());\n+                    }\n                 }\n             }\n         }\n     }\n \n-    fn metadata_output_only(&self) -> bool {\n-        // MIR optimisation can be skipped when we're just interested in the metadata.\n-        !self.tcx.sess.opts.output_types.should_codegen()\n+    fn should_encode_fn_opt_mir(&self, def_id: DefId) -> bool {\n+        self.tcx.sess.opts.debugging_opts.always_encode_mir\n+            || (self.emit_codegen_mir\n+                && (self.tcx.generics_of(def_id).requires_monomorphization(self.tcx)\n+                    || self.tcx.codegen_fn_attrs(def_id).requests_inline()))\n     }\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) {\n@@ -1105,13 +1120,9 @@ impl EncodeContext<'a, 'tcx> {\n         let (mir, mir_const) = match ast_item.kind {\n             hir::ImplItemKind::Const(..) => (false, true),\n             hir::ImplItemKind::Fn(ref sig, _) => {\n-                let generics = self.tcx.generics_of(def_id);\n-                let needs_inline = (generics.requires_monomorphization(self.tcx)\n-                    || tcx.codegen_fn_attrs(def_id).requests_inline())\n-                    && !self.metadata_output_only();\n+                let opt_mir = self.should_encode_fn_opt_mir(def_id);\n                 let is_const_fn = sig.header.constness == hir::Constness::Const;\n-                let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n-                (needs_inline || always_encode_mir, is_const_fn)\n+                (opt_mir, is_const_fn)\n             }\n             hir::ImplItemKind::TyAlias(..) => (false, false),\n         };\n@@ -1433,16 +1444,10 @@ impl EncodeContext<'a, 'tcx> {\n         let (mir, const_mir) = match item.kind {\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => (false, true),\n             hir::ItemKind::Fn(ref sig, ..) => {\n-                let generics = tcx.generics_of(def_id);\n-                let needs_inline = (generics.requires_monomorphization(tcx)\n-                    || tcx.codegen_fn_attrs(def_id).requests_inline())\n-                    && !self.metadata_output_only();\n-\n+                let opt_mir = self.should_encode_fn_opt_mir(def_id);\n                 let is_const_fn = sig.header.constness == hir::Constness::Const;\n-                let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n-                let mir = needs_inline || always_encode_mir;\n                 // We don't need the optimized MIR for const fns.\n-                (mir, is_const_fn)\n+                (opt_mir, is_const_fn)\n             }\n             _ => (false, false),\n         };\n@@ -1502,8 +1507,11 @@ impl EncodeContext<'a, 'tcx> {\n             record!(self.tables.fn_sig[def_id] <- substs.as_closure().sig());\n         }\n         self.encode_generics(def_id.to_def_id());\n-        self.encode_optimized_mir(def_id);\n-        self.encode_promoted_mir(def_id);\n+        let opt_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir || self.emit_codegen_mir;\n+        if opt_mir {\n+            self.encode_optimized_mir(def_id);\n+            self.encode_promoted_mir(def_id);\n+        }\n     }\n \n     fn encode_info_for_anon_const(&mut self, def_id: LocalDefId) {\n@@ -2008,10 +2016,9 @@ impl<'tcx, 'v> ParItemLikeVisitor<'v> for PrefetchVisitor<'tcx> {\n             }\n             hir::ItemKind::Fn(ref sig, ..) => {\n                 let def_id = tcx.hir().local_def_id(item.hir_id);\n-                let generics = tcx.generics_of(def_id.to_def_id());\n-                let needs_inline = generics.requires_monomorphization(tcx)\n+                let opt_mir = tcx.generics_of(def_id.to_def_id()).requires_monomorphization(tcx)\n                     || tcx.codegen_fn_attrs(def_id.to_def_id()).requests_inline();\n-                if needs_inline {\n+                if opt_mir {\n                     self.prefetch_mir(def_id)\n                 }\n                 if sig.header.constness == hir::Constness::Const {\n@@ -2045,11 +2052,10 @@ impl<'tcx, 'v> ParItemLikeVisitor<'v> for PrefetchVisitor<'tcx> {\n             }\n             hir::ImplItemKind::Fn(ref sig, _) => {\n                 let def_id = tcx.hir().local_def_id(impl_item.hir_id);\n-                let generics = tcx.generics_of(def_id.to_def_id());\n-                let needs_inline = generics.requires_monomorphization(tcx)\n+                let opt_mir = tcx.generics_of(def_id.to_def_id()).requires_monomorphization(tcx)\n                     || tcx.codegen_fn_attrs(def_id.to_def_id()).requests_inline();\n                 let is_const_fn = sig.header.constness == hir::Constness::Const;\n-                if needs_inline {\n+                if opt_mir {\n                     self.prefetch_mir(def_id)\n                 }\n                 if is_const_fn {\n@@ -2148,6 +2154,7 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n         required_source_files,\n         is_proc_macro: tcx.sess.crate_types().contains(&CrateType::ProcMacro),\n         hygiene_ctxt: &hygiene_ctxt,\n+        emit_codegen_mir: tcx.sess.opts.output_types.should_codegen(),\n     };\n \n     // Encode the rustc version string in a predictable location."}]}