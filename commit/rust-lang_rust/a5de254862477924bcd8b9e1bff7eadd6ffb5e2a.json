{"sha": "a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZGUyNTQ4NjI0Nzc5MjRiY2Q4YjllMWJmZjdlYWRkNmZmYjVlMmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-03T10:18:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-03T10:18:57Z"}, "message": "Auto merge of #69666 - JohnTitor:rollup-6nt3op0, r=JohnTitor\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #69213 (Improve documentation on iterators length)\n - #69609 (Remove `usable_size` APIs)\n - #69619 (more cleanups)\n - #69620 (doc(librustc_error_codes): add long error explanation for E0719)\n - #69626 (Toolstate: don't duplicate nightly tool list.)\n - #69628 (Fix a leak in `DiagnosticBuilder::into_diagnostic`.)\n - #69633 (Update my mailmap entry)\n - #69634 (clean up E0378 explanation)\n - #69637 (Don't convert Results to Options just for matching.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "6d30e786044c654a5478545b69a9f8792e856655", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d30e786044c654a5478545b69a9f8792e856655"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "html_url": "https://github.com/rust-lang/rust/commit/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9381e8178b49636d4604e4ec0f1263960691c958", "url": "https://api.github.com/repos/rust-lang/rust/commits/9381e8178b49636d4604e4ec0f1263960691c958", "html_url": "https://github.com/rust-lang/rust/commit/9381e8178b49636d4604e4ec0f1263960691c958"}, {"sha": "e453a0cc49ad83fbb54fb22f9bba7545f5a92c68", "url": "https://api.github.com/repos/rust-lang/rust/commits/e453a0cc49ad83fbb54fb22f9bba7545f5a92c68", "html_url": "https://github.com/rust-lang/rust/commit/e453a0cc49ad83fbb54fb22f9bba7545f5a92c68"}], "stats": {"total": 546, "additions": 225, "deletions": 321}, "files": [{"sha": "ea8ef0eebf9a1141a1b0154209b98f81cab197f3", "filename": ".mailmap", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -5,7 +5,6 @@\n # email addresses.\n #\n \n-Aaron Power <theaaronepower@gmail.com> Erin Power <xampprocky@gmail.com>\n Aaron Todd <github@opprobrio.us>\n Abhishek Chanda <abhishek.becs@gmail.com> Abhishek Chanda <abhishek@cloudscaling.com>\n Adolfo Ochagav\u00eda <aochagavia92@gmail.com>\n@@ -84,6 +83,8 @@ Eric Holk <eric.holk@gmail.com> <eholk@mozilla.com>\n Eric Holmes <eric@ejholmes.net>\n Eric Reed <ecreed@cs.washington.edu> <ereed@mozilla.com>\n Erick Tryzelaar <erick.tryzelaar@gmail.com> <etryzelaar@iqt.org>\n+Erin Power <xampprocky@gmail.com> <theaaronepower@gmail.com>\n+Erin Power <xampprocky@gmail.com> <Aaronepower@users.noreply.github.com>\n Esteban K\u00fcber <esteban@kuber.com.ar> <esteban@commure.com>\n Esteban K\u00fcber <esteban@kuber.com.ar> <estebank@users.noreply.github.com>\n Esteban K\u00fcber <esteban@kuber.com.ar> <github@kuber.com.ar>"}, {"sha": "7cffc472930700e59afe34c07001d6b39a669220", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -443,7 +443,7 @@ fn change_toolstate(\n         if new_state != state {\n             eprintln!(\"The state of `{}` has changed from `{}` to `{}`\", tool, state, new_state);\n             if new_state < state {\n-                if ![\"rustc-guide\", \"miri\", \"embedded-book\"].contains(&tool.as_str()) {\n+                if !NIGHTLY_TOOLS.iter().any(|(name, _path)| name == tool) {\n                     regressed = true;\n                 }\n             }"}, {"sha": "73e8121868aba67ea7b38da5affec03f34ea0e50", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -165,8 +165,8 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(alloc(layout)).ok_or(AllocErr)\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        NonNull::new(alloc(layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n     }\n \n     #[inline]\n@@ -180,13 +180,13 @@ unsafe impl AllocRef for Global {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(realloc(ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n+    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        NonNull::new(realloc(ptr.as_ptr(), layout, new_size)).ok_or(AllocErr).map(|p| (p, new_size))\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr)\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n     }\n }\n \n@@ -201,7 +201,7 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     } else {\n         let layout = Layout::from_size_align_unchecked(size, align);\n         match Global.alloc(layout) {\n-            Ok(ptr) => ptr.as_ptr(),\n+            Ok((ptr, _)) => ptr.as_ptr(),\n             Err(_) => handle_alloc_error(layout),\n         }\n     }"}, {"sha": "55944398e16772b65b7533d7722b220be6ebf22c", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -8,7 +8,7 @@ use test::Bencher;\n fn allocate_zeroed() {\n     unsafe {\n         let layout = Layout::from_size_align(1024, 1).unwrap();\n-        let ptr =\n+        let (ptr, _) =\n             Global.alloc_zeroed(layout.clone()).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         let mut i = ptr.cast::<u8>().as_ptr();"}, {"sha": "9a7d0d9aebaafcf68742bfdebcce238a1dc272d7", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -200,7 +200,7 @@ impl<T> Box<T> {\n             let ptr = if layout.size() == 0 {\n                 NonNull::dangling()\n             } else {\n-                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).cast()\n+                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).0.cast()\n             };\n             Box::from_raw(ptr.as_ptr())\n         }\n@@ -270,7 +270,7 @@ impl<T> Box<[T]> {\n             let ptr = if layout.size() == 0 {\n                 NonNull::dangling()\n             } else {\n-                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).cast()\n+                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).0.cast()\n             };\n             Box::from_raw(slice::from_raw_parts_mut(ptr.as_ptr(), len))\n         }"}, {"sha": "345834d7daacc3a499374bbee8dc9eb80a0f889c", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -72,7 +72,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         RawVec::allocate_in(capacity, true, a)\n     }\n \n-    fn allocate_in(capacity: usize, zeroed: bool, mut a: A) -> Self {\n+    fn allocate_in(mut capacity: usize, zeroed: bool, mut a: A) -> Self {\n         unsafe {\n             let elem_size = mem::size_of::<T>();\n \n@@ -87,7 +87,10 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                 let layout = Layout::from_size_align(alloc_size, align).unwrap();\n                 let result = if zeroed { a.alloc_zeroed(layout) } else { a.alloc(layout) };\n                 match result {\n-                    Ok(ptr) => ptr.cast(),\n+                    Ok((ptr, size)) => {\n+                        capacity = size / elem_size;\n+                        ptr.cast()\n+                    }\n                     Err(_) => handle_alloc_error(layout),\n                 }\n             };\n@@ -280,7 +283,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            let (new_cap, ptr) = match self.current_layout() {\n+            let (ptr, new_cap) = match self.current_layout() {\n                 Some(cur) => {\n                     // Since we guarantee that we never allocate more than\n                     // `isize::MAX` bytes, `elem_size * self.cap <= isize::MAX` as\n@@ -297,7 +300,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                     alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n                     let ptr_res = self.a.realloc(NonNull::from(self.ptr).cast(), cur, new_size);\n                     match ptr_res {\n-                        Ok(ptr) => (new_cap, ptr),\n+                        Ok((ptr, new_size)) => (ptr, new_size / elem_size),\n                         Err(_) => handle_alloc_error(Layout::from_size_align_unchecked(\n                             new_size,\n                             cur.align(),\n@@ -310,7 +313,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                     let layout = Layout::array::<T>(new_cap).unwrap();\n                     match self.a.alloc(layout) {\n-                        Ok(ptr) => (new_cap, ptr),\n+                        Ok((ptr, new_size)) => (ptr, new_size / elem_size),\n                         Err(_) => handle_alloc_error(layout),\n                     }\n                 }\n@@ -598,7 +601,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                 let align = mem::align_of::<T>();\n                 let old_layout = Layout::from_size_align_unchecked(old_size, align);\n                 match self.a.realloc(NonNull::from(self.ptr).cast(), old_layout, new_size) {\n-                    Ok(p) => self.ptr = p.cast().into(),\n+                    Ok((ptr, _)) => self.ptr = ptr.cast().into(),\n                     Err(_) => {\n                         handle_alloc_error(Layout::from_size_align_unchecked(new_size, align))\n                     }\n@@ -631,6 +634,8 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         fallibility: Fallibility,\n         strategy: ReserveStrategy,\n     ) -> Result<(), TryReserveError> {\n+        let elem_size = mem::size_of::<T>();\n+\n         unsafe {\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n@@ -662,15 +667,15 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                 None => self.a.alloc(new_layout),\n             };\n \n-            let ptr = match (res, fallibility) {\n+            let (ptr, new_cap) = match (res, fallibility) {\n                 (Err(AllocErr), Infallible) => handle_alloc_error(new_layout),\n                 (Err(AllocErr), Fallible) => {\n                     return Err(TryReserveError::AllocError {\n                         layout: new_layout,\n                         non_exhaustive: (),\n                     });\n                 }\n-                (Ok(ptr), _) => ptr,\n+                (Ok((ptr, new_size)), _) => (ptr, new_size / elem_size),\n             };\n \n             self.ptr = ptr.cast().into();"}, {"sha": "860058debe1fda3588b6eb92e9fe141e7d9eafce", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -20,7 +20,7 @@ fn allocator_param() {\n         fuel: usize,\n     }\n     unsafe impl AllocRef for BoundedAlloc {\n-        unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+        unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {\n                 return Err(AllocErr);"}, {"sha": "9c286298aa65cd908d20eb4348bef33fa86d5102", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -923,7 +923,7 @@ impl<T: ?Sized> Rc<T> {\n         let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n         // Allocate for the layout.\n-        let mem = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let (mem, _) = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n         let inner = mem_to_rcbox(mem.as_ptr());"}, {"sha": "4a0cf2984edd93740ca1c3e7bd135e89ab5e53ac", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -784,7 +784,7 @@ impl<T: ?Sized> Arc<T> {\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n-        let mem = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let (mem, _) = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n         let inner = mem_to_arcinner(mem.as_ptr());"}, {"sha": "d159126f426c52070b7290f0025dfe191d093c75", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -20,7 +20,7 @@ fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n             unsafe {\n                 let pointers: Vec<_> = (0..iterations)\n                     .map(|_| {\n-                        allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n+                        allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap().0\n                     })\n                     .collect();\n                 for &ptr in &pointers {"}, {"sha": "f3a2b73f2b8de92d3d6299ec0db48c853d2ec3db", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 80, "deletions": 224, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -11,12 +11,6 @@ use crate::num::NonZeroUsize;\n use crate::ptr::{self, NonNull};\n use crate::usize;\n \n-/// Represents the combination of a starting address and\n-/// a total capacity of the returned block.\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[derive(Debug)]\n-pub struct Excess(pub NonNull<u8>, pub usize);\n-\n const fn size_align<T>() -> (usize, usize) {\n     (mem::size_of::<T>(), mem::align_of::<T>())\n }\n@@ -593,13 +587,12 @@ pub unsafe trait GlobalAlloc {\n ///\n /// * the starting address for that memory block was previously\n ///   returned by a previous call to an allocation method (`alloc`,\n-///   `alloc_zeroed`, `alloc_excess`) or reallocation method\n-///   (`realloc`, `realloc_excess`), and\n+///   `alloc_zeroed`) or reallocation method (`realloc`), and\n ///\n /// * the memory block has not been subsequently deallocated, where\n ///   blocks are deallocated either by being passed to a deallocation\n-///   method (`dealloc`, `dealloc_one`, `dealloc_array`) or by being\n-///   passed to a reallocation method (see above) that returns `Ok`.\n+///   method (`dealloc`) or by being passed to a reallocation method\n+///  (see above) that returns `Ok`.\n ///\n /// A note regarding zero-sized types and zero-sized layouts: many\n /// methods in the `AllocRef` trait state that allocation requests\n@@ -625,11 +618,9 @@ pub unsafe trait GlobalAlloc {\n ///\n /// 2. The block's size must fall in the range `[use_min, use_max]`, where:\n ///\n-///    * `use_min` is `self.usable_size(layout).0`, and\n+///    * `use_min` is `layout.size()`, and\n ///\n-///    * `use_max` is the capacity that was (or would have been)\n-///      returned when (if) the block was allocated via a call to\n-///      `alloc_excess` or `realloc_excess`.\n+///    * `use_max` is the capacity that was returned.\n ///\n /// Note that:\n ///\n@@ -643,6 +634,9 @@ pub unsafe trait GlobalAlloc {\n ///    currently allocated via an allocator `a`, then it is legal to\n ///    use that layout to deallocate it, i.e., `a.dealloc(ptr, k);`.\n ///\n+///  * if an allocator does not support overallocating, it is fine to\n+///    simply return `layout.size()` as the allocated size.\n+///\n /// # Safety\n ///\n /// The `AllocRef` trait is an `unsafe` trait for a number of reasons, and\n@@ -671,8 +665,9 @@ pub unsafe trait AllocRef {\n     // However in jemalloc for example,\n     // `mallocx(0)` is documented as undefined behavior.)\n \n-    /// Returns a pointer meeting the size and alignment guarantees of\n-    /// `layout`.\n+    /// On success, returns a pointer meeting the size and alignment\n+    /// guarantees of `layout` and the actual size of the allocated block,\n+    /// which must be greater than or equal to `layout.size()`.\n     ///\n     /// If this method returns an `Ok(addr)`, then the `addr` returned\n     /// will be non-null address pointing to a block of storage\n@@ -709,7 +704,7 @@ pub unsafe trait AllocRef {\n     /// rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr>;\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr>;\n \n     /// Deallocate the memory referenced by `ptr`.\n     ///\n@@ -728,48 +723,42 @@ pub unsafe trait AllocRef {\n     ///   to allocate that block of memory.\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n \n-    // == ALLOCATOR-SPECIFIC QUANTITIES AND LIMITS ==\n-    // usable_size\n-\n-    /// Returns bounds on the guaranteed usable size of a successful\n-    /// allocation created with the specified `layout`.\n-    ///\n-    /// In particular, if one has a memory block allocated via a given\n-    /// allocator `a` and layout `k` where `a.usable_size(k)` returns\n-    /// `(l, u)`, then one can pass that block to `a.dealloc()` with a\n-    /// layout in the size range [l, u].\n-    ///\n-    /// (All implementors of `usable_size` must ensure that\n-    /// `l <= k.size() <= u`)\n-    ///\n-    /// Both the lower- and upper-bounds (`l` and `u` respectively)\n-    /// are provided, because an allocator based on size classes could\n-    /// misbehave if one attempts to deallocate a block without\n-    /// providing a correct value for its size (i.e., one within the\n-    /// range `[l, u]`).\n-    ///\n-    /// Clients who wish to make use of excess capacity are encouraged\n-    /// to use the `alloc_excess` and `realloc_excess` instead, as\n-    /// this method is constrained to report conservative values that\n-    /// serve as valid bounds for *all possible* allocation method\n-    /// calls.\n-    ///\n-    /// However, for clients that do not wish to track the capacity\n-    /// returned by `alloc_excess` locally, this method is likely to\n-    /// produce useful results.\n-    #[inline]\n-    fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n-        (layout.size(), layout.size())\n+    /// Behaves like `alloc`, but also ensures that the contents\n+    /// are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `alloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `alloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        let size = layout.size();\n+        let result = self.alloc(layout);\n+        if let Ok((p, _)) = result {\n+            ptr::write_bytes(p.as_ptr(), 0, size);\n+        }\n+        result\n     }\n \n     // == METHODS FOR MEMORY REUSE ==\n     // realloc. alloc_excess, realloc_excess\n \n     /// Returns a pointer suitable for holding data described by\n     /// a new layout with `layout`\u2019s alignment and a size given\n-    /// by `new_size`. To\n-    /// accomplish this, this may extend or shrink the allocation\n-    /// referenced by `ptr` to fit the new layout.\n+    /// by `new_size` and the actual size of the allocated block.\n+    /// The latter is greater than or equal to `layout.size()`.\n+    /// To accomplish this, the allocator may extend or shrink\n+    /// the allocation referenced by `ptr` to fit the new layout.\n     ///\n     /// If this returns `Ok`, then ownership of the memory block\n     /// referenced by `ptr` has been transferred to this\n@@ -824,23 +813,25 @@ pub unsafe trait AllocRef {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<NonNull<u8>, AllocErr> {\n+    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n         let old_size = layout.size();\n \n-        if new_size >= old_size {\n-            if let Ok(()) = self.grow_in_place(ptr, layout, new_size) {\n-                return Ok(ptr);\n+        if new_size > old_size {\n+            if let Ok(size) = self.grow_in_place(ptr, layout, new_size) {\n+                return Ok((ptr, size));\n             }\n         } else if new_size < old_size {\n-            if let Ok(()) = self.shrink_in_place(ptr, layout, new_size) {\n-                return Ok(ptr);\n+            if let Ok(size) = self.shrink_in_place(ptr, layout, new_size) {\n+                return Ok((ptr, size));\n             }\n+        } else {\n+            return Ok((ptr, new_size));\n         }\n \n         // otherwise, fall back on alloc + copy + dealloc.\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let result = self.alloc(new_layout);\n-        if let Ok(new_ptr) = result {\n+        if let Ok((new_ptr, _)) = result {\n             ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), cmp::min(old_size, new_size));\n             self.dealloc(ptr, layout);\n         }\n@@ -877,174 +868,40 @@ pub unsafe trait AllocRef {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<NonNull<u8>, AllocErr> {\n+    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n         let old_size = layout.size();\n \n-        if new_size >= old_size {\n-            if let Ok(()) = self.grow_in_place_zeroed(ptr, layout, new_size) {\n-                return Ok(ptr);\n+        if new_size > old_size {\n+            if let Ok(size) = self.grow_in_place_zeroed(ptr, layout, new_size) {\n+                return Ok((ptr, size));\n             }\n         } else if new_size < old_size {\n-            if let Ok(()) = self.shrink_in_place(ptr, layout, new_size) {\n-                return Ok(ptr);\n+            if let Ok(size) = self.shrink_in_place(ptr, layout, new_size) {\n+                return Ok((ptr, size));\n             }\n+        } else {\n+            return Ok((ptr, new_size));\n         }\n \n         // otherwise, fall back on alloc + copy + dealloc.\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let result = self.alloc_zeroed(new_layout);\n-        if let Ok(new_ptr) = result {\n+        if let Ok((new_ptr, _)) = result {\n             ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), cmp::min(old_size, new_size));\n             self.dealloc(ptr, layout);\n         }\n         result\n     }\n \n-    /// Behaves like `alloc`, but also ensures that the contents\n-    /// are set to zero before being returned.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `alloc` is.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `layout` does not meet allocator's size or alignment\n-    /// constraints, just as in `alloc`.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-        let size = layout.size();\n-        let p = self.alloc(layout);\n-        if let Ok(p) = p {\n-            ptr::write_bytes(p.as_ptr(), 0, size);\n-        }\n-        p\n-    }\n-\n-    /// Behaves like `alloc`, but also returns the whole size of\n-    /// the returned block. For some `layout` inputs, like arrays, this\n-    /// may include extra storage usable for additional data.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `alloc` is.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `layout` does not meet allocator's size or alignment\n-    /// constraints, just as in `alloc`.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n-        let usable_size = self.usable_size(&layout);\n-        self.alloc(layout).map(|p| Excess(p, usable_size.1))\n-    }\n-\n-    /// Behaves like `alloc`, but also returns the whole size of\n-    /// the returned block. For some `layout` inputs, like arrays, this\n-    /// may include extra storage usable for additional data.\n-    /// Also it ensures that the contents are set to zero before being returned.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `alloc` is.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `layout` does not meet allocator's size or alignment\n-    /// constraints, just as in `alloc`.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn alloc_excess_zeroed(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n-        let usable_size = self.usable_size(&layout);\n-        self.alloc_zeroed(layout).map(|p| Excess(p, usable_size.1))\n-    }\n-\n-    /// Behaves like `realloc`, but also returns the whole size of\n-    /// the returned block. For some `layout` inputs, like arrays, this\n-    /// may include extra storage usable for additional data.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `realloc` is.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `layout` does not meet allocator's size or alignment\n-    /// constraints, just as in `realloc`.\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc_excess(\n-        &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n-    ) -> Result<Excess, AllocErr> {\n-        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-        let usable_size = self.usable_size(&new_layout);\n-        self.realloc(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n-    }\n-\n-    /// Behaves like `realloc`, but also returns the whole size of\n-    /// the returned block. For some `layout` inputs, like arrays, this\n-    /// may include extra storage usable for additional data.\n-    /// Also it ensures that the contents are set to zero before being returned.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `realloc` is.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `layout` does not meet allocator's size or alignment\n-    /// constraints, just as in `realloc`.\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc_excess_zeroed(\n-        &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n-    ) -> Result<Excess, AllocErr> {\n-        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-        let usable_size = self.usable_size(&new_layout);\n-        self.realloc_zeroed(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n-    }\n-\n     /// Attempts to extend the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n     /// memory block referenced by `ptr` now fits `new_size`, and thus can\n     /// be used to carry data of a layout of that size and same alignment as\n-    /// `layout`. (The allocator is allowed to\n-    /// expend effort to accomplish this, such as extending the memory block to\n-    /// include successor blocks, or virtual memory tricks.)\n+    /// `layout`. The returned value is the new size of the allocated block.\n+    /// (The allocator is allowed to expend effort to accomplish this, such\n+    /// as extending the memory block to include successor blocks, or virtual\n+    /// memory tricks.)\n     ///\n     /// Regardless of what this method returns, ownership of the\n     /// memory block referenced by `ptr` has not been transferred, and\n@@ -1072,18 +929,17 @@ pub unsafe trait AllocRef {\n     /// function; clients are expected either to be able to recover from\n     /// `grow_in_place` failures without aborting, or to fall back on\n     /// another reallocation method before resorting to an abort.\n+    #[inline]\n     unsafe fn grow_in_place(\n         &mut self,\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<(), CannotReallocInPlace> {\n-        let _ = ptr; // this default implementation doesn't care about the actual address.\n-        debug_assert!(new_size >= layout.size());\n-        let (_l, u) = self.usable_size(&layout);\n-        // _l <= layout.size()                       [guaranteed by usable_size()]\n-        //       layout.size() <= new_layout.size()  [required by this method]\n-        if new_size <= u { Ok(()) } else { Err(CannotReallocInPlace) }\n+    ) -> Result<usize, CannotReallocInPlace> {\n+        let _ = ptr;\n+        let _ = layout;\n+        let _ = new_size;\n+        Err(CannotReallocInPlace)\n     }\n \n     /// Behaves like `grow_in_place`, but also ensures that the new\n@@ -1108,18 +964,19 @@ pub unsafe trait AllocRef {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<(), CannotReallocInPlace> {\n-        self.grow_in_place(ptr, layout, new_size)?;\n+    ) -> Result<usize, CannotReallocInPlace> {\n+        let size = self.grow_in_place(ptr, layout, new_size)?;\n         ptr.as_ptr().add(layout.size()).write_bytes(0, new_size - layout.size());\n-        Ok(())\n+        Ok(size)\n     }\n \n     /// Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n     /// memory block referenced by `ptr` now fits `new_size`, and\n     /// thus can only be used to carry data of that smaller\n-    /// layout. (The allocator is allowed to take advantage of this,\n+    /// layout. The returned value is the new size the allocated block.\n+    /// (The allocator is allowed to take advantage of this,\n     /// carving off portions of the block for reuse elsewhere.) The\n     /// truncated contents of the block within the smaller layout are\n     /// unaltered, and ownership of block has not been transferred.\n@@ -1153,17 +1010,16 @@ pub unsafe trait AllocRef {\n     /// function; clients are expected either to be able to recover from\n     /// `shrink_in_place` failures without aborting, or to fall back\n     /// on another reallocation method before resorting to an abort.\n+    #[inline]\n     unsafe fn shrink_in_place(\n         &mut self,\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<(), CannotReallocInPlace> {\n-        let _ = ptr; // this default implementation doesn't care about the actual address.\n-        debug_assert!(new_size <= layout.size());\n-        let (l, _u) = self.usable_size(&layout);\n-        //                      layout.size() <= _u  [guaranteed by usable_size()]\n-        // new_layout.size() <= layout.size()        [required by this method]\n-        if l <= new_size { Ok(()) } else { Err(CannotReallocInPlace) }\n+    ) -> Result<usize, CannotReallocInPlace> {\n+        let _ = ptr;\n+        let _ = layout;\n+        let _ = new_size;\n+        Err(CannotReallocInPlace)\n     }\n }"}, {"sha": "080b70c6368b286bf80f5636300001df18c2b4d0", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -43,7 +43,7 @@\n //! are elements, and once they've all been exhausted, will return `None` to\n //! indicate that iteration is finished. Individual iterators may choose to\n //! resume iteration, and so calling [`next`] again may or may not eventually\n-//! start returning `Some(Item)` again at some point.\n+//! start returning `Some(Item)` again at some point (for example, see [`TryIter`]).\n //!\n //! [`Iterator`]'s full definition includes a number of other methods as well,\n //! but they are default methods, built on top of [`next`], and so you get\n@@ -56,6 +56,7 @@\n //! [`Iterator`]: trait.Iterator.html\n //! [`next`]: trait.Iterator.html#tymethod.next\n //! [`Option`]: ../../std/option/enum.Option.html\n+//! [`TryIter`]: ../../std/sync/mpsc/struct.TryIter.html\n //!\n //! # The three forms of iteration\n //!"}, {"sha": "ad87d09588e3a217fbda625eced1c2493a9b3667", "filename": "src/libcore/iter/traits/exact_size.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -69,8 +69,10 @@\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ExactSizeIterator: Iterator {\n-    /// Returns the exact number of times the iterator will iterate.\n+    /// Returns the exact length of the iterator.\n     ///\n+    /// The implementation ensures that the iterator will return exactly `len()`\n+    /// more times a `Some(T)` value, before returning `None`.\n     /// This method has a default implementation, so you usually should not\n     /// implement it directly. However, if you can provide a more efficient\n     /// implementation, you can do so. See the [trait-level] docs for an"}, {"sha": "f9c8b01571e04d1086ed6a86bd9f96cb1ea26903", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -234,7 +234,7 @@ impl BoundNamesCollector {\n             start = false;\n             write!(fmt, \"{}\", r)?;\n         }\n-        for (_, t) in &self.types {\n+        for t in self.types.values() {\n             if !start {\n                 write!(fmt, \", \")?;\n             }"}, {"sha": "f1b4b828c71fa00f419514374ef7785d4ee2c7a8", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -1382,10 +1382,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         // Write down the order of our locals that will be promoted to the prefix.\n         {\n-            let mut idx = 0u32;\n-            for local in ineligible_locals.iter() {\n-                assignments[local] = Ineligible(Some(idx));\n-                idx += 1;\n+            for (idx, local) in ineligible_locals.iter().enumerate() {\n+                assignments[local] = Ineligible(Some(idx as u32));\n             }\n         }\n         debug!(\"generator saved local assignments: {:?}\", assignments);"}, {"sha": "3724a83a94981c486191c5b3d4ca4bbfafc0fe07", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -188,7 +188,7 @@ fn parse_args<'a>(\n                 let mut err = ecx\n                     .struct_span_err(e.span, \"positional arguments cannot follow named arguments\");\n                 err.span_label(e.span, \"positional arguments must be before named arguments\");\n-                for (_, pos) in &names {\n+                for pos in names.values() {\n                     err.span_label(args[*pos].span, \"named argument\");\n                 }\n                 err.emit();"}, {"sha": "11d1209923fb2912020c837c7735bde7ac2c391a", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -395,6 +395,7 @@ E0714: include_str!(\"./error_codes/E0714.md\"),\n E0715: include_str!(\"./error_codes/E0715.md\"),\n E0716: include_str!(\"./error_codes/E0716.md\"),\n E0718: include_str!(\"./error_codes/E0718.md\"),\n+E0719: include_str!(\"./error_codes/E0719.md\"),\n E0720: include_str!(\"./error_codes/E0720.md\"),\n E0723: include_str!(\"./error_codes/E0723.md\"),\n E0725: include_str!(\"./error_codes/E0725.md\"),\n@@ -605,7 +606,6 @@ E0748: include_str!(\"./error_codes/E0748.md\"),\n     E0710, // an unknown tool name found in scoped lint\n     E0711, // a feature has been declared with conflicting stability attributes\n     E0717, // rustc_promotable without stability attribute\n-    E0719, // duplicate values for associated type binding\n //  E0721, // `await` keyword\n     E0722, // Malformed `#[optimize]` attribute\n     E0724, // `#[ffi_returns_twice]` is only allowed in foreign functions"}, {"sha": "7f4374738de28ec4341247a93f3b1cd7c0edb298", "filename": "src/librustc_error_codes/error_codes/E0378.md", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -1,10 +1,28 @@\n+The `DispatchFromDyn` trait was implemented on something which is not a pointer\n+or a newtype wrapper around a pointer.\n+\n+Erroneous code example:\n+\n+```compile-fail,E0378\n+#![feature(dispatch_from_dyn)]\n+use std::ops::DispatchFromDyn;\n+\n+struct WrapperExtraField<T> {\n+    ptr: T,\n+    extra_stuff: i32,\n+}\n+\n+impl<T, U> DispatchFromDyn<WrapperExtraField<U>> for WrapperExtraField<T>\n+where\n+    T: DispatchFromDyn<U>,\n+{}\n+```\n+\n The `DispatchFromDyn` trait currently can only be implemented for\n builtin pointer types and structs that are newtype wrappers around them\n \u2014 that is, the struct must have only one field (except for`PhantomData`),\n and that field must itself implement `DispatchFromDyn`.\n \n-Examples:\n-\n ```\n #![feature(dispatch_from_dyn, unsize)]\n use std::{\n@@ -20,6 +38,8 @@ where\n {}\n ```\n \n+Another example:\n+\n ```\n #![feature(dispatch_from_dyn)]\n use std::{\n@@ -37,21 +57,3 @@ where\n     T: DispatchFromDyn<U>,\n {}\n ```\n-\n-Example of illegal `DispatchFromDyn` implementation\n-(illegal because of extra field)\n-\n-```compile-fail,E0378\n-#![feature(dispatch_from_dyn)]\n-use std::ops::DispatchFromDyn;\n-\n-struct WrapperExtraField<T> {\n-    ptr: T,\n-    extra_stuff: i32,\n-}\n-\n-impl<T, U> DispatchFromDyn<WrapperExtraField<U>> for WrapperExtraField<T>\n-where\n-    T: DispatchFromDyn<U>,\n-{}\n-```"}, {"sha": "38bc63550ac7ff0f0541becc1eef0e0076d47f77", "filename": "src/librustc_error_codes/error_codes/E0719.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_error_codes%2Ferror_codes%2FE0719.md", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_error_codes%2Ferror_codes%2FE0719.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0719.md?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -0,0 +1,35 @@\n+The value for an associated type has already been specified.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0719\n+#![feature(associated_type_bounds)]\n+\n+trait FooTrait {}\n+trait BarTrait {}\n+\n+// error: associated type `Item` in trait `Iterator` is specified twice\n+struct Foo<T: Iterator<Item: FooTrait, Item: BarTrait>> { f: T }\n+```\n+\n+`Item` in trait `Iterator` cannot be specified multiple times for struct `Foo`.\n+To fix this, create a new trait that is a combination of the desired traits and\n+specify the associated type with the new trait.\n+\n+Corrected example:\n+\n+```\n+#![feature(associated_type_bounds)]\n+\n+trait FooTrait {}\n+trait BarTrait {}\n+trait FooBarTrait: FooTrait + BarTrait {}\n+\n+struct Foo<T: Iterator<Item: FooBarTrait>> { f: T }\n+```\n+\n+For more information about associated types, see [the book][bk-at]. For more\n+information on associated type bounds, see [RFC 2289][rfc-2289].\n+\n+[bk-at]: https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types\n+[rfc-2289]: https://rust-lang.github.io/rfcs/2289-associated-type-bounds.html"}, {"sha": "008d2e92418f9b89f38cf83e74c3808a48d69a5a", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -136,12 +136,11 @@ impl<'a> DiagnosticBuilder<'a> {\n \n         let handler = self.0.handler;\n \n-        // We need to use `ptr::read` because `DiagnosticBuilder` implements `Drop`.\n-        let diagnostic;\n-        unsafe {\n-            diagnostic = std::ptr::read(&self.0.diagnostic);\n-            std::mem::forget(self);\n-        };\n+        // We must use `Level::Cancelled` for `dummy` to avoid an ICE about an\n+        // unused diagnostic.\n+        let dummy = Diagnostic::new(Level::Cancelled, \"\");\n+        let diagnostic = std::mem::replace(&mut self.0.diagnostic, dummy);\n+\n         // Logging here is useful to help track down where in logs an error was\n         // actually emitted.\n         debug!(\"buffer: diagnostic={:?}\", diagnostic);"}, {"sha": "eb9d4b887ad1d192edce00390260c99e4af1d23d", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -1574,9 +1574,9 @@ impl EmitterWriter {\n \n             let line_start = sm.lookup_char_pos(parts[0].span.lo()).line;\n             draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n-            let mut line_pos = 0;\n             let mut lines = complete.lines();\n-            for line in lines.by_ref().take(MAX_SUGGESTION_HIGHLIGHT_LINES) {\n+            for (line_pos, line) in lines.by_ref().take(MAX_SUGGESTION_HIGHLIGHT_LINES).enumerate()\n+            {\n                 // Print the span column to avoid confusion\n                 buffer.puts(\n                     row_num,\n@@ -1587,7 +1587,6 @@ impl EmitterWriter {\n                 // print the suggestion\n                 draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n                 buffer.append(row_num, line, Style::NoStyle);\n-                line_pos += 1;\n                 row_num += 1;\n             }\n "}, {"sha": "f948e22e84b10fa158d5972e412a116fc369eeca", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -679,15 +679,15 @@ impl Crate<'_> {\n     where\n         V: itemlikevisit::ItemLikeVisitor<'hir>,\n     {\n-        for (_, item) in &self.items {\n+        for item in self.items.values() {\n             visitor.visit_item(item);\n         }\n \n-        for (_, trait_item) in &self.trait_items {\n+        for trait_item in self.trait_items.values() {\n             visitor.visit_trait_item(trait_item);\n         }\n \n-        for (_, impl_item) in &self.impl_items {\n+        for impl_item in self.impl_items.values() {\n             visitor.visit_impl_item(impl_item);\n         }\n     }"}, {"sha": "b7278ecd5e4076cff4b24a849ad806117fe78c0f", "filename": "src/librustc_infer/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -751,7 +751,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         let dummy_source = graph.add_node(());\n         let dummy_sink = graph.add_node(());\n \n-        for (constraint, _) in &self.data.constraints {\n+        for constraint in self.data.constraints.keys() {\n             match *constraint {\n                 Constraint::VarSubVar(a_id, b_id) => {\n                     graph.add_edge("}, {"sha": "bbd4f3b35508e0a97a33ca44fd60d14f35ea984c", "filename": "src/librustc_infer/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -34,7 +34,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.in_snapshot());\n \n         // Go through each placeholder that we created.\n-        for (_, &placeholder_region) in placeholder_map {\n+        for &placeholder_region in placeholder_map.values() {\n             // Find the universe this placeholder inhabits.\n             let placeholder = match placeholder_region {\n                 ty::RePlaceholder(p) => p,"}, {"sha": "73bc038ea15f9758f5494944d31a690597dccc89", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -1252,7 +1252,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n         self.r.per_ns(|this, ns| {\n-            if let Some(binding) = source_bindings[ns].get().ok() {\n+            if let Ok(binding) = source_bindings[ns].get() {\n                 this.import_res_map.entry(directive.id).or_default()[ns] = Some(binding.res());\n             }\n         });\n@@ -1293,7 +1293,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let mut redundant_span = PerNS { value_ns: None, type_ns: None, macro_ns: None };\n \n         self.r.per_ns(|this, ns| {\n-            if let Some(binding) = source_bindings[ns].get().ok() {\n+            if let Ok(binding) = source_bindings[ns].get() {\n                 if binding.res() == Res::Err {\n                     return;\n                 }"}, {"sha": "193b6d75935b2163972ea213267b4150ee05bb39", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -347,7 +347,7 @@ fn krate(tcx: TyCtxt<'_>) -> NamedRegionMap {\n             lifetime_uses: &mut Default::default(),\n             missing_named_lifetime_spots: vec![],\n         };\n-        for (_, item) in &krate.items {\n+        for item in krate.items.values() {\n             visitor.visit_item(item);\n         }\n     }"}, {"sha": "199b476cb9a3e74ff44d0d081d9a0ee472a9f243", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -1652,7 +1652,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         for (projection_bound, _) in &bounds.projection_bounds {\n-            for (_, def_ids) in &mut associated_types {\n+            for def_ids in associated_types.values_mut() {\n                 def_ids.remove(&projection_bound.projection_def_id());\n             }\n         }"}, {"sha": "14f7a6b6817ef17ea02303b6bee5fb8f2744cebd", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -526,7 +526,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // we may want to suggest removing a `&`.\n                 if !sm.span_to_filename(expr.span).is_real() {\n                     if let Ok(code) = sm.span_to_snippet(sp) {\n-                        if code.chars().next() == Some('&') {\n+                        if code.starts_with('&') {\n                             return Some((\n                                 sp,\n                                 \"consider removing the borrow\","}, {"sha": "2da18e06d99bf79048e9cedeab4b0971f02aa52d", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -137,13 +137,15 @@ pub struct System;\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for System {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout))\n+            .ok_or(AllocErr)\n+            .map(|p| (p, layout.size()))\n     }\n \n     #[inline]\n@@ -157,8 +159,10 @@ unsafe impl AllocRef for System {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<NonNull<u8>, AllocErr> {\n-        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n+    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size))\n+            .ok_or(AllocErr)\n+            .map(|p| (p, new_size))\n     }\n }\n "}, {"sha": "57cba6b1f7a1be6949bb0d85dd8d5a15e43f2d57", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -901,7 +901,7 @@ impl ToSocketAddrs for str {\n     type Iter = vec::IntoIter<SocketAddr>;\n     fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n         // try to parse as a regular SocketAddr first\n-        if let Some(addr) = self.parse().ok() {\n+        if let Ok(addr) = self.parse() {\n             return Ok(vec![addr].into_iter());\n         }\n "}, {"sha": "b37675e0a0a008a4afdcb01fd7dda5522a585330", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -280,7 +280,7 @@ impl Socket {\n                 };\n                 let mut timeout = libc::timeval {\n                     tv_sec: secs,\n-                    tv_usec: (dur.subsec_nanos() / 1000) as libc::suseconds_t,\n+                    tv_usec: dur.subsec_micros() as libc::suseconds_t,\n                 };\n                 if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n                     timeout.tv_usec = 1;"}, {"sha": "c275db14b427cfa65c68f8a64ab1cebe1beafffa", "filename": "src/test/ui/allocator/custom.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -37,7 +37,7 @@ fn main() {\n     unsafe {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let ptr = Global.alloc(layout.clone()).unwrap();\n+        let (ptr, _) = Global.alloc(layout.clone()).unwrap();\n         helper::work_with(&ptr);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 1);\n         Global.dealloc(ptr, layout.clone());\n@@ -49,7 +49,7 @@ fn main() {\n         drop(s);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n \n-        let ptr = System.alloc(layout.clone()).unwrap();\n+        let (ptr, _) = System.alloc(layout.clone()).unwrap();\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n         helper::work_with(&ptr);\n         System.dealloc(ptr, layout);"}, {"sha": "e4746d1a7ec0904e5b7be30d05faf749e9d51b6b", "filename": "src/test/ui/allocator/xcrate-use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -20,13 +20,13 @@ fn main() {\n         let n = GLOBAL.0.load(Ordering::SeqCst);\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let ptr = Global.alloc(layout.clone()).unwrap();\n+        let (ptr, _) = Global.alloc(layout.clone()).unwrap();\n         helper::work_with(&ptr);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n         Global.dealloc(ptr, layout.clone());\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n \n-        let ptr = System.alloc(layout.clone()).unwrap();\n+        let (ptr, _) = System.alloc(layout.clone()).unwrap();\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n         helper::work_with(&ptr);\n         System.dealloc(ptr, layout);"}, {"sha": "82b2d32d09d575815b5a4f20d1c1fe93525e3662", "filename": "src/test/ui/associated-type-bounds/duplicate.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -728,3 +728,4 @@ LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n \n error: aborting due to 96 previous errors\n \n+For more information about this error, try `rustc --explain E0719`."}, {"sha": "0e4bbf083baf326c04a6f940aa9a66761b97d92c", "filename": "src/test/ui/error-codes/E0719.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -16,3 +16,4 @@ LL | fn test() -> Box<dyn Iterator<Item = (), Item = Unit>> {\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0719`."}, {"sha": "eb6224ad1bbb6d1766f1a5abc6c926570b0b3094", "filename": "src/test/ui/realloc-16687.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Ftest%2Fui%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Ftest%2Fui%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frealloc-16687.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -41,13 +41,13 @@ unsafe fn test_triangle() -> bool {\n             println!(\"allocate({:?})\", layout);\n         }\n \n-        let ret = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let (ptr, _) = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         if PRINT {\n-            println!(\"allocate({:?}) = {:?}\", layout, ret);\n+            println!(\"allocate({:?}) = {:?}\", layout, ptr);\n         }\n \n-        ret.cast().as_ptr()\n+        ptr.cast().as_ptr()\n     }\n \n     unsafe fn deallocate(ptr: *mut u8, layout: Layout) {\n@@ -63,16 +63,16 @@ unsafe fn test_triangle() -> bool {\n             println!(\"reallocate({:?}, old={:?}, new={:?})\", ptr, old, new);\n         }\n \n-        let ret = Global.realloc(NonNull::new_unchecked(ptr), old, new.size())\n+        let (ptr, _) = Global.realloc(NonNull::new_unchecked(ptr), old, new.size())\n             .unwrap_or_else(|_| handle_alloc_error(\n                 Layout::from_size_align_unchecked(new.size(), old.align())\n             ));\n \n         if PRINT {\n             println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\",\n-                     ptr, old, new, ret);\n+                     ptr, old, new, ptr);\n         }\n-        ret.cast().as_ptr()\n+        ptr.cast().as_ptr()\n     }\n \n     fn idx_to_size(i: usize) -> usize { (i+1) * 10 }"}, {"sha": "fe3a864fe4ba58be0286e4a9c98fe8b5d25ecace", "filename": "src/test/ui/regions/regions-mock-codegen.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de254862477924bcd8b9e1bff7eadd6ffb5e2a/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs?ref=a5de254862477924bcd8b9e1bff7eadd6ffb5e2a", "patch": "@@ -24,29 +24,29 @@ struct Ccx {\n     x: isize\n }\n \n-fn alloc<'a>(_bcx : &'a arena) -> &'a Bcx<'a> {\n+fn alloc(_bcx: &arena) -> &Bcx<'_> {\n     unsafe {\n         let layout = Layout::new::<Bcx>();\n-        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let (ptr, _) = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n         &*(ptr.as_ptr() as *const _)\n     }\n }\n \n-fn h<'a>(bcx : &'a Bcx<'a>) -> &'a Bcx<'a> {\n+fn h<'a>(bcx: &'a Bcx<'a>) -> &'a Bcx<'a> {\n     return alloc(bcx.fcx.arena);\n }\n \n-fn g(fcx : &Fcx) {\n-    let bcx = Bcx { fcx: fcx };\n+fn g(fcx: &Fcx) {\n+    let bcx = Bcx { fcx };\n     let bcx2 = h(&bcx);\n     unsafe {\n         Global.dealloc(NonNull::new_unchecked(bcx2 as *const _ as *mut _), Layout::new::<Bcx>());\n     }\n }\n \n-fn f(ccx : &Ccx) {\n+fn f(ccx: &Ccx) {\n     let a = arena(());\n-    let fcx = Fcx { arena: &a, ccx: ccx };\n+    let fcx = Fcx { arena: &a, ccx };\n     return g(&fcx);\n }\n "}]}