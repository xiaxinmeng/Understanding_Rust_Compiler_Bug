{"sha": "99a9d6806d355b69fa66621df5208342de823aea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5YTlkNjgwNmQzNTViNjlmYTY2NjIxZGY1MjA4MzQyZGU4MjNhZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-28T01:41:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-28T01:41:40Z"}, "message": "Auto merge of #51538 - nikomatsakis:nll-perf-examination, r=eddyb\n\nconvert NLL ops to caches\n\nThis is a extension of <https://github.com/rust-lang/rust/pull/51460>. It uses a lot more caching than we used to do. This caching is not yet as efficient as it could be, but I'm curious to see the current perf results.\n\nThis is the high-level idea: in the MIR type checker, use [canonicalized queries](https://rust-lang-nursery.github.io/rustc-guide/traits/canonical-queries.html) for all the major operations. This is helpful because the MIR type check is operating in a context where all types are fully known (mostly, anyway) but regions are completely renumbered. This means we often wind up with duplicate queries like `Foo<'1, '2> :Bar` and `Foo<'3, '4>: Bar`. Canonicalized queries let us re-use the results. By the final commit in this PR, we can essentially just \"read off\" the resulting region relations and add them to the NLL type check.", "tree": {"sha": "e4af5719bab719a6e8c15a84b0e055554b3bcbe4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4af5719bab719a6e8c15a84b0e055554b3bcbe4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99a9d6806d355b69fa66621df5208342de823aea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99a9d6806d355b69fa66621df5208342de823aea", "html_url": "https://github.com/rust-lang/rust/commit/99a9d6806d355b69fa66621df5208342de823aea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99a9d6806d355b69fa66621df5208342de823aea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "266afeb17c993f83d01d8129e97981a57bb442e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/266afeb17c993f83d01d8129e97981a57bb442e0", "html_url": "https://github.com/rust-lang/rust/commit/266afeb17c993f83d01d8129e97981a57bb442e0"}, {"sha": "1523de34a2267b624f1b920c1b4496568bd8c16b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1523de34a2267b624f1b920c1b4496568bd8c16b", "html_url": "https://github.com/rust-lang/rust/commit/1523de34a2267b624f1b920c1b4496568bd8c16b"}], "stats": {"total": 4906, "additions": 3139, "deletions": 1767}, "files": [{"sha": "33322993b1db6289be3317638f9743e252387aec", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -70,9 +70,12 @@ use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use std::fmt;\n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n-use traits::query::{CanonicalProjectionGoal,\n-                    CanonicalTyGoal, CanonicalPredicateGoal};\n-use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n+use traits::query::{\n+    CanonicalProjectionGoal, CanonicalTyGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal,\n+    CanonicalPredicateGoal, CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpNormalizeGoal,\n+};\n+use ty::{TyCtxt, FnSig, Instance, InstanceDef,\n+         ParamEnv, ParamEnvAnd, Predicate, PolyFnSig, PolyTraitRef, Ty};\n use ty::subst::Substs;\n \n // erase!() just makes tokens go away. It's used to specify which macro argument\n@@ -647,6 +650,13 @@ define_dep_nodes!( <'tcx>\n     [] NormalizeTyAfterErasingRegions(ParamEnvAnd<'tcx, Ty<'tcx>>),\n     [] DropckOutlives(CanonicalTyGoal<'tcx>),\n     [] EvaluateObligation(CanonicalPredicateGoal<'tcx>),\n+    [] TypeOpEq(CanonicalTypeOpEqGoal<'tcx>),\n+    [] TypeOpSubtype(CanonicalTypeOpSubtypeGoal<'tcx>),\n+    [] TypeOpProvePredicate(CanonicalTypeOpProvePredicateGoal<'tcx>),\n+    [] TypeOpNormalizeTy(CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>),\n+    [] TypeOpNormalizePredicate(CanonicalTypeOpNormalizeGoal<'tcx, Predicate<'tcx>>),\n+    [] TypeOpNormalizePolyFnSig(CanonicalTypeOpNormalizeGoal<'tcx, PolyFnSig<'tcx>>),\n+    [] TypeOpNormalizeFnSig(CanonicalTypeOpNormalizeGoal<'tcx, FnSig<'tcx>>),\n \n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n "}, {"sha": "ef11cc0f4932e6094a238799cddd30d317ceca6a", "filename": "src/librustc/infer/canonical.rs", "status": "removed", "additions": 0, "deletions": 925, "changes": 925, "blob_url": "https://github.com/rust-lang/rust/blob/266afeb17c993f83d01d8129e97981a57bb442e0/src%2Flibrustc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266afeb17c993f83d01d8129e97981a57bb442e0/src%2Flibrustc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical.rs?ref=266afeb17c993f83d01d8129e97981a57bb442e0", "patch": "@@ -1,925 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! **Canonicalization** is the key to constructing a query in the\n-//! middle of type inference. Ordinarily, it is not possible to store\n-//! types from type inference in query keys, because they contain\n-//! references to inference variables whose lifetimes are too short\n-//! and so forth. Canonicalizing a value T1 using `canonicalize_query`\n-//! produces two things:\n-//!\n-//! - a value T2 where each unbound inference variable has been\n-//!   replaced with a **canonical variable**;\n-//! - a map M (of type `CanonicalVarValues`) from those canonical\n-//!   variables back to the original.\n-//!\n-//! We can then do queries using T2. These will give back constriants\n-//! on the canonical variables which can be translated, using the map\n-//! M, into constraints in our source context. This process of\n-//! translating the results back is done by the\n-//! `instantiate_query_result` method.\n-//!\n-//! For a more detailed look at what is happening here, check\n-//! out the [chapter in the rustc guide][c].\n-//!\n-//! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n-\n-use infer::{InferCtxt, InferOk, InferResult, RegionVariableOrigin, TypeVariableOrigin};\n-use rustc_data_structures::indexed_vec::Idx;\n-use serialize::UseSpecializedDecodable;\n-use std::fmt::Debug;\n-use std::ops::Index;\n-use std::sync::atomic::Ordering;\n-use syntax::codemap::Span;\n-use traits::{Obligation, ObligationCause, PredicateObligation};\n-use ty::{self, CanonicalVar, Lift, Region, Slice, Ty, TyCtxt, TypeFlags};\n-use ty::subst::{Kind, UnpackedKind};\n-use ty::fold::{TypeFoldable, TypeFolder};\n-\n-use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::fx::FxHashMap;\n-\n-/// A \"canonicalized\" type `V` is one where all free inference\n-/// variables have been rewriten to \"canonical vars\". These are\n-/// numbered starting from 0 in order of first appearance.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n-pub struct Canonical<'gcx, V> {\n-    pub variables: CanonicalVarInfos<'gcx>,\n-    pub value: V,\n-}\n-\n-pub type CanonicalVarInfos<'gcx> = &'gcx Slice<CanonicalVarInfo>;\n-\n-impl<'gcx> UseSpecializedDecodable for CanonicalVarInfos<'gcx> { }\n-\n-/// A set of values corresponding to the canonical variables from some\n-/// `Canonical`. You can give these values to\n-/// `canonical_value.substitute` to substitute them into the canonical\n-/// value at the right places.\n-///\n-/// When you canonicalize a value `V`, you get back one of these\n-/// vectors with the original values that were replaced by canonical\n-/// variables.\n-///\n-/// You can also use `infcx.fresh_inference_vars_for_canonical_vars`\n-/// to get back a `CanonicalVarValues` containing fresh inference\n-/// variables.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n-pub struct CanonicalVarValues<'tcx> {\n-    pub var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n-}\n-\n-/// Information about a canonical variable that is included with the\n-/// canonical value. This is sufficient information for code to create\n-/// a copy of the canonical value in some other inference context,\n-/// with fresh inference variables replacing the canonical values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n-pub struct CanonicalVarInfo {\n-    pub kind: CanonicalVarKind,\n-}\n-\n-/// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n-/// in the type-theory sense of the term -- i.e., a \"meta\" type system\n-/// that analyzes type-like values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n-pub enum CanonicalVarKind {\n-    /// Some kind of type inference variable.\n-    Ty(CanonicalTyVarKind),\n-\n-    /// Region variable `'?R`.\n-    Region,\n-}\n-\n-/// Rust actually has more than one category of type variables;\n-/// notably, the type variables we create for literals (e.g., 22 or\n-/// 22.) can only be instantiated with integral/float types (e.g.,\n-/// usize or f32). In order to faithfully reproduce a type, we need to\n-/// know what set of types a given type variable can be unified with.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n-pub enum CanonicalTyVarKind {\n-    /// General type variable `?T` that can be unified with arbitrary types.\n-    General,\n-\n-    /// Integral type variable `?I` (that can only be unified with integral types).\n-    Int,\n-\n-    /// Floating-point type variable `?F` (that can only be unified with float types).\n-    Float,\n-}\n-\n-/// After we execute a query with a canonicalized key, we get back a\n-/// `Canonical<QueryResult<..>>`. You can use\n-/// `instantiate_query_result` to access the data in this result.\n-#[derive(Clone, Debug)]\n-pub struct QueryResult<'tcx, R> {\n-    pub var_values: CanonicalVarValues<'tcx>,\n-    pub region_constraints: Vec<QueryRegionConstraint<'tcx>>,\n-    pub certainty: Certainty,\n-    pub value: R,\n-}\n-\n-/// Indicates whether or not we were able to prove the query to be\n-/// true.\n-#[derive(Copy, Clone, Debug)]\n-pub enum Certainty {\n-    /// The query is known to be true, presuming that you apply the\n-    /// given `var_values` and the region-constraints are satisfied.\n-    Proven,\n-\n-    /// The query is not known to be true, but also not known to be\n-    /// false. The `var_values` represent *either* values that must\n-    /// hold in order for the query to be true, or helpful tips that\n-    /// *might* make it true. Currently rustc's trait solver cannot\n-    /// distinguish the two (e.g., due to our preference for where\n-    /// clauses over impls).\n-    ///\n-    /// After some unifiations and things have been done, it makes\n-    /// sense to try and prove again -- of course, at that point, the\n-    /// canonical form will be different, making this a distinct\n-    /// query.\n-    Ambiguous,\n-}\n-\n-impl Certainty {\n-    pub fn is_proven(&self) -> bool {\n-        match self {\n-            Certainty::Proven => true,\n-            Certainty::Ambiguous => false,\n-        }\n-    }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n-}\n-\n-impl<'tcx, R> QueryResult<'tcx, R> {\n-    pub fn is_proven(&self) -> bool {\n-        self.certainty.is_proven()\n-    }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n-}\n-\n-impl<'tcx, R> Canonical<'tcx, QueryResult<'tcx, R>> {\n-    pub fn is_proven(&self) -> bool {\n-        self.value.is_proven()\n-    }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n-}\n-\n-pub type QueryRegionConstraint<'tcx> = ty::Binder<ty::OutlivesPredicate<Kind<'tcx>, Region<'tcx>>>;\n-\n-/// Trait implemented by values that can be canonicalized. It mainly\n-/// serves to identify the interning table we will use.\n-pub trait Canonicalize<'gcx: 'tcx, 'tcx>: TypeFoldable<'tcx> + Lift<'gcx> {\n-    type Canonicalized: 'gcx + Debug;\n-\n-    /// After a value has been fully canonicalized and lifted, this\n-    /// method will allocate it in a global arena.\n-    fn intern(\n-        gcx: TyCtxt<'_, 'gcx, 'gcx>,\n-        value: Canonical<'gcx, Self::Lifted>,\n-    ) -> Self::Canonicalized;\n-}\n-\n-impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n-    /// Creates a substitution S for the canonical value with fresh\n-    /// inference variables and applies it to the canonical value.\n-    /// Returns both the instantiated result *and* the substitution S.\n-    ///\n-    /// This is useful at the start of a query: it basically brings\n-    /// the canonical value \"into scope\" within your new infcx. At the\n-    /// end of processing, the substitution S (once canonicalized)\n-    /// then represents the values that you computed for each of the\n-    /// canonical inputs to your query.\n-    pub fn instantiate_canonical_with_fresh_inference_vars<T>(\n-        &self,\n-        span: Span,\n-        canonical: &Canonical<'tcx, T>,\n-    ) -> (T, CanonicalVarValues<'tcx>)\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let canonical_inference_vars =\n-            self.fresh_inference_vars_for_canonical_vars(span, canonical.variables);\n-        let result = canonical.substitute(self.tcx, &canonical_inference_vars);\n-        (result, canonical_inference_vars)\n-    }\n-\n-    /// Given the \"infos\" about the canonical variables from some\n-    /// canonical, creates fresh inference variables with the same\n-    /// characteristics. You can then use `substitute` to instantiate\n-    /// the canonical variable with these inference variables.\n-    pub fn fresh_inference_vars_for_canonical_vars(\n-        &self,\n-        span: Span,\n-        variables: &Slice<CanonicalVarInfo>,\n-    ) -> CanonicalVarValues<'tcx> {\n-        let var_values: IndexVec<CanonicalVar, Kind<'tcx>> = variables\n-            .iter()\n-            .map(|info| self.fresh_inference_var_for_canonical_var(span, *info))\n-            .collect();\n-\n-        CanonicalVarValues { var_values }\n-    }\n-\n-    /// Given the \"info\" about a canonical variable, creates a fresh\n-    /// inference variable with the same characteristics.\n-    pub fn fresh_inference_var_for_canonical_var(\n-        &self,\n-        span: Span,\n-        cv_info: CanonicalVarInfo,\n-    ) -> Kind<'tcx> {\n-        match cv_info.kind {\n-            CanonicalVarKind::Ty(ty_kind) => {\n-                let ty = match ty_kind {\n-                    CanonicalTyVarKind::General => {\n-                        self.next_ty_var(\n-                            TypeVariableOrigin::MiscVariable(span),\n-                        )\n-                    }\n-\n-                    CanonicalTyVarKind::Int => self.tcx.mk_int_var(self.next_int_var_id()),\n-\n-                    CanonicalTyVarKind::Float => self.tcx.mk_float_var(self.next_float_var_id()),\n-                };\n-                ty.into()\n-            }\n-\n-            CanonicalVarKind::Region => {\n-                self.next_region_var(RegionVariableOrigin::MiscVariable(span)).into()\n-            }\n-        }\n-    }\n-\n-    /// Given the (canonicalized) result to a canonical query,\n-    /// instantiates the result so it can be used, plugging in the\n-    /// values from the canonical query. (Note that the result may\n-    /// have been ambiguous; you should check the certainty level of\n-    /// the query before applying this function.)\n-    ///\n-    /// To get a good understanding of what is happening here, check\n-    /// out the [chapter in the rustc guide][c].\n-    ///\n-    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html#processing-the-canonicalized-query-result\n-    pub fn instantiate_query_result<R>(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        original_values: &CanonicalVarValues<'tcx>,\n-        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n-    ) -> InferResult<'tcx, R>\n-    where\n-        R: Debug + TypeFoldable<'tcx>,\n-    {\n-        debug!(\n-            \"instantiate_query_result(original_values={:#?}, query_result={:#?})\",\n-            original_values, query_result,\n-        );\n-\n-        // Every canonical query result includes values for each of\n-        // the inputs to the query. Therefore, we begin by unifying\n-        // these values with the original inputs that were\n-        // canonicalized.\n-        let result_values = &query_result.value.var_values;\n-        assert_eq!(original_values.len(), result_values.len());\n-\n-        // Quickly try to find initial values for the canonical\n-        // variables in the result in terms of the query. We do this\n-        // by iterating down the values that the query gave to each of\n-        // the canonical inputs. If we find that one of those values\n-        // is directly equal to one of the canonical variables in the\n-        // result, then we can type the corresponding value from the\n-        // input. See the example above.\n-        let mut opt_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>> =\n-            IndexVec::from_elem_n(None, query_result.variables.len());\n-\n-        // In terms of our example above, we are iterating over pairs like:\n-        // [(?A, Vec<?0>), ('static, '?1), (?B, ?0)]\n-        for (original_value, result_value) in original_values.iter().zip(result_values) {\n-            match result_value.unpack() {\n-                UnpackedKind::Type(result_value) => {\n-                    // e.g., here `result_value` might be `?0` in the example above...\n-                    if let ty::TyInfer(ty::InferTy::CanonicalTy(index)) = result_value.sty {\n-                        // in which case we would set `canonical_vars[0]` to `Some(?U)`.\n-                        opt_values[index] = Some(original_value);\n-                    }\n-                }\n-                UnpackedKind::Lifetime(result_value) => {\n-                    // e.g., here `result_value` might be `'?1` in the example above...\n-                    if let &ty::RegionKind::ReCanonical(index) = result_value {\n-                        // in which case we would set `canonical_vars[0]` to `Some('static)`.\n-                        opt_values[index] = Some(original_value);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Create a result substitution: if we found a value for a\n-        // given variable in the loop above, use that. Otherwise, use\n-        // a fresh inference variable.\n-        let result_subst = &CanonicalVarValues {\n-            var_values: query_result\n-                .variables\n-                .iter()\n-                .enumerate()\n-                .map(|(index, info)| match opt_values[CanonicalVar::new(index)] {\n-                    Some(k) => k,\n-                    None => self.fresh_inference_var_for_canonical_var(cause.span, *info),\n-                })\n-                .collect(),\n-        };\n-\n-        // Unify the original values for the canonical variables in\n-        // the input with the value found in the query\n-        // post-substitution. Often, but not always, this is a no-op,\n-        // because we already found the mapping in the first step.\n-        let substituted_values = |index: CanonicalVar| -> Kind<'tcx> {\n-            query_result.substitute_projected(self.tcx, result_subst, |v| &v.var_values[index])\n-        };\n-        let mut obligations =\n-            self.unify_canonical_vars(cause, param_env, original_values, substituted_values)?\n-                .into_obligations();\n-\n-        obligations.extend(self.query_region_constraints_into_obligations(\n-            cause,\n-            param_env,\n-            &query_result.value.region_constraints,\n-            result_subst,\n-        ));\n-\n-        let user_result: R =\n-            query_result.substitute_projected(self.tcx, result_subst, |q_r| &q_r.value);\n-\n-        Ok(InferOk {\n-            value: user_result,\n-            obligations,\n-        })\n-    }\n-\n-    /// Converts the region constraints resulting from a query into an\n-    /// iterator of obligations.\n-    fn query_region_constraints_into_obligations<'a>(\n-        &'a self,\n-        cause: &'a ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        unsubstituted_region_constraints: &'a [QueryRegionConstraint<'tcx>],\n-        result_subst: &'a CanonicalVarValues<'tcx>,\n-    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a {\n-        Box::new(unsubstituted_region_constraints.iter().map(move |constraint| {\n-            let ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n-            let k1 = substitute_value(self.tcx, result_subst, k1);\n-            let r2 = substitute_value(self.tcx, result_subst, r2);\n-            match k1.unpack() {\n-                UnpackedKind::Lifetime(r1) =>\n-                    Obligation::new(\n-                        cause.clone(),\n-                        param_env,\n-                        ty::Predicate::RegionOutlives(\n-                            ty::Binder::dummy(ty::OutlivesPredicate(r1, r2))),\n-                    ),\n-\n-                UnpackedKind::Type(t1) =>\n-                    Obligation::new(\n-                        cause.clone(),\n-                        param_env,\n-                        ty::Predicate::TypeOutlives(\n-                            ty::Binder::dummy(ty::OutlivesPredicate(t1, r2))),\n-                    ),\n-            }\n-        })) as Box<dyn Iterator<Item = _>>\n-    }\n-\n-    /// Given two sets of values for the same set of canonical variables, unify them.\n-    /// The second set is produced lazilly by supplying indices from the first set.\n-    fn unify_canonical_vars(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        variables1: &CanonicalVarValues<'tcx>,\n-        variables2: impl Fn(CanonicalVar) -> Kind<'tcx>,\n-    ) -> InferResult<'tcx, ()> {\n-        self.commit_if_ok(|_| {\n-            let mut obligations = vec![];\n-            for (index, value1) in variables1.var_values.iter_enumerated() {\n-                let value2 = variables2(index);\n-\n-                match (value1.unpack(), value2.unpack()) {\n-                    (UnpackedKind::Type(v1), UnpackedKind::Type(v2)) => {\n-                        obligations\n-                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n-                    }\n-                    (\n-                        UnpackedKind::Lifetime(ty::ReErased),\n-                        UnpackedKind::Lifetime(ty::ReErased),\n-                    ) => {\n-                        // no action needed\n-                    }\n-                    (UnpackedKind::Lifetime(v1), UnpackedKind::Lifetime(v2)) => {\n-                        obligations\n-                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n-                    }\n-                    _ => {\n-                        bug!(\"kind mismatch, cannot unify {:?} and {:?}\", value1, value2,);\n-                    }\n-                }\n-            }\n-            Ok(InferOk {\n-                value: (),\n-                obligations,\n-            })\n-        })\n-    }\n-\n-    /// Canonicalizes a query value `V`. When we canonicalize a query,\n-    /// we not only canonicalize unbound inference variables, but we\n-    /// *also* replace all free regions whatsoever. So for example a\n-    /// query like `T: Trait<'static>` would be canonicalized to\n-    ///\n-    /// ```text\n-    /// T: Trait<'?0>\n-    /// ```\n-    ///\n-    /// with a mapping M that maps `'?0` to `'static`.\n-    ///\n-    /// To get a good understanding of what is happening here, check\n-    /// out the [chapter in the rustc guide][c].\n-    ///\n-    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html#canonicalizing-the-query\n-    pub fn canonicalize_query<V>(&self, value: &V) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n-    where\n-        V: Canonicalize<'gcx, 'tcx>,\n-    {\n-        self.tcx.sess.perf_stats.queries_canonicalized.fetch_add(1, Ordering::Relaxed);\n-\n-        Canonicalizer::canonicalize(\n-            value,\n-            Some(self),\n-            self.tcx,\n-            CanonicalizeAllFreeRegions(true),\n-        )\n-    }\n-\n-    /// Canonicalizes a query *response* `V`. When we canonicalize a\n-    /// query response, we only canonicalize unbound inference\n-    /// variables, and we leave other free regions alone. So,\n-    /// continuing with the example from `canonicalize_query`, if\n-    /// there was an input query `T: Trait<'static>`, it would have\n-    /// been canonicalized to\n-    ///\n-    /// ```text\n-    /// T: Trait<'?0>\n-    /// ```\n-    ///\n-    /// with a mapping M that maps `'?0` to `'static`. But if we found that there\n-    /// exists only one possible impl of `Trait`, and it looks like\n-    ///\n-    ///     impl<T> Trait<'static> for T { .. }\n-    ///\n-    /// then we would prepare a query result R that (among other\n-    /// things) includes a mapping to `'?0 := 'static`. When\n-    /// canonicalizing this query result R, we would leave this\n-    /// reference to `'static` alone.\n-    ///\n-    /// To get a good understanding of what is happening here, check\n-    /// out the [chapter in the rustc guide][c].\n-    ///\n-    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html#canonicalizing-the-query-result\n-    pub fn canonicalize_response<V>(\n-        &self,\n-        value: &V,\n-    ) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n-    where\n-        V: Canonicalize<'gcx, 'tcx>,\n-    {\n-        Canonicalizer::canonicalize(\n-            value,\n-            Some(self),\n-            self.tcx,\n-            CanonicalizeAllFreeRegions(false),\n-        )\n-    }\n-}\n-\n-/// If this flag is true, then all free regions will be replaced with\n-/// a canonical var. This is used to make queries as generic as\n-/// possible. For example, the query `F: Foo<'static>` would be\n-/// canonicalized to `F: Foo<'0>`.\n-struct CanonicalizeAllFreeRegions(bool);\n-\n-struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    variables: IndexVec<CanonicalVar, CanonicalVarInfo>,\n-    indices: FxHashMap<Kind<'tcx>, CanonicalVar>,\n-    var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n-    canonicalize_all_free_regions: CanonicalizeAllFreeRegions,\n-    needs_canonical_flags: TypeFlags,\n-}\n-\n-impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match *r {\n-            ty::ReLateBound(..) => {\n-                // leave bound regions alone\n-                r\n-            }\n-\n-            ty::ReVar(vid) => {\n-                let r = self.infcx\n-                    .unwrap()\n-                    .borrow_region_constraints()\n-                    .opportunistic_resolve_var(self.tcx, vid);\n-                let info = CanonicalVarInfo {\n-                    kind: CanonicalVarKind::Region,\n-                };\n-                debug!(\n-                    \"canonical: region var found with vid {:?}, \\\n-                     opportunistically resolved to {:?}\",\n-                    vid, r\n-                );\n-                let cvar = self.canonical_var(info, r.into());\n-                self.tcx().mk_region(ty::ReCanonical(cvar))\n-            }\n-\n-            ty::ReStatic\n-            | ty::ReEarlyBound(..)\n-            | ty::ReFree(_)\n-            | ty::ReScope(_)\n-            | ty::ReSkolemized(..)\n-            | ty::ReEmpty\n-            | ty::ReErased => {\n-                if self.canonicalize_all_free_regions.0 {\n-                    let info = CanonicalVarInfo {\n-                        kind: CanonicalVarKind::Region,\n-                    };\n-                    let cvar = self.canonical_var(info, r.into());\n-                    self.tcx().mk_region(ty::ReCanonical(cvar))\n-                } else {\n-                    r\n-                }\n-            }\n-\n-            ty::ReClosureBound(..) | ty::ReCanonical(_) => {\n-                bug!(\"canonical region encountered during canonicalization\")\n-            }\n-        }\n-    }\n-\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.sty {\n-            ty::TyInfer(ty::TyVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::General, t),\n-\n-            ty::TyInfer(ty::IntVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Int, t),\n-\n-            ty::TyInfer(ty::FloatVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Float, t),\n-\n-            ty::TyInfer(ty::FreshTy(_))\n-            | ty::TyInfer(ty::FreshIntTy(_))\n-            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n-                bug!(\"encountered a fresh type during canonicalization\")\n-            }\n-\n-            ty::TyInfer(ty::CanonicalTy(_)) => {\n-                bug!(\"encountered a canonical type during canonicalization\")\n-            }\n-\n-            ty::TyClosure(..)\n-            | ty::TyGenerator(..)\n-            | ty::TyGeneratorWitness(..)\n-            | ty::TyBool\n-            | ty::TyChar\n-            | ty::TyInt(..)\n-            | ty::TyUint(..)\n-            | ty::TyFloat(..)\n-            | ty::TyAdt(..)\n-            | ty::TyStr\n-            | ty::TyError\n-            | ty::TyArray(..)\n-            | ty::TySlice(..)\n-            | ty::TyRawPtr(..)\n-            | ty::TyRef(..)\n-            | ty::TyFnDef(..)\n-            | ty::TyFnPtr(_)\n-            | ty::TyDynamic(..)\n-            | ty::TyNever\n-            | ty::TyTuple(..)\n-            | ty::TyProjection(..)\n-            | ty::TyForeign(..)\n-            | ty::TyParam(..)\n-            | ty::TyAnon(..) => {\n-                if t.flags.intersects(self.needs_canonical_flags) {\n-                    t.super_fold_with(self)\n-                } else {\n-                    t\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n-    /// The main `canonicalize` method, shared impl of\n-    /// `canonicalize_query` and `canonicalize_response`.\n-    fn canonicalize<V>(\n-        value: &V,\n-        infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-        canonicalize_all_free_regions: CanonicalizeAllFreeRegions,\n-    ) -> (V::Canonicalized, CanonicalVarValues<'tcx>)\n-    where\n-        V: Canonicalize<'gcx, 'tcx>,\n-    {\n-        debug_assert!(\n-            !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS),\n-            \"canonicalizing a canonical value: {:?}\",\n-            value,\n-        );\n-\n-        let needs_canonical_flags = if canonicalize_all_free_regions.0 {\n-            TypeFlags::HAS_FREE_REGIONS | TypeFlags::KEEP_IN_LOCAL_TCX\n-        } else {\n-            TypeFlags::KEEP_IN_LOCAL_TCX\n-        };\n-\n-        let gcx = tcx.global_tcx();\n-\n-        // Fast path: nothing that needs to be canonicalized.\n-        if !value.has_type_flags(needs_canonical_flags) {\n-            let out_value = gcx.lift(value).unwrap();\n-            let canon_value = V::intern(\n-                gcx,\n-                Canonical {\n-                    variables: Slice::empty(),\n-                    value: out_value,\n-                },\n-            );\n-            let values = CanonicalVarValues {\n-                var_values: IndexVec::default(),\n-            };\n-            return (canon_value, values);\n-        }\n-\n-        let mut canonicalizer = Canonicalizer {\n-            infcx,\n-            tcx,\n-            canonicalize_all_free_regions,\n-            needs_canonical_flags,\n-            variables: IndexVec::default(),\n-            indices: FxHashMap::default(),\n-            var_values: IndexVec::default(),\n-        };\n-        let out_value = value.fold_with(&mut canonicalizer);\n-\n-        // Once we have canonicalized `out_value`, it should not\n-        // contain anything that ties it to this inference context\n-        // anymore, so it should live in the global arena.\n-        let out_value = gcx.lift(&out_value).unwrap_or_else(|| {\n-            bug!(\n-                \"failed to lift `{:?}`, canonicalized from `{:?}`\",\n-                out_value,\n-                value\n-            )\n-        });\n-\n-        let canonical_variables = tcx.intern_canonical_var_infos(&canonicalizer.variables.raw);\n-\n-        let canonical_value = V::intern(\n-            gcx,\n-            Canonical {\n-                variables: canonical_variables,\n-                value: out_value,\n-            },\n-        );\n-        let canonical_var_values = CanonicalVarValues {\n-            var_values: canonicalizer.var_values,\n-        };\n-        (canonical_value, canonical_var_values)\n-    }\n-\n-    /// Creates a canonical variable replacing `kind` from the input,\n-    /// or returns an existing variable if `kind` has already been\n-    /// seen. `kind` is expected to be an unbound variable (or\n-    /// potentially a free region).\n-    fn canonical_var(&mut self, info: CanonicalVarInfo, kind: Kind<'tcx>) -> CanonicalVar {\n-        let Canonicalizer {\n-            indices,\n-            variables,\n-            var_values,\n-            ..\n-        } = self;\n-\n-        indices\n-            .entry(kind)\n-            .or_insert_with(|| {\n-                let cvar1 = variables.push(info);\n-                let cvar2 = var_values.push(kind);\n-                assert_eq!(cvar1, cvar2);\n-                cvar1\n-            })\n-            .clone()\n-    }\n-\n-    /// Given a type variable `ty_var` of the given kind, first check\n-    /// if `ty_var` is bound to anything; if so, canonicalize\n-    /// *that*. Otherwise, create a new canonical variable for\n-    /// `ty_var`.\n-    fn canonicalize_ty_var(&mut self, ty_kind: CanonicalTyVarKind, ty_var: Ty<'tcx>) -> Ty<'tcx> {\n-        let infcx = self.infcx.expect(\"encountered ty-var without infcx\");\n-        let bound_to = infcx.shallow_resolve(ty_var);\n-        if bound_to != ty_var {\n-            self.fold_ty(bound_to)\n-        } else {\n-            let info = CanonicalVarInfo {\n-                kind: CanonicalVarKind::Ty(ty_kind),\n-            };\n-            let cvar = self.canonical_var(info, ty_var.into());\n-            self.tcx().mk_infer(ty::InferTy::CanonicalTy(cvar))\n-        }\n-    }\n-}\n-\n-impl<'tcx, V> Canonical<'tcx, V> {\n-    /// Instantiate the wrapped value, replacing each canonical value\n-    /// with the value given in `var_values`.\n-    fn substitute(&self, tcx: TyCtxt<'_, '_, 'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n-    where\n-        V: TypeFoldable<'tcx>,\n-    {\n-        self.substitute_projected(tcx, var_values, |value| value)\n-    }\n-\n-    /// Invoke `projection_fn` with `self.value` to get a value V that\n-    /// is expressed in terms of the same canonical variables bound in\n-    /// `self`. Apply the substitution `var_values` to this value V,\n-    /// replacing each of the canonical variables.\n-    fn substitute_projected<T>(\n-        &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        var_values: &CanonicalVarValues<'tcx>,\n-        projection_fn: impl FnOnce(&V) -> &T,\n-    ) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        assert_eq!(self.variables.len(), var_values.var_values.len());\n-        let value = projection_fn(&self.value);\n-        substitute_value(tcx, var_values, value)\n-    }\n-}\n-\n-/// Substitute the values from `var_values` into `value`. `var_values`\n-/// must be values for the set of cnaonical variables that appear in\n-/// `value`.\n-fn substitute_value<'a, 'tcx, T>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n-    var_values: &CanonicalVarValues<'tcx>,\n-    value: &'a T,\n-) -> T\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    if var_values.var_values.is_empty() {\n-        debug_assert!(!value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS));\n-        value.clone()\n-    } else if !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n-        value.clone()\n-    } else {\n-        value.fold_with(&mut CanonicalVarValuesSubst { tcx, var_values })\n-    }\n-}\n-\n-struct CanonicalVarValuesSubst<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    var_values: &'cx CanonicalVarValues<'tcx>,\n-}\n-\n-impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for CanonicalVarValuesSubst<'cx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.sty {\n-            ty::TyInfer(ty::InferTy::CanonicalTy(c)) => {\n-                match self.var_values.var_values[c].unpack() {\n-                    UnpackedKind::Type(ty) => ty,\n-                    r => bug!(\"{:?} is a type but value is {:?}\", c, r),\n-                }\n-            }\n-            _ => {\n-                if !t.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n-                    t\n-                } else {\n-                    t.super_fold_with(self)\n-                }\n-            }\n-        }\n-    }\n-\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match r {\n-            ty::RegionKind::ReCanonical(c) => match self.var_values.var_values[*c].unpack() {\n-                UnpackedKind::Lifetime(l) => l,\n-                r => bug!(\"{:?} is a region but value is {:?}\", c, r),\n-            },\n-            _ => r.super_fold_with(self),\n-        }\n-    }\n-}\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    ::infer::canonical::Certainty,\n-    ::infer::canonical::CanonicalVarInfo,\n-    ::infer::canonical::CanonicalVarKind,\n-}\n-\n-CloneTypeFoldableImpls! {\n-    for <'tcx> {\n-        ::infer::canonical::CanonicalVarInfos<'tcx>,\n-    }\n-}\n-\n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx, C> TypeFoldable<'tcx> for Canonical<'tcx, C> {\n-        variables,\n-        value,\n-    } where C: TypeFoldable<'tcx>\n-}\n-\n-BraceStructLiftImpl! {\n-    impl<'a, 'tcx, T> Lift<'tcx> for Canonical<'a, T> {\n-        type Lifted = Canonical<'tcx, T::Lifted>;\n-        variables, value\n-    } where T: Lift<'tcx>\n-}\n-\n-impl<'tcx> CanonicalVarValues<'tcx> {\n-    fn iter<'a>(&'a self) -> impl Iterator<Item = Kind<'tcx>> + 'a {\n-        self.var_values.iter().cloned()\n-    }\n-\n-    fn len(&self) -> usize {\n-        self.var_values.len()\n-    }\n-}\n-\n-impl<'a, 'tcx> IntoIterator for &'a CanonicalVarValues<'tcx> {\n-    type Item = Kind<'tcx>;\n-    type IntoIter = ::std::iter::Cloned<::std::slice::Iter<'a, Kind<'tcx>>>;\n-\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.var_values.iter().cloned()\n-    }\n-}\n-\n-BraceStructLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for CanonicalVarValues<'a> {\n-        type Lifted = CanonicalVarValues<'tcx>;\n-        var_values,\n-    }\n-}\n-\n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for CanonicalVarValues<'tcx> {\n-        var_values,\n-    }\n-}\n-\n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx, R> TypeFoldable<'tcx> for QueryResult<'tcx, R> {\n-        var_values, region_constraints, certainty, value\n-    } where R: TypeFoldable<'tcx>,\n-}\n-\n-BraceStructLiftImpl! {\n-    impl<'a, 'tcx, R> Lift<'tcx> for QueryResult<'a, R> {\n-        type Lifted = QueryResult<'tcx, R::Lifted>;\n-        var_values, region_constraints, certainty, value\n-    } where R: Lift<'tcx>\n-}\n-\n-impl<'tcx> Index<CanonicalVar> for CanonicalVarValues<'tcx> {\n-    type Output = Kind<'tcx>;\n-\n-    fn index(&self, value: CanonicalVar) -> &Kind<'tcx> {\n-        &self.var_values[value]\n-    }\n-}"}, {"sha": "8b67f04e0201c04d488224aa7b99c066dba09a19", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "added", "additions": 403, "deletions": 0, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -0,0 +1,403 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains the \"canonicalizer\" itself.\n+//!\n+//! For an overview of what canonicaliation is and how it fits into\n+//! rustc, check out the [chapter in the rustc guide][c].\n+//!\n+//! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n+\n+use infer::canonical::{\n+    Canonical, CanonicalTyVarKind, CanonicalVarInfo, CanonicalVarKind, CanonicalVarValues,\n+    Canonicalized,\n+};\n+use infer::InferCtxt;\n+use std::sync::atomic::Ordering;\n+use ty::fold::{TypeFoldable, TypeFolder};\n+use ty::subst::Kind;\n+use ty::{self, CanonicalVar, Lift, Slice, Ty, TyCtxt, TypeFlags};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Canonicalizes a query value `V`. When we canonicalize a query,\n+    /// we not only canonicalize unbound inference variables, but we\n+    /// *also* replace all free regions whatsoever. So for example a\n+    /// query like `T: Trait<'static>` would be canonicalized to\n+    ///\n+    /// ```text\n+    /// T: Trait<'?0>\n+    /// ```\n+    ///\n+    /// with a mapping M that maps `'?0` to `'static`.\n+    ///\n+    /// To get a good understanding of what is happening here, check\n+    /// out the [chapter in the rustc guide][c].\n+    ///\n+    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html#canonicalizing-the-query\n+    pub fn canonicalize_query<V>(\n+        &self,\n+        value: &V,\n+    ) -> (Canonicalized<'gcx, V>, CanonicalVarValues<'tcx>)\n+    where\n+        V: TypeFoldable<'tcx> + Lift<'gcx>,\n+    {\n+        self.tcx\n+            .sess\n+            .perf_stats\n+            .queries_canonicalized\n+            .fetch_add(1, Ordering::Relaxed);\n+\n+        Canonicalizer::canonicalize(\n+            value,\n+            Some(self),\n+            self.tcx,\n+            CanonicalizeRegionMode {\n+                static_region: true,\n+                other_free_regions: true,\n+            },\n+        )\n+    }\n+\n+    /// Canonicalizes a query *response* `V`. When we canonicalize a\n+    /// query response, we only canonicalize unbound inference\n+    /// variables, and we leave other free regions alone. So,\n+    /// continuing with the example from `canonicalize_query`, if\n+    /// there was an input query `T: Trait<'static>`, it would have\n+    /// been canonicalized to\n+    ///\n+    /// ```text\n+    /// T: Trait<'?0>\n+    /// ```\n+    ///\n+    /// with a mapping M that maps `'?0` to `'static`. But if we found that there\n+    /// exists only one possible impl of `Trait`, and it looks like\n+    ///\n+    ///     impl<T> Trait<'static> for T { .. }\n+    ///\n+    /// then we would prepare a query result R that (among other\n+    /// things) includes a mapping to `'?0 := 'static`. When\n+    /// canonicalizing this query result R, we would leave this\n+    /// reference to `'static` alone.\n+    ///\n+    /// To get a good understanding of what is happening here, check\n+    /// out the [chapter in the rustc guide][c].\n+    ///\n+    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html#canonicalizing-the-query-result\n+    pub fn canonicalize_response<V>(\n+        &self,\n+        value: &V,\n+    ) -> (Canonicalized<'gcx, V>, CanonicalVarValues<'tcx>)\n+    where\n+        V: TypeFoldable<'tcx> + Lift<'gcx>,\n+    {\n+        Canonicalizer::canonicalize(\n+            value,\n+            Some(self),\n+            self.tcx,\n+            CanonicalizeRegionMode {\n+                static_region: false,\n+                other_free_regions: false,\n+            },\n+        )\n+    }\n+\n+    /// A hacky variant of `canonicalize_query` that does not\n+    /// canonicalize `'static`.  Unfortunately, the existing leak\n+    /// check treaks `'static` differently in some cases (see also\n+    /// #33684), so if we are performing an operation that may need to\n+    /// prove \"leak-check\" related things, we leave `'static`\n+    /// alone.\n+    ///\n+    /// FIXME(#48536) -- once we have universes, we can remove this and just use\n+    /// `canonicalize_query`.\n+    pub fn canonicalize_hr_query_hack<V>(\n+        &self,\n+        value: &V,\n+    ) -> (Canonicalized<'gcx, V>, CanonicalVarValues<'tcx>)\n+    where\n+        V: TypeFoldable<'tcx> + Lift<'gcx>,\n+    {\n+        self.tcx\n+            .sess\n+            .perf_stats\n+            .queries_canonicalized\n+            .fetch_add(1, Ordering::Relaxed);\n+\n+        Canonicalizer::canonicalize(\n+            value,\n+            Some(self),\n+            self.tcx,\n+            CanonicalizeRegionMode {\n+                static_region: false,\n+                other_free_regions: true,\n+            },\n+        )\n+    }\n+}\n+\n+/// If this flag is true, then all free regions will be replaced with\n+/// a canonical var. This is used to make queries as generic as\n+/// possible. For example, the query `F: Foo<'static>` would be\n+/// canonicalized to `F: Foo<'0>`.\n+struct CanonicalizeRegionMode {\n+    static_region: bool,\n+    other_free_regions: bool,\n+}\n+\n+impl CanonicalizeRegionMode {\n+    fn any(&self) -> bool {\n+        self.static_region || self.other_free_regions\n+    }\n+}\n+\n+struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    variables: IndexVec<CanonicalVar, CanonicalVarInfo>,\n+    indices: FxHashMap<Kind<'tcx>, CanonicalVar>,\n+    var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n+    canonicalize_region_mode: CanonicalizeRegionMode,\n+    needs_canonical_flags: TypeFlags,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            ty::ReLateBound(..) => {\n+                // leave bound regions alone\n+                r\n+            }\n+\n+            ty::ReVar(vid) => {\n+                let r = self\n+                    .infcx\n+                    .unwrap()\n+                    .borrow_region_constraints()\n+                    .opportunistic_resolve_var(self.tcx, vid);\n+                let info = CanonicalVarInfo {\n+                    kind: CanonicalVarKind::Region,\n+                };\n+                debug!(\n+                    \"canonical: region var found with vid {:?}, \\\n+                     opportunistically resolved to {:?}\",\n+                    vid, r\n+                );\n+                let cvar = self.canonical_var(info, r.into());\n+                self.tcx().mk_region(ty::ReCanonical(cvar))\n+            }\n+\n+            ty::ReStatic => {\n+                if self.canonicalize_region_mode.static_region {\n+                    let info = CanonicalVarInfo {\n+                        kind: CanonicalVarKind::Region,\n+                    };\n+                    let cvar = self.canonical_var(info, r.into());\n+                    self.tcx().mk_region(ty::ReCanonical(cvar))\n+                } else {\n+                    r\n+                }\n+            }\n+\n+            ty::ReEarlyBound(..)\n+            | ty::ReFree(_)\n+            | ty::ReScope(_)\n+            | ty::ReSkolemized(..)\n+            | ty::ReEmpty\n+            | ty::ReErased => {\n+                if self.canonicalize_region_mode.other_free_regions {\n+                    let info = CanonicalVarInfo {\n+                        kind: CanonicalVarKind::Region,\n+                    };\n+                    let cvar = self.canonical_var(info, r.into());\n+                    self.tcx().mk_region(ty::ReCanonical(cvar))\n+                } else {\n+                    r\n+                }\n+            }\n+\n+            ty::ReClosureBound(..) | ty::ReCanonical(_) => {\n+                bug!(\"canonical region encountered during canonicalization\")\n+            }\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.sty {\n+            ty::TyInfer(ty::TyVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::General, t),\n+\n+            ty::TyInfer(ty::IntVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Int, t),\n+\n+            ty::TyInfer(ty::FloatVar(_)) => self.canonicalize_ty_var(CanonicalTyVarKind::Float, t),\n+\n+            ty::TyInfer(ty::FreshTy(_))\n+            | ty::TyInfer(ty::FreshIntTy(_))\n+            | ty::TyInfer(ty::FreshFloatTy(_)) => {\n+                bug!(\"encountered a fresh type during canonicalization\")\n+            }\n+\n+            ty::TyInfer(ty::CanonicalTy(_)) => {\n+                bug!(\"encountered a canonical type during canonicalization\")\n+            }\n+\n+            ty::TyClosure(..)\n+            | ty::TyGenerator(..)\n+            | ty::TyGeneratorWitness(..)\n+            | ty::TyBool\n+            | ty::TyChar\n+            | ty::TyInt(..)\n+            | ty::TyUint(..)\n+            | ty::TyFloat(..)\n+            | ty::TyAdt(..)\n+            | ty::TyStr\n+            | ty::TyError\n+            | ty::TyArray(..)\n+            | ty::TySlice(..)\n+            | ty::TyRawPtr(..)\n+            | ty::TyRef(..)\n+            | ty::TyFnDef(..)\n+            | ty::TyFnPtr(_)\n+            | ty::TyDynamic(..)\n+            | ty::TyNever\n+            | ty::TyTuple(..)\n+            | ty::TyProjection(..)\n+            | ty::TyForeign(..)\n+            | ty::TyParam(..)\n+            | ty::TyAnon(..) => {\n+                if t.flags.intersects(self.needs_canonical_flags) {\n+                    t.super_fold_with(self)\n+                } else {\n+                    t\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n+    /// The main `canonicalize` method, shared impl of\n+    /// `canonicalize_query` and `canonicalize_response`.\n+    fn canonicalize<V>(\n+        value: &V,\n+        infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        canonicalize_region_mode: CanonicalizeRegionMode,\n+    ) -> (Canonicalized<'gcx, V>, CanonicalVarValues<'tcx>)\n+    where\n+        V: TypeFoldable<'tcx> + Lift<'gcx>,\n+    {\n+        debug_assert!(\n+            !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS),\n+            \"canonicalizing a canonical value: {:?}\",\n+            value,\n+        );\n+\n+        let needs_canonical_flags = if canonicalize_region_mode.any() {\n+            TypeFlags::HAS_FREE_REGIONS | TypeFlags::KEEP_IN_LOCAL_TCX\n+        } else {\n+            TypeFlags::KEEP_IN_LOCAL_TCX\n+        };\n+\n+        let gcx = tcx.global_tcx();\n+\n+        // Fast path: nothing that needs to be canonicalized.\n+        if !value.has_type_flags(needs_canonical_flags) {\n+            let out_value = gcx.lift(value).unwrap();\n+            let canon_value = Canonical {\n+                variables: Slice::empty(),\n+                value: out_value,\n+            };\n+            let values = CanonicalVarValues {\n+                var_values: IndexVec::default(),\n+            };\n+            return (canon_value, values);\n+        }\n+\n+        let mut canonicalizer = Canonicalizer {\n+            infcx,\n+            tcx,\n+            canonicalize_region_mode,\n+            needs_canonical_flags,\n+            variables: IndexVec::default(),\n+            indices: FxHashMap::default(),\n+            var_values: IndexVec::default(),\n+        };\n+        let out_value = value.fold_with(&mut canonicalizer);\n+\n+        // Once we have canonicalized `out_value`, it should not\n+        // contain anything that ties it to this inference context\n+        // anymore, so it should live in the global arena.\n+        let out_value = gcx.lift(&out_value).unwrap_or_else(|| {\n+            bug!(\n+                \"failed to lift `{:?}`, canonicalized from `{:?}`\",\n+                out_value,\n+                value\n+            )\n+        });\n+\n+        let canonical_variables = tcx.intern_canonical_var_infos(&canonicalizer.variables.raw);\n+\n+        let canonical_value = Canonical {\n+            variables: canonical_variables,\n+            value: out_value,\n+        };\n+        let canonical_var_values = CanonicalVarValues {\n+            var_values: canonicalizer.var_values,\n+        };\n+        (canonical_value, canonical_var_values)\n+    }\n+\n+    /// Creates a canonical variable replacing `kind` from the input,\n+    /// or returns an existing variable if `kind` has already been\n+    /// seen. `kind` is expected to be an unbound variable (or\n+    /// potentially a free region).\n+    fn canonical_var(&mut self, info: CanonicalVarInfo, kind: Kind<'tcx>) -> CanonicalVar {\n+        let Canonicalizer {\n+            indices,\n+            variables,\n+            var_values,\n+            ..\n+        } = self;\n+\n+        indices\n+            .entry(kind)\n+            .or_insert_with(|| {\n+                let cvar1 = variables.push(info);\n+                let cvar2 = var_values.push(kind);\n+                assert_eq!(cvar1, cvar2);\n+                cvar1\n+            })\n+            .clone()\n+    }\n+\n+    /// Given a type variable `ty_var` of the given kind, first check\n+    /// if `ty_var` is bound to anything; if so, canonicalize\n+    /// *that*. Otherwise, create a new canonical variable for\n+    /// `ty_var`.\n+    fn canonicalize_ty_var(&mut self, ty_kind: CanonicalTyVarKind, ty_var: Ty<'tcx>) -> Ty<'tcx> {\n+        let infcx = self.infcx.expect(\"encountered ty-var without infcx\");\n+        let bound_to = infcx.shallow_resolve(ty_var);\n+        if bound_to != ty_var {\n+            self.fold_ty(bound_to)\n+        } else {\n+            let info = CanonicalVarInfo {\n+                kind: CanonicalVarKind::Ty(ty_kind),\n+            };\n+            let cvar = self.canonical_var(info, ty_var.into());\n+            self.tcx().mk_infer(ty::InferTy::CanonicalTy(cvar))\n+        }\n+    }\n+}"}, {"sha": "62424ff9226dfe8588b16225076aba24ea5f0f91", "filename": "src/librustc/infer/canonical/mod.rs", "status": "added", "additions": 334, "deletions": 0, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -0,0 +1,334 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! **Canonicalization** is the key to constructing a query in the\n+//! middle of type inference. Ordinarily, it is not possible to store\n+//! types from type inference in query keys, because they contain\n+//! references to inference variables whose lifetimes are too short\n+//! and so forth. Canonicalizing a value T1 using `canonicalize_query`\n+//! produces two things:\n+//!\n+//! - a value T2 where each unbound inference variable has been\n+//!   replaced with a **canonical variable**;\n+//! - a map M (of type `CanonicalVarValues`) from those canonical\n+//!   variables back to the original.\n+//!\n+//! We can then do queries using T2. These will give back constriants\n+//! on the canonical variables which can be translated, using the map\n+//! M, into constraints in our source context. This process of\n+//! translating the results back is done by the\n+//! `instantiate_query_result` method.\n+//!\n+//! For a more detailed look at what is happening here, check\n+//! out the [chapter in the rustc guide][c].\n+//!\n+//! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n+\n+use infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin};\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::sync::Lrc;\n+use serialize::UseSpecializedDecodable;\n+use std::ops::Index;\n+use syntax::codemap::Span;\n+use ty::fold::TypeFoldable;\n+use ty::subst::Kind;\n+use ty::{self, CanonicalVar, Lift, Region, Slice, TyCtxt};\n+\n+mod canonicalizer;\n+\n+pub mod query_result;\n+\n+mod substitute;\n+\n+/// A \"canonicalized\" type `V` is one where all free inference\n+/// variables have been rewriten to \"canonical vars\". These are\n+/// numbered starting from 0 in order of first appearance.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+pub struct Canonical<'gcx, V> {\n+    pub variables: CanonicalVarInfos<'gcx>,\n+    pub value: V,\n+}\n+\n+pub type CanonicalVarInfos<'gcx> = &'gcx Slice<CanonicalVarInfo>;\n+\n+impl<'gcx> UseSpecializedDecodable for CanonicalVarInfos<'gcx> {}\n+\n+/// A set of values corresponding to the canonical variables from some\n+/// `Canonical`. You can give these values to\n+/// `canonical_value.substitute` to substitute them into the canonical\n+/// value at the right places.\n+///\n+/// When you canonicalize a value `V`, you get back one of these\n+/// vectors with the original values that were replaced by canonical\n+/// variables. You will need to supply it later to instantiate the\n+/// canonicalized query response.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+pub struct CanonicalVarValues<'tcx> {\n+    pub var_values: IndexVec<CanonicalVar, Kind<'tcx>>,\n+}\n+\n+/// Information about a canonical variable that is included with the\n+/// canonical value. This is sufficient information for code to create\n+/// a copy of the canonical value in some other inference context,\n+/// with fresh inference variables replacing the canonical values.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+pub struct CanonicalVarInfo {\n+    pub kind: CanonicalVarKind,\n+}\n+\n+/// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n+/// in the type-theory sense of the term -- i.e., a \"meta\" type system\n+/// that analyzes type-like values.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+pub enum CanonicalVarKind {\n+    /// Some kind of type inference variable.\n+    Ty(CanonicalTyVarKind),\n+\n+    /// Region variable `'?R`.\n+    Region,\n+}\n+\n+/// Rust actually has more than one category of type variables;\n+/// notably, the type variables we create for literals (e.g., 22 or\n+/// 22.) can only be instantiated with integral/float types (e.g.,\n+/// usize or f32). In order to faithfully reproduce a type, we need to\n+/// know what set of types a given type variable can be unified with.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+pub enum CanonicalTyVarKind {\n+    /// General type variable `?T` that can be unified with arbitrary types.\n+    General,\n+\n+    /// Integral type variable `?I` (that can only be unified with integral types).\n+    Int,\n+\n+    /// Floating-point type variable `?F` (that can only be unified with float types).\n+    Float,\n+}\n+\n+/// After we execute a query with a canonicalized key, we get back a\n+/// `Canonical<QueryResult<..>>`. You can use\n+/// `instantiate_query_result` to access the data in this result.\n+#[derive(Clone, Debug)]\n+pub struct QueryResult<'tcx, R> {\n+    pub var_values: CanonicalVarValues<'tcx>,\n+    pub region_constraints: Vec<QueryRegionConstraint<'tcx>>,\n+    pub certainty: Certainty,\n+    pub value: R,\n+}\n+\n+pub type Canonicalized<'gcx, V> = Canonical<'gcx, <V as Lift<'gcx>>::Lifted>;\n+\n+pub type CanonicalizedQueryResult<'gcx, T> =\n+    Lrc<Canonical<'gcx, QueryResult<'gcx, <T as Lift<'gcx>>::Lifted>>>;\n+\n+/// Indicates whether or not we were able to prove the query to be\n+/// true.\n+#[derive(Copy, Clone, Debug)]\n+pub enum Certainty {\n+    /// The query is known to be true, presuming that you apply the\n+    /// given `var_values` and the region-constraints are satisfied.\n+    Proven,\n+\n+    /// The query is not known to be true, but also not known to be\n+    /// false. The `var_values` represent *either* values that must\n+    /// hold in order for the query to be true, or helpful tips that\n+    /// *might* make it true. Currently rustc's trait solver cannot\n+    /// distinguish the two (e.g., due to our preference for where\n+    /// clauses over impls).\n+    ///\n+    /// After some unifiations and things have been done, it makes\n+    /// sense to try and prove again -- of course, at that point, the\n+    /// canonical form will be different, making this a distinct\n+    /// query.\n+    Ambiguous,\n+}\n+\n+impl Certainty {\n+    pub fn is_proven(&self) -> bool {\n+        match self {\n+            Certainty::Proven => true,\n+            Certainty::Ambiguous => false,\n+        }\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+impl<'tcx, R> QueryResult<'tcx, R> {\n+    pub fn is_proven(&self) -> bool {\n+        self.certainty.is_proven()\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+impl<'tcx, R> Canonical<'tcx, QueryResult<'tcx, R>> {\n+    pub fn is_proven(&self) -> bool {\n+        self.value.is_proven()\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+pub type QueryRegionConstraint<'tcx> = ty::Binder<ty::OutlivesPredicate<Kind<'tcx>, Region<'tcx>>>;\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Creates a substitution S for the canonical value with fresh\n+    /// inference variables and applies it to the canonical value.\n+    /// Returns both the instantiated result *and* the substitution S.\n+    ///\n+    /// This is useful at the start of a query: it basically brings\n+    /// the canonical value \"into scope\" within your new infcx. At the\n+    /// end of processing, the substitution S (once canonicalized)\n+    /// then represents the values that you computed for each of the\n+    /// canonical inputs to your query.\n+    pub fn instantiate_canonical_with_fresh_inference_vars<T>(\n+        &self,\n+        span: Span,\n+        canonical: &Canonical<'tcx, T>,\n+    ) -> (T, CanonicalVarValues<'tcx>)\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let canonical_inference_vars =\n+            self.fresh_inference_vars_for_canonical_vars(span, canonical.variables);\n+        let result = canonical.substitute(self.tcx, &canonical_inference_vars);\n+        (result, canonical_inference_vars)\n+    }\n+\n+    /// Given the \"infos\" about the canonical variables from some\n+    /// canonical, creates fresh inference variables with the same\n+    /// characteristics. You can then use `substitute` to instantiate\n+    /// the canonical variable with these inference variables.\n+    fn fresh_inference_vars_for_canonical_vars(\n+        &self,\n+        span: Span,\n+        variables: &Slice<CanonicalVarInfo>,\n+    ) -> CanonicalVarValues<'tcx> {\n+        let var_values: IndexVec<CanonicalVar, Kind<'tcx>> = variables\n+            .iter()\n+            .map(|info| self.fresh_inference_var_for_canonical_var(span, *info))\n+            .collect();\n+\n+        CanonicalVarValues { var_values }\n+    }\n+\n+    /// Given the \"info\" about a canonical variable, creates a fresh\n+    /// inference variable with the same characteristics.\n+    fn fresh_inference_var_for_canonical_var(\n+        &self,\n+        span: Span,\n+        cv_info: CanonicalVarInfo,\n+    ) -> Kind<'tcx> {\n+        match cv_info.kind {\n+            CanonicalVarKind::Ty(ty_kind) => {\n+                let ty = match ty_kind {\n+                    CanonicalTyVarKind::General => {\n+                        self.next_ty_var(TypeVariableOrigin::MiscVariable(span))\n+                    }\n+\n+                    CanonicalTyVarKind::Int => self.tcx.mk_int_var(self.next_int_var_id()),\n+\n+                    CanonicalTyVarKind::Float => self.tcx.mk_float_var(self.next_float_var_id()),\n+                };\n+                ty.into()\n+            }\n+\n+            CanonicalVarKind::Region => self\n+                .next_region_var(RegionVariableOrigin::MiscVariable(span))\n+                .into(),\n+        }\n+    }\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    ::infer::canonical::Certainty,\n+    ::infer::canonical::CanonicalVarInfo,\n+    ::infer::canonical::CanonicalVarKind,\n+}\n+\n+CloneTypeFoldableImpls! {\n+    for <'tcx> {\n+        ::infer::canonical::CanonicalVarInfos<'tcx>,\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, C> TypeFoldable<'tcx> for Canonical<'tcx, C> {\n+        variables,\n+        value,\n+    } where C: TypeFoldable<'tcx>\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx, T> Lift<'tcx> for Canonical<'a, T> {\n+        type Lifted = Canonical<'tcx, T::Lifted>;\n+        variables, value\n+    } where T: Lift<'tcx>\n+}\n+\n+impl<'tcx> CanonicalVarValues<'tcx> {\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = Kind<'tcx>> + 'a {\n+        self.var_values.iter().cloned()\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.var_values.len()\n+    }\n+}\n+\n+impl<'a, 'tcx> IntoIterator for &'a CanonicalVarValues<'tcx> {\n+    type Item = Kind<'tcx>;\n+    type IntoIter = ::std::iter::Cloned<::std::slice::Iter<'a, Kind<'tcx>>>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.var_values.iter().cloned()\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for CanonicalVarValues<'a> {\n+        type Lifted = CanonicalVarValues<'tcx>;\n+        var_values,\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for CanonicalVarValues<'tcx> {\n+        var_values,\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, R> TypeFoldable<'tcx> for QueryResult<'tcx, R> {\n+        var_values, region_constraints, certainty, value\n+    } where R: TypeFoldable<'tcx>,\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx, R> Lift<'tcx> for QueryResult<'a, R> {\n+        type Lifted = QueryResult<'tcx, R::Lifted>;\n+        var_values, region_constraints, certainty, value\n+    } where R: Lift<'tcx>\n+}\n+\n+impl<'tcx> Index<CanonicalVar> for CanonicalVarValues<'tcx> {\n+    type Output = Kind<'tcx>;\n+\n+    fn index(&self, value: CanonicalVar) -> &Kind<'tcx> {\n+        &self.var_values[value]\n+    }\n+}"}, {"sha": "b8b13e03afaf93d29b897d85fdee16644132261e", "filename": "src/librustc/infer/canonical/query_result.rs", "status": "added", "additions": 605, "deletions": 0, "changes": 605, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_result.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -0,0 +1,605 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains the code to instantiate a \"query result\", and\n+//! in particular to extract out the resulting region obligations and\n+//! encode them therein.\n+//!\n+//! For an overview of what canonicaliation is and how it fits into\n+//! rustc, check out the [chapter in the rustc guide][c].\n+//!\n+//! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n+\n+use infer::canonical::substitute::substitute_value;\n+use infer::canonical::{Canonical, CanonicalVarKind, CanonicalVarValues, CanonicalizedQueryResult,\n+                       Certainty, QueryRegionConstraint, QueryResult};\n+use infer::region_constraints::{Constraint, RegionConstraintData};\n+use infer::InferCtxtBuilder;\n+use infer::{InferCtxt, InferOk, InferResult, RegionObligation};\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::sync::Lrc;\n+use std::fmt::Debug;\n+use syntax::ast;\n+use syntax_pos::DUMMY_SP;\n+use traits::query::{Fallible, NoSolution};\n+use traits::{FulfillmentContext, TraitEngine};\n+use traits::{Obligation, ObligationCause, PredicateObligation};\n+use ty::fold::TypeFoldable;\n+use ty::subst::{Kind, UnpackedKind};\n+use ty::{self, CanonicalVar, Lift, TyCtxt};\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxtBuilder<'cx, 'gcx, 'tcx> {\n+    /// The \"main method\" for a canonicalized trait query. Given the\n+    /// canonical key `canonical_key`, this method will create a new\n+    /// inference context, instantiate the key, and run your operation\n+    /// `op`. The operation should yield up a result (of type `R`) as\n+    /// well as a set of trait obligations that must be fully\n+    /// satisfied. These obligations will be processed and the\n+    /// canonical result created.\n+    ///\n+    /// Returns `NoSolution` in the event of any error.\n+    ///\n+    /// (It might be mildly nicer to implement this on `TyCtxt`, and\n+    /// not `InferCtxtBuilder`, but that is a bit tricky right now.\n+    /// In part because we would need a `for<'gcx: 'tcx>` sort of\n+    /// bound for the closure and in part because it is convenient to\n+    /// have `'tcx` be free on this function so that we can talk about\n+    /// `K: TypeFoldable<'tcx>`.)\n+    pub fn enter_canonical_trait_query<K, R>(\n+        &'tcx mut self,\n+        canonical_key: &Canonical<'tcx, K>,\n+        operation: impl FnOnce(&InferCtxt<'_, 'gcx, 'tcx>, &mut FulfillmentContext<'tcx>, K)\n+            -> Fallible<R>,\n+    ) -> Fallible<CanonicalizedQueryResult<'gcx, R>>\n+    where\n+        K: TypeFoldable<'tcx>,\n+        R: Debug + Lift<'gcx> + TypeFoldable<'tcx>,\n+    {\n+        self.enter(|ref infcx| {\n+            let (key, canonical_inference_vars) =\n+                infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_key);\n+            let fulfill_cx = &mut FulfillmentContext::new();\n+            let value = operation(infcx, fulfill_cx, key)?;\n+            infcx.make_canonicalized_query_result(canonical_inference_vars, value, fulfill_cx)\n+        })\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// This method is meant to be invoked as the final step of a canonical query\n+    /// implementation. It is given:\n+    ///\n+    /// - the instantiated variables `inference_vars` created from the query key\n+    /// - the result `answer` of the query\n+    /// - a fulfillment context `fulfill_cx` that may contain various obligations which\n+    ///   have yet to be proven.\n+    ///\n+    /// Given this, the function will process the obligations pending\n+    /// in `fulfill_cx`:\n+    ///\n+    /// - If all the obligations can be proven successfully, it will\n+    ///   package up any resulting region obligations (extracted from\n+    ///   `infcx`) along with the fully resolved value `answer` into a\n+    ///   query result (which is then itself canonicalized).\n+    /// - If some obligations can be neither proven nor disproven, then\n+    ///   the same thing happens, but the resulting query is marked as ambiguous.\n+    /// - Finally, if any of the obligations result in a hard error,\n+    ///   then `Err(NoSolution)` is returned.\n+    pub fn make_canonicalized_query_result<T>(\n+        &self,\n+        inference_vars: CanonicalVarValues<'tcx>,\n+        answer: T,\n+        fulfill_cx: &mut FulfillmentContext<'tcx>,\n+    ) -> Fallible<CanonicalizedQueryResult<'gcx, T>>\n+    where\n+        T: Debug + Lift<'gcx> + TypeFoldable<'tcx>,\n+    {\n+        let query_result = self.make_query_result(inference_vars, answer, fulfill_cx)?;\n+        let (canonical_result, _) = self.canonicalize_response(&query_result);\n+\n+        debug!(\n+            \"make_canonicalized_query_result: canonical_result = {:#?}\",\n+            canonical_result\n+        );\n+\n+        Ok(Lrc::new(canonical_result))\n+    }\n+\n+    /// Helper for `make_canonicalized_query_result` that does\n+    /// everything up until the final canonicalization.\n+    fn make_query_result<T>(\n+        &self,\n+        inference_vars: CanonicalVarValues<'tcx>,\n+        answer: T,\n+        fulfill_cx: &mut FulfillmentContext<'tcx>,\n+    ) -> Result<QueryResult<'tcx, T>, NoSolution>\n+    where\n+        T: Debug + TypeFoldable<'tcx> + Lift<'gcx>,\n+    {\n+        let tcx = self.tcx;\n+\n+        debug!(\n+            \"make_query_result(\\\n+             inference_vars={:?}, \\\n+             answer={:?})\",\n+            inference_vars, answer,\n+        );\n+\n+        // Select everything, returning errors.\n+        let true_errors = match fulfill_cx.select_where_possible(self) {\n+            Ok(()) => vec![],\n+            Err(errors) => errors,\n+        };\n+        debug!(\"true_errors = {:#?}\", true_errors);\n+\n+        if !true_errors.is_empty() {\n+            // FIXME -- we don't indicate *why* we failed to solve\n+            debug!(\"make_query_result: true_errors={:#?}\", true_errors);\n+            return Err(NoSolution);\n+        }\n+\n+        // Anything left unselected *now* must be an ambiguity.\n+        let ambig_errors = match fulfill_cx.select_all_or_error(self) {\n+            Ok(()) => vec![],\n+            Err(errors) => errors,\n+        };\n+        debug!(\"ambig_errors = {:#?}\", ambig_errors);\n+\n+        let region_obligations = self.take_registered_region_obligations();\n+        let region_constraints = self.with_region_constraints(|region_constraints| {\n+            make_query_outlives(tcx, region_obligations, region_constraints)\n+        });\n+\n+        let certainty = if ambig_errors.is_empty() {\n+            Certainty::Proven\n+        } else {\n+            Certainty::Ambiguous\n+        };\n+\n+        Ok(QueryResult {\n+            var_values: inference_vars,\n+            region_constraints,\n+            certainty,\n+            value: answer,\n+        })\n+    }\n+\n+    /// Given the (canonicalized) result to a canonical query,\n+    /// instantiates the result so it can be used, plugging in the\n+    /// values from the canonical query. (Note that the result may\n+    /// have been ambiguous; you should check the certainty level of\n+    /// the query before applying this function.)\n+    ///\n+    /// To get a good understanding of what is happening here, check\n+    /// out the [chapter in the rustc guide][c].\n+    ///\n+    /// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html#processing-the-canonicalized-query-result\n+    pub fn instantiate_query_result_and_region_obligations<R>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: &CanonicalVarValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+    ) -> InferResult<'tcx, R>\n+    where\n+        R: Debug + TypeFoldable<'tcx>,\n+    {\n+        let InferOk {\n+            value: result_subst,\n+            mut obligations,\n+        } = self.query_result_substitution(cause, param_env, original_values, query_result)?;\n+\n+        obligations.extend(self.query_region_constraints_into_obligations(\n+            cause,\n+            param_env,\n+            &query_result.value.region_constraints,\n+            &result_subst,\n+        ));\n+\n+        let user_result: R =\n+            query_result.substitute_projected(self.tcx, &result_subst, |q_r| &q_r.value);\n+\n+        Ok(InferOk {\n+            value: user_result,\n+            obligations,\n+        })\n+    }\n+\n+    /// An alternative to\n+    /// `instantiate_query_result_and_region_obligations` that is more\n+    /// efficient for NLL. NLL is a bit more advanced in the\n+    /// \"transition to chalk\" than the rest of the compiler. During\n+    /// the NLL type check, all of the \"processing\" of types and\n+    /// things happens in queries -- the NLL checker itself is only\n+    /// interested in the region obligations (`'a: 'b` or `T: 'b`)\n+    /// that come out of these queries, which it wants to convert into\n+    /// MIR-based constraints and solve. Therefore, it is most\n+    /// convenient for the NLL Type Checker to **directly consume**\n+    /// the `QueryRegionConstraint` values that arise from doing a\n+    /// query. This is contrast to other parts of the compiler, which\n+    /// would prefer for those `QueryRegionConstraint` to be converted\n+    /// into the older infcx-style constraints (e.g., calls to\n+    /// `sub_regions` or `register_region_obligation`).\n+    ///\n+    /// Therefore, `instantiate_nll_query_result_and_region_obligations` performs the same\n+    /// basic operations as `instantiate_query_result_and_region_obligations` but\n+    /// it returns its result differently:\n+    ///\n+    /// - It creates a substitution `S` that maps from the original\n+    ///   query variables to the values computed in the query\n+    ///   result. If any errors arise, they are propagated back as an\n+    ///   `Err` result.\n+    /// - In the case of a successful substitution, we will append\n+    ///   `QueryRegionConstraint` values onto the\n+    ///   `output_query_region_constraints` vector for the solver to\n+    ///   use (if an error arises, some values may also be pushed, but\n+    ///   they should be ignored).\n+    /// - It **can happen** (though it rarely does currently) that\n+    ///   equating types and things will give rise to subobligations\n+    ///   that must be processed.  In this case, those subobligations\n+    ///   are propagated back in the return value.\n+    /// - Finally, the query result (of type `R`) is propagated back,\n+    ///   after applying the substitution `S`.\n+    pub fn instantiate_nll_query_result_and_region_obligations<R>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: &CanonicalVarValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+        output_query_region_constraints: &mut Vec<QueryRegionConstraint<'tcx>>,\n+    ) -> InferResult<'tcx, R>\n+    where\n+        R: Debug + TypeFoldable<'tcx>,\n+    {\n+        // In an NLL query, there should be no type variables in the\n+        // query, only region variables.\n+        debug_assert!(query_result.variables.iter().all(|v| match v.kind {\n+            CanonicalVarKind::Ty(_) => false,\n+            CanonicalVarKind::Region => true,\n+        }));\n+\n+        let result_subst =\n+            self.query_result_substitution_guess(cause, original_values, query_result);\n+\n+        // Compute `QueryRegionConstraint` values that unify each of\n+        // the original values `v_o` that was canonicalized into a\n+        // variable...\n+        let mut obligations = vec![];\n+\n+        for (index, original_value) in original_values.var_values.iter_enumerated() {\n+            // ...with the value `v_r` of that variable from the query.\n+            let result_value = query_result\n+                .substitute_projected(self.tcx, &result_subst, |v| &v.var_values[index]);\n+            match (original_value.unpack(), result_value.unpack()) {\n+                (UnpackedKind::Lifetime(ty::ReErased), UnpackedKind::Lifetime(ty::ReErased)) => {\n+                    // no action needed\n+                }\n+\n+                (UnpackedKind::Lifetime(v_o), UnpackedKind::Lifetime(v_r)) => {\n+                    // To make `v_o = v_r`, we emit `v_o: v_r` and `v_r: v_o`.\n+                    if v_o != v_r {\n+                        output_query_region_constraints\n+                            .push(ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)));\n+                        output_query_region_constraints\n+                            .push(ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)));\n+                    }\n+                }\n+\n+                (UnpackedKind::Type(v1), UnpackedKind::Type(v2)) => {\n+                    let ok = self.at(cause, param_env).eq(v1, v2)?;\n+                    obligations.extend(ok.into_obligations());\n+                }\n+\n+                _ => {\n+                    bug!(\n+                        \"kind mismatch, cannot unify {:?} and {:?}\",\n+                        original_value,\n+                        result_value\n+                    );\n+                }\n+            }\n+        }\n+\n+        // ...also include the other query region constraints from the query.\n+        output_query_region_constraints.reserve(query_result.value.region_constraints.len());\n+        for r_c in query_result.value.region_constraints.iter() {\n+            output_query_region_constraints.push(r_c.map_bound(|ty::OutlivesPredicate(k1, r2)| {\n+                let k1 = substitute_value(self.tcx, &result_subst, &k1);\n+                let r2 = substitute_value(self.tcx, &result_subst, &r2);\n+                ty::OutlivesPredicate(k1, r2)\n+            }));\n+        }\n+\n+        let user_result: R =\n+            query_result.substitute_projected(self.tcx, &result_subst, |q_r| &q_r.value);\n+\n+        Ok(InferOk {\n+            value: user_result,\n+            obligations,\n+        })\n+    }\n+\n+    /// Given the original values and the (canonicalized) result from\n+    /// computing a query, returns a substitution that can be applied\n+    /// to the query result to convert the result back into the\n+    /// original namespace.\n+    ///\n+    /// The substitution also comes accompanied with subobligations\n+    /// that arose from unification; these might occur if (for\n+    /// example) we are doing lazy normalization and the value\n+    /// assigned to a type variable is unified with an unnormalized\n+    /// projection.\n+    fn query_result_substitution<R>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: &CanonicalVarValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+    ) -> InferResult<'tcx, CanonicalVarValues<'tcx>>\n+    where\n+        R: Debug + TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"query_result_substitution(original_values={:#?}, query_result={:#?})\",\n+            original_values, query_result,\n+        );\n+\n+        let result_subst =\n+            self.query_result_substitution_guess(cause, original_values, query_result);\n+\n+        let obligations = self.unify_query_result_substitution_guess(\n+            cause,\n+            param_env,\n+            original_values,\n+            &result_subst,\n+            query_result,\n+        )?\n+            .into_obligations();\n+\n+        Ok(InferOk {\n+            value: result_subst,\n+            obligations,\n+        })\n+    }\n+\n+    /// Given the original values and the (canonicalized) result from\n+    /// computing a query, returns a **guess** at a substitution that\n+    /// can be applied to the query result to convert the result back\n+    /// into the original namespace. This is called a **guess**\n+    /// because it uses a quick heuristic to find the values for each\n+    /// canonical variable; if that quick heuristic fails, then we\n+    /// will instantiate fresh inference variables for each canonical\n+    /// variable instead. Therefore, the result of this method must be\n+    /// properly unified\n+    fn query_result_substitution_guess<R>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        original_values: &CanonicalVarValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+    ) -> CanonicalVarValues<'tcx>\n+    where\n+        R: Debug + TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"query_result_substitution_guess(original_values={:#?}, query_result={:#?})\",\n+            original_values, query_result,\n+        );\n+\n+        // Every canonical query result includes values for each of\n+        // the inputs to the query. Therefore, we begin by unifying\n+        // these values with the original inputs that were\n+        // canonicalized.\n+        let result_values = &query_result.value.var_values;\n+        assert_eq!(original_values.len(), result_values.len());\n+\n+        // Quickly try to find initial values for the canonical\n+        // variables in the result in terms of the query. We do this\n+        // by iterating down the values that the query gave to each of\n+        // the canonical inputs. If we find that one of those values\n+        // is directly equal to one of the canonical variables in the\n+        // result, then we can type the corresponding value from the\n+        // input. See the example above.\n+        let mut opt_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>> =\n+            IndexVec::from_elem_n(None, query_result.variables.len());\n+\n+        // In terms of our example above, we are iterating over pairs like:\n+        // [(?A, Vec<?0>), ('static, '?1), (?B, ?0)]\n+        for (original_value, result_value) in original_values.iter().zip(result_values) {\n+            match result_value.unpack() {\n+                UnpackedKind::Type(result_value) => {\n+                    // e.g., here `result_value` might be `?0` in the example above...\n+                    if let ty::TyInfer(ty::InferTy::CanonicalTy(index)) = result_value.sty {\n+                        // in which case we would set `canonical_vars[0]` to `Some(?U)`.\n+                        opt_values[index] = Some(original_value);\n+                    }\n+                }\n+                UnpackedKind::Lifetime(result_value) => {\n+                    // e.g., here `result_value` might be `'?1` in the example above...\n+                    if let &ty::RegionKind::ReCanonical(index) = result_value {\n+                        // in which case we would set `canonical_vars[0]` to `Some('static)`.\n+                        opt_values[index] = Some(original_value);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Create a result substitution: if we found a value for a\n+        // given variable in the loop above, use that. Otherwise, use\n+        // a fresh inference variable.\n+        let result_subst = CanonicalVarValues {\n+            var_values: query_result\n+                .variables\n+                .iter()\n+                .enumerate()\n+                .map(|(index, info)| match opt_values[CanonicalVar::new(index)] {\n+                    Some(k) => k,\n+                    None => self.fresh_inference_var_for_canonical_var(cause.span, *info),\n+                })\n+                .collect(),\n+        };\n+\n+        result_subst\n+    }\n+\n+    /// Given a \"guess\" at the values for the canonical variables in\n+    /// the input, try to unify with the *actual* values found in the\n+    /// query result.  Often, but not always, this is a no-op, because\n+    /// we already found the mapping in the \"guessing\" step.\n+    ///\n+    /// See also: `query_result_substitution_guess`\n+    fn unify_query_result_substitution_guess<R>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: &CanonicalVarValues<'tcx>,\n+        result_subst: &CanonicalVarValues<'tcx>,\n+        query_result: &Canonical<'tcx, QueryResult<'tcx, R>>,\n+    ) -> InferResult<'tcx, ()>\n+    where\n+        R: Debug + TypeFoldable<'tcx>,\n+    {\n+        // A closure that yields the result value for the given\n+        // canonical variable; this is taken from\n+        // `query_result.var_values` after applying the substitution\n+        // `result_subst`.\n+        let substituted_query_result = |index: CanonicalVar| -> Kind<'tcx> {\n+            query_result.substitute_projected(self.tcx, &result_subst, |v| &v.var_values[index])\n+        };\n+\n+        // Unify the original value for each variable with the value\n+        // taken from `query_result` (after applying `result_subst`).\n+        Ok(self.unify_canonical_vars(cause, param_env, original_values, substituted_query_result)?)\n+    }\n+\n+    /// Converts the region constraints resulting from a query into an\n+    /// iterator of obligations.\n+    fn query_region_constraints_into_obligations<'a>(\n+        &'a self,\n+        cause: &'a ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        unsubstituted_region_constraints: &'a [QueryRegionConstraint<'tcx>],\n+        result_subst: &'a CanonicalVarValues<'tcx>,\n+    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a {\n+        Box::new(\n+            unsubstituted_region_constraints\n+                .iter()\n+                .map(move |constraint| {\n+                    let ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n+                    let k1 = substitute_value(self.tcx, result_subst, k1);\n+                    let r2 = substitute_value(self.tcx, result_subst, r2);\n+                    match k1.unpack() {\n+                        UnpackedKind::Lifetime(r1) => Obligation::new(\n+                            cause.clone(),\n+                            param_env,\n+                            ty::Predicate::RegionOutlives(ty::Binder::dummy(\n+                                ty::OutlivesPredicate(r1, r2),\n+                            )),\n+                        ),\n+\n+                        UnpackedKind::Type(t1) => Obligation::new(\n+                            cause.clone(),\n+                            param_env,\n+                            ty::Predicate::TypeOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n+                                t1, r2,\n+                            ))),\n+                        ),\n+                    }\n+                }),\n+        ) as Box<dyn Iterator<Item = _>>\n+    }\n+\n+    /// Given two sets of values for the same set of canonical variables, unify them.\n+    /// The second set is produced lazilly by supplying indices from the first set.\n+    fn unify_canonical_vars(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        variables1: &CanonicalVarValues<'tcx>,\n+        variables2: impl Fn(CanonicalVar) -> Kind<'tcx>,\n+    ) -> InferResult<'tcx, ()> {\n+        self.commit_if_ok(|_| {\n+            let mut obligations = vec![];\n+            for (index, value1) in variables1.var_values.iter_enumerated() {\n+                let value2 = variables2(index);\n+\n+                match (value1.unpack(), value2.unpack()) {\n+                    (UnpackedKind::Type(v1), UnpackedKind::Type(v2)) => {\n+                        obligations\n+                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                    }\n+                    (\n+                        UnpackedKind::Lifetime(ty::ReErased),\n+                        UnpackedKind::Lifetime(ty::ReErased),\n+                    ) => {\n+                        // no action needed\n+                    }\n+                    (UnpackedKind::Lifetime(v1), UnpackedKind::Lifetime(v2)) => {\n+                        obligations\n+                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                    }\n+                    _ => {\n+                        bug!(\"kind mismatch, cannot unify {:?} and {:?}\", value1, value2,);\n+                    }\n+                }\n+            }\n+            Ok(InferOk {\n+                value: (),\n+                obligations,\n+            })\n+        })\n+    }\n+}\n+\n+/// Given the region obligations and constraints scraped from the infcx,\n+/// creates query region constraints.\n+pub fn make_query_outlives<'tcx>(\n+    tcx: TyCtxt<'_, '_, 'tcx>,\n+    region_obligations: Vec<(ast::NodeId, RegionObligation<'tcx>)>,\n+    region_constraints: &RegionConstraintData<'tcx>,\n+) -> Vec<QueryRegionConstraint<'tcx>> {\n+    let RegionConstraintData {\n+        constraints,\n+        verifys,\n+        givens,\n+    } = region_constraints;\n+\n+    assert!(verifys.is_empty());\n+    assert!(givens.is_empty());\n+\n+    let mut outlives: Vec<_> = constraints\n+            .into_iter()\n+            .map(|(k, _)| match *k {\n+                // Swap regions because we are going from sub (<=) to outlives\n+                // (>=).\n+                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n+                    tcx.mk_region(ty::ReVar(v2)).into(),\n+                    tcx.mk_region(ty::ReVar(v1)),\n+                ),\n+                Constraint::VarSubReg(v1, r2) => {\n+                    ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n+                }\n+                Constraint::RegSubVar(r1, v2) => {\n+                    ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n+                }\n+                Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n+            })\n+            .map(ty::Binder::dummy) // no bound regions in the code above\n+            .collect();\n+\n+    outlives.extend(\n+        region_obligations\n+            .into_iter()\n+            .map(|(_, r_o)| ty::OutlivesPredicate(r_o.sup_type.into(), r_o.sub_region))\n+            .map(ty::Binder::dummy), // no bound regions in the code above\n+    );\n+\n+    outlives\n+}"}, {"sha": "5bc1ae689a5d2d0cc097ffb41643283edbdcfcea", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains code to substitute new values into a\n+//! `Canonical<'tcx, T>`.\n+//!\n+//! For an overview of what canonicaliation is and how it fits into\n+//! rustc, check out the [chapter in the rustc guide][c].\n+//!\n+//! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n+\n+use infer::canonical::{Canonical, CanonicalVarValues};\n+use ty::fold::{TypeFoldable, TypeFolder};\n+use ty::subst::UnpackedKind;\n+use ty::{self, Ty, TyCtxt, TypeFlags};\n+\n+impl<'tcx, V> Canonical<'tcx, V> {\n+    /// Instantiate the wrapped value, replacing each canonical value\n+    /// with the value given in `var_values`.\n+    pub fn substitute(&self, tcx: TyCtxt<'_, '_, 'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n+    where\n+        V: TypeFoldable<'tcx>,\n+    {\n+        self.substitute_projected(tcx, var_values, |value| value)\n+    }\n+\n+    /// Allows one to apply a substitute to some subset of\n+    /// `self.value`. Invoke `projection_fn` with `self.value` to get\n+    /// a value V that is expressed in terms of the same canonical\n+    /// variables bound in `self` (usually this extracts from subset\n+    /// of `self`). Apply the substitution `var_values` to this value\n+    /// V, replacing each of the canonical variables.\n+    pub fn substitute_projected<T>(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        var_values: &CanonicalVarValues<'tcx>,\n+        projection_fn: impl FnOnce(&V) -> &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        assert_eq!(self.variables.len(), var_values.var_values.len());\n+        let value = projection_fn(&self.value);\n+        substitute_value(tcx, var_values, value)\n+    }\n+}\n+\n+/// Substitute the values from `var_values` into `value`. `var_values`\n+/// must be values for the set of canonical variables that appear in\n+/// `value`.\n+pub(super) fn substitute_value<'a, 'tcx, T>(\n+    tcx: TyCtxt<'_, '_, 'tcx>,\n+    var_values: &CanonicalVarValues<'tcx>,\n+    value: &'a T,\n+) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    if var_values.var_values.is_empty() {\n+        debug_assert!(!value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS));\n+        value.clone()\n+    } else if !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n+        value.clone()\n+    } else {\n+        value.fold_with(&mut CanonicalVarValuesSubst { tcx, var_values })\n+    }\n+}\n+\n+struct CanonicalVarValuesSubst<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    var_values: &'cx CanonicalVarValues<'tcx>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for CanonicalVarValuesSubst<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.sty {\n+            ty::TyInfer(ty::InferTy::CanonicalTy(c)) => {\n+                match self.var_values.var_values[c].unpack() {\n+                    UnpackedKind::Type(ty) => ty,\n+                    r => bug!(\"{:?} is a type but value is {:?}\", c, r),\n+                }\n+            }\n+            _ => {\n+                if !t.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n+                    t\n+                } else {\n+                    t.super_fold_with(self)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match r {\n+            ty::RegionKind::ReCanonical(c) => match self.var_values.var_values[*c].unpack() {\n+                UnpackedKind::Lifetime(l) => l,\n+                r => bug!(\"{:?} is a region but value is {:?}\", c, r),\n+            },\n+            _ => r.super_fold_with(self),\n+        }\n+    }\n+}"}, {"sha": "5b5ae6473f84011cdf3215cc4d3a7e8e532d19f1", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -27,7 +27,7 @@ use ty::{self, Ty, TyCtxt, GenericParamDefKind};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::TypeFoldable;\n use ty::relate::RelateResult;\n-use traits::{self, ObligationCause, PredicateObligations};\n+use traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n use rustc_data_structures::unify as ut;\n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::collections::BTreeMap;\n@@ -485,6 +485,19 @@ impl<'tcx, T> InferOk<'tcx, T> {\n     pub fn unit(self) -> InferOk<'tcx, ()> {\n         InferOk { value: (), obligations: self.obligations }\n     }\n+\n+    /// Extract `value`, registering any obligations into `fulfill_cx`\n+    pub fn into_value_registering_obligations(\n+        self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        fulfill_cx: &mut impl TraitEngine<'tcx>,\n+    ) -> T {\n+        let InferOk { value, obligations } = self;\n+        for obligation in obligations {\n+            fulfill_cx.register_predicate_obligation(infcx, obligation);\n+        }\n+        value\n+    }\n }\n \n impl<'tcx> InferOk<'tcx, ()> {"}, {"sha": "57abdd18d353cb52a5084480b76726d3ddc2b27d", "filename": "src/librustc/infer/outlives/bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -11,7 +11,7 @@\n use infer::InferCtxt;\n use syntax::ast;\n use syntax::codemap::Span;\n-use traits::{FulfillmentContext, TraitEngine};\n+use traits::{FulfillmentContext, TraitEngine, TraitEngineExt};\n use ty::{self, Ty, TypeFoldable};\n use ty::outlives::Component;\n use ty::wf;"}, {"sha": "93079b046690c509aa5028d11a462a40f1102722", "filename": "src/librustc/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -13,4 +13,4 @@\n pub mod env;\n pub mod free_region_map;\n pub mod bounds;\n-mod obligations;\n+pub mod obligations;"}, {"sha": "07286f1250cd38f4063dce51754e7b205a96aee9", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 109, "deletions": 65, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -71,11 +71,11 @@\n \n use hir::def_id::DefId;\n use infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n+use syntax::ast;\n use traits;\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::subst::{Subst, Substs};\n use ty::outlives::Component;\n-use syntax::ast;\n+use ty::subst::{Subst, Substs};\n+use ty::{self, Ty, TyCtxt, TypeFoldable};\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Registers that the given region obligation must be resolved\n@@ -90,8 +90,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     ) {\n         debug!(\n             \"register_region_obligation(body_id={:?}, obligation={:?})\",\n-            body_id,\n-            obligation\n+            body_id, obligation\n         );\n \n         self.region_obligations\n@@ -100,13 +99,8 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// Trait queries just want to pass back type obligations \"as is\"\n-    pub fn take_registered_region_obligations(\n-        &self,\n-    ) -> Vec<(ast::NodeId, RegionObligation<'tcx>)> {\n-        ::std::mem::replace(\n-            &mut *self.region_obligations.borrow_mut(),\n-            vec![],\n-        )\n+    pub fn take_registered_region_obligations(&self) -> Vec<(ast::NodeId, RegionObligation<'tcx>)> {\n+        ::std::mem::replace(&mut *self.region_obligations.borrow_mut(), vec![])\n     }\n \n     /// Process the region obligations that must be proven (during\n@@ -165,8 +159,13 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n \n-        let outlives =\n-            TypeOutlives::new(self, region_bound_pairs, implicit_region_bound, param_env);\n+        let outlives = &mut TypeOutlives::new(\n+            self,\n+            self.tcx,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+        );\n \n         for RegionObligation {\n             sup_type,\n@@ -176,16 +175,14 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         {\n             debug!(\n                 \"process_registered_region_obligations: sup_type={:?} sub_region={:?} cause={:?}\",\n-                sup_type,\n-                sub_region,\n-                cause\n+                sup_type, sub_region, cause\n             );\n \n-            let origin = SubregionOrigin::from_obligation_cause(\n-                &cause,\n-                || infer::RelateParamBound(cause.span, sup_type),\n-            );\n+            let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n+                infer::RelateParamBound(cause.span, sup_type)\n+            });\n \n+            let sup_type = self.resolve_type_vars_if_possible(&sup_type);\n             outlives.type_must_outlive(origin, sup_type, sub_region);\n         }\n     }\n@@ -201,31 +198,68 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n     ) {\n-        let outlives =\n-            TypeOutlives::new(self, region_bound_pairs, implicit_region_bound, param_env);\n+        let outlives = &mut TypeOutlives::new(\n+            self,\n+            self.tcx,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+        );\n+        let ty = self.resolve_type_vars_if_possible(&ty);\n         outlives.type_must_outlive(origin, ty, region);\n     }\n }\n \n-#[must_use] // you ought to invoke `into_accrued_obligations` when you are done =)\n-struct TypeOutlives<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+/// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n+/// obligation into a series of `'a: 'b` constraints and \"verifys\", as\n+/// described on the module comment. The final constraints are emitted\n+/// via a \"delegate\" of type `D` -- this is usually the `infcx`, which\n+/// accrues them into the `region_obligations` code, but for NLL we\n+/// use something else.\n+pub struct TypeOutlives<'cx, 'gcx: 'tcx, 'tcx: 'cx, D>\n+where\n+    D: TypeOutlivesDelegate<'tcx>,\n+{\n     // See the comments on `process_registered_region_obligations` for the meaning\n     // of these fields.\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    delegate: D,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n-    fn new(\n-        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+pub trait TypeOutlivesDelegate<'tcx> {\n+    fn push_sub_region_constraint(\n+        &mut self,\n+        origin: SubregionOrigin<'tcx>,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    );\n+\n+    fn push_verify(\n+        &mut self,\n+        origin: SubregionOrigin<'tcx>,\n+        kind: GenericKind<'tcx>,\n+        a: ty::Region<'tcx>,\n+        bound: VerifyBound<'tcx>,\n+    );\n+}\n+\n+impl<'cx, 'gcx, 'tcx, D> TypeOutlives<'cx, 'gcx, 'tcx, D>\n+where\n+    D: TypeOutlivesDelegate<'tcx>,\n+{\n+    pub fn new(\n+        delegate: D,\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n         region_bound_pairs: &'cx [(ty::Region<'tcx>, GenericKind<'tcx>)],\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         Self {\n-            infcx,\n+            delegate,\n+            tcx,\n             region_bound_pairs,\n             implicit_region_bound,\n             param_env,\n@@ -240,33 +274,25 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n     /// - `origin`, the reason we need this constraint\n     /// - `ty`, the type `T`\n     /// - `region`, the region `'a`\n-    fn type_must_outlive(\n-        &self,\n+    pub fn type_must_outlive(\n+        &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n     ) {\n-        let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n-\n         debug!(\n             \"type_must_outlive(ty={:?}, region={:?}, origin={:?})\",\n-            ty,\n-            region,\n-            origin\n+            ty, region, origin\n         );\n \n         assert!(!ty.has_escaping_regions());\n \n-        let components = self.tcx().outlives_components(ty);\n+        let components = self.tcx.outlives_components(ty);\n         self.components_must_outlive(origin, components, region);\n     }\n \n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n-        self.infcx.tcx\n-    }\n-\n     fn components_must_outlive(\n-        &self,\n+        &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         components: Vec<Component<'tcx>>,\n         region: ty::Region<'tcx>,\n@@ -275,7 +301,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n             let origin = origin.clone();\n             match component {\n                 Component::Region(region1) => {\n-                    self.infcx.sub_regions(origin, region, region1);\n+                    self.delegate.push_sub_region_constraint(origin, region, region1);\n                 }\n                 Component::Param(param_ty) => {\n                     self.param_ty_must_outlive(origin, region, param_ty);\n@@ -290,7 +316,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n                     // ignore this, we presume it will yield an error\n                     // later, since if a type variable is not resolved by\n                     // this point it never will be\n-                    self.infcx.tcx.sess.delay_span_bug(\n+                    self.tcx.sess.delay_span_bug(\n                         origin.span(),\n                         &format!(\"unresolved inference variable in outlives: {:?}\", v),\n                     );\n@@ -300,35 +326,31 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n     }\n \n     fn param_ty_must_outlive(\n-        &self,\n+        &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n         param_ty: ty::ParamTy,\n     ) {\n         debug!(\n             \"param_ty_must_outlive(region={:?}, param_ty={:?}, origin={:?})\",\n-            region,\n-            param_ty,\n-            origin\n+            region, param_ty, origin\n         );\n \n         let verify_bound = self.param_bound(param_ty);\n         let generic = GenericKind::Param(param_ty);\n-        self.infcx\n-            .verify_generic_bound(origin, generic, region, verify_bound);\n+        self.delegate\n+            .push_verify(origin, generic, region, verify_bound);\n     }\n \n     fn projection_must_outlive(\n-        &self,\n+        &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         region: ty::Region<'tcx>,\n         projection_ty: ty::ProjectionTy<'tcx>,\n     ) {\n         debug!(\n             \"projection_must_outlive(region={:?}, projection_ty={:?}, origin={:?})\",\n-            region,\n-            projection_ty,\n-            origin\n+            region, projection_ty, origin\n         );\n \n         // This case is thorny for inference. The fundamental problem is\n@@ -382,7 +404,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n             }\n \n             for r in projection_ty.substs.regions() {\n-                self.infcx.sub_regions(origin.clone(), region, r);\n+                self.delegate.push_sub_region_constraint(origin.clone(), region, r);\n             }\n \n             return;\n@@ -408,7 +430,8 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n                 .any(|r| env_bounds.contains(&r))\n             {\n                 debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n-                self.infcx.sub_regions(origin.clone(), region, unique_bound);\n+                self.delegate\n+                    .push_sub_region_constraint(origin.clone(), region, unique_bound);\n                 return;\n             }\n         }\n@@ -420,8 +443,8 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         // even though a satisfactory solution exists.\n         let verify_bound = self.projection_bound(env_bounds, projection_ty);\n         let generic = GenericKind::Projection(projection_ty);\n-        self.infcx\n-            .verify_generic_bound(origin, generic.clone(), region, verify_bound);\n+        self.delegate\n+            .push_verify(origin, generic.clone(), region, verify_bound);\n     }\n \n     fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n@@ -469,12 +492,11 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n     ) -> VerifyBound<'tcx> {\n         debug!(\n             \"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n-            declared_bounds,\n-            projection_ty\n+            declared_bounds, projection_ty\n         );\n \n         // see the extensive comment in projection_must_outlive\n-        let ty = self.infcx\n+        let ty = self\n             .tcx\n             .mk_projection(projection_ty.item_def_id, projection_ty.substs);\n         let recursive_bound = self.recursive_type_bound(ty);\n@@ -507,7 +529,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         &self,\n         generic: GenericKind<'tcx>,\n     ) -> Vec<ty::Region<'tcx>> {\n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n \n         // To start, collect bounds from user environment. Note that\n         // parameter environments are already elaborated, so we don't\n@@ -559,7 +581,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         debug!(\"projection_bounds(projection_ty={:?})\", projection_ty);\n         let mut bounds = self.region_bounds_declared_on_associated_item(projection_ty.item_def_id);\n         for r in &mut bounds {\n-            *r = r.subst(self.tcx(), projection_ty.substs);\n+            *r = r.subst(self.tcx, projection_ty.substs);\n         }\n         bounds\n     }\n@@ -598,7 +620,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         &self,\n         assoc_item_def_id: DefId,\n     ) -> Vec<ty::Region<'tcx>> {\n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n         let assoc_item = tcx.associated_item(assoc_item_def_id);\n         let trait_def_id = assoc_item.container.assert_trait();\n         let trait_predicates = tcx.predicates_of(trait_def_id);\n@@ -634,3 +656,25 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n             .collect()\n     }\n }\n+\n+impl<'cx, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx> for &'cx InferCtxt<'cx, 'gcx, 'tcx> {\n+    fn push_sub_region_constraint(\n+        &mut self,\n+        origin: SubregionOrigin<'tcx>,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) {\n+        self.sub_regions(origin, a, b)\n+    }\n+\n+    fn push_verify(\n+        &mut self,\n+        origin: SubregionOrigin<'tcx>,\n+        kind: GenericKind<'tcx>,\n+        a: ty::Region<'tcx>,\n+        bound: VerifyBound<'tcx>,\n+    ) {\n+        self.verify_generic_bound(origin, kind, a, bound)\n+    }\n+}\n+"}, {"sha": "acbf5392cf54c0b7f633d2bc4c6e405b44d39ab3", "filename": "src/librustc/traits/engine.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -16,56 +16,64 @@ use super::{FulfillmentContext, FulfillmentError};\n use super::{ObligationCause, PredicateObligation};\n \n pub trait TraitEngine<'tcx>: 'tcx {\n-    fn normalize_projection_type<'a, 'gcx>(\n+    fn normalize_projection_type(\n         &mut self,\n-        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         projection_ty: ty::ProjectionTy<'tcx>,\n         cause: ObligationCause<'tcx>,\n     ) -> Ty<'tcx>;\n \n-    fn register_bound<'a, 'gcx>(\n+    fn register_bound(\n         &mut self,\n-        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         ty: Ty<'tcx>,\n         def_id: DefId,\n         cause: ObligationCause<'tcx>,\n     );\n \n-    fn register_predicate_obligation<'a, 'gcx>(\n+    fn register_predicate_obligation(\n         &mut self,\n-        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         obligation: PredicateObligation<'tcx>,\n     );\n \n-    fn select_all_or_error<'a, 'gcx>(\n+    fn select_all_or_error(\n         &mut self,\n-        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n     ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n \n-    fn select_where_possible<'a, 'gcx>(\n+    fn select_where_possible(\n         &mut self,\n-        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n     ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n \n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>>;\n }\n \n-impl<'a, 'gcx, 'tcx> dyn TraitEngine<'tcx> {\n-    pub fn new(_tcx: TyCtxt<'_, '_, 'tcx>) -> Box<Self> {\n-        Box::new(FulfillmentContext::new())\n-    }\n+pub trait TraitEngineExt<'tcx> {\n+    fn register_predicate_obligations(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n+    );\n+}\n \n-    pub fn register_predicate_obligations<I>(\n+impl<T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n+    fn register_predicate_obligations(\n         &mut self,\n-        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-        obligations: I,\n-    ) where\n-        I: IntoIterator<Item = PredicateObligation<'tcx>>,\n-    {\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n+    ) {\n         for obligation in obligations {\n             self.register_predicate_obligation(infcx, obligation);\n         }\n     }\n }\n+\n+impl dyn TraitEngine<'tcx> {\n+    pub fn new(_tcx: TyCtxt<'_, '_, 'tcx>) -> Box<Self> {\n+        Box::new(FulfillmentContext::new())\n+    }\n+}"}, {"sha": "b3f56d4de65340971f4372bc9f954621a4979942", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -21,7 +21,7 @@ use middle::const_val::{ConstEvalErr, ErrKind};\n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n-use super::engine::TraitEngine;\n+use super::engine::{TraitEngine, TraitEngineExt};\n use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation, Obligation};\n use super::project;\n@@ -86,16 +86,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n-    pub fn register_predicate_obligations<I>(&mut self,\n-                                             infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                             obligations: I)\n-        where I: IntoIterator<Item = PredicateObligation<'tcx>>\n-    {\n-        for obligation in obligations {\n-            self.register_predicate_obligation(infcx, obligation);\n-        }\n-    }\n-\n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n     fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)"}, {"sha": "c7e55fa574f94cf5ca0e28686a18535e37e2bbc6", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -27,7 +27,6 @@ use ty::subst::Substs;\n use ty::{self, AdtKind, Slice, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n use ty::fold::{TypeFolder, TypeFoldable, TypeVisitor};\n-use infer::canonical::{Canonical, Canonicalize};\n use infer::{InferCtxt};\n \n use rustc_data_structures::sync::Lrc;\n@@ -48,7 +47,7 @@ pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::{SpecializesCache, find_associated_item};\n-pub use self::engine::TraitEngine;\n+pub use self::engine::{TraitEngine, TraitEngineExt};\n pub use self::util::elaborate_predicates;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n@@ -1015,18 +1014,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     };\n }\n \n-impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ty::ParamEnvAnd<'tcx, Goal<'tcx>> {\n-    // we ought to intern this, but I'm too lazy just now\n-    type Canonicalized = Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>;\n-\n-    fn intern(\n-        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n-        value: Canonical<'gcx, Self::Lifted>,\n-    ) -> Self::Canonicalized {\n-        value\n-    }\n-}\n-\n pub trait ExClauseFold<'tcx>\n where\n     Self: chalk_engine::context::Context + Clone,\n@@ -1053,20 +1040,3 @@ where\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     ) -> Option<Self::LiftedExClause>;\n }\n-\n-impl<'gcx: 'tcx, 'tcx, C> Canonicalize<'gcx, 'tcx> for chalk_engine::ExClause<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: ExClauseLift<'gcx> + ExClauseFold<'tcx>,\n-    C::Substitution: Clone,\n-    C::RegionConstraint: Clone,\n-{\n-    type Canonicalized = Canonical<'gcx, C::LiftedExClause>;\n-\n-    fn intern(\n-        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n-        value: Canonical<'gcx, Self::Lifted>,\n-    ) -> Self::Canonicalized {\n-        value\n-    }\n-}"}, {"sha": "2aaa32aa032025f0d3fa0601b065c8b21014abbb", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -9,13 +9,11 @@\n // except according to those terms.\n \n use infer::at::At;\n-use infer::canonical::{Canonical, Canonicalize, QueryResult};\n use infer::InferOk;\n use std::iter::FromIterator;\n-use traits::query::CanonicalTyGoal;\n-use ty::{self, Ty, TyCtxt};\n+use syntax::codemap::Span;\n use ty::subst::Kind;\n-use rustc_data_structures::sync::Lrc;\n+use ty::{self, Ty, TyCtxt};\n \n impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n     /// Given a type `ty` of some value being dropped, computes a set\n@@ -45,7 +43,10 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n         // any destructor.\n         let tcx = self.infcx.tcx;\n         if trivial_dropck_outlives(tcx, ty) {\n-            return InferOk { value: vec![], obligations: vec![] };\n+            return InferOk {\n+                value: vec![],\n+                obligations: vec![],\n+            };\n         }\n \n         let gcx = tcx.global_tcx();\n@@ -54,28 +55,15 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n         debug!(\"c_ty = {:?}\", c_ty);\n         match &gcx.dropck_outlives(c_ty) {\n             Ok(result) if result.is_proven() => {\n-                match self.infcx.instantiate_query_result(\n+                match self.infcx.instantiate_query_result_and_region_obligations(\n                     self.cause,\n                     self.param_env,\n                     &orig_values,\n                     result,\n                 ) {\n-                    Ok(InferOk {\n-                        value: DropckOutlivesResult { kinds, overflows },\n-                        obligations,\n-                    }) => {\n-                        for overflow_ty in overflows.into_iter().take(1) {\n-                            let mut err = struct_span_err!(\n-                                tcx.sess,\n-                                span,\n-                                E0320,\n-                                \"overflow while adding drop-check rules for {}\",\n-                                self.infcx.resolve_type_vars_if_possible(&ty),\n-                            );\n-                            err.note(&format!(\"overflowed on {}\", overflow_ty));\n-                            err.emit();\n-                        }\n-\n+                    Ok(InferOk { value, obligations }) => {\n+                        let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n+                        let kinds = value.into_kinds_reporting_overflows(tcx, span, ty);\n                         return InferOk {\n                             value: kinds,\n                             obligations,\n@@ -102,12 +90,44 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, Default)]\n pub struct DropckOutlivesResult<'tcx> {\n     pub kinds: Vec<Kind<'tcx>>,\n     pub overflows: Vec<Ty<'tcx>>,\n }\n \n+impl<'tcx> DropckOutlivesResult<'tcx> {\n+    pub fn report_overflows(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        span: Span,\n+        ty: Ty<'tcx>,\n+    ) {\n+        for overflow_ty in self.overflows.iter().take(1) {\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0320,\n+                \"overflow while adding drop-check rules for {}\",\n+                ty,\n+            );\n+            err.note(&format!(\"overflowed on {}\", overflow_ty));\n+            err.emit();\n+        }\n+    }\n+\n+    pub fn into_kinds_reporting_overflows(\n+        self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        span: Span,\n+        ty: Ty<'tcx>,\n+    ) -> Vec<Kind<'tcx>> {\n+        self.report_overflows(tcx, span, ty);\n+        let DropckOutlivesResult { kinds, overflows: _ } = self;\n+        kinds\n+    }\n+}\n+\n /// A set of constraints that need to be satisfied in order for\n /// a type to be valid for destruction.\n #[derive(Clone, Debug)]\n@@ -153,17 +173,6 @@ impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx> {\n         result\n     }\n }\n-impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ty::ParamEnvAnd<'tcx, Ty<'tcx>> {\n-    type Canonicalized = CanonicalTyGoal<'gcx>;\n-\n-    fn intern(\n-        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n-        value: Canonical<'gcx, Self::Lifted>,\n-    ) -> Self::Canonicalized {\n-        value\n-    }\n-}\n-\n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for DropckOutlivesResult<'tcx> {\n         kinds, overflows\n@@ -181,18 +190,6 @@ impl_stable_hash_for!(struct DropckOutlivesResult<'tcx> {\n     kinds, overflows\n });\n \n-impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for QueryResult<'tcx, DropckOutlivesResult<'tcx>> {\n-    // we ought to intern this, but I'm too lazy just now\n-    type Canonicalized = Lrc<Canonical<'gcx, QueryResult<'gcx, DropckOutlivesResult<'gcx>>>>;\n-\n-    fn intern(\n-        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n-        value: Canonical<'gcx, Self::Lifted>,\n-    ) -> Self::Canonicalized {\n-        Lrc::new(value)\n-    }\n-}\n-\n impl_stable_hash_for!(struct DtorckConstraint<'tcx> {\n     outlives,\n     dtorck_types,\n@@ -210,7 +207,7 @@ impl_stable_hash_for!(struct DtorckConstraint<'tcx> {\n ///\n /// Note also that `needs_drop` requires a \"global\" type (i.e., one\n /// with erased regions), but this funtcion does not.\n-fn trivial_dropck_outlives<'cx, 'tcx>(tcx: TyCtxt<'cx, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         // None of these types have a destructor and hence they do not\n         // require anything in particular to outlive the dtor's"}, {"sha": "c81d1123d42af045f435f5fb9f5ca3da430e070c", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -9,11 +9,8 @@\n // except according to those terms.\n \n use infer::InferCtxt;\n-use infer::canonical::{Canonical, Canonicalize};\n use traits::{EvaluationResult, PredicateObligation, SelectionContext,\n              TraitQueryMode, OverflowError};\n-use traits::query::CanonicalPredicateGoal;\n-use ty::{ParamEnvAnd, Predicate, TyCtxt};\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Evaluates whether the predicate can be satisfied (by any means)\n@@ -57,14 +54,3 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n }\n-\n-impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ParamEnvAnd<'tcx, Predicate<'tcx>> {\n-    type Canonicalized = CanonicalPredicateGoal<'gcx>;\n-\n-    fn intern(\n-        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n-        value: Canonical<'gcx, Self::Lifted>,\n-    ) -> Self::Canonicalized {\n-        value\n-    }\n-}"}, {"sha": "54b67edb1360b91d1d1fe3dab4433b6f4ef5c667", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -16,12 +16,14 @@\n //! `librustc_traits`.\n \n use infer::canonical::Canonical;\n+use ty::error::TypeError;\n use ty::{self, Ty};\n \n pub mod dropck_outlives;\n pub mod evaluate_obligation;\n pub mod normalize;\n pub mod normalize_erasing_regions;\n+pub mod type_op;\n \n pub type CanonicalProjectionGoal<'tcx> =\n     Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::ProjectionTy<'tcx>>>;\n@@ -31,9 +33,27 @@ pub type CanonicalTyGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n pub type CanonicalPredicateGoal<'tcx> =\n     Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::Predicate<'tcx>>>;\n \n+pub type CanonicalTypeOpEqGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::eq::Eq<'tcx>>>;\n+\n+pub type CanonicalTypeOpSubtypeGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::subtype::Subtype<'tcx>>>;\n+\n+pub type CanonicalTypeOpProvePredicateGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::prove_predicate::ProvePredicate<'tcx>>>;\n+\n+pub type CanonicalTypeOpNormalizeGoal<'tcx, T> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::normalize::Normalize<T>>>;\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct NoSolution;\n \n pub type Fallible<T> = Result<T, NoSolution>;\n \n+impl<'tcx> From<TypeError<'tcx>> for NoSolution {\n+    fn from(_: TypeError<'tcx>) -> NoSolution {\n+        NoSolution\n+    }\n+}\n+\n impl_stable_hash_for!(struct NoSolution { });"}, {"sha": "8d10195941e0d28e38894a149d05715c892d9ceb", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -14,12 +14,9 @@\n \n use infer::{InferCtxt, InferOk};\n use infer::at::At;\n-use infer::canonical::{Canonical, Canonicalize, QueryResult};\n use middle::const_val::ConstVal;\n use mir::interpret::GlobalId;\n-use rustc_data_structures::sync::Lrc;\n use traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n-use traits::query::CanonicalProjectionGoal;\n use traits::project::Normalized;\n use ty::{self, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n@@ -163,7 +160,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                             return ty;\n                         }\n \n-                        match self.infcx.instantiate_query_result(\n+                        match self.infcx.instantiate_query_result_and_region_obligations(\n                             self.cause,\n                             self.param_env,\n                             &orig_values,\n@@ -251,29 +248,6 @@ BraceStructLiftImpl! {\n     }\n }\n \n-impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ty::ParamEnvAnd<'tcx, ty::ProjectionTy<'tcx>> {\n-    type Canonicalized = CanonicalProjectionGoal<'gcx>;\n-\n-    fn intern(\n-        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n-        value: Canonical<'gcx, Self::Lifted>,\n-    ) -> Self::Canonicalized {\n-        value\n-    }\n-}\n-\n-impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for QueryResult<'tcx, NormalizationResult<'tcx>> {\n-    // we ought to intern this, but I'm too lazy just now\n-    type Canonicalized = Lrc<Canonical<'gcx, QueryResult<'gcx, NormalizationResult<'gcx>>>>;\n-\n-    fn intern(\n-        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n-        value: Canonical<'gcx, Self::Lifted>,\n-    ) -> Self::Canonicalized {\n-        Lrc::new(value)\n-    }\n-}\n-\n impl_stable_hash_for!(struct NormalizationResult<'tcx> {\n     normalized_ty\n });"}, {"sha": "3d10ce805853d973b0c8f3cd870d9dcecbaad8bb", "filename": "src/librustc/traits/query/type_op/custom.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::{InferCtxt, InferOk};\n+use std::fmt;\n+use traits::query::Fallible;\n+\n+use infer::canonical::query_result;\n+use infer::canonical::QueryRegionConstraint;\n+use std::rc::Rc;\n+use syntax::codemap::DUMMY_SP;\n+use traits::{ObligationCause, TraitEngine, TraitEngineExt};\n+\n+pub struct CustomTypeOp<F, G> {\n+    closure: F,\n+    description: G,\n+}\n+\n+impl<F, G> CustomTypeOp<F, G> {\n+    pub fn new<'gcx, 'tcx, R>(closure: F, description: G) -> Self\n+    where\n+        F: FnOnce(&InferCtxt<'_, 'gcx, 'tcx>) -> Fallible<InferOk<'tcx, R>>,\n+        G: Fn() -> String,\n+    {\n+        CustomTypeOp {\n+            closure,\n+            description,\n+        }\n+    }\n+}\n+\n+impl<'gcx, 'tcx, F, R, G> super::TypeOp<'gcx, 'tcx> for CustomTypeOp<F, G>\n+where\n+    F: for<'a, 'cx> FnOnce(&'a InferCtxt<'cx, 'gcx, 'tcx>) -> Fallible<InferOk<'tcx, R>>,\n+    G: Fn() -> String,\n+{\n+    type Output = R;\n+\n+    /// Processes the operation and all resulting obligations,\n+    /// returning the final result along with any region constraints\n+    /// (they will be given over to the NLL region solver).\n+    fn fully_perform(\n+        self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n+        if cfg!(debug_assertions) {\n+            info!(\"fully_perform({:?})\", self);\n+        }\n+\n+        scrape_region_constraints(infcx, || Ok((self.closure)(infcx)?))\n+    }\n+}\n+\n+impl<F, G> fmt::Debug for CustomTypeOp<F, G>\n+where\n+    G: Fn() -> String,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", (self.description)())\n+    }\n+}\n+\n+/// Executes `op` and then scrapes out all the \"old style\" region\n+/// constraints that result, creating query-region-constraints.\n+fn scrape_region_constraints<'gcx, 'tcx, R>(\n+    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n+) -> Fallible<(R, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n+    let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n+    let dummy_body_id = ObligationCause::dummy().body_id;\n+    let InferOk { value, obligations } = infcx.commit_if_ok(|_| op())?;\n+    debug_assert!(obligations.iter().all(|o| o.cause.body_id == dummy_body_id));\n+    fulfill_cx.register_predicate_obligations(infcx, obligations);\n+    if let Err(e) = fulfill_cx.select_all_or_error(infcx) {\n+        infcx.tcx.sess.diagnostic().delay_span_bug(\n+            DUMMY_SP,\n+            &format!(\"errors selecting obligation during MIR typeck: {:?}\", e),\n+        );\n+    }\n+\n+    let region_obligations = infcx.take_registered_region_obligations();\n+\n+    let region_constraint_data = infcx.take_and_reset_region_constraints();\n+\n+    let outlives =\n+        query_result::make_query_outlives(infcx.tcx, region_obligations, &region_constraint_data);\n+\n+    if outlives.is_empty() {\n+        Ok((value, None))\n+    } else {\n+        Ok((value, Some(Rc::new(outlives))))\n+    }\n+}"}, {"sha": "52a087cbc80699fc374f7cdc74a0345b3c15b0f8", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryResult};\n+use traits::query::Fallible;\n+use ty::{ParamEnvAnd, Ty, TyCtxt};\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub struct Eq<'tcx> {\n+    pub a: Ty<'tcx>,\n+    pub b: Ty<'tcx>,\n+}\n+\n+impl<'tcx> Eq<'tcx> {\n+    pub fn new(a: Ty<'tcx>, b: Ty<'tcx>) -> Self {\n+        Self { a, b }\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Eq<'tcx> {\n+    type QueryResult = ();\n+\n+    fn try_fast_path(\n+        _tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        key: &ParamEnvAnd<'tcx, Eq<'tcx>>,\n+    ) -> Option<Self::QueryResult> {\n+        if key.value.a == key.value.b {\n+            Some(())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn perform_query(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResult<'gcx, ()>> {\n+        tcx.type_op_eq(canonicalized)\n+    }\n+\n+    fn shrink_to_tcx_lifetime(\n+        v: &'a CanonicalizedQueryResult<'gcx, ()>,\n+    ) -> &'a Canonical<'tcx, QueryResult<'tcx, ()>> {\n+        v\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for Eq<'tcx> {\n+        a,\n+        b,\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for Eq<'a> {\n+        type Lifted = Eq<'tcx>;\n+        a,\n+        b,\n+    }\n+}\n+\n+impl_stable_hash_for! {\n+    struct Eq<'tcx> { a, b }\n+}"}, {"sha": "3dfa66cd41a4f5813d41316ac2d6fc888401e760", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -0,0 +1,163 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryRegionConstraint,\n+                       QueryResult};\n+use infer::{InferCtxt, InferOk};\n+use std::fmt;\n+use std::rc::Rc;\n+use traits::query::Fallible;\n+use traits::ObligationCause;\n+use ty::fold::TypeFoldable;\n+use ty::{Lift, ParamEnvAnd, TyCtxt};\n+\n+pub mod custom;\n+pub mod eq;\n+pub mod normalize;\n+pub mod outlives;\n+pub mod prove_predicate;\n+use self::prove_predicate::ProvePredicate;\n+pub mod subtype;\n+\n+/// \"Type ops\" are used in NLL to perform some particular action and\n+/// extract out the resulting region constraints (or an error if it\n+/// cannot be completed).\n+pub trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n+    type Output;\n+\n+    /// Processes the operation and all resulting obligations,\n+    /// returning the final result along with any region constraints\n+    /// (they will be given over to the NLL region solver).\n+    fn fully_perform(\n+        self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)>;\n+}\n+\n+/// \"Query type ops\" are type ops that are implemented using a\n+/// [canonical query][c]. The `Self` type here contains the kernel of\n+/// information needed to do the operation -- `TypeOp` is actually\n+/// implemented for `ParamEnvAnd<Self>`, since we always need to bring\n+/// along a parameter environment as well. For query type-ops, we will\n+/// first canonicalize the key and then invoke the query on the tcx,\n+/// which produces the resulting query region constraints.\n+///\n+/// [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n+pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>:\n+    fmt::Debug + Sized + TypeFoldable<'tcx> + Lift<'gcx>\n+{\n+    type QueryResult: TypeFoldable<'tcx> + Lift<'gcx>;\n+\n+    /// Give query the option for a simple fast path that never\n+    /// actually hits the tcx cache lookup etc. Return `Some(r)` with\n+    /// a final result or `None` to do the full path.\n+    fn try_fast_path(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        key: &ParamEnvAnd<'tcx, Self>,\n+    ) -> Option<Self::QueryResult>;\n+\n+    /// Performs the actual query with the canonicalized key -- the\n+    /// real work happens here. This method is not given an `infcx`\n+    /// because it shouldn't need one -- and if it had access to one,\n+    /// it might do things like invoke `sub_regions`, which would be\n+    /// bad, because it would create subregion relationships that are\n+    /// not captured in the return value.\n+    fn perform_query(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self::QueryResult>>;\n+\n+    /// Casts a lifted query result (which is in the gcx lifetime)\n+    /// into the tcx lifetime. This is always just an identity cast,\n+    /// but the generic code doesn't realize it -- put another way, in\n+    /// the generic code, we have a `Lifted<'gcx, Self::QueryResult>`\n+    /// and we want to convert that to a `Self::QueryResult`. This is\n+    /// not a priori valid, so we can't do it -- but in practice, it\n+    /// is always a no-op (e.g., the lifted form of a type,\n+    /// `Ty<'gcx>`, is a subtype of `Ty<'tcx>`). So we have to push\n+    /// the operation into the impls that know more specifically what\n+    /// `QueryResult` is. This operation would (maybe) be nicer with\n+    /// something like HKTs or GATs, since then we could make\n+    /// `QueryResult` parametric and `'gcx` and `'tcx` etc.\n+    fn shrink_to_tcx_lifetime(\n+        lifted_query_result: &'a CanonicalizedQueryResult<'gcx, Self::QueryResult>,\n+    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self::QueryResult>>;\n+\n+    fn fully_perform_into(\n+        query_key: ParamEnvAnd<'tcx, Self>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        output_query_region_constraints: &mut Vec<QueryRegionConstraint<'tcx>>,\n+    ) -> Fallible<Self::QueryResult> {\n+        if let Some(result) = QueryTypeOp::try_fast_path(infcx.tcx, &query_key) {\n+            return Ok(result);\n+        }\n+\n+        // FIXME(#33684) -- We need to use\n+        // `canonicalize_hr_query_hack` here because of things\n+        // like the subtype query, which go awry around\n+        // `'static` otherwise.\n+        let (canonical_self, canonical_var_values) = infcx.canonicalize_hr_query_hack(&query_key);\n+        let canonical_result = Self::perform_query(infcx.tcx, canonical_self)?;\n+        let canonical_result = Self::shrink_to_tcx_lifetime(&canonical_result);\n+\n+        let param_env = query_key.param_env;\n+\n+        let InferOk { value, obligations } = infcx\n+            .instantiate_nll_query_result_and_region_obligations(\n+                &ObligationCause::dummy(),\n+                param_env,\n+                &canonical_var_values,\n+                canonical_result,\n+                output_query_region_constraints,\n+            )?;\n+\n+        // Typically, instantiating NLL query results does not\n+        // create obligations. However, in some cases there\n+        // are unresolved type variables, and unify them *can*\n+        // create obligations. In that case, we have to go\n+        // fulfill them. We do this via a (recursive) query.\n+        for obligation in obligations {\n+            let () = ProvePredicate::fully_perform_into(\n+                obligation\n+                    .param_env\n+                    .and(ProvePredicate::new(obligation.predicate)),\n+                infcx,\n+                output_query_region_constraints,\n+            )?;\n+        }\n+\n+        Ok(value)\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, Q> TypeOp<'gcx, 'tcx> for ParamEnvAnd<'tcx, Q>\n+where\n+    Q: QueryTypeOp<'gcx, 'tcx>,\n+{\n+    type Output = Q::QueryResult;\n+\n+    fn fully_perform(\n+        self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    ) -> Fallible<(Self::Output, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n+        let mut qrc = vec![];\n+        let r = Q::fully_perform_into(self, infcx, &mut qrc)?;\n+\n+        // Promote the final query-region-constraints into a\n+        // (optional) ref-counted vector:\n+        let opt_qrc = if qrc.is_empty() {\n+            None\n+        } else {\n+            Some(Rc::new(qrc))\n+        };\n+\n+        Ok((r, opt_qrc))\n+    }\n+}"}, {"sha": "0c393fa4ca80fb73982fc85aa0a17c9fbd5d97dd", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -0,0 +1,161 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryResult};\n+use std::fmt;\n+use traits::query::Fallible;\n+use ty::fold::TypeFoldable;\n+use ty::{self, Lift, ParamEnvAnd, Ty, TyCtxt};\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub struct Normalize<T> {\n+    pub value: T,\n+}\n+\n+impl<'tcx, T> Normalize<T>\n+where\n+    T: fmt::Debug + TypeFoldable<'tcx>,\n+{\n+    pub fn new(value: T) -> Self {\n+        Self { value }\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, T> super::QueryTypeOp<'gcx, 'tcx> for Normalize<T>\n+where\n+    T: Normalizable<'gcx, 'tcx>,\n+{\n+    type QueryResult = T;\n+\n+    fn try_fast_path(_tcx: TyCtxt<'_, 'gcx, 'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<T> {\n+        if !key.value.value.has_projections() {\n+            Some(key.value.value)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn perform_query(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self::QueryResult>> {\n+        T::type_op_method(tcx, canonicalized)\n+    }\n+\n+    fn shrink_to_tcx_lifetime(\n+        v: &'a CanonicalizedQueryResult<'gcx, T>,\n+    ) -> &'a Canonical<'tcx, QueryResult<'tcx, T>> {\n+        T::shrink_to_tcx_lifetime(v)\n+    }\n+}\n+\n+pub trait Normalizable<'gcx, 'tcx>: fmt::Debug + TypeFoldable<'tcx> + Lift<'gcx> + Copy {\n+    fn type_op_method(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self>>;\n+\n+    /// Convert from the `'gcx` (lifted) form of `Self` into the `tcx`\n+    /// form of `Self`.\n+    fn shrink_to_tcx_lifetime(\n+        v: &'a CanonicalizedQueryResult<'gcx, Self>,\n+    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self>>;\n+}\n+\n+impl Normalizable<'gcx, 'tcx> for Ty<'tcx>\n+where\n+    'gcx: 'tcx,\n+{\n+    fn type_op_method(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self>> {\n+        tcx.type_op_normalize_ty(canonicalized)\n+    }\n+\n+    fn shrink_to_tcx_lifetime(\n+        v: &'a CanonicalizedQueryResult<'gcx, Self>,\n+    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self>> {\n+        v\n+    }\n+}\n+\n+impl Normalizable<'gcx, 'tcx> for ty::Predicate<'tcx>\n+where\n+    'gcx: 'tcx,\n+{\n+    fn type_op_method(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self>> {\n+        tcx.type_op_normalize_predicate(canonicalized)\n+    }\n+\n+    fn shrink_to_tcx_lifetime(\n+        v: &'a CanonicalizedQueryResult<'gcx, Self>,\n+    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self>> {\n+        v\n+    }\n+}\n+\n+impl Normalizable<'gcx, 'tcx> for ty::PolyFnSig<'tcx>\n+where\n+    'gcx: 'tcx,\n+{\n+    fn type_op_method(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self>> {\n+        tcx.type_op_normalize_poly_fn_sig(canonicalized)\n+    }\n+\n+    fn shrink_to_tcx_lifetime(\n+        v: &'a CanonicalizedQueryResult<'gcx, Self>,\n+    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self>> {\n+        v\n+    }\n+}\n+\n+impl Normalizable<'gcx, 'tcx> for ty::FnSig<'tcx>\n+where\n+    'gcx: 'tcx,\n+{\n+    fn type_op_method(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n+    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self>> {\n+        tcx.type_op_normalize_fn_sig(canonicalized)\n+    }\n+\n+    fn shrink_to_tcx_lifetime(\n+        v: &'a CanonicalizedQueryResult<'gcx, Self>,\n+    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self>> {\n+        v\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, T> TypeFoldable<'tcx> for Normalize<T> {\n+        value,\n+    } where T: TypeFoldable<'tcx>,\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'tcx, T> Lift<'tcx> for Normalize<T> {\n+        type Lifted = Normalize<T::Lifted>;\n+        value,\n+    } where T: Lift<'tcx>,\n+}\n+\n+impl_stable_hash_for! {\n+    impl<'tcx, T> for struct Normalize<T> {\n+        value\n+    }\n+}"}, {"sha": "e41ae7a72f9c2b33c59edfec4710a3596a5f11dd", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryResult};\n+use traits::query::dropck_outlives::trivial_dropck_outlives;\n+use traits::query::dropck_outlives::DropckOutlivesResult;\n+use traits::query::Fallible;\n+use ty::{ParamEnvAnd, Ty, TyCtxt};\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct DropckOutlives<'tcx> {\n+    dropped_ty: Ty<'tcx>,\n+}\n+\n+impl<'tcx> DropckOutlives<'tcx> {\n+    pub fn new(dropped_ty: Ty<'tcx>) -> Self {\n+        DropckOutlives { dropped_ty }\n+    }\n+}\n+\n+impl super::QueryTypeOp<'gcx, 'tcx> for DropckOutlives<'tcx>\n+where\n+    'gcx: 'tcx,\n+{\n+    type QueryResult = DropckOutlivesResult<'tcx>;\n+\n+    fn try_fast_path(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        key: &ParamEnvAnd<'tcx, Self>,\n+    ) -> Option<Self::QueryResult> {\n+        if trivial_dropck_outlives(tcx, key.value.dropped_ty) {\n+            Some(DropckOutlivesResult::default())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn perform_query(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResult<'gcx, Self::QueryResult>> {\n+        // Subtle: note that we are not invoking\n+        // `infcx.at(...).dropck_outlives(...)` here, but rather the\n+        // underlying `dropck_outlives` query. This same underlying\n+        // query is also used by the\n+        // `infcx.at(...).dropck_outlives(...)` fn. Avoiding the\n+        // wrapper means we don't need an infcx in this code, which is\n+        // good because the interface doesn't give us one (so that we\n+        // know we are not registering any subregion relations or\n+        // other things).\n+\n+        // FIXME convert to the type expected by the `dropck_outlives`\n+        // query. This should eventually be fixed by changing the\n+        // *underlying query*.\n+        let Canonical {\n+            variables,\n+            value:\n+                ParamEnvAnd {\n+                    param_env,\n+                    value: DropckOutlives { dropped_ty },\n+                },\n+        } = canonicalized;\n+        let canonicalized = Canonical {\n+            variables,\n+            value: param_env.and(dropped_ty),\n+        };\n+\n+        tcx.dropck_outlives(canonicalized)\n+    }\n+\n+    fn shrink_to_tcx_lifetime(\n+        lifted_query_result: &'a CanonicalizedQueryResult<'gcx, Self::QueryResult>,\n+    ) -> &'a Canonical<'tcx, QueryResult<'tcx, Self::QueryResult>> {\n+        lifted_query_result\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for DropckOutlives<'tcx> {\n+        dropped_ty\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for DropckOutlives<'a> {\n+        type Lifted = DropckOutlives<'tcx>;\n+        dropped_ty\n+    }\n+}\n+\n+impl_stable_hash_for! {\n+    struct DropckOutlives<'tcx> { dropped_ty }\n+}"}, {"sha": "33dc3210f08813802f896b681608922aa0253cc3", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryResult};\n+use traits::query::Fallible;\n+use ty::{ParamEnvAnd, Predicate, TyCtxt};\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub struct ProvePredicate<'tcx> {\n+    pub predicate: Predicate<'tcx>,\n+}\n+\n+impl<'tcx> ProvePredicate<'tcx> {\n+    pub fn new(predicate: Predicate<'tcx>) -> Self {\n+        ProvePredicate { predicate }\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ProvePredicate<'tcx> {\n+    type QueryResult = ();\n+\n+    fn try_fast_path(\n+        _tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        _key: &ParamEnvAnd<'tcx, Self>,\n+    ) -> Option<Self::QueryResult> {\n+        None\n+    }\n+\n+    fn perform_query(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResult<'gcx, ()>> {\n+        tcx.type_op_prove_predicate(canonicalized)\n+    }\n+\n+    fn shrink_to_tcx_lifetime(\n+        v: &'a CanonicalizedQueryResult<'gcx, ()>,\n+    ) -> &'a Canonical<'tcx, QueryResult<'tcx, ()>> {\n+        v\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ProvePredicate<'tcx> {\n+        predicate,\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for ProvePredicate<'a> {\n+        type Lifted = ProvePredicate<'tcx>;\n+        predicate,\n+    }\n+}\n+\n+impl_stable_hash_for! {\n+    struct ProvePredicate<'tcx> { predicate }\n+}"}, {"sha": "dc41bb1d6ab69fcaa521cce2be7b3633e57f5a29", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::canonical::{Canonical, Canonicalized, CanonicalizedQueryResult, QueryResult};\n+use traits::query::Fallible;\n+use ty::{ParamEnvAnd, Ty, TyCtxt};\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub struct Subtype<'tcx> {\n+    pub sub: Ty<'tcx>,\n+    pub sup: Ty<'tcx>,\n+}\n+\n+impl<'tcx> Subtype<'tcx> {\n+    pub fn new(sub: Ty<'tcx>, sup: Ty<'tcx>) -> Self {\n+        Self {\n+            sub,\n+            sup,\n+        }\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Subtype<'tcx> {\n+    type QueryResult = ();\n+\n+    fn try_fast_path(_tcx: TyCtxt<'_, 'gcx, 'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<()> {\n+        if key.value.sub == key.value.sup {\n+            Some(())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn perform_query(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n+    ) -> Fallible<CanonicalizedQueryResult<'gcx, ()>> {\n+        tcx.type_op_subtype(canonicalized)\n+    }\n+\n+    fn shrink_to_tcx_lifetime(\n+        v: &'a CanonicalizedQueryResult<'gcx, ()>,\n+    ) -> &'a Canonical<'tcx, QueryResult<'tcx, ()>> {\n+        v\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for Subtype<'tcx> {\n+        sub,\n+        sup,\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for Subtype<'a> {\n+        type Lifted = Subtype<'tcx>;\n+        sub,\n+        sup,\n+    }\n+}\n+\n+impl_stable_hash_for! {\n+    struct Subtype<'tcx> { sub, sup }\n+}"}, {"sha": "5142a30ae574f52064cf3ef1bd960348c5d3124d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -64,6 +64,7 @@ use std::borrow::Borrow;\n use std::cmp::Ordering;\n use std::collections::hash_map::{self, Entry};\n use std::hash::{Hash, Hasher};\n+use std::fmt;\n use std::mem;\n use std::ops::Deref;\n use std::iter;\n@@ -1503,8 +1504,8 @@ impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n /// contain the TypeVariants key or if the address of the interned\n /// pointer differs. The latter case is possible if a primitive type,\n /// e.g. `()` or `u8`, was interned in a different context.\n-pub trait Lift<'tcx> {\n-    type Lifted: 'tcx;\n+pub trait Lift<'tcx>: fmt::Debug {\n+    type Lifted: fmt::Debug + 'tcx;\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted>;\n }\n "}, {"sha": "e89a022f818701ee93f7b2d2768204764965f485", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -21,7 +21,7 @@ use hir::map::DefPathData;\n use hir::svh::Svh;\n use ich::Fingerprint;\n use ich::StableHashingContext;\n-use infer::canonical::{Canonical, Canonicalize};\n+use infer::canonical::Canonical;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n@@ -591,15 +591,6 @@ impl<'tcx> serialize::UseSpecializedDecodable for Ty<'tcx> {}\n \n pub type CanonicalTy<'gcx> = Canonical<'gcx, Ty<'gcx>>;\n \n-impl <'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for Ty<'tcx> {\n-    type Canonicalized = CanonicalTy<'gcx>;\n-\n-    fn intern(_gcx: TyCtxt<'_, 'gcx, 'gcx>,\n-              value: Canonical<'gcx, Self::Lifted>) -> Self::Canonicalized {\n-        value\n-    }\n-}\n-\n extern {\n     /// A dummy type used to force Slice to by unsized without requiring fat pointers\n     type OpaqueSliceContents;"}, {"sha": "eadfc62244f815179f55b9264eb0f21c99b50099", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -12,7 +12,10 @@ use dep_graph::SerializedDepNodeIndex;\n use dep_graph::DepNode;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use mir::interpret::{GlobalId, ConstValue};\n-use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal};\n+use traits::query::{\n+    CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal, CanonicalTypeOpEqGoal,\n+    CanonicalTypeOpNormalizeGoal, CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n+};\n use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::query::queries;\n@@ -102,6 +105,54 @@ impl<'tcx> QueryDescription<'tcx> for queries::evaluate_obligation<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::type_op_eq<'tcx> {\n+    fn describe(_tcx: TyCtxt, goal: CanonicalTypeOpEqGoal<'tcx>) -> String {\n+        format!(\"evaluating `type_op_eq` `{:?}`\", goal)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription<'tcx> for queries::type_op_subtype<'tcx> {\n+    fn describe(_tcx: TyCtxt, goal: CanonicalTypeOpSubtypeGoal<'tcx>) -> String {\n+        format!(\"evaluating `type_op_subtype` `{:?}`\", goal)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription<'tcx> for queries::type_op_prove_predicate<'tcx> {\n+    fn describe(_tcx: TyCtxt, goal: CanonicalTypeOpProvePredicateGoal<'tcx>) -> String {\n+        format!(\"evaluating `type_op_prove_predicate` `{:?}`\", goal)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_ty<'tcx> {\n+    fn describe(_tcx: TyCtxt, goal: CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"normalizing `{:?}`\", goal)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_predicate<'tcx> {\n+    fn describe(\n+        _tcx: TyCtxt,\n+        goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> String {\n+        format!(\"normalizing `{:?}`\", goal)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_poly_fn_sig<'tcx> {\n+    fn describe(\n+        _tcx: TyCtxt,\n+        goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::PolyFnSig<'tcx>>,\n+    ) -> String {\n+        format!(\"normalizing `{:?}`\", goal)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription<'tcx> for queries::type_op_normalize_fn_sig<'tcx> {\n+    fn describe(_tcx: TyCtxt, goal: CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>) -> String {\n+        format!(\"normalizing `{:?}`\", goal)\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::is_copy_raw<'tcx> {\n     fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n         format!(\"computing whether `{}` is `Copy`\", env.value)"}, {"sha": "cad3a6586829e0d348142fe3ea3d14eb259eb34f", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -10,8 +10,8 @@\n \n //! Defines the set of legal keys that can be used in queries.\n \n+use infer::canonical::Canonical;\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n-use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n@@ -190,27 +190,12 @@ impl Key for InternedString {\n     }\n }\n \n-impl<'tcx> Key for CanonicalProjectionGoal<'tcx> {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n-    }\n-\n-    fn default_span(&self, _tcx: TyCtxt) -> Span {\n-        DUMMY_SP\n-    }\n-}\n-\n-impl<'tcx> Key for CanonicalTyGoal<'tcx> {\n-    fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n-    }\n-\n-    fn default_span(&self, _tcx: TyCtxt) -> Span {\n-        DUMMY_SP\n-    }\n-}\n-\n-impl<'tcx> Key for CanonicalPredicateGoal<'tcx> {\n+/// Canonical query goals correspond to abstract trait operations that\n+/// are not tied to any crate in particular.\n+impl<'tcx, T> Key for Canonical<'tcx, T>\n+where\n+    T: Debug + Hash + Clone + Eq,\n+{\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }"}, {"sha": "178ee7cf8e9ac1938b165b202c41c674b44c4a2b", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -34,7 +34,8 @@ use session::{CompileResult, CrateDisambiguator};\n use session::config::OutputFilenames;\n use traits::{self, Vtable};\n use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal,\n-                    CanonicalTyGoal, NoSolution};\n+                    CanonicalTyGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal,\n+                    CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpNormalizeGoal, NoSolution};\n use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use traits::query::normalize::NormalizationResult;\n use traits::specialization_graph;\n@@ -446,6 +447,62 @@ define_queries! { <'tcx>\n         CanonicalPredicateGoal<'tcx>\n     ) -> Result<traits::EvaluationResult, traits::OverflowError>,\n \n+    /// Do not call this query directly: part of the `Eq` type-op\n+    [] fn type_op_eq: TypeOpEq(\n+        CanonicalTypeOpEqGoal<'tcx>\n+    ) -> Result<\n+        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ()>>>,\n+        NoSolution,\n+    >,\n+\n+    /// Do not call this query directly: part of the `Subtype` type-op\n+    [] fn type_op_subtype: TypeOpSubtype(\n+        CanonicalTypeOpSubtypeGoal<'tcx>\n+    ) -> Result<\n+        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ()>>>,\n+        NoSolution,\n+    >,\n+\n+    /// Do not call this query directly: part of the `ProvePredicate` type-op\n+    [] fn type_op_prove_predicate: TypeOpProvePredicate(\n+        CanonicalTypeOpProvePredicateGoal<'tcx>\n+    ) -> Result<\n+        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ()>>>,\n+        NoSolution,\n+    >,\n+\n+    /// Do not call this query directly: part of the `Normalize` type-op\n+    [] fn type_op_normalize_ty: TypeOpNormalizeTy(\n+        CanonicalTypeOpNormalizeGoal<'tcx, Ty<'tcx>>\n+    ) -> Result<\n+        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, Ty<'tcx>>>>,\n+        NoSolution,\n+    >,\n+\n+    /// Do not call this query directly: part of the `Normalize` type-op\n+    [] fn type_op_normalize_predicate: TypeOpNormalizePredicate(\n+        CanonicalTypeOpNormalizeGoal<'tcx, ty::Predicate<'tcx>>\n+    ) -> Result<\n+        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ty::Predicate<'tcx>>>>,\n+        NoSolution,\n+    >,\n+\n+    /// Do not call this query directly: part of the `Normalize` type-op\n+    [] fn type_op_normalize_poly_fn_sig: TypeOpNormalizePolyFnSig(\n+        CanonicalTypeOpNormalizeGoal<'tcx, ty::PolyFnSig<'tcx>>\n+    ) -> Result<\n+        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ty::PolyFnSig<'tcx>>>>,\n+        NoSolution,\n+    >,\n+\n+    /// Do not call this query directly: part of the `Normalize` type-op\n+    [] fn type_op_normalize_fn_sig: TypeOpNormalizeFnSig(\n+        CanonicalTypeOpNormalizeGoal<'tcx, ty::FnSig<'tcx>>\n+    ) -> Result<\n+        Lrc<Canonical<'tcx, canonical::QueryResult<'tcx, ty::FnSig<'tcx>>>>,\n+        NoSolution,\n+    >,\n+\n     [] fn substitute_normalize_and_test_predicates:\n         substitute_normalize_and_test_predicates_node((DefId, &'tcx Substs<'tcx>)) -> bool,\n "}, {"sha": "e17c6fba74c6ed2fc0c406e19287bef25ad5d891", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -1028,6 +1028,13 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::NormalizeTyAfterErasingRegions |\n         DepKind::DropckOutlives |\n         DepKind::EvaluateObligation |\n+        DepKind::TypeOpEq |\n+        DepKind::TypeOpSubtype |\n+        DepKind::TypeOpProvePredicate |\n+        DepKind::TypeOpNormalizeTy |\n+        DepKind::TypeOpNormalizePredicate |\n+        DepKind::TypeOpNormalizePolyFnSig |\n+        DepKind::TypeOpNormalizeFnSig |\n         DepKind::SubstituteNormalizeAndTestPredicates |\n         DepKind::InstanceDefSizeEstimate |\n         DepKind::ProgramClausesForEnv |"}, {"sha": "7b7568cfcfc39509a4c056fd4553f7da293b883b", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -275,6 +275,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         mir_def_id: def_id,\n         move_data: &mdpe.move_data,\n         param_env: param_env,\n+        location_table,\n         movable_generator,\n         locals_are_invalidated_at_exit: match tcx.hir.body_owner_kind(id) {\n             hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => false,\n@@ -362,6 +363,11 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     mir: &'cx Mir<'tcx>,\n     mir_def_id: DefId,\n     move_data: &'cx MoveData<'tcx>,\n+\n+    /// Map from MIR `Location` to `LocationIndex`; created\n+    /// when MIR borrowck begins.\n+    location_table: &'cx LocationTable,\n+\n     param_env: ParamEnv<'gcx>,\n     movable_generator: bool,\n     /// This keeps track of whether local variables are free-ed when the function\n@@ -976,8 +982,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mut error_reported = false;\n         let tcx = self.tcx;\n         let mir = self.mir;\n-        let location_table = &LocationTable::new(mir);\n-        let location = location_table.start_index(context.loc);\n+        let location = self.location_table.start_index(context.loc);\n         let borrow_set = self.borrow_set.clone();\n         each_borrow_involving_path(\n             self,"}, {"sha": "2523711f936e1bc80578105de2bb234062dc192c", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -12,7 +12,7 @@ use borrow_check::location::{LocationIndex, LocationTable};\n use dataflow::indexes::BorrowIndex;\n use polonius_engine::AllFacts as PoloniusAllFacts;\n use polonius_engine::Atom;\n-use rustc::ty::RegionVid;\n+use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n use std::error::Error;\n use std::fmt::Debug;\n@@ -23,6 +23,10 @@ use std::path::Path;\n crate type AllFacts = PoloniusAllFacts<RegionVid, BorrowIndex, LocationIndex>;\n \n crate trait AllFactsExt {\n+    /// Returns true if there is a need to gather `AllFacts` given the\n+    /// current `-Z` flags.\n+    fn enabled(tcx: TyCtxt<'_, '_, '_>) -> bool;\n+\n     fn write_to_dir(\n         &self,\n         dir: impl AsRef<Path>,\n@@ -31,6 +35,12 @@ crate trait AllFactsExt {\n }\n \n impl AllFactsExt for AllFacts {\n+    /// Return\n+    fn enabled(tcx: TyCtxt<'_, '_, '_>) -> bool {\n+        tcx.sess.opts.debugging_opts.nll_facts\n+            || tcx.sess.opts.debugging_opts.polonius\n+    }\n+\n     fn write_to_dir(\n         &self,\n         dir: impl AsRef<Path>,"}, {"sha": "e26665e8291bf9bf825434cbdf8fc6a84bf1a17f", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -91,9 +91,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex>>>,\n     Option<ClosureRegionRequirements<'gcx>>,\n ) {\n-    let mut all_facts = if infcx.tcx.sess.opts.debugging_opts.nll_facts\n-        || infcx.tcx.sess.opts.debugging_opts.polonius\n-    {\n+    let mut all_facts = if AllFacts::enabled(infcx.tcx) {\n         Some(AllFacts::default())\n     } else {\n         None"}, {"sha": "2e1f7fc9e70076103522dee7d0374ca0dd61a8c6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 38, "deletions": 52, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -11,25 +11,22 @@\n use super::universal_regions::UniversalRegions;\n use borrow_check::nll::region_infer::values::ToElementIndex;\n use rustc::hir::def_id::DefId;\n+use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::region_constraints::{GenericKind, VarInfos};\n use rustc::infer::InferCtxt;\n use rustc::infer::NLLRegionVariableOrigin;\n-use rustc::infer::RegionObligation;\n use rustc::infer::RegionVariableOrigin;\n-use rustc::infer::SubregionOrigin;\n use rustc::mir::{\n     ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements, Local, Location,\n     Mir,\n };\n-use rustc::traits::ObligationCause;\n-use rustc::ty::{self, RegionVid, Ty, TypeFoldable};\n+use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::{self, ErrorReported};\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use std::fmt;\n use std::rc::Rc;\n-use syntax::ast;\n use syntax_pos::Span;\n \n mod annotation;\n@@ -1162,16 +1159,15 @@ impl fmt::Debug for OutlivesConstraint {\n pub trait ClosureRegionRequirementsExt<'gcx, 'tcx> {\n     fn apply_requirements(\n         &self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        body_id: ast::NodeId,\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         location: Location,\n         closure_def_id: DefId,\n         closure_substs: ty::ClosureSubsts<'tcx>,\n-    );\n+    ) -> Vec<QueryRegionConstraint<'tcx>>;\n \n     fn subst_closure_mapping<T>(\n         &self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n         value: &T,\n     ) -> T\n@@ -1194,14 +1190,11 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n     /// requirements.\n     fn apply_requirements(\n         &self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        body_id: ast::NodeId,\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         location: Location,\n         closure_def_id: DefId,\n         closure_substs: ty::ClosureSubsts<'tcx>,\n-    ) {\n-        let tcx = infcx.tcx;\n-\n+    ) -> Vec<QueryRegionConstraint<'tcx>> {\n         debug!(\n             \"apply_requirements(location={:?}, closure_def_id={:?}, closure_substs={:?})\",\n             location, closure_def_id, closure_substs\n@@ -1215,59 +1208,52 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n         // into a vector.  These are the regions that we will be\n         // relating to one another.\n         let closure_mapping =\n-            &UniversalRegions::closure_mapping(infcx, user_closure_ty, self.num_external_vids);\n+            &UniversalRegions::closure_mapping(tcx, user_closure_ty, self.num_external_vids);\n         debug!(\"apply_requirements: closure_mapping={:?}\", closure_mapping);\n \n         // Create the predicates.\n-        for outlives_requirement in &self.outlives_requirements {\n-            let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n-\n-            // FIXME, this origin is not entirely suitable.\n-            let origin = SubregionOrigin::CallRcvr(outlives_requirement.blame_span);\n-\n-            match outlives_requirement.subject {\n-                ClosureOutlivesSubject::Region(region) => {\n-                    let region = closure_mapping[region];\n-                    debug!(\n-                        \"apply_requirements: region={:?} \\\n-                         outlived_region={:?} \\\n-                         outlives_requirement={:?}\",\n-                        region, outlived_region, outlives_requirement,\n-                    );\n-                    infcx.sub_regions(origin, outlived_region, region);\n-                }\n+        self.outlives_requirements\n+            .iter()\n+            .map(|outlives_requirement| {\n+                let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n+\n+                match outlives_requirement.subject {\n+                    ClosureOutlivesSubject::Region(region) => {\n+                        let region = closure_mapping[region];\n+                        debug!(\n+                            \"apply_requirements: region={:?} \\\n+                             outlived_region={:?} \\\n+                             outlives_requirement={:?}\",\n+                            region, outlived_region, outlives_requirement,\n+                        );\n+                        ty::Binder::dummy(ty::OutlivesPredicate(region.into(), outlived_region))\n+                    }\n \n-                ClosureOutlivesSubject::Ty(ty) => {\n-                    let ty = self.subst_closure_mapping(infcx, closure_mapping, &ty);\n-                    debug!(\n-                        \"apply_requirements: ty={:?} \\\n-                         outlived_region={:?} \\\n-                         outlives_requirement={:?}\",\n-                        ty, outlived_region, outlives_requirement,\n-                    );\n-                    infcx.register_region_obligation(\n-                        body_id,\n-                        RegionObligation {\n-                            sup_type: ty,\n-                            sub_region: outlived_region,\n-                            cause: ObligationCause::misc(outlives_requirement.blame_span, body_id),\n-                        },\n-                    );\n+                    ClosureOutlivesSubject::Ty(ty) => {\n+                        let ty = self.subst_closure_mapping(tcx, closure_mapping, &ty);\n+                        debug!(\n+                            \"apply_requirements: ty={:?} \\\n+                             outlived_region={:?} \\\n+                             outlives_requirement={:?}\",\n+                            ty, outlived_region, outlives_requirement,\n+                        );\n+                        ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region))\n+                    }\n                 }\n-            }\n-        }\n+            })\n+            .collect()\n     }\n \n     fn subst_closure_mapping<T>(\n         &self,\n-        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n         closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n         value: &T,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        infcx.tcx.fold_regions(value, &mut false, |r, _depth| {\n+        tcx.fold_regions(value, &mut false, |r, _depth| {\n             if let ty::ReClosureBound(vid) = r {\n                 closure_mapping[*vid]\n             } else {"}, {"sha": "900899b9cdebe7a3907a6a48cf3825b30bc3a169", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 130, "deletions": 82, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -13,127 +13,146 @@ use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::{OutlivesConstraint, RegionTest, TypeTest};\n use borrow_check::nll::type_check::Locations;\n use borrow_check::nll::universal_regions::UniversalRegions;\n-use rustc::infer::region_constraints::Constraint;\n-use rustc::infer::region_constraints::RegionConstraintData;\n-use rustc::infer::region_constraints::{Verify, VerifyBound};\n+use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n+use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n+use rustc::infer::{self, SubregionOrigin};\n use rustc::mir::{Location, Mir};\n-use rustc::ty;\n+use rustc::ty::subst::UnpackedKind;\n+use rustc::ty::{self, TyCtxt};\n use syntax::codemap::Span;\n \n-crate struct ConstraintConversion<'a, 'tcx: 'a> {\n+crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n     location_table: &'a LocationTable,\n+    region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+    implicit_region_bound: Option<ty::Region<'tcx>>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    locations: Locations,\n     outlives_constraints: &'a mut Vec<OutlivesConstraint>,\n     type_tests: &'a mut Vec<TypeTest<'tcx>>,\n     all_facts: &'a mut Option<AllFacts>,\n-\n }\n \n-impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     crate fn new(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         mir: &'a Mir<'tcx>,\n         universal_regions: &'a UniversalRegions<'tcx>,\n         location_table: &'a LocationTable,\n+        region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n+        implicit_region_bound: Option<ty::Region<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        locations: Locations,\n         outlives_constraints: &'a mut Vec<OutlivesConstraint>,\n         type_tests: &'a mut Vec<TypeTest<'tcx>>,\n         all_facts: &'a mut Option<AllFacts>,\n     ) -> Self {\n         Self {\n+            tcx,\n             mir,\n             universal_regions,\n             location_table,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+            locations,\n             outlives_constraints,\n             type_tests,\n             all_facts,\n         }\n     }\n \n-    crate fn convert(\n-        &mut self,\n-        locations: Locations,\n-        data: &RegionConstraintData<'tcx>,\n-    ) {\n-        debug!(\"generate: constraints at: {:#?}\", locations);\n-        let RegionConstraintData {\n-            constraints,\n-            verifys,\n-            givens,\n-        } = data;\n-\n-        let span = self\n-            .mir\n-            .source_info(locations.from_location().unwrap_or(Location::START))\n-            .span;\n-\n-        let at_location = locations.at_location().unwrap_or(Location::START);\n-\n-        for constraint in constraints.keys() {\n-            debug!(\"generate: constraint: {:?}\", constraint);\n-            let (a_vid, b_vid) = match constraint {\n-                Constraint::VarSubVar(a_vid, b_vid) => (*a_vid, *b_vid),\n-                Constraint::RegSubVar(a_r, b_vid) => (self.to_region_vid(a_r), *b_vid),\n-                Constraint::VarSubReg(a_vid, b_r) => (*a_vid, self.to_region_vid(b_r)),\n-                Constraint::RegSubReg(a_r, b_r) => {\n-                    (self.to_region_vid(a_r), self.to_region_vid(b_r))\n-                }\n-            };\n-\n-            // We have the constraint that `a_vid <= b_vid`. Add\n-            // `b_vid: a_vid` to our region checker. Note that we\n-            // reverse direction, because `regioncx` talks about\n-            // \"outlives\" (`>=`) whereas the region constraints\n-            // talk about `<=`.\n-            self.add_outlives(span, b_vid, a_vid, at_location);\n-\n-            // In the new analysis, all outlives relations etc\n-            // \"take effect\" at the mid point of the statement\n-            // that requires them, so ignore the `at_location`.\n-            if let Some(all_facts) = &mut self.all_facts {\n-                if let Some(from_location) = locations.from_location() {\n-                    all_facts.outlives.push((\n-                        b_vid,\n-                        a_vid,\n-                        self.location_table.mid_index(from_location),\n-                    ));\n-                } else {\n-                    for location in self.location_table.all_points() {\n-                        all_facts.outlives.push((b_vid, a_vid, location));\n+    pub(super) fn convert_all(&mut self, query_constraints: &[QueryRegionConstraint<'tcx>]) {\n+        for query_constraint in query_constraints {\n+            self.convert(query_constraint);\n+        }\n+    }\n+\n+    pub(super) fn convert(&mut self, query_constraint: &QueryRegionConstraint<'tcx>) {\n+        debug!(\"generate: constraints at: {:#?}\", self.locations);\n+\n+        // Extract out various useful fields we'll need below.\n+        let ConstraintConversion {\n+            tcx,\n+            region_bound_pairs,\n+            implicit_region_bound,\n+            param_env,\n+            ..\n+        } = *self;\n+\n+        // At the moment, we never generate any \"higher-ranked\"\n+        // region constraints like `for<'a> 'a: 'b`. At some point\n+        // when we move to universes, we will, and this assertion\n+        // will start to fail.\n+        let ty::OutlivesPredicate(k1, r2) =\n+            query_constraint.no_late_bound_regions().unwrap_or_else(|| {\n+                span_bug!(\n+                    self.span(),\n+                    \"query_constraint {:?} contained bound regions\",\n+                    query_constraint,\n+                );\n+            });\n+\n+        match k1.unpack() {\n+            UnpackedKind::Lifetime(r1) => {\n+                let r1_vid = self.to_region_vid(r1);\n+                let r2_vid = self.to_region_vid(r2);\n+                self.add_outlives(r1_vid, r2_vid);\n+\n+                // In the new analysis, all outlives relations etc\n+                // \"take effect\" at the mid point of the statement\n+                // that requires them, so ignore the `at_location`.\n+                if let Some(all_facts) = &mut self.all_facts {\n+                    if let Some(from_location) = self.locations.from_location() {\n+                        all_facts.outlives.push((\n+                            r1_vid,\n+                            r2_vid,\n+                            self.location_table.mid_index(from_location),\n+                        ));\n+                    } else {\n+                        for location in self.location_table.all_points() {\n+                            all_facts.outlives.push((r1_vid, r2_vid, location));\n+                        }\n                     }\n                 }\n             }\n-        }\n \n-        for verify in verifys {\n-            let type_test = self.verify_to_type_test(verify, span, locations);\n-            self.add_type_test(type_test);\n+            UnpackedKind::Type(t1) => {\n+                // we don't actually use this for anything, but\n+                // the `TypeOutlives` code needs an origin.\n+                let origin = infer::RelateParamBound(self.span(), t1);\n+\n+                TypeOutlives::new(\n+                    &mut *self,\n+                    tcx,\n+                    region_bound_pairs,\n+                    implicit_region_bound,\n+                    param_env,\n+                ).type_must_outlive(origin, t1, r2);\n+            }\n         }\n-\n-        assert!(\n-            givens.is_empty(),\n-            \"MIR type-checker does not use givens (thank goodness)\"\n-        );\n     }\n \n     fn verify_to_type_test(\n         &self,\n-        verify: &Verify<'tcx>,\n-        span: Span,\n-        locations: Locations,\n+        generic_kind: GenericKind<'tcx>,\n+        region: ty::Region<'tcx>,\n+        bound: VerifyBound<'tcx>,\n     ) -> TypeTest<'tcx> {\n-        let generic_kind = verify.kind;\n-\n-        let lower_bound = self.to_region_vid(verify.region);\n+        let lower_bound = self.to_region_vid(region);\n \n-        let point = locations.at_location().unwrap_or(Location::START);\n+        let point = self.locations.at_location().unwrap_or(Location::START);\n \n-        let test = self.verify_bound_to_region_test(&verify.bound);\n+        let test = self.verify_bound_to_region_test(&bound);\n \n         TypeTest {\n             generic_kind,\n             lower_bound,\n             point,\n-            span,\n+            span: self.span(),\n             test,\n         }\n     }\n@@ -168,13 +187,16 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         self.universal_regions.to_region_vid(r)\n     }\n \n-    fn add_outlives(\n-        &mut self,\n-        span: Span,\n-        sup: ty::RegionVid,\n-        sub: ty::RegionVid,\n-        point: Location,\n-    ) {\n+    fn span(&self) -> Span {\n+        self.mir\n+            .source_info(self.locations.from_location().unwrap_or(Location::START))\n+            .span\n+    }\n+\n+    fn add_outlives(&mut self, sup: ty::RegionVid, sub: ty::RegionVid) {\n+        let span = self.span();\n+        let point = self.locations.at_location().unwrap_or(Location::START);\n+\n         self.outlives_constraints.push(OutlivesConstraint {\n             span,\n             sub,\n@@ -188,3 +210,29 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         self.type_tests.push(type_test);\n     }\n }\n+\n+impl<'a, 'b, 'gcx, 'tcx> TypeOutlivesDelegate<'tcx>\n+    for &'a mut ConstraintConversion<'b, 'gcx, 'tcx>\n+{\n+    fn push_sub_region_constraint(\n+        &mut self,\n+        _origin: SubregionOrigin<'tcx>,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) {\n+        let b = self.universal_regions.to_region_vid(b);\n+        let a = self.universal_regions.to_region_vid(a);\n+        self.add_outlives(b, a);\n+    }\n+\n+    fn push_verify(\n+        &mut self,\n+        _origin: SubregionOrigin<'tcx>,\n+        kind: GenericKind<'tcx>,\n+        a: ty::Region<'tcx>,\n+        bound: VerifyBound<'tcx>,\n+    ) {\n+        let type_test = self.verify_to_type_test(kind, a, bound);\n+        self.add_type_test(type_test);\n+    }\n+}"}, {"sha": "770a0614811dc32ddcce753f8cc26e1f95c2bf4b", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 67, "deletions": 60, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -23,6 +23,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::InferOk;\n use rustc::mir::visit::TyContext;\n use rustc::mir::*;\n+use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::subst::Subst;\n use rustc::ty::Ty;\n@@ -50,7 +51,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         // Equate expected input tys with those in the MIR.\n         let argument_locals = (1..).map(Local::new);\n         for (&unnormalized_input_ty, local) in unnormalized_input_tys.iter().zip(argument_locals) {\n-            let input_ty = self.normalize(&unnormalized_input_ty, Locations::All);\n+            let input_ty = self.normalize(unnormalized_input_ty, Locations::All);\n             let mir_input_ty = mir.local_decls[local].ty;\n             self.equate_normalized_input_or_output(input_ty, mir_input_ty);\n         }\n@@ -70,72 +71,76 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             \"equate_inputs_and_outputs: unnormalized_output_ty={:?}\",\n             unnormalized_output_ty\n         );\n-        let output_ty = self.normalize(&unnormalized_output_ty, Locations::All);\n+        let output_ty = self.normalize(unnormalized_output_ty, Locations::All);\n         debug!(\n             \"equate_inputs_and_outputs: normalized output_ty={:?}\",\n             output_ty\n         );\n+        let param_env = self.param_env;\n         let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n         let anon_type_map =\n             self.fully_perform_op(\n                 Locations::All,\n-                || format!(\"input_output\"),\n-                |cx| {\n-                    let mut obligations = ObligationAccumulator::default();\n-\n-                    let dummy_body_id = ObligationCause::dummy().body_id;\n-                    let (output_ty, anon_type_map) = obligations.add(infcx.instantiate_anon_types(\n-                        mir_def_id,\n-                        dummy_body_id,\n-                        cx.param_env,\n-                        &output_ty,\n-                    ));\n-                    debug!(\n-                        \"equate_inputs_and_outputs: instantiated output_ty={:?}\",\n-                        output_ty\n-                    );\n-                    debug!(\n-                        \"equate_inputs_and_outputs: anon_type_map={:#?}\",\n-                        anon_type_map\n-                    );\n-\n-                    debug!(\n-                        \"equate_inputs_and_outputs: mir_output_ty={:?}\",\n-                        mir_output_ty\n-                    );\n-                    obligations.add(\n-                        infcx\n-                            .at(&ObligationCause::dummy(), cx.param_env)\n-                            .eq(output_ty, mir_output_ty)?,\n-                    );\n-\n-                    for (&anon_def_id, anon_decl) in &anon_type_map {\n-                        let anon_defn_ty = tcx.type_of(anon_def_id);\n-                        let anon_defn_ty = anon_defn_ty.subst(tcx, anon_decl.substs);\n-                        let anon_defn_ty = renumber::renumber_regions(\n-                            cx.infcx,\n-                            TyContext::Location(Location::START),\n-                            &anon_defn_ty,\n+                CustomTypeOp::new(\n+                    |infcx| {\n+                        let mut obligations = ObligationAccumulator::default();\n+\n+                        let dummy_body_id = ObligationCause::dummy().body_id;\n+                        let (output_ty, anon_type_map) =\n+                            obligations.add(infcx.instantiate_anon_types(\n+                                mir_def_id,\n+                                dummy_body_id,\n+                                param_env,\n+                                &output_ty,\n+                            ));\n+                        debug!(\n+                            \"equate_inputs_and_outputs: instantiated output_ty={:?}\",\n+                            output_ty\n                         );\n                         debug!(\n-                            \"equate_inputs_and_outputs: concrete_ty={:?}\",\n-                            anon_decl.concrete_ty\n+                            \"equate_inputs_and_outputs: anon_type_map={:#?}\",\n+                            anon_type_map\n+                        );\n+\n+                        debug!(\n+                            \"equate_inputs_and_outputs: mir_output_ty={:?}\",\n+                            mir_output_ty\n                         );\n-                        debug!(\"equate_inputs_and_outputs: anon_defn_ty={:?}\", anon_defn_ty);\n                         obligations.add(\n                             infcx\n-                                .at(&ObligationCause::dummy(), cx.param_env)\n-                                .eq(anon_decl.concrete_ty, anon_defn_ty)?,\n+                                .at(&ObligationCause::dummy(), param_env)\n+                                .eq(output_ty, mir_output_ty)?,\n                         );\n-                    }\n-\n-                    debug!(\"equate_inputs_and_outputs: equated\");\n \n-                    Ok(InferOk {\n-                        value: Some(anon_type_map),\n-                        obligations: obligations.into_vec(),\n-                    })\n-                },\n+                        for (&anon_def_id, anon_decl) in &anon_type_map {\n+                            let anon_defn_ty = tcx.type_of(anon_def_id);\n+                            let anon_defn_ty = anon_defn_ty.subst(tcx, anon_decl.substs);\n+                            let anon_defn_ty = renumber::renumber_regions(\n+                                infcx,\n+                                TyContext::Location(Location::START),\n+                                &anon_defn_ty,\n+                            );\n+                            debug!(\n+                                \"equate_inputs_and_outputs: concrete_ty={:?}\",\n+                                anon_decl.concrete_ty\n+                            );\n+                            debug!(\"equate_inputs_and_outputs: anon_defn_ty={:?}\", anon_defn_ty);\n+                            obligations.add(\n+                                infcx\n+                                    .at(&ObligationCause::dummy(), param_env)\n+                                    .eq(anon_decl.concrete_ty, anon_defn_ty)?,\n+                            );\n+                        }\n+\n+                        debug!(\"equate_inputs_and_outputs: equated\");\n+\n+                        Ok(InferOk {\n+                            value: Some(anon_type_map),\n+                            obligations: obligations.into_vec(),\n+                        })\n+                    },\n+                    || format!(\"input_output\"),\n+                ),\n             ).unwrap_or_else(|terr| {\n                 span_mirbug!(\n                     self,\n@@ -155,14 +160,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         if let Some(anon_type_map) = anon_type_map {\n             self.fully_perform_op(\n                 Locations::All,\n-                || format!(\"anon_type_map\"),\n-                |_cx| {\n-                    infcx.constrain_anon_types(&anon_type_map, universal_regions);\n-                    Ok(InferOk {\n-                        value: (),\n-                        obligations: vec![],\n-                    })\n-                },\n+                CustomTypeOp::new(\n+                    |_cx| {\n+                        infcx.constrain_anon_types(&anon_type_map, universal_regions);\n+                        Ok(InferOk {\n+                            value: (),\n+                            obligations: vec![],\n+                        })\n+                    },\n+                    || format!(\"anon_type_map\"),\n+                ),\n             ).unwrap();\n         }\n     }"}, {"sha": "f27de92c6215a9eecdb7bfafd7fb07ef7588efac", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -13,11 +13,12 @@ use borrow_check::nll::type_check::AtLocation;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use dataflow::MaybeInitializedPlaces;\n use dataflow::{FlowAtLocation, FlowsAtLocation};\n-use rustc::infer::region_constraints::RegionConstraintData;\n+use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::mir::Local;\n use rustc::mir::{BasicBlock, Location, Mir};\n-use rustc::traits::ObligationCause;\n-use rustc::ty::subst::Kind;\n+use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n+use rustc::traits::query::type_op::outlives::DropckOutlives;\n+use rustc::traits::query::type_op::TypeOp;\n use rustc::ty::{Ty, TypeFoldable};\n use rustc_data_structures::fx::FxHashMap;\n use std::rc::Rc;\n@@ -70,8 +71,8 @@ where\n }\n \n struct DropData<'tcx> {\n-    dropped_kinds: Vec<Kind<'tcx>>,\n-    region_constraint_data: Option<Rc<RegionConstraintData<'tcx>>>,\n+    dropck_result: DropckOutlivesResult<'tcx>,\n+    region_constraint_data: Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>,\n }\n \n impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx> {\n@@ -170,8 +171,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         );\n \n         cx.tcx().for_each_free_region(&value, |live_region| {\n-            cx\n-                .constraints\n+            cx.constraints\n                 .liveness_set\n                 .push((live_region, location, cause.clone()));\n         });\n@@ -199,14 +199,19 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         });\n \n         if let Some(data) = &drop_data.region_constraint_data {\n-            self.cx\n-                .push_region_constraints(location.at_self(), data.clone());\n+            self.cx.push_region_constraints(location.at_self(), data);\n         }\n \n+        drop_data.dropck_result.report_overflows(\n+            self.cx.infcx.tcx,\n+            self.mir.source_info(location).span,\n+            dropped_ty,\n+        );\n+\n         // All things in the `outlives` array may be touched by\n         // the destructor and must be live at this point.\n         let cause = Cause::DropVar(dropped_local, location);\n-        for &kind in &drop_data.dropped_kinds {\n+        for &kind in &drop_data.dropck_result.kinds {\n             Self::push_type_live_constraint(&mut self.cx, kind, location, cause);\n         }\n     }\n@@ -217,19 +222,14 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n     ) -> DropData<'tcx> {\n         debug!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty,);\n \n-        let (dropped_kinds, region_constraint_data) =\n-            cx.fully_perform_op_and_get_region_constraint_data(\n-                || format!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty),\n-                |cx| {\n-                    Ok(cx\n-                        .infcx\n-                        .at(&ObligationCause::dummy(), cx.param_env)\n-                        .dropck_outlives(dropped_ty))\n-                },\n-            ).unwrap();\n+        let param_env = cx.param_env;\n+        let (dropck_result, region_constraint_data) = param_env\n+            .and(DropckOutlives::new(dropped_ty))\n+            .fully_perform(cx.infcx)\n+            .unwrap();\n \n         DropData {\n-            dropped_kinds,\n+            dropck_result,\n             region_constraint_data,\n         }\n     }"}, {"sha": "2da2b10edb8032355f06089d3df72b409ea68e1d", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 81, "deletions": 167, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -20,19 +20,18 @@ use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::region_constraints::{GenericKind, RegionConstraintData};\n-use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n+use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::region_constraints::GenericKind;\n+use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::mir::*;\n-use rustc::traits::query::NoSolution;\n-use rustc::traits::{self, ObligationCause, Normalized, TraitEngine};\n-use rustc::ty::error::TypeError;\n+use rustc::traits::query::type_op;\n+use rustc::traits::query::{Fallible, NoSolution};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n use std::fmt;\n-use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n use util::liveness::LivenessResults;\n@@ -286,9 +285,10 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n                     let instantiated_predicates =\n                         tcx.predicates_of(def_id).instantiate(tcx, substs);\n-                    let predicates =\n-                        type_checker.normalize(&instantiated_predicates.predicates, location);\n-                    type_checker.prove_predicates(predicates, location);\n+                    type_checker.normalize_and_prove_instantiated_predicates(\n+                        instantiated_predicates,\n+                        location,\n+                    );\n                 }\n \n                 value.ty\n@@ -344,7 +344,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             Place::Static(box Static { def_id, ty: sty }) => {\n                 let sty = self.sanitize_type(place, sty);\n                 let ty = self.tcx().type_of(def_id);\n-                let ty = self.cx.normalize(&ty, location);\n+                let ty = self.cx.normalize(ty, location);\n                 if let Err(terr) = self.cx.eq_types(ty, sty, location.at_self()) {\n                     span_mirbug!(\n                         self,\n@@ -731,15 +731,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn fully_perform_op<R>(\n         &mut self,\n         locations: Locations,\n-        describe_op: impl Fn() -> String,\n-        op: impl FnOnce(&mut Self) -> InferResult<'tcx, R>,\n-    ) -> Result<R, TypeError<'tcx>> {\n-        let (r, opt_data) = self.fully_perform_op_and_get_region_constraint_data(\n-            || format!(\"{} at {:?}\", describe_op(), locations),\n-            op,\n-        )?;\n-\n-        if let Some(data) = opt_data {\n+        op: impl type_op::TypeOp<'gcx, 'tcx, Output = R>,\n+    ) -> Fallible<R> {\n+        let (r, opt_data) = op.fully_perform(self.infcx)?;\n+\n+        if let Some(data) = &opt_data {\n             self.push_region_constraints(locations, data);\n         }\n \n@@ -749,7 +745,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn push_region_constraints(\n         &mut self,\n         locations: Locations,\n-        data: Rc<RegionConstraintData<'tcx>>,\n+        data: &[QueryRegionConstraint<'tcx>],\n     ) {\n         debug!(\n             \"push_region_constraints: constraints generated at {:?} are {:#?}\",\n@@ -758,55 +754,18 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         if let Some(borrowck_context) = &mut self.borrowck_context {\n             constraint_conversion::ConstraintConversion::new(\n+                self.infcx.tcx,\n                 self.mir,\n                 borrowck_context.universal_regions,\n                 borrowck_context.location_table,\n+                self.region_bound_pairs,\n+                self.implicit_region_bound,\n+                self.param_env,\n+                locations,\n                 &mut self.constraints.outlives_constraints,\n                 &mut self.constraints.type_tests,\n                 &mut borrowck_context.all_facts,\n-            ).convert(locations, &data);\n-        }\n-    }\n-\n-    /// Helper for `fully_perform_op`, but also used on its own\n-    /// sometimes to enable better caching: executes `op` fully (along\n-    /// with resulting obligations) and returns the full set of region\n-    /// obligations. If the same `op` were to be performed at some\n-    /// other location, then the same set of region obligations would\n-    /// be generated there, so this can be useful for caching.\n-    fn fully_perform_op_and_get_region_constraint_data<R>(\n-        &mut self,\n-        describe_op: impl Fn() -> String,\n-        op: impl FnOnce(&mut Self) -> InferResult<'tcx, R>,\n-    ) -> Result<(R, Option<Rc<RegionConstraintData<'tcx>>>), TypeError<'tcx>> {\n-        if cfg!(debug_assertions) {\n-            info!(\n-                \"fully_perform_op_and_get_region_constraint_data({})\",\n-                describe_op(),\n-            );\n-        }\n-\n-        let mut fulfill_cx = TraitEngine::new(self.infcx.tcx);\n-        let dummy_body_id = ObligationCause::dummy().body_id;\n-        let InferOk { value, obligations } = self.infcx.commit_if_ok(|_| op(self))?;\n-        debug_assert!(obligations.iter().all(|o| o.cause.body_id == dummy_body_id));\n-        fulfill_cx.register_predicate_obligations(self.infcx, obligations);\n-        if let Err(e) = fulfill_cx.select_all_or_error(self.infcx) {\n-            span_mirbug!(self, \"\", \"errors selecting obligation: {:?}\", e);\n-        }\n-\n-        self.infcx.process_registered_region_obligations(\n-            self.region_bound_pairs,\n-            self.implicit_region_bound,\n-            self.param_env,\n-            dummy_body_id,\n-        );\n-\n-        let data = self.infcx.take_and_reset_region_constraints();\n-        if data.is_empty() {\n-            Ok((value, None))\n-        } else {\n-            Ok((value, Some(Rc::new(data))))\n+            ).convert_all(&data);\n         }\n     }\n \n@@ -815,38 +774,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         sub: Ty<'tcx>,\n         sup: Ty<'tcx>,\n         locations: Locations,\n-    ) -> UnitResult<'tcx> {\n-        // Micro-optimization.\n-        if sub == sup {\n-            return Ok(());\n-        }\n-\n+    ) -> Fallible<()> {\n+        let param_env = self.param_env;\n         self.fully_perform_op(\n             locations,\n-            || format!(\"sub_types({:?} <: {:?})\", sub, sup),\n-            |this| {\n-                this.infcx\n-                    .at(&ObligationCause::dummy(), this.param_env)\n-                    .sup(sup, sub)\n-            },\n+            param_env.and(type_op::subtype::Subtype::new(sub, sup)),\n         )\n     }\n \n-    fn eq_types(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, locations: Locations) -> UnitResult<'tcx> {\n-        // Micro-optimization.\n-        if a == b {\n-            return Ok(());\n-        }\n-\n-        self.fully_perform_op(\n-            locations,\n-            || format!(\"eq_types({:?} = {:?})\", a, b),\n-            |this| {\n-                this.infcx\n-                    .at(&ObligationCause::dummy(), this.param_env)\n-                    .eq(b, a)\n-            },\n-        )\n+    fn eq_types(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, locations: Locations) -> Fallible<()> {\n+        let param_env = self.param_env;\n+        self.fully_perform_op(locations, param_env.and(type_op::eq::Eq::new(b, a)))\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -1040,7 +978,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     LateBoundRegionConversionTime::FnCall,\n                     &sig,\n                 );\n-                let sig = self.normalize(&sig, term_location);\n+                let sig = self.normalize(sig, term_location);\n                 self.check_call_dest(mir, term, &sig, destination, term_location);\n \n                 self.prove_predicates(\n@@ -1328,7 +1266,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let variant = &def.variants[variant_index];\n                 let adj_field_index = active_field_index.unwrap_or(field_index);\n                 if let Some(field) = variant.fields.get(adj_field_index) {\n-                    Ok(self.normalize(&field.ty(tcx, substs), location))\n+                    Ok(self.normalize(field.ty(tcx, substs), location))\n                 } else {\n                     Err(FieldAccessError::OutOfRange {\n                         field_count: variant.fields.len(),\n@@ -1402,7 +1340,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     // function definition. When we extract the\n                     // signature, it comes from the `fn_sig` query,\n                     // and hence may contain unnormalized results.\n-                    let fn_sig = self.normalize(&fn_sig, location);\n+                    let fn_sig = self.normalize(fn_sig, location);\n \n                     let ty_fn_ptr_from = tcx.mk_fn_ptr(fn_sig);\n \n@@ -1447,7 +1385,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     // function definition. When we extract the\n                     // signature, it comes from the `fn_sig` query,\n                     // and hence may contain unnormalized results.\n-                    let fn_sig = self.normalize(&fn_sig, location);\n+                    let fn_sig = self.normalize(fn_sig, location);\n \n                     let ty_fn_ptr_from = tcx.safe_to_unsafe_fn_ty(fn_sig);\n \n@@ -1573,14 +1511,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 if let Some(closure_region_requirements) =\n                     tcx.mir_borrowck(*def_id).closure_requirements\n                 {\n-                    let dummy_body_id = ObligationCause::dummy().body_id;\n-                    closure_region_requirements.apply_requirements(\n-                        self.infcx,\n-                        dummy_body_id,\n+                    let closure_constraints = closure_region_requirements.apply_requirements(\n+                        self.infcx.tcx,\n                         location,\n                         *def_id,\n                         *substs,\n                     );\n+\n+                    self.push_region_constraints(\n+                        location.at_self(),\n+                        &closure_constraints,\n+                    );\n                 }\n \n                 tcx.predicates_of(*def_id).instantiate(tcx, substs.substs)\n@@ -1593,9 +1534,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             AggregateKind::Array(_) | AggregateKind::Tuple => ty::InstantiatedPredicates::empty(),\n         };\n \n-        let predicates = self.normalize(&instantiated_predicates.predicates, location);\n-        debug!(\"prove_aggregate_predicates: predicates={:?}\", predicates);\n-        self.prove_predicates(predicates, location);\n+        self.normalize_and_prove_instantiated_predicates(instantiated_predicates, location);\n     }\n \n     fn prove_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>, location: Location) {\n@@ -1607,46 +1546,45 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         );\n     }\n \n-    fn prove_predicates<T>(&mut self, predicates: T, location: Location)\n-    where\n-        T: IntoIterator<Item = ty::Predicate<'tcx>> + Clone,\n-    {\n-        let cause = ObligationCause::dummy();\n-        let obligations: Vec<_> = predicates\n-            .into_iter()\n-            .map(|p| traits::Obligation::new(cause.clone(), self.param_env, p))\n-            .collect();\n-\n-        // Micro-optimization\n-        if obligations.is_empty() {\n-            return;\n+    fn normalize_and_prove_instantiated_predicates(\n+        &mut self,\n+        instantiated_predicates: ty::InstantiatedPredicates<'tcx>,\n+        location: Location,\n+    ) {\n+        for predicate in instantiated_predicates.predicates {\n+            let predicate = self.normalize(predicate, location);\n+            self.prove_predicate(predicate, location);\n         }\n+    }\n \n-        // This intermediate vector is mildly unfortunate, in that we\n-        // sometimes create it even when logging is disabled, but only\n-        // if debug-info is enabled, and I doubt it is actually\n-        // expensive. -nmatsakis\n-        let predicates_vec: Vec<_> = if cfg!(debug_assertions) {\n-            obligations.iter().map(|o| o.predicate).collect()\n-        } else {\n-            Vec::new()\n-        };\n+    fn prove_predicates(\n+        &mut self,\n+        predicates: impl IntoIterator<Item = ty::Predicate<'tcx>>,\n+        location: Location,\n+    ) {\n+        for predicate in predicates {\n+            debug!(\n+                \"prove_predicates(predicate={:?}, location={:?})\",\n+                predicate, location,\n+            );\n+\n+            self.prove_predicate(predicate, location);\n+        }\n+    }\n \n+    fn prove_predicate(&mut self, predicate: ty::Predicate<'tcx>, location: Location) {\n         debug!(\n-            \"prove_predicates(predicates={:?}, location={:?})\",\n-            predicates_vec, location,\n+            \"prove_predicate(predicate={:?}, location={:?})\",\n+            predicate, location,\n         );\n \n+        let param_env = self.param_env;\n         self.fully_perform_op(\n             location.at_self(),\n-            || format!(\"prove_predicates({:?})\", predicates_vec),\n-            |_this| {\n-                Ok(InferOk {\n-                    value: (),\n-                    obligations,\n-                })\n-            },\n-        ).unwrap()\n+            param_env.and(type_op::prove_predicate::ProvePredicate::new(predicate)),\n+        ).unwrap_or_else(|NoSolution| {\n+            span_mirbug!(self, NoSolution, \"could not prove {:?}\", predicate);\n+        })\n     }\n \n     fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n@@ -1675,35 +1613,19 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn normalize<T>(&mut self, value: &T, location: impl ToLocations) -> T\n+    fn normalize<T>(&mut self, value: T, location: impl ToLocations) -> T\n     where\n-        T: fmt::Debug + TypeFoldable<'tcx>,\n+        T: type_op::normalize::Normalizable<'gcx, 'tcx> + Copy,\n     {\n-        // Micro-optimization: avoid work when we don't have to\n-        if !value.has_projections() {\n-            return value.clone();\n-        }\n-\n         debug!(\"normalize(value={:?}, location={:?})\", value, location);\n+        let param_env = self.param_env;\n         self.fully_perform_op(\n             location.to_locations(),\n-            || format!(\"normalize(value={:?})\", value),\n-            |this| {\n-                let Normalized { value, obligations } = this\n-                    .infcx\n-                    .at(&ObligationCause::dummy(), this.param_env)\n-                    .normalize(value)\n-                    .unwrap_or_else(|NoSolution| {\n-                        span_bug!(\n-                            this.last_span,\n-                            \"normalization of `{:?}` failed at {:?}\",\n-                            value,\n-                            location,\n-                        );\n-                    });\n-                Ok(InferOk { value, obligations })\n-            },\n-        ).unwrap()\n+            param_env.and(type_op::normalize::Normalize::new(value)),\n+        ).unwrap_or_else(|NoSolution| {\n+            span_mirbug!(self, NoSolution, \"failed to normalize `{:?}`\", value);\n+            value\n+        })\n     }\n }\n \n@@ -1735,16 +1657,8 @@ impl MirPass for TypeckMir {\n \n         let param_env = tcx.param_env(def_id);\n         tcx.infer_ctxt().enter(|infcx| {\n-            let _ = type_check_internal(\n-                &infcx,\n-                def_id,\n-                param_env,\n-                mir,\n-                &[],\n-                None,\n-                None,\n-                &mut |_| (),\n-            );\n+            let _ =\n+                type_check_internal(&infcx, def_id, param_env, mir, &[], None, None, &mut |_| ());\n \n             // For verification purposes, we just ignore the resulting\n             // region constraint sets. Not our problem. =)"}, {"sha": "ec8cd386679c39970592a29f82593069cfe3e189", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -238,13 +238,13 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// `'1: '2`, then the caller would impose the constraint that\n     /// `V[1]: V[2]`.\n     pub fn closure_mapping(\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n         closure_ty: Ty<'tcx>,\n         expected_num_vars: usize,\n     ) -> IndexVec<RegionVid, ty::Region<'tcx>> {\n         let mut region_mapping = IndexVec::with_capacity(expected_num_vars);\n-        region_mapping.push(infcx.tcx.types.re_static);\n-        infcx.tcx.for_each_free_region(&closure_ty, |fr| {\n+        region_mapping.push(tcx.types.re_static);\n+        tcx.for_each_free_region(&closure_ty, |fr| {\n             region_mapping.push(fr);\n         });\n "}, {"sha": "6062fe03e6a16d4651581af570ea2c42d86cb638", "filename": "src/librustc_traits/chalk_context.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Fchalk_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Fchalk_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -10,9 +10,7 @@\n \n use chalk_engine::fallible::Fallible as ChalkEngineFallible;\n use chalk_engine::{context, hh::HhGoal, DelayedLiteral, ExClause};\n-use rustc::infer::canonical::{\n-    Canonical, CanonicalVarValues, Canonicalize, QueryRegionConstraint, QueryResult,\n-};\n+use rustc::infer::canonical::{Canonical, CanonicalVarValues, QueryRegionConstraint, QueryResult};\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc::traits::{\n     WellFormed,\n@@ -519,14 +517,3 @@ BraceStructLiftImpl! {\n         subst, constraints\n     }\n }\n-\n-impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ConstrainedSubst<'tcx> {\n-    type Canonicalized = Canonical<'gcx, ConstrainedSubst<'gcx>>;\n-\n-    fn intern(\n-        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n-        value: Canonical<'gcx, ConstrainedSubst<'gcx>>,\n-    ) -> Self::Canonicalized {\n-        value\n-    }\n-}"}, {"sha": "5f9060b36234644c9f59ba75fc44240662c2b075", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -8,19 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::infer::canonical::{Canonical, QueryResult};\n use rustc::hir::def_id::DefId;\n-use rustc::traits::{FulfillmentContext, Normalized, ObligationCause};\n+use rustc::infer::canonical::{Canonical, QueryResult};\n+use rustc::traits::query::dropck_outlives::{DropckOutlivesResult, DtorckConstraint};\n use rustc::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc::traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n-use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use rustc::traits::{FulfillmentContext, Normalized, ObligationCause, TraitEngineExt};\n+use rustc::ty::query::Providers;\n use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax::codemap::{Span, DUMMY_SP};\n-use util;\n \n-crate fn dropck_outlives<'tcx>(\n+crate fn provide(p: &mut Providers) {\n+    *p = Providers {\n+        dropck_outlives,\n+        adt_dtorck_constraint,\n+        ..*p\n+    };\n+}\n+\n+fn dropck_outlives<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     goal: CanonicalTyGoal<'tcx>,\n ) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, DropckOutlivesResult<'tcx>>>>, NoSolution> {\n@@ -36,7 +44,10 @@ crate fn dropck_outlives<'tcx>(\n             canonical_inference_vars,\n         ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &goal);\n \n-        let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n+        let mut result = DropckOutlivesResult {\n+            kinds: vec![],\n+            overflows: vec![],\n+        };\n \n         // A stack of types left to process. Each round, we pop\n         // something from the stack and invoke\n@@ -135,7 +146,7 @@ crate fn dropck_outlives<'tcx>(\n \n         debug!(\"dropck_outlives: result = {:#?}\", result);\n \n-        util::make_query_response(infcx, canonical_inference_vars, result, fulfill_cx)\n+        infcx.make_canonicalized_query_result(canonical_inference_vars, result, fulfill_cx)\n     })\n }\n \n@@ -184,7 +195,8 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n             dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ety)\n         }\n \n-        ty::TyTuple(tys) => tys.iter()\n+        ty::TyTuple(tys) => tys\n+            .iter()\n             .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n             .collect(),\n \n@@ -222,7 +234,10 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n                 dtorck_types: vec![],\n                 overflows: vec![],\n             };\n-            debug!(\"dtorck_constraint: generator {:?} => {:?}\", def_id, constraint);\n+            debug!(\n+                \"dtorck_constraint: generator {:?} => {:?}\",\n+                def_id, constraint\n+            );\n \n             Ok(constraint)\n         }\n@@ -291,7 +306,8 @@ crate fn adt_dtorck_constraint<'a, 'tcx>(\n         return Ok(result);\n     }\n \n-    let mut result = def.all_fields()\n+    let mut result = def\n+        .all_fields()\n         .map(|field| tcx.type_of(field.did))\n         .map(|fty| dtorck_constraint_for_ty(tcx, span, fty, 0, fty))\n         .collect::<Result<DtorckConstraint, NoSolution>>()?;"}, {"sha": "e8a3447902fd357de4a93de6b63224130187a922", "filename": "src/librustc_traits/evaluate_obligation.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fevaluate_obligation.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -11,10 +11,18 @@\n use rustc::traits::{EvaluationResult, Obligation, ObligationCause,\n                     OverflowError, SelectionContext, TraitQueryMode};\n use rustc::traits::query::CanonicalPredicateGoal;\n+use rustc::ty::query::Providers;\n use rustc::ty::{ParamEnvAnd, TyCtxt};\n use syntax::codemap::DUMMY_SP;\n \n-crate fn evaluate_obligation<'tcx>(\n+crate fn provide(p: &mut Providers) {\n+    *p = Providers {\n+        evaluate_obligation,\n+        ..*p\n+    };\n+}\n+\n+fn evaluate_obligation<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     goal: CanonicalPredicateGoal<'tcx>,\n ) -> Result<EvaluationResult, OverflowError> {"}, {"sha": "1da3907915a0724a78d8e1547fe94c0f307ce889", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -33,21 +33,16 @@ mod dropck_outlives;\n mod evaluate_obligation;\n mod normalize_projection_ty;\n mod normalize_erasing_regions;\n-mod util;\n pub mod lowering;\n+mod type_op;\n \n use rustc::ty::query::Providers;\n \n pub fn provide(p: &mut Providers) {\n-    *p = Providers {\n-        dropck_outlives: dropck_outlives::dropck_outlives,\n-        adt_dtorck_constraint: dropck_outlives::adt_dtorck_constraint,\n-        normalize_projection_ty: normalize_projection_ty::normalize_projection_ty,\n-        normalize_ty_after_erasing_regions:\n-            normalize_erasing_regions::normalize_ty_after_erasing_regions,\n-        program_clauses_for: lowering::program_clauses_for,\n-        program_clauses_for_env: lowering::program_clauses_for_env,\n-        evaluate_obligation: evaluate_obligation::evaluate_obligation,\n-        ..*p\n-    };\n+    dropck_outlives::provide(p);\n+    evaluate_obligation::provide(p);\n+    lowering::provide(p);\n+    normalize_projection_ty::provide(p);\n+    normalize_erasing_regions::provide(p);\n+    type_op::provide(p);\n }"}, {"sha": "16aa63d6999972906213e0259cd7d9f8d9b43704", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -14,6 +14,7 @@ use rustc::hir::map::definitions::DefPathData;\n use rustc::hir::{self, ImplPolarity};\n use rustc::traits::{Clause, Clauses, DomainGoal, Goal, PolyDomainGoal, ProgramClause,\n                     WhereClause, FromEnv, WellFormed};\n+use rustc::ty::query::Providers;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Slice, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n@@ -22,6 +23,14 @@ use syntax::ast;\n \n use std::iter;\n \n+crate fn provide(p: &mut Providers) {\n+    *p = Providers {\n+        program_clauses_for,\n+        program_clauses_for_env,\n+        ..*p\n+    };\n+}\n+\n crate trait Lower<T> {\n     /// Lower a rustc construct (e.g. `ty::TraitPredicate`) to a chalk-like type.\n     fn lower(&self) -> T;"}, {"sha": "a85983d0e9a8164a6b9c5c27b8d337bc979c370c", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -10,10 +10,18 @@\n \n use rustc::traits::{Normalized, ObligationCause};\n use rustc::traits::query::NoSolution;\n+use rustc::ty::query::Providers;\n use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use std::sync::atomic::Ordering;\n \n-crate fn normalize_ty_after_erasing_regions<'tcx>(\n+crate fn provide(p: &mut Providers) {\n+    *p = Providers {\n+        normalize_ty_after_erasing_regions,\n+        ..*p\n+    };\n+}\n+\n+fn normalize_ty_after_erasing_regions<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     goal: ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Ty<'tcx> {"}, {"sha": "1c0f677fbf3cbf369f226ff07c9eb350006d89bf", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "modified", "additions": 40, "deletions": 30, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -9,45 +9,55 @@\n // except according to those terms.\n \n use rustc::infer::canonical::{Canonical, QueryResult};\n-use rustc::traits::{self, FulfillmentContext, ObligationCause, SelectionContext};\n-use rustc::traits::query::{CanonicalProjectionGoal, NoSolution, normalize::NormalizationResult};\n+use rustc::traits::query::{normalize::NormalizationResult, CanonicalProjectionGoal, NoSolution};\n+use rustc::traits::{self, ObligationCause, SelectionContext, TraitEngineExt};\n+use rustc::ty::query::Providers;\n use rustc::ty::{ParamEnvAnd, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n+use std::sync::atomic::Ordering;\n use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::DUMMY_SP;\n-use util;\n-use std::sync::atomic::Ordering;\n \n-crate fn normalize_projection_ty<'tcx>(\n+crate fn provide(p: &mut Providers) {\n+    *p = Providers {\n+        normalize_projection_ty,\n+        ..*p\n+    };\n+}\n+\n+fn normalize_projection_ty<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     goal: CanonicalProjectionGoal<'tcx>,\n ) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, NormalizationResult<'tcx>>>>, NoSolution> {\n     debug!(\"normalize_provider(goal={:#?})\", goal);\n \n-    tcx.sess.perf_stats.normalize_projection_ty.fetch_add(1, Ordering::Relaxed);\n-    tcx.infer_ctxt().enter(|ref infcx| {\n-        let (\n-            ParamEnvAnd {\n+    tcx.sess\n+        .perf_stats\n+        .normalize_projection_ty\n+        .fetch_add(1, Ordering::Relaxed);\n+    tcx.infer_ctxt().enter_canonical_trait_query(\n+        &goal,\n+        |infcx,\n+         fulfill_cx,\n+         ParamEnvAnd {\n+             param_env,\n+             value: goal,\n+         }| {\n+            let selcx = &mut SelectionContext::new(infcx);\n+            let cause = ObligationCause::misc(DUMMY_SP, DUMMY_NODE_ID);\n+            let mut obligations = vec![];\n+            let answer = traits::normalize_projection_type(\n+                selcx,\n                 param_env,\n-                value: goal,\n-            },\n-            canonical_inference_vars,\n-        ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &goal);\n-        let fulfill_cx = &mut FulfillmentContext::new();\n-        let selcx = &mut SelectionContext::new(infcx);\n-        let cause = ObligationCause::misc(DUMMY_SP, DUMMY_NODE_ID);\n-        let mut obligations = vec![];\n-        let answer =\n-            traits::normalize_projection_type(selcx, param_env, goal, cause, 0, &mut obligations);\n-        fulfill_cx.register_predicate_obligations(infcx, obligations);\n-\n-        // Now that we have fulfilled as much as we can, create a solution\n-        // from what we've learned.\n-        util::make_query_response(\n-            infcx,\n-            canonical_inference_vars,\n-            NormalizationResult { normalized_ty: answer },\n-            fulfill_cx,\n-        )\n-    })\n+                goal,\n+                cause,\n+                0,\n+                &mut obligations,\n+            );\n+            fulfill_cx.register_predicate_obligations(infcx, obligations);\n+            Ok(NormalizationResult {\n+                normalized_ty: answer,\n+            })\n+        },\n+    )\n }"}, {"sha": "8fe4290528e74d280fe4e2986b7351f6400cc18a", "filename": "src/librustc_traits/type_op.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::infer::canonical::{Canonical, QueryResult};\n+use rustc::infer::InferCtxt;\n+use rustc::traits::query::type_op::eq::Eq;\n+use rustc::traits::query::type_op::normalize::Normalize;\n+use rustc::traits::query::type_op::prove_predicate::ProvePredicate;\n+use rustc::traits::query::type_op::subtype::Subtype;\n+use rustc::traits::query::{Fallible, NoSolution};\n+use rustc::traits::{FulfillmentContext, Normalized, Obligation, ObligationCause, TraitEngine,\n+                    TraitEngineExt};\n+use rustc::ty::query::Providers;\n+use rustc::ty::{FnSig, Lift, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable};\n+use rustc_data_structures::sync::Lrc;\n+use std::fmt;\n+\n+crate fn provide(p: &mut Providers) {\n+    *p = Providers {\n+        type_op_eq,\n+        type_op_prove_predicate,\n+        type_op_subtype,\n+        type_op_normalize_ty,\n+        type_op_normalize_predicate,\n+        type_op_normalize_fn_sig,\n+        type_op_normalize_poly_fn_sig,\n+        ..*p\n+    };\n+}\n+\n+fn type_op_eq<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Eq<'tcx>>>,\n+) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, ()>>>, NoSolution> {\n+    tcx.infer_ctxt()\n+        .enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n+            let (param_env, Eq { a, b }) = key.into_parts();\n+            Ok(infcx\n+                .at(&ObligationCause::dummy(), param_env)\n+                .eq(a, b)?\n+                .into_value_registering_obligations(infcx, fulfill_cx))\n+        })\n+}\n+\n+fn type_op_normalize<T>(\n+    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    fulfill_cx: &mut FulfillmentContext<'tcx>,\n+    key: ParamEnvAnd<'tcx, Normalize<T>>,\n+) -> Fallible<T>\n+where\n+    T: fmt::Debug + TypeFoldable<'tcx> + Lift<'gcx>,\n+{\n+    let (param_env, Normalize { value }) = key.into_parts();\n+    let Normalized { value, obligations } = infcx\n+        .at(&ObligationCause::dummy(), param_env)\n+        .normalize(&value)?;\n+    fulfill_cx.register_predicate_obligations(infcx, obligations);\n+    Ok(value)\n+}\n+\n+fn type_op_normalize_ty(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Ty<'tcx>>>>,\n+) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, Ty<'tcx>>>>, NoSolution> {\n+    tcx.infer_ctxt()\n+        .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n+}\n+\n+fn type_op_normalize_predicate(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Predicate<'tcx>>>>,\n+) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, Predicate<'tcx>>>>, NoSolution> {\n+    tcx.infer_ctxt()\n+        .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n+}\n+\n+fn type_op_normalize_fn_sig(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<FnSig<'tcx>>>>,\n+) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, FnSig<'tcx>>>>, NoSolution> {\n+    tcx.infer_ctxt()\n+        .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n+}\n+\n+fn type_op_normalize_poly_fn_sig(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<PolyFnSig<'tcx>>>>,\n+) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, PolyFnSig<'tcx>>>>, NoSolution> {\n+    tcx.infer_ctxt()\n+        .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n+}\n+\n+fn type_op_subtype<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Subtype<'tcx>>>,\n+) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, ()>>>, NoSolution> {\n+    tcx.infer_ctxt()\n+        .enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n+            let (param_env, Subtype { sub, sup }) = key.into_parts();\n+            Ok(infcx\n+                .at(&ObligationCause::dummy(), param_env)\n+                .sup(sup, sub)?\n+                .into_value_registering_obligations(infcx, fulfill_cx))\n+        })\n+}\n+\n+fn type_op_prove_predicate<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, ProvePredicate<'tcx>>>,\n+) -> Result<Lrc<Canonical<'tcx, QueryResult<'tcx, ()>>>, NoSolution> {\n+    tcx.infer_ctxt()\n+        .enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n+            let (param_env, ProvePredicate { predicate }) = key.into_parts();\n+            fulfill_cx.register_predicate_obligation(\n+                infcx,\n+                Obligation::new(ObligationCause::dummy(), param_env, predicate),\n+            );\n+            Ok(())\n+        })\n+}"}, {"sha": "cdf20bdafadc40024990d6035823f5c416126b24", "filename": "src/librustc_traits/util.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/266afeb17c993f83d01d8129e97981a57bb442e0/src%2Flibrustc_traits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266afeb17c993f83d01d8129e97981a57bb442e0/src%2Flibrustc_traits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Futil.rs?ref=266afeb17c993f83d01d8129e97981a57bb442e0", "patch": "@@ -1,123 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::infer::InferCtxt;\n-use rustc::infer::canonical::{CanonicalVarValues, Canonicalize, Certainty, QueryResult};\n-use rustc::infer::region_constraints::{Constraint, RegionConstraintData};\n-use rustc::traits::{FulfillmentContext, TraitEngine};\n-use rustc::traits::query::NoSolution;\n-use rustc::ty;\n-use std::fmt::Debug;\n-\n-/// The canonicalization form of `QueryResult<'tcx, T>`.\n-type CanonicalizedQueryResult<'gcx, 'tcx, T> =\n-    <QueryResult<'tcx, T> as Canonicalize<'gcx, 'tcx>>::Canonicalized;\n-\n-crate fn make_query_response<'gcx, 'tcx, T>(\n-    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-    inference_vars: CanonicalVarValues<'tcx>,\n-    answer: T,\n-    fulfill_cx: &mut FulfillmentContext<'tcx>,\n-) -> Result<CanonicalizedQueryResult<'gcx, 'tcx, T>, NoSolution>\n-where\n-    T: Debug,\n-    QueryResult<'tcx, T>: Canonicalize<'gcx, 'tcx>,\n-{\n-    let tcx = infcx.tcx;\n-\n-    debug!(\n-        \"make_query_response(\\\n-         inference_vars={:?}, \\\n-         answer={:?})\",\n-        inference_vars, answer,\n-    );\n-\n-    // Select everything, returning errors.\n-    let true_errors = match fulfill_cx.select_where_possible(infcx) {\n-        Ok(()) => vec![],\n-        Err(errors) => errors,\n-    };\n-    debug!(\"true_errors = {:#?}\", true_errors);\n-\n-    if !true_errors.is_empty() {\n-        // FIXME -- we don't indicate *why* we failed to solve\n-        debug!(\"make_query_response: true_errors={:#?}\", true_errors);\n-        return Err(NoSolution);\n-    }\n-\n-    // Anything left unselected *now* must be an ambiguity.\n-    let ambig_errors = match fulfill_cx.select_all_or_error(infcx) {\n-        Ok(()) => vec![],\n-        Err(errors) => errors,\n-    };\n-    debug!(\"ambig_errors = {:#?}\", ambig_errors);\n-\n-    let region_obligations = infcx.take_registered_region_obligations();\n-\n-    let region_constraints = infcx.with_region_constraints(|region_constraints| {\n-        let RegionConstraintData {\n-            constraints,\n-            verifys,\n-            givens,\n-        } = region_constraints;\n-\n-        assert!(verifys.is_empty());\n-        assert!(givens.is_empty());\n-\n-        let mut outlives: Vec<_> = constraints\n-            .into_iter()\n-            .map(|(k, _)| match *k {\n-                // Swap regions because we are going from sub (<=) to outlives\n-                // (>=).\n-                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n-                    tcx.mk_region(ty::ReVar(v2)).into(),\n-                    tcx.mk_region(ty::ReVar(v1)),\n-                ),\n-                Constraint::VarSubReg(v1, r2) => {\n-                    ty::OutlivesPredicate(r2.into(), tcx.mk_region(ty::ReVar(v1)))\n-                }\n-                Constraint::RegSubVar(r1, v2) => {\n-                    ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n-                }\n-                Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n-            })\n-            .map(ty::Binder::dummy) // no bound regions in the code above\n-            .collect();\n-\n-        outlives.extend(\n-            region_obligations\n-                .into_iter()\n-                .map(|(_, r_o)| ty::OutlivesPredicate(r_o.sup_type.into(), r_o.sub_region))\n-                .map(ty::Binder::dummy) // no bound regions in the code above\n-        );\n-\n-        outlives\n-    });\n-\n-    let certainty = if ambig_errors.is_empty() {\n-        Certainty::Proven\n-    } else {\n-        Certainty::Ambiguous\n-    };\n-\n-    let (canonical_result, _) = infcx.canonicalize_response(&QueryResult {\n-        var_values: inference_vars,\n-        region_constraints,\n-        certainty,\n-        value: answer,\n-    });\n-\n-    debug!(\n-        \"make_query_response: canonical_result = {:#?}\",\n-        canonical_result\n-    );\n-\n-    Ok(canonical_result)\n-}"}, {"sha": "f9166851f6fcc75bfac80b0f48c39bd64b916310", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -16,7 +16,7 @@ use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;\n use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{ObligationCause, TraitEngine};\n+use rustc::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n use util::common::ErrorReported;\n \n use syntax::ast;"}, {"sha": "b18e5ca54ff476775b6ce75b0ddbe379a65f8768", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a9d6806d355b69fa66621df5208342de823aea/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=99a9d6806d355b69fa66621df5208342de823aea", "patch": "@@ -108,7 +108,7 @@ use rustc::infer::InferOk;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::query::Providers;\n-use rustc::traits::{ObligationCause, ObligationCauseCode, TraitEngine};\n+use rustc::traits::{ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt};\n use session::{CompileIncomplete, config};\n use util::common::time;\n "}]}