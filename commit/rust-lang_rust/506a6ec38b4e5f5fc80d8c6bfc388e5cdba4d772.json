{"sha": "506a6ec38b4e5f5fc80d8c6bfc388e5cdba4d772", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwNmE2ZWMzOGI0ZTVmNWZjODBkOGM2YmZjMzg4ZTVjZGJhNGQ3NzI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-03T14:29:28Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-03T14:37:41Z"}, "message": "Make syntax for impls less magical\n\nThe trick of interpreting parameters to the iface type as parameters\nto the impl was just too magical.\n\nIssue #1227", "tree": {"sha": "6b9919a8ead303d129dc04f0e0745b410a1fd91a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b9919a8ead303d129dc04f0e0745b410a1fd91a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/506a6ec38b4e5f5fc80d8c6bfc388e5cdba4d772", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/506a6ec38b4e5f5fc80d8c6bfc388e5cdba4d772", "html_url": "https://github.com/rust-lang/rust/commit/506a6ec38b4e5f5fc80d8c6bfc388e5cdba4d772", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/506a6ec38b4e5f5fc80d8c6bfc388e5cdba4d772/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60", "html_url": "https://github.com/rust-lang/rust/commit/e1dc40b2717c3469a52d3b8ae31b377dbd6e4d60"}], "stats": {"total": 41, "additions": 18, "deletions": 23}, "files": [{"sha": "1036b8e9f92a6f7af1ab01bb591e31f463233c65", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/506a6ec38b4e5f5fc80d8c6bfc388e5cdba4d772/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/506a6ec38b4e5f5fc80d8c6bfc388e5cdba4d772/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=506a6ec38b4e5f5fc80d8c6bfc388e5cdba4d772", "patch": "@@ -1850,34 +1850,29 @@ fn parse_item_iface(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                 ast::item_iface(tps, meths), attrs);\n }\n \n+// Parses three variants (with the initial params always optional):\n+//    impl <T: copy> of to_str for [T] { ... }\n+//    impl name<T> of to_str for [T] { ... }\n+//    impl name<T> for [T] { ... }\n fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n-    let lo = p.get_last_lo_pos(), ident, tps, ifce;\n+    let lo = p.get_last_lo_pos();\n     fn wrap_path(p: parser, pt: @ast::path) -> @ast::ty {\n         @{node: ast::ty_path(pt, p.get_id()), span: pt.span}\n     }\n-    if eat_word(p, \"of\") {\n+    let (ident, tps) = if !is_word(p, \"of\") {\n+        if p.peek() == token::LT { (none, parse_ty_params(p)) }\n+        else { (some(parse_ident(p)), parse_ty_params(p)) }\n+    } else { (none, []) };\n+    let ifce = if eat_word(p, \"of\") {\n         let path = parse_path_and_ty_param_substs(p, false);\n-        tps = vec::map(path.node.types, {|tp|\n-            alt tp.node {\n-              ast::ty_path(pt, _) {\n-                if vec::len(pt.node.idents) == 1u &&\n-                   vec::len(pt.node.types) == 0u {\n-                     ret {ident: pt.node.idents[0], id: p.get_id(),\n-                          bounds: @[]};\n-                }\n-              }\n-              _ {}\n-            }\n-            p.fatal(\"only single-word, parameter-less types allowed here\");\n-        });\n-        ident = path.node.idents[vec::len(path.node.idents)-1u];\n-        ifce = some(wrap_path(p, path));\n-    } else {\n-        ident = parse_ident(p);\n-        tps = parse_ty_params(p);\n-        ifce = if eat_word(p, \"of\") {\n-            some(wrap_path(p, parse_path_and_ty_param_substs(p, false)))\n-        } else { none };\n+        if option::is_none(ident) {\n+            ident = some(path.node.idents[vec::len(path.node.idents) - 1u]);\n+        }\n+        some(wrap_path(p, path))\n+    } else { none };\n+    let ident = alt ident {\n+        some(name) { name }\n+        none. { expect_word(p, \"of\"); fail; }\n     };\n     expect_word(p, \"for\");\n     let ty = parse_ty(p, false), meths = [];"}]}