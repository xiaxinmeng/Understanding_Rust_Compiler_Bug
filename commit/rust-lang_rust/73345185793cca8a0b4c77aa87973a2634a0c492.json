{"sha": "73345185793cca8a0b4c77aa87973a2634a0c492", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMzQ1MTg1NzkzY2NhOGEwYjRjNzdhYTg3OTczYTI2MzRhMGM0OTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-11T04:46:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-11T04:46:41Z"}, "message": "Auto merge of #25085 - carols10cents:remove-old-tilde, r=steveklabnik\n\nThere were still some mentions of `~[T]` and `~T`, mostly in comments and debugging statements. I tried to do my best to preserve meaning, but I might have gotten some wrong-- I'm happy to fix anything :)", "tree": {"sha": "52d526a0ac985c02e4ab105ff6f3fd8c4a989e74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52d526a0ac985c02e4ab105ff6f3fd8c4a989e74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73345185793cca8a0b4c77aa87973a2634a0c492", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73345185793cca8a0b4c77aa87973a2634a0c492", "html_url": "https://github.com/rust-lang/rust/commit/73345185793cca8a0b4c77aa87973a2634a0c492", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73345185793cca8a0b4c77aa87973a2634a0c492/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bef0b4bb0217fa530e4e2951458f215c4b346c84", "url": "https://api.github.com/repos/rust-lang/rust/commits/bef0b4bb0217fa530e4e2951458f215c4b346c84", "html_url": "https://github.com/rust-lang/rust/commit/bef0b4bb0217fa530e4e2951458f215c4b346c84"}, {"sha": "abc0017f3b2308c3bff2a975d4e33b53c2f52bdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/abc0017f3b2308c3bff2a975d4e33b53c2f52bdb", "html_url": "https://github.com/rust-lang/rust/commit/abc0017f3b2308c3bff2a975d4e33b53c2f52bdb"}], "stats": {"total": 128, "additions": 61, "deletions": 67}, "files": [{"sha": "0458bd70346c1b19d1ecbce422bb07da9ddcbb62", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -1125,7 +1125,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         // that case we can adjust the length of the\n                         // original vec accordingly, but we'd have to\n                         // make trans do the right thing, and it would\n-                        // only work for `~` vectors. It seems simpler\n+                        // only work for `Box<[T]>`s. It seems simpler\n                         // to just require that people call\n                         // `vec.pop()` or `vec.unshift()`.\n                         let slice_bk = ty::BorrowKind::from_mutbl(slice_mutbl);"}, {"sha": "222da6d7c3e5ef39ca6a6174d7d2b20632557273", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -323,7 +323,7 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n             def_id.krate == ast::LOCAL_CRATE\n         }\n \n-        ty::ty_uniq(_) => { // treat ~T like Box<T>\n+        ty::ty_uniq(_) => { // Box<T>\n             let krate = tcx.lang_items.owned_box().map(|d| d.krate);\n             krate == Some(ast::LOCAL_CRATE)\n         }"}, {"sha": "9a5e7219aaa8ca552ccc768a12cb7a4e66bde736", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -2441,10 +2441,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// `match_impl()`. For example, if `impl_def_id` is declared\n     /// as:\n     ///\n-    ///    impl<T:Copy> Foo for ~T { ... }\n+    ///    impl<T:Copy> Foo for Box<T> { ... }\n     ///\n-    /// and `obligation_self_ty` is `int`, we'd back an `Err(_)`\n-    /// result. But if `obligation_self_ty` were `~int`, we'd get\n+    /// and `obligation_self_ty` is `int`, we'd get back an `Err(_)`\n+    /// result. But if `obligation_self_ty` were `Box<int>`, we'd get\n     /// back `Ok(T=int)`.\n     fn match_inherent_impl(&mut self,\n                            impl_def_id: ast::DefId,"}, {"sha": "32ec70c487887d51c2bcc4e4929e1659e4596491", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -637,7 +637,7 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n     }\n }\n \n-// This is necessary to handle types like Option<~[T]>, for which\n+// This is necessary to handle types like Option<Vec<T>>, for which\n // autoderef cannot convert the &[T] handler\n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {"}, {"sha": "839b39a8ca003a304170dc613a38241cbfbae8b4", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -732,7 +732,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     /// let p: Point;\n     /// p.x = 22; // ok, even though `p` is uninitialized\n     ///\n-    /// let p: ~Point;\n+    /// let p: Box<Point>;\n     /// (*p).x = 22; // not ok, p is uninitialized, can't deref\n     /// ```\n     fn check_if_assigned_path_is_moved(&self,"}, {"sha": "9a8bbc5ea0bc0c99426fb953e95c2d6730de7327", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -1314,7 +1314,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // impl [... for] Public<...>, but not `impl [... for]\n-                // ~[Public]` or `(Public,)` etc.\n+                // Vec<Public>` or `(Public,)` etc.\n                 let self_is_public_path;\n \n                 // check the properties of the Self type:"}, {"sha": "38ad909dd012e41eca1c583080256cbbb6cabe2a", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -289,7 +289,7 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n     // when using unix's linker. Perhaps one day when we just use a linker from LLVM\n     // we won't need to do this name mangling. The problem with name mangling is\n     // that it seriously limits the available characters. For example we can't\n-    // have things like &T or ~[T] in symbol names when one would theoretically\n+    // have things like &T in symbol names when one would theoretically\n     // want them for things like impls of traits on that type.\n     //\n     // To be able to work on all platforms and get *some* reasonable output, we"}, {"sha": "504663571f5338e3ed04ae5842398813c8e11d24", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -230,8 +230,8 @@ impl<'a> SpanUtils<'a> {\n     // Reparse span and return an owned vector of sub spans of the first limit\n     // identifier tokens in the given nesting level.\n     // example with Foo<Bar<T,V>, Bar<T,V>>\n-    // Nesting = 0: all idents outside of brackets: ~[Foo]\n-    // Nesting = 1: idents within one level of brackets: ~[Bar, Bar]\n+    // Nesting = 0: all idents outside of brackets: Vec<Foo>\n+    // Nesting = 1: idents within one level of brackets: Vec<Bar, Bar>\n     pub fn spans_with_brackets(&self, span: Span, nesting: isize, limit: isize) -> Vec<Span> {\n         let mut result: Vec<Span> = vec!();\n \n@@ -352,7 +352,7 @@ impl<'a> SpanUtils<'a> {\n             return vec!();\n         }\n         // Type params are nested within one level of brackets:\n-        // i.e. we want ~[A, B] from Foo<A, B<T,U>>\n+        // i.e. we want Vec<A, B> from Foo<A, B<T,U>>\n         self.spans_with_brackets(span, 1, number)\n     }\n "}, {"sha": "132947e34d795e052da61c5214e1960077ad4668", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -196,7 +196,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             // The `noalias` attribute on the return value is useful to a\n             // function ptr caller.\n             match ret_ty.sty {\n-                // `~` pointer return values never alias because ownership\n+                // `Box` pointer return values never alias because ownership\n                 // is transferred\n                 ty::ty_uniq(it) if common::type_is_sized(ccx.tcx(), it) => {\n                     attrs.ret(llvm::Attribute::NoAlias);\n@@ -239,7 +239,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 attrs.arg(idx, llvm::Attribute::ZExt);\n             }\n \n-            // `~` pointer parameters never alias because ownership is transferred\n+            // `Box` pointer parameters never alias because ownership is transferred\n             ty::ty_uniq(inner) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n "}, {"sha": "bd04bd7a75460d0e0b44e37f55c7a6aa84e9bebd", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -142,26 +142,24 @@ impl<'tcx> TypeMap<'tcx> {\n     fn get_unique_type_id_of_type<'a>(&mut self, cx: &CrateContext<'a, 'tcx>,\n                                       type_: Ty<'tcx>) -> UniqueTypeId {\n \n-        // basic type           -> {:name of the type:}\n-        // tuple                -> {tuple_(:param-uid:)*}\n-        // struct               -> {struct_:svh: / :node-id:_<(:param-uid:),*> }\n-        // enum                 -> {enum_:svh: / :node-id:_<(:param-uid:),*> }\n-        // enum variant         -> {variant_:variant-name:_:enum-uid:}\n-        // reference (&)        -> {& :pointee-uid:}\n-        // mut reference (&mut) -> {&mut :pointee-uid:}\n-        // ptr (*)              -> {* :pointee-uid:}\n-        // mut ptr (*mut)       -> {*mut :pointee-uid:}\n-        // unique ptr (~)       -> {~ :pointee-uid:}\n-        // @-ptr (@)            -> {@ :pointee-uid:}\n-        // sized vec ([T; x])   -> {[:size:] :element-uid:}\n-        // unsized vec ([T])    -> {[] :element-uid:}\n-        // trait (T)            -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n-        // closure              -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n+        // basic type             -> {:name of the type:}\n+        // tuple                  -> {tuple_(:param-uid:)*}\n+        // struct                 -> {struct_:svh: / :node-id:_<(:param-uid:),*> }\n+        // enum                   -> {enum_:svh: / :node-id:_<(:param-uid:),*> }\n+        // enum variant           -> {variant_:variant-name:_:enum-uid:}\n+        // reference (&)          -> {& :pointee-uid:}\n+        // mut reference (&mut)   -> {&mut :pointee-uid:}\n+        // ptr (*)                -> {* :pointee-uid:}\n+        // mut ptr (*mut)         -> {*mut :pointee-uid:}\n+        // unique ptr (box)       -> {box :pointee-uid:}\n+        // @-ptr (@)              -> {@ :pointee-uid:}\n+        // sized vec ([T; x])     -> {[:size:] :element-uid:}\n+        // unsized vec ([T])      -> {[] :element-uid:}\n+        // trait (T)              -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n+        // closure                -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n         //                             :return-type-uid: : (:bounds:)*}\n-        // function             -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n+        // function               -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n         //                             :return-type-uid:}\n-        // unique vec box (~[]) -> {HEAP_VEC_BOX<:pointee-uid:>}\n-        // gc box               -> {GC_BOX<:pointee-uid:>}\n \n         match self.type_to_unique_id.get(&type_).cloned() {\n             Some(unique_type_id) => return unique_type_id,\n@@ -202,7 +200,7 @@ impl<'tcx> TypeMap<'tcx> {\n                 }\n             },\n             ty::ty_uniq(inner_type) => {\n-                unique_type_id.push('~');\n+                unique_type_id.push_str(\"box \");\n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n                 unique_type_id.push_str(&inner_type_id[..]);"}, {"sha": "3769e9fa0f36a025c2b5cbab6fd3963e4ee97abf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -2458,7 +2458,7 @@ fn check_expr_with_lvalue_pref<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, expr: &'tcx ast::\n }\n \n // determine the `self` type, using fresh variables for all variables\n-// declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n+// declared on the impl declaration e.g., `impl<A,B> for Vec<(A,B)>`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n pub fn impl_self_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,"}, {"sha": "7c062d354d395f2d2cf2408fee973a56be7cd74b", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -178,8 +178,8 @@\n //! further that for whatever reason I specifically supply the value of\n //! `String` for the type parameter `T`:\n //!\n-//!     let mut vector = ~[\"string\", ...];\n-//!     convertAll::<int, String>(v);\n+//!     let mut vector = vec![\"string\", ...];\n+//!     convertAll::<int, String>(vector);\n //!\n //! Is this legal? To put another way, can we apply the `impl` for\n //! `Object` to the type `String`? The answer is yes, but to see why"}, {"sha": "4c2357f8a8f0d05b1df64fbbe00cafe4997a53e0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -897,7 +897,7 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-// maybe use a Generic enum and use ~[Generic]?\n+// maybe use a Generic enum and use Vec<Generic>?\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct Generics {\n     pub lifetimes: Vec<Lifetime>,"}, {"sha": "f7511f9753aa18a975c3e702ee5c9f4f267fb2e8", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -896,8 +896,8 @@ impl<'a> MethodDef<'a> {\n                                  nonself_args: &[P<Expr>])\n         -> P<Expr> {\n \n-        let mut raw_fields = Vec::new(); // ~[[fields of self],\n-                                 // [fields of next Self arg], [etc]]\n+        let mut raw_fields = Vec::new(); // Vec<[fields of self],\n+                                 // [fields of next Self arg], [etc]>\n         let mut patterns = Vec::new();\n         for i in 0..self_args.len() {\n             let struct_path= cx.path(DUMMY_SP, vec!( type_ident ));"}, {"sha": "05499959b758598f5b83259c5f3b1d86aedab79d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -1692,7 +1692,7 @@ mod tests {\n     // induced by visit.  Each of these arrays contains a list of indexes,\n     // interpreted as the varrefs in the varref traversal that this binding\n     // should match.  So, for instance, in a program with two bindings and\n-    // three varrefs, the array ~[~[1,2],~[0]] would indicate that the first\n+    // three varrefs, the array [[1, 2], [0]] would indicate that the first\n     // binding should match the second two varrefs, and the second binding\n     // should match the first varref.\n     //"}, {"sha": "ed9937c53f4af80a27dd02dd3ffb71676fd1623a", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -312,7 +312,7 @@ impl<'a> Printer<'a> {\n         self.token[self.right] = t;\n     }\n     pub fn pretty_print(&mut self, token: Token) -> io::Result<()> {\n-        debug!(\"pp ~[{},{}]\", self.left, self.right);\n+        debug!(\"pp Vec<{},{}>\", self.left, self.right);\n         match token {\n           Token::Eof => {\n             if !self.scan_stack_empty {\n@@ -329,7 +329,7 @@ impl<'a> Printer<'a> {\n                 self.left = 0;\n                 self.right = 0;\n             } else { self.advance_right(); }\n-            debug!(\"pp Begin({})/buffer ~[{},{}]\",\n+            debug!(\"pp Begin({})/buffer Vec<{},{}>\",\n                    b.offset, self.left, self.right);\n             self.token[self.right] = token;\n             self.size[self.right] = -self.right_total;\n@@ -339,10 +339,10 @@ impl<'a> Printer<'a> {\n           }\n           Token::End => {\n             if self.scan_stack_empty {\n-                debug!(\"pp End/print ~[{},{}]\", self.left, self.right);\n+                debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n                 self.print(token, 0)\n             } else {\n-                debug!(\"pp End/buffer ~[{},{}]\", self.left, self.right);\n+                debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = token;\n                 self.size[self.right] = -1;\n@@ -358,7 +358,7 @@ impl<'a> Printer<'a> {\n                 self.left = 0;\n                 self.right = 0;\n             } else { self.advance_right(); }\n-            debug!(\"pp Break({})/buffer ~[{},{}]\",\n+            debug!(\"pp Break({})/buffer Vec<{},{}>\",\n                    b.offset, self.left, self.right);\n             self.check_stack(0);\n             let right = self.right;\n@@ -370,11 +370,11 @@ impl<'a> Printer<'a> {\n           }\n           Token::String(s, len) => {\n             if self.scan_stack_empty {\n-                debug!(\"pp String('{}')/print ~[{},{}]\",\n+                debug!(\"pp String('{}')/print Vec<{},{}>\",\n                        s, self.left, self.right);\n                 self.print(Token::String(s, len), len)\n             } else {\n-                debug!(\"pp String('{}')/buffer ~[{},{}]\",\n+                debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n                        s, self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = Token::String(s, len);\n@@ -386,7 +386,7 @@ impl<'a> Printer<'a> {\n         }\n     }\n     pub fn check_stream(&mut self) -> io::Result<()> {\n-        debug!(\"check_stream ~[{}, {}] with left_total={}, right_total={}\",\n+        debug!(\"check_stream Vec<{}, {}> with left_total={}, right_total={}\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n             debug!(\"scan window is {}, longer than space on line ({})\",\n@@ -446,7 +446,7 @@ impl<'a> Printer<'a> {\n         assert!((self.right != self.left));\n     }\n     pub fn advance_left(&mut self) -> io::Result<()> {\n-        debug!(\"advance_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n+        debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,\n                self.left, self.size[self.left]);\n \n         let mut left_size = self.size[self.left];"}, {"sha": "00ef8760985be4842fd41774a76bd7cbc157db30", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -259,8 +259,8 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn> ) {\n // This will panic (intentionally) when fed any dynamic tests, because\n // it is copying the static values out into a dynamic vector and cannot\n // copy dynamic values. It is doing this because from this point on\n-// a ~[TestDescAndFn] is used in order to effect ownership-transfer\n-// semantics into parallel test runners, which in turn requires a ~[]\n+// a Vec<TestDescAndFn> is used in order to effect ownership-transfer\n+// semantics into parallel test runners, which in turn requires a Vec<>\n // rather than a &[].\n pub fn test_main_static(args: env::Args, tests: &[TestDescAndFn]) {\n     let args = args.collect::<Vec<_>>();"}, {"sha": "95ab2bbab14a3e7e2f8f48db73242a2d78e71dc6", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -37,7 +37,7 @@ fn test<'a,T,U:Copy>(_: &'a isize) {\n     assert_copy::<&'static mut isize>(); //~ ERROR `core::marker::Copy` is not implemented\n     assert_copy::<&'a mut isize>();  //~ ERROR `core::marker::Copy` is not implemented\n \n-    // ~ pointers are not ok\n+    // owned pointers are not ok\n     assert_copy::<Box<isize>>();   //~ ERROR `core::marker::Copy` is not implemented\n     assert_copy::<String>();   //~ ERROR `core::marker::Copy` is not implemented\n     assert_copy::<Vec<isize> >(); //~ ERROR `core::marker::Copy` is not implemented"}, {"sha": "dea2a0c5a23f8180c0779c39b6b43f610511b5c3", "filename": "src/test/debuginfo/issue11600.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Ftest%2Fdebuginfo%2Fissue11600.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Ftest%2Fdebuginfo%2Fissue11600.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue11600.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -13,7 +13,7 @@\n // ignore-test\n \n fn main() {\n-    let args : ~[String] = ::std::os::args();\n+    let args : Vec<String> = ::std::os::args();\n     ::std::io::println(args[0]);\n }\n \n@@ -25,6 +25,6 @@ fn main() {\n // compile-flags:-g\n // gdb-command:list\n // gdb-check:1[...]fn main() {\n-// gdb-check:2[...]let args : ~[String] = ::std::os::args();\n+// gdb-check:2[...]let args : Vec<String> = ::std::os::args();\n // gdb-check:3[...]::std::io::println(args[0]);\n // gdb-check:4[...]}"}, {"sha": "72a23b998e5a16dc587722cfaf9ca54cae3e1308", "filename": "src/test/run-pass/const-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-bound.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -20,7 +20,7 @@ struct F { field: isize }\n pub fn main() {\n     /*foo(1);\n     foo(\"hi\".to_string());\n-    foo(~[1, 2, 3]);\n+    foo(vec![1, 2, 3]);\n     foo(F{field: 42});\n     foo((1, 2));\n     foo(@1);*/"}, {"sha": "e6b577ada0c869a55f93d8ec4fa54616fb7e1e94", "filename": "src/test/run-pass/issue-3556.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3556.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -32,10 +32,6 @@ fn check_strs(actual: &str, expected: &str) -> bool\n \n pub fn main()\n {\n-// assert!(check_strs(fmt!(\"%?\", Text(@\"foo\".to_string())), \"Text(@~\\\"foo\\\")\"));\n-// assert!(check_strs(fmt!(\"%?\", ETag(@~[\"foo\".to_string()], @\"bar\".to_string())),\n-//                    \"ETag(@~[ ~\\\"foo\\\" ], @~\\\"bar\\\")\"));\n-\n     let t = Token::Text(\"foo\".to_string());\n     let u = Token::Section(vec![\"alpha\".to_string()],\n                     true,"}, {"sha": "ab75c2064a403667f5edd6168cfacdb25d409e2e", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73345185793cca8a0b4c77aa87973a2634a0c492/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=73345185793cca8a0b4c77aa87973a2634a0c492", "patch": "@@ -22,8 +22,8 @@ use std::io::{ReaderUtil,WriterUtil};\n enum Result {\n   Nil,\n   Int(isize),\n-  Data(~[u8]),\n-  List(~[Result]),\n+  Data(Vec<u8>),\n+  List(Vec<Result>),\n   Error(String),\n   Status(String)\n }\n@@ -35,15 +35,15 @@ fn parse_data(len: usize, io: @io::Reader) -> Result {\n       assert_eq!(bytes.len(), len);\n       Data(bytes)\n   } else {\n-      Data(~[])\n+      Data(vec![])\n   };\n   assert_eq!(io.read_char(), '\\r');\n   assert_eq!(io.read_char(), '\\n');\n   return res;\n }\n \n fn parse_list(len: usize, io: @io::Reader) -> Result {\n-    let mut list: ~[Result] = ~[];\n+    let mut list: Vec<Result> = vec![];\n     for _ in 0..len {\n         let v = match io.read_char() {\n             '$' => parse_bulk(io),\n@@ -72,7 +72,7 @@ fn parse_multi(io: @io::Reader) -> Result {\n     match from_str::<isize>(chop(io.read_line())) {\n     None => panic!(),\n     Some(-1) => Nil,\n-    Some(0) => List(~[]),\n+    Some(0) => List(vec![]),\n     Some(len) if len >= 0 => parse_list(len as usize, io),\n     Some(_) => panic!()\n     }\n@@ -96,7 +96,7 @@ fn parse_response(io: @io::Reader) -> Result {\n     }\n }\n \n-fn cmd_to_string(cmd: ~[String]) -> String {\n+fn cmd_to_string(cmd: Vec<String>) -> String {\n   let mut res = \"*\".to_string();\n   res.push_str(cmd.len().to_string());\n   res.push_str(\"\\r\\n\");\n@@ -107,15 +107,15 @@ fn cmd_to_string(cmd: ~[String]) -> String {\n   res\n }\n \n-fn query(cmd: ~[String], sb: TcpSocketBuf) -> Result {\n+fn query(cmd: Vec<String>, sb: TcpSocketBuf) -> Result {\n   let cmd = cmd_to_string(cmd);\n   //println!(\"{}\", cmd);\n   sb.write_str(cmd);\n   let res = parse_response(@sb as @io::Reader);\n   res\n }\n \n-fn query2(cmd: ~[String]) -> Result {\n+fn query2(cmd: Vec<String>) -> Result {\n   let _cmd = cmd_to_string(cmd);\n     io::with_str_reader(\"$3\\r\\nXXX\\r\\n\".to_string())(|sb| {\n     let res = parse_response(@sb as @io::Reader);"}]}