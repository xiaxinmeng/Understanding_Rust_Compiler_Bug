{"sha": "7d2f75a953b5645d3a336b2978b48b60d310bf54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMmY3NWE5NTNiNTY0NWQzYTMzNmIyOTc4YjQ4YjYwZDMxMGJmNTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-09T22:48:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-09T22:48:37Z"}, "message": "Auto merge of #34095 - petrochenkov:pathir2, r=jseyfried\n\nImprovements to pattern resolution + some refactoring\n\nContinuation of https://github.com/rust-lang/rust/pull/33929\nFirst commit is a careful rewrite of `resolve_pattern`, pattern path resolution and new binding creation logic is factored out in separate functions, some minor bugs are fixed. Also, `resolve_possibly_assoc_item` doesn't swallow modules now.\nLater commits are refactorings, see the comment descriptions.\n\nI intend to continue this work later with better support for `Def::Err` in patterns in post-resolve stages and cleanup of pattern resolution code in type checker.\n\nFixes https://github.com/rust-lang/rust/issues/32086\nFixes https://github.com/rust-lang/rust/issues/34047 ([breaking-change])\nFixes https://github.com/rust-lang/rust/issues/34074\n\ncc @jseyfried\nr? @eddyb", "tree": {"sha": "e08cdb6ca15086992180b9b05204f67801cdc0a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e08cdb6ca15086992180b9b05204f67801cdc0a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d2f75a953b5645d3a336b2978b48b60d310bf54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d2f75a953b5645d3a336b2978b48b60d310bf54", "html_url": "https://github.com/rust-lang/rust/commit/7d2f75a953b5645d3a336b2978b48b60d310bf54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d2f75a953b5645d3a336b2978b48b60d310bf54/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee00760a14020d73e8ad509b2ddbd3054101db6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee00760a14020d73e8ad509b2ddbd3054101db6f", "html_url": "https://github.com/rust-lang/rust/commit/ee00760a14020d73e8ad509b2ddbd3054101db6f"}, {"sha": "6d7b35bd98858a8095fbc205115cedf069434f7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d7b35bd98858a8095fbc205115cedf069434f7f", "html_url": "https://github.com/rust-lang/rust/commit/6d7b35bd98858a8095fbc205115cedf069434f7f"}], "stats": {"total": 1913, "additions": 696, "deletions": 1217}, "files": [{"sha": "18ea17f48162f1b66c168c00d3246d8b9b7712b3", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -574,8 +574,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             return *self.loop_scopes.last().unwrap();\n         }\n \n-        match self.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n-            Some(Def::Label(loop_id)) => {\n+        match self.tcx.expect_def(expr.id) {\n+            Def::Label(loop_id) => {\n                 for l in &self.loop_scopes {\n                     if l.loop_id == loop_id {\n                         return *l;"}, {"sha": "72261c473e5c5d6a252733f988b43956f681ef78", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -67,6 +67,10 @@ pub struct PathResolution {\n }\n \n impl PathResolution {\n+    pub fn new(def: Def) -> PathResolution {\n+        PathResolution { base_def: def, depth: 0 }\n+    }\n+\n     /// Get the definition, if fully resolved, otherwise panic.\n     pub fn full_def(&self) -> Def {\n         if self.depth != 0 {\n@@ -75,17 +79,11 @@ impl PathResolution {\n         self.base_def\n     }\n \n-    /// Get the DefId, if fully resolved, otherwise panic.\n-    pub fn def_id(&self) -> DefId {\n-        self.full_def().def_id()\n-    }\n-\n-    pub fn new(base_def: Def,\n-               depth: usize)\n-               -> PathResolution {\n-        PathResolution {\n-            base_def: base_def,\n-            depth: depth,\n+    pub fn kind_name(&self) -> &'static str {\n+        if self.depth != 0 {\n+            \"associated item\"\n+        } else {\n+            self.base_def.kind_name()\n         }\n     }\n }\n@@ -161,8 +159,8 @@ impl Def {\n             Def::Struct(..) => \"struct\",\n             Def::Trait(..) => \"trait\",\n             Def::Method(..) => \"method\",\n-            Def::Const(..) => \"const\",\n-            Def::AssociatedConst(..) => \"associated const\",\n+            Def::Const(..) => \"constant\",\n+            Def::AssociatedConst(..) => \"associated constant\",\n             Def::TyParam(..) => \"type parameter\",\n             Def::PrimTy(..) => \"builtin type\",\n             Def::Local(..) => \"local variable\","}, {"sha": "69cf5baa26fecc5d7013fb94f01f67e2e2363e9a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -866,7 +866,7 @@ impl<'a> LoweringContext<'a> {\n                 PatKind::Wild => hir::PatKind::Wild,\n                 PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n                     self.with_parent_def(p.id, |this| {\n-                        match this.resolver.get_resolution(p.id).map(|d| d.full_def()) {\n+                        match this.resolver.get_resolution(p.id).map(|d| d.base_def) {\n                             // `None` can occur in body-less function signatures\n                             None | Some(Def::Local(..)) => {\n                                 hir::PatKind::Binding(this.lower_binding_mode(binding_mode),\n@@ -1238,14 +1238,10 @@ impl<'a> LoweringContext<'a> {\n                             position: position,\n                         }\n                     });\n-                    let rename = if path.segments.len() == 1 {\n-                        // Only local variables are renamed\n-                        match self.resolver.get_resolution(e.id).map(|d| d.full_def()) {\n-                            Some(Def::Local(..)) | Some(Def::Upvar(..)) => true,\n-                            _ => false,\n-                        }\n-                    } else {\n-                        false\n+                    // Only local variables are renamed\n+                    let rename = match self.resolver.get_resolution(e.id).map(|d| d.base_def) {\n+                        Some(Def::Local(..)) | Some(Def::Upvar(..)) => true,\n+                        _ => false,\n                     };\n                     hir::ExprPath(hir_qself, self.lower_path_full(path, rename))\n                 }"}, {"sha": "6405be7455dfef3f1d8dac2f62a5df81c40782c6", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -53,16 +53,6 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n     }\n }\n \n-// This is used because same-named variables in alternative patterns need to\n-// use the NodeId of their namesake in the first pattern.\n-pub fn pat_id_map(pat: &hir::Pat) -> PatIdMap {\n-    let mut map = FnvHashMap();\n-    pat_bindings(pat, |_bm, p_id, _s, path1| {\n-        map.insert(path1.node, p_id);\n-    });\n-    map\n-}\n-\n pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n         PatKind::Lit(_) | PatKind::Range(_, _) | PatKind::QPath(..) => true,"}, {"sha": "27896b09981210d91ba2cbc32beb802a60b6bd18", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -1357,17 +1357,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                     ty_queue.push(&mut_ty.ty);\n                 }\n                 hir::TyPath(ref maybe_qself, ref path) => {\n-                    let a_def = match self.tcx.def_map.borrow().get(&cur_ty.id) {\n-                        None => {\n-                            self.tcx\n-                                .sess\n-                                .fatal(&format!(\n-                                        \"unbound path {}\",\n-                                        pprust::path_to_string(path)))\n-                        }\n-                        Some(d) => d.full_def()\n-                    };\n-                    match a_def {\n+                    match self.tcx.expect_def(cur_ty.id) {\n                         Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) => {\n                             let generics = self.tcx.lookup_item_type(did).generics;\n "}, {"sha": "f132212415f2f4d43ca4d7a84b3ca60cd7a49b93", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -65,13 +65,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// to it.\n     pub fn ast_ty_to_prim_ty(self, ast_ty: &ast::Ty) -> Option<Ty<'tcx>> {\n         if let ast::TyPath(None, ref path) = ast_ty.node {\n-            let def = match self.def_map.borrow().get(&ast_ty.id) {\n-                None => {\n-                    span_bug!(ast_ty.span, \"unbound path {:?}\", path)\n-                }\n-                Some(d) => d.full_def()\n-            };\n-            if let Def::PrimTy(nty) = def {\n+            if let Def::PrimTy(nty) = self.expect_def(ast_ty.id) {\n                 Some(self.prim_ty_to_ty(&path.segments, nty))\n             } else {\n                 None"}, {"sha": "e65074a4f07b3b64e8480b4a249af5cf1f4e6873", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -84,36 +84,35 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n+    fn lookup_and_handle_definition(&mut self, id: ast::NodeId) {\n         use ty::TypeVariants::{TyEnum, TyStruct};\n \n         // If `bar` is a trait item, make sure to mark Foo as alive in `Foo::bar`\n-        self.tcx.tables.borrow().item_substs.get(id)\n+        self.tcx.tables.borrow().item_substs.get(&id)\n             .and_then(|substs| substs.substs.self_ty())\n             .map(|ty| match ty.sty {\n                 TyEnum(tyid, _) | TyStruct(tyid, _) => self.check_def_id(tyid.did),\n                 _ => (),\n             });\n \n-        self.tcx.def_map.borrow().get(id).map(|def| {\n-            match def.full_def() {\n-                Def::Const(_) | Def::AssociatedConst(..) => {\n-                    self.check_def_id(def.def_id());\n-                }\n-                _ if self.ignore_non_const_paths => (),\n-                Def::PrimTy(_) => (),\n-                Def::SelfTy(..) => (),\n-                Def::Variant(enum_id, variant_id) => {\n-                    self.check_def_id(enum_id);\n-                    if !self.ignore_variant_stack.contains(&variant_id) {\n-                        self.check_def_id(variant_id);\n-                    }\n-                }\n-                _ => {\n-                    self.check_def_id(def.def_id());\n+        let def = self.tcx.expect_def(id);\n+        match def {\n+            Def::Const(_) | Def::AssociatedConst(..) => {\n+                self.check_def_id(def.def_id());\n+            }\n+            _ if self.ignore_non_const_paths => (),\n+            Def::PrimTy(_) => (),\n+            Def::SelfTy(..) => (),\n+            Def::Variant(enum_id, variant_id) => {\n+                self.check_def_id(enum_id);\n+                if !self.ignore_variant_stack.contains(&variant_id) {\n+                    self.check_def_id(variant_id);\n                 }\n             }\n-        });\n+            _ => {\n+                self.check_def_id(def.def_id());\n+            }\n+        }\n     }\n \n     fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n@@ -138,10 +137,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n-        let def = self.tcx.def_map.borrow().get(&lhs.id).unwrap().full_def();\n-        let pat_ty = self.tcx.node_id_to_type(lhs.id);\n-        let variant = match pat_ty.sty {\n-            ty::TyStruct(adt, _) | ty::TyEnum(adt, _) => adt.variant_of_def(def),\n+        let variant = match self.tcx.node_id_to_type(lhs.id).sty {\n+            ty::TyStruct(adt, _) | ty::TyEnum(adt, _) => {\n+                adt.variant_of_def(self.tcx.expect_def(lhs.id))\n+            }\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n@@ -272,7 +271,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n             }\n             _ if pat_util::pat_is_const(&def_map.borrow(), pat) => {\n                 // it might be the only use of a const\n-                self.lookup_and_handle_definition(&pat.id)\n+                self.lookup_and_handle_definition(pat.id)\n             }\n             _ => ()\n         }\n@@ -283,12 +282,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n-        self.lookup_and_handle_definition(&id);\n+        self.lookup_and_handle_definition(id);\n         intravisit::walk_path(self, path);\n     }\n \n     fn visit_path_list_item(&mut self, path: &hir::Path, item: &hir::PathListItem) {\n-        self.lookup_and_handle_definition(&item.node.id());\n+        self.lookup_and_handle_definition(item.node.id());\n         intravisit::walk_path_list_item(self, path, item);\n     }\n }"}, {"sha": "24816d2b497295e81c1a7d207fac0c68efe4f86c", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -172,7 +172,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n             hir::ExprPath(..) => {\n-                if let Def::Static(_, true) = self.tcx.resolve_expr(expr) {\n+                if let Def::Static(_, true) = self.tcx.expect_def(expr.id) {\n                     self.require_unsafe(expr.span, \"use of mutable static\");\n                 }\n             }"}, {"sha": "3b571ed057602955c855148fffe1f1e152036a95", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -955,9 +955,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr,\n                pat);\n \n+        let tcx = &self.tcx();\n         let mc = &self.mc;\n         let infcx = self.mc.infcx;\n-        let def_map = &self.tcx().def_map;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             match pat.node {\n@@ -972,8 +972,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n                     // Each match binding is effectively an assignment to the\n                     // binding being produced.\n-                    let def = def_map.borrow().get(&pat.id).unwrap().full_def();\n-                    if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty, def) {\n+                    if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty,\n+                                                        tcx.expect_def(pat.id)) {\n                         delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n                     }\n \n@@ -1002,14 +1002,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n-            let def_map = def_map.borrow();\n-            let tcx = infcx.tcx;\n-\n             match pat.node {\n                 PatKind::Struct(..) | PatKind::TupleStruct(..) |\n                 PatKind::Path(..) | PatKind::QPath(..) => {\n-                    match def_map.get(&pat.id).map(|d| d.full_def()) {\n-                        Some(Def::Variant(enum_did, variant_did)) => {\n+                    match tcx.expect_def(pat.id) {\n+                        Def::Variant(enum_did, variant_did) => {\n                             let downcast_cmt =\n                                 if tcx.lookup_adt_def(enum_did).is_univariant() {\n                                     cmt_pat\n@@ -1025,7 +1022,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                             delegate.matched_pat(pat, downcast_cmt, match_mode);\n                         }\n \n-                        Some(Def::Struct(..)) | Some(Def::TyAlias(..)) => {\n+                        Def::Struct(..) | Def::TyAlias(..) => {\n                             // A struct (in either the value or type\n                             // namespace; we encounter the former on\n                             // e.g. patterns for unit structs).\n@@ -1037,8 +1034,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                             delegate.matched_pat(pat, cmt_pat, match_mode);\n                         }\n \n-                        Some(Def::Const(..)) |\n-                        Some(Def::AssociatedConst(..)) => {\n+                        Def::Const(..) | Def::AssociatedConst(..) => {\n                             // This is a leaf (i.e. identifier binding\n                             // or constant value to match); thus no\n                             // `matched_pat` call."}, {"sha": "70158e9b9dff7704e12c16461b3999277db354da", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -156,7 +156,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         if let hir::ExprPath(..) = expr.node {\n-            match self.infcx.tcx.resolve_expr(expr) {\n+            match self.infcx.tcx.expect_def(expr.id) {\n                 Def::Fn(did) if self.def_id_is_transmute(did) => {\n                     let typ = self.infcx.tcx.node_id_to_type(expr.id);\n                     match typ.sty {"}, {"sha": "ceffa366413fa3aaf0893c13f90325f217e1abb4", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -445,7 +445,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       hir::ExprPath(..) => {\n-        let def = ir.tcx.def_map.borrow().get(&expr.id).unwrap().full_def();\n+        let def = ir.tcx.expect_def(expr.id);\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if let Def::Local(..) = def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -695,8 +695,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             Some(_) => {\n                 // Refers to a labeled loop. Use the results of resolve\n                 // to find with one\n-                match self.ir.tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n-                    Some(Def::Label(loop_id)) => loop_id,\n+                match self.ir.tcx.expect_def(id) {\n+                    Def::Label(loop_id) => loop_id,\n                     _ => span_bug!(sp, \"label on break/loop \\\n                                         doesn't refer to a loop\")\n                 }\n@@ -1269,7 +1269,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n-        match self.ir.tcx.def_map.borrow().get(&expr.id).unwrap().full_def() {\n+        match self.ir.tcx.expect_def(expr.id) {\n           Def::Local(_, nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0 {\n@@ -1534,9 +1534,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n             hir::ExprPath(..) => {\n-                if let Def::Local(_, nid) = self.ir.tcx.def_map.borrow().get(&expr.id)\n-                                                                      .unwrap()\n-                                                                      .full_def() {\n+                if let Def::Local(_, nid) = self.ir.tcx.expect_def(expr.id) {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability"}, {"sha": "d513af10b361829b8590491f14602d0655daf14d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -517,8 +517,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           hir::ExprPath(..) => {\n-            let def = self.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n-            self.cat_def(expr.id, expr.span, expr_ty, def)\n+            self.cat_def(expr.id, expr.span, expr_ty, self.tcx().expect_def(expr.id))\n           }\n \n           hir::ExprType(ref e, _) => {\n@@ -1106,18 +1105,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         (*op)(self, cmt.clone(), pat);\n \n-        let opt_def = if let Some(path_res) = self.tcx().def_map.borrow().get(&pat.id) {\n-            if path_res.depth != 0 || path_res.base_def == Def::Err {\n-                // Since patterns can be associated constants\n-                // which are resolved during typeck, we might have\n-                // some unresolved patterns reaching this stage\n-                // without aborting\n-                return Err(());\n-            }\n-            Some(path_res.full_def())\n-        } else {\n-            None\n-        };\n+        let opt_def = self.tcx().expect_def_or_none(pat.id);\n+        if opt_def == Some(Def::Err) {\n+            return Err(());\n+        }\n \n         // Note: This goes up here (rather than within the PatKind::TupleStruct arm\n         // alone) because struct patterns can refer to struct types or"}, {"sha": "6ea0fa20c572689c00b6804c74c1818e077dd04c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -92,13 +92,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprPath(..) => {\n-                let def = match self.tcx.def_map.borrow().get(&expr.id) {\n-                    Some(d) => d.full_def(),\n-                    None => {\n-                        span_bug!(expr.span, \"def ID not in def map?!\")\n-                    }\n-                };\n-\n+                let def = self.tcx.expect_def(expr.id);\n                 let def_id = def.def_id();\n                 if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n                     if self.def_id_represents_local_inlined_item(def_id) {"}, {"sha": "3744f564fa27117b46b37ababc40dddf1ee1d617", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -494,7 +494,7 @@ pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // individually as it's possible to have a stable trait with unstable\n         // items.\n         hir::ItemImpl(_, _, _, Some(ref t), _, ref impl_items) => {\n-            let trait_did = tcx.def_map.borrow().get(&t.ref_id).unwrap().def_id();\n+            let trait_did = tcx.expect_def(t.ref_id).def_id();\n             let trait_items = tcx.trait_items(trait_did);\n \n             for impl_item in impl_items {\n@@ -580,7 +580,8 @@ pub fn check_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             cb: &mut FnMut(DefId, Span,\n                                            &Option<&Stability>,\n                                            &Option<Deprecation>)) {\n-    match tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n+    // Paths in import prefixes may have no resolution.\n+    match tcx.expect_def_or_none(id) {\n         Some(Def::PrimTy(..)) => {}\n         Some(Def::SelfTy(..)) => {}\n         Some(def) => {\n@@ -595,12 +596,11 @@ pub fn check_path_list_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       cb: &mut FnMut(DefId, Span,\n                                                      &Option<&Stability>,\n                                                      &Option<Deprecation>)) {\n-    match tcx.def_map.borrow().get(&item.node.id()).map(|d| d.full_def()) {\n-        Some(Def::PrimTy(..)) => {}\n-        Some(def) => {\n+    match tcx.expect_def(item.node.id()) {\n+        Def::PrimTy(..) => {}\n+        def => {\n             maybe_do_stability_check(tcx, def.def_id(), item.span, cb);\n         }\n-        None => {}\n     }\n }\n "}, {"sha": "28266809266373aa96b8df2efb1c0b88d5817d44", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -22,7 +22,7 @@ use dep_graph::{self, DepNode};\n use hir::map as ast_map;\n use middle;\n use middle::cstore::{self, LOCAL_CRATE};\n-use hir::def::{self, Def, ExportMap};\n+use hir::def::{Def, PathResolution, ExportMap};\n use hir::def_id::DefId;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n@@ -308,13 +308,11 @@ impl Visibility {\n         match *visibility {\n             hir::Public => Visibility::Public,\n             hir::Visibility::Crate => Visibility::Restricted(ast::CRATE_NODE_ID),\n-            hir::Visibility::Restricted { id, .. } => match tcx.def_map.borrow().get(&id) {\n-                Some(resolution) => Visibility::Restricted({\n-                    tcx.map.as_local_node_id(resolution.base_def.def_id()).unwrap()\n-                }),\n+            hir::Visibility::Restricted { id, .. } => match tcx.expect_def(id) {\n                 // If there is no resolution, `resolve` will have already reported an error, so\n                 // assume that the visibility is public to avoid reporting more privacy errors.\n-                None => Visibility::Public,\n+                Def::Err => Visibility::Public,\n+                def => Visibility::Restricted(tcx.map.as_local_node_id(def.def_id()).unwrap()),\n             },\n             hir::Inherited => Visibility::Restricted(tcx.map.get_module_parent(id)),\n         }\n@@ -2249,34 +2247,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_expr(self, expr: &hir::Expr) -> Def {\n-        match self.def_map.borrow().get(&expr.id) {\n-            Some(def) => def.full_def(),\n-            None => {\n-                span_bug!(expr.span, \"no def-map entry for expr {}\", expr.id);\n-            }\n-        }\n-    }\n-\n     pub fn expr_is_lval(self, expr: &hir::Expr) -> bool {\n          match expr.node {\n             hir::ExprPath(..) => {\n-                // We can't use resolve_expr here, as this needs to run on broken\n-                // programs. We don't need to through - associated items are all\n-                // rvalues.\n-                match self.def_map.borrow().get(&expr.id) {\n-                    Some(&def::PathResolution {\n-                        base_def: Def::Static(..), ..\n-                    }) | Some(&def::PathResolution {\n-                        base_def: Def::Upvar(..), ..\n-                    }) | Some(&def::PathResolution {\n-                        base_def: Def::Local(..), ..\n-                    }) => {\n-                        true\n-                    }\n-                    Some(&def::PathResolution { base_def: Def::Err, .. })=> true,\n-                    Some(..) => false,\n-                    None => span_bug!(expr.span, \"no def for path {}\", expr.id)\n+                // This function can be used during type checking when not all paths are\n+                // fully resolved. Partially resolved paths in expressions can only legally\n+                // refer to associated items which are always rvalues.\n+                match self.expect_resolution(expr.id).base_def {\n+                    Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n+                    _ => false,\n                 }\n             }\n \n@@ -2459,8 +2438,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn trait_ref_to_def_id(self, tr: &hir::TraitRef) -> DefId {\n-        self.def_map.borrow().get(&tr.ref_id).expect(\"no def-map entry for trait\").def_id()\n+    /// Returns a path resolution for node id if it exists, panics otherwise.\n+    pub fn expect_resolution(self, id: NodeId) -> PathResolution {\n+        *self.def_map.borrow().get(&id).expect(\"no def-map entry for node id\")\n+    }\n+\n+    /// Returns a fully resolved definition for node id if it exists, panics otherwise.\n+    pub fn expect_def(self, id: NodeId) -> Def {\n+        self.expect_resolution(id).full_def()\n+    }\n+\n+    /// Returns a fully resolved definition for node id if it exists, or none if no\n+    /// definition exists, panics on partial resolutions to catch errors.\n+    pub fn expect_def_or_none(self, id: NodeId) -> Option<Def> {\n+        self.def_map.borrow().get(&id).map(|resolution| resolution.full_def())\n     }\n \n     pub fn def_key(self, id: DefId) -> ast_map::DefKey {"}, {"sha": "f183736b9ed577ad562d3143bdb06b7f5bf58c6e", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -245,8 +245,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n         if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n             let pat_ty = cx.tcx.pat_ty(p);\n             if let ty::TyEnum(edef, _) = pat_ty.sty {\n-                let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n-                if let Some(Def::Local(..)) = def {\n+                if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n                     if edef.variants.iter().any(|variant|\n                         variant.name == name.node.unhygienize()\n                             && variant.kind() == VariantKind::Unit\n@@ -492,9 +491,8 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n             PatKind::Path(..) | PatKind::QPath(..) => {\n-                let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n-                match def {\n-                    Some(Def::AssociatedConst(did)) | Some(Def::Const(did)) => {\n+                match self.tcx.expect_def(pat.id) {\n+                    Def::AssociatedConst(did) | Def::Const(did) => {\n                         let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n                         if let Some((const_expr, _)) = lookup_const_by_id(self.tcx, did, substs) {\n                             match const_expr_to_pat(self.tcx, const_expr, pat.id, pat.span) {\n@@ -788,7 +786,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     let pat = raw_pat(p);\n     match pat.node {\n         PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n-            match cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n+            match cx.tcx.expect_def(pat.id) {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat.span, \"const pattern should've \\\n                                          been rewritten\"),\n@@ -903,21 +901,19 @@ pub fn specialize<'a, 'b, 'tcx>(\n             Some(vec![dummy_pat; arity]),\n \n         PatKind::Path(..) => {\n-            let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n-            match def {\n+            match cx.tcx.expect_def(pat_id) {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n                 Def::Variant(_, id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => Some(Vec::new()),\n-                _ => span_bug!(pat_span, \"specialize: unexpected \\\n+                def => span_bug!(pat_span, \"specialize: unexpected \\\n                                           definition {:?}\", def),\n             }\n         }\n \n         PatKind::TupleStruct(_, ref args, ddpos) => {\n-            let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n-            match def {\n+            match cx.tcx.expect_def(pat_id) {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n@@ -944,10 +940,9 @@ pub fn specialize<'a, 'b, 'tcx>(\n         }\n \n         PatKind::Struct(_, ref pattern_fields, _) => {\n-            let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n             let variant = constructor.variant_for_adt(adt);\n-            let def_variant = adt.variant_of_def(def);\n+            let def_variant = adt.variant_of_def(cx.tcx.expect_def(pat_id));\n             if variant.did == def_variant.did {\n                 Some(variant.fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.node.name == sf.name) {"}, {"sha": "c3db252584cce28f864e4a5693d9f384d66080f5", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -19,7 +19,7 @@ use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::cstore::{self, InlinedItem};\n use rustc::traits;\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, PathResolution};\n use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::def_to_path;\n use rustc::ty::{self, Ty, TyCtxt, subst};\n@@ -276,11 +276,11 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      .collect()), None),\n \n         hir::ExprCall(ref callee, ref args) => {\n-            let def = *tcx.def_map.borrow().get(&callee.id).unwrap();\n+            let def = tcx.expect_def(callee.id);\n             if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n-               entry.insert(def);\n+               entry.insert(PathResolution::new(def));\n             }\n-            let path = match def.full_def() {\n+            let path = match def {\n                 Def::Struct(def_id) => def_to_path(tcx, def_id),\n                 Def::Variant(_, variant_did) => def_to_path(tcx, variant_did),\n                 Def::Fn(..) | Def::Method(..) => return Ok(P(hir::Pat {\n@@ -322,12 +322,9 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         hir::ExprPath(_, ref path) => {\n-            let opt_def = tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def());\n-            match opt_def {\n-                Some(Def::Struct(..)) | Some(Def::Variant(..)) =>\n-                    PatKind::Path(path.clone()),\n-                Some(Def::Const(def_id)) |\n-                Some(Def::AssociatedConst(def_id)) => {\n+            match tcx.expect_def(expr.id) {\n+                Def::Struct(..) | Def::Variant(..) => PatKind::Path(path.clone()),\n+                Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                     let substs = Some(tcx.node_id_item_substs(expr.id).substs);\n                     let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n                     return const_expr_to_pat(tcx, expr, pat_id, span);\n@@ -714,21 +711,13 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n       }\n       hir::ExprPath(..) => {\n-          let opt_def = if let Some(def) = tcx.def_map.borrow().get(&e.id) {\n-              // After type-checking, def_map contains definition of the\n-              // item referred to by the path. During type-checking, it\n-              // can contain the raw output of path resolution, which\n-              // might be a partially resolved path.\n-              // FIXME: There's probably a better way to make sure we don't\n-              // panic here.\n-              if def.depth != 0 {\n-                  signal!(e, UnresolvedPath);\n-              }\n-              def.full_def()\n-          } else {\n-              signal!(e, NonConstPath);\n-          };\n-          match opt_def {\n+          // This function can be used before type checking when not all paths are fully resolved.\n+          // FIXME: There's probably a better way to make sure we don't panic here.\n+          let resolution = tcx.expect_resolution(e.id);\n+          if resolution.depth != 0 {\n+              signal!(e, UnresolvedPath);\n+          }\n+          match resolution.base_def {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                   let substs = if let ExprTypeChecked = ty_hint {"}, {"sha": "54e5824cbc78686f014c0f671c43fadb05b1f2da", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -276,7 +276,7 @@ impl LateLintPass for NonSnakeCase {\n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         if let &PatKind::Binding(_, ref path1, _) = &p.node {\n             // Exclude parameter names from foreign functions (they have no `Def`)\n-            if cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def()).is_some() {\n+            if cx.tcx.expect_def_or_none(p.id).is_some() {\n                 self.check_snake_case(cx, \"variable\", &path1.node.as_str(), Some(p.span));\n             }\n         }\n@@ -362,8 +362,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(ref path) = p.node {\n             if !path.global && path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n-                if let Some(Def::Const(..)) = cx.tcx.def_map.borrow().get(&p.id)\n-                                                                     .map(|d| d.full_def()) {\n+                if let Def::Const(..) = cx.tcx.expect_def(p.id) {\n                     NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n                                                           path.segments[0].name, path.span);\n                 }"}, {"sha": "2bd2997566e0dcf81b1fd38f4cc06be7908a54d4", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -157,20 +157,11 @@ impl LintPass for NonShorthandFieldPatterns {\n \n impl LateLintPass for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n-        let def_map = cx.tcx.def_map.borrow();\n-        if let PatKind::Struct(_, ref v, _) = pat.node {\n-            let field_pats = v.iter().filter(|fieldpat| {\n+        if let PatKind::Struct(_, ref field_pats, _) = pat.node {\n+            for fieldpat in field_pats {\n                 if fieldpat.node.is_shorthand {\n-                    return false;\n-                }\n-                let def = def_map.get(&fieldpat.node.pat.id).map(|d| d.full_def());\n-                if let Some(def_id) = cx.tcx.map.opt_local_def_id(fieldpat.node.pat.id) {\n-                    def == Some(Def::Local(def_id, fieldpat.node.pat.id))\n-                } else {\n-                    false\n+                    continue;\n                 }\n-            });\n-            for fieldpat in field_pats {\n                 if let PatKind::Binding(_, ident, None) = fieldpat.node.pat.node {\n                     if ident.node.unhygienize() == fieldpat.node.name {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n@@ -377,7 +368,7 @@ impl LateLintPass for MissingDoc {\n             hir::ItemImpl(_, _, _, Some(ref trait_ref), _, ref impl_items) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n-                let real_trait = cx.tcx.trait_ref_to_def_id(trait_ref);\n+                let real_trait = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n                 if let Some(node_id) = cx.tcx.map.as_local_node_id(real_trait) {\n                     match cx.tcx.map.find(node_id) {\n                         Some(hir_map::NodeItem(item)) => if item.vis == hir::Visibility::Inherited {\n@@ -780,11 +771,9 @@ impl LateLintPass for UnconditionalRecursion {\n                                   id: ast::NodeId) -> bool {\n             match tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n-                    tcx.def_map\n-                       .borrow()\n-                       .get(&callee.id)\n-                       .map_or(false,\n-                               |def| def.def_id() == tcx.map.local_def_id(fn_id))\n+                    tcx.expect_def_or_none(callee.id).map_or(false, |def| {\n+                        def.def_id() == tcx.map.local_def_id(fn_id)\n+                    })\n                 }\n                 _ => false\n             }\n@@ -820,7 +809,9 @@ impl LateLintPass for UnconditionalRecursion {\n             // Check for calls to methods via explicit paths (e.g. `T::method()`).\n             match tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n-                    match tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def()) {\n+                    // The callee is an arbitrary expression,\n+                    // it doesn't necessarily have a definition.\n+                    match tcx.expect_def_or_none(callee.id) {\n                         Some(Def::Method(def_id)) => {\n                             let item_substs = tcx.node_id_item_substs(callee.id);\n                             method_call_refers_to_method(\n@@ -1057,7 +1048,7 @@ impl LateLintPass for MutableTransmutes {\n                 hir::ExprPath(..) => (),\n                 _ => return None\n             }\n-            if let Def::Fn(did) = cx.tcx.resolve_expr(expr) {\n+            if let Def::Fn(did) = cx.tcx.expect_def(expr.id) {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }"}, {"sha": "78825aca4188e443caead4e22b74f922eaa3657f", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -719,7 +719,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     debug!(\"Encoding side tables for id {}\", id);\n \n-    if let Some(def) = tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n+    if let Some(def) = tcx.expect_def_or_none(id) {\n         rbml_w.tag(c::tag_table_def, |rbml_w| {\n             rbml_w.id(id);\n             def.encode(rbml_w).unwrap();\n@@ -1133,10 +1133,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                 match value {\n                     c::tag_table_def => {\n                         let def = decode_def(dcx, val_dsr);\n-                        dcx.tcx.def_map.borrow_mut().insert(id, def::PathResolution {\n-                            base_def: def,\n-                            depth: 0\n-                        });\n+                        dcx.tcx.def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n                     }\n                     c::tag_table_node_type => {\n                         let ty = val_dsr.read_ty(dcx);"}, {"sha": "b5e2ce9de483692054406c1b0371dea674538ae8", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 9, "deletions": 29, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use hair::*;\n-use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_const_math::ConstInt;\n use hair::cx::Cx;\n@@ -20,7 +19,6 @@ use rustc::hir::def::Def;\n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval as const_eval;\n use rustc::middle::region::CodeExtent;\n-use rustc::hir::pat_util;\n use rustc::ty::{self, VariantDef, Ty};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::mir::repr::*;\n@@ -264,7 +262,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 let adt_data = if let hir::ExprPath(..) = fun.node {\n                     // Tuple-like ADTs are represented as ExprCall. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def|{\n-                        match cx.tcx.def_map.borrow()[&fun.id].full_def() {\n+                        match cx.tcx.expect_def(fun.id) {\n                             Def::Variant(_, variant_id) => {\n                                 Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n                             },\n@@ -472,7 +470,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     }\n                 }\n                 ty::TyEnum(adt, substs) => {\n-                    match cx.tcx.def_map.borrow()[&expr.id].full_def() {\n+                    match cx.tcx.expect_def(expr.id) {\n                         Def::Variant(enum_id, variant_id) => {\n                             debug_assert!(adt.did == enum_id);\n                             assert!(base.is_none());\n@@ -652,19 +650,8 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n \n fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                arm: &'tcx hir::Arm) -> Arm<'tcx> {\n-    let mut map;\n-    let opt_map = if arm.pats.len() == 1 {\n-        None\n-    } else {\n-        map = FnvHashMap();\n-        pat_util::pat_bindings(&arm.pats[0], |_, p_id, _, path| {\n-            map.insert(path.node, p_id);\n-        });\n-        Some(&map)\n-    };\n-\n     Arm {\n-        patterns: arm.pats.iter().map(|p| cx.refutable_pat(opt_map, p)).collect(),\n+        patterns: arm.pats.iter().map(|p| cx.refutable_pat(p)).collect(),\n         guard: arm.guard.to_ref(),\n         body: arm.body.to_ref(),\n     }\n@@ -675,7 +662,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      -> ExprKind<'tcx> {\n     let substs = cx.tcx.node_id_item_substs(expr.id).substs;\n     // Otherwise there may be def_map borrow conflicts\n-    let def = cx.tcx.def_map.borrow()[&expr.id].full_def();\n+    let def = cx.tcx.expect_def(expr.id);\n     let def_id = match def {\n         // A regular function.\n         Def::Fn(def_id) | Def::Method(def_id) => def_id,\n@@ -731,14 +718,9 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             id: node_id,\n         },\n \n-        def @ Def::Local(..) |\n-        def @ Def::Upvar(..) => return convert_var(cx, expr, def),\n+        Def::Local(..) | Def::Upvar(..) => return convert_var(cx, expr, def),\n \n-        def =>\n-            span_bug!(\n-                expr.span,\n-                \"def `{:?}` not yet implemented\",\n-                def),\n+        _ => span_bug!(expr.span, \"def `{:?}` not yet implemented\", def),\n     };\n     ExprKind::Literal {\n         literal: Literal::Item { def_id: def_id, substs: substs }\n@@ -1039,11 +1021,9 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n fn loop_label<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                               expr: &'tcx hir::Expr) -> CodeExtent {\n-    match cx.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n-        Some(Def::Label(loop_id)) => cx.tcx.region_maps.node_extent(loop_id),\n-        d => {\n-            span_bug!(expr.span, \"loop scope resolved to {:?}\", d);\n-        }\n+    match cx.tcx.expect_def(expr.id) {\n+        Def::Label(loop_id) => cx.tcx.region_maps.node_extent(loop_id),\n+        d => span_bug!(expr.span, \"loop scope resolved to {:?}\", d),\n     }\n }\n "}, {"sha": "1bc3954a5fe7589dc1ca000cbaa1e618cc262fc7", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -10,15 +10,13 @@\n \n use hair::*;\n use hair::cx::Cx;\n-use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_const_eval as const_eval;\n use rustc::hir::def::Def;\n use rustc::hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc::hir::{self, PatKind};\n-use syntax::ast;\n use syntax::codemap::Span;\n use syntax::ptr::P;\n \n@@ -37,29 +35,25 @@ use syntax::ptr::P;\n /// ```\n struct PatCx<'patcx, 'cx: 'patcx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     cx: &'patcx mut Cx<'cx, 'gcx, 'tcx>,\n-    binding_map: Option<&'patcx FnvHashMap<ast::Name, ast::NodeId>>,\n }\n \n impl<'cx, 'gcx, 'tcx> Cx<'cx, 'gcx, 'tcx> {\n     pub fn irrefutable_pat(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        PatCx::new(self, None).to_pattern(pat)\n+        PatCx::new(self).to_pattern(pat)\n     }\n \n     pub fn refutable_pat(&mut self,\n-                         binding_map: Option<&FnvHashMap<ast::Name, ast::NodeId>>,\n                          pat: &hir::Pat)\n                          -> Pattern<'tcx> {\n-        PatCx::new(self, binding_map).to_pattern(pat)\n+        PatCx::new(self).to_pattern(pat)\n     }\n }\n \n impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n-    fn new(cx: &'patcx mut Cx<'cx, 'gcx, 'tcx>,\n-               binding_map: Option<&'patcx FnvHashMap<ast::Name, ast::NodeId>>)\n+    fn new(cx: &'patcx mut Cx<'cx, 'gcx, 'tcx>)\n                -> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n         PatCx {\n             cx: cx,\n-            binding_map: binding_map,\n         }\n     }\n \n@@ -85,8 +79,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n             PatKind::Path(..) | PatKind::QPath(..)\n                 if pat_is_resolved_const(&self.cx.tcx.def_map.borrow(), pat) =>\n             {\n-                let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-                match def {\n+                match self.cx.tcx.expect_def(pat.id) {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                         let tcx = self.cx.tcx.global_tcx();\n                         let substs = Some(self.cx.tcx.node_id_item_substs(pat.id).substs);\n@@ -111,7 +104,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                             }\n                         }\n                     }\n-                    _ =>\n+                    def =>\n                         span_bug!(\n                             pat.span,\n                             \"def not a constant: {:?}\",\n@@ -169,10 +162,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n             }\n \n             PatKind::Binding(bm, ref ident, ref sub) => {\n-                let id = match self.binding_map {\n-                    None => pat.id,\n-                    Some(ref map) => map[&ident.node],\n-                };\n+                let id = self.cx.tcx.expect_def(pat.id).var_id();\n                 let var_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(&r, _) => Some(r),\n@@ -219,8 +209,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                     ty::TyStruct(adt_def, _) | ty::TyEnum(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to struct or enum\"),\n                 };\n-                let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-                let variant_def = adt_def.variant_of_def(def);\n+                let variant_def = adt_def.variant_of_def(self.cx.tcx.expect_def(pat.id));\n \n                 let subpatterns =\n                         subpatterns.iter()\n@@ -243,9 +232,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                             \"struct pattern not applied to struct or enum\");\n                     }\n                 };\n-\n-                let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-                let variant_def = adt_def.variant_of_def(def);\n+                let variant_def = adt_def.variant_of_def(self.cx.tcx.expect_def(pat.id));\n \n                 let subpatterns =\n                     fields.iter()\n@@ -324,8 +311,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                        pat: &hir::Pat,\n                        subpatterns: Vec<FieldPattern<'tcx>>)\n                        -> PatternKind<'tcx> {\n-        let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-        match def {\n+        match self.cx.tcx.expect_def(pat.id) {\n             Def::Variant(enum_id, variant_id) => {\n                 let adt_def = self.cx.tcx.lookup_adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n@@ -343,7 +329,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n \n-            _ => {\n+            def => {\n                 span_bug!(pat.span, \"inappropriate def for pattern: {:?}\", def);\n             }\n         }"}, {"sha": "75bfe7c0f2f9524bf9baa8a363d7c3501fe48986", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -499,38 +499,36 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         hir::ExprPath(..) => {\n-            let def = v.tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n-            match def {\n-                Some(Def::Variant(..)) => {\n+            match v.tcx.expect_def(e.id) {\n+                Def::Variant(..) => {\n                     // Count the discriminator or function pointer.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n-                Some(Def::Struct(..)) => {\n+                Def::Struct(..) => {\n                     if let ty::TyFnDef(..) = node_ty.sty {\n                         // Count the function pointer.\n                         v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                     }\n                 }\n-                Some(Def::Fn(..)) | Some(Def::Method(..)) => {\n+                Def::Fn(..) | Def::Method(..) => {\n                     // Count the function pointer.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n-                Some(Def::Static(..)) => {\n+                Def::Static(..) => {\n                     match v.mode {\n                         Mode::Static | Mode::StaticMut => {}\n                         Mode::Const | Mode::ConstFn => {}\n                         Mode::Var => v.add_qualif(ConstQualif::NOT_CONST)\n                     }\n                 }\n-                Some(Def::Const(did)) |\n-                Some(Def::AssociatedConst(did)) => {\n+                Def::Const(did) | Def::AssociatedConst(did) => {\n                     let substs = Some(v.tcx.node_id_item_substs(e.id).substs);\n                     if let Some((expr, _)) = lookup_const_by_id(v.tcx, did, substs) {\n                         let inner = v.global_expr(Mode::Const, expr);\n                         v.add_qualif(inner);\n                     }\n                 }\n-                Some(Def::Local(..)) if v.mode == Mode::ConstFn => {\n+                Def::Local(..) if v.mode == Mode::ConstFn => {\n                     // Sadly, we can't determine whether the types are zero-sized.\n                     v.add_qualif(ConstQualif::NOT_CONST | ConstQualif::NON_ZERO_SIZED);\n                 }\n@@ -550,8 +548,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                     _ => break\n                 };\n             }\n-            let def = v.tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def());\n-            let is_const = match def {\n+            // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n+            let is_const = match v.tcx.expect_def_or_none(callee.id) {\n                 Some(Def::Struct(..)) => true,\n                 Some(Def::Variant(..)) => {\n                     // Count the discriminator.\n@@ -586,8 +584,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         hir::ExprStruct(..) => {\n-            let did = v.tcx.def_map.borrow().get(&e.id).map(|def| def.def_id());\n-            if did == v.tcx.lang_items.unsafe_cell_type() {\n+            // unsafe_cell_type doesn't necessarily exist with no_core\n+            if Some(v.tcx.expect_def(e.id).def_id()) == v.tcx.lang_items.unsafe_cell_type() {\n                 v.add_qualif(ConstQualif::MUTABLE_MEM);\n             }\n         }"}, {"sha": "918c149ef8589e897df80d3e3829fd67f36446aa", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -65,7 +65,7 @@ struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn ty_level(&self, ty: &hir::Ty) -> Option<AccessLevel> {\n         if let hir::TyPath(..) = ty.node {\n-            match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n+            match self.tcx.expect_def(ty.id) {\n                 Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n                     Some(AccessLevel::Public)\n                 }\n@@ -83,7 +83,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     }\n \n     fn trait_level(&self, trait_ref: &hir::TraitRef) -> Option<AccessLevel> {\n-        let did = self.tcx.trait_ref_to_def_id(trait_ref);\n+        let did = self.tcx.expect_def(trait_ref.ref_id).def_id();\n         if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n             self.get(node_id)\n         } else {\n@@ -317,7 +317,7 @@ impl<'b, 'a, 'tcx: 'a> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyPath(_, ref path) = ty.node {\n-            let def = self.ev.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n+            let def = self.ev.tcx.expect_def(ty.id);\n             match def {\n                 Def::Struct(def_id) | Def::Enum(def_id) | Def::TyAlias(def_id) |\n                 Def::Trait(def_id) | Def::AssociatedTy(def_id, _) => {\n@@ -343,7 +343,7 @@ impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<\n     }\n \n     fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n-        let def_id = self.ev.tcx.trait_ref_to_def_id(trait_ref);\n+        let def_id = self.ev.tcx.expect_def(trait_ref.ref_id).def_id();\n         if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n             let item = self.ev.tcx.map.expect_item(node_id);\n             self.ev.update(item.id, Some(AccessLevel::Reachable));\n@@ -426,7 +426,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             hir::ExprStruct(..) => {\n                 let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();\n-                let variant = adt.variant_of_def(self.tcx.resolve_expr(expr));\n+                let variant = adt.variant_of_def(self.tcx.expect_def(expr.id));\n                 // RFC 736: ensure all unmentioned fields are visible.\n                 // Rather than computing the set of unmentioned fields\n                 // (i.e. `all_fields - fields`), just check them all.\n@@ -436,7 +436,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             hir::ExprPath(..) => {\n \n-                if let Def::Struct(..) = self.tcx.resolve_expr(expr) {\n+                if let Def::Struct(..) = self.tcx.expect_def(expr.id) {\n                     let expr_ty = self.tcx.expr_ty(expr);\n                     let def = match expr_ty.sty {\n                         ty::TyFnDef(_, _, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n@@ -470,8 +470,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         match pattern.node {\n             PatKind::Struct(_, ref fields, _) => {\n                 let adt = self.tcx.pat_ty(pattern).ty_adt_def().unwrap();\n-                let def = self.tcx.def_map.borrow().get(&pattern.id).unwrap().full_def();\n-                let variant = adt.variant_of_def(def);\n+                let variant = adt.variant_of_def(self.tcx.expect_def(pattern.id));\n                 for field in fields {\n                     self.check_field(pattern.span, adt, variant.field_named(field.node.name));\n                 }\n@@ -534,10 +533,9 @@ struct ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n \n impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n-        let did = match self.tcx.def_map.borrow().get(&path_id).map(|d| d.full_def()) {\n-            // `int` etc. (None doesn't seem to occur.)\n-            None | Some(Def::PrimTy(..)) | Some(Def::SelfTy(..)) => return false,\n-            Some(def) => def.def_id(),\n+        let did = match self.tcx.expect_def(path_id) {\n+            Def::PrimTy(..) | Def::SelfTy(..) => return false,\n+            def => def.def_id(),\n         };\n \n         // A path can only be private if:\n@@ -653,7 +651,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                 let not_private_trait =\n                     trait_ref.as_ref().map_or(true, // no trait counts as public trait\n                                               |tr| {\n-                        let did = self.tcx.trait_ref_to_def_id(tr);\n+                        let did = self.tcx.expect_def(tr.ref_id).def_id();\n \n                         if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n                             self.trait_is_public(node_id)\n@@ -911,8 +909,7 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyPath(_, ref path) = ty.node {\n-            let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n-            match def {\n+            match self.tcx.expect_def(ty.id) {\n                 Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n                     // Public\n                 }\n@@ -962,7 +959,7 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n \n     fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n         // Non-local means public (private items can't leave their crate, modulo bugs)\n-        let def_id = self.tcx.trait_ref_to_def_id(trait_ref);\n+        let def_id = self.tcx.expect_def(trait_ref.ref_id).def_id();\n         if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n             let item = self.tcx.map.expect_item(node_id);\n             let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);"}, {"sha": "476b9a5447b0788d40f230b0853d51be460eff55", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 152, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -677,100 +677,6 @@ fn foo<T>(x: T) {} // ok!\n ```\n \"##,\n \n-E0413: r##\"\n-A declaration shadows an enum variant or unit-like struct in scope. Example of\n-erroneous code:\n-\n-```compile_fail\n-struct Foo;\n-\n-let Foo = 12i32; // error: declaration of `Foo` shadows an enum variant or\n-                 //        unit-like struct in scope\n-```\n-\n-To fix this error, rename the variable such that it doesn't shadow any enum\n-variable or structure in scope. Example:\n-\n-```\n-struct Foo;\n-\n-let foo = 12i32; // ok!\n-```\n-\n-Or:\n-\n-```\n-struct FooStruct;\n-\n-let Foo = 12i32; // ok!\n-```\n-\n-The goal here is to avoid a conflict of names.\n-\"##,\n-\n-E0414: r##\"\n-A variable binding in an irrefutable pattern is shadowing the name of a\n-constant. Example of erroneous code:\n-\n-```compile_fail\n-const FOO: u8 = 7;\n-\n-let FOO = 5; // error: variable bindings cannot shadow constants\n-\n-// or\n-\n-fn bar(FOO: u8) { // error: variable bindings cannot shadow constants\n-\n-}\n-\n-// or\n-\n-for FOO in bar {\n-\n-}\n-```\n-\n-Introducing a new variable in Rust is done through a pattern. Thus you can have\n-`let` bindings like `let (a, b) = ...`. However, patterns also allow constants\n-in them, e.g. if you want to match over a constant:\n-\n-```ignore\n-const FOO: u8 = 1;\n-\n-match (x,y) {\n- (3, 4) => { .. }, // it is (3,4)\n- (FOO, 1) => { .. }, // it is (1,1)\n- (foo, 1) => { .. }, // it is (anything, 1)\n-                     // call the value in the first slot \"foo\"\n- _ => { .. } // it is anything\n-}\n-```\n-\n-Here, the second arm matches the value of `x` against the constant `FOO`,\n-whereas the third arm will accept any value of `x` and call it `foo`.\n-\n-This works for `match`, however in cases where an irrefutable pattern is\n-required, constants can't be used. An irrefutable pattern is one which always\n-matches, whose purpose is only to bind variable names to values. These are\n-required by let, for, and function argument patterns.\n-\n-Refutable patterns in such a situation do not make sense, for example:\n-\n-```ignore\n-let Some(x) = foo; // what if foo is None, instead?\n-\n-let (1, x) = foo; // what if foo.0 is not 1?\n-\n-let (SOME_CONST, x) = foo; // what if foo.0 is not SOME_CONST?\n-\n-let SOME_CONST = foo; // what if foo is not SOME_CONST?\n-```\n-\n-Thus, an irrefutable variable binding can't contain a constant.\n-\n-To fix this error, just give the marked variable a different name.\n-\"##,\n-\n E0415: r##\"\n More than one function parameter have the same name. Example of erroneous code:\n \n@@ -814,60 +720,6 @@ match (A, B, C) {\n ```\n \"##,\n \n-E0417: r##\"\n-A static variable was referenced in a pattern. Example of erroneous code:\n-\n-```compile_fail\n-static FOO : i32 = 0;\n-\n-match 0 {\n-    FOO => {} // error: static variables cannot be referenced in a\n-              //        pattern, use a `const` instead\n-    _ => {}\n-}\n-```\n-\n-The compiler needs to know the value of the pattern at compile time;\n-compile-time patterns can defined via const or enum items. Please verify\n-that the identifier is spelled correctly, and if so, use a const instead\n-of static to define it. Example:\n-\n-```\n-const FOO : i32 = 0;\n-\n-match 0 {\n-    FOO => {} // ok!\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0419: r##\"\n-An unknown enum variant, struct or const was used. Example of erroneous code:\n-\n-```compile_fail\n-match 0 {\n-    Something::Foo => {} // error: unresolved enum variant, struct\n-                         //        or const `Foo`\n-}\n-```\n-\n-Please verify you didn't misspell it and the enum variant, struct or const has\n-been declared and imported into scope. Example:\n-\n-```\n-enum Something {\n-    Foo,\n-    NotFoo,\n-}\n-\n-match Something::NotFoo {\n-    Something::Foo => {} // ok!\n-    _ => {}\n-}\n-```\n-\"##,\n-\n E0422: r##\"\n You are trying to use an identifier that is either undefined or not a struct.\n For instance:\n@@ -1255,8 +1107,15 @@ register_diagnostics! {\n     E0402, // cannot use an outer type parameter in this context\n     E0406, // undeclared associated type\n //  E0410, merged into 408\n-    E0418, // is not an enum variant, struct or const\n-    E0420, // is not an associated const\n-    E0421, // unresolved associated const\n-    E0427, // cannot use `ref` binding mode with ...\n+//  E0413, merged into 530\n+//  E0414, merged into 530\n+//  E0417, merged into 532\n+//  E0418, merged into 532\n+//  E0419, merged into 531\n+//  E0420, merged into 532\n+//  E0421, merged into 531\n+    E0530, // X bindings cannot shadow Ys\n+    E0531, // unresolved pattern path kind `name`\n+    E0532, // expected pattern path kind, found another pattern path kind\n+//  E0427, merged into 530\n }"}, {"sha": "377863b016d85057a803617f621ed49fc47362c6", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 298, "deletions": 476, "changes": 774, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -31,16 +31,13 @@ extern crate arena;\n #[macro_use]\n extern crate rustc;\n \n-use self::PatternBindingMode::*;\n use self::Namespace::*;\n use self::ResolveResult::*;\n use self::FallbackSuggestion::*;\n use self::TypeParameters::*;\n use self::RibKind::*;\n use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n-use self::AssocItemResolveResult::*;\n-use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n \n use rustc::hir::map::Definitions;\n@@ -66,8 +63,8 @@ use syntax::visit::{self, FnKind, Visitor};\n use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n-use syntax::ast::{Local, Pat, PatKind, Path};\n-use syntax::ast::{PathSegment, PathParameters, TraitItemKind, TraitRef, Ty, TyKind};\n+use syntax::ast::{Local, Mutability, Pat, PatKind, Path};\n+use syntax::ast::{PathSegment, PathParameters, QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n@@ -123,24 +120,10 @@ enum ResolutionError<'a> {\n     SelfUsedOutsideImplOrTrait,\n     /// error E0412: use of undeclared\n     UseOfUndeclared(&'a str, &'a str, SuggestedCandidates),\n-    /// error E0413: cannot be named the same as an enum variant or unit-like struct in scope\n-    DeclarationShadowsEnumVariantOrUnitLikeStruct(Name),\n-    /// error E0414: only irrefutable patterns allowed here\n-    ConstantForIrrefutableBinding(Name, &'a NameBinding<'a>),\n     /// error E0415: identifier is bound more than once in this parameter list\n     IdentifierBoundMoreThanOnceInParameterList(&'a str),\n     /// error E0416: identifier is bound more than once in the same pattern\n     IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n-    /// error E0417: static variables cannot be referenced in a pattern\n-    StaticVariableReference(&'a NameBinding<'a>),\n-    /// error E0418: is not an enum variant, struct or const\n-    NotAnEnumVariantStructOrConst(&'a str),\n-    /// error E0419: unresolved enum variant, struct or const\n-    UnresolvedEnumVariantStructOrConst(&'a str),\n-    /// error E0420: is not an associated const\n-    NotAnAssociatedConst(&'a str),\n-    /// error E0421: unresolved associated const\n-    UnresolvedAssociatedConst(&'a str),\n     /// error E0422: does not name a struct\n     DoesNotNameAStruct(&'a str),\n     /// error E0423: is a struct variant name, but this expression uses it like a function name\n@@ -158,8 +141,6 @@ enum ResolutionError<'a> {\n     },\n     /// error E0426: use of undeclared label\n     UndeclaredLabel(&'a str),\n-    /// error E0427: cannot use `ref` binding mode with ...\n-    CannotUseRefBindingModeWith(&'a str),\n     /// error E0429: `self` imports are only allowed within a { } list\n     SelfImportsOnlyAllowedWithin,\n     /// error E0430: `self` import can only appear once in the list\n@@ -174,6 +155,12 @@ enum ResolutionError<'a> {\n     CannotCaptureDynamicEnvironmentInFnItem,\n     /// error E0435: attempt to use a non-constant value in a constant\n     AttemptToUseNonConstantValueInConstant,\n+    /// error E0530: X bindings cannot shadow Ys\n+    BindingShadowsSomethingUnacceptable(&'a str, &'a str, Name),\n+    /// error E0531: unresolved pattern path kind `name`\n+    PatPathUnresolved(&'a str, &'a Path),\n+    /// error E0532: expected pattern path kind, found another pattern path kind\n+    PatPathUnexpected(&'a str, &'a str, &'a Path),\n }\n \n /// Context of where `ResolutionError::UnresolvedName` arose.\n@@ -306,28 +293,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n             err.span_label(span, &format!(\"undefined or not in scope\"));\n             err\n         }\n-        ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(name) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                             span,\n-                             E0413,\n-                             \"`{}` cannot be named the same as an enum variant \\\n-                              or unit-like struct in scope\",\n-                             name);\n-            err.span_label(span,\n-                &format!(\"has same name as enum variant or unit-like struct\"));\n-            err\n-        }\n-        ResolutionError::ConstantForIrrefutableBinding(name, binding) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0414,\n-                                       \"let variables cannot be named the same as const variables\");\n-            err.span_label(span,\n-                           &format!(\"cannot be named the same as a const variable\"));\n-            let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n-            err.span_label(binding.span, &format!(\"a constant `{}` is {} here\", name, participle));\n-            err\n-        }\n         ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n             let mut err = struct_span_err!(resolver.session,\n                              span,\n@@ -346,47 +311,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n             err.span_label(span, &format!(\"used in a pattern more than once\"));\n             err\n         }\n-        ResolutionError::StaticVariableReference(binding) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0417,\n-                                           \"static variables cannot be referenced in a \\\n-                                            pattern, use a `const` instead\");\n-            err.span_label(span, &format!(\"static variable used in pattern\"));\n-            if binding.span != codemap::DUMMY_SP {\n-                let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n-                err.span_label(binding.span, &format!(\"static variable {} here\", participle));\n-            }\n-            err\n-        }\n-        ResolutionError::NotAnEnumVariantStructOrConst(name) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0418,\n-                             \"`{}` is not an enum variant, struct or const\",\n-                             name)\n-        }\n-        ResolutionError::UnresolvedEnumVariantStructOrConst(name) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0419,\n-                             \"unresolved enum variant, struct or const `{}`\",\n-                             name)\n-        }\n-        ResolutionError::NotAnAssociatedConst(name) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0420,\n-                             \"`{}` is not an associated const\",\n-                             name)\n-        }\n-        ResolutionError::UnresolvedAssociatedConst(name) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0421,\n-                             \"unresolved associated const `{}`\",\n-                             name)\n-        }\n         ResolutionError::DoesNotNameAStruct(name) => {\n             struct_span_err!(resolver.session,\n                              span,\n@@ -455,13 +379,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                              \"use of undeclared label `{}`\",\n                              name)\n         }\n-        ResolutionError::CannotUseRefBindingModeWith(descr) => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0427,\n-                             \"cannot use `ref` binding mode with {}\",\n-                             descr)\n-        }\n         ResolutionError::SelfImportsOnlyAllowedWithin => {\n             struct_span_err!(resolver.session,\n                              span,\n@@ -506,6 +423,36 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                              E0435,\n                              \"attempt to use a non-constant value in a constant\")\n         }\n+        ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, shadows_what, name) => {\n+            let mut err = struct_span_err!(resolver.session,\n+                                           span,\n+                                           E0530,\n+                                           \"{}s cannot shadow {}s\", what_binding, shadows_what);\n+            err.span_label(span, &format!(\"cannot be named the same as a {}\", shadows_what));\n+            if let Success(binding) = resolver.current_module.resolve_name(name, ValueNS, true) {\n+                let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n+                err.span_label(binding.span, &format!(\"a {} `{}` is {} here\",\n+                                                      shadows_what, name, participle));\n+            }\n+            err\n+        }\n+        ResolutionError::PatPathUnresolved(expected_what, path) => {\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0531,\n+                             \"unresolved {} `{}`\",\n+                             expected_what,\n+                             path.segments.last().unwrap().identifier)\n+        }\n+        ResolutionError::PatPathUnexpected(expected_what, found_what, path) => {\n+            struct_span_err!(resolver.session,\n+                             span,\n+                             E0532,\n+                             \"expected {}, found {} `{}`\",\n+                             expected_what,\n+                             found_what,\n+                             path.segments.last().unwrap().identifier)\n+        }\n     }\n }\n \n@@ -518,11 +465,33 @@ struct BindingInfo {\n // Map from the name in a pattern to its binding mode.\n type BindingMap = HashMap<Name, BindingInfo>;\n \n-#[derive(Copy, Clone, PartialEq)]\n-enum PatternBindingMode {\n-    RefutableMode,\n-    LocalIrrefutableMode,\n-    ArgumentIrrefutableMode,\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum PatternSource {\n+    Match,\n+    IfLet,\n+    WhileLet,\n+    Let,\n+    For,\n+    FnParam,\n+}\n+\n+impl PatternSource {\n+    fn is_refutable(self) -> bool {\n+        match self {\n+            PatternSource::Match | PatternSource::IfLet | PatternSource::WhileLet => true,\n+            PatternSource::Let | PatternSource::For | PatternSource::FnParam  => false,\n+        }\n+    }\n+    fn descr(self) -> &'static str {\n+        match self {\n+            PatternSource::Match => \"match binding\",\n+            PatternSource::IfLet => \"if let binding\",\n+            PatternSource::WhileLet => \"while let binding\",\n+            PatternSource::Let => \"let binding\",\n+            PatternSource::For => \"for binding\",\n+            PatternSource::FnParam => \"function parameter\",\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -700,22 +669,6 @@ enum ModulePrefixResult<'a> {\n     PrefixFound(Module<'a>, usize),\n }\n \n-#[derive(Copy, Clone)]\n-enum AssocItemResolveResult {\n-    /// Syntax such as `<T>::item`, which can't be resolved until type\n-    /// checking.\n-    TypecheckRequired,\n-    /// We should have been able to resolve the associated item.\n-    ResolveAttempt(Option<PathResolution>),\n-}\n-\n-#[derive(Copy, Clone)]\n-enum BareIdentifierPatternResolution<'a> {\n-    FoundStructOrEnumVariant(Def),\n-    FoundConst(&'a NameBinding<'a>, Name),\n-    BareIdentifierPatternUnresolved,\n-}\n-\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n@@ -1127,7 +1080,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     }\n \n     fn record_resolution(&mut self, id: NodeId, def: Def) {\n-        self.def_map.insert(id, PathResolution { base_def: def, depth: 0 });\n+        self.def_map.insert(id, PathResolution::new(def));\n     }\n \n     fn definitions(&mut self) -> Option<&mut Definitions> {\n@@ -1720,7 +1673,7 @@ impl<'a> Resolver<'a> {\n                                                                    TypeNS) {\n                                 Ok(binding) => {\n                                     let def = binding.def().unwrap();\n-                                    self.record_def(item.id, PathResolution::new(def, 0));\n+                                    self.record_def(item.id, PathResolution::new(def));\n                                 }\n                                 Err(true) => self.record_def(item.id, err_path_resolution()),\n                                 Err(false) => {\n@@ -1814,7 +1767,7 @@ impl<'a> Resolver<'a> {\n         // Add each argument to the rib.\n         let mut bindings_list = HashMap::new();\n         for argument in &declaration.inputs {\n-            self.resolve_pattern(&argument.pat, ArgumentIrrefutableMode, &mut bindings_list);\n+            self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n \n             self.visit_ty(&argument.ty);\n \n@@ -2055,7 +2008,7 @@ impl<'a> Resolver<'a> {\n         walk_list!(self, visit_expr, &local.init);\n \n         // Resolve the pattern.\n-        self.resolve_pattern(&local.pat, LocalIrrefutableMode, &mut HashMap::new());\n+        self.resolve_pattern(&local.pat, PatternSource::Let, &mut HashMap::new());\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n@@ -2124,7 +2077,7 @@ impl<'a> Resolver<'a> {\n \n         let mut bindings_list = HashMap::new();\n         for pattern in &arm.pats {\n-            self.resolve_pattern(&pattern, RefutableMode, &mut bindings_list);\n+            self.resolve_pattern(&pattern, PatternSource::Match, &mut bindings_list);\n         }\n \n         // This has to happen *after* we determine which\n@@ -2167,26 +2120,22 @@ impl<'a> Resolver<'a> {\n     fn resolve_type(&mut self, ty: &Ty) {\n         match ty.node {\n             TyKind::Path(ref maybe_qself, ref path) => {\n-                let resolution = match self.resolve_possibly_assoc_item(ty.id,\n-                                                                        maybe_qself.as_ref(),\n-                                                                        path,\n-                                                                        TypeNS) {\n-                    // `<T>::a::b::c` is resolved by typeck alone.\n-                    TypecheckRequired => {\n-                        // Resolve embedded types.\n-                        visit::walk_ty(self, ty);\n-                        return;\n-                    }\n-                    ResolveAttempt(resolution) => resolution,\n-                };\n-\n                 // This is a path in the type namespace. Walk through scopes\n                 // looking for it.\n-                if let Some(def) = resolution {\n-                    // Write the result into the def map.\n-                    debug!(\"(resolving type) writing resolution for `{}` (id {}) = {:?}\",\n-                           path_names_to_string(path, 0), ty.id, def);\n-                    self.record_def(ty.id, def);\n+                if let Some(def) = self.resolve_possibly_assoc_item(ty.id, maybe_qself.as_ref(),\n+                                                                    path, TypeNS) {\n+                    match def.base_def {\n+                        Def::Mod(..) if def.depth == 0 => {\n+                            self.session.span_err(path.span, \"expected type, found module\");\n+                            self.record_def(ty.id, err_path_resolution());\n+                        }\n+                        _ => {\n+                            // Write the result into the def map.\n+                            debug!(\"(resolving type) writing resolution for `{}` (id {}) = {:?}\",\n+                                   path_names_to_string(path, 0), ty.id, def);\n+                            self.record_def(ty.id, def);\n+                        }\n+                    }\n                 } else {\n                     self.record_def(ty.id, err_path_resolution());\n \n@@ -2246,321 +2195,229 @@ impl<'a> Resolver<'a> {\n         visit::walk_ty(self, ty);\n     }\n \n-    fn resolve_pattern(&mut self,\n-                       pattern: &Pat,\n-                       mode: PatternBindingMode,\n-                       // Maps idents to the node ID for the (outermost)\n-                       // pattern that binds them\n-                       bindings_list: &mut HashMap<Name, NodeId>) {\n-        let pat_id = pattern.id;\n-        pattern.walk(&mut |pattern| {\n-            match pattern.node {\n-                PatKind::Ident(binding_mode, ref path1, ref at_rhs) => {\n-                    // The meaning of PatKind::Ident with no type parameters\n-                    // depends on whether an enum variant or unit-like struct\n-                    // with that name is in scope. The probing lookup has to\n-                    // be careful not to emit spurious errors. Only matching\n-                    // patterns (match) can match nullary variants or\n-                    // unit-like structs. For binding patterns (let\n-                    // and the LHS of @-patterns), matching such a value is\n-                    // simply disallowed (since it's rarely what you want).\n-                    let const_ok = mode == RefutableMode && at_rhs.is_none();\n-\n-                    let ident = path1.node;\n-                    let renamed = mtwt::resolve(ident);\n-\n-                    match self.resolve_bare_identifier_pattern(ident, pattern.span) {\n-                        FoundStructOrEnumVariant(def) if const_ok => {\n-                            debug!(\"(resolving pattern) resolving `{}` to struct or enum variant\",\n-                                   renamed);\n-\n-                            self.enforce_default_binding_mode(pattern,\n-                                                              binding_mode,\n-                                                              \"an enum variant\");\n-                            self.record_def(pattern.id,\n-                                            PathResolution {\n-                                                base_def: def,\n-                                                depth: 0,\n-                                            });\n-                        }\n-                        FoundStructOrEnumVariant(..) => {\n-                            resolve_error(\n-                                self,\n-                                pattern.span,\n-                                ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(\n-                                    renamed)\n-                            );\n-                            self.record_def(pattern.id, err_path_resolution());\n-                        }\n-                        FoundConst(binding, _) if const_ok => {\n-                            debug!(\"(resolving pattern) resolving `{}` to constant\", renamed);\n-\n-                            self.enforce_default_binding_mode(pattern, binding_mode, \"a constant\");\n-                            self.record_def(pattern.id,\n-                                            PathResolution {\n-                                                base_def: binding.def().unwrap(),\n-                                                depth: 0,\n-                                            });\n-                        }\n-                        FoundConst(binding, name) => {\n-                            resolve_error(\n-                                self,\n-                                pattern.span,\n-                                ResolutionError::ConstantForIrrefutableBinding(name, binding)\n-                            );\n-                            self.record_def(pattern.id, err_path_resolution());\n-                        }\n-                        BareIdentifierPatternUnresolved => {\n-                            debug!(\"(resolving pattern) binding `{}`\", renamed);\n-\n-                            let def_id = self.definitions.local_def_id(pattern.id);\n-                            let def = Def::Local(def_id, pattern.id);\n-\n-                            // Record the definition so that later passes\n-                            // will be able to distinguish variants from\n-                            // locals in patterns.\n-\n-                            self.record_def(pattern.id,\n-                                            PathResolution {\n-                                                base_def: def,\n-                                                depth: 0,\n-                                            });\n-\n-                            // Add the binding to the local ribs, if it\n-                            // doesn't already exist in the bindings list. (We\n-                            // must not add it if it's in the bindings list\n-                            // because that breaks the assumptions later\n-                            // passes make about or-patterns.)\n-                            if !bindings_list.contains_key(&renamed) {\n-                                let this = &mut *self;\n-                                let last_rib = this.value_ribs.last_mut().unwrap();\n-                                last_rib.bindings.insert(renamed, def);\n-                                bindings_list.insert(renamed, pat_id);\n-                            } else if mode == ArgumentIrrefutableMode &&\n-                               bindings_list.contains_key(&renamed) {\n-                                // Forbid duplicate bindings in the same\n-                                // parameter list.\n-                                resolve_error(\n-                                    self,\n-                                    pattern.span,\n-                                    ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n-                                        &ident.name.as_str())\n-                                );\n-                            } else if bindings_list.get(&renamed) == Some(&pat_id) {\n-                                // Then this is a duplicate variable in the\n-                                // same disjunction, which is an error.\n-                                resolve_error(\n-                                    self,\n-                                    pattern.span,\n-                                    ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n-                                        &ident.name.as_str())\n-                                );\n-                            }\n-                            // Else, not bound in the same pattern: do\n-                            // nothing.\n-                        }\n-                    }\n+    fn fresh_binding(&mut self,\n+                     ident: &ast::SpannedIdent,\n+                     pat_id: NodeId,\n+                     outer_pat_id: NodeId,\n+                     pat_src: PatternSource,\n+                     bindings: &mut HashMap<Name, NodeId>)\n+                     -> PathResolution {\n+        // Add the binding to the local ribs, if it\n+        // doesn't already exist in the bindings map. (We\n+        // must not add it if it's in the bindings map\n+        // because that breaks the assumptions later\n+        // passes make about or-patterns.)\n+        let renamed = mtwt::resolve(ident.node);\n+        let def = match bindings.get(&renamed).cloned() {\n+            Some(id) if id == outer_pat_id => {\n+                // `Variant(a, a)`, error\n+                resolve_error(\n+                    self,\n+                    ident.span,\n+                    ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n+                        &ident.node.name.as_str())\n+                );\n+                Def::Err\n+            }\n+            Some(..) if pat_src == PatternSource::FnParam => {\n+                // `fn f(a: u8, a: u8)`, error\n+                resolve_error(\n+                    self,\n+                    ident.span,\n+                    ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n+                        &ident.node.name.as_str())\n+                );\n+                Def::Err\n+            }\n+            Some(..) if pat_src == PatternSource::Match => {\n+                // `Variant1(a) | Variant2(a)`, ok\n+                // Reuse definition from the first `a`.\n+                self.value_ribs.last_mut().unwrap().bindings[&renamed]\n+            }\n+            Some(..) => {\n+                span_bug!(ident.span, \"two bindings with the same name from \\\n+                                       unexpected pattern source {:?}\", pat_src);\n+            }\n+            None => {\n+                // A completely fresh binding, add to the lists.\n+                // FIXME: Later stages are not ready to deal with `Def::Err` here yet, so\n+                // define `Invalid` bindings as `Def::Local`, just don't add them to the lists.\n+                let def = Def::Local(self.definitions.local_def_id(pat_id), pat_id);\n+                if ident.node.name != keywords::Invalid.name() {\n+                    bindings.insert(renamed, outer_pat_id);\n+                    self.value_ribs.last_mut().unwrap().bindings.insert(renamed, def);\n                 }\n+                def\n+            }\n+        };\n \n-                PatKind::TupleStruct(ref path, _, _) | PatKind::Path(ref path) => {\n-                    // This must be an enum variant, struct or const.\n-                    let resolution = match self.resolve_possibly_assoc_item(pat_id,\n-                                                                            None,\n-                                                                            path,\n-                                                                            ValueNS) {\n-                        // The below shouldn't happen because all\n-                        // qualified paths should be in PatKind::QPath.\n-                        TypecheckRequired =>\n-                            span_bug!(path.span,\n-                                      \"resolve_possibly_assoc_item claimed that a path \\\n-                                       in PatKind::Path or PatKind::TupleStruct \\\n-                                       requires typecheck to resolve, but qualified \\\n-                                       paths should be PatKind::QPath\"),\n-                        ResolveAttempt(resolution) => resolution,\n-                    };\n-                    if let Some(path_res) = resolution {\n-                        match path_res.base_def {\n-                            Def::Struct(..) if path_res.depth == 0 => {\n-                                self.record_def(pattern.id, path_res);\n-                            }\n-                            Def::Variant(..) | Def::Const(..) => {\n-                                self.record_def(pattern.id, path_res);\n-                            }\n-                            Def::Static(..) => {\n-                                let segments = &path.segments;\n-                                let binding = if path.global {\n-                                    self.resolve_crate_relative_path(path.span, segments, ValueNS)\n-                                } else {\n-                                    self.resolve_module_relative_path(path.span, segments, ValueNS)\n-                                }.unwrap();\n+        PathResolution::new(def)\n+    }\n \n-                                let error = ResolutionError::StaticVariableReference(binding);\n-                                resolve_error(self, path.span, error);\n-                                self.record_def(pattern.id, err_path_resolution());\n-                            }\n-                            _ => {\n-                                // If anything ends up here entirely resolved,\n-                                // it's an error. If anything ends up here\n-                                // partially resolved, that's OK, because it may\n-                                // be a `T::CONST` that typeck will resolve.\n-                                if path_res.depth == 0 {\n-                                    resolve_error(\n-                                        self,\n-                                        path.span,\n-                                        ResolutionError::NotAnEnumVariantStructOrConst(\n-                                            &path.segments\n-                                                 .last()\n-                                                 .unwrap()\n-                                                 .identifier\n-                                                 .name\n-                                                 .as_str())\n-                                    );\n-                                    self.record_def(pattern.id, err_path_resolution());\n-                                } else {\n-                                    let const_name = path.segments\n-                                                         .last()\n-                                                         .unwrap()\n-                                                         .identifier\n-                                                         .name;\n-                                    let traits = self.get_traits_containing_item(const_name);\n-                                    self.trait_map.insert(pattern.id, traits);\n-                                    self.record_def(pattern.id, path_res);\n-                                }\n-                            }\n-                        }\n-                    } else {\n-                        if let Err(false) = self.resolve_path(pat_id, &path, 0, ValueNS) {\n-                            // No error has been reported, so we need to do this ourselves.\n-                            resolve_error(\n-                                self,\n-                                path.span,\n-                                ResolutionError::UnresolvedEnumVariantStructOrConst(\n-                                    &path.segments.last().unwrap().identifier.name.as_str())\n-                            );\n-                        }\n-                        self.record_def(pattern.id, err_path_resolution());\n-                    }\n-                    visit::walk_path(self, path);\n+    fn resolve_pattern_path<ExpectedFn>(&mut self,\n+                                        pat_id: NodeId,\n+                                        qself: Option<&QSelf>,\n+                                        path: &Path,\n+                                        namespace: Namespace,\n+                                        expected_fn: ExpectedFn,\n+                                        expected_what: &str)\n+        where ExpectedFn: FnOnce(Def) -> bool\n+    {\n+        let resolution = if let Some(resolution) = self.resolve_possibly_assoc_item(pat_id,\n+                                                                        qself, path, namespace) {\n+            if resolution.depth == 0 {\n+                if expected_fn(resolution.base_def) {\n+                    resolution\n+                } else {\n+                    resolve_error(\n+                        self,\n+                        path.span,\n+                        ResolutionError::PatPathUnexpected(expected_what,\n+                                                           resolution.kind_name(), path)\n+                    );\n+                    err_path_resolution()\n+                }\n+            } else {\n+                // Not fully resolved associated item `T::A::B` or `<T as Tr>::A::B`\n+                // or `<T>::A::B`. If `B` should be resolved in value namespace then\n+                // it needs to be added to the trait map.\n+                if namespace == ValueNS {\n+                    let item_name = path.segments.last().unwrap().identifier.name;\n+                    let traits = self.get_traits_containing_item(item_name);\n+                    self.trait_map.insert(pat_id, traits);\n                 }\n+                resolution\n+            }\n+        } else {\n+            if let Err(false) = self.resolve_path(pat_id, path, 0, namespace) {\n+                resolve_error(\n+                    self,\n+                    path.span,\n+                    ResolutionError::PatPathUnresolved(expected_what, path)\n+                );\n+            }\n+            err_path_resolution()\n+        };\n \n-                PatKind::QPath(ref qself, ref path) => {\n-                    // Associated constants only.\n-                    let resolution = match self.resolve_possibly_assoc_item(pat_id,\n-                                                                            Some(qself),\n-                                                                            path,\n-                                                                            ValueNS) {\n-                        TypecheckRequired => {\n-                            // All `<T>::CONST` should end up here, and will\n-                            // require use of the trait map to resolve\n-                            // during typechecking.\n-                            let const_name = path.segments\n-                                                 .last()\n-                                                 .unwrap()\n-                                                 .identifier\n-                                                 .name;\n-                            let traits = self.get_traits_containing_item(const_name);\n-                            self.trait_map.insert(pattern.id, traits);\n-                            visit::walk_pat(self, pattern);\n-                            return true;\n-                        }\n-                        ResolveAttempt(resolution) => resolution,\n-                    };\n-                    if let Some(path_res) = resolution {\n-                        match path_res.base_def {\n-                            // All `<T as Trait>::CONST` should end up here, and\n-                            // have the trait already selected.\n-                            Def::AssociatedConst(..) => {\n-                                self.record_def(pattern.id, path_res);\n+        self.record_def(pat_id, resolution);\n+    }\n+\n+    fn resolve_pattern(&mut self,\n+                       pat: &Pat,\n+                       pat_src: PatternSource,\n+                       // Maps idents to the node ID for the\n+                       // outermost pattern that binds them.\n+                       bindings: &mut HashMap<Name, NodeId>) {\n+        // Visit all direct subpatterns of this pattern.\n+        let outer_pat_id = pat.id;\n+        pat.walk(&mut |pat| {\n+            match pat.node {\n+                PatKind::Ident(bmode, ref ident, ref opt_pat) => {\n+                    // First try to resolve the identifier as some existing\n+                    // entity, then fall back to a fresh binding.\n+                    let resolution = if let Ok(resolution) = self.resolve_path(pat.id,\n+                                &Path::from_ident(ident.span, ident.node), 0, ValueNS) {\n+                        let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n+                                             bmode != BindingMode::ByValue(Mutability::Immutable);\n+                        match resolution.base_def {\n+                            Def::Struct(..) | Def::Variant(..) |\n+                            Def::Const(..) | Def::AssociatedConst(..) if !always_binding => {\n+                                // A constant, unit variant, etc pattern.\n+                                resolution\n                             }\n-                            _ => {\n+                            Def::Struct(..) | Def::Variant(..) |\n+                            Def::Const(..) | Def::AssociatedConst(..) | Def::Static(..) => {\n+                                // A fresh binding that shadows something unacceptable.\n                                 resolve_error(\n                                     self,\n-                                    path.span,\n-                                    ResolutionError::NotAnAssociatedConst(\n-                                        &path.segments.last().unwrap().identifier.name.as_str()\n-                                    )\n+                                    ident.span,\n+                                    ResolutionError::BindingShadowsSomethingUnacceptable(\n+                                        pat_src.descr(), resolution.kind_name(), ident.node.name)\n                                 );\n-                                self.record_def(pattern.id, err_path_resolution());\n+                                err_path_resolution()\n+                            }\n+                            Def::Local(..) | Def::Upvar(..) | Def::Fn(..) | Def::Err => {\n+                                // These entities are explicitly allowed\n+                                // to be shadowed by fresh bindings.\n+                                self.fresh_binding(ident, pat.id, outer_pat_id,\n+                                                   pat_src, bindings)\n+                            }\n+                            def => {\n+                                span_bug!(ident.span, \"unexpected definition for an \\\n+                                                       identifier in pattern {:?}\", def);\n                             }\n                         }\n                     } else {\n-                        resolve_error(self,\n-                                      path.span,\n-                                      ResolutionError::UnresolvedAssociatedConst(&path.segments\n-                                                                                      .last()\n-                                                                                      .unwrap()\n-                                                                                      .identifier\n-                                                                                      .name\n-                                                                                      .as_str()));\n-                        self.record_def(pattern.id, err_path_resolution());\n-                    }\n-                    visit::walk_pat(self, pattern);\n+                        // Fall back to a fresh binding.\n+                        self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n+                    };\n+\n+                    self.record_def(pat.id, resolution);\n                 }\n \n-                PatKind::Struct(ref path, _, _) => {\n-                    match self.resolve_path(pat_id, path, 0, TypeNS) {\n-                        Ok(definition) => {\n-                            self.record_def(pattern.id, definition);\n+                PatKind::TupleStruct(ref path, _, _) => {\n+                    self.resolve_pattern_path(pat.id, None, path, ValueNS, |def| {\n+                        match def {\n+                            Def::Struct(..) | Def::Variant(..) | Def::Err => true,\n+                            _ => false,\n                         }\n-                        Err(true) => self.record_def(pattern.id, err_path_resolution()),\n-                        Err(false) => {\n-                            resolve_error(\n-                                self,\n-                                path.span,\n-                                ResolutionError::DoesNotNameAStruct(\n-                                    &path_names_to_string(path, 0))\n-                            );\n-                            self.record_def(pattern.id, err_path_resolution());\n+                    }, \"variant or struct\");\n+                }\n+\n+                PatKind::Path(ref path) => {\n+                    self.resolve_pattern_path(pat.id, None, path, ValueNS, |def| {\n+                        match def {\n+                            Def::Struct(..) | Def::Variant(..) |\n+                            Def::Const(..) | Def::AssociatedConst(..) | Def::Err => true,\n+                            _ => false,\n                         }\n-                    }\n-                    visit::walk_path(self, path);\n+                    }, \"variant, struct or constant\");\n                 }\n \n-                PatKind::Lit(_) | PatKind::Range(..) => {\n-                    visit::walk_pat(self, pattern);\n+                PatKind::QPath(ref qself, ref path) => {\n+                    self.resolve_pattern_path(pat.id, Some(qself), path, ValueNS, |def| {\n+                        match def {\n+                            Def::AssociatedConst(..) | Def::Err => true,\n+                            _ => false,\n+                        }\n+                    }, \"associated constant\");\n                 }\n \n-                _ => {\n-                    // Nothing to do.\n+                PatKind::Struct(ref path, _, _) => {\n+                    self.resolve_pattern_path(pat.id, None, path, TypeNS, |def| {\n+                        match def {\n+                            Def::Struct(..) | Def::Variant(..) |\n+                            Def::TyAlias(..) | Def::AssociatedTy(..) | Def::Err => true,\n+                            _ => false,\n+                        }\n+                    }, \"variant, struct or type alias\");\n                 }\n+\n+                _ => {}\n             }\n             true\n         });\n-    }\n-\n-    fn resolve_bare_identifier_pattern(&mut self, ident: ast::Ident, span: Span)\n-                                       -> BareIdentifierPatternResolution<'a> {\n-        let binding = match self.resolve_ident_in_lexical_scope(ident, ValueNS, true) {\n-            Some(LexicalScopeBinding::Item(binding)) => binding,\n-            _ => return BareIdentifierPatternUnresolved,\n-        };\n-        let def = binding.def().unwrap();\n \n-        match def {\n-            Def::Variant(..) | Def::Struct(..) => FoundStructOrEnumVariant(def),\n-            Def::Const(..) | Def::AssociatedConst(..) => FoundConst(binding, ident.name),\n-            Def::Static(..) => {\n-                let error = ResolutionError::StaticVariableReference(binding);\n-                resolve_error(self, span, error);\n-                BareIdentifierPatternUnresolved\n-            }\n-            _ => BareIdentifierPatternUnresolved,\n-        }\n+        visit::walk_pat(self, pat);\n     }\n \n     /// Handles paths that may refer to associated items\n     fn resolve_possibly_assoc_item(&mut self,\n                                    id: NodeId,\n-                                   maybe_qself: Option<&ast::QSelf>,\n+                                   maybe_qself: Option<&QSelf>,\n                                    path: &Path,\n                                    namespace: Namespace)\n-                                   -> AssocItemResolveResult {\n+                                   -> Option<PathResolution> {\n         let max_assoc_types;\n \n         match maybe_qself {\n             Some(qself) => {\n                 if qself.position == 0 {\n-                    return TypecheckRequired;\n+                    // FIXME: Create some fake resolution that can't possibly be a type.\n+                    return Some(PathResolution {\n+                        base_def: Def::Mod(self.definitions.local_def_id(ast::CRATE_NODE_ID)),\n+                        depth: path.segments.len(),\n+                    });\n                 }\n                 max_assoc_types = path.segments.len() - qself.position;\n                 // Make sure the trait is valid.\n@@ -2579,14 +2436,15 @@ impl<'a> Resolver<'a> {\n                 break;\n             }\n             self.with_no_errors(|this| {\n-                resolution = this.resolve_path(id, path, depth, TypeNS).ok();\n+                let partial_resolution = this.resolve_path(id, path, depth, TypeNS).ok();\n+                if let Some(Def::Mod(..)) = partial_resolution.map(|r| r.base_def) {\n+                    // Modules cannot have associated items\n+                } else {\n+                    resolution = partial_resolution;\n+                }\n             });\n         }\n-        if let Some(Def::Mod(_)) = resolution.map(|r| r.base_def) {\n-            // A module is not a valid type or value.\n-            resolution = None;\n-        }\n-        ResolveAttempt(resolution)\n+        resolution\n     }\n \n     /// Skips `path_depth` trailing segments, which is also reflected in the\n@@ -2598,7 +2456,7 @@ impl<'a> Resolver<'a> {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len() - path_depth];\n \n-        let mk_res = |def| PathResolution::new(def, path_depth);\n+        let mk_res = |def| PathResolution { base_def: def, depth: path_depth };\n \n         if path.global {\n             let binding = self.resolve_crate_relative_path(span, segments, namespace);\n@@ -2866,19 +2724,18 @@ impl<'a> Resolver<'a> {\n \n         if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n             // Look for a field with the same name in the current self_type.\n-            match self.def_map.get(&node_id).map(|d| d.full_def()) {\n-                Some(Def::Enum(did)) |\n-                Some(Def::TyAlias(did)) |\n-                Some(Def::Struct(did)) |\n-                Some(Def::Variant(_, did)) => match self.structs.get(&did) {\n-                    None => {}\n-                    Some(fields) => {\n-                        if fields.iter().any(|&field_name| name == field_name) {\n-                            return Field;\n+            if let Some(resolution) = self.def_map.get(&node_id) {\n+                match resolution.base_def {\n+                    Def::Enum(did) | Def::TyAlias(did) |\n+                    Def::Struct(did) | Def::Variant(_, did) if resolution.depth == 0 => {\n+                        if let Some(fields) = self.structs.get(&did) {\n+                            if fields.iter().any(|&field_name| name == field_name) {\n+                                return Field;\n+                            }\n                         }\n                     }\n-                },\n-                _ => {} // Self type didn't resolve properly\n+                    _ => {}\n+                }\n             }\n         }\n \n@@ -2935,24 +2792,10 @@ impl<'a> Resolver<'a> {\n         // Next, resolve the node.\n         match expr.node {\n             ExprKind::Path(ref maybe_qself, ref path) => {\n-                let resolution = match self.resolve_possibly_assoc_item(expr.id,\n-                                                                        maybe_qself.as_ref(),\n-                                                                        path,\n-                                                                        ValueNS) {\n-                    // `<T>::a::b::c` is resolved by typeck alone.\n-                    TypecheckRequired => {\n-                        let method_name = path.segments.last().unwrap().identifier.name;\n-                        let traits = self.get_traits_containing_item(method_name);\n-                        self.trait_map.insert(expr.id, traits);\n-                        visit::walk_expr(self, expr);\n-                        return;\n-                    }\n-                    ResolveAttempt(resolution) => resolution,\n-                };\n-\n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n-                if let Some(path_res) = resolution {\n+                if let Some(path_res) = self.resolve_possibly_assoc_item(expr.id,\n+                                                            maybe_qself.as_ref(), path, ValueNS) {\n                     // Check if struct variant\n                     let is_struct_variant = if let Def::Variant(_, variant_id) = path_res.base_def {\n                         self.structs.contains_key(&variant_id)\n@@ -3155,11 +2998,7 @@ impl<'a> Resolver<'a> {\n                     }\n                     Some(def @ Def::Label(_)) => {\n                         // Since this def is a label, it is never read.\n-                        self.record_def(expr.id,\n-                                        PathResolution {\n-                                            base_def: def,\n-                                            depth: 0,\n-                                        })\n+                        self.record_def(expr.id, PathResolution::new(def))\n                     }\n                     Some(_) => {\n                         span_bug!(expr.span, \"label wasn't mapped to a label def!\")\n@@ -3171,7 +3010,7 @@ impl<'a> Resolver<'a> {\n                 self.visit_expr(subexpression);\n \n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, RefutableMode, &mut HashMap::new());\n+                self.resolve_pattern(pattern, PatternSource::IfLet, &mut HashMap::new());\n                 self.visit_block(if_block);\n                 self.value_ribs.pop();\n \n@@ -3181,7 +3020,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, RefutableMode, &mut HashMap::new());\n+                self.resolve_pattern(pattern, PatternSource::WhileLet, &mut HashMap::new());\n \n                 self.resolve_labeled_block(label.map(|l| l.node), expr.id, block);\n \n@@ -3191,7 +3030,7 @@ impl<'a> Resolver<'a> {\n             ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n                 self.value_ribs.push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, LocalIrrefutableMode, &mut HashMap::new());\n+                self.resolve_pattern(pattern, PatternSource::For, &mut HashMap::new());\n \n                 self.resolve_labeled_block(label.map(|l| l.node), expr.id, block);\n \n@@ -3411,20 +3250,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn enforce_default_binding_mode(&mut self,\n-                                    pat: &Pat,\n-                                    pat_binding_mode: BindingMode,\n-                                    descr: &str) {\n-        match pat_binding_mode {\n-            BindingMode::ByValue(_) => {}\n-            BindingMode::ByRef(..) => {\n-                resolve_error(self,\n-                              pat.span,\n-                              ResolutionError::CannotUseRefBindingModeWith(descr));\n-            }\n-        }\n-    }\n-\n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n         let (path, id) = match *vis {\n             ast::Visibility::Public => return ty::Visibility::Public,\n@@ -3440,11 +3265,11 @@ impl<'a> Resolver<'a> {\n         };\n \n         let segments: Vec<_> = path.segments.iter().map(|seg| seg.identifier.name).collect();\n+        let mut path_resolution = err_path_resolution();\n         let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, path.span) {\n             Success(module) => {\n                 let def = module.def.unwrap();\n-                let path_resolution = PathResolution { base_def: def, depth: 0 };\n-                self.def_map.insert(id, path_resolution);\n+                path_resolution = PathResolution::new(def);\n                 ty::Visibility::Restricted(self.definitions.as_local_node_id(def.def_id()).unwrap())\n             }\n             Failed(Some((span, msg))) => {\n@@ -3456,6 +3281,7 @@ impl<'a> Resolver<'a> {\n                 ty::Visibility::Public\n             }\n         };\n+        self.def_map.insert(id, path_resolution);\n         if !self.is_accessible(vis) {\n             let msg = format!(\"visibilities can only be restricted to ancestor modules\");\n             self.session.span_err(path.span, &msg);\n@@ -3656,13 +3482,9 @@ fn module_to_string(module: Module) -> String {\n }\n \n fn err_path_resolution() -> PathResolution {\n-    PathResolution {\n-        base_def: Def::Err,\n-        depth: 0,\n-    }\n+    PathResolution::new(Def::Err)\n }\n \n-\n #[derive(PartialEq,Copy, Clone)]\n pub enum MakeGlobMap {\n     Yes,"}, {"sha": "3082a8b43076f24218f4c2c94a6a220a36818176", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -598,7 +598,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             Some(def) => def,\n             None => value_result.success().and_then(NameBinding::def).unwrap(),\n         };\n-        let path_resolution = PathResolution { base_def: def, depth: 0 };\n+        let path_resolution = PathResolution::new(def);\n         self.resolver.def_map.insert(directive.id, path_resolution);\n \n         debug!(\"(resolving single import) successfully resolved import\");\n@@ -644,7 +644,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         // Record the destination of this import\n         if let Some(did) = target_module.def_id() {\n-            let resolution = PathResolution { base_def: Def::Mod(did), depth: 0 };\n+            let resolution = PathResolution::new(Def::Mod(did));\n             self.resolver.def_map.insert(directive.id, resolution);\n         }\n "}, {"sha": "216d188a503e3a2b73477bea643c82b56191608d", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -269,14 +269,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n     // looks up anything, not just a type\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n-        if !self.tcx.def_map.borrow().contains_key(&ref_id) {\n-            bug!(\"def_map has no key for {} in lookup_type_ref\", ref_id);\n-        }\n-        let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n-        match def {\n+        match self.tcx.expect_def(ref_id) {\n             Def::PrimTy(..) => None,\n             Def::SelfTy(..) => None,\n-            _ => Some(def.def_id()),\n+            def => Some(def.def_id()),\n         }\n     }\n \n@@ -290,13 +286,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             return;\n         }\n \n-        let def_map = self.tcx.def_map.borrow();\n-        if !def_map.contains_key(&ref_id) {\n-            span_bug!(span,\n-                      \"def_map has no key for {} in lookup_def_kind\",\n-                      ref_id);\n-        }\n-        let def = def_map.get(&ref_id).unwrap().full_def();\n+        let def = self.tcx.expect_def(ref_id);\n         match def {\n             Def::Mod(_) |\n             Def::ForeignMod(_) => {\n@@ -853,9 +843,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n \n         // Modules or types in the path prefix.\n-        let def_map = self.tcx.def_map.borrow();\n-        let def = def_map.get(&id).unwrap().full_def();\n-        match def {\n+        match self.tcx.expect_def(id) {\n             Def::Method(did) => {\n                 let ti = self.tcx.impl_or_trait_item(did);\n                 if let ty::MethodTraitItem(m) = ti {\n@@ -924,8 +912,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             PatKind::Struct(ref path, ref fields, _) => {\n                 visit::walk_path(self, path);\n                 let adt = self.tcx.node_id_to_type(p.id).ty_adt_def().unwrap();\n-                let def = self.tcx.def_map.borrow()[&p.id].full_def();\n-                let variant = adt.variant_of_def(def);\n+                let variant = adt.variant_of_def(self.tcx.expect_def(p.id));\n \n                 for &Spanned { node: ref field, span } in fields {\n                     let sub_span = self.span.span_for_first_ident(span);\n@@ -1269,7 +1256,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n                 let hir_expr = self.save_ctxt.tcx.map.expect_expr(ex.id);\n                 let adt = self.tcx.expr_ty(&hir_expr).ty_adt_def().unwrap();\n-                let def = self.tcx.resolve_expr(&hir_expr);\n+                let def = self.tcx.expect_def(hir_expr.id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n             }\n             ast::ExprKind::MethodCall(_, _, ref args) => self.process_method_call(ex, args),\n@@ -1366,12 +1353,7 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n \n         // process collected paths\n         for &(id, ref p, immut, ref_kind) in &collector.collected_paths {\n-            let def_map = self.tcx.def_map.borrow();\n-            if !def_map.contains_key(&id) {\n-                span_bug!(p.span, \"def_map has no key for {} in visit_arm\", id);\n-            }\n-            let def = def_map.get(&id).unwrap().full_def();\n-            match def {\n+            match self.tcx.expect_def(id) {\n                 Def::Local(_, id) => {\n                     let value = if immut == ast::Mutability::Immutable {\n                         self.span.snippet(p.span).to_string()\n@@ -1401,8 +1383,8 @@ impl<'v, 'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor<'v> for DumpVisitor<'l, 'tcx,\n                 Def::Static(_, _) |\n                 Def::Const(..) |\n                 Def::AssociatedConst(..) => {}\n-                _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n-                            def),\n+                def => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n+                              def),\n             }\n         }\n "}, {"sha": "27f15756a9130ec6f6c4e9a84556e8b93485a906", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -465,11 +465,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Data> {\n-        let def_map = self.tcx.def_map.borrow();\n-        if !def_map.contains_key(&id) {\n-            span_bug!(path.span, \"def_map has no key for {} in visit_expr\", id);\n-        }\n-        let def = def_map.get(&id).unwrap().full_def();\n+        let def = self.tcx.expect_def(id);\n         let sub_span = self.span_utils.span_for_last_ident(path.span);\n         filter!(self.span_utils, sub_span, path.span, None);\n         match def {\n@@ -637,13 +633,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     fn lookup_ref_id(&self, ref_id: NodeId) -> Option<DefId> {\n-        if !self.tcx.def_map.borrow().contains_key(&ref_id) {\n-            bug!(\"def_map has no key for {} in lookup_type_ref\", ref_id);\n-        }\n-        let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n-        match def {\n+        match self.tcx.expect_def(ref_id) {\n             Def::PrimTy(_) | Def::SelfTy(..) => None,\n-            _ => Some(def.def_id()),\n+            def => Some(def.def_id()),\n         }\n     }\n "}, {"sha": "8ad1ba2a61418b554abd218c35ad362e4adc6fac", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -657,9 +657,8 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 ConstantValue(ConstantExpr(&l), debug_loc)\n             }\n             PatKind::Path(..) | PatKind::TupleStruct(..) | PatKind::Struct(..) => {\n-                let opt_def = tcx.def_map.borrow().get(&cur.id).map(|d| d.full_def());\n-                match opt_def {\n-                    Some(Def::Variant(enum_id, var_id)) => {\n+                match tcx.expect_def(cur.id) {\n+                    Def::Variant(enum_id, var_id) => {\n                         let variant = tcx.lookup_adt_def(enum_id).variant_with_id(var_id);\n                         Variant(Disr::from(variant.disr_val),\n                                 adt::represent_node(bcx, cur.id),\n@@ -796,7 +795,7 @@ fn any_irrefutable_adt_pat(tcx: TyCtxt, m: &[Match], col: usize) -> bool {\n         match pat.node {\n             PatKind::Tuple(..) => true,\n             PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) => {\n-                match tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n+                match tcx.expect_def(pat.id) {\n                     Def::Struct(..) | Def::TyAlias(..) => true,\n                     _ => false,\n                 }\n@@ -1444,19 +1443,19 @@ pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// Checks whether the binding in `discr` is assigned to anywhere in the expression `body`\n fn is_discr_reassigned(bcx: Block, discr: &hir::Expr, body: &hir::Expr) -> bool {\n     let (vid, field) = match discr.node {\n-        hir::ExprPath(..) => match bcx.def(discr.id) {\n+        hir::ExprPath(..) => match bcx.tcx().expect_def(discr.id) {\n             Def::Local(_, vid) | Def::Upvar(_, vid, _, _) => (vid, None),\n             _ => return false\n         },\n         hir::ExprField(ref base, field) => {\n-            let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n+            let vid = match bcx.tcx().expect_def_or_none(base.id) {\n                 Some(Def::Local(_, vid)) | Some(Def::Upvar(_, vid, _, _)) => vid,\n                 _ => return false\n             };\n             (vid, Some(mc::NamedField(field.node)))\n         },\n         hir::ExprTupField(ref base, field) => {\n-            let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n+            let vid = match bcx.tcx().expect_def_or_none(base.id) {\n                 Some(Def::Local(_, vid)) | Some(Def::Upvar(_, vid, _, _)) => vid,\n                 _ => return false\n             };\n@@ -1835,9 +1834,8 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         PatKind::TupleStruct(_, ref sub_pats, ddpos) => {\n-            let opt_def = bcx.tcx().def_map.borrow().get(&pat.id).map(|d| d.full_def());\n-            match opt_def {\n-                Some(Def::Variant(enum_id, var_id)) => {\n+            match bcx.tcx().expect_def(pat.id) {\n+                Def::Variant(enum_id, var_id) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n                     let vinfo = ccx.tcx().lookup_adt_def(enum_id).variant_with_id(var_id);\n                     let args = extract_variant_args(bcx,\n@@ -1853,7 +1851,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             cleanup_scope);\n                     }\n                 }\n-                Some(Def::Struct(..)) => {\n+                Def::Struct(..) => {\n                     let expected_len = match *ccx.tcx().pat_ty(&pat) {\n                         ty::TyS{sty: ty::TyStruct(adt_def, _), ..} => {\n                             adt_def.struct_variant().fields.len()"}, {"sha": "6b8198881c83c61820236c76e2e7fc4e3066c0e3", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -260,8 +260,7 @@ impl<'a, 'tcx> VariantInfo<'tcx> {\n \n     /// Return the variant corresponding to a given node (e.g. expr)\n     pub fn of_node(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>, id: ast::NodeId) -> Self {\n-        let node_def = tcx.def_map.borrow().get(&id).map(|v| v.full_def());\n-        Self::from_ty(tcx, ty, node_def)\n+        Self::from_ty(tcx, ty, Some(tcx.expect_def(id)))\n     }\n \n     pub fn field_index(&self, name: ast::Name) -> usize {\n@@ -656,15 +655,6 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.tcx().map.node_to_string(id).to_string()\n     }\n \n-    pub fn def(&self, nid: ast::NodeId) -> Def {\n-        match self.tcx().def_map.borrow().get(&nid) {\n-            Some(v) => v.full_def(),\n-            None => {\n-                bug!(\"no def associated with node id {}\", nid);\n-            }\n-        }\n-    }\n-\n     pub fn to_str(&self) -> String {\n         format!(\"[block {:p}]\", self)\n     }"}, {"sha": "e988d2e6ac31482725ebd2eb47194be5c64a77f9", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -297,8 +297,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // `def` must be its own statement and cannot be in the `match`\n         // otherwise the `def_map` will be borrowed for the entire match instead\n         // of just to get the `def` value\n-        let def = ccx.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n-        match def {\n+        match ccx.tcx().expect_def(expr.id) {\n             Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                 if !ccx.tcx().tables.borrow().adjustments.contains_key(&expr.id) {\n                     debug!(\"get_const_expr_as_global ({:?}): found const {:?}\",\n@@ -803,8 +802,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     _ => break,\n                 }\n             }\n-            let opt_def = cx.tcx().def_map.borrow().get(&cur.id).map(|d| d.full_def());\n-            if let Some(Def::Static(def_id, _)) = opt_def {\n+            if let Some(Def::Static(def_id, _)) = cx.tcx().expect_def_or_none(cur.id) {\n                 get_static(cx, def_id).val\n             } else {\n                 // If this isn't the address of a static, then keep going through\n@@ -891,8 +889,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         },\n         hir::ExprPath(..) => {\n-            let def = cx.tcx().def_map.borrow().get(&e.id).unwrap().full_def();\n-            match def {\n+            match cx.tcx().expect_def(e.id) {\n                 Def::Local(_, id) => {\n                     if let Some(val) = fn_args.and_then(|args| args.get(&id).cloned()) {\n                         val\n@@ -937,9 +934,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     _ => break,\n                 };\n             }\n-            let def = cx.tcx().def_map.borrow()[&callee.id].full_def();\n             let arg_vals = map_list(args)?;\n-            match def {\n+            match cx.tcx().expect_def(callee.id) {\n                 Def::Fn(did) | Def::Method(did) => {\n                     const_fn_call(\n                         cx,"}, {"sha": "8845f124218bc437b3da19d2a9048be5c97eba88", "filename": "src/librustc_trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_trans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_trans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontrolflow.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -318,8 +318,8 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let loop_id = match opt_label {\n         None => fcx.top_loop_scope(),\n         Some(_) => {\n-            match bcx.tcx().def_map.borrow().get(&expr.id).map(|d| d.full_def())  {\n-                Some(Def::Label(loop_id)) => loop_id,\n+            match bcx.tcx().expect_def(expr.id) {\n+                Def::Label(loop_id) => loop_id,\n                 r => {\n                     bug!(\"{:?} in def-map for label\", r)\n                 }"}, {"sha": "652886ff2a0449a5d2c1f38e8571162484710a8d", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -153,7 +153,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // have side effects. This seems to be reached through tuple struct constructors being\n             // passed zero-size constants.\n             if let hir::ExprPath(..) = expr.node {\n-                match bcx.def(expr.id) {\n+                match bcx.tcx().expect_def(expr.id) {\n                     Def::Const(_) | Def::AssociatedConst(_) => {\n                         assert!(type_is_zero_size(bcx.ccx(), bcx.tcx().node_id_to_type(expr.id)));\n                         return bcx;\n@@ -172,7 +172,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // `[x; N]` somewhere within.\n             match expr.node {\n                 hir::ExprPath(..) => {\n-                    match bcx.def(expr.id) {\n+                    match bcx.tcx().expect_def(expr.id) {\n                         Def::Const(did) | Def::AssociatedConst(did) => {\n                             let empty_substs = bcx.tcx().mk_substs(Substs::empty());\n                             let const_expr = consts::get_const_expr(bcx.ccx(), did, expr,\n@@ -651,7 +651,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans(bcx, &e)\n         }\n         hir::ExprPath(..) => {\n-            let var = trans_var(bcx, bcx.def(expr.id));\n+            let var = trans_var(bcx, bcx.tcx().expect_def(expr.id));\n             DatumBlock::new(bcx, var.to_expr_datum())\n         }\n         hir::ExprField(ref base, name) => {\n@@ -1073,7 +1073,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_into(bcx, &e, dest)\n         }\n         hir::ExprPath(..) => {\n-            trans_def_dps_unadjusted(bcx, expr, bcx.def(expr.id), dest)\n+            trans_def_dps_unadjusted(bcx, expr, bcx.tcx().expect_def(expr.id), dest)\n         }\n         hir::ExprIf(ref cond, ref thn, ref els) => {\n             controlflow::trans_if(bcx, expr.id, &cond, &thn, els.as_ref().map(|e| &**e), dest)\n@@ -2373,7 +2373,7 @@ fn expr_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, expr: &hir::Expr) -> ExprKin\n \n     match expr.node {\n         hir::ExprPath(..) => {\n-            match tcx.resolve_expr(expr) {\n+            match tcx.expect_def(expr.id) {\n                 // Put functions and ctors with the ADTs, as they\n                 // are zero-sized, so DPS is the cheapest option.\n                 Def::Struct(..) | Def::Variant(..) |"}, {"sha": "350ebf201653cd931611476abbadd86be356d370", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -734,7 +734,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     fn trait_def_id(&self, trait_ref: &hir::TraitRef) -> DefId {\n         let path = &trait_ref.path;\n-        match ::lookup_full_def(self.tcx(), path.span, trait_ref.ref_id) {\n+        match self.tcx().expect_def(trait_ref.ref_id) {\n             Def::Trait(trait_def_id) => trait_def_id,\n             Def::Err => {\n                 self.tcx().sess.fatal(\"cannot continue compilation due to previous error\");\n@@ -1064,12 +1064,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         match ty.node {\n             hir::TyPath(None, ref path) => {\n-                let def = match self.tcx().def_map.borrow().get(&ty.id) {\n-                    Some(&def::PathResolution { base_def, depth: 0, .. }) => Some(base_def),\n-                    _ => None\n-                };\n-                match def {\n-                    Some(Def::Trait(trait_def_id)) => {\n+                let resolution = self.tcx().expect_resolution(ty.id);\n+                match resolution.base_def {\n+                    Def::Trait(trait_def_id) if resolution.depth == 0 => {\n                         let mut projection_bounds = Vec::new();\n                         let trait_ref =\n                             self.object_path_to_poly_trait_ref(rscope,\n@@ -1721,17 +1718,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyPath(ref maybe_qself, ref path) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n-                let path_res = if let Some(&d) = tcx.def_map.borrow().get(&ast_ty.id) {\n-                    d\n-                } else if let Some(hir::QSelf { position: 0, .. }) = *maybe_qself {\n-                    // Create some fake resolution that can't possibly be a type.\n-                    def::PathResolution {\n-                        base_def: Def::Mod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n-                        depth: path.segments.len()\n-                    }\n-                } else {\n-                    span_bug!(ast_ty.span, \"unbound path {:?}\", ast_ty)\n-                };\n+                let path_res = tcx.expect_resolution(ast_ty.id);\n                 let def = path_res.base_def;\n                 let base_ty_end = path.segments.len() - path_res.depth;\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n@@ -1748,10 +1735,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n                 if path_res.depth != 0 && ty.sty != ty::TyError {\n                     // Write back the new resolution.\n-                    tcx.def_map.borrow_mut().insert(ast_ty.id, def::PathResolution {\n-                        base_def: def,\n-                        depth: 0\n-                    });\n+                    tcx.def_map.borrow_mut().insert(ast_ty.id, def::PathResolution::new(def));\n                 }\n \n                 ty\n@@ -2232,7 +2216,7 @@ pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     for ast_bound in ast_bounds {\n         match *ast_bound {\n             hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n-                match ::lookup_full_def(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n+                match tcx.expect_def(b.trait_ref.ref_id) {\n                     Def::Trait(trait_did) => {\n                         if tcx.try_add_builtin_trait(trait_did,\n                                                      &mut builtin_bounds) {"}, {"sha": "1cff392cf8338060f3e5dfbf85822449ad782e8f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 44, "deletions": 77, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def::{self, Def};\n+use hir::def::Def;\n use rustc::infer::{self, InferOk, TypeOrigin};\n-use hir::pat_util::{PatIdMap, pat_id_map};\n use hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n@@ -21,26 +20,13 @@ use session::Session;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n-use std::ops::Deref;\n use syntax::ast;\n use syntax::codemap::{Span, Spanned};\n use syntax::ptr::P;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n \n-pub struct PatCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    pub fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    pub map: PatIdMap,\n-}\n-\n-impl<'a, 'gcx, 'tcx> Deref for PatCtxt<'a, 'gcx, 'tcx> {\n-    type Target = FnCtxt<'a, 'gcx, 'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        self.fcx\n-    }\n-}\n-\n // This function exists due to the warning \"diagnostic code E0164 already used\"\n fn bad_struct_kind_err(sess: &Session, pat: &hir::Pat, path: &hir::Path, lint: bool) {\n     let name = pprust::path_to_string(path);\n@@ -55,7 +41,7 @@ fn bad_struct_kind_err(sess: &Session, pat: &hir::Pat, path: &hir::Path, lint: b\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_pat(&self, pat: &'gcx hir::Pat, expected: Ty<'tcx>) {\n         let tcx = self.tcx;\n \n@@ -150,26 +136,22 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n                 self.demand_eqtype(pat.span, expected, lhs_ty);\n             }\n             PatKind::Path(..) if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n-                if let Some(pat_def) = tcx.def_map.borrow().get(&pat.id) {\n-                    let const_did = pat_def.def_id();\n-                    let const_scheme = tcx.lookup_item_type(const_did);\n-                    assert!(const_scheme.generics.is_empty());\n-                    let const_ty = self.instantiate_type_scheme(pat.span,\n-                                                                &Substs::empty(),\n-                                                                &const_scheme.ty);\n-                    self.write_ty(pat.id, const_ty);\n-\n-                    // FIXME(#20489) -- we should limit the types here to scalars or something!\n-\n-                    // As with PatKind::Lit, what we really want here is that there\n-                    // exist a LUB, but for the cases that can occur, subtype\n-                    // is good enough.\n-                    self.demand_suptype(pat.span, expected, const_ty);\n-                } else {\n-                    self.write_error(pat.id);\n-                }\n-            }\n-            PatKind::Binding(bm, ref path, ref sub) => {\n+                let const_did = tcx.expect_def(pat.id).def_id();\n+                let const_scheme = tcx.lookup_item_type(const_did);\n+                assert!(const_scheme.generics.is_empty());\n+                let const_ty = self.instantiate_type_scheme(pat.span,\n+                                                            &Substs::empty(),\n+                                                            &const_scheme.ty);\n+                self.write_ty(pat.id, const_ty);\n+\n+                // FIXME(#20489) -- we should limit the types here to scalars or something!\n+\n+                // As with PatKind::Lit, what we really want here is that there\n+                // exist a LUB, but for the cases that can occur, subtype\n+                // is good enough.\n+                self.demand_suptype(pat.span, expected, const_ty);\n+            }\n+            PatKind::Binding(bm, _, ref sub) => {\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n                     hir::BindByRef(mutbl) => {\n@@ -198,15 +180,19 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n-                if let Some(&canon_id) = self.map.get(&path.node) {\n-                    if canon_id != pat.id {\n-                        let ct = self.local_ty(pat.span, canon_id);\n-                        self.demand_eqtype(pat.span, ct, typ);\n+                match tcx.expect_def(pat.id) {\n+                    Def::Err => {}\n+                    Def::Local(_, var_id) => {\n+                        if var_id != pat.id {\n+                            let vt = self.local_ty(pat.span, var_id);\n+                            self.demand_eqtype(pat.span, vt, typ);\n+                        }\n                     }\n+                    d => bug!(\"bad def for pattern binding `{:?}`\", d)\n+                }\n \n-                    if let Some(ref p) = *sub {\n-                        self.check_pat(&p, expected);\n-                    }\n+                if let Some(ref p) = *sub {\n+                    self.check_pat(&p, expected);\n                 }\n             }\n             PatKind::TupleStruct(ref path, ref subpats, ddpos) => {\n@@ -217,25 +203,12 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n             }\n             PatKind::QPath(ref qself, ref path) => {\n                 let self_ty = self.to_ty(&qself.ty);\n-                let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n-                    if d.base_def == Def::Err {\n-                        self.set_tainted_by_errors();\n-                        self.write_error(pat.id);\n-                        return;\n-                    }\n-                    d\n-                } else if qself.position == 0 {\n-                    // This is just a sentinel for finish_resolving_def_to_ty.\n-                    let sentinel = self.tcx.map.local_def_id(ast::CRATE_NODE_ID);\n-                    def::PathResolution {\n-                        base_def: Def::Mod(sentinel),\n-                        depth: path.segments.len()\n-                    }\n-                } else {\n-                    debug!(\"unbound path {:?}\", pat);\n+                let path_res = tcx.expect_resolution(pat.id);\n+                if path_res.base_def == Def::Err {\n+                    self.set_tainted_by_errors();\n                     self.write_error(pat.id);\n                     return;\n-                };\n+                }\n                 if let Some((opt_ty, segments, def)) =\n                         self.resolve_ty_and_def_ufcs(path_res, Some(self_ty),\n                                                      path, pat.span, pat.id) {\n@@ -493,12 +466,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n         for arm in arms {\n-            let pcx = PatCtxt {\n-                fcx: self,\n-                map: pat_id_map(&arm.pats[0]),\n-            };\n             for p in &arm.pats {\n-                pcx.check_pat(&p, discrim_ty);\n+                self.check_pat(&p, discrim_ty);\n             }\n         }\n \n@@ -583,13 +552,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_pat_struct(&self, pat: &'gcx hir::Pat,\n                             path: &hir::Path, fields: &'gcx [Spanned<hir::FieldPat>],\n                             etc: bool, expected: Ty<'tcx>) {\n         let tcx = self.tcx;\n \n-        let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n+        let def = tcx.expect_def(pat.id);\n         let variant = match self.def_struct_variant(def, path.span) {\n             Some((_, variant)) => variant,\n             None => {\n@@ -630,18 +599,16 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n         // Typecheck the path.\n         let tcx = self.tcx;\n \n-        let path_res = match tcx.def_map.borrow().get(&pat.id) {\n-            Some(&path_res) if path_res.base_def != Def::Err => path_res,\n-            _ => {\n-                self.set_tainted_by_errors();\n-                self.write_error(pat.id);\n+        let path_res = tcx.expect_resolution(pat.id);\n+        if path_res.base_def == Def::Err {\n+            self.set_tainted_by_errors();\n+            self.write_error(pat.id);\n \n-                for pat in subpats {\n-                    self.check_pat(&pat, tcx.types.err);\n-                }\n-                return;\n+            for pat in subpats {\n+                self.check_pat(&pat, tcx.types.err);\n             }\n-        };\n+            return;\n+        }\n \n         let (opt_ty, segments, def) = match self.resolve_ty_and_def_ufcs(path_res,\n                                                                          None, path,"}, {"sha": "58abf8db2c33d0c909b9696c8f6218b8bc291a28", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -222,7 +222,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let tcx = self.tcx;\n                     if let Some(pr) = tcx.def_map.borrow().get(&expr.id) {\n                         if pr.depth == 0 && pr.base_def != Def::Err {\n-                            if let Some(span) = tcx.map.span_if_local(pr.def_id()) {\n+                            if let Some(span) = tcx.map.span_if_local(pr.base_def.def_id()) {\n                                 err.span_note(span, \"defined here\");\n                             }\n                         }"}, {"sha": "d9dd122d07376e49b7ecf28c176d98b35ba3df42", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -81,14 +81,13 @@ pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n \n use astconv::{AstConv, ast_region_to_region, PathParamMode};\n-use check::_match::PatCtxt;\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use middle::cstore::LOCAL_CRATE;\n use hir::def::{self, Def};\n use hir::def_id::DefId;\n+use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n-use hir::pat_util::{self, pat_id_map};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::{GenericPredicates, TypeScheme};\n@@ -102,7 +101,7 @@ use rustc::ty::util::{Representability, IntTypeExt};\n use require_c_abi_if_variadic;\n use rscope::{ElisionFailureInfo, RegionScope};\n use session::{Session, CompileResult};\n-use {CrateCtxt, lookup_full_def};\n+use CrateCtxt;\n use TypeAndSubsts;\n use lint;\n use util::common::{block_query, ErrorReported, indenter, loop_query};\n@@ -672,11 +671,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n             });\n \n             // Check the pattern.\n-            let pcx = PatCtxt {\n-                fcx: &fcx,\n-                map: pat_id_map(&input.pat),\n-            };\n-            pcx.check_pat(&input.pat, *arg_ty);\n+            fcx.check_pat(&input.pat, *arg_ty);\n         }\n \n         visit.visit_block(body);\n@@ -3158,7 +3153,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx;\n \n         // Find the relevant variant\n-        let def = lookup_full_def(tcx, path.span, expr.id);\n+        let def = tcx.expect_def(expr.id);\n         if def == Def::Err {\n             self.set_tainted_by_errors();\n             self.check_struct_fields_on_error(expr.id, fields, base_expr);\n@@ -3350,18 +3345,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   self.to_ty(&qself.ty)\n               });\n \n-              let path_res = if let Some(&d) = tcx.def_map.borrow().get(&id) {\n-                  d\n-              } else if let Some(hir::QSelf { position: 0, .. }) = *maybe_qself {\n-                    // Create some fake resolution that can't possibly be a type.\n-                    def::PathResolution {\n-                        base_def: Def::Mod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n-                        depth: path.segments.len()\n-                    }\n-                } else {\n-                  span_bug!(expr.span, \"unbound path {:?}\", expr)\n-              };\n-\n+              let path_res = tcx.expect_resolution(id);\n               if let Some((opt_ty, segments, def)) =\n                       self.resolve_ty_and_def_ufcs(path_res, opt_self_ty, path,\n                                                    expr.span, expr.id) {\n@@ -3752,10 +3736,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if let Some(def) = def {\n                 // Write back the new resolution.\n-                self.tcx().def_map.borrow_mut().insert(node_id, def::PathResolution {\n-                    base_def: def,\n-                    depth: 0,\n-                });\n+                self.tcx().def_map.borrow_mut().insert(node_id, def::PathResolution::new(def));\n                 Some((Some(ty), slice::ref_slice(item_segment), def))\n             } else {\n                 self.write_error(node_id);\n@@ -3800,11 +3781,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        let pcx = PatCtxt {\n-            fcx: self,\n-            map: pat_id_map(&local.pat),\n-        };\n-        pcx.check_pat(&local.pat, t);\n+        self.check_pat(&local.pat, t);\n         let pat_ty = self.node_ty(local.pat.id);\n         if pat_ty.references_error() {\n             self.write_ty(local.id, pat_ty);\n@@ -4562,7 +4539,7 @@ pub fn may_break(tcx: TyCtxt, id: ast::NodeId, b: &hir::Block) -> bool {\n     // <id> nested anywhere inside the loop?\n     (block_query(b, |e| {\n         if let hir::ExprBreak(Some(_)) = e.node {\n-            lookup_full_def(tcx, e.span, e.id) == Def::Label(id)\n+            tcx.expect_def(e.id) == Def::Label(id)\n         } else {\n             false\n         }"}, {"sha": "586c4f5c1858de3973ad5d519da0acdb246f9775", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -532,17 +532,13 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       -> bool\n {\n     if let hir::TyPath(None, _) = ast_ty.node {\n-        let path_res = *tcx.def_map.borrow().get(&ast_ty.id).unwrap();\n+        let path_res = tcx.expect_resolution(ast_ty.id);\n         match path_res.base_def {\n-            Def::SelfTy(Some(def_id), None) => {\n-                path_res.depth == 0 && def_id == tcx.map.local_def_id(param_id)\n-            }\n-            Def::TyParam(_, _, def_id, _) => {\n-                path_res.depth == 0 && def_id == tcx.map.local_def_id(param_id)\n-            }\n-            _ => {\n-                false\n+            Def::SelfTy(Some(def_id), None) |\n+            Def::TyParam(_, _, def_id, _) if path_res.depth == 0 => {\n+                def_id == tcx.map.local_def_id(param_id)\n             }\n+            _ => false\n         }\n     } else {\n         false\n@@ -1719,7 +1715,7 @@ fn add_unsized_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     match unbound {\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n-            let trait_def_id = tcx.trait_ref_to_def_id(tpb);\n+            let trait_def_id = tcx.expect_def(tpb.ref_id).def_id();\n             match kind_id {\n                 Ok(kind_id) if trait_def_id != kind_id => {\n                     tcx.sess.span_warn(span,"}, {"sha": "7017cb9f6a22b0b61b27e5f371616edd6523b0f9", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -4125,7 +4125,7 @@ register_diagnostics! {\n //  E0239, // `next` method of `Iterator` trait has unexpected type\n //  E0240,\n //  E0241,\n-    E0242, // internal error looking up a definition\n+//  E0242,\n     E0245, // not a trait\n //  E0246, // invalid recursive type\n //  E0247,"}, {"sha": "c6c575719c0158b2d8889a4da4eb2477780dea3b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -103,7 +103,6 @@ pub use rustc::util;\n \n use dep_graph::DepNode;\n use hir::map as hir_map;\n-use hir::def::Def;\n use rustc::infer::TypeOrigin;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -176,15 +175,6 @@ fn write_substs_to_tcx<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn lookup_full_def(tcx: TyCtxt, sp: Span, id: ast::NodeId) -> Def {\n-    match tcx.def_map.borrow().get(&id) {\n-        Some(x) => x.full_def(),\n-        None => {\n-            span_fatal!(tcx.sess, sp, E0242, \"internal error looking up a definition\")\n-        }\n-    }\n-}\n-\n fn require_c_abi_if_variadic(tcx: TyCtxt,\n                              decl: &hir::FnDecl,\n                              abi: Abi,"}, {"sha": "e49b96cbfd02ef9e98f0f539c9fc9ec62081d305", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -50,8 +50,8 @@ pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Name>)\n         Some(tcx) => tcx,\n         None => return None,\n     };\n-    let def = match tcx.def_map.borrow().get(&id) {\n-        Some(d) => d.full_def(),\n+    let def = match tcx.expect_def_or_none(id) {\n+        Some(def) => def,\n         None => return None,\n     };\n     let did = def.def_id();"}, {"sha": "14ca63403163c85c0fb258dc875a6ad47c0e3560", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -2631,7 +2631,7 @@ fn resolve_type(cx: &DocContext,\n             };\n         }\n     };\n-    let def = tcx.def_map.borrow().get(&id).expect(\"unresolved id not in defmap\").full_def();\n+    let def = tcx.expect_def(id);\n     debug!(\"resolve_type: def={:?}\", def);\n \n     let is_generic = match def {\n@@ -2700,7 +2700,7 @@ fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSou\n \n fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<DefId> {\n     cx.tcx_opt().and_then(|tcx| {\n-        tcx.def_map.borrow().get(&id).map(|d| register_def(cx, d.full_def()))\n+        tcx.expect_def_or_none(id).map(|def| register_def(cx, def))\n     })\n }\n "}, {"sha": "c7b571c2d1911438e3b33b647dceb0b6cf8b50d9", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -241,7 +241,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Some(tcx) => tcx,\n             None => return false\n         };\n-        let def = tcx.def_map.borrow()[&id];\n+        let def = tcx.expect_def(id);\n         let def_did = def.def_id();\n \n         let use_attrs = tcx.map.attrs(id).clean(self.cx);\n@@ -251,10 +251,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // reachable in documentation - a previously nonreachable item can be\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront)\n-        if !def.def_id().is_local() && !is_no_inline {\n+        if !def_did.is_local() && !is_no_inline {\n             let attrs = clean::inline::load_attrs(self.cx, tcx, def_did);\n             let self_is_hidden = attrs.list(\"doc\").has_word(\"hidden\");\n-            match def.base_def {\n+            match def {\n                 Def::Trait(did) |\n                 Def::Struct(did) |\n                 Def::Enum(did) |"}, {"sha": "4245786295b343fa14df160e11f5d447a65483be", "filename": "src/test/compile-fail-fulldeps/issue-18986.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -15,6 +15,7 @@ pub use use_from_trait_xc::Trait;\n \n fn main() {\n     match () {\n-        Trait { x: 42 } => () //~ ERROR `Trait` does not name a struct\n+        Trait { x: 42 } => () //~ ERROR expected variant, struct or type alias, found trait `Trait`\n+        //~^ ERROR `Trait` does not name a struct or a struct variant\n     }\n }"}, {"sha": "6ebe80b5701b9dbcb090da8e330833df9f6cd88f", "filename": "src/test/compile-fail/associated-const-private-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fassociated-const-private-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fassociated-const-private-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-private-impl.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -23,5 +23,5 @@ mod bar1 {\n \n fn main() {\n     assert_eq!(1, bar1::Foo::ID);\n-    //~^ERROR associated const `ID` is private\n+    //~^ERROR associated constant `ID` is private\n }"}, {"sha": "f57727b773d635a87608b4e4e08a4233d1408c6f", "filename": "src/test/compile-fail/blind-item-block-middle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblind-item-block-middle.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -12,6 +12,6 @@ mod foo { pub struct bar; }\n \n fn main() {\n     let bar = 5;\n-    //~^ ERROR cannot be named the same\n+    //~^ ERROR let bindings cannot shadow structs\n     use foo::bar;\n }"}, {"sha": "75b6397f4ebd71ac5c7260acb3c93b57179aa481", "filename": "src/test/compile-fail/const-pattern-irrefutable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -19,10 +19,10 @@ use foo::d; //~ NOTE is imported here\n const a: u8 = 2; //~ NOTE is defined here\n \n fn main() {\n-    let a = 4; //~ ERROR let variables cannot\n-               //~^ NOTE cannot be named the same as a const variable\n-    let c = 4; //~ ERROR let variables cannot\n-               //~^ NOTE cannot be named the same as a const variable\n-    let d = 4; //~ ERROR let variables cannot\n-               //~^ NOTE cannot be named the same as a const variable\n+    let a = 4; //~ ERROR let bindings cannot shadow constants\n+               //~^ NOTE cannot be named the same as a constant\n+    let c = 4; //~ ERROR let bindings cannot shadow constants\n+               //~^ NOTE cannot be named the same as a constant\n+    let d = 4; //~ ERROR let bindings cannot shadow constants\n+               //~^ NOTE cannot be named the same as a constant\n }"}, {"sha": "0522a654a8528200a661fda6393ce0e836675e9e", "filename": "src/test/compile-fail/empty-struct-braces-pat-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -29,9 +29,9 @@ fn main() {\n     //     XEmpty1() => () // ERROR unresolved enum variant, struct or const `XEmpty1`\n     // }\n     match e1 {\n-        Empty1(..) => () //~ ERROR unresolved enum variant, struct or const `Empty1`\n+        Empty1(..) => () //~ ERROR unresolved variant or struct `Empty1`\n     }\n     match xe1 {\n-        XEmpty1(..) => () //~ ERROR unresolved enum variant, struct or const `XEmpty1`\n+        XEmpty1(..) => () //~ ERROR unresolved variant or struct `XEmpty1`\n     }\n }"}, {"sha": "e89b08a8a06510fd63a0f2adf7363f5bb0719e1e", "filename": "src/test/compile-fail/enum-in-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fenum-in-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fenum-in-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-in-scope.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -11,5 +11,5 @@\n struct hello(isize);\n \n fn main() {\n-    let hello = 0; //~ERROR cannot be named the same\n+    let hello = 0; //~ERROR let bindings cannot shadow structs\n }"}, {"sha": "c847366a707a7e9cb933460749c826e512fffdfb", "filename": "src/test/compile-fail/enums-pats-not-idents.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fenums-pats-not-idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fenums-pats-not-idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenums-pats-not-idents.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//error-pattern:unresolved enum variant\n-\n fn main() {\n-    // a bug in the parser is allowing this:\n-    let a(1) = 13;\n+    let a(1) = 13; //~ ERROR unresolved variant or struct `a`\n }"}, {"sha": "9eec8487a50874cad88672d256b0fe5dd8c33a6e", "filename": "src/test/compile-fail/issue-10200.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-10200.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-10200.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10200.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -13,7 +13,7 @@ fn foo(_: usize) -> Foo { Foo(false) }\n \n fn main() {\n     match Foo(true) {\n-        foo(x) //~ ERROR `foo` is not an enum variant, struct or const\n+        foo(x) //~ ERROR expected variant or struct, found function `foo`\n         => ()\n     }\n }"}, {"sha": "7912410f69ea1f8d90d8647f951fe8667fccd245", "filename": "src/test/compile-fail/issue-12863.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-12863.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-12863.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12863.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -12,6 +12,6 @@ mod foo { pub fn bar() {} }\n \n fn main() {\n     match () {\n-        foo::bar => {} //~ ERROR `bar` is not an enum variant, struct or const\n+        foo::bar => {} //~ ERROR expected variant, struct or constant, found function `bar`\n     }\n }"}, {"sha": "60117bd88d46ad2b6e1a2323bd536bd40a2b8638", "filename": "src/test/compile-fail/issue-16149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -15,7 +15,7 @@ extern {\n fn main() {\n     let boolValue = match 42 {\n         externalValue => true,\n-        //~^ ERROR static variables cannot be referenced in a pattern\n+        //~^ ERROR match bindings cannot shadow statics\n         _ => false\n     };\n }"}, {"sha": "db43c1cce9947fa348602ea021e5ccf204575760", "filename": "src/test/compile-fail/issue-17405.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -14,6 +14,7 @@ enum Foo {\n \n fn main() {\n     match Foo::Bar(1) {\n-        Foo { i } => () //~ ERROR `Foo` does not name a struct or a struct variant\n+        Foo { i } => () //~ ERROR expected variant, struct or type alias, found enum `Foo`\n+        //~^ ERROR `Foo` does not name a struct or a struct variant\n     }\n }"}, {"sha": "523a387956a32e7e93b4f6175e588c6ce0d14b08", "filename": "src/test/compile-fail/issue-17718-const-privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-privacy.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -12,10 +12,10 @@\n \n extern crate issue_17718_const_privacy as other;\n \n-use a::B; //~ ERROR: const `B` is private\n+use a::B; //~ ERROR: constant `B` is private\n use other::{\n     FOO,\n-    BAR, //~ ERROR: const `BAR` is private\n+    BAR, //~ ERROR: constant `BAR` is private\n     FOO2,\n };\n "}, {"sha": "b9f5e98b6faa97d112d935888a800e068d25f54e", "filename": "src/test/compile-fail/issue-17718-patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-17718-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-17718-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-patterns.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -14,8 +14,8 @@ const A3: usize = 1;\n \n fn main() {\n     match 1 {\n-        A1 => {} //~ ERROR: static variables cannot be referenced in a pattern\n-        A2 => {} //~ ERROR: static variables cannot be referenced in a pattern\n+        A1 => {} //~ ERROR: match bindings cannot shadow statics\n+        A2 => {} //~ ERROR: match bindings cannot shadow statics\n         A3 => {}\n         _ => {}\n     }"}, {"sha": "2313a3fe9c6d518190355db24b1a721b03b42654", "filename": "src/test/compile-fail/issue-17933.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-17933.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-17933.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17933.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -13,7 +13,7 @@ pub static X: usize = 1;\n fn main() {\n     match 1 {\n         self::X => { },\n-        //~^ ERROR static variables cannot be referenced in a pattern, use a `const` instead\n+        //~^ ERROR expected variant, struct or constant, found static `X`\n         _       => { },\n     }\n }"}, {"sha": "5cf80dd172a3de7538ef5a863396dd466c5e0903", "filename": "src/test/compile-fail/issue-23716.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -9,21 +9,21 @@\n // except according to those terms.\n \n static foo: i32 = 0;\n-//~^ NOTE static variable defined here\n+//~^ NOTE a static `foo` is defined here\n \n fn bar(foo: i32) {}\n-//~^ ERROR static variables cannot be referenced in a pattern, use a `const` instead\n-//~| static variable used in pattern\n+//~^ ERROR function parameters cannot shadow statics\n+//~| cannot be named the same as a static\n \n mod submod {\n     pub static answer: i32 = 42;\n }\n \n use self::submod::answer;\n-//~^ NOTE static variable imported here\n+//~^ NOTE a static `answer` is imported here\n \n fn question(answer: i32) {}\n-//~^ ERROR static variables cannot be referenced in a pattern, use a `const` instead\n-//~| static variable used in pattern\n+//~^ ERROR function parameters cannot shadow statics\n+//~| cannot be named the same as a static\n fn main() {\n }"}, {"sha": "6cadbef33e7f0b4f9eb555b9d7425a9f8f9a2166", "filename": "src/test/compile-fail/issue-26459.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -11,6 +11,7 @@\n fn main() {\n     match 'a' {\n         char{ch} => true\n-        //~^ ERROR `char` does not name a struct or a struct variant\n+        //~^ ERROR expected variant, struct or type alias, found builtin type `char`\n+        //~| ERROR `char` does not name a struct or a struct variant\n     };\n }"}, {"sha": "2a015adb498e17780c4046056e0d75c7a1925106", "filename": "src/test/compile-fail/issue-27033.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-27033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-27033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27033.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -10,11 +10,11 @@\n \n fn main() {\n     match Some(1) {\n-        None @ _ => {} //~ ERROR cannot be named the same\n+        None @ _ => {} //~ ERROR match bindings cannot shadow variants\n     };\n     const C: u8 = 1;\n     match 1 {\n-        C @ 2 => { //~ ERROR cannot be named the same\n+        C @ 2 => { //~ ERROR match bindings cannot shadow constant\n             println!(\"{}\", C);\n         }\n         _ => {}"}, {"sha": "d2f9abd2e316b41539d235ebaaa6599f01cb5049", "filename": "src/test/compile-fail/issue-27815.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -14,7 +14,9 @@ fn main() {\n     let u = A { x: 1 }; //~ ERROR `A` does not name a structure\n     let v = u32 { x: 1 }; //~ ERROR `u32` does not name a structure\n     match () {\n-        A { x: 1 } => {} //~ ERROR `A` does not name a struct\n-        u32 { x: 1 } => {} //~ ERROR `u32` does not name a struct\n+        A { x: 1 } => {} //~ ERROR expected variant, struct or type alias, found module `A`\n+        //~^ ERROR `A` does not name a struct or a struct variant\n+        u32 { x: 1 } => {} //~ ERROR expected variant, struct or type alias, found builtin type `u32\n+        //~^ ERROR `u32` does not name a struct or a struct variant\n     }\n }"}, {"sha": "e492d48fdaf0f041f65109bbe4d8f64f661238f1", "filename": "src/test/compile-fail/issue-28992-empty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -21,6 +21,6 @@ impl S {\n }\n \n fn main() {\n-    if let C1(..) = 0 {} //~ ERROR `C1` does not name a tuple variant or a tuple struct\n+    if let C1(..) = 0 {} //~ ERROR expected variant or struct, found constant `C1`\n     if let S::C2(..) = 0 {} //~ ERROR `S::C2` does not name a tuple variant or a tuple struct\n }"}, {"sha": "926f58198dfae4b15f76047d1001ba3f466a570b", "filename": "src/test/compile-fail/issue-32086.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-32086.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-32086.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32086.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S(u8);\n+const C: S = S(10);\n+\n+fn main() {\n+    let C(a) = S(11); //~ ERROR expected variant or struct, found constant `C`\n+    let C(..) = S(11); //~ ERROR expected variant or struct, found constant `C`\n+}"}, {"sha": "630694d91561d8fdb274fd5e937fac8ba9c871fe", "filename": "src/test/compile-fail/issue-34047.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-34047.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-34047.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-34047.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const C: u8 = 0; //~ NOTE a constant `C` is defined here\n+\n+fn main() {\n+    match 1u8 {\n+        mut C => {} //~ ERROR match bindings cannot shadow constants\n+        //~^ NOTE cannot be named the same as a constant\n+        _ => {}\n+    }\n+}"}, {"sha": "3a8ff12429ab374fc0d36f5376a374a63b48b958", "filename": "src/test/compile-fail/issue-5927.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5927.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -11,7 +11,7 @@\n \n fn main() {\n     let z = match 3 {\n-        x(1) => x(1) //~ ERROR unresolved enum variant\n+        x(1) => x(1) //~ ERROR unresolved variant or struct `x`\n         //~^ ERROR unresolved name `x`\n     };\n     assert!(z == 3);"}, {"sha": "1cba64ccf2cde48a7886c2c9b8a3560c5ba61414", "filename": "src/test/compile-fail/method-resolvable-path-in-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -19,6 +19,6 @@ impl MyTrait for Foo {}\n fn main() {\n     match 0u32 {\n         <Foo as MyTrait>::trait_bar => {}\n-        //~^ ERROR `trait_bar` is not an associated const\n+        //~^ ERROR expected associated constant, found method `trait_bar`\n     }\n }"}, {"sha": "2e2d53c4d40b6400854c1bcc3c15a1296f06ffdb", "filename": "src/test/compile-fail/name-clash-nullary.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fname-clash-nullary.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:cannot be named the same\n use std::option::*;\n \n fn main() {\n-  let None: isize = 42;\n+  let None: isize = 42; //~ ERROR let bindings cannot shadow variants\n   log(debug, None);\n+  //~^ ERROR unresolved name `debug`\n+  //~| ERROR unresolved name `log`\n }"}, {"sha": "f1683e51c648d2b0b069262794984c2c0b0cab43", "filename": "src/test/compile-fail/pat-shadow-in-nested-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fpat-shadow-in-nested-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fpat-shadow-in-nested-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-shadow-in-nested-binding.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -11,5 +11,5 @@\n struct foo(usize);\n \n fn main() {\n-    let (foo, _) = (2, 3); //~ ERROR `foo` cannot be named the same as\n+    let (foo, _) = (2, 3); //~ ERROR let bindings cannot shadow structs\n }"}, {"sha": "86873022f0ff10b666941c3cd86cdefcac106ffa", "filename": "src/test/compile-fail/qualified-path-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -27,7 +27,7 @@ impl S {\n \n fn main() {\n     match 10 {\n-        <S as Tr>::A::f::<u8> => {} //~ ERROR `f` is not an associated const\n+        <S as Tr>::A::f::<u8> => {} //~ ERROR associated items in match patterns must be constants\n         0 ... <S as Tr>::A::f::<u8> => {} //~ ERROR only char and numeric types are allowed in range\n     }\n }"}, {"sha": "351a47fdf3923191d85505cd034f57f8eaf41ff6", "filename": "src/test/compile-fail/static-mut-not-pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -20,7 +20,7 @@ fn main() {\n     // instead of spitting out a custom error about some identifier collisions\n     // (we should allow shadowing)\n     match 4 {\n-        a => {} //~ ERROR static variables cannot be referenced in a pattern\n+        a => {} //~ ERROR match bindings cannot shadow statics\n         _ => {}\n     }\n }\n@@ -44,7 +44,7 @@ fn mutable_statics() {\n     match (Foo { bar: Some(Direction::North), baz: NewBool(true) }) {\n         Foo { bar: None, baz: NewBool(true) } => (),\n         STATIC_MUT_FOO => (),\n-        //~^ ERROR static variables cannot be referenced in a pattern\n+        //~^ ERROR match bindings cannot shadow statics\n         Foo { bar: Some(Direction::South), .. } => (),\n         Foo { bar: Some(EAST), .. } => (),\n         Foo { bar: Some(Direction::North), baz: NewBool(true) } => (),"}, {"sha": "1fe8f6294da2118c0e9506de421aeca10f5a0579", "filename": "src/test/compile-fail/trait-impl-for-module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Ftrait-impl-for-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Fcompile-fail%2Ftrait-impl-for-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-for-module.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -14,7 +14,7 @@ mod a {\n trait A {\n }\n \n-impl A for a { //~ ERROR type name `a` is undefined or not in scope\n+impl A for a { //~ ERROR expected type, found module\n }\n \n fn main() {"}, {"sha": "169a87f0b12fcb654d99292247afad4bb86806dc", "filename": "src/test/run-pass/issue-34074.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Frun-pass%2Fissue-34074.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2f75a953b5645d3a336b2978b48b60d310bf54/src%2Ftest%2Frun-pass%2Fissue-34074.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-34074.rs?ref=7d2f75a953b5645d3a336b2978b48b60d310bf54", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure several unnamed function arguments don't conflict with each other\n+\n+trait Tr {\n+    fn f(u8, u8) {}\n+}\n+\n+fn main() {\n+}"}]}