{"sha": "b5c4244c6c46df22bb55531b629f4c314fe2ab22", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YzQyNDRjNmM0NmRmMjJiYjU1NTMxYjYyOWY0YzMxNGZlMmFiMjI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-28T23:30:53Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T15:07:59Z"}, "message": "rustc: introduce a query system for type information in ty::maps.", "tree": {"sha": "a67d04b3f7845cee86ff188b55328b64e2e0a71b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a67d04b3f7845cee86ff188b55328b64e2e0a71b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5c4244c6c46df22bb55531b629f4c314fe2ab22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5c4244c6c46df22bb55531b629f4c314fe2ab22", "html_url": "https://github.com/rust-lang/rust/commit/b5c4244c6c46df22bb55531b629f4c314fe2ab22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5c4244c6c46df22bb55531b629f4c314fe2ab22/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc8a3a93b70f6805e235199029c3948515f99226", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc8a3a93b70f6805e235199029c3948515f99226", "html_url": "https://github.com/rust-lang/rust/commit/cc8a3a93b70f6805e235199029c3948515f99226"}], "stats": {"total": 726, "additions": 333, "deletions": 393}, "files": [{"sha": "bfcaf1e00f06eca5d4428137b6fac46eacc522dd", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -525,7 +525,7 @@ impl<'a> LoweringContext<'a> {\n                         return n;\n                     }\n                     assert!(!def_id.is_local());\n-                    let n = self.sess.cstore.item_generics(def_id).regions.len();\n+                    let n = self.sess.cstore.item_generics_cloned(def_id).regions.len();\n                     self.type_def_lifetime_params.insert(def_id, n);\n                     n\n                 });"}, {"sha": "cb5ced57bd8b915e83f98d70055e3f555511f0d6", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 24, "deletions": 58, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -28,12 +28,12 @@ use hir::map as hir_map;\n use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData};\n use hir::svh::Svh;\n use middle::lang_items;\n-use ty::{self, Ty, TyCtxt};\n-use mir::Mir;\n+use ty::{self, TyCtxt};\n use session::Session;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n \n+use std::any::Any;\n use std::collections::BTreeMap;\n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -163,46 +163,31 @@ pub struct ExternCrate {\n \n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n-pub trait CrateStore<'tcx> {\n+pub trait CrateStore {\n+    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>;\n+\n     // item info\n     fn describe_def(&self, def: DefId) -> Option<Def>;\n     fn def_span(&self, sess: &Session, def: DefId) -> Span;\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n-    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind;\n-    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                      -> ty::ClosureTy<'tcx>;\n-    fn item_variances(&self, def: DefId) -> Vec<ty::Variance>;\n-    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                     -> Ty<'tcx>;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>>;\n-    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> ty::GenericPredicates<'tcx>;\n-    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                 -> ty::GenericPredicates<'tcx>;\n-    fn item_generics(&self, def: DefId) -> ty::Generics;\n+    fn item_generics_cloned(&self, def: DefId) -> ty::Generics;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef;\n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef;\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n \n     // impl info\n-    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId>;\n-    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                          -> Option<ty::TraitRef<'tcx>>;\n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity;\n-    fn custom_coerce_unsized_kind(&self, def: DefId)\n-                                  -> Option<ty::adjustment::CustomCoerceUnsized>;\n     fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId>;\n-    fn associated_item(&self, def: DefId) -> Option<ty::AssociatedItem>;\n+    fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem;\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n@@ -252,12 +237,11 @@ pub trait CrateStore<'tcx> {\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n \n     // misc. metadata\n-    fn maybe_get_item_body<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                               -> Option<&'tcx hir::Body>;\n+    fn maybe_get_item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                                     -> Option<&'tcx hir::Body>;\n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body>;\n     fn const_is_rvalue_promotable_to_static(&self, def: DefId) -> bool;\n \n-    fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n \n     // This is basically a 1-based range of ints, which is a little\n@@ -272,10 +256,10 @@ pub trait CrateStore<'tcx> {\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>;\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n-    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           reexports: &def::ExportMap,\n-                           link_meta: &LinkMeta,\n-                           reachable: &NodeSet) -> Vec<u8>;\n+    fn encode_metadata<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 reexports: &def::ExportMap,\n+                                 link_meta: &LinkMeta,\n+                                 reachable: &NodeSet) -> Vec<u8>;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -309,53 +293,37 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n /// A dummy crate store that does not support any non-local crates,\n /// for test purposes.\n pub struct DummyCrateStore;\n+\n #[allow(unused_variables)]\n-impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n+impl CrateStore for DummyCrateStore {\n+    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>\n+        { bug!(\"crate_data_as_rc_any\") }\n     // item info\n     fn describe_def(&self, def: DefId) -> Option<Def> { bug!(\"describe_def\") }\n     fn def_span(&self, sess: &Session, def: DefId) -> Span { bug!(\"def_span\") }\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n     fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n-    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind { bug!(\"closure_kind\") }\n-    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                      -> ty::ClosureTy<'tcx>  { bug!(\"closure_ty\") }\n-    fn item_variances(&self, def: DefId) -> Vec<ty::Variance> { bug!(\"item_variances\") }\n-    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                     -> Ty<'tcx> { bug!(\"item_type\") }\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>> {\n         bug!(\"visible_parent_map\")\n     }\n-    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n-    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                 -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n-    fn item_generics(&self, def: DefId) -> ty::Generics { bug!(\"item_generics\") }\n+    fn item_generics_cloned(&self, def: DefId) -> ty::Generics\n+        { bug!(\"item_generics_cloned\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef\n-        { bug!(\"trait_def\") }\n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef\n-        { bug!(\"adt_def\") }\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name> { bug!(\"fn_arg_names\") }\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info\n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }\n \n     // impl info\n-    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId>\n-        { bug!(\"associated_items\") }\n-    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                          -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity { bug!(\"impl_polarity\") }\n-    fn custom_coerce_unsized_kind(&self, def: DefId)\n-                                  -> Option<ty::adjustment::CustomCoerceUnsized>\n-        { bug!(\"custom_coerce_unsized_kind\") }\n     fn impl_parent(&self, def: DefId) -> Option<DefId> { bug!(\"impl_parent\") }\n \n     // trait/impl-item info\n     fn trait_of_item(&self, def_id: DefId) -> Option<DefId> { bug!(\"trait_of_item\") }\n-    fn associated_item(&self, def: DefId) -> Option<ty::AssociatedItem> { bug!(\"associated_item\") }\n+    fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem\n+        { bug!(\"associated_item_cloned\") }\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n@@ -418,8 +386,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro { bug!(\"load_macro\") }\n \n     // misc. metadata\n-    fn maybe_get_item_body<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                               -> Option<&'tcx hir::Body> {\n+    fn maybe_get_item_body<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                                     -> Option<&'tcx hir::Body> {\n         bug!(\"maybe_get_item_body\")\n     }\n     fn item_body_nested_bodies(&self, def: DefId) -> BTreeMap<hir::BodyId, hir::Body> {\n@@ -429,8 +397,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         bug!(\"const_is_rvalue_promotable_to_static\")\n     }\n \n-    fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                        -> Mir<'tcx> { bug!(\"get_item_mir\") }\n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         bug!(\"is_item_mir_available\")\n     }\n@@ -448,7 +414,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         { vec![] }\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n-    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn encode_metadata<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n                            reachable: &NodeSet) -> Vec<u8> { vec![] }"}, {"sha": "37749816eb153c725300a0eddba7f66cdc21b917", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -995,7 +995,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else {\n                 let cstore = &self.sess.cstore;\n                 self.xcrate_object_lifetime_defaults.entry(def_id).or_insert_with(|| {\n-                    cstore.item_generics(def_id).types.into_iter().map(|def| {\n+                    cstore.item_generics_cloned(def_id).types.into_iter().map(|def| {\n                         def.object_lifetime_default\n                     }).collect()\n                 })"}, {"sha": "baa22d706143519e6b20605b77d4bfebe2f399a7", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -433,23 +433,27 @@ struct Checker<'a, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // (See issue #38412)\n-    fn skip_stability_check_due_to_privacy(self, def_id: DefId) -> bool {\n-        let visibility = {\n-            // Check if `def_id` is a trait method.\n-            match self.sess.cstore.associated_item(def_id) {\n-                Some(ty::AssociatedItem { container: ty::TraitContainer(trait_def_id), .. }) => {\n-                    // Trait methods do not declare visibility (even\n-                    // for visibility info in cstore). Use containing\n-                    // trait instead, so methods of pub traits are\n-                    // themselves considered pub.\n-                    self.sess.cstore.visibility(trait_def_id)\n-                }\n-                _ => {\n-                    // Otherwise, cstore info works directly.\n-                    self.sess.cstore.visibility(def_id)\n+    fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n+        // Check if `def_id` is a trait method.\n+        match self.sess.cstore.describe_def(def_id) {\n+            Some(Def::Method(_)) |\n+            Some(Def::AssociatedTy(_)) |\n+            Some(Def::AssociatedConst(_)) => {\n+                match self.associated_item(def_id).container {\n+                    ty::TraitContainer(trait_def_id) => {\n+                        // Trait methods do not declare visibility (even\n+                        // for visibility info in cstore). Use containing\n+                        // trait instead, so methods of pub traits are\n+                        // themselves considered pub.\n+                        def_id = trait_def_id;\n+                    }\n+                    _ => {}\n                 }\n             }\n-        };\n+            _ => {}\n+        }\n+\n+        let visibility = self.sess.cstore.visibility(def_id);\n \n         match visibility {\n             // must check stability for pub items."}, {"sha": "3ba82f34c3266a804fece8554e94707fb562c796", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -64,7 +64,7 @@ pub struct Session {\n     pub target: config::Config,\n     pub host: Target,\n     pub opts: config::Options,\n-    pub cstore: Rc<for<'a> CrateStore<'a>>,\n+    pub cstore: Rc<CrateStore>,\n     pub parse_sess: ParseSess,\n     // For a library crate, this is always none\n     pub entry_fn: RefCell<Option<(NodeId, Span)>>,\n@@ -510,7 +510,7 @@ pub fn build_session(sopts: config::Options,\n                      dep_graph: &DepGraph,\n                      local_crate_source_file: Option<PathBuf>,\n                      registry: errors::registry::Registry,\n-                     cstore: Rc<for<'a> CrateStore<'a>>)\n+                     cstore: Rc<CrateStore>)\n                      -> Session {\n     build_session_with_codemap(sopts,\n                                dep_graph,\n@@ -525,7 +525,7 @@ pub fn build_session_with_codemap(sopts: config::Options,\n                                   dep_graph: &DepGraph,\n                                   local_crate_source_file: Option<PathBuf>,\n                                   registry: errors::registry::Registry,\n-                                  cstore: Rc<for<'a> CrateStore<'a>>,\n+                                  cstore: Rc<CrateStore>,\n                                   codemap: Rc<codemap::CodeMap>,\n                                   emitter_dest: Option<Box<Write + Send>>)\n                                   -> Session {\n@@ -575,7 +575,7 @@ pub fn build_session_(sopts: config::Options,\n                       local_crate_source_file: Option<PathBuf>,\n                       span_diagnostic: errors::Handler,\n                       codemap: Rc<codemap::CodeMap>,\n-                      cstore: Rc<for<'a> CrateStore<'a>>)\n+                      cstore: Rc<CrateStore>)\n                       -> Session {\n     let host = match Target::search(config::host_triple()) {\n         Ok(t) => t,"}, {"sha": "c31ab2372b69ce420964601e2361ff199fc97f0e", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -155,7 +155,7 @@ impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n                       -> Option<Vec<PredicateObligation<'tcx>>> {\n         if let ty::TyAnon(def_id, substs) = self.predicate.skip_binder().self_ty().sty {\n             let ty = if def_id.is_local() {\n-                tcx.maps.types.borrow().get(&def_id).cloned()\n+                tcx.maps.ty.borrow().get(&def_id).cloned()\n             } else {\n                 Some(tcx.item_type(def_id))\n             };"}, {"sha": "62aa6522a7bdcf1bb74775c2f6eebe14dc6121d4", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -44,6 +44,7 @@ use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n use arena::{TypedArena, DroplessArena};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell};\n use std::hash::{Hash, Hasher};\n@@ -220,7 +221,7 @@ pub struct TypeckTables<'tcx> {\n     /// Records the type of each closure.\n     pub closure_tys: NodeMap<ty::ClosureTy<'tcx>>,\n \n-    /// Records the type of each closure.\n+    /// Records the kind of each closure.\n     pub closure_kinds: NodeMap<ty::ClosureKind>,\n \n     /// For each fn, records the \"liberated\" types of its arguments\n@@ -389,15 +390,15 @@ pub struct GlobalCtxt<'tcx> {\n     global_arenas: &'tcx GlobalArenas<'tcx>,\n     global_interners: CtxtInterners<'tcx>,\n \n+    pub sess: &'tcx Session,\n+\n     pub specializes_cache: RefCell<traits::SpecializesCache>,\n \n     pub dep_graph: DepGraph,\n \n     /// Common types, pre-interned for your convenience.\n     pub types: CommonTypes<'tcx>,\n \n-    pub sess: &'tcx Session,\n-\n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n     pub trait_map: TraitMap,\n@@ -659,6 +660,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n+                                  local_providers: ty::maps::Providers<'tcx>,\n+                                  extern_providers: ty::maps::Providers<'tcx>,\n                                   arenas: &'tcx GlobalArenas<'tcx>,\n                                   arena: &'tcx DroplessArena,\n                                   resolutions: ty::Resolutions,\n@@ -676,7 +679,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let common_types = CommonTypes::new(&interners);\n         let dep_graph = hir.dep_graph.clone();\n         let fulfilled_predicates = traits::GlobalFulfilledPredicates::new(dep_graph.clone());\n+        let max_cnum = s.cstore.crates().iter().map(|c| c.as_usize()).max().unwrap_or(0);\n+        let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n+        providers[LOCAL_CRATE] = local_providers;\n         tls::enter_global(GlobalCtxt {\n+            sess: s,\n             specializes_cache: RefCell::new(traits::SpecializesCache::new()),\n             global_arenas: arenas,\n             global_interners: interners,\n@@ -686,11 +693,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             region_maps: region_maps,\n             free_region_maps: RefCell::new(FxHashMap()),\n             variance_computed: Cell::new(false),\n-            sess: s,\n             trait_map: resolutions.trait_map,\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             hir: hir,\n-            maps: maps::Maps::new(dep_graph),\n+            maps: maps::Maps::new(dep_graph, providers),\n             freevars: RefCell::new(resolutions.freevars),\n             maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n             rcache: RefCell::new(FxHashMap()),"}, {"sha": "7bf1ba155b53511964c7e95edfc2e755e190a1e3", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         } else {\n             // for local crates, check whether type info is\n             // available; typeck might not have completed yet\n-            self.maps.impl_trait_refs.borrow().contains_key(&impl_def_id)\n+            self.maps.impl_trait_ref.borrow().contains_key(&impl_def_id)\n         };\n \n         if !use_types {"}, {"sha": "4a91cdd24fcaa99b237aef8715f446797b4af082", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 88, "deletions": 31, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -9,49 +9,102 @@\n // except according to those terms.\n \n use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n-use hir::def_id::DefId;\n+use hir::def_id::{CrateNum, DefId};\n use middle::const_val::ConstVal;\n-use ty::{self, Ty};\n+use mir;\n+use ty::{self, Ty, TyCtxt};\n+use util::common::MemoizationMap;\n use util::nodemap::DefIdSet;\n \n+use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::RefCell;\n-use std::marker::PhantomData;\n use std::rc::Rc;\n use syntax::attr;\n \n+trait Key {\n+    fn map_crate(&self) -> CrateNum;\n+}\n+\n+impl Key for DefId {\n+    fn map_crate(&self) -> CrateNum {\n+        self.krate\n+    }\n+}\n+\n macro_rules! define_maps {\n-    ($($(#[$attr:meta])* pub $field:ident: $node_name:ident($key:ty) -> $value:ty),*) => {\n-        pub struct Maps<'tcx> {\n-            $($(#[$attr])* pub $field: RefCell<DepTrackingMap<$field<'tcx>>>),*\n+    (<$tcx:tt>\n+     $($(#[$attr:meta])*\n+       pub $name:ident: $node:ident($K:ty) -> $V:ty),*) => {\n+        pub struct Maps<$tcx> {\n+            providers: IndexVec<CrateNum, Providers<$tcx>>,\n+            $($(#[$attr])* pub $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>),*\n         }\n \n-        impl<'tcx> Maps<'tcx> {\n-            pub fn new(dep_graph: DepGraph) -> Self {\n+        impl<$tcx> Maps<$tcx> {\n+            pub fn new(dep_graph: DepGraph,\n+                       providers: IndexVec<CrateNum, Providers<$tcx>>)\n+                       -> Self {\n                 Maps {\n-                    $($field: RefCell::new(DepTrackingMap::new(dep_graph.clone()))),*\n+                    providers,\n+                    $($name: RefCell::new(DepTrackingMap::new(dep_graph.clone()))),*\n                 }\n             }\n         }\n \n-        $(#[allow(bad_style)]\n-        pub struct $field<'tcx> {\n-            data: PhantomData<&'tcx ()>\n+        pub mod queries {\n+            use std::marker::PhantomData;\n+\n+            $(#[allow(bad_style)]\n+            pub struct $name<$tcx> {\n+                data: PhantomData<&$tcx ()>\n+            })*\n         }\n \n-        impl<'tcx> DepTrackingMapConfig for $field<'tcx> {\n-            type Key = $key;\n-            type Value = $value;\n-            fn to_dep_node(key: &$key) -> DepNode<DefId> { DepNode::$node_name(*key) }\n+        $(impl<$tcx> DepTrackingMapConfig for queries::$name<$tcx> {\n+            type Key = $K;\n+            type Value = $V;\n+            fn to_dep_node(key: &$K) -> DepNode<DefId> { DepNode::$node(*key) }\n         })*\n+\n+        pub struct Providers<$tcx> {\n+            $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $V),*\n+        }\n+\n+        impl<$tcx> Copy for Providers<$tcx> {}\n+        impl<$tcx> Clone for Providers<$tcx> {\n+            fn clone(&self) -> Self { *self }\n+        }\n+\n+        impl<$tcx> Default for Providers<$tcx> {\n+            fn default() -> Self {\n+                $(fn $name<'a, $tcx>(_: TyCtxt<'a, $tcx, $tcx>, key: $K) -> $V {\n+                    bug!(\"tcx.maps.{}({:?}) unsupported by its crate\",\n+                         stringify!($name), key);\n+                })*\n+                Providers { $($name),* }\n+            }\n+        }\n+\n+        impl<$tcx> Maps<$tcx> {\n+            $($(#[$attr])*\n+              pub fn $name<'a, 'lcx>(&self, tcx: TyCtxt<'a, $tcx, 'lcx>, key: $K) -> $V {\n+                self.$name.memoize(key, || {\n+                    (self.providers[key.map_crate()].$name)(tcx.global_tcx(), key)\n+                })\n+            })*\n+        }\n     }\n }\n \n-define_maps! {\n-    /// Maps from a trait item to the trait item \"descriptor\"\n-    pub associated_items: AssociatedItems(DefId) -> ty::AssociatedItem,\n-\n+// Each of these maps also corresponds to a method on a\n+// `Provider` trait for requesting a value of that type,\n+// and a method on `Maps` itself for doing that in a\n+// a way that memoizes and does dep-graph tracking,\n+// wrapping around the actual chain of providers that\n+// the driver creates (using several `rustc_*` crates).\n+define_maps! { <'tcx>\n     /// Records the type of every item.\n-    pub types: ItemSignature(DefId) -> Ty<'tcx>,\n+    pub ty: ItemSignature(DefId) -> Ty<'tcx>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated generics and predicates.\n@@ -66,18 +119,22 @@ define_maps! {\n     /// additional acyclicity requirements).\n     pub super_predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx>,\n \n-    /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    pub associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n-\n-    pub impl_trait_refs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>,\n-    pub trait_defs: ItemSignature(DefId) -> &'tcx ty::TraitDef,\n-    pub adt_defs: ItemSignature(DefId) -> &'tcx ty::AdtDef,\n+    pub trait_def: ItemSignature(DefId) -> &'tcx ty::TraitDef,\n+    pub adt_def: ItemSignature(DefId) -> &'tcx ty::AdtDef,\n     pub adt_sized_constraint: SizedConstraint(DefId) -> Ty<'tcx>,\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n     pub variances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,\n \n+    /// Maps from an impl/trait def-id to a list of the def-ids of its items\n+    pub associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n+\n+    /// Maps from a trait item to the trait item \"descriptor\"\n+    pub associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n+\n+    pub impl_trait_ref: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>>,\n+\n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n@@ -93,18 +150,18 @@ define_maps! {\n     ///\n     /// Note that cross-crate MIR appears to be always borrowed\n     /// (in the `RefCell` sense) to prevent accidental mutation.\n-    pub mir: Mir(DefId) -> &'tcx RefCell<::mir::Mir<'tcx>>,\n+    pub mir: Mir(DefId) -> &'tcx RefCell<mir::Mir<'tcx>>,\n \n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n-    pub closure_kinds: ItemSignature(DefId) -> ty::ClosureKind,\n+    pub closure_kind: ItemSignature(DefId) -> ty::ClosureKind,\n \n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n-    pub closure_types: ItemSignature(DefId) -> ty::ClosureTy<'tcx>,\n+    pub closure_type: ItemSignature(DefId) -> ty::ClosureTy<'tcx>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n-    pub custom_coerce_unsized_kinds: ItemSignature(DefId)\n+    pub custom_coerce_unsized_kind: ItemSignature(DefId)\n         -> ty::adjustment::CustomCoerceUnsized,\n \n     pub typeck_tables: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,"}, {"sha": "dd3ed2d9c2cd8811409f18169d1bc76b2dfb08d1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 36, "deletions": 111, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -1908,28 +1908,6 @@ impl LvaluePreference {\n     }\n }\n \n-/// Helper for looking things up in the various maps that are populated during\n-/// typeck::collect (e.g., `tcx.associated_items`, `tcx.types`, etc).  All of\n-/// these share the pattern that if the id is local, it should have been loaded\n-/// into the map by the `typeck::collect` phase.  If the def-id is external,\n-/// then we have to go consult the crate loading code (and cache the result for\n-/// the future).\n-fn lookup_locally_or_in_crate_store<M, F>(descr: &str,\n-                                          def_id: DefId,\n-                                          map: &M,\n-                                          load_external: F)\n-                                          -> M::Value where\n-    M: MemoizationMap<Key=DefId>,\n-    F: FnOnce() -> M::Value,\n-{\n-    map.memoize(def_id, || {\n-        if def_id.is_local() {\n-            bug!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n-        }\n-        load_external()\n-    })\n-}\n-\n impl BorrowKind {\n     pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n         match m {\n@@ -2095,31 +2073,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn custom_coerce_unsized_kind(self, did: DefId) -> adjustment::CustomCoerceUnsized {\n-        self.maps.custom_coerce_unsized_kinds.memoize(did, || {\n-            let (kind, src) = if did.krate != LOCAL_CRATE {\n-                (self.sess.cstore.custom_coerce_unsized_kind(did), \"external\")\n-            } else {\n-                (None, \"local\")\n-            };\n-\n-            match kind {\n-                Some(kind) => kind,\n-                None => {\n-                    bug!(\"custom_coerce_unsized_kind: \\\n-                          {} impl `{}` is missing its kind\",\n-                          src, self.item_path_str(did));\n-                }\n-            }\n-        })\n+        self.maps.custom_coerce_unsized_kind(self, did)\n     }\n \n     pub fn associated_item(self, def_id: DefId) -> AssociatedItem {\n-        self.maps.associated_items.memoize(def_id, || {\n-            if !def_id.is_local() {\n-                return self.sess.cstore.associated_item(def_id)\n-                           .expect(\"missing AssociatedItem in metadata\");\n-            }\n+        if !def_id.is_local() {\n+            return self.maps.associated_item(self, def_id);\n+        }\n \n+        self.maps.associated_item.memoize(def_id, || {\n             // When the user asks for a given associated item, we\n             // always go ahead and convert all the associated items in\n             // the container. Note that we are also careful only to\n@@ -2141,7 +2103,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                             self.associated_item_from_impl_item_ref(parent_def_id,\n                                                                     impl_trait_ref.is_some(),\n                                                                     impl_item_ref);\n-                        self.maps.associated_items.borrow_mut()\n+                        self.maps.associated_item.borrow_mut()\n                             .insert(assoc_item.def_id, assoc_item);\n                     }\n                 }\n@@ -2150,7 +2112,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     for trait_item_ref in trait_item_refs {\n                         let assoc_item =\n                             self.associated_item_from_trait_item_ref(parent_def_id, trait_item_ref);\n-                        self.maps.associated_items.borrow_mut()\n+                        self.maps.associated_item.borrow_mut()\n                             .insert(assoc_item.def_id, assoc_item);\n                     }\n                 }\n@@ -2162,7 +2124,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             // memoize wants us to return something, so return\n             // the one we generated for this def-id\n-            *self.maps.associated_items.borrow().get(&def_id).unwrap()\n+            *self.maps.associated_item.borrow().get(&def_id).unwrap()\n         })\n     }\n \n@@ -2220,11 +2182,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn associated_item_def_ids(self, def_id: DefId) -> Rc<Vec<DefId>> {\n-        self.maps.associated_item_def_ids.memoize(def_id, || {\n-            if !def_id.is_local() {\n-                return Rc::new(self.sess.cstore.associated_item_def_ids(def_id));\n-            }\n+        if !def_id.is_local() {\n+            return self.maps.associated_item_def_ids(self, def_id);\n+        }\n \n+        self.maps.associated_item_def_ids.memoize(def_id, || {\n             let id = self.hir.as_local_node_id(def_id).unwrap();\n             let item = self.hir.expect_item(id);\n             let vec: Vec<_> = match item.node {\n@@ -2256,9 +2218,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n     /// an inherent impl.\n     pub fn impl_trait_ref(self, id: DefId) -> Option<TraitRef<'gcx>> {\n-        lookup_locally_or_in_crate_store(\n-            \"impl_trait_refs\", id, &self.maps.impl_trait_refs,\n-            || self.sess.cstore.impl_trait_ref(self.global_tcx(), id))\n+        self.maps.impl_trait_ref(self, id)\n     }\n \n     // Returns `ty::VariantDef` if `def` refers to a struct,\n@@ -2337,58 +2297,37 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // If the given item is in an external crate, looks up its type and adds it to\n     // the type cache. Returns the type parameters and type.\n     pub fn item_type(self, did: DefId) -> Ty<'gcx> {\n-        lookup_locally_or_in_crate_store(\n-            \"item_types\", did, &self.maps.types,\n-            || self.sess.cstore.item_type(self.global_tcx(), did))\n+        self.maps.ty(self, did)\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n     pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef {\n-        lookup_locally_or_in_crate_store(\n-            \"trait_defs\", did, &self.maps.trait_defs,\n-            || self.alloc_trait_def(self.sess.cstore.trait_def(self.global_tcx(), did))\n-        )\n+        self.maps.trait_def(self, did)\n     }\n \n     /// Given the did of an ADT, return a reference to its definition.\n     pub fn lookup_adt_def(self, did: DefId) -> &'gcx AdtDef {\n-        lookup_locally_or_in_crate_store(\n-            \"adt_defs\", did, &self.maps.adt_defs,\n-            || self.sess.cstore.adt_def(self.global_tcx(), did))\n+        self.maps.adt_def(self, did)\n     }\n \n     /// Given the did of an item, returns its generics.\n     pub fn item_generics(self, did: DefId) -> &'gcx Generics {\n-        lookup_locally_or_in_crate_store(\n-            \"generics\", did, &self.maps.generics,\n-            || self.alloc_generics(self.sess.cstore.item_generics(did)))\n+        self.maps.generics(self, did)\n     }\n \n     /// Given the did of an item, returns its full set of predicates.\n     pub fn item_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n-        lookup_locally_or_in_crate_store(\n-            \"predicates\", did, &self.maps.predicates,\n-            || self.sess.cstore.item_predicates(self.global_tcx(), did))\n+        self.maps.predicates(self, did)\n     }\n \n     /// Given the did of a trait, returns its superpredicates.\n     pub fn item_super_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n-        lookup_locally_or_in_crate_store(\n-            \"super_predicates\", did, &self.maps.super_predicates,\n-            || self.sess.cstore.item_super_predicates(self.global_tcx(), did))\n+        self.maps.super_predicates(self, did)\n     }\n \n     /// Given the did of an item, returns its MIR, borrowed immutably.\n     pub fn item_mir(self, did: DefId) -> Ref<'gcx, Mir<'gcx>> {\n-        lookup_locally_or_in_crate_store(\"mir_map\", did, &self.maps.mir, || {\n-            let mir = self.sess.cstore.get_item_mir(self.global_tcx(), did);\n-            let mir = self.alloc_mir(mir);\n-\n-            // Perma-borrow MIR from extern crates to prevent mutation.\n-            mem::forget(mir.borrow());\n-\n-            mir\n-        }).borrow()\n+        self.maps.mir(self, did).borrow()\n     }\n \n     /// If `type_needs_drop` returns true, then `ty` is definitely\n@@ -2451,9 +2390,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn item_variances(self, item_id: DefId) -> Rc<Vec<ty::Variance>> {\n-        lookup_locally_or_in_crate_store(\n-            \"item_variance_map\", item_id, &self.maps.variances,\n-            || Rc::new(self.sess.cstore.item_variances(item_id)))\n+        self.maps.variances(self, item_id)\n     }\n \n     pub fn trait_has_default_impl(self, trait_def_id: DefId) -> bool {\n@@ -2528,33 +2465,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn closure_kind(self, def_id: DefId) -> ty::ClosureKind {\n-        // If this is a local def-id, it should be inserted into the\n-        // tables by typeck; else, it will be retreived from\n-        // the external crate metadata.\n-        if let Some(&kind) = self.maps.closure_kinds.borrow().get(&def_id) {\n-            return kind;\n-        }\n-\n-        let kind = self.sess.cstore.closure_kind(def_id);\n-        self.maps.closure_kinds.borrow_mut().insert(def_id, kind);\n-        kind\n+        self.maps.closure_kind(self, def_id)\n     }\n \n     pub fn closure_type(self,\n                         def_id: DefId,\n                         substs: ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        // If this is a local def-id, it should be inserted into the\n-        // tables by typeck; else, it will be retreived from\n-        // the external crate metadata.\n-        if let Some(ty) = self.maps.closure_types.borrow().get(&def_id) {\n+        if let Some(ty) = self.maps.closure_type.borrow().get(&def_id) {\n             return ty.subst(self, substs.substs);\n         }\n \n-        let ty = self.sess.cstore.closure_ty(self.global_tcx(), def_id);\n-        self.maps.closure_types.borrow_mut().insert(def_id, ty.clone());\n-        ty.subst(self, substs.substs)\n+        self.maps.closure_type(self, def_id).subst(self, substs.substs)\n     }\n \n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n@@ -2566,15 +2489,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// If the given def ID describes a method belonging to an impl, return the\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n-        if def_id.krate != LOCAL_CRATE {\n-            return self.sess.cstore.associated_item(def_id).and_then(|item| {\n-                match item.container {\n-                    TraitContainer(_) => None,\n-                    ImplContainer(def_id) => Some(def_id),\n-                }\n-            });\n-        }\n-        match self.maps.associated_items.borrow().get(&def_id).cloned() {\n+        let item = if def_id.krate != LOCAL_CRATE {\n+            if let Some(Def::Method(_)) = self.sess.cstore.describe_def(def_id) {\n+                Some(self.associated_item(def_id))\n+            } else {\n+                None\n+            }\n+        } else {\n+            self.maps.associated_item.borrow().get(&def_id).cloned()\n+        };\n+\n+        match item {\n             Some(trait_item) => {\n                 match trait_item.container {\n                     TraitContainer(_) => None,\n@@ -2592,7 +2517,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if def_id.krate != LOCAL_CRATE {\n             return self.sess.cstore.trait_of_item(def_id);\n         }\n-        match self.maps.associated_items.borrow().get(&def_id) {\n+        match self.maps.associated_item.borrow().get(&def_id) {\n             Some(associated_item) => {\n                 match associated_item.container {\n                     TraitContainer(def_id) => Some(def_id),"}, {"sha": "3981c8a7c4f527260fdb3822a598e17f7e94f301", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -770,7 +770,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyAdt(def, substs) => {\n                 ty::tls::with(|tcx| {\n                     if def.did.is_local() &&\n-                          !tcx.maps.types.borrow().contains_key(&def.did) {\n+                          !tcx.maps.ty.borrow().contains_key(&def.did) {\n                         write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n                     } else {\n                         parameterized(f, substs, def.did, &[])"}, {"sha": "967705c7481611e2c25eb9d208fe440a20cf8258", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -123,7 +123,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     } else {\n         let expr_tables_ty = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n             (&body.value, Some(tcx.item_tables(def_id)),\n-             Some(tcx.sess.cstore.item_type(tcx, def_id)))\n+             Some(tcx.item_type(def_id)))\n         });\n         match tcx.sess.cstore.describe_def(def_id) {\n             Some(Def::AssociatedConst(_)) => {"}, {"sha": "6dbdf55f1ca377fd6cf2f5197bd9e5a823d79d61", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -28,7 +28,7 @@ use rustc_incremental::{self, IncrementalHashesMap};\n use rustc_incremental::ich::Fingerprint;\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::creader::CrateLoader;\n-use rustc_metadata::cstore::CStore;\n+use rustc_metadata::cstore::{self, CStore};\n use rustc_trans::back::{link, write};\n use rustc_trans as trans;\n use rustc_typeck as typeck;\n@@ -872,7 +872,14 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let index = stability::Index::new(&hir_map);\n \n+    let local_providers = ty::maps::Providers::default();\n+    let mut extern_providers = ty::maps::Providers::default();\n+\n+    cstore::provide(&mut extern_providers);\n+\n     TyCtxt::create_and_enter(sess,\n+                             local_providers,\n+                             extern_providers,\n                              arenas,\n                              arena,\n                              resolutions,"}, {"sha": "2aa1b9981b3cd0923f49c7118667eb749b0241d9", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -139,6 +139,8 @@ fn test_env<F>(source_string: &str,\n     let region_map = region::resolve_crate(&sess, &hir_map);\n     let index = stability::Index::new(&hir_map);\n     TyCtxt::create_and_enter(&sess,\n+                             ty::maps::Providers::default(),\n+                             ty::maps::Providers::default(),\n                              &arenas,\n                              &arena,\n                              resolutions,"}, {"sha": "353b86820c405e3811d9f438cc5a55cd797fdeea", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -29,7 +29,7 @@ pub enum MethodLateContext {\n \n pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n     let def_id = cx.tcx.hir.local_def_id(id);\n-    match cx.tcx.maps.associated_items.borrow().get(&def_id) {\n+    match cx.tcx.maps.associated_item.borrow().get(&def_id) {\n         None => span_bug!(span, \"missing method descriptor?!\"),\n         Some(item) => {\n             match item.container {"}, {"sha": "bb30245df5f56315a1069c07c9da2d607626795c", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -35,6 +35,8 @@ pub use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind, LinkagePrefere\n pub use rustc::middle::cstore::NativeLibraryKind::*;\n pub use rustc::middle::cstore::{CrateSource, LinkMeta, LibSource};\n \n+pub use cstore_impl::provide;\n+\n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their"}, {"sha": "770591bc17ad7e90e1d9554ce0b5b219e18fbcd4", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 84, "deletions": 93, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -13,20 +13,25 @@ use encoder;\n use locator;\n use schema;\n \n+use rustc::dep_graph::DepTrackingMapConfig;\n use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind, ExternCrate};\n use rustc::middle::cstore::{NativeLibrary, LinkMeta, LinkagePreference, LoadedMacro};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n use rustc::session::Session;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, TyCtxt};\n+use rustc::ty::maps::Providers;\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map::{DefKey, DefPath, DisambiguatedDefPathData};\n-use rustc::mir::Mir;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n \n+use std::any::Any;\n+use std::mem;\n+use std::rc::Rc;\n+\n use syntax::ast;\n use syntax::attr;\n use syntax::parse::filemap_to_tts;\n@@ -38,7 +43,73 @@ use rustc::hir;\n \n use std::collections::BTreeMap;\n \n-impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n+macro_rules! provide {\n+    (<$lt:tt> $tcx:ident, $def_id:ident, $cdata:ident $($name:ident => $compute:block)*) => {\n+        pub fn provide<$lt>(providers: &mut Providers<$lt>) {\n+            $(fn $name<'a, $lt:$lt>($tcx: TyCtxt<'a, $lt, $lt>, $def_id: DefId)\n+                                    -> <ty::maps::queries::$name<$lt> as\n+                                        DepTrackingMapConfig>::Value {\n+                assert!(!$def_id.is_local());\n+\n+                $tcx.dep_graph.read(DepNode::MetaData($def_id));\n+\n+                let $cdata = $tcx.sess.cstore.crate_data_as_rc_any($def_id.krate);\n+                let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n+                    .expect(\"CrateStore crated ata is not a CrateMetadata\");\n+                $compute\n+            })*\n+\n+            *providers = Providers {\n+                $($name,)*\n+                ..*providers\n+            };\n+        }\n+    }\n+}\n+\n+provide! { <'tcx> tcx, def_id, cdata\n+    ty => { cdata.get_type(def_id.index, tcx) }\n+    generics => { tcx.alloc_generics(cdata.get_generics(def_id.index)) }\n+    predicates => { cdata.get_predicates(def_id.index, tcx) }\n+    super_predicates => { cdata.get_super_predicates(def_id.index, tcx) }\n+    trait_def => {\n+        tcx.alloc_trait_def(cdata.get_trait_def(def_id.index, tcx))\n+    }\n+    adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n+    variances => { Rc::new(cdata.get_item_variances(def_id.index)) }\n+    associated_item_def_ids => {\n+        let mut result = vec![];\n+        cdata.each_child_of_item(def_id.index, |child| result.push(child.def.def_id()));\n+        Rc::new(result)\n+    }\n+    associated_item => { cdata.get_associated_item(def_id.index) }\n+    impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n+    custom_coerce_unsized_kind => {\n+        cdata.get_custom_coerce_unsized_kind(def_id.index).unwrap_or_else(|| {\n+            bug!(\"custom_coerce_unsized_kind: `{:?}` is missing its kind\", def_id);\n+        })\n+    }\n+    mir => {\n+        let mir = cdata.maybe_get_item_mir(tcx, def_id.index).unwrap_or_else(|| {\n+            bug!(\"get_item_mir: missing MIR for `{:?}`\", def_id)\n+        });\n+\n+        let mir = tcx.alloc_mir(mir);\n+\n+        // Perma-borrow MIR from extern crates to prevent mutation.\n+        mem::forget(mir.borrow());\n+\n+        mir\n+    }\n+    closure_kind => { cdata.closure_kind(def_id.index) }\n+    closure_type => { cdata.closure_ty(def_id.index, tcx) }\n+}\n+\n+impl CrateStore for cstore::CStore {\n+    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any> {\n+        self.get_crate_data(krate)\n+    }\n+\n     fn describe_def(&self, def: DefId) -> Option<Def> {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_def(def.index)\n@@ -64,46 +135,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).get_visibility(def.index)\n     }\n \n-    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind\n-    {\n-        assert!(!def_id.is_local());\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-        self.get_crate_data(def_id.krate).closure_kind(def_id.index)\n-    }\n-\n-    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx> {\n-        assert!(!def_id.is_local());\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-        self.get_crate_data(def_id.krate).closure_ty(def_id.index, tcx)\n-    }\n-\n-    fn item_variances(&self, def: DefId) -> Vec<ty::Variance> {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_item_variances(def.index)\n-    }\n-\n-    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                     -> Ty<'tcx>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_type(def.index, tcx)\n-    }\n-\n-    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                           -> ty::GenericPredicates<'tcx>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_predicates(def.index, tcx)\n-    }\n-\n-    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                 -> ty::GenericPredicates<'tcx>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_super_predicates(def.index, tcx)\n-    }\n-\n-    fn item_generics(&self, def: DefId) -> ty::Generics {\n+    fn item_generics_cloned(&self, def: DefId) -> ty::Generics {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_generics(def.index)\n     }\n@@ -114,18 +146,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def_id.krate).get_item_attrs(def_id.index)\n     }\n \n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::TraitDef\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_trait_def(def.index, tcx)\n-    }\n-\n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_adt_def(def.index, tcx)\n-    }\n-\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>\n     {\n         // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n@@ -154,34 +174,12 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn associated_item_def_ids(&self, def_id: DefId) -> Vec<DefId> {\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-        let mut result = vec![];\n-        self.get_crate_data(def_id.krate)\n-            .each_child_of_item(def_id.index, |child| result.push(child.def.def_id()));\n-        result\n-    }\n-\n     fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_impl_polarity(def.index)\n     }\n \n-    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                          -> Option<ty::TraitRef<'tcx>>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_impl_trait(def.index, tcx)\n-    }\n-\n-    fn custom_coerce_unsized_kind(&self, def: DefId)\n-                                  -> Option<ty::adjustment::CustomCoerceUnsized>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).get_custom_coerce_unsized_kind(def.index)\n-    }\n-\n     fn impl_parent(&self, impl_def: DefId) -> Option<DefId> {\n         self.dep_graph.read(DepNode::MetaData(impl_def));\n         self.get_crate_data(impl_def.krate).get_parent_impl(impl_def.index)\n@@ -192,7 +190,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def_id.krate).get_trait_of_item(def_id.index)\n     }\n \n-    fn associated_item(&self, def: DefId) -> Option<ty::AssociatedItem>\n+    fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_associated_item(def.index)\n@@ -425,10 +423,10 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         })\n     }\n \n-    fn maybe_get_item_body<'a>(&'tcx self,\n-                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               def_id: DefId)\n-                               -> Option<&'tcx hir::Body>\n+    fn maybe_get_item_body<'a, 'tcx>(&self,\n+                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     def_id: DefId)\n+                                     -> Option<&'tcx hir::Body>\n     {\n         if let Some(cached) = tcx.hir.get_inlined_body(def_id) {\n             return Some(cached);\n@@ -450,13 +448,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).const_is_rvalue_promotable_to_static(def.index)\n     }\n \n-    fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx> {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        self.get_crate_data(def.krate).maybe_get_item_mir(tcx, def.index).unwrap_or_else(|| {\n-            bug!(\"get_item_mir: missing MIR for {}\", tcx.item_path_str(def))\n-        })\n-    }\n-\n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).is_item_mir_available(def.index)\n@@ -504,10 +495,10 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.do_extern_mod_stmt_cnum(emod_id)\n     }\n \n-    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           reexports: &def::ExportMap,\n-                           link_meta: &LinkMeta,\n-                           reachable: &NodeSet) -> Vec<u8>\n+    fn encode_metadata<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 reexports: &def::ExportMap,\n+                                 link_meta: &LinkMeta,\n+                                 reachable: &NodeSet) -> Vec<u8>\n     {\n         encoder::encode_metadata(tcx, self, reexports, link_meta, reachable)\n     }"}, {"sha": "3f8873ddc27427d14858adff1b1efcc3a6fb61a1", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 21, "deletions": 40, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -584,7 +584,7 @@ impl<'a, 'tcx> CrateMetadata {\n         let adt = tcx.alloc_adt_def(did, kind, variants, repr);\n         if let Some(ctor_index) = ctor_index {\n             // Make adt definition available through constructor id as well.\n-            tcx.maps.adt_defs.borrow_mut().insert(self.local_def_id(ctor_index), adt);\n+            tcx.maps.adt_def.borrow_mut().insert(self.local_def_id(ctor_index), adt);\n         }\n \n         adt\n@@ -822,54 +822,35 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_associated_item(&self, id: DefIndex) -> Option<ty::AssociatedItem> {\n+    pub fn get_associated_item(&self, id: DefIndex) -> ty::AssociatedItem {\n         let item = self.entry(id);\n-        let parent_and_name = || {\n-            let def_key = self.def_key(id);\n-            (self.local_def_id(def_key.parent.unwrap()),\n-             def_key.disambiguated_data.data.get_opt_name().unwrap())\n-        };\n+        let def_key = self.def_key(id);\n+        let parent = self.local_def_id(def_key.parent.unwrap());\n+        let name = def_key.disambiguated_data.data.get_opt_name().unwrap();\n \n-        Some(match item.kind {\n+        let (kind, container, has_self) = match item.kind {\n             EntryKind::AssociatedConst(container) => {\n-                let (parent, name) = parent_and_name();\n-                ty::AssociatedItem {\n-                    name: name,\n-                    kind: ty::AssociatedKind::Const,\n-                    vis: item.visibility.decode(self),\n-                    defaultness: container.defaultness(),\n-                    def_id: self.local_def_id(id),\n-                    container: container.with_def_id(parent),\n-                    method_has_self_argument: false\n-                }\n+                (ty::AssociatedKind::Const, container, false)\n             }\n             EntryKind::Method(data) => {\n-                let (parent, name) = parent_and_name();\n                 let data = data.decode(self);\n-                ty::AssociatedItem {\n-                    name: name,\n-                    kind: ty::AssociatedKind::Method,\n-                    vis: item.visibility.decode(self),\n-                    defaultness: data.container.defaultness(),\n-                    def_id: self.local_def_id(id),\n-                    container: data.container.with_def_id(parent),\n-                    method_has_self_argument: data.has_self\n-                }\n+                (ty::AssociatedKind::Method, data.container, data.has_self)\n             }\n             EntryKind::AssociatedType(container) => {\n-                let (parent, name) = parent_and_name();\n-                ty::AssociatedItem {\n-                    name: name,\n-                    kind: ty::AssociatedKind::Type,\n-                    vis: item.visibility.decode(self),\n-                    defaultness: container.defaultness(),\n-                    def_id: self.local_def_id(id),\n-                    container: container.with_def_id(parent),\n-                    method_has_self_argument: false\n-                }\n+                (ty::AssociatedKind::Type, container, false)\n             }\n-            _ => return None,\n-        })\n+            _ => bug!()\n+        };\n+\n+        ty::AssociatedItem {\n+            name: name,\n+            kind: kind,\n+            vis: item.visibility.decode(self),\n+            defaultness: container.defaultness(),\n+            def_id: self.local_def_id(id),\n+            container: container.with_def_id(parent),\n+            method_has_self_argument: has_self\n+        }\n     }\n \n     pub fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {"}, {"sha": "e101dc8cb5892314df5f9564a41e7df82e9b24cf", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -711,7 +711,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let data = ImplData {\n                     polarity: polarity,\n                     parent_impl: parent,\n-                    coerce_unsized_kind: tcx.maps.custom_coerce_unsized_kinds\n+                    coerce_unsized_kind: tcx.maps.custom_coerce_unsized_kind\n                         .borrow()\n                         .get(&def_id)\n                         .cloned(),\n@@ -1096,7 +1096,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = ClosureData {\n             kind: tcx.closure_kind(def_id),\n-            ty: self.lazy(&tcx.maps.closure_types.borrow()[&def_id]),\n+            ty: self.lazy(&tcx.maps.closure_type.borrow()[&def_id]),\n         };\n \n         Entry {"}, {"sha": "0ce886ce9e9dfc92a8ad9c35a4a5c76b22478eb3", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -20,6 +20,7 @@\n #![feature(box_patterns)]\n #![feature(conservative_impl_trait)]\n #![feature(core_intrinsics)]\n+#![cfg_attr(stage0, feature(field_init_shorthand))]\n #![feature(i128_type)]\n #![feature(proc_macro_internals)]\n #![feature(quote)]"}, {"sha": "89cff39c59e31317f3af47fe0fa81921c7962925", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -462,8 +462,8 @@ impl<'a> Resolver<'a> {\n                     self.define(module, ident, ns, (child.def, ty::Visibility::Public,\n                                                     DUMMY_SP, Mark::root()));\n \n-                    let has_self = self.session.cstore.associated_item(child.def.def_id())\n-                                       .map_or(false, |item| item.method_has_self_argument);\n+                    let has_self = self.session.cstore.associated_item_cloned(child.def.def_id())\n+                                       .method_has_self_argument;\n                     self.trait_item_map.insert((def_id, child.name, ns), (child.def, has_self));\n                 }\n                 module.populated.set(true);"}, {"sha": "7b14684267173e6fc2492bf662aee95a5cfc6227", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -208,9 +208,9 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n \n         // If we are also inferred the closure kind here, update the\n         // main table and process any deferred resolutions.\n-        let closure_def_id = self.fcx.tcx.hir.local_def_id(id);\n         if let Some(&kind) = self.temp_closure_kinds.get(&id) {\n             self.fcx.tables.borrow_mut().closure_kinds.insert(id, kind);\n+            let closure_def_id = self.fcx.tcx.hir.local_def_id(id);\n             debug!(\"closure_kind({:?}) = {:?}\", closure_def_id, kind);\n \n             let mut deferred_call_resolutions ="}, {"sha": "650f32eb6b216f3fa69b3bda8032eee9ceeb9b1e", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -290,12 +290,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         for (&id, closure_ty) in self.fcx.tables.borrow().closure_tys.iter() {\n             let closure_ty = self.resolve(closure_ty, ResolvingClosure(id));\n             let def_id = self.tcx().hir.local_def_id(id);\n-            self.tcx().maps.closure_types.borrow_mut().insert(def_id, closure_ty);\n+            self.tcx().maps.closure_type.borrow_mut().insert(def_id, closure_ty);\n         }\n \n         for (&id, &closure_kind) in self.fcx.tables.borrow().closure_kinds.iter() {\n             let def_id = self.tcx().hir.local_def_id(id);\n-            self.tcx().maps.closure_kinds.borrow_mut().insert(def_id, closure_kind);\n+            self.tcx().maps.closure_kind.borrow_mut().insert(def_id, closure_kind);\n         }\n     }\n \n@@ -361,7 +361,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 }\n             });\n \n-            gcx.maps.types.borrow_mut().insert(def_id, outside_ty);\n+            gcx.maps.ty.borrow_mut().insert(def_id, outside_ty);\n         }\n     }\n "}, {"sha": "bfe8abb201caea401f9618d7280071cfcde8e083", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -341,7 +341,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n \n         if let Some(kind) = kind {\n-            tcx.maps.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n+            tcx.maps.custom_coerce_unsized_kind.borrow_mut().insert(impl_did, kind);\n         }\n     });\n }"}, {"sha": "4aa0650e57f717aa28ca66a360d048c1e6dd3d88", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -39,7 +39,7 @@ mod unsafety;\n \n struct CoherenceCollect<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    inherent_impls: RefMut<'a, DepTrackingMap<maps::inherent_impls<'tcx>>>,\n+    inherent_impls: RefMut<'a, DepTrackingMap<maps::queries::inherent_impls<'tcx>>>,\n }\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCollect<'a, 'tcx> {"}, {"sha": "90d12b26c6a62861a7a177ac1eb34669edcb81c5", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -606,7 +606,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n {\n     generics_of_def_id(ccx, ty_f.did);\n     let tt = ccx.icx(ty_f.did).to_ty(&field.ty);\n-    ccx.tcx.maps.types.borrow_mut().insert(ty_f.did, tt);\n+    ccx.tcx.maps.ty.borrow_mut().insert(ty_f.did, tt);\n     ccx.tcx.maps.predicates.borrow_mut().insert(ty_f.did, ty::GenericPredicates {\n         parent: Some(ccx.tcx.hir.get_parent_did(field.id)),\n         predicates: vec![]\n@@ -619,7 +619,7 @@ fn convert_method(ccx: &CrateCtxt, id: ast::NodeId, sig: &hir::MethodSig) {\n     let fty = AstConv::ty_of_fn(&ccx.icx(def_id), sig.unsafety, sig.abi, &sig.decl);\n     let substs = mk_item_substs(ccx, def_id);\n     let fty = ccx.tcx.mk_fn_def(def_id, substs, fty);\n-    ccx.tcx.maps.types.borrow_mut().insert(def_id, fty);\n+    ccx.tcx.maps.ty.borrow_mut().insert(def_id, fty);\n \n     ty_generic_predicates(ccx, def_id, &sig.generics);\n }\n@@ -635,7 +635,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     };\n     let def_id = ccx.tcx.hir.local_def_id(id);\n     ccx.tcx.maps.predicates.borrow_mut().insert(def_id, predicates);\n-    ccx.tcx.maps.types.borrow_mut().insert(def_id, ty);\n+    ccx.tcx.maps.ty.borrow_mut().insert(def_id, ty);\n }\n \n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -651,7 +651,7 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     ccx.tcx.maps.predicates.borrow_mut().insert(def_id, predicates);\n \n     if let Some(ty) = ty {\n-        ccx.tcx.maps.types.borrow_mut().insert(def_id, ty);\n+        ccx.tcx.maps.ty.borrow_mut().insert(def_id, ty);\n     }\n }\n \n@@ -725,7 +725,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             tcx.record_trait_has_default_impl(trait_ref.def_id);\n \n-            tcx.maps.impl_trait_refs.borrow_mut().insert(ccx.tcx.hir.local_def_id(it.id),\n+            tcx.maps.impl_trait_ref.borrow_mut().insert(ccx.tcx.hir.local_def_id(it.id),\n                                                          Some(trait_ref));\n         }\n         hir::ItemImpl(.., ref opt_trait_ref, _, _) => {\n@@ -735,7 +735,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 AstConv::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n             });\n-            tcx.maps.impl_trait_refs.borrow_mut().insert(def_id, trait_ref);\n+            tcx.maps.impl_trait_ref.borrow_mut().insert(def_id, trait_ref);\n \n             predicates_of_item(ccx, it);\n         },\n@@ -864,7 +864,7 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             }))\n         }\n     };\n-    tcx.maps.types.borrow_mut().insert(def_id, ctor_ty);\n+    tcx.maps.ty.borrow_mut().insert(def_id, ctor_ty);\n     tcx.maps.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n         parent: Some(ccx.tcx.hir.get_parent_did(ctor_id)),\n         predicates: vec![]\n@@ -966,10 +966,10 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ReprOptions::new(&ccx.tcx, did));\n     if let Some(ctor_id) = ctor_id {\n         // Make adt definition available through constructor id as well.\n-        ccx.tcx.maps.adt_defs.borrow_mut().insert(ctor_id, adt);\n+        ccx.tcx.maps.adt_def.borrow_mut().insert(ctor_id, adt);\n     }\n \n-    ccx.tcx.maps.adt_defs.borrow_mut().insert(did, adt);\n+    ccx.tcx.maps.adt_def.borrow_mut().insert(did, adt);\n     adt\n }\n \n@@ -983,7 +983,7 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                ty::VariantDiscr::Relative(0), def)];\n \n     let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, variants, ReprOptions::new(&ccx.tcx, did));\n-    ccx.tcx.maps.adt_defs.borrow_mut().insert(did, adt);\n+    ccx.tcx.maps.adt_def.borrow_mut().insert(did, adt);\n     adt\n }\n \n@@ -1061,7 +1061,7 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let did = tcx.hir.local_def_id(it.id);\n     let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants, ReprOptions::new(&ccx.tcx, did));\n-    tcx.maps.adt_defs.borrow_mut().insert(did, adt);\n+    tcx.maps.adt_def.borrow_mut().insert(did, adt);\n     adt\n }\n \n@@ -1150,7 +1150,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) -> &'t\n     let tcx = ccx.tcx;\n     let def_id = tcx.hir.local_def_id(it.id);\n \n-    tcx.maps.trait_defs.memoize(def_id, || {\n+    tcx.maps.trait_def.memoize(def_id, || {\n         let unsafety = match it.node {\n             hir::ItemTrait(unsafety, ..) => unsafety,\n             _ => span_bug!(it.span, \"trait_def_of_item invoked on non-trait\"),\n@@ -1380,7 +1380,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     } else {\n         return ccx.tcx.item_type(def_id);\n     };\n-    ccx.tcx.maps.types.memoize(def_id, || {\n+    ccx.tcx.maps.ty.memoize(def_id, || {\n         use rustc::hir::map::*;\n         use rustc::hir::*;\n \n@@ -1389,7 +1389,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         let icx = ccx.icx(def_id);\n \n-        let ty = match ccx.tcx.hir.get(node_id) {\n+        match ccx.tcx.hir.get(node_id) {\n             NodeItem(item) => {\n                 match item.node {\n                     ItemStatic(ref t, ..) | ItemConst(ref t, _) |\n@@ -1455,9 +1455,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             x => {\n                 bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n             }\n-        };\n-\n-        ty\n+        }\n     })\n }\n "}, {"sha": "852c98eb2fd52fcfb37e4cab0131f3aa415b6338", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c4244c6c46df22bb55531b629f4c314fe2ab22/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=b5c4244c6c46df22bb55531b629f4c314fe2ab22", "patch": "@@ -24,7 +24,7 @@ use clean::{AttributesExt, NestedAttributesExt};\n /// specific rustdoc annotations into account (i.e. `doc(hidden)`)\n pub struct LibEmbargoVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     cx: &'a ::core::DocContext<'b, 'tcx>,\n-    cstore: &'a CrateStore<'tcx>,\n+    cstore: &'a CrateStore,\n     // Accessibility levels for reachable nodes\n     access_levels: RefMut<'a, AccessLevels<DefId>>,\n     // Previous accessibility level, None means unreachable"}]}