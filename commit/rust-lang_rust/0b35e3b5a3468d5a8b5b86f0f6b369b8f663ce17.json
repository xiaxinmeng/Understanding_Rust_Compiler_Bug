{"sha": "0b35e3b5a3468d5a8b5b86f0f6b369b8f663ce17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMzVlM2I1YTM0NjhkNWE4YjViODZmMGY2YjM2OWI4ZjY2M2NlMTc=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-09T21:31:57Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-11T00:18:21Z"}, "message": "extra::treemap: Use IteratorUtil::peekable\n\nReplace the previous equivalent iterator adaptor with .peekable().\nRefactor the set operation iterators so that they are easier to read.", "tree": {"sha": "74ba07e1acc0e13131864eefed02f9a2d7f12811", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74ba07e1acc0e13131864eefed02f9a2d7f12811"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b35e3b5a3468d5a8b5b86f0f6b369b8f663ce17", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b35e3b5a3468d5a8b5b86f0f6b369b8f663ce17", "html_url": "https://github.com/rust-lang/rust/commit/0b35e3b5a3468d5a8b5b86f0f6b369b8f663ce17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b35e3b5a3468d5a8b5b86f0f6b369b8f663ce17/comments", "author": null, "committer": null, "parents": [{"sha": "deb7b67aa1a26aff628da272531aa9f74d166f78", "url": "https://api.github.com/repos/rust-lang/rust/commits/deb7b67aa1a26aff628da272531aa9f74d166f78", "html_url": "https://github.com/rust-lang/rust/commit/deb7b67aa1a26aff628da272531aa9f74d166f78"}], "stats": {"total": 134, "additions": 46, "deletions": 88}, "files": [{"sha": "f5a61692509ad2a322907d867eca00c2b59ec7f1", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 46, "deletions": 88, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/0b35e3b5a3468d5a8b5b86f0f6b369b8f663ce17/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b35e3b5a3468d5a8b5b86f0f6b369b8f663ce17/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=0b35e3b5a3468d5a8b5b86f0f6b369b8f663ce17", "patch": "@@ -14,7 +14,8 @@\n \n \n use std::util::{swap, replace};\n-use std::iterator::{FromIterator, Extendable};\n+use std::iterator::{FromIterator, Extendable, Peekable};\n+use std::cmp::Ordering;\n \n // This is implemented as an AA tree, which is a simplified variation of\n // a red-black tree where red (horizontal) nodes can only be added\n@@ -529,24 +530,24 @@ impl<T: TotalOrd> TreeSet<T> {\n \n     /// Visit the values (in-order) representing the difference\n     pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> Difference<'a, T> {\n-        Difference{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+        Difference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visit the values (in-order) representing the symmetric difference\n     pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n         -> SymDifference<'a, T> {\n-        SymDifference{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+        SymDifference{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visit the values (in-order) representing the intersection\n     pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n         -> Intersection<'a, T> {\n-        Intersection{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+        Intersection{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visit the values (in-order) representing the union\n     pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> Union<'a, T> {\n-        Union{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+        Union{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n }\n \n@@ -560,61 +561,47 @@ pub struct TreeSetRevIterator<'self, T> {\n     priv iter: TreeMapRevIterator<'self, T, ()>\n }\n \n-// Encapsulate an iterator and hold its latest value until stepped forward\n-struct Focus<A, T> {\n-    priv iter: T,\n-    priv focus: Option<A>,\n-}\n-\n-impl<A, T: Iterator<A>> Focus<A, T> {\n-    fn new(mut it: T) -> Focus<A, T> {\n-        Focus{focus: it.next(), iter: it}\n-    }\n-    fn step(&mut self) {\n-        self.focus = self.iter.next()\n-    }\n-}\n-\n /// Lazy iterator producing elements in the set difference (in-order)\n pub struct Difference<'self, T> {\n-    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n-    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n }\n \n /// Lazy iterator producing elements in the set symmetric difference (in-order)\n pub struct SymDifference<'self, T> {\n-    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n-    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n }\n \n /// Lazy iterator producing elements in the set intersection (in-order)\n pub struct Intersection<'self, T> {\n-    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n-    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n }\n \n /// Lazy iterator producing elements in the set intersection (in-order)\n pub struct Union<'self, T> {\n-    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n-    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n+}\n+\n+/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n+fn cmp_opt<T: TotalOrd>(x: Option<&T>, y: Option<&T>,\n+                        short: Ordering, long: Ordering) -> Ordering {\n+    match (x, y) {\n+        (None    , _       ) => short,\n+        (_       , None    ) => long,\n+        (Some(x1), Some(y1)) => x1.cmp(y1),\n+    }\n }\n \n impl<'self, T: TotalOrd> Iterator<&'self T> for Difference<'self, T> {\n     fn next(&mut self) -> Option<&'self T> {\n         loop {\n-            match (self.a.focus, self.b.focus) {\n-                (None    , _       ) => return None,\n-                (ret     , None    ) => { self.a.step(); return ret },\n-                (Some(a1), Some(b1)) => {\n-                    let cmp = a1.cmp(b1);\n-                    if cmp == Less {\n-                        self.a.step();\n-                        return Some(a1);\n-                    } else {\n-                        if cmp == Equal { self.a.step() }\n-                        self.b.step();\n-                    }\n-                }\n+            match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.a.next(); self.b.next(); }\n+                Greater => { self.b.next(); }\n             }\n         }\n     }\n@@ -623,23 +610,10 @@ impl<'self, T: TotalOrd> Iterator<&'self T> for Difference<'self, T> {\n impl<'self, T: TotalOrd> Iterator<&'self T> for SymDifference<'self, T> {\n     fn next(&mut self) -> Option<&'self T> {\n         loop {\n-            match (self.a.focus, self.b.focus) {\n-                (ret     , None    ) => { self.a.step(); return ret },\n-                (None    , ret     ) => { self.b.step(); return ret },\n-                (Some(a1), Some(b1)) => {\n-                    let cmp = a1.cmp(b1);\n-                    if cmp == Less {\n-                        self.a.step();\n-                        return Some(a1);\n-                    } else {\n-                        self.b.step();\n-                        if cmp == Greater {\n-                            return Some(b1);\n-                        } else {\n-                            self.a.step();\n-                        }\n-                    }\n-                }\n+            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.a.next(); self.b.next(); }\n+                Greater => return self.b.next(),\n             }\n         }\n     }\n@@ -648,20 +622,16 @@ impl<'self, T: TotalOrd> Iterator<&'self T> for SymDifference<'self, T> {\n impl<'self, T: TotalOrd> Iterator<&'self T> for Intersection<'self, T> {\n     fn next(&mut self) -> Option<&'self T> {\n         loop {\n-            match (self.a.focus, self.b.focus) {\n-                (None    , _       ) => return None,\n-                (_       , None    ) => return None,\n-                (Some(a1), Some(b1)) => {\n-                    let cmp = a1.cmp(b1);\n-                    if cmp == Less {\n-                        self.a.step();\n-                    } else {\n-                        self.b.step();\n-                        if cmp == Equal {\n-                            return Some(a1);\n-                        }\n-                    }\n-                },\n+            let o_cmp = match (self.a.peek(), self.b.peek()) {\n+                (None    , _       ) => None,\n+                (_       , None    ) => None,\n+                (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n+            };\n+            match o_cmp {\n+                None          => return None,\n+                Some(Less)    => { self.a.next(); }\n+                Some(Equal)   => { self.b.next(); return self.a.next() }\n+                Some(Greater) => { self.b.next(); }\n             }\n         }\n     }\n@@ -670,22 +640,10 @@ impl<'self, T: TotalOrd> Iterator<&'self T> for Intersection<'self, T> {\n impl<'self, T: TotalOrd> Iterator<&'self T> for Union<'self, T> {\n     fn next(&mut self) -> Option<&'self T> {\n         loop {\n-            match (self.a.focus, self.b.focus) {\n-                (ret     , None) => { self.a.step(); return ret },\n-                (None    , ret ) => { self.b.step(); return ret },\n-                (Some(a1), Some(b1)) => {\n-                    let cmp = a1.cmp(b1);\n-                    if cmp == Greater {\n-                        self.b.step();\n-                        return Some(b1);\n-                    } else {\n-                        self.a.step();\n-                        if cmp == Equal {\n-                            self.b.step();\n-                        }\n-                        return Some(a1);\n-                    }\n-                }\n+            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n+                Less    => return self.a.next(),\n+                Equal   => { self.b.next(); return self.a.next() }\n+                Greater => return self.b.next(),\n             }\n         }\n     }"}]}