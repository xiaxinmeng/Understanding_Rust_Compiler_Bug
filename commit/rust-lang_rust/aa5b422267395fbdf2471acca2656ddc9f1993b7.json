{"sha": "aa5b422267395fbdf2471acca2656ddc9f1993b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNWI0MjIyNjczOTVmYmRmMjQ3MWFjY2EyNjU2ZGRjOWYxOTkzYjc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-22T01:32:22Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T23:54:33Z"}, "message": "librustc: De-`@mut` `ImportResolution::is_public`", "tree": {"sha": "215a46a58b392afef5cc2093efc081498da6a8b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/215a46a58b392afef5cc2093efc081498da6a8b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa5b422267395fbdf2471acca2656ddc9f1993b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa5b422267395fbdf2471acca2656ddc9f1993b7", "html_url": "https://github.com/rust-lang/rust/commit/aa5b422267395fbdf2471acca2656ddc9f1993b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa5b422267395fbdf2471acca2656ddc9f1993b7/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de6eb2b2906cb959ce374306c28c535c5e799982", "url": "https://api.github.com/repos/rust-lang/rust/commits/de6eb2b2906cb959ce374306c28c535c5e799982", "html_url": "https://github.com/rust-lang/rust/commit/de6eb2b2906cb959ce374306c28c535c5e799982"}], "stats": {"total": 22, "additions": 11, "deletions": 11}, "files": [{"sha": "12cde0c4ba802d102361a7be5d1d56daaf6c644e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aa5b422267395fbdf2471acca2656ddc9f1993b7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5b422267395fbdf2471acca2656ddc9f1993b7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=aa5b422267395fbdf2471acca2656ddc9f1993b7", "patch": "@@ -346,7 +346,7 @@ struct ImportResolution {\n     /// should *not* be used whenever resolution is being performed, this is\n     /// only looked at for glob imports statements currently. Privacy testing\n     /// occurs during a later phase of compilation.\n-    is_public: bool,\n+    is_public: Cell<bool>,\n \n     // The number of outstanding references to this name. When this reaches\n     // zero, outside modules can count on the targets being correct. Before\n@@ -374,7 +374,7 @@ impl ImportResolution {\n             outstanding_references: Cell::new(0),\n             value_target: None,\n             type_target: None,\n-            is_public: is_public,\n+            is_public: Cell::new(is_public),\n         }\n     }\n \n@@ -2340,7 +2340,7 @@ impl Resolver {\n \n                             // Import resolutions must be declared with \"pub\"\n                             // in order to be exported.\n-                            if !import_resolution.is_public {\n+                            if !import_resolution.is_public.get() {\n                                 return UnboundResult;\n                             }\n \n@@ -2363,12 +2363,12 @@ impl Resolver {\n                         if value_result.is_unknown() {\n                             value_result = get_binding(self, *import_resolution,\n                                                        ValueNS);\n-                            used_reexport = import_resolution.is_public;\n+                            used_reexport = import_resolution.is_public.get();\n                         }\n                         if type_result.is_unknown() {\n                             type_result = get_binding(self, *import_resolution,\n                                                       TypeNS);\n-                            used_reexport = import_resolution.is_public;\n+                            used_reexport = import_resolution.is_public.get();\n                         }\n \n                     }\n@@ -2521,7 +2521,7 @@ impl Resolver {\n                    target_import_resolution.type_target.is_none(),\n                    self.module_to_str(module_));\n \n-            if !target_import_resolution.is_public {\n+            if !target_import_resolution.is_public.get() {\n                 debug!(\"(resolving glob import) nevermind, just kidding\");\n                 continue\n             }\n@@ -2564,7 +2564,7 @@ impl Resolver {\n                                 Some(type_target);\n                         }\n                     }\n-                    dest_import_resolution.is_public = is_public;\n+                    dest_import_resolution.is_public.set(is_public);\n                 }\n             }\n         }\n@@ -2605,7 +2605,7 @@ impl Resolver {\n                     Some(Target::new(containing_module, name_bindings));\n                 dest_import_resolution.type_id = id;\n             }\n-            dest_import_resolution.is_public = is_public;\n+            dest_import_resolution.is_public.set(is_public);\n         };\n \n         // Add all children from the containing module.\n@@ -3182,7 +3182,7 @@ impl Resolver {\n         let import_resolutions = module_.import_resolutions.borrow();\n         match import_resolutions.get().find(&name.name) {\n             Some(import_resolution) => {\n-                if import_resolution.is_public &&\n+                if import_resolution.is_public.get() &&\n                         import_resolution.outstanding_references.get() != 0 {\n                     debug!(\"(resolving name in module) import \\\n                            unresolved; bailing out\");\n@@ -3374,7 +3374,7 @@ impl Resolver {\n                               module_: @Module) {\n         let import_resolutions = module_.import_resolutions.borrow();\n         for (name, importresolution) in import_resolutions.get().iter() {\n-            if !importresolution.is_public {\n+            if !importresolution.is_public.get() {\n                 continue\n             }\n             let xs = [TypeNS, ValueNS];\n@@ -4744,7 +4744,7 @@ impl Resolver {\n         let import_resolutions = containing_module.import_resolutions\n                                                   .borrow();\n         match import_resolutions.get().find(&name.name) {\n-            Some(import_resolution) if import_resolution.is_public => {\n+            Some(import_resolution) if import_resolution.is_public.get() => {\n                 match (*import_resolution).target_for_namespace(namespace) {\n                     Some(target) => {\n                         match target.bindings.def_for_namespace(namespace) {"}]}