{"sha": "e530829797ed2dd0cbab0309979ad5846c69b497", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1MzA4Mjk3OTdlZDJkZDBjYmFiMDMwOTk3OWFkNTg0NmM2OWI0OTc=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-01-01T09:12:27Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-24T13:41:04Z"}, "message": "Use 'cargo check' to build the sysroot and target crate\n\nFixes #1057\n\nSince we are no longer using \"cargo rustc\", we now use the rustc\narguments passed by Cargo to determine whether we are building a\nbuild dependency, normal dependency, or \"target\" (final binary or test)\ncrate.", "tree": {"sha": "c2372b13d8ee5eab3e6989fa5d830be9bf63bb62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2372b13d8ee5eab3e6989fa5d830be9bf63bb62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e530829797ed2dd0cbab0309979ad5846c69b497", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e530829797ed2dd0cbab0309979ad5846c69b497", "html_url": "https://github.com/rust-lang/rust/commit/e530829797ed2dd0cbab0309979ad5846c69b497", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e530829797ed2dd0cbab0309979ad5846c69b497/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c444bf6a6cff3b9014005f21cc44995b34862ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c444bf6a6cff3b9014005f21cc44995b34862ce", "html_url": "https://github.com/rust-lang/rust/commit/3c444bf6a6cff3b9014005f21cc44995b34862ce"}], "stats": {"total": 89, "additions": 65, "deletions": 24}, "files": [{"sha": "236905b895f8e38880925ef670f36917161725f5", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e530829797ed2dd0cbab0309979ad5846c69b497/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e530829797ed2dd0cbab0309979ad5846c69b497/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=e530829797ed2dd0cbab0309979ad5846c69b497", "patch": "@@ -50,6 +50,7 @@ rustc-workspace-hack = \"1.0.0\"\n # between \"cargo build\" and \"cargo intall\".\n num-traits = \"*\"\n serde = { version = \"*\", features = [\"derive\"] }\n+serde_json = \"1.0.44\"\n \n [build-dependencies]\n vergen = \"3\""}, {"sha": "55503c635dbaf9333e1efcbcfe3c5c6d6293886f", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 64, "deletions": 24, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e530829797ed2dd0cbab0309979ad5846c69b497/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e530829797ed2dd0cbab0309979ad5846c69b497/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=e530829797ed2dd0cbab0309979ad5846c69b497", "patch": "@@ -6,7 +6,7 @@ use std::ops::Not;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n-const XARGO_MIN_VERSION: (u32, u32, u32) = (0, 3, 17);\n+const XARGO_MIN_VERSION: (u32, u32, u32) = (0, 3, 19);\n \n const CARGO_MIRI_HELP: &str = r#\"Interprets bin crates and tests in Miri\n \n@@ -84,6 +84,34 @@ fn get_arg_flag_value(name: &str) -> Option<String> {\n     }\n }\n \n+\n+/// Determines if we are being invoked (as rustc) to build a runnable\n+/// executable. We run \"cargo check\", so this should only happen when\n+/// we are trying to compile a build script or build script dependency,\n+/// which actually needs to be executed on the host platform.\n+///\n+/// Currently, we detect this by checking for \"--emit=link\",\n+/// which indicates that Cargo instruced rustc to output\n+/// a native object.\n+fn is_build_dep() -> bool {\n+    std::env::args().any(|arg| arg.starts_with(\"--emit=\") && arg.contains(\"link\"))\n+}\n+\n+/// Returns whether or not Cargo invoked the wrapper (this binary) to compile\n+/// the final, target crate (either a test for 'cargo test', or a binary for 'cargo run')\n+/// Cargo does not give us this information directly, so we need to check\n+/// various command-line flags.\n+fn is_target_crate(is_build_script: bool) -> bool {\n+    let is_bin = get_arg_flag_value(\"--crate-type\").as_deref() == Some(\"bin\");\n+    let is_test = std::env::args().find(|arg| arg == \"--test\").is_some();\n+\n+    // The final runnable (under Miri) crate will either be a binary crate\n+    // or a test crate. We make sure to exclude build scripts here, since\n+    // they are also build with \"--crate-type bin\"\n+    (is_bin || is_test) && !is_build_script\n+}\n+\n+\n fn list_targets() -> impl Iterator<Item = cargo_metadata::Target> {\n     // We need to get the manifest, and then the metadata, to enumerate targets.\n     let manifest_path =\n@@ -197,7 +225,7 @@ fn xargo() -> Command {\n         // Bootstrap tells us where to find xargo\n         Command::new(val)\n     } else {\n-        Command::new(\"xargo\")\n+        Command::new(\"xargo-check\")\n     }\n }\n \n@@ -467,7 +495,7 @@ fn in_cargo_miri() {\n         // change to add additional arguments. `FLAGS` is set to identify\n         // this target.  The user gets to control what gets actually passed to Miri.\n         let mut cmd = cargo();\n-        cmd.arg(\"rustc\");\n+        cmd.arg(\"check\");\n         match (subcommand, kind.as_str()) {\n             (MiriCommand::Run, \"bin\") => {\n                 // FIXME: we just run all the binaries here.\n@@ -494,10 +522,15 @@ fn in_cargo_miri() {\n             }\n             cmd.arg(arg);\n         }\n-        // Add `--` (to end the `cargo` flags), and then the user flags. We add markers around the\n-        // user flags to be able to identify them later.  \"cargo rustc\" adds more stuff after this,\n-        // so we have to mark both the beginning and the end.\n-        cmd.arg(\"--\").arg(\"cargo-miri-marker-begin\").args(args).arg(\"cargo-miri-marker-end\");\n+\n+        // Serialize our actual args into a special environemt variable.\n+        // This will be read by `inside_cargo_rustc` when we go to invoke\n+        // our actual target crate (the binary or the test we are running).\n+        // Since we're using \"cargo check\", we have no other way of passing\n+        // these arguments.\n+        let args_vec: Vec<String> = args.collect();\n+        cmd.env(\"MIRI_MAGIC_ARGS\", serde_json::to_string(&args_vec).expect(\"failed to serialize args\"));\n+\n         let path = std::env::current_exe().expect(\"current executable path invalid\");\n         cmd.env(\"RUSTC_WRAPPER\", path);\n         if verbose {\n@@ -517,25 +550,32 @@ fn inside_cargo_rustc() {\n     let sysroot = std::env::var(\"MIRI_SYSROOT\").expect(\"The wrapper should have set MIRI_SYSROOT\");\n \n     let rustc_args = std::env::args().skip(2); // skip `cargo rustc`\n-    let mut args: Vec<String> =\n-        rustc_args.chain(Some(\"--sysroot\".to_owned())).chain(Some(sysroot)).collect();\n-    args.splice(0..0, miri::miri_default_args().iter().map(ToString::to_string));\n \n-    // See if we can find the `cargo-miri` markers. Those only get added to the binary we want to\n-    // run. They also serve to mark the user-defined arguments, which we have to move all the way\n-    // to the end (they get added somewhere in the middle).\n+    let in_build_script = is_build_dep();\n+\n+    // Build scripts need to be compiled to actual runnable executables,\n+    // and therefore completely bypass Miri. We make sure to only specify\n+    // our custom Xargo sysroot for non-build-script crate - that is,\n+    // crates which are ultimately going to get interpreted by Miri.\n+    let mut args = if in_build_script {\n+        rustc_args.collect()\n+    } else {\n+        let mut args: Vec<String> = rustc_args\n+            .chain(Some(\"--sysroot\".to_owned()))\n+            .chain(Some(sysroot))\n+            .collect();\n+        args.splice(0..0, miri::miri_default_args().iter().map(ToString::to_string));\n+        args\n+    };\n+\n     let needs_miri =\n-        if let Some(begin) = args.iter().position(|arg| arg == \"cargo-miri-marker-begin\") {\n-            let end = args\n-                .iter()\n-                .position(|arg| arg == \"cargo-miri-marker-end\")\n-                .expect(\"cannot find end marker\");\n-            // These mark the user arguments. We remove the first and last as they are the markers.\n-            let mut user_args = args.drain(begin..=end);\n-            assert_eq!(user_args.next().unwrap(), \"cargo-miri-marker-begin\");\n-            assert_eq!(user_args.next_back().unwrap(), \"cargo-miri-marker-end\");\n-            // Collect the rest and add it back at the end.\n-            let mut user_args = user_args.collect::<Vec<String>>();\n+        if is_target_crate(in_build_script) {\n+            // This is the 'target crate '- the binary or test crate that\n+            // we want to interpret under Miri. We deserialize the user-provided arguments\n+            // from the special environment variable \"MIRI_MAGIC_ARGS\", and feed them\n+            // to the 'miri' binary.\n+            let magic = std::env::var(\"MIRI_MAGIC_ARGS\").expect(\"missing MIRI_MAGIC_ARGS\");\n+            let mut user_args: Vec<String> = serde_json::from_str(&magic).expect(\"failed to deserialize args\");\n             args.append(&mut user_args);\n             // Run this in Miri.\n             true"}]}