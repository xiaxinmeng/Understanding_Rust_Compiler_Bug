{"sha": "63e9b8f105ba0fe18e99cb280a23db82380960f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZTliOGYxMDViYTBmZTE4ZTk5Y2IyODBhMjNkYjgyMzgwOTYwZjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-03T00:16:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-03T00:16:31Z"}, "message": "auto merge of #14601 : skade/rust/remove-notrust-tags, r=alexcrichton\n\nNow that rustdoc understands proper language tags\r\nas the code not being Rust, we can tag everything\r\nproperly. `norust` as a negative statement is a bad\r\ntag.\r\n\r\nThis change tags examples in other languages by\r\ntheir language. Plain notations are marked as `text`.\r\nConsole examples are marked as `console`.\r\n\r\nAlso fix markdown.rs to not highlight non-rust code.\r\n\r\nAmends the documentation to reflect the new\r\nbehaviour.", "tree": {"sha": "ee65b10c16ef7181ba34f0653cae3b3672734cf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee65b10c16ef7181ba34f0653cae3b3672734cf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63e9b8f105ba0fe18e99cb280a23db82380960f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63e9b8f105ba0fe18e99cb280a23db82380960f4", "html_url": "https://github.com/rust-lang/rust/commit/63e9b8f105ba0fe18e99cb280a23db82380960f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63e9b8f105ba0fe18e99cb280a23db82380960f4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "455f574470a3a3f755522bc0fb6594ec10eeda40", "url": "https://api.github.com/repos/rust-lang/rust/commits/455f574470a3a3f755522bc0fb6594ec10eeda40", "html_url": "https://github.com/rust-lang/rust/commit/455f574470a3a3f755522bc0fb6594ec10eeda40"}, {"sha": "20fb7c62d433addf853b8ab824462fca536aba07", "url": "https://api.github.com/repos/rust-lang/rust/commits/20fb7c62d433addf853b8ab824462fca536aba07", "html_url": "https://github.com/rust-lang/rust/commit/20fb7c62d433addf853b8ab824462fca536aba07"}], "stats": {"total": 321, "additions": 165, "deletions": 156}, "files": [{"sha": "5ad0e82658d1a7c7eb7b1a4468e3603cd6b16cef", "filename": "src/doc/complement-cheatsheet.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-cheatsheet.md?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -255,7 +255,7 @@ Note: The Rust signatures should be wrapped in an `extern \"ABI\" { ... }` block.\n \n You might see things like this in C APIs:\n \n-~~~ {.notrust}\n+~~~c\n typedef struct Window Window;\n Window* createWindow(int width, int height);\n ~~~"}, {"sha": "12176102ec64fcd40afdb0aa0d03e86d9655ad01", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -135,7 +135,7 @@ For simplicity, we do not plan to do so. Implementing automatic semicolon insert\n \n **Short answer** set the RUST_LOG environment variable to the name of your source file, sans extension.\n \n-```notrust,sh\n+```sh\n rustc hello.rs\n export RUST_LOG=hello\n ./hello"}, {"sha": "13e44765d59eb3ee88b87f7e98318e321453114f", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -229,7 +229,7 @@ fn main() {\n \n C code:\n \n-~~~~ {.notrust}\n+~~~~c\n typedef void (*rust_callback)(int32_t);\n rust_callback cb;\n \n@@ -296,7 +296,7 @@ fn main() {\n \n C code:\n \n-~~~~ {.notrust}\n+~~~~c\n typedef void (*rust_callback)(int32_t);\n void* cb_target;\n rust_callback cb;"}, {"sha": "2f519306dfd08375d98930dd264a6aae728c3e43", "filename": "src/doc/guide-lifetimes.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-lifetimes.md?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -218,7 +218,7 @@ fn example3() -> int {\n To make this clearer, consider this diagram showing the state of\n memory immediately before the re-assignment of `x`:\n \n-~~~ {.notrust}\n+~~~ {.text}\n     Stack               Exchange Heap\n \n   x +-------------+\n@@ -232,7 +232,7 @@ memory immediately before the re-assignment of `x`:\n \n Once the reassignment occurs, the memory will look like this:\n \n-~~~ {.notrust}\n+~~~ {.text}\n     Stack               Exchange Heap\n \n   x +-------------+          +---------+\n@@ -329,7 +329,7 @@ to a pointer of type `&size` into the _interior of the enum_.\n To make this more clear, let's look at a diagram of memory layout in\n the case where `shape` points at a rectangle:\n \n-~~~ {.notrust}\n+~~~ {.text}\n Stack             Memory\n \n +-------+         +---------------+\n@@ -354,7 +354,7 @@ to store that shape value would still be valid, _it would have a\n different type_! The following diagram shows what memory would look\n like if code overwrote `shape` with a circle:\n \n-~~~ {.notrust}\n+~~~ {.text}\n Stack             Memory\n \n +-------+         +---------------+"}, {"sha": "5161dbc6bbb600a57ec32661f0cf9b819ae319cd", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -31,7 +31,7 @@ fn main() {\n \n And now I get an error:\n \n-~~~ {.notrust}\n+~~~text\n error: mismatched types: expected `&int` but found `<generic integer #0>` (expected &-ptr but found integral variable)\n ~~~\n \n@@ -201,7 +201,7 @@ fn main() {\n \n This prints:\n \n-~~~ {.notrust}\n+~~~text\n Cons(1, box Cons(2, box Cons(3, box Nil)))\n ~~~\n \n@@ -347,7 +347,7 @@ fn main() {\n \n It gives this error:\n \n-~~~ {.notrust}\n+~~~text\n test.rs:5:8: 5:10 error: cannot assign to `*x` because it is borrowed\n test.rs:5         *x -= 1;\n                   ^~"}, {"sha": "a1d89961840e2e915830ee6cfe781f51f82acb75", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -19,7 +19,7 @@ fn return_two_test() {\n To run these tests, compile with `rustc --test` and run the resulting\n binary:\n \n-~~~ {.notrust}\n+~~~console\n $ rustc --test foo.rs\n $ ./foo\n running 1 test\n@@ -111,7 +111,7 @@ sequentially.\n \n ### Typical test run\n \n-~~~ {.notrust}\n+~~~console\n $ mytests\n \n running 30 tests\n@@ -125,7 +125,7 @@ result: ok. 28 passed; 0 failed; 2 ignored\n \n ### Test run with failures\n \n-~~~ {.notrust}\n+~~~console\n $ mytests\n \n running 30 tests\n@@ -139,7 +139,7 @@ result: FAILED. 27 passed; 1 failed; 2 ignored\n \n ### Running ignored tests\n \n-~~~ {.notrust}\n+~~~console\n $ mytests --ignored\n \n running 2 tests\n@@ -153,7 +153,7 @@ result: FAILED. 1 passed; 1 failed; 0 ignored\n \n Using a plain string:\n \n-~~~ {.notrust}\n+~~~console\n $ mytests mytest23\n \n running 1 tests\n@@ -164,7 +164,7 @@ result: ok. 1 passed; 0 failed; 0 ignored\n \n Using some regular expression features:\n \n-~~~ {.notrust}\n+~~~console\n $ mytests 'mytest[145]'\n \n running 13 tests\n@@ -247,7 +247,7 @@ Advice on writing benchmarks:\n To run benchmarks, pass the `--bench` flag to the compiled\n test-runner. Benchmarks are compiled-in but not executed by default.\n \n-~~~ {.notrust}\n+~~~console\n $ rustc mytests.rs -O --test\n $ mytests --bench\n \n@@ -283,7 +283,7 @@ fn bench_xor_1000_ints(b: &mut Bencher) {\n \n gives the following results\n \n-~~~ {.notrust}\n+~~~console\n running 1 test\n test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)\n \n@@ -323,7 +323,7 @@ overhead (e.g. `black_box(&huge_struct)`).\n Performing either of the above changes gives the following\n benchmarking results\n \n-~~~ {.notrust}\n+~~~console\n running 1 test\n test bench_xor_1000_ints ... bench:       375 ns/iter (+/- 148)\n "}, {"sha": "50f57aca12f1fdcde33f935928a4d3c460a2f174", "filename": "src/doc/intro.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -22,7 +22,7 @@ and is the feature from which many of Rust's powerful capabilities are derived.\n write, and ultimately release, memory.\n Let's start by looking at some C++ code:\n \n-```notrust\n+```cpp\n int* dangling(void)\n {\n     int i = 1234;\n@@ -74,7 +74,7 @@ fn main() {\n \n Save this program as `dangling.rs`. When you try to compile this program with `rustc dangling.rs`, you'll get an interesting (and long) error message:\n \n-```notrust\n+```text\n dangling.rs:3:12: 3:14 error: `i` does not live long enough\n dangling.rs:3     return &i;\n                          ^~\n@@ -155,7 +155,7 @@ You can roughly compare these two lines:\n let i = box 1234;\n ```\n \n-```notrust\n+```cpp\n // C++\n int *i = new int;\n *i = 1234;\n@@ -254,7 +254,7 @@ fn main() {\n \n This will result an error indicating that the value is no longer in scope:\n \n-```notrust\n+```text\n concurrency.rs:12:20: 12:27 error: use of moved value: 'numbers'\n concurrency.rs:12     println!(\"{}\", numbers.get(0));\n                                      ^~~~~~~"}, {"sha": "00ec1bc36709d592ce7b665453cca80866bcf1f8", "filename": "src/doc/po/ja/tutorial.md.po", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -356,15 +356,15 @@ msgstr \"\u4e0a\u8a18\u6761\u4ef6\u3092\u6e80\u305f\u3057\u3066\u3044\u308c\u3070\u3001\u4ee5\u4e0b\u306e\u3088\u3046\u306a\u624b\u9806\u3067\u30d3\u30eb\n #: src/doc/tutorial.md:112\n #, fuzzy\n #| msgid \"\"\n-#| \"~~~~ {.notrust} $ curl -O http://static.rust-lang.org/dist/rust-nightly.tar.\"\n+#| \"~~~~console $ curl -O http://static.rust-lang.org/dist/rust-nightly.tar.\"\n #| \"gz $ tar -xzf rust-nightly.tar.gz $ cd rust-nightly $ ./configure $ make && make \"\n #| \"install ~~~~\"\n msgid \"\"\n-\"~~~~ {.notrust} $ curl -O http://static.rust-lang.org/dist/rust-nightly.tar.gz $ \"\n+\"~~~~console $ curl -O http://static.rust-lang.org/dist/rust-nightly.tar.gz $ \"\n \"tar -xzf rust-nightly.tar.gz $ cd rust-nightly $ ./configure $ make && make install \"\n \"~~~~\"\n msgstr \"\"\n-\"~~~~ {.notrust}\\n\"\n+\"~~~~console\\n\"\n \"$ curl -O http://static.rust-lang.org/dist/rust-nightly.tar.gz\\n\"\n \"$ tar -xzf rust-nightly.tar.gz $ cd rust-nightly $ ./configure\\n\"\n \"$ make && make install\\n\"\n@@ -4610,7 +4610,7 @@ msgstr \"\"\n #: src/doc/tutorial.md:2761 src/doc/tutorial.md:2793\n #, fuzzy\n #| msgid \"~~~~ {.ignore} let foo = 10;\"\n-msgid \"~~~ {.notrust} src/plants.rs src/plants/mod.rs\"\n+msgid \"~~~text src/plants.rs src/plants/mod.rs\"\n msgstr \"\"\n \"~~~~ {.ignore}\\n\"\n \"let foo = 10;\"\n@@ -4927,24 +4927,24 @@ msgstr \"\"\n #: src/doc/tutorial.md:3168\n #, fuzzy, no-wrap\n #| msgid \"\"\n-#| \"~~~~ {.notrust}\\n\"\n-#| \"> rustc --lib world.rs  # compiles libworld-94839cbfe144198-1.0.so\\n\"\n-#| \"> rustc main.rs -L .    # compiles main\\n\"\n-#| \"> ./main\\n\"\n+#| \"~~~~console\\n\"\n+#| \"$ rustc --lib world.rs  # compiles libworld-94839cbfe144198-1.0.so\\n\"\n+#| \"$ rustc main.rs -L .    # compiles main\\n\"\n+#| \"$ ./main\\n\"\n #| \"\\\"hello world\\\"\\n\"\n #| \"~~~~\\n\"\n msgid \"\"\n-\"~~~~ {.notrust}\\n\"\n-\"> rustc --lib world.rs  # compiles libworld-<HASH>-0.42.so\\n\"\n-\"> rustc main.rs -L .    # compiles main\\n\"\n-\"> ./main\\n\"\n+\"~~~~console\\n\"\n+\"$ rustc --crate-type=lib world.rs  # compiles libworld-<HASH>-0.42.so\\n\"\n+\"$ rustc main.rs -L .               # compiles main\\n\"\n+\"$ ./main\\n\"\n \"\\\"hello world\\\"\\n\"\n \"~~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.notrust}\\n\"\n-\"> rustc --lib world.rs  # libworld-94839cbfe144198-1.0.so \u304c\u751f\u6210\u3055\u308c\u308b\\n\"\n-\"> rustc main.rs -L .    # main \u304c\u751f\u6210\u3055\u308c\u308b\\n\"\n-\"> ./main\\n\"\n+\"~~~~console\\n\"\n+\"$ rustc --lib world.rs  # libworld-94839cbfe144198-1.0.so \u304c\u751f\u6210\u3055\u308c\u308b\\n\"\n+\"$ rustc main.rs -L .    # main \u304c\u751f\u6210\u3055\u308c\u308b\\n\"\n+\"$ ./main\\n\"\n \"\\\"hello world\\\"\\n\"\n \"~~~~\\n\"\n "}, {"sha": "b690c2eb983474635ccc9565b417576f06e09fd5", "filename": "src/doc/rust.md", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -59,7 +59,7 @@ dialect of EBNF supported by common automated LL(k) parsing tools such as\n `llgen`, rather than the dialect given in ISO 14977. The dialect can be\n defined self-referentially as follows:\n \n-~~~~ {.notrust .ebnf .notation}\n+~~~~ {.ebnf .notation}\n grammar : rule + ;\n rule    : nonterminal ':' productionrule ';' ;\n productionrule : production [ '|' production ] * ;\n@@ -153,7 +153,7 @@ Some productions are defined by exclusion of particular Unicode characters:\n \n ## Comments\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n comment : block_comment | line_comment ;\n block_comment : \"/*\" block_comment_body * '*' + '/' ;\n block_comment_body : [block_comment | character] * ;\n@@ -174,7 +174,7 @@ Non-doc comments are interpreted as a form of whitespace.\n \n ## Whitespace\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n whitespace_char : '\\x20' | '\\x09' | '\\x0a' | '\\x0d' ;\n whitespace : [ whitespace_char | comment ] + ;\n ~~~~\n@@ -191,7 +191,7 @@ with any other legal whitespace element, such as a single space character.\n \n ## Tokens\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n simple_token : keyword | unop | binop ;\n token : simple_token | ident | literal | symbol | whitespace token ;\n ~~~~\n@@ -205,7 +205,7 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n \n The keywords are the following strings:\n \n-~~~~ {.notrust .keyword}\n+~~~~ {.text .keyword}\n as\n box break\n continue crate\n@@ -233,13 +233,13 @@ evaluates to, rather than referring to it by name or some other evaluation\n rule. A literal is a form of constant expression, so is evaluated (primarily)\n at compile time.\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n literal : string_lit | char_lit | num_lit ;\n ~~~~\n \n #### Character and string literals\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n char_lit : '\\x27' char_body '\\x27' ;\n string_lit : '\"' string_body * '\"' | 'r' raw_string ;\n \n@@ -321,7 +321,7 @@ r##\"foo #\"# bar\"##;                // foo #\"# bar\n \n #### Number literals\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n num_lit : nonzero_dec [ dec_digit | '_' ] * num_suffix ?\n         | '0' [       [ dec_digit | '_' ] * num_suffix ?\n               | 'b'   [ '1' | '0' | '_' ] + int_suffix ?\n@@ -419,7 +419,7 @@ The two values of the boolean type are written `true` and `false`.\n \n ### Symbols\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n symbol : \"::\" \"->\"\n        | '#' | '[' | ']' | '(' | ')' | '{' | '}'\n        | ',' | ';' ;\n@@ -434,7 +434,7 @@ operators](#binary-operator-expressions), or [keywords](#keywords).\n \n ## Paths\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n expr_path : [ \"::\" ] ident [ \"::\" expr_path_tail ] + ;\n expr_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n                | expr_path ;\n@@ -543,7 +543,7 @@ All of the above extensions are expressions with values.\n \n ## Macros\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')' ;\n macro_rule : '(' matcher * ')' \"=>\" '(' transcriber * ')' ';' ;\n matcher : '(' matcher * ')' | '[' matcher * ']'\n@@ -687,7 +687,7 @@ each of which may have some number of [attributes](#attributes) attached to it.\n \n ## Items\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n item : mod_item | fn_item | type_item | struct_item | enum_item\n      | static_item | trait_item | impl_item | extern_block ;\n ~~~~\n@@ -735,7 +735,7 @@ That is, Rust has no notion of type abstraction: there are no first-class \"foral\n \n ### Modules\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n mod_item : \"mod\" ident ( ';' | '{' mod '}' );\n mod : [ view_item | item ] * ;\n ~~~~\n@@ -803,7 +803,7 @@ mod task {\n \n #### View items\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n view_item : extern_crate_decl | use_decl ;\n ~~~~\n \n@@ -816,7 +816,7 @@ There are several kinds of view item:\n \n ##### Extern crate declarations\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n extern_crate_decl : \"extern\" \"crate\" ident [ '(' link_attrs ')' ] ? [ '=' string_lit ] ? ;\n link_attrs : link_attr [ ',' link_attrs ] + ;\n link_attr : ident '=' literal ;\n@@ -848,7 +848,7 @@ extern crate foo = \"some/where/rust-foo#foo:1.0\"; // a full crate ID for externa\n \n ##### Use declarations\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n use_decl : \"pub\" ? \"use\" [ ident '=' path\n                           | path_glob ] ;\n \n@@ -1274,7 +1274,7 @@ whereas `Dog` is simply called an enum variant.\n \n ### Static items\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n static_item : \"static\" ident ':' type '=' expr ';' ;\n ~~~~\n \n@@ -1519,7 +1519,7 @@ impl Seq<bool> for u32 {\n \n ### External blocks\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n extern_block_item : \"extern\" '{' extern_block '}' ;\n extern_block : [ foreign_fn ] * ;\n ~~~~\n@@ -1741,7 +1741,7 @@ import public items from their destination, not private items.\n \n ## Attributes\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n attribute : '#' '!' ? '[' meta_item ']' ;\n meta_item : ident [ '=' literal\n                   | '(' meta_seq ')' ] ? ;\n@@ -2383,7 +2383,7 @@ declaring a function-local item.\n \n #### Slot declarations\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n init : [ '=' ] expr ;\n ~~~~\n@@ -2483,7 +2483,7 @@ values.\n \n ### Structure expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n struct_expr : expr_path '{' ident ':' expr\n                       [ ',' ident ':' expr ] *\n                       [ \"..\" expr ] '}' |\n@@ -2537,7 +2537,7 @@ Point3d {y: 0, z: 10, .. base};\n \n ### Block expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n block_expr : '{' [ view_item ] *\n                  [ stmt ';' | item ] *\n                  [ expr ] '}' ;\n@@ -2555,7 +2555,7 @@ of the block are that of the expression itself.\n \n ### Method-call expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n method_call_expr : expr '.' ident paren_expr_list ;\n ~~~~\n \n@@ -2566,7 +2566,7 @@ or dynamically dispatching if the left-hand-side expression is an indirect [obje\n \n ### Field expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n field_expr : expr '.' ident ;\n ~~~~\n \n@@ -2588,7 +2588,7 @@ it is automatically dereferenced to make the field access possible.\n \n ### Vector expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n vec_expr : '[' \"mut\" ? vec_elems? ']' ;\n \n vec_elems : [expr [',' expr]*] | [expr ',' \"..\" expr] ;\n@@ -2610,7 +2610,7 @@ as a [literal](#literals) or a [static item](#static-items).\n \n ### Index expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n idx_expr : expr '[' expr ']' ;\n ~~~~\n \n@@ -2662,7 +2662,7 @@ before the expression they apply to.\n \n ### Binary operator expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n binop_expr : expr binop expr ;\n ~~~~\n \n@@ -2803,7 +2803,7 @@ Any such expression always has the [`unit`](#primitive-types) type.\n The precedence of Rust binary operators is ordered as follows, going\n from strong to weak:\n \n-~~~~ {.notrust .precedence}\n+~~~~ {.text .precedence}\n * / %\n as\n + -\n@@ -2827,7 +2827,7 @@ An expression enclosed in parentheses evaluates to the result of the enclosed\n expression.  Parentheses can be used to explicitly specify evaluation order\n within an expression.\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n paren_expr : '(' expr ')' ;\n ~~~~\n \n@@ -2840,7 +2840,7 @@ let x = (2 + 3) * 4;\n \n ### Call expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n expr_list : [ expr [ ',' expr ]* ] ? ;\n paren_expr_list : '(' expr_list ')' ;\n call_expr : expr paren_expr_list ;\n@@ -2863,7 +2863,7 @@ let pi: Option<f32> = FromStr::from_str(\"3.14\");\n \n ### Lambda expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n ident_list : [ ident [ ',' ident ]* ] ? ;\n lambda_expr : '|' ident_list '|' expr ;\n ~~~~\n@@ -2906,7 +2906,7 @@ ten_times(|j| println!(\"hello, {}\", j));\n \n ### While loops\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n while_expr : \"while\" expr '{' block '}' ;\n ~~~~\n \n@@ -2930,7 +2930,7 @@ while i < 10 {\n \n A `loop` expression denotes an infinite loop.\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n loop_expr : [ lifetime ':' ] \"loop\" '{' block '}';\n ~~~~\n \n@@ -2941,7 +2941,7 @@ See [Break expressions](#break-expressions) and [Continue expressions](#continue\n \n ### Break expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n break_expr : \"break\" [ lifetime ];\n ~~~~\n \n@@ -2954,7 +2954,7 @@ but must enclose it.\n \n ### Continue expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n continue_expr : \"continue\" [ lifetime ];\n ~~~~\n \n@@ -2973,7 +2973,7 @@ A `continue` expression is only permitted in the body of a loop.\n \n ### For expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n for_expr : \"for\" pat \"in\" expr '{' block '}' ;\n ~~~~\n \n@@ -3007,7 +3007,7 @@ for i in range(0u, 256) {\n \n ### If expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n if_expr : \"if\" expr '{' block '}'\n           else_tail ? ;\n \n@@ -3028,7 +3028,7 @@ then any `else` block is executed.\n \n ### Match expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n match_expr : \"match\" expr '{' match_arm * '}' ;\n \n match_arm : attribute * match_pat \"=>\" [ expr \",\" | '{' block '}' ] ;\n@@ -3219,7 +3219,7 @@ let message = match maybe_digit {\n \n ### Return expressions\n \n-~~~~ {.notrust .ebnf .gram}\n+~~~~ {.ebnf .gram}\n return_expr : \"return\" expr ? ;\n ~~~~\n \n@@ -3496,7 +3496,7 @@ x = bo(5,7);\n \n ### Closure types\n \n-~~~~ {.notrust .ebnf .notation}\n+~~~~ {.ebnf .notation}\n closure_type := [ 'unsafe' ] [ '<' lifetime-list '>' ] '|' arg-list '|'\n                 [ ':' bound-list ] [ '->' type ]\n procedure_type := 'proc' [ '<' lifetime-list '>' ] '(' arg-list ')'\n@@ -4107,7 +4107,7 @@ fn main() {\n \n These four log levels correspond to levels 1-4, as controlled by `RUST_LOG`:\n \n-```notrust,bash\n+```sh\n $ RUST_LOG=rust=3 ./rust\n This is an error log\n This is a warn log"}, {"sha": "af69c6c1f7f159ada6e2115c991d707b55b0277d", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -122,33 +122,41 @@ source code.\n \n To test documentation, the `--test` argument is passed to rustdoc:\n \n-~~~ {.notrust}\n+~~~ {.sh}\n rustdoc --test crate.rs\n ~~~\n \n ## Defining tests\n \n Rust documentation currently uses the markdown format, and rustdoc treats all\n-code blocks as testable-by-default. In order to not run a test over a block of\n-code, the `ignore` string can be added to the three-backtick form of markdown\n-code block.\n+code blocks as testable-by-default unless they carry a language tag of another\n+language. In order to not run a test over a block of code, the `ignore` string\n+can be added to the three-backtick form of markdown code block.\n \n-~~~notrust\n+~~~md\n ```\n // This is a testable code block\n ```\n \n+```rust{.example}\n+// This is rust and also testable\n+```\n+\n ```ignore\n // This is not a testable code block\n ```\n \n     // This is a testable code block (4-space indent)\n+\n+```sh\n+# this is shell code and not tested\n+```\n ~~~\n \n You can specify that the test's execution should fail with the `should_fail`\n directive.\n \n-~~~notrust\n+~~~md\n ```should_fail\n // This code block is expected to generate a failure when run\n ```\n@@ -157,7 +165,7 @@ directive.\n You can specify that the code block should be compiled but not run with the\n `no_run` directive.\n \n-~~~notrust\n+~~~md\n ```no_run\n // This code will be compiled but not executed\n ```\n@@ -169,7 +177,7 @@ will not show up in the HTML documentation, but it will be used when\n testing the code block (NB. the space after the `#` is required, so\n that one can still write things like `#[deriving(Eq)]`).\n \n-~~~notrust\n+~~~md\n ```\n # /!\\ The three following lines are comments, which are usually stripped off by\n # the doc-generating tool.  In order to display them anyway in this particular\n@@ -194,7 +202,7 @@ uses is build on crate `test`, which is also used when you compile crates with\n rustc's `--test` flag. Extra arguments can be passed to rustdoc's test harness\n with the `--test-args` flag.\n \n-~~~ {.notrust}\n+~~~console\n # Only run tests containing 'foo' in their name\n $ rustdoc --test lib.rs --test-args 'foo'\n "}, {"sha": "4ee76952f0c9d4be8efa7c2bd0f403f9d7584254", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -106,7 +106,7 @@ packages:\n If you've fulfilled those prerequisites, something along these lines\n should work.\n \n-~~~~ {.notrust}\n+~~~~console\n $ curl -O http://static.rust-lang.org/dist/rust-nightly.tar.gz\n $ tar -xzf rust-nightly.tar.gz\n $ cd rust-nightly\n@@ -151,7 +151,7 @@ error. If you introduce an error into the program (for example, by changing\n `println!` to some nonexistent macro), and then compile it, you'll see\n an error message like this:\n \n-~~~~ {.notrust}\n+~~~~text\n hello.rs:2:5: 2:24 error: macro undefined: 'print_with_unicorns'\n hello.rs:2     print_with_unicorns!(\"hello?\");\n                ^~~~~~~~~~~~~~~~~~~\n@@ -1066,7 +1066,7 @@ being destroyed along with the owner. Since the `list` variable above is\n immutable, the whole list is immutable. The memory allocation itself is the\n box, while the owner holds onto a pointer to it:\n \n-~~~ {.notrust}\n+~~~text\n             List box            List box            List box          List box\n         +--------------+    +--------------+    +--------------+    +----------+\n list -> | Cons | 1 |   | -> | Cons | 2 |   | -> | Cons | 3 |   | -> | Nil      |\n@@ -2841,7 +2841,7 @@ mod animals {\n \n The compiler will look for these files, in this order:\n \n-~~~ {.notrust}\n+~~~text\n src/plants.rs\n src/plants/mod.rs\n \n@@ -2872,7 +2872,7 @@ mod mammals {\n \n ...then the source files of `mod animals`'s submodules can either be in the same directory as the animals source file or in a subdirectory of its directory. If the animals file is `src/animals.rs`, `rustc` will look for:\n \n-~~~ {.notrust}\n+~~~text\n src/animals.rs\n     src/fish.rs\n     src/fish/mod.rs\n@@ -2883,7 +2883,7 @@ src/animals.rs\n \n If the animals file is `src/animals/mod.rs`, `rustc` will look for:\n \n-~~~ {.notrust}\n+~~~text\n src/animals/mod.rs\n     src/animals/fish.rs\n     src/animals/fish/mod.rs\n@@ -3244,10 +3244,10 @@ fn main() { println!(\"hello {}\", world::explore()); }\n \n Now compile and run like this (adjust to your platform if necessary):\n \n-~~~~ {.notrust}\n-> rustc --crate-type=lib world.rs  # compiles libworld-<HASH>-0.42.so\n-> rustc main.rs -L .               # compiles main\n-> ./main\n+~~~~console\n+$ rustc --crate-type=lib world.rs  # compiles libworld-<HASH>-0.42.so\n+$ rustc main.rs -L .               # compiles main\n+$ ./main\n \"hello world\"\n ~~~~\n "}, {"sha": "3a847004df909aa88bf2b761cc18f334ae5288dd", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -59,7 +59,7 @@ pub trait Zero: Add<Self, Self> {\n     ///\n     /// # Laws\n     ///\n-    /// ~~~notrust\n+    /// ~~~text\n     /// a + 0 = a       \u2200 a \u2208 Self\n     /// 0 + a = a       \u2200 a \u2208 Self\n     /// ~~~\n@@ -123,7 +123,7 @@ pub trait One: Mul<Self, Self> {\n     ///\n     /// # Laws\n     ///\n-    /// ~~~notrust\n+    /// ~~~text\n     /// a * 1 = a       \u2200 a \u2208 Self\n     /// 1 * a = a       \u2200 a \u2208 Self\n     /// ~~~"}, {"sha": "ff5805599690d07a330fd0b1201b72cfbb0f8db1", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -57,7 +57,7 @@ disabled except for `error!` (a log level of 1). Logging is controlled via the\n `RUST_LOG` environment variable. The value of this environment variable is a\n comma-separated list of logging directives. A logging directive is of the form:\n \n-```notrust\n+```text\n path::to::module=log_level\n ```\n \n@@ -80,7 +80,7 @@ all modules is set to this value.\n \n Some examples of valid values of `RUST_LOG` are:\n \n-```notrust\n+```text\n hello                // turns on all logging for the 'hello' module\n info                 // turns on all info logging\n hello=debug          // turns on debug logging for 'hello'"}, {"sha": "cfabf2b08e2e81ce574b8f44f5c0eefbdb3de328", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -20,7 +20,7 @@ use super::{IndependentSample, Sample, Exp};\n ///\n /// The density function of this distribution is\n ///\n-/// ```notrust\n+/// ```text\n /// f(x) =  x^(k - 1) * exp(-x / \u03b8) / (\u0393(k) * \u03b8^k)\n /// ```\n ///"}, {"sha": "74faf7cf17c0c47061f4e958d59fd986fe0e0641", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -56,15 +56,15 @@ it is safe with respect to the in-scope loans.\n Throughout the docs we'll consider a simple subset of Rust in which\n you can only borrow from lvalues, defined like so:\n \n-```notrust\n+```text\n LV = x | LV.f | *LV\n ```\n \n Here `x` represents some variable, `LV.f` is a field reference,\n and `*LV` is a pointer dereference. There is no auto-deref or other\n niceties. This means that if you have a type like:\n \n-```notrust\n+```text\n struct S { f: uint }\n ```\n \n@@ -73,15 +73,15 @@ to an `LV` of `(*a).f`.\n \n Here is the formal grammar for the types we'll consider:\n \n-```notrust\n+```text\n TY = () | S<'LT...> | Box<TY> | & 'LT MQ TY | @ MQ TY\n MQ = mut | imm | const\n ```\n \n Most of these types should be pretty self explanatory. Here `S` is a\n struct name and we assume structs are declared like so:\n \n-```notrust\n+```text\n SD = struct S<'LT...> { (f: TY)... }\n ```\n \n@@ -93,7 +93,7 @@ SD = struct S<'LT...> { (f: TY)... }\n \n Now, imagine we had a program like this:\n \n-```notrust\n+```text\n struct Foo { f: uint, g: uint }\n ...\n 'a: {\n@@ -118,7 +118,7 @@ the borrow, and (3) a set of restrictions. In the code, `Loan` is a\n struct defined in `middle::borrowck`. Formally, we define `LOAN` as\n follows:\n \n-```notrust\n+```text\n LOAN = (LV, LT, MQ, RESTRICTION*)\n RESTRICTION = (LV, ACTION*)\n ACTION = MUTATE | CLAIM | FREEZE\n@@ -151,7 +151,7 @@ To give you a better feeling for what kind of restrictions derived\n from a loan, let's look at the loan `L` that would be issued as a\n result of the borrow `&mut (*x).f` in the example above:\n \n-```notrust\n+```text\n L = ((*x).f, 'a, mut, RS) where\n     RS = [((*x).f, [MUTATE, CLAIM, FREEZE]),\n           (*x, [MUTATE, CLAIM, FREEZE]),\n@@ -214,7 +214,7 @@ conditions that it uses. For simplicity I will ignore const loans.\n I will present the rules in a modified form of standard inference\n rules, which looks as follows:\n \n-```notrust\n+```text\n PREDICATE(X, Y, Z)                  // Rule-Name\n   Condition 1\n   Condition 2\n@@ -290,7 +290,7 @@ Let's begin with the rules for variables, which state that if a\n variable is declared as mutable, it may be borrowed any which way, but\n otherwise the variable must be borrowed as immutable or const:\n \n-```notrust\n+```text\n MUTABILITY(X, MQ)                   // M-Var-Mut\n   DECL(X) = mut\n \n@@ -305,7 +305,7 @@ Fields and owned pointers inherit their mutability from\n their base expressions, so both of their rules basically\n delegate the check to the base expression `LV`:\n \n-```notrust\n+```text\n MUTABILITY(LV.f, MQ)                // M-Field\n   MUTABILITY(LV, MQ)\n \n@@ -319,7 +319,7 @@ MUTABILITY(*LV, MQ)                 // M-Deref-Unique\n Immutable pointer types like `&T` and `@T` can only\n be borrowed if MQ is immutable or const:\n \n-```notrust\n+```text\n MUTABILITY(*LV, MQ)                // M-Deref-Borrowed-Imm\n   TYPE(LV) = &Ty\n   MQ == imm | const\n@@ -333,7 +333,7 @@ MUTABILITY(*LV, MQ)                // M-Deref-Managed-Imm\n \n `&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n \n-```notrust\n+```text\n MUTABILITY(*LV, MQ)                 // M-Deref-Borrowed-Mut\n   TYPE(LV) = &mut Ty\n ```\n@@ -352,15 +352,15 @@ Rust code corresponding to this predicate is the function\n Local variables are never aliasable as they are accessible only within\n the stack frame.\n \n-```notrust\n+```text\n     ALIASABLE(X, MQ)                   // M-Var-Mut\n ```\n \n ### Checking aliasable of owned content\n \n Owned content is aliasable if it is found in an aliasable location:\n \n-```notrust\n+```text\n ALIASABLE(LV.f, MQ)                // M-Field\n   ALIASABLE(LV, MQ)\n \n@@ -373,7 +373,7 @@ ALIASABLE(*LV, MQ)                 // M-Deref-Unique\n Immutable pointer types like `&T` are aliasable, and hence can only be\n borrowed immutably:\n \n-```notrust\n+```text\n ALIASABLE(*LV, imm)                // M-Deref-Borrowed-Imm\n   TYPE(LV) = &Ty\n ```\n@@ -382,7 +382,7 @@ ALIASABLE(*LV, imm)                // M-Deref-Borrowed-Imm\n \n `&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n \n-```notrust\n+```text\n ALIASABLE(*LV, MQ)                 // M-Deref-Borrowed-Mut\n   TYPE(LV) = &mut Ty\n ```\n@@ -405,37 +405,37 @@ guaranteed to exist, presuming that no mutations occur.\n \n The scope of a local variable is the block where it is declared:\n \n-```notrust\n+```text\n   SCOPE(X) = block where X is declared\n ```\n \n The scope of a field is the scope of the struct:\n \n-```notrust\n+```text\n   SCOPE(LV.f) = SCOPE(LV)\n ```\n \n The scope of a unique referent is the scope of the pointer, since\n (barring mutation or moves) the pointer will not be freed until\n the pointer itself `LV` goes out of scope:\n \n-```notrust\n+```text\n   SCOPE(*LV) = SCOPE(LV) if LV has type Box<T>\n ```\n \n The scope of a managed referent is also the scope of the pointer.  This\n is a conservative approximation, since there may be other aliases for\n that same managed box that would cause it to live longer:\n \n-```notrust\n+```text\n   SCOPE(*LV) = SCOPE(LV) if LV has type @T\n ```\n \n The scope of a borrowed referent is the scope associated with the\n pointer.  This is a conservative approximation, since the data that\n the pointer points at may actually live longer:\n \n-```notrust\n+```text\n   SCOPE(*LV) = LT if LV has type &'LT T or &'LT mut T\n ```\n \n@@ -444,7 +444,7 @@ the pointer points at may actually live longer:\n The rule for variables states that a variable can only be borrowed a\n lifetime `LT` that is a subregion of the variable's scope:\n \n-```notrust\n+```text\n LIFETIME(X, LT, MQ)                 // L-Local\n   LT <= SCOPE(X)\n ```\n@@ -454,7 +454,7 @@ LIFETIME(X, LT, MQ)                 // L-Local\n The lifetime of a field or owned pointer is the same as the lifetime\n of its owner:\n \n-```notrust\n+```text\n LIFETIME(LV.f, LT, MQ)              // L-Field\n   LIFETIME(LV, LT, MQ)\n \n@@ -471,7 +471,7 @@ lifetime. Therefore, the borrow is valid so long as the lifetime `LT`\n of the borrow is shorter than the lifetime `LT'` of the pointer\n itself:\n \n-```notrust\n+```text\n LIFETIME(*LV, LT, MQ)               // L-Deref-Borrowed\n   TYPE(LV) = &LT' Ty OR &LT' mut Ty\n   LT <= LT'\n@@ -484,7 +484,7 @@ Managed pointers are valid so long as the data within them is\n when the user guarantees such a root will exist. For this to be true,\n three conditions must be met:\n \n-```notrust\n+```text\n LIFETIME(*LV, LT, MQ)               // L-Deref-Managed-Imm-User-Root\n   TYPE(LV) = @Ty\n   LT <= SCOPE(LV)                   // (1)\n@@ -518,7 +518,7 @@ borrow without crossing the exit from the scope `LT`.\n \n The rule for compiler rooting is as follows:\n \n-```notrust\n+```text\n LIFETIME(*LV, LT, MQ)               // L-Deref-Managed-Imm-Compiler-Root\n   TYPE(LV) = @Ty\n   LT <= innermost enclosing loop/func\n@@ -542,7 +542,7 @@ for the lifetime of the loan\".\n Note that there is an initial set of restrictions: these restrictions\n are computed based on the kind of borrow:\n \n-```notrust\n+```text\n &mut LV =>   RESTRICTIONS(LV, LT, MUTATE|CLAIM|FREEZE)\n &LV =>       RESTRICTIONS(LV, LT, MUTATE|CLAIM)\n &const LV => RESTRICTIONS(LV, LT, [])\n@@ -559,7 +559,7 @@ moved out from under it, so no actions are forbidden.\n \n The simplest case is a borrow of a local variable `X`:\n \n-```notrust\n+```text\n RESTRICTIONS(X, LT, ACTIONS) = (X, ACTIONS)            // R-Variable\n ```\n \n@@ -570,7 +570,7 @@ In such cases we just record the actions that are not permitted.\n Restricting a field is the same as restricting the owner of that\n field:\n \n-```notrust\n+```text\n RESTRICTIONS(LV.f, LT, ACTIONS) = RS, (LV.f, ACTIONS)  // R-Field\n   RESTRICTIONS(LV, LT, ACTIONS) = RS\n ```\n@@ -593,7 +593,7 @@ must prevent the owned pointer `LV` from being mutated, which means\n that we always add `MUTATE` and `CLAIM` to the restriction set imposed\n on `LV`:\n \n-```notrust\n+```text\n RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Send-Pointer\n   TYPE(LV) = Box<Ty>\n   RESTRICTIONS(LV, LT, ACTIONS|MUTATE|CLAIM) = RS\n@@ -610,7 +610,7 @@ restricting that path. Therefore, the rule for `&Ty` and `@Ty`\n pointers always returns an empty set of restrictions, and it only\n permits restricting `MUTATE` and `CLAIM` actions:\n \n-```notrust\n+```text\n RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Managed\n   TYPE(LV) = @Ty\n   ACTIONS subset of [MUTATE, CLAIM]\n@@ -733,7 +733,7 @@ Because moves from a `&const` or `@const` lvalue are never legal, it\n is not necessary to add any restrictions at all to the final\n result.\n \n-```notrust\n+```text\n     RESTRICTIONS(*LV, LT, []) = []                         // R-Deref-Freeze-Borrowed\n       TYPE(LV) = &const Ty or @const Ty\n ```\n@@ -749,7 +749,7 @@ while the new claimant is live.\n \n The rule for mutable borrowed pointers is as follows:\n \n-```notrust\n+```text\n RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Mut-Borrowed\n   TYPE(LV) = &LT' mut Ty\n   LT <= LT'                                            // (1)"}, {"sha": "886550a3b246149c874ebd6dc3acf8ae45597d84", "filename": "src/librustc/middle/typeck/infer/doc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -45,7 +45,7 @@ There are several critical invariants which we maintain:\n > types lie in between.  The bottom type is then the Null type.\n > So the tree looks like:\n >\n-> ```notrust\n+> ```text\n >         Object\n >         /    \\\n >     String   Other\n@@ -106,7 +106,7 @@ Pictorally, what this does is to take two distinct variables with\n (hopefully not completely) distinct type ranges and produce one with\n the intersection.\n \n-```notrust\n+```text\n                   B.ub                  B.ub\n                    /\\                    /\n            A.ub   /  \\           A.ub   /\n@@ -129,7 +129,7 @@ bounds in such a way that, whatever happens, we know that A <: B will hold.\n This can be achieved by ensuring that A.ub <: B.lb.  In practice there\n are two ways to do that, depicted pictorally here:\n \n-```notrust\n+```text\n     Before                Option #1            Option #2\n \n              B.ub                B.ub                B.ub\n@@ -164,7 +164,7 @@ course, it depends on the program.\n \n The main case which fails today that I would like to support is:\n \n-```notrust\n+```text\n fn foo<T>(x: T, y: T) { ... }\n \n fn bar() {"}, {"sha": "406bdc48af3b24c0222c898247db1f5fed84acb5", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -168,7 +168,8 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                     slice::raw::buf_as_slice((*lang).data,\n                                            (*lang).size as uint, |rlang| {\n                         let rlang = str::from_utf8(rlang).unwrap();\n-                        if rlang.contains(\"notrust\") {\n+                        let (_,_,_,notrust) = parse_lang_string(rlang);\n+                        if notrust {\n                             (my_opaque.dfltblk)(ob, &buf, lang,\n                                                 opaque as *mut libc::c_void);\n                             true"}, {"sha": "fd3df63ebd4126006e69c0745d72363689fb60d1", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -85,7 +85,7 @@ function, but the `format!` macro is a syntax extension which allows it to\n leverage named parameters. Named parameters are listed at the end of the\n argument list and have the syntax:\n \n-```notrust\n+```text\n identifier '=' expression\n ```\n \n@@ -110,7 +110,7 @@ Each argument's type is dictated by the format string. It is a requirement that\n every argument is only ever referred to by one type. For example, this is an\n invalid format string:\n \n-```notrust\n+```text\n {0:d} {0:s}\n ```\n \n@@ -126,7 +126,7 @@ must have the type `uint`. Although a `uint` can be printed with `{:u}`, it is\n illegal to reference an argument as such. For example, this is another invalid\n format string:\n \n-```notrust\n+```text\n {:.*s} {0:u}\n ```\n \n@@ -347,7 +347,7 @@ This example is the equivalent of `{0:s}` essentially.\n The select method is a switch over a `&str` parameter, and the parameter *must*\n be of the type `&str`. An example of the syntax is:\n \n-```notrust\n+```text\n {0, select, male{...} female{...} other{...}}\n ```\n \n@@ -366,7 +366,7 @@ The plural method is a switch statement over a `uint` parameter, and the\n parameter *must* be a `uint`. A plural method in its full glory can be specified\n as:\n \n-```notrust\n+```text\n {0, plural, offset=1 =1{...} two{...} many{...} other{...}}\n ```\n \n@@ -394,7 +394,7 @@ should not be too alien. Arguments are formatted with python-like syntax,\n meaning that arguments are surrounded by `{}` instead of the C-like `%`. The\n actual grammar for the formatting syntax is:\n \n-```notrust\n+```text\n format_string := <text> [ format <text> ] *\n format := '{' [ argument ] [ ':' format_spec ] [ ',' function_spec ] '}'\n argument := integer | identifier"}, {"sha": "228f5f02beea4779390a269161923b2dd3dce518", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63e9b8f105ba0fe18e99cb280a23db82380960f4/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=63e9b8f105ba0fe18e99cb280a23db82380960f4", "patch": "@@ -102,7 +102,7 @@ above `PartialEq`, `A`, `B` and `C`.\n \n When generating the `expr` for the `A` impl, the `SubstructureFields` is\n \n-~~~notrust\n+~~~text\n Struct(~[FieldInfo {\n            span: <span of x>\n            name: Some(<ident of x>),\n@@ -113,7 +113,7 @@ Struct(~[FieldInfo {\n \n For the `B` impl, called with `B(a)` and `B(b)`,\n \n-~~~notrust\n+~~~text\n Struct(~[FieldInfo {\n           span: <span of `int`>,\n           name: None,\n@@ -127,7 +127,7 @@ Struct(~[FieldInfo {\n When generating the `expr` for a call with `self == C0(a)` and `other\n == C0(b)`, the SubstructureFields is\n \n-~~~notrust\n+~~~text\n EnumMatching(0, <ast::Variant for C0>,\n              ~[FieldInfo {\n                 span: <span of int>\n@@ -139,7 +139,7 @@ EnumMatching(0, <ast::Variant for C0>,\n \n For `C1 {x}` and `C1 {x}`,\n \n-~~~notrust\n+~~~text\n EnumMatching(1, <ast::Variant for C1>,\n              ~[FieldInfo {\n                 span: <span of x>\n@@ -151,7 +151,7 @@ EnumMatching(1, <ast::Variant for C1>,\n \n For `C0(a)` and `C1 {x}` ,\n \n-~~~notrust\n+~~~text\n EnumNonMatching(~[(0, <ast::Variant for B0>,\n                    ~[(<span of int>, None, <expr for &a>)]),\n                   (1, <ast::Variant for B1>,\n@@ -165,7 +165,7 @@ EnumNonMatching(~[(0, <ast::Variant for B0>,\n \n A static method on the above would result in,\n \n-~~~~notrust\n+~~~text\n StaticStruct(<ast::StructDef of A>, Named(~[(<ident of x>, <span of x>)]))\n \n StaticStruct(<ast::StructDef of B>, Unnamed(~[<span of x>]))\n@@ -793,7 +793,7 @@ impl<'a> MethodDef<'a> {\n     /**\n     Creates the nested matches for an enum definition recursively, i.e.\n \n-   ~~~notrust\n+   ~~~text\n     match self {\n        Variant1 => match other { Variant1 => matching, Variant2 => nonmatching, ... },\n        Variant2 => match other { Variant1 => nonmatching, Variant2 => matching, ... },"}]}