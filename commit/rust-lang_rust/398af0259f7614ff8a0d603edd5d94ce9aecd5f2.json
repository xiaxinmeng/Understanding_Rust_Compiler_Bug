{"sha": "398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "node_id": "C_kwDOAAsO6NoAKDM5OGFmMDI1OWY3NjE0ZmY4YTBkNjAzZWRkNWQ5NGNlOWFlY2Q1ZjI", "commit": {"author": {"name": "hecatia-elegua", "email": "108802164+hecatia-elegua@users.noreply.github.com", "date": "2023-04-11T19:14:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-11T19:14:52Z"}, "message": "Merge branch 'master' into alias-based-completion2", "tree": {"sha": "207fc25b5c6d73d5c7833fab11d24d2fa5a837d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/207fc25b5c6d73d5c7833fab11d24d2fa5a837d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkNbGsCRBK7hj4Ov3rIwAAkGMIAGfwuFuAll57ZjIAaUxXgHUs\n/BaH/8ftf4FVLVOVuwg+/abITCR4vcPhpgOYCfeG39vpQ400TcjJWDebTVj5ir8A\nxM8L6YXEnMazF6neUfInJAsbj9Yad4u8nrATx0PbIwSbpvGsK/pi0/shcN2GxADY\nIrLIkxGq49gFfXfzCykRnxIYmBoBqpKWtFaELTpEnb6wmP1ffUUHEp9TkUyCCEbe\n+PBuFkOskc3/ryeup9QoSUlnDHEbf0DQDmQX3UfTaA75xc9Yh25qCkIPFE62I1Pq\n0/h7vWkvXmM/4i54LBbf9+4TE58lCY+9dyK5l5EQb1wI0iJy4PBxo3nxbd0YWSY=\n=7OBr\n-----END PGP SIGNATURE-----\n", "payload": "tree 207fc25b5c6d73d5c7833fab11d24d2fa5a837d7\nparent 33ee157f3b05865984957953df21f4711f8e5cd6\nparent 7501d3b721560637e27f904d9fce79182c41bef7\nauthor hecatia-elegua <108802164+hecatia-elegua@users.noreply.github.com> 1681240492 +0200\ncommitter GitHub <noreply@github.com> 1681240492 +0200\n\nMerge branch 'master' into alias-based-completion2"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "html_url": "https://github.com/rust-lang/rust/commit/398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/comments", "author": {"login": "hecatia-elegua", "id": 108802164, "node_id": "U_kgDOBnwwdA", "avatar_url": "https://avatars.githubusercontent.com/u/108802164?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hecatia-elegua", "html_url": "https://github.com/hecatia-elegua", "followers_url": "https://api.github.com/users/hecatia-elegua/followers", "following_url": "https://api.github.com/users/hecatia-elegua/following{/other_user}", "gists_url": "https://api.github.com/users/hecatia-elegua/gists{/gist_id}", "starred_url": "https://api.github.com/users/hecatia-elegua/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hecatia-elegua/subscriptions", "organizations_url": "https://api.github.com/users/hecatia-elegua/orgs", "repos_url": "https://api.github.com/users/hecatia-elegua/repos", "events_url": "https://api.github.com/users/hecatia-elegua/events{/privacy}", "received_events_url": "https://api.github.com/users/hecatia-elegua/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33ee157f3b05865984957953df21f4711f8e5cd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/33ee157f3b05865984957953df21f4711f8e5cd6", "html_url": "https://github.com/rust-lang/rust/commit/33ee157f3b05865984957953df21f4711f8e5cd6"}, {"sha": "7501d3b721560637e27f904d9fce79182c41bef7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7501d3b721560637e27f904d9fce79182c41bef7", "html_url": "https://github.com/rust-lang/rust/commit/7501d3b721560637e27f904d9fce79182c41bef7"}], "stats": {"total": 11099, "additions": 5165, "deletions": 5934}, "files": [{"sha": "6293b11d1e89d9fb773bc9f59e9c6443d950d308", "filename": ".github/workflows/ci.yaml", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/.github%2Fworkflows%2Fci.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/.github%2Fworkflows%2Fci.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yaml?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -24,6 +24,9 @@ jobs:\n     runs-on: ${{ matrix.os }}\n     env:\n       CC: deny_c\n+      # we want to build r-a on stable to check that it keeps building on stable,\n+      # but we also want to test our proc-macro-srv which depends on nightly features\n+      RUSTC_BOOTSTRAP: 1\n \n     strategy:\n       fail-fast: false\n@@ -50,15 +53,15 @@ jobs:\n         run: sed -i '/\\[profile.dev]/a opt-level=1' Cargo.toml\n \n       - name: Compile (tests)\n-        run: cargo test --no-run --locked\n+        run: cargo test --no-run --locked  --features sysroot-abi\n \n       # It's faster to `test` before `build` \u00af\\_(\u30c4)_/\u00af\n       - name: Compile (rust-analyzer)\n         if: matrix.os == 'ubuntu-latest'\n-        run: cargo build --quiet\n+        run: cargo build --quiet --features sysroot-abi\n \n       - name: Test\n-        run: cargo test -- --nocapture --quiet\n+        run: cargo test --features sysroot-abi -- --nocapture --quiet\n \n       - name: Run analysis-stats on rust-analyzer\n         if: matrix.os == 'ubuntu-latest'"}, {"sha": "9d082215e85cbffc72b725767bad6531cbcc29da", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1250,6 +1250,7 @@ dependencies = [\n name = \"proc-macro-srv-cli\"\n version = \"0.0.0\"\n dependencies = [\n+ \"proc-macro-api\",\n  \"proc-macro-srv\",\n ]\n \n@@ -1457,7 +1458,7 @@ dependencies = [\n  \"parking_lot 0.12.1\",\n  \"parking_lot_core 0.9.6\",\n  \"proc-macro-api\",\n- \"proc-macro-srv\",\n+ \"proc-macro-srv-cli\",\n  \"profile\",\n  \"project-model\",\n  \"rayon\",\n@@ -1641,9 +1642,9 @@ checksum = \"a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0\"\n \n [[package]]\n name = \"smol_str\"\n-version = \"0.1.25\"\n+version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9d268d24892b932cac466d214af6ec8a3ec99873f0f8664d9a384b49596db682\"\n+checksum = \"74212e6bbe9a4352329b2f68ba3130c15a3f26fe88ff22dbdc6cdd58fa85e99c\"\n dependencies = [\n  \"serde\",\n ]"}, {"sha": "985a1844c734eeabbe92e81635d39785615932c4", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -77,6 +77,7 @@ vfs = { path = \"./crates/vfs\", version = \"0.0.0\" }\n \n # non-local crates\n smallvec = { version = \"1.10.0\", features = [\"const_new\", \"union\", \"const_generics\"] }\n+smol_str = \"0.2.0\"\n # the following crates are pinned to prevent us from pulling in syn 2 until all our dependencies have moved\n serde = { version = \"=1.0.156\", features = [\"derive\"] }\n serde_json = \"1.0.94\""}, {"sha": "f01f75b13874341dd378b708d3f4c30cb82ab52e", "filename": "crates/base-db/src/fixture.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fbase-db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fbase-db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Ffixture.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -4,15 +4,16 @@ use std::{mem, str::FromStr, sync::Arc};\n use cfg::CfgOptions;\n use rustc_hash::FxHashMap;\n use test_utils::{\n-    extract_range_or_offset, Fixture, RangeOrOffset, CURSOR_MARKER, ESCAPED_CURSOR_MARKER,\n+    extract_range_or_offset, Fixture, FixtureWithProjectMeta, RangeOrOffset, CURSOR_MARKER,\n+    ESCAPED_CURSOR_MARKER,\n };\n use tt::token_id::{Leaf, Subtree, TokenTree};\n use vfs::{file_set::FileSet, VfsPath};\n \n use crate::{\n     input::{CrateName, CrateOrigin, LangCrateOrigin},\n     Change, CrateDisplayName, CrateGraph, CrateId, Dependency, Edition, Env, FileId, FilePosition,\n-    FileRange, ProcMacro, ProcMacroExpander, ProcMacroExpansionError, ProcMacros,\n+    FileRange, ProcMacro, ProcMacroExpander, ProcMacroExpansionError, ProcMacros, ReleaseChannel,\n     SourceDatabaseExt, SourceRoot, SourceRootId,\n };\n \n@@ -102,7 +103,14 @@ impl ChangeFixture {\n         ra_fixture: &str,\n         mut proc_macro_defs: Vec<(String, ProcMacro)>,\n     ) -> ChangeFixture {\n-        let (mini_core, proc_macro_names, fixture) = Fixture::parse(ra_fixture);\n+        let FixtureWithProjectMeta { fixture, mini_core, proc_macro_names, toolchain } =\n+            FixtureWithProjectMeta::parse(ra_fixture);\n+        let toolchain = toolchain\n+            .map(|it| {\n+                ReleaseChannel::from_str(&it)\n+                    .unwrap_or_else(|| panic!(\"unknown release channel found: {it}\"))\n+            })\n+            .unwrap_or(ReleaseChannel::Stable);\n         let mut change = Change::new();\n \n         let mut files = Vec::new();\n@@ -166,7 +174,7 @@ impl ChangeFixture {\n                         .as_deref()\n                         .map(Arc::from)\n                         .ok_or_else(|| \"target_data_layout unset\".into()),\n-                    None,\n+                    Some(toolchain),\n                 );\n                 let prev = crates.insert(crate_name.clone(), crate_id);\n                 assert!(prev.is_none());\n@@ -205,7 +213,7 @@ impl ChangeFixture {\n                 default_target_data_layout\n                     .map(|x| x.into())\n                     .ok_or_else(|| \"target_data_layout unset\".into()),\n-                None,\n+                Some(toolchain),\n             );\n         } else {\n             for (from, to, prelude) in crate_deps {\n@@ -247,7 +255,7 @@ impl ChangeFixture {\n                 false,\n                 CrateOrigin::Lang(LangCrateOrigin::Core),\n                 target_layout.clone(),\n-                None,\n+                Some(toolchain),\n             );\n \n             for krate in all_crates {\n@@ -286,7 +294,7 @@ impl ChangeFixture {\n                 true,\n                 CrateOrigin::Local { repo: None, name: None },\n                 target_layout,\n-                None,\n+                Some(toolchain),\n             );\n             proc_macros.insert(proc_macros_crate, Ok(proc_macro));\n "}, {"sha": "cc59e780938c8b8c8400040abea6dc4b292fb75e", "filename": "crates/hir-def/src/attr.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,5 +1,7 @@\n //! A higher level attributes based on TokenTree, with also some shortcuts.\n \n+pub mod builtin;\n+\n #[cfg(test)]\n mod tests;\n \n@@ -267,6 +269,10 @@ impl Attrs {\n     pub fn is_proc_macro_derive(&self) -> bool {\n         self.by_key(\"proc_macro_derive\").exists()\n     }\n+\n+    pub fn is_unstable(&self) -> bool {\n+        self.by_key(\"unstable\").exists()\n+    }\n }\n \n use std::slice::Iter as SliceIter;"}, {"sha": "f7c1e683d0d20366df5ba7e87c910934deadca89", "filename": "crates/hir-def/src/attr/builtin.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr%2Fbuiltin.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "previous_filename": "crates/hir-def/src/builtin_attr.rs"}, {"sha": "9caa084f2a2a311b57db7583a7a884163720fc1c", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -13,18 +13,20 @@ use cfg::{CfgExpr, CfgOptions};\n use drop_bomb::DropBomb;\n use either::Either;\n use hir_expand::{\n-    attrs::RawAttrs, hygiene::Hygiene, ExpandError, ExpandResult, HirFileId, InFile, MacroCallId,\n+    ast_id_map::AstIdMap, attrs::RawAttrs, hygiene::Hygiene, name::Name, AstId, ExpandError,\n+    ExpandResult, HirFileId, InFile, MacroCallId,\n };\n use la_arena::{Arena, ArenaMap};\n use limit::Limit;\n+use once_cell::unsync::OnceCell;\n use profile::Count;\n use rustc_hash::FxHashMap;\n use syntax::{ast, AstPtr, SyntaxNode, SyntaxNodePtr};\n \n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n-    expr::{\n+    hir::{\n         dummy_expr_id, Binding, BindingId, Expr, ExprId, Label, LabelId, Pat, PatId, RecordFieldPat,\n     },\n     item_scope::BuiltinShadowMode,\n@@ -36,7 +38,43 @@ use crate::{\n     UnresolvedMacro,\n };\n \n-pub use lower::LowerCtx;\n+pub struct LowerCtx<'a> {\n+    pub db: &'a dyn DefDatabase,\n+    hygiene: Hygiene,\n+    ast_id_map: Option<(HirFileId, OnceCell<Arc<AstIdMap>>)>,\n+}\n+\n+impl<'a> LowerCtx<'a> {\n+    pub fn new(db: &'a dyn DefDatabase, hygiene: &Hygiene, file_id: HirFileId) -> Self {\n+        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: Some((file_id, OnceCell::new())) }\n+    }\n+\n+    pub fn with_file_id(db: &'a dyn DefDatabase, file_id: HirFileId) -> Self {\n+        LowerCtx {\n+            db,\n+            hygiene: Hygiene::new(db.upcast(), file_id),\n+            ast_id_map: Some((file_id, OnceCell::new())),\n+        }\n+    }\n+\n+    pub fn with_hygiene(db: &'a dyn DefDatabase, hygiene: &Hygiene) -> Self {\n+        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: None }\n+    }\n+\n+    pub(crate) fn hygiene(&self) -> &Hygiene {\n+        &self.hygiene\n+    }\n+\n+    pub(crate) fn lower_path(&self, ast: ast::Path) -> Option<Path> {\n+        Path::from_src(ast, self)\n+    }\n+\n+    pub(crate) fn ast_id<N: syntax::AstNode>(&self, item: &N) -> Option<AstId<N>> {\n+        let &(file_id, ref ast_id_map) = self.ast_id_map.as_ref()?;\n+        let ast_id_map = ast_id_map.get_or_init(|| self.db.ast_id_map(file_id));\n+        Some(InFile::new(file_id, ast_id_map.ast_id(item)))\n+    }\n+}\n \n /// A subset of Expander that only deals with cfg attributes. We only need it to\n /// avoid cyclic queries in crate def map during enum processing.\n@@ -76,6 +114,10 @@ impl CfgExpander {\n         let attrs = self.parse_attrs(db, owner);\n         attrs.is_cfg_enabled(&self.cfg_options)\n     }\n+\n+    pub(crate) fn hygiene(&self) -> &Hygiene {\n+        &self.hygiene\n+    }\n }\n \n impl Expander {\n@@ -180,6 +222,10 @@ impl Expander {\n         mark.bomb.defuse();\n     }\n \n+    pub fn ctx<'a>(&self, db: &'a dyn DefDatabase) -> LowerCtx<'a> {\n+        LowerCtx::new(db, &self.cfg_expander.hygiene, self.current_file_id)\n+    }\n+\n     pub(crate) fn to_source<T>(&self, value: T) -> InFile<T> {\n         InFile { file_id: self.current_file_id, value }\n     }\n@@ -232,7 +278,7 @@ impl Expander {\n             // The overflow error should have been reported when it occurred (see the next branch),\n             // so don't return overflow error here to avoid diagnostics duplication.\n             cov_mark::hit!(overflow_but_not_me);\n-            return ExpandResult::only_err(ExpandError::RecursionOverflowPosioned);\n+            return ExpandResult::only_err(ExpandError::RecursionOverflowPoisoned);\n         } else if self.recursion_limit(db).check(self.recursion_depth + 1).is_err() {\n             self.recursion_depth = usize::MAX;\n             cov_mark::hit!(your_stack_belongs_to_me);\n@@ -343,6 +389,8 @@ pub enum BodyDiagnostic {\n     MacroError { node: InFile<AstPtr<ast::MacroCall>>, message: String },\n     UnresolvedProcMacro { node: InFile<AstPtr<ast::MacroCall>>, krate: CrateId },\n     UnresolvedMacroCall { node: InFile<AstPtr<ast::MacroCall>>, path: ModPath },\n+    UnreachableLabel { node: InFile<AstPtr<ast::Lifetime>>, name: Name },\n+    UndeclaredLabel { node: InFile<AstPtr<ast::Lifetime>>, name: Name },\n }\n \n impl Body {"}, {"sha": "688c9e86bbb614b9659c7a4220293eda44791378", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 373, "deletions": 268, "changes": 641, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -7,77 +7,38 @@ use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n     ast_id_map::AstIdMap,\n-    hygiene::Hygiene,\n     name::{name, AsName, Name},\n-    AstId, ExpandError, HirFileId, InFile,\n+    AstId, ExpandError, InFile,\n };\n use intern::Interned;\n use la_arena::Arena;\n-use once_cell::unsync::OnceCell;\n use profile::Count;\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use syntax::{\n     ast::{\n-        self, ArrayExprKind, AstChildren, BlockExpr, HasArgList, HasLoopBody, HasName, LiteralKind,\n+        self, ArrayExprKind, AstChildren, BlockExpr, HasArgList, HasLoopBody, HasName,\n         SlicePatComponents,\n     },\n     AstNode, AstPtr, SyntaxNodePtr,\n };\n \n use crate::{\n-    adt::StructKind,\n-    body::{Body, BodySourceMap, Expander, ExprPtr, LabelPtr, LabelSource, PatPtr},\n-    body::{BodyDiagnostic, ExprSource, PatSource},\n-    builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n+    body::{Body, BodyDiagnostic, BodySourceMap, Expander, ExprPtr, LabelPtr, LowerCtx, PatPtr},\n+    data::adt::StructKind,\n     db::DefDatabase,\n-    expr::{\n-        dummy_expr_id, Array, Binding, BindingAnnotation, BindingId, ClosureKind, Expr, ExprId,\n-        FloatTypeWrapper, Label, LabelId, Literal, MatchArm, Movability, Pat, PatId,\n-        RecordFieldPat, RecordLitField, Statement,\n+    hir::{\n+        dummy_expr_id, Array, Binding, BindingAnnotation, BindingId, CaptureBy, ClosureKind, Expr,\n+        ExprId, Label, LabelId, Literal, MatchArm, Movability, Pat, PatId, RecordFieldPat,\n+        RecordLitField, Statement,\n     },\n     item_scope::BuiltinShadowMode,\n-    item_tree::ItemTree,\n     lang_item::LangItem,\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n     AdtId, BlockId, BlockLoc, ModuleDefId, UnresolvedMacro,\n };\n \n-pub struct LowerCtx<'a> {\n-    pub db: &'a dyn DefDatabase,\n-    hygiene: Hygiene,\n-    ast_id_map: Option<(HirFileId, OnceCell<Arc<AstIdMap>>)>,\n-}\n-\n-impl<'a> LowerCtx<'a> {\n-    pub fn new(db: &'a dyn DefDatabase, file_id: HirFileId) -> Self {\n-        LowerCtx {\n-            db,\n-            hygiene: Hygiene::new(db.upcast(), file_id),\n-            ast_id_map: Some((file_id, OnceCell::new())),\n-        }\n-    }\n-\n-    pub fn with_hygiene(db: &'a dyn DefDatabase, hygiene: &Hygiene) -> Self {\n-        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: None }\n-    }\n-\n-    pub(crate) fn hygiene(&self) -> &Hygiene {\n-        &self.hygiene\n-    }\n-\n-    pub(crate) fn lower_path(&self, ast: ast::Path) -> Option<Path> {\n-        Path::from_src(ast, self)\n-    }\n-\n-    pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> Option<AstId<N>> {\n-        let &(file_id, ref ast_id_map) = self.ast_id_map.as_ref()?;\n-        let ast_id_map = ast_id_map.get_or_init(|| self.db.ast_id_map(file_id));\n-        Some(InFile::new(file_id, ast_id_map.ast_id(item)))\n-    }\n-}\n-\n pub(super) fn lower(\n     db: &dyn DefDatabase,\n     expander: Expander,\n@@ -102,9 +63,11 @@ pub(super) fn lower(\n             _c: Count::new(),\n         },\n         expander,\n-        current_try_block: None,\n+        current_try_block_label: None,\n         is_lowering_assignee_expr: false,\n         is_lowering_generator: false,\n+        label_ribs: Vec::new(),\n+        current_binding_owner: None,\n     }\n     .collect(params, body, is_async_fn)\n }\n@@ -113,12 +76,57 @@ struct ExprCollector<'a> {\n     db: &'a dyn DefDatabase,\n     expander: Expander,\n     ast_id_map: Arc<AstIdMap>,\n-    body: Body,\n     krate: CrateId,\n+    body: Body,\n     source_map: BodySourceMap,\n-    current_try_block: Option<LabelId>,\n+\n     is_lowering_assignee_expr: bool,\n     is_lowering_generator: bool,\n+\n+    current_try_block_label: Option<LabelId>,\n+    // points to the expression that a try expression will target (replaces current_try_block_label)\n+    // catch_scope: Option<ExprId>,\n+    // points to the expression that an unlabeled control flow will target\n+    // loop_scope: Option<ExprId>,\n+    // needed to diagnose non label control flow in while conditions\n+    // is_in_loop_condition: bool,\n+\n+    // resolution\n+    label_ribs: Vec<LabelRib>,\n+    current_binding_owner: Option<ExprId>,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct LabelRib {\n+    kind: RibKind,\n+    // Once we handle macro hygiene this will need to be a map\n+    label: Option<(Name, LabelId)>,\n+}\n+\n+impl LabelRib {\n+    fn new(kind: RibKind) -> Self {\n+        LabelRib { kind, label: None }\n+    }\n+    fn new_normal(label: (Name, LabelId)) -> Self {\n+        LabelRib { kind: RibKind::Normal, label: Some(label) }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum RibKind {\n+    Normal,\n+    Closure,\n+    Constant,\n+}\n+\n+impl RibKind {\n+    /// This rib forbids referring to labels defined in upwards ribs.\n+    fn is_label_barrier(self) -> bool {\n+        match self {\n+            RibKind::Normal => false,\n+            RibKind::Closure | RibKind::Constant => true,\n+        }\n+    }\n }\n \n #[derive(Debug, Default)]\n@@ -162,97 +170,35 @@ impl ExprCollector<'_> {\n                 self.body.params.push(param_pat);\n             }\n \n-            for pat in param_list\n-                .params()\n-                .zip(attr_enabled)\n-                .filter_map(|(param, enabled)| param.pat().filter(|_| enabled))\n+            for (param, _) in param_list.params().zip(attr_enabled).filter(|(_, enabled)| *enabled)\n             {\n-                let param_pat = self.collect_pat(pat);\n+                let param_pat = self.collect_pat_top(param.pat());\n                 self.body.params.push(param_pat);\n             }\n         };\n+        self.body.body_expr = self.with_label_rib(RibKind::Closure, |this| {\n+            if is_async_fn {\n+                match body {\n+                    Some(e) => {\n+                        let expr = this.collect_expr(e);\n+                        this.alloc_expr_desugared(Expr::Async {\n+                            id: None,\n+                            statements: Box::new([]),\n+                            tail: Some(expr),\n+                        })\n+                    }\n+                    None => this.missing_expr(),\n+                }\n+            } else {\n+                this.collect_expr_opt(body)\n+            }\n+        });\n \n-        self.body.body_expr = if is_async_fn {\n-            self.current_try_block =\n-                Some(self.alloc_label_desugared(Label { name: Name::generate_new_name() }));\n-            let expr = self.collect_expr_opt(body);\n-            let expr = self.alloc_expr_desugared(Expr::Block {\n-                id: None,\n-                statements: Box::new([]),\n-                tail: Some(expr),\n-                label: self.current_try_block,\n-            });\n-            let expr = self.alloc_expr_desugared(Expr::Async {\n-                id: None,\n-                statements: Box::new([]),\n-                tail: Some(expr),\n-            });\n-            expr\n-        } else {\n-            self.collect_expr_opt(body)\n-        };\n         (self.body, self.source_map)\n     }\n \n     fn ctx(&self) -> LowerCtx<'_> {\n-        LowerCtx::new(self.db, self.expander.current_file_id)\n-    }\n-\n-    fn alloc_expr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {\n-        let src = self.expander.to_source(ptr);\n-        let id = self.make_expr(expr, src.clone());\n-        self.source_map.expr_map.insert(src, id);\n-        id\n-    }\n-    // FIXME: desugared exprs don't have ptr, that's wrong and should be fixed somehow.\n-    fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n-        self.body.exprs.alloc(expr)\n-    }\n-    fn missing_expr(&mut self) -> ExprId {\n-        self.alloc_expr_desugared(Expr::Missing)\n-    }\n-    fn make_expr(&mut self, expr: Expr, src: ExprSource) -> ExprId {\n-        let id = self.body.exprs.alloc(expr);\n-        self.source_map.expr_map_back.insert(id, src);\n-        id\n-    }\n-\n-    fn alloc_binding(&mut self, name: Name, mode: BindingAnnotation) -> BindingId {\n-        self.body.bindings.alloc(Binding { name, mode, definitions: SmallVec::new() })\n-    }\n-    fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n-        let src = self.expander.to_source(ptr);\n-        let id = self.make_pat(pat, src.clone());\n-        self.source_map.pat_map.insert(src, id);\n-        id\n-    }\n-    // FIXME: desugared pats don't have ptr, that's wrong and should be fixed somehow.\n-    fn alloc_pat_desugared(&mut self, pat: Pat) -> PatId {\n-        self.body.pats.alloc(pat)\n-    }\n-    fn missing_pat(&mut self) -> PatId {\n-        self.body.pats.alloc(Pat::Missing)\n-    }\n-    fn make_pat(&mut self, pat: Pat, src: PatSource) -> PatId {\n-        let id = self.body.pats.alloc(pat);\n-        self.source_map.pat_map_back.insert(id, src);\n-        id\n-    }\n-\n-    fn alloc_label(&mut self, label: Label, ptr: LabelPtr) -> LabelId {\n-        let src = self.expander.to_source(ptr);\n-        let id = self.make_label(label, src.clone());\n-        self.source_map.label_map.insert(src, id);\n-        id\n-    }\n-    // FIXME: desugared labels don't have ptr, that's wrong and should be fixed somehow.\n-    fn alloc_label_desugared(&mut self, label: Label) -> LabelId {\n-        self.body.labels.alloc(label)\n-    }\n-    fn make_label(&mut self, label: Label, src: LabelSource) -> LabelId {\n-        let id = self.body.labels.alloc(label);\n-        self.source_map.label_map_back.insert(id, src);\n-        id\n+        self.expander.ctx(self.db)\n     }\n \n     fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n@@ -264,6 +210,7 @@ impl ExprCollector<'_> {\n         let syntax_ptr = AstPtr::new(&expr);\n         self.check_cfg(&expr)?;\n \n+        // FIXME: Move some of these arms out into separate methods for clarity\n         Some(match expr {\n             ast::Expr::IfExpr(e) => {\n                 let then_branch = self.collect_block_opt(e.then_branch());\n@@ -281,12 +228,12 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n             }\n             ast::Expr::LetExpr(e) => {\n-                let pat = self.collect_pat_opt(e.pat());\n+                let pat = self.collect_pat_top(e.pat());\n                 let expr = self.collect_expr_opt(e.expr());\n                 self.alloc_expr(Expr::Let { pat, expr }, syntax_ptr)\n             }\n             ast::Expr::BlockExpr(e) => match e.modifier() {\n-                Some(ast::BlockModifier::Try(_)) => self.collect_try_block(e),\n+                Some(ast::BlockModifier::Try(_)) => self.desugar_try_block(e),\n                 Some(ast::BlockModifier::Unsafe(_)) => {\n                     self.collect_block_(e, |id, statements, tail| Expr::Unsafe {\n                         id,\n@@ -296,37 +243,57 @@ impl ExprCollector<'_> {\n                 }\n                 Some(ast::BlockModifier::Label(label)) => {\n                     let label = self.collect_label(label);\n-                    self.collect_block_(e, |id, statements, tail| Expr::Block {\n-                        id,\n-                        statements,\n-                        tail,\n-                        label: Some(label),\n+                    self.with_labeled_rib(label, |this| {\n+                        this.collect_block_(e, |id, statements, tail| Expr::Block {\n+                            id,\n+                            statements,\n+                            tail,\n+                            label: Some(label),\n+                        })\n+                    })\n+                }\n+                Some(ast::BlockModifier::Async(_)) => {\n+                    self.with_label_rib(RibKind::Closure, |this| {\n+                        this.collect_block_(e, |id, statements, tail| Expr::Async {\n+                            id,\n+                            statements,\n+                            tail,\n+                        })\n+                    })\n+                }\n+                Some(ast::BlockModifier::Const(_)) => {\n+                    self.with_label_rib(RibKind::Constant, |this| {\n+                        this.collect_as_a_binding_owner_bad(\n+                            |this| {\n+                                this.collect_block_(e, |id, statements, tail| Expr::Const {\n+                                    id,\n+                                    statements,\n+                                    tail,\n+                                })\n+                            },\n+                            syntax_ptr,\n+                        )\n                     })\n                 }\n-                Some(ast::BlockModifier::Async(_)) => self\n-                    .collect_block_(e, |id, statements, tail| Expr::Async { id, statements, tail }),\n-                Some(ast::BlockModifier::Const(_)) => self\n-                    .collect_block_(e, |id, statements, tail| Expr::Const { id, statements, tail }),\n                 None => self.collect_block(e),\n             },\n             ast::Expr::LoopExpr(e) => {\n                 let label = e.label().map(|label| self.collect_label(label));\n-                let body = self.collect_block_opt(e.loop_body());\n+                let body = self.collect_labelled_block_opt(label, e.loop_body());\n                 self.alloc_expr(Expr::Loop { body, label }, syntax_ptr)\n             }\n             ast::Expr::WhileExpr(e) => {\n                 let label = e.label().map(|label| self.collect_label(label));\n-                let body = self.collect_block_opt(e.loop_body());\n-\n+                let body = self.collect_labelled_block_opt(label, e.loop_body());\n                 let condition = self.collect_expr_opt(e.condition());\n \n                 self.alloc_expr(Expr::While { condition, body, label }, syntax_ptr)\n             }\n             ast::Expr::ForExpr(e) => {\n                 let label = e.label().map(|label| self.collect_label(label));\n                 let iterable = self.collect_expr_opt(e.iterable());\n-                let pat = self.collect_pat_opt(e.pat());\n-                let body = self.collect_block_opt(e.loop_body());\n+                let pat = self.collect_pat_top(e.pat());\n+                let body = self.collect_labelled_block_opt(label, e.loop_body());\n                 self.alloc_expr(Expr::For { iterable, pat, body, label }, syntax_ptr)\n             }\n             ast::Expr::CallExpr(e) => {\n@@ -365,7 +332,7 @@ impl ExprCollector<'_> {\n                         .arms()\n                         .filter_map(|arm| {\n                             self.check_cfg(&arm).map(|()| MatchArm {\n-                                pat: self.collect_pat_opt(arm.pat()),\n+                                pat: self.collect_pat_top(arm.pat()),\n                                 expr: self.collect_expr_opt(arm.expr()),\n                                 guard: arm\n                                     .guard()\n@@ -386,16 +353,20 @@ impl ExprCollector<'_> {\n                     .unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n             }\n-            ast::Expr::ContinueExpr(e) => self.alloc_expr(\n-                Expr::Continue { label: e.lifetime().map(|l| Name::new_lifetime(&l)) },\n-                syntax_ptr,\n-            ),\n+            ast::Expr::ContinueExpr(e) => {\n+                let label = self.resolve_label(e.lifetime()).unwrap_or_else(|e| {\n+                    self.source_map.diagnostics.push(e);\n+                    None\n+                });\n+                self.alloc_expr(Expr::Continue { label }, syntax_ptr)\n+            }\n             ast::Expr::BreakExpr(e) => {\n+                let label = self.resolve_label(e.lifetime()).unwrap_or_else(|e| {\n+                    self.source_map.diagnostics.push(e);\n+                    None\n+                });\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n-                self.alloc_expr(\n-                    Expr::Break { expr, label: e.lifetime().map(|l| Name::new_lifetime(&l)) },\n-                    syntax_ptr,\n-                )\n+                self.alloc_expr(Expr::Break { expr, label }, syntax_ptr)\n             }\n             ast::Expr::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n@@ -496,29 +467,30 @@ impl ExprCollector<'_> {\n                     None => self.alloc_expr(Expr::Missing, syntax_ptr),\n                 }\n             }\n-            ast::Expr::ClosureExpr(e) => {\n+            ast::Expr::ClosureExpr(e) => self.with_label_rib(RibKind::Closure, |this| {\n+                let (result_expr_id, prev_binding_owner) =\n+                    this.initialize_binding_owner(syntax_ptr);\n                 let mut args = Vec::new();\n                 let mut arg_types = Vec::new();\n                 if let Some(pl) = e.param_list() {\n                     for param in pl.params() {\n-                        let pat = self.collect_pat_opt(param.pat());\n+                        let pat = this.collect_pat_top(param.pat());\n                         let type_ref =\n-                            param.ty().map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n+                            param.ty().map(|it| Interned::new(TypeRef::from_ast(&this.ctx(), it)));\n                         args.push(pat);\n                         arg_types.push(type_ref);\n                     }\n                 }\n                 let ret_type = e\n                     .ret_type()\n                     .and_then(|r| r.ty())\n-                    .map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n+                    .map(|it| Interned::new(TypeRef::from_ast(&this.ctx(), it)));\n \n-                let prev_is_lowering_generator = self.is_lowering_generator;\n-                self.is_lowering_generator = false;\n+                let prev_is_lowering_generator = mem::take(&mut this.is_lowering_generator);\n \n-                let body = self.collect_expr_opt(e.body());\n+                let body = this.collect_expr_opt(e.body());\n \n-                let closure_kind = if self.is_lowering_generator {\n+                let closure_kind = if this.is_lowering_generator {\n                     let movability = if e.static_token().is_some() {\n                         Movability::Static\n                     } else {\n@@ -530,19 +502,21 @@ impl ExprCollector<'_> {\n                 } else {\n                     ClosureKind::Closure\n                 };\n-                self.is_lowering_generator = prev_is_lowering_generator;\n-\n-                self.alloc_expr(\n-                    Expr::Closure {\n-                        args: args.into(),\n-                        arg_types: arg_types.into(),\n-                        ret_type,\n-                        body,\n-                        closure_kind,\n-                    },\n-                    syntax_ptr,\n-                )\n-            }\n+                this.is_lowering_generator = prev_is_lowering_generator;\n+                let capture_by =\n+                    if e.move_token().is_some() { CaptureBy::Value } else { CaptureBy::Ref };\n+                this.is_lowering_generator = prev_is_lowering_generator;\n+                this.current_binding_owner = prev_binding_owner;\n+                this.body.exprs[result_expr_id] = Expr::Closure {\n+                    args: args.into(),\n+                    arg_types: arg_types.into(),\n+                    ret_type,\n+                    body,\n+                    closure_kind,\n+                    capture_by,\n+                };\n+                result_expr_id\n+            }),\n             ast::Expr::BinExpr(e) => {\n                 let op = e.op_kind();\n                 if let Some(ast::BinaryOp::Assignment { op: None }) = op {\n@@ -581,7 +555,17 @@ impl ExprCollector<'_> {\n                     }\n                     ArrayExprKind::Repeat { initializer, repeat } => {\n                         let initializer = self.collect_expr_opt(initializer);\n-                        let repeat = self.collect_expr_opt(repeat);\n+                        let repeat = self.with_label_rib(RibKind::Constant, |this| {\n+                            if let Some(repeat) = repeat {\n+                                let syntax_ptr = AstPtr::new(&repeat);\n+                                this.collect_as_a_binding_owner_bad(\n+                                    |this| this.collect_expr(repeat),\n+                                    syntax_ptr,\n+                                )\n+                            } else {\n+                                this.missing_expr()\n+                            }\n+                        });\n                         self.alloc_expr(\n                             Expr::Array(Array::Repeat { initializer, repeat }),\n                             syntax_ptr,\n@@ -627,23 +611,53 @@ impl ExprCollector<'_> {\n         })\n     }\n \n+    fn initialize_binding_owner(\n+        &mut self,\n+        syntax_ptr: AstPtr<ast::Expr>,\n+    ) -> (ExprId, Option<ExprId>) {\n+        let result_expr_id = self.alloc_expr(Expr::Missing, syntax_ptr);\n+        let prev_binding_owner = self.current_binding_owner.take();\n+        self.current_binding_owner = Some(result_expr_id);\n+        (result_expr_id, prev_binding_owner)\n+    }\n+\n+    /// FIXME: This function is bad. It will produce a dangling `Missing` expr which wastes memory. Currently\n+    /// it is used only for const blocks and repeat expressions, which are also hacky and ideally should have\n+    /// their own body. Don't add more usage for this function so that we can remove this function after\n+    /// separating those bodies.\n+    fn collect_as_a_binding_owner_bad(\n+        &mut self,\n+        job: impl FnOnce(&mut ExprCollector<'_>) -> ExprId,\n+        syntax_ptr: AstPtr<ast::Expr>,\n+    ) -> ExprId {\n+        let (id, prev_owner) = self.initialize_binding_owner(syntax_ptr);\n+        let tmp = job(self);\n+        self.body.exprs[id] = mem::replace(&mut self.body.exprs[tmp], Expr::Missing);\n+        self.current_binding_owner = prev_owner;\n+        id\n+    }\n+\n     /// Desugar `try { <stmts>; <expr> }` into `'<new_label>: { <stmts>; ::std::ops::Try::from_output(<expr>) }`,\n     /// `try { <stmts>; }` into `'<new_label>: { <stmts>; ::std::ops::Try::from_output(()) }`\n     /// and save the `<new_label>` to use it as a break target for desugaring of the `?` operator.\n-    fn collect_try_block(&mut self, e: BlockExpr) -> ExprId {\n+    fn desugar_try_block(&mut self, e: BlockExpr) -> ExprId {\n         let Some(try_from_output) = LangItem::TryTraitFromOutput.path(self.db, self.krate) else {\n-            return self.alloc_expr_desugared(Expr::Missing);\n+            return self.collect_block(e);\n         };\n-        let prev_try_block = self.current_try_block.take();\n-        self.current_try_block =\n-            Some(self.alloc_label_desugared(Label { name: Name::generate_new_name() }));\n-        let expr_id = self.collect_block(e);\n+        let label = self.alloc_label_desugared(Label { name: Name::generate_new_name() });\n+        let old_label = self.current_try_block_label.replace(label);\n+\n+        let (btail, expr_id) = self.with_labeled_rib(label, |this| {\n+            let mut btail = None;\n+            let block = this.collect_block_(e, |id, statements, tail| {\n+                btail = tail;\n+                Expr::Block { id, statements, tail, label: Some(label) }\n+            });\n+            (btail, block)\n+        });\n+\n         let callee = self.alloc_expr_desugared(Expr::Path(try_from_output));\n-        let Expr::Block { label, tail, .. } = &mut self.body.exprs[expr_id] else {\n-            unreachable!(\"It is the output of collect block\");\n-        };\n-        *label = self.current_try_block;\n-        let next_tail = match *tail {\n+        let next_tail = match btail {\n             Some(tail) => self.alloc_expr_desugared(Expr::Call {\n                 callee,\n                 args: Box::new([tail]),\n@@ -662,10 +676,10 @@ impl ExprCollector<'_> {\n             }\n         };\n         let Expr::Block { tail, .. } = &mut self.body.exprs[expr_id] else {\n-            unreachable!(\"It is the output of collect block\");\n+            unreachable!(\"block was lowered to non-block\");\n         };\n         *tail = Some(next_tail);\n-        self.current_try_block = prev_try_block;\n+        self.current_try_block_label = old_label;\n         expr_id\n     }\n \n@@ -735,12 +749,13 @@ impl ExprCollector<'_> {\n                     Expr::Call { callee, args: Box::new([x]), is_assignee_expr: false },\n                     syntax_ptr.clone(),\n                 );\n-                if let Some(label) = self.current_try_block {\n-                    let label = Some(self.body.labels[label].name.clone());\n-                    self.alloc_expr(Expr::Break { expr: Some(result), label }, syntax_ptr.clone())\n-                } else {\n-                    self.alloc_expr(Expr::Return { expr: Some(result) }, syntax_ptr.clone())\n-                }\n+                self.alloc_expr(\n+                    match self.current_try_block_label {\n+                        Some(label) => Expr::Break { expr: Some(result), label: Some(label) },\n+                        None => Expr::Return { expr: Some(result) },\n+                    },\n+                    syntax_ptr.clone(),\n+                )\n             },\n         };\n         let arms = Box::new([continue_arm, break_arm]);\n@@ -785,7 +800,7 @@ impl ExprCollector<'_> {\n                         krate: *krate,\n                     });\n                 }\n-                Some(ExpandError::RecursionOverflowPosioned) => {\n+                Some(ExpandError::RecursionOverflowPoisoned) => {\n                     // Recursion limit has been reached in the macro expansion tree, but not in\n                     // this very macro call. Don't add diagnostics to avoid duplication.\n                 }\n@@ -866,7 +881,7 @@ impl ExprCollector<'_> {\n                 if self.check_cfg(&stmt).is_none() {\n                     return;\n                 }\n-                let pat = self.collect_pat_opt(stmt.pat());\n+                let pat = self.collect_pat_top(stmt.pat());\n                 let type_ref =\n                     stmt.ty().map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n                 let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n@@ -911,10 +926,20 @@ impl ExprCollector<'_> {\n         block: ast::BlockExpr,\n         mk_block: impl FnOnce(Option<BlockId>, Box<[Statement]>, Option<ExprId>) -> Expr,\n     ) -> ExprId {\n-        let file_local_id = self.ast_id_map.ast_id(&block);\n-        let ast_id = AstId::new(self.expander.current_file_id, file_local_id);\n+        let block_has_items = {\n+            let statement_has_item = block.statements().any(|stmt| match stmt {\n+                ast::Stmt::Item(_) => true,\n+                // Macro calls can be both items and expressions. The syntax library always treats\n+                // them as expressions here, so we undo that.\n+                ast::Stmt::ExprStmt(es) => matches!(es.expr(), Some(ast::Expr::MacroExpr(_))),\n+                _ => false,\n+            });\n+            statement_has_item || matches!(block.tail_expr(), Some(ast::Expr::MacroExpr(_)))\n+        };\n \n-        let block_id = if ItemTree::block_has_items(self.db, ast_id.file_id, &block) {\n+        let block_id = if block_has_items {\n+            let file_local_id = self.ast_id_map.ast_id(&block);\n+            let ast_id = AstId::new(self.expander.current_file_id, file_local_id);\n             Some(self.db.intern_block(BlockLoc {\n                 ast_id,\n                 module: self.expander.def_map.module_id(self.expander.module),\n@@ -966,32 +991,34 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_label(&mut self, ast_label: ast::Label) -> LabelId {\n-        let label = Label {\n-            name: ast_label.lifetime().as_ref().map_or_else(Name::missing, Name::new_lifetime),\n-        };\n-        self.alloc_label(label, AstPtr::new(&ast_label))\n+    fn collect_labelled_block_opt(\n+        &mut self,\n+        label: Option<LabelId>,\n+        expr: Option<ast::BlockExpr>,\n+    ) -> ExprId {\n+        match label {\n+            Some(label) => self.with_labeled_rib(label, |this| this.collect_block_opt(expr)),\n+            None => self.collect_block_opt(expr),\n+        }\n     }\n \n-    fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n-        self.collect_pat_(pat, &mut BindingList::default())\n-    }\n+    // region: patterns\n \n-    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n+    fn collect_pat_top(&mut self, pat: Option<ast::Pat>) -> PatId {\n         match pat {\n-            Some(pat) => self.collect_pat(pat),\n+            Some(pat) => self.collect_pat(pat, &mut BindingList::default()),\n             None => self.missing_pat(),\n         }\n     }\n \n-    fn collect_pat_(&mut self, pat: ast::Pat, binding_list: &mut BindingList) -> PatId {\n+    fn collect_pat(&mut self, pat: ast::Pat, binding_list: &mut BindingList) -> PatId {\n         let pattern = match &pat {\n             ast::Pat::IdentPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n \n                 let annotation =\n                     BindingAnnotation::new(bp.mut_token().is_some(), bp.ref_token().is_some());\n-                let subpat = bp.pat().map(|subpat| self.collect_pat_(subpat, binding_list));\n+                let subpat = bp.pat().map(|subpat| self.collect_pat(subpat, binding_list));\n \n                 let is_simple_ident_pat =\n                     annotation == BindingAnnotation::Unannotated && subpat.is_none();\n@@ -1045,7 +1072,7 @@ impl ExprCollector<'_> {\n                 Pat::TupleStruct { path, args, ellipsis }\n             }\n             ast::Pat::RefPat(p) => {\n-                let pat = self.collect_pat_opt_(p.pat(), binding_list);\n+                let pat = self.collect_pat_opt(p.pat(), binding_list);\n                 let mutability = Mutability::from_mutable(p.mut_token().is_some());\n                 Pat::Ref { pat, mutability }\n             }\n@@ -1055,10 +1082,10 @@ impl ExprCollector<'_> {\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n             ast::Pat::OrPat(p) => {\n-                let pats = p.pats().map(|p| self.collect_pat_(p, binding_list)).collect();\n+                let pats = p.pats().map(|p| self.collect_pat(p, binding_list)).collect();\n                 Pat::Or(pats)\n             }\n-            ast::Pat::ParenPat(p) => return self.collect_pat_opt_(p.pat(), binding_list),\n+            ast::Pat::ParenPat(p) => return self.collect_pat_opt(p.pat(), binding_list),\n             ast::Pat::TuplePat(p) => {\n                 let (args, ellipsis) = self.collect_tuple_pat(p.fields(), binding_list);\n                 Pat::Tuple { args, ellipsis }\n@@ -1073,7 +1100,7 @@ impl ExprCollector<'_> {\n                     .fields()\n                     .filter_map(|f| {\n                         let ast_pat = f.pat()?;\n-                        let pat = self.collect_pat_(ast_pat, binding_list);\n+                        let pat = self.collect_pat(ast_pat, binding_list);\n                         let name = f.field_name()?.as_name();\n                         Some(RecordFieldPat { name, pat })\n                     })\n@@ -1092,15 +1119,9 @@ impl ExprCollector<'_> {\n \n                 // FIXME properly handle `RestPat`\n                 Pat::Slice {\n-                    prefix: prefix\n-                        .into_iter()\n-                        .map(|p| self.collect_pat_(p, binding_list))\n-                        .collect(),\n-                    slice: slice.map(|p| self.collect_pat_(p, binding_list)),\n-                    suffix: suffix\n-                        .into_iter()\n-                        .map(|p| self.collect_pat_(p, binding_list))\n-                        .collect(),\n+                    prefix: prefix.into_iter().map(|p| self.collect_pat(p, binding_list)).collect(),\n+                    slice: slice.map(|p| self.collect_pat(p, binding_list)),\n+                    suffix: suffix.into_iter().map(|p| self.collect_pat(p, binding_list)).collect(),\n                 }\n             }\n             #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5676\n@@ -1131,12 +1152,18 @@ impl ExprCollector<'_> {\n                 Pat::Missing\n             }\n             ast::Pat::BoxPat(boxpat) => {\n-                let inner = self.collect_pat_opt_(boxpat.pat(), binding_list);\n+                let inner = self.collect_pat_opt(boxpat.pat(), binding_list);\n                 Pat::Box { inner }\n             }\n             ast::Pat::ConstBlockPat(const_block_pat) => {\n-                if let Some(expr) = const_block_pat.block_expr() {\n-                    let expr_id = self.collect_block(expr);\n+                if let Some(block) = const_block_pat.block_expr() {\n+                    let expr_id = self.with_label_rib(RibKind::Constant, |this| {\n+                        let syntax_ptr = AstPtr::new(&block.clone().into());\n+                        this.collect_as_a_binding_owner_bad(\n+                            |this| this.collect_block(block),\n+                            syntax_ptr,\n+                        )\n+                    });\n                     Pat::ConstBlock(expr_id)\n                 } else {\n                     Pat::Missing\n@@ -1148,7 +1175,7 @@ impl ExprCollector<'_> {\n                     let src = self.expander.to_source(Either::Left(AstPtr::new(&pat)));\n                     let pat =\n                         self.collect_macro_call(call, macro_ptr, true, |this, expanded_pat| {\n-                            this.collect_pat_opt_(expanded_pat, binding_list)\n+                            this.collect_pat_opt(expanded_pat, binding_list)\n                         });\n                     self.source_map.pat_map.insert(src, pat);\n                     return pat;\n@@ -1162,9 +1189,9 @@ impl ExprCollector<'_> {\n         self.alloc_pat(pattern, Either::Left(ptr))\n     }\n \n-    fn collect_pat_opt_(&mut self, pat: Option<ast::Pat>, binding_list: &mut BindingList) -> PatId {\n+    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>, binding_list: &mut BindingList) -> PatId {\n         match pat {\n-            Some(pat) => self.collect_pat_(pat, binding_list),\n+            Some(pat) => self.collect_pat(pat, binding_list),\n             None => self.missing_pat(),\n         }\n     }\n@@ -1180,12 +1207,14 @@ impl ExprCollector<'_> {\n         // We want to skip the `..` pattern here, since we account for it above.\n         let args = args\n             .filter(|p| !matches!(p, ast::Pat::RestPat(_)))\n-            .map(|p| self.collect_pat_(p, binding_list))\n+            .map(|p| self.collect_pat(p, binding_list))\n             .collect();\n \n         (args, ellipsis)\n     }\n \n+    // endregion: patterns\n+\n     /// Returns `None` (and emits diagnostics) when `owner` if `#[cfg]`d out, and `Some(())` when\n     /// not.\n     fn check_cfg(&mut self, owner: &dyn ast::HasAttrs) -> Option<()> {\n@@ -1213,42 +1242,118 @@ impl ExprCollector<'_> {\n     fn add_definition_to_binding(&mut self, binding_id: BindingId, pat_id: PatId) {\n         self.body.bindings[binding_id].definitions.push(pat_id);\n     }\n-}\n \n-impl From<ast::LiteralKind> for Literal {\n-    fn from(ast_lit_kind: ast::LiteralKind) -> Self {\n-        match ast_lit_kind {\n-            // FIXME: these should have actual values filled in, but unsure on perf impact\n-            LiteralKind::IntNumber(lit) => {\n-                if let builtin @ Some(_) = lit.suffix().and_then(BuiltinFloat::from_suffix) {\n-                    Literal::Float(\n-                        FloatTypeWrapper::new(lit.float_value().unwrap_or(Default::default())),\n-                        builtin,\n-                    )\n-                } else if let builtin @ Some(_) = lit.suffix().and_then(BuiltinUint::from_suffix) {\n-                    Literal::Uint(lit.value().unwrap_or(0), builtin)\n-                } else {\n-                    let builtin = lit.suffix().and_then(BuiltinInt::from_suffix);\n-                    Literal::Int(lit.value().unwrap_or(0) as i128, builtin)\n+    // region: labels\n+\n+    fn collect_label(&mut self, ast_label: ast::Label) -> LabelId {\n+        let label = Label {\n+            name: ast_label.lifetime().as_ref().map_or_else(Name::missing, Name::new_lifetime),\n+        };\n+        self.alloc_label(label, AstPtr::new(&ast_label))\n+    }\n+\n+    fn resolve_label(\n+        &self,\n+        lifetime: Option<ast::Lifetime>,\n+    ) -> Result<Option<LabelId>, BodyDiagnostic> {\n+        let Some(lifetime) = lifetime else {\n+            return Ok(None)\n+        };\n+        let name = Name::new_lifetime(&lifetime);\n+\n+        for (rib_idx, rib) in self.label_ribs.iter().enumerate().rev() {\n+            if let Some((label_name, id)) = &rib.label {\n+                if *label_name == name {\n+                    return if self.is_label_valid_from_rib(rib_idx) {\n+                        Ok(Some(*id))\n+                    } else {\n+                        Err(BodyDiagnostic::UnreachableLabel {\n+                            name,\n+                            node: InFile::new(\n+                                self.expander.current_file_id,\n+                                AstPtr::new(&lifetime),\n+                            ),\n+                        })\n+                    };\n                 }\n             }\n-            LiteralKind::FloatNumber(lit) => {\n-                let ty = lit.suffix().and_then(BuiltinFloat::from_suffix);\n-                Literal::Float(FloatTypeWrapper::new(lit.value().unwrap_or(Default::default())), ty)\n-            }\n-            LiteralKind::ByteString(bs) => {\n-                let text = bs.value().map(Box::from).unwrap_or_else(Default::default);\n-                Literal::ByteString(text)\n-            }\n-            LiteralKind::String(s) => {\n-                let text = s.value().map(Box::from).unwrap_or_else(Default::default);\n-                Literal::String(text)\n-            }\n-            LiteralKind::Byte(b) => {\n-                Literal::Uint(b.value().unwrap_or_default() as u128, Some(BuiltinUint::U8))\n-            }\n-            LiteralKind::Char(c) => Literal::Char(c.value().unwrap_or_default()),\n-            LiteralKind::Bool(val) => Literal::Bool(val),\n         }\n+\n+        Err(BodyDiagnostic::UndeclaredLabel {\n+            name,\n+            node: InFile::new(self.expander.current_file_id, AstPtr::new(&lifetime)),\n+        })\n+    }\n+\n+    fn is_label_valid_from_rib(&self, rib_index: usize) -> bool {\n+        !self.label_ribs[rib_index + 1..].iter().any(|rib| rib.kind.is_label_barrier())\n+    }\n+\n+    fn with_label_rib<T>(&mut self, kind: RibKind, f: impl FnOnce(&mut Self) -> T) -> T {\n+        self.label_ribs.push(LabelRib::new(kind));\n+        let res = f(self);\n+        self.label_ribs.pop();\n+        res\n+    }\n+\n+    fn with_labeled_rib<T>(&mut self, label: LabelId, f: impl FnOnce(&mut Self) -> T) -> T {\n+        self.label_ribs.push(LabelRib::new_normal((self.body[label].name.clone(), label)));\n+        let res = f(self);\n+        self.label_ribs.pop();\n+        res\n+    }\n+    // endregion: labels\n+}\n+\n+impl ExprCollector<'_> {\n+    fn alloc_expr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {\n+        let src = self.expander.to_source(ptr);\n+        let id = self.body.exprs.alloc(expr);\n+        self.source_map.expr_map_back.insert(id, src.clone());\n+        self.source_map.expr_map.insert(src, id);\n+        id\n+    }\n+    // FIXME: desugared exprs don't have ptr, that's wrong and should be fixed somehow.\n+    fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n+        self.body.exprs.alloc(expr)\n+    }\n+    fn missing_expr(&mut self) -> ExprId {\n+        self.alloc_expr_desugared(Expr::Missing)\n+    }\n+\n+    fn alloc_binding(&mut self, name: Name, mode: BindingAnnotation) -> BindingId {\n+        self.body.bindings.alloc(Binding {\n+            name,\n+            mode,\n+            definitions: SmallVec::new(),\n+            owner: self.current_binding_owner,\n+        })\n+    }\n+\n+    fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n+        let src = self.expander.to_source(ptr);\n+        let id = self.body.pats.alloc(pat);\n+        self.source_map.pat_map_back.insert(id, src.clone());\n+        self.source_map.pat_map.insert(src, id);\n+        id\n+    }\n+    // FIXME: desugared pats don't have ptr, that's wrong and should be fixed somehow.\n+    fn alloc_pat_desugared(&mut self, pat: Pat) -> PatId {\n+        self.body.pats.alloc(pat)\n+    }\n+    fn missing_pat(&mut self) -> PatId {\n+        self.body.pats.alloc(Pat::Missing)\n+    }\n+\n+    fn alloc_label(&mut self, label: Label, ptr: LabelPtr) -> LabelId {\n+        let src = self.expander.to_source(ptr);\n+        let id = self.body.labels.alloc(label);\n+        self.source_map.label_map_back.insert(id, src.clone());\n+        self.source_map.label_map.insert(src, id);\n+        id\n+    }\n+    // FIXME: desugared labels don't have ptr, that's wrong and should be fixed somehow.\n+    fn alloc_label_desugared(&mut self, label: Label) -> LabelId {\n+        self.body.labels.alloc(label)\n     }\n }"}, {"sha": "c3bd99b94876a0562fb29d8c601406e28ebb89e5", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -5,28 +5,26 @@ use std::fmt::{self, Write};\n use syntax::ast::HasName;\n \n use crate::{\n-    expr::{Array, BindingAnnotation, BindingId, ClosureKind, Literal, Movability, Statement},\n+    hir::{\n+        Array, BindingAnnotation, BindingId, CaptureBy, ClosureKind, Literal, Movability, Statement,\n+    },\n     pretty::{print_generic_args, print_path, print_type_ref},\n     type_ref::TypeRef,\n };\n \n use super::*;\n \n pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBodyId) -> String {\n-    let needs_semi;\n     let header = match owner {\n         DefWithBodyId::FunctionId(it) => {\n-            needs_semi = false;\n             let item_tree_id = it.lookup(db).id;\n-            format!(\"fn {}(\u2026) \", item_tree_id.item_tree(db)[item_tree_id.value].name)\n+            format!(\"fn {}\", item_tree_id.item_tree(db)[item_tree_id.value].name)\n         }\n         DefWithBodyId::StaticId(it) => {\n-            needs_semi = true;\n             let item_tree_id = it.lookup(db).id;\n             format!(\"static {} = \", item_tree_id.item_tree(db)[item_tree_id.value].name)\n         }\n         DefWithBodyId::ConstId(it) => {\n-            needs_semi = true;\n             let item_tree_id = it.lookup(db).id;\n             let name = match &item_tree_id.item_tree(db)[item_tree_id.value].name {\n                 Some(name) => name.to_string(),\n@@ -35,7 +33,6 @@ pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBo\n             format!(\"const {name} = \")\n         }\n         DefWithBodyId::VariantId(it) => {\n-            needs_semi = false;\n             let src = it.parent.child_source(db);\n             let variant = &src.value[it.local_id];\n             let name = match &variant.name() {\n@@ -47,8 +44,18 @@ pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBo\n     };\n \n     let mut p = Printer { body, buf: header, indent_level: 0, needs_indent: false };\n+    if let DefWithBodyId::FunctionId(it) = owner {\n+        p.buf.push('(');\n+        body.params.iter().zip(&db.function_data(it).params).for_each(|(&param, ty)| {\n+            p.print_pat(param);\n+            p.buf.push(':');\n+            p.print_type_ref(ty);\n+        });\n+        p.buf.push(')');\n+        p.buf.push(' ');\n+    }\n     p.print_expr(body.body_expr);\n-    if needs_semi {\n+    if matches!(owner, DefWithBodyId::StaticId(_) | DefWithBodyId::ConstId(_)) {\n         p.buf.push(';');\n     }\n     p.buf\n@@ -219,14 +226,14 @@ impl<'a> Printer<'a> {\n             }\n             Expr::Continue { label } => {\n                 w!(self, \"continue\");\n-                if let Some(label) = label {\n-                    w!(self, \" {}\", label);\n+                if let Some(lbl) = label {\n+                    w!(self, \" {}\", self.body[*lbl].name);\n                 }\n             }\n             Expr::Break { expr, label } => {\n                 w!(self, \"break\");\n-                if let Some(label) = label {\n-                    w!(self, \" {}\", label);\n+                if let Some(lbl) = label {\n+                    w!(self, \" {}\", self.body[*lbl].name);\n                 }\n                 if let Some(expr) = expr {\n                     self.whitespace();\n@@ -355,7 +362,7 @@ impl<'a> Printer<'a> {\n                 self.print_expr(*index);\n                 w!(self, \"]\");\n             }\n-            Expr::Closure { args, arg_types, ret_type, body, closure_kind } => {\n+            Expr::Closure { args, arg_types, ret_type, body, closure_kind, capture_by } => {\n                 match closure_kind {\n                     ClosureKind::Generator(Movability::Static) => {\n                         w!(self, \"static \");\n@@ -365,6 +372,12 @@ impl<'a> Printer<'a> {\n                     }\n                     _ => (),\n                 }\n+                match capture_by {\n+                    CaptureBy::Value => {\n+                        w!(self, \"move \");\n+                    }\n+                    CaptureBy::Ref => (),\n+                }\n                 w!(self, \"|\");\n                 for (i, (pat, ty)) in args.iter().zip(arg_types.iter()).enumerate() {\n                     if i != 0 {"}, {"sha": "f3f9aa79461f1f2ddbeb6a38dd1e201c7a53ed47", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -8,7 +8,7 @@ use rustc_hash::FxHashMap;\n use crate::{\n     body::Body,\n     db::DefDatabase,\n-    expr::{Binding, BindingId, Expr, ExprId, LabelId, Pat, PatId, Statement},\n+    hir::{Binding, BindingId, Expr, ExprId, LabelId, Pat, PatId, Statement},\n     BlockId, DefWithBodyId,\n };\n "}, {"sha": "21180fcbdae40aab1709b2b1cdb999863ddb8a16", "filename": "crates/hir-def/src/child_by_source.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -10,9 +10,8 @@ use syntax::ast::HasDocComments;\n \n use crate::{\n     db::DefDatabase,\n-    dyn_map::DynMap,\n+    dyn_map::{keys, DynMap},\n     item_scope::ItemScope,\n-    keys,\n     src::{HasChildSource, HasSource},\n     AdtId, AssocItemId, DefWithBodyId, EnumId, EnumVariantId, FieldId, ImplId, Lookup, MacroId,\n     ModuleDefId, ModuleId, TraitId, VariantId,"}, {"sha": "98cf69c168976685299699e7e0faf2c1d9f69e3e", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,5 +1,7 @@\n //! Contains basic data about various HIR declarations.\n \n+pub mod adt;\n+\n use std::sync::Arc;\n \n use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, InFile, MacroCallId, MacroDefKind};\n@@ -28,7 +30,7 @@ use crate::{\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct FunctionData {\n     pub name: Name,\n-    pub params: Vec<(Option<Name>, Interned<TypeRef>)>,\n+    pub params: Vec<Interned<TypeRef>>,\n     pub ret_type: Interned<TypeRef>,\n     pub attrs: Attrs,\n     pub visibility: RawVisibility,\n@@ -98,7 +100,7 @@ impl FunctionData {\n             params: enabled_params\n                 .clone()\n                 .filter_map(|id| match &item_tree[id] {\n-                    Param::Normal(name, ty) => Some((name.clone(), ty.clone())),\n+                    Param::Normal(ty) => Some(ty.clone()),\n                     Param::Varargs => None,\n                 })\n                 .collect(),"}, {"sha": "0b6a51fe7649da2b19d4f19d7eab2644591f26e1", "filename": "crates/hir-def/src/data/adt.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fdata%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fdata%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata%2Fadt.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -473,7 +473,7 @@ fn lower_struct(\n     trace: &mut Trace<FieldData, Either<ast::TupleField, ast::RecordField>>,\n     ast: &InFile<ast::StructKind>,\n ) -> StructKind {\n-    let ctx = LowerCtx::new(db, ast.file_id);\n+    let ctx = LowerCtx::new(db, &expander.hygiene(), ast.file_id);\n \n     match &ast.value {\n         ast::StructKind::Tuple(fl) => {", "previous_filename": "crates/hir-def/src/adt.rs"}, {"sha": "2dfe4b6264847c38cb1851503a313b9301c6c7e8", "filename": "crates/hir-def/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdb.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -9,10 +9,10 @@ use la_arena::ArenaMap;\n use syntax::{ast, AstPtr};\n \n use crate::{\n-    adt::{EnumData, StructData},\n     attr::{Attrs, AttrsWithOwner},\n     body::{scope::ExprScopes, Body, BodySourceMap},\n     data::{\n+        adt::{EnumData, StructData},\n         ConstData, FunctionData, ImplData, Macro2Data, MacroRulesData, ProcMacroData, StaticData,\n         TraitAliasData, TraitData, TypeAliasData,\n     },"}, {"sha": "63138aa6ad78fa179e6df61f79aa935995553be2", "filename": "crates/hir-def/src/dyn_map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fdyn_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fdyn_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdyn_map.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -21,6 +21,8 @@\n //!\n //! This is a work of fiction. Any similarities to Kotlin's `BindingContext` are\n //! a coincidence.\n+pub mod keys;\n+\n use std::{\n     hash::Hash,\n     marker::PhantomData,"}, {"sha": "f30be6b64e3ded45ee26afb15fd74eb12d1811b8", "filename": "crates/hir-def/src/dyn_map/keys.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fdyn_map%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fdyn_map%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdyn_map%2Fkeys.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "previous_filename": "crates/hir-def/src/keys.rs"}, {"sha": "30edaed109585362c7437951be7ce8900857ef9f", "filename": "crates/hir-def/src/generics.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -12,16 +12,14 @@ use hir_expand::{\n use intern::Interned;\n use la_arena::{Arena, ArenaMap, Idx};\n use once_cell::unsync::Lazy;\n-use std::ops::DerefMut;\n use stdx::impl_from;\n use syntax::ast::{self, HasGenericParams, HasName, HasTypeBounds};\n \n use crate::{\n     body::{Expander, LowerCtx},\n     child_by_source::ChildBySource,\n     db::DefDatabase,\n-    dyn_map::DynMap,\n-    keys,\n+    dyn_map::{keys, DynMap},\n     src::{HasChildSource, HasSource},\n     type_ref::{LifetimeRef, TypeBound, TypeRef},\n     AdtId, ConstParamId, GenericDefId, HasModule, LifetimeParamId, LocalLifetimeParamId,\n@@ -177,7 +175,7 @@ impl GenericParams {\n                 // Don't create an `Expander` nor call `loc.source(db)` if not needed since this\n                 // causes a reparse after the `ItemTree` has been created.\n                 let mut expander = Lazy::new(|| Expander::new(db, loc.source(db).file_id, module));\n-                for (_, param) in &func_data.params {\n+                for param in &func_data.params {\n                     generic_params.fill_implicit_impl_trait_args(db, &mut expander, param);\n                 }\n \n@@ -329,7 +327,7 @@ impl GenericParams {\n     pub(crate) fn fill_implicit_impl_trait_args(\n         &mut self,\n         db: &dyn DefDatabase,\n-        expander: &mut impl DerefMut<Target = Expander>,\n+        expander: &mut Expander,\n         type_ref: &TypeRef,\n     ) {\n         type_ref.walk(&mut |type_ref| {\n@@ -351,7 +349,7 @@ impl GenericParams {\n                 let macro_call = mc.to_node(db.upcast());\n                 match expander.enter_expand::<ast::Type>(db, macro_call) {\n                     Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n-                        let ctx = LowerCtx::new(db, expander.current_file_id());\n+                        let ctx = expander.ctx(db);\n                         let type_ref = TypeRef::from_ast(&ctx, expanded);\n                         self.fill_implicit_impl_trait_args(db, expander, &type_ref);\n                         expander.exit(db, mark);"}, {"sha": "8709ad0e99b8d6a541e85a4db34c492163be813f", "filename": "crates/hir-def/src/hir.rs", "status": "renamed", "additions": 71, "deletions": 4, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fhir.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -12,12 +12,15 @@\n //!\n //! See also a neighboring `body` module.\n \n+pub mod type_ref;\n+\n use std::fmt;\n \n use hir_expand::name::Name;\n use intern::Interned;\n use la_arena::{Idx, RawIdx};\n use smallvec::SmallVec;\n+use syntax::ast;\n \n use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n@@ -28,10 +31,10 @@ use crate::{\n \n pub use syntax::ast::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, UnaryOp};\n \n-pub type ExprId = Idx<Expr>;\n-\n pub type BindingId = Idx<Binding>;\n \n+pub type ExprId = Idx<Expr>;\n+\n /// FIXME: this is a hacky function which should be removed\n pub(crate) fn dummy_expr_id() -> ExprId {\n     ExprId::from_raw(RawIdx::from(u32::MAX))\n@@ -102,6 +105,45 @@ impl Literal {\n     }\n }\n \n+impl From<ast::LiteralKind> for Literal {\n+    fn from(ast_lit_kind: ast::LiteralKind) -> Self {\n+        use ast::LiteralKind;\n+        match ast_lit_kind {\n+            // FIXME: these should have actual values filled in, but unsure on perf impact\n+            LiteralKind::IntNumber(lit) => {\n+                if let builtin @ Some(_) = lit.suffix().and_then(BuiltinFloat::from_suffix) {\n+                    Literal::Float(\n+                        FloatTypeWrapper::new(lit.float_value().unwrap_or(Default::default())),\n+                        builtin,\n+                    )\n+                } else if let builtin @ Some(_) = lit.suffix().and_then(BuiltinUint::from_suffix) {\n+                    Literal::Uint(lit.value().unwrap_or(0), builtin)\n+                } else {\n+                    let builtin = lit.suffix().and_then(BuiltinInt::from_suffix);\n+                    Literal::Int(lit.value().unwrap_or(0) as i128, builtin)\n+                }\n+            }\n+            LiteralKind::FloatNumber(lit) => {\n+                let ty = lit.suffix().and_then(BuiltinFloat::from_suffix);\n+                Literal::Float(FloatTypeWrapper::new(lit.value().unwrap_or(Default::default())), ty)\n+            }\n+            LiteralKind::ByteString(bs) => {\n+                let text = bs.value().map(Box::from).unwrap_or_else(Default::default);\n+                Literal::ByteString(text)\n+            }\n+            LiteralKind::String(s) => {\n+                let text = s.value().map(Box::from).unwrap_or_else(Default::default);\n+                Literal::String(text)\n+            }\n+            LiteralKind::Byte(b) => {\n+                Literal::Uint(b.value().unwrap_or_default() as u128, Some(BuiltinUint::U8))\n+            }\n+            LiteralKind::Char(c) => Literal::Char(c.value().unwrap_or_default()),\n+            LiteralKind::Bool(val) => Literal::Bool(val),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Expr {\n     /// This is produced if the syntax tree does not have a required expression piece.\n@@ -168,11 +210,11 @@ pub enum Expr {\n         arms: Box<[MatchArm]>,\n     },\n     Continue {\n-        label: Option<Name>,\n+        label: Option<LabelId>,\n     },\n     Break {\n         expr: Option<ExprId>,\n-        label: Option<Name>,\n+        label: Option<LabelId>,\n     },\n     Return {\n         expr: Option<ExprId>,\n@@ -233,6 +275,7 @@ pub enum Expr {\n         ret_type: Option<Interned<TypeRef>>,\n         body: ExprId,\n         closure_kind: ClosureKind,\n+        capture_by: CaptureBy,\n     },\n     Tuple {\n         exprs: Box<[ExprId]>,\n@@ -250,6 +293,14 @@ pub enum ClosureKind {\n     Async,\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum CaptureBy {\n+    /// `move |x| y + x`.\n+    Value,\n+    /// `move` keyword was not specified.\n+    Ref,\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum Movability {\n     Static,\n@@ -442,6 +493,22 @@ pub struct Binding {\n     pub name: Name,\n     pub mode: BindingAnnotation,\n     pub definitions: SmallVec<[PatId; 1]>,\n+    /// Id of the closure/generator that owns this binding. If it is owned by the\n+    /// top level expression, this field would be `None`.\n+    pub owner: Option<ExprId>,\n+}\n+\n+impl Binding {\n+    pub fn is_upvar(&self, relative_to: ExprId) -> bool {\n+        match self.owner {\n+            Some(x) => {\n+                // We assign expression ids in a way that outer closures will recieve\n+                // a lower id\n+                x.into_raw() < relative_to.into_raw()\n+            }\n+            None => true,\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]", "previous_filename": "crates/hir-def/src/expr.rs"}, {"sha": "0e2c0d864dc13c6590177890b71b2ad35fa58041", "filename": "crates/hir-def/src/hir/type_ref.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fhir%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fhir%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fhir%2Ftype_ref.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -13,7 +13,7 @@ use syntax::ast::{self, HasName};\n use crate::{\n     body::LowerCtx,\n     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n-    expr::Literal,\n+    hir::Literal,\n     path::Path,\n };\n ", "previous_filename": "crates/hir-def/src/type_ref.rs"}, {"sha": "8546d36d7984f9053cd7826280d7842043b8fab6", "filename": "crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -152,14 +152,6 @@ impl ItemTree {\n         &self.top_level\n     }\n \n-    pub fn block_has_items(\n-        db: &dyn DefDatabase,\n-        file_id: HirFileId,\n-        block: &ast::BlockExpr,\n-    ) -> bool {\n-        lower::Ctx::new(db, file_id).block_has_items(block)\n-    }\n-\n     /// Returns the inner attributes of the source file.\n     pub fn top_level_attrs(&self, db: &dyn DefDatabase, krate: CrateId) -> Attrs {\n         Attrs::filter(\n@@ -614,7 +606,7 @@ pub struct Function {\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Param {\n-    Normal(Option<Name>, Interned<TypeRef>),\n+    Normal(Interned<TypeRef>),\n     Varargs,\n }\n "}, {"sha": "c67c8bb4401bdc8b5efd68204e2b1ed8ce8ddb1f", "filename": "crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 3, "deletions": 43, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -29,7 +29,7 @@ impl<'a> Ctx<'a> {\n             db,\n             tree: ItemTree::default(),\n             source_ast_id_map: db.ast_id_map(file),\n-            body_ctx: crate::body::LowerCtx::new(db, file),\n+            body_ctx: crate::body::LowerCtx::with_file_id(db, file),\n         }\n     }\n \n@@ -101,34 +101,6 @@ impl<'a> Ctx<'a> {\n         self.tree\n     }\n \n-    pub(super) fn block_has_items(mut self, block: &ast::BlockExpr) -> bool {\n-        let statement_has_item = block\n-            .statements()\n-            .find_map(|stmt| match stmt {\n-                ast::Stmt::Item(item) => self.lower_mod_item(&item),\n-                // Macro calls can be both items and expressions. The syntax library always treats\n-                // them as expressions here, so we undo that.\n-                ast::Stmt::ExprStmt(es) => match es.expr()? {\n-                    ast::Expr::MacroExpr(expr) => self.lower_mod_item(&expr.macro_call()?.into()),\n-                    _ => None,\n-                },\n-                _ => None,\n-            })\n-            .is_some();\n-        if statement_has_item {\n-            return true;\n-        }\n-\n-        if let Some(ast::Expr::MacroExpr(expr)) = block.tail_expr() {\n-            if let Some(call) = expr.macro_call() {\n-                if let Some(_) = self.lower_mod_item(&call.into()) {\n-                    return true;\n-                }\n-            }\n-        }\n-        false\n-    }\n-\n     fn data(&mut self) -> &mut ItemTreeData {\n         self.tree.data_mut()\n     }\n@@ -321,7 +293,7 @@ impl<'a> Ctx<'a> {\n                     }\n                 };\n                 let ty = Interned::new(self_type);\n-                let idx = self.data().params.alloc(Param::Normal(None, ty));\n+                let idx = self.data().params.alloc(Param::Normal(ty));\n                 self.add_attrs(\n                     idx.into(),\n                     RawAttrs::new(self.db.upcast(), &self_param, self.hygiene()),\n@@ -334,19 +306,7 @@ impl<'a> Ctx<'a> {\n                     None => {\n                         let type_ref = TypeRef::from_ast_opt(&self.body_ctx, param.ty());\n                         let ty = Interned::new(type_ref);\n-                        let mut pat = param.pat();\n-                        // FIXME: This really shouldn't be here, in fact FunctionData/ItemTree's function shouldn't know about\n-                        // pattern names at all\n-                        let name = 'name: loop {\n-                            match pat {\n-                                Some(ast::Pat::RefPat(ref_pat)) => pat = ref_pat.pat(),\n-                                Some(ast::Pat::IdentPat(ident)) => {\n-                                    break 'name ident.name().map(|it| it.as_name())\n-                                }\n-                                _ => break 'name None,\n-                            }\n-                        };\n-                        self.data().params.alloc(Param::Normal(name, ty))\n+                        self.data().params.alloc(Param::Normal(ty))\n                     }\n                 };\n                 self.add_attrs(idx.into(), RawAttrs::new(self.db.upcast(), &param, self.hygiene()));"}, {"sha": "94c5157386ef78b2b281bd865b397c920df22552", "filename": "crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -257,21 +257,15 @@ impl<'a> Printer<'a> {\n                 w!(self, \"(\");\n                 if !params.is_empty() {\n                     self.indented(|this| {\n-                        for (i, param) in params.clone().enumerate() {\n+                        for param in params.clone() {\n                             this.print_attrs_of(param);\n                             match &this.tree[param] {\n-                                Param::Normal(name, ty) => {\n-                                    match name {\n-                                        Some(name) => w!(this, \"{}: \", name),\n-                                        None => w!(this, \"_: \"),\n+                                Param::Normal(ty) => {\n+                                    if flags.contains(FnFlags::HAS_SELF_PARAM) {\n+                                        w!(this, \"self: \");\n                                     }\n                                     this.print_type_ref(ty);\n-                                    w!(this, \",\");\n-                                    if flags.contains(FnFlags::HAS_SELF_PARAM) && i == 0 {\n-                                        wln!(this, \"  // self\");\n-                                    } else {\n-                                        wln!(this);\n-                                    }\n+                                    wln!(this, \",\");\n                                 }\n                                 Param::Varargs => {\n                                     wln!(this, \"...\");"}, {"sha": "1b7564f7a9909a9515da78b558b3d00c027c1770", "filename": "crates/hir-def/src/item_tree/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -165,7 +165,7 @@ trait Tr: SuperTrait + 'lifetime {\n     fn method(&self);\n }\n         \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             pub static mut ST: () = _;\n \n             pub(self) const _: Anon = _;\n@@ -174,8 +174,8 @@ trait Tr: SuperTrait + 'lifetime {\n             #[inner_attr_in_fn]\n             pub(self) fn f(\n                 #[attr]\n-                arg: u8,\n-                _: (),\n+                u8,\n+                (),\n             ) -> () { ... }\n \n             pub(self) trait Tr<Self>\n@@ -186,10 +186,10 @@ trait Tr: SuperTrait + 'lifetime {\n                 pub(self) type Assoc: AssocBound = Default;\n \n                 pub(self) fn method(\n-                    _: &Self,  // self\n+                    self: &Self,\n                 ) -> ();\n             }\n-        \"##]],\n+        \"#]],\n     );\n }\n \n@@ -336,7 +336,7 @@ trait Tr<'a, T: 'a>: Super where Self: for<'a> Tr<'a, T> {}\n                 T: 'b\n             {\n                 pub(self) fn f<G>(\n-                    arg: impl Copy,\n+                    impl Copy,\n                 ) -> impl Copy\n                 where\n                     G: 'a { ... }"}, {"sha": "873936b5b761092c5e540bfc2243310777fc525d", "filename": "crates/hir-def/src/layout.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flayout.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -92,6 +92,7 @@ pub enum LayoutError {\n     SizeOverflow,\n     TargetLayoutNotAvailable,\n     HasPlaceholder,\n+    HasErrorType,\n     NotImplemented,\n     Unknown,\n }"}, {"sha": "65c33322b1dc77d1bb29a297a1f2ead53a238fa4", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -18,24 +18,21 @@ pub mod db;\n \n pub mod attr;\n pub mod path;\n-pub mod type_ref;\n pub mod builtin_type;\n-pub mod builtin_attr;\n pub mod per_ns;\n pub mod item_scope;\n \n pub mod dyn_map;\n-pub mod keys;\n \n pub mod item_tree;\n \n-pub mod adt;\n pub mod data;\n pub mod generics;\n pub mod lang_item;\n pub mod layout;\n \n-pub mod expr;\n+pub mod hir;\n+pub use self::hir::type_ref;\n pub mod body;\n pub mod resolver;\n \n@@ -82,8 +79,8 @@ use syntax::ast;\n use ::tt::token_id as tt;\n \n use crate::{\n-    adt::VariantData,\n     builtin_type::BuiltinType,\n+    data::adt::VariantData,\n     item_tree::{\n         Const, Enum, Function, Impl, ItemTreeId, ItemTreeNode, MacroDef, MacroRules, ModItem,\n         Static, Struct, Trait, TraitAlias, TypeAlias, Union,\n@@ -236,15 +233,15 @@ pub struct EnumVariantId {\n     pub local_id: LocalEnumVariantId,\n }\n \n-pub type LocalEnumVariantId = Idx<adt::EnumVariantData>;\n+pub type LocalEnumVariantId = Idx<data::adt::EnumVariantData>;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct FieldId {\n     pub parent: VariantId,\n     pub local_id: LocalFieldId,\n }\n \n-pub type LocalFieldId = Idx<adt::FieldData>;\n+pub type LocalFieldId = Idx<data::adt::FieldData>;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ConstId(salsa::InternId);"}, {"sha": "37cf348c92d7590bc2cc0eecc13b0adb9bb2fe39", "filename": "crates/hir-def/src/macro_expansion_tests/builtin_derive_macro.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -16,7 +16,7 @@ struct Foo;\n #[derive(Copy)]\n struct Foo;\n \n-impl < > core::marker::Copy for Foo< > {}\"#]],\n+impl < > core::marker::Copy for Foo< > where {}\"#]],\n     );\n }\n \n@@ -41,7 +41,7 @@ macro Copy {}\n #[derive(Copy)]\n struct Foo;\n \n-impl < > crate ::marker::Copy for Foo< > {}\"#]],\n+impl < > crate ::marker::Copy for Foo< > where {}\"#]],\n     );\n }\n \n@@ -57,7 +57,7 @@ struct Foo<A, B>;\n #[derive(Copy)]\n struct Foo<A, B>;\n \n-impl <T0: core::marker::Copy, T1: core::marker::Copy, > core::marker::Copy for Foo<T0, T1, > {}\"#]],\n+impl <A: core::marker::Copy, B: core::marker::Copy, > core::marker::Copy for Foo<A, B, > where {}\"#]],\n     );\n }\n \n@@ -74,7 +74,7 @@ struct Foo<A, B, 'a, 'b>;\n #[derive(Copy)]\n struct Foo<A, B, 'a, 'b>;\n \n-impl <T0: core::marker::Copy, T1: core::marker::Copy, > core::marker::Copy for Foo<T0, T1, > {}\"#]],\n+impl <A: core::marker::Copy, B: core::marker::Copy, > core::marker::Copy for Foo<A, B, > where {}\"#]],\n     );\n }\n \n@@ -90,7 +90,7 @@ struct Foo<A, B>;\n #[derive(Clone)]\n struct Foo<A, B>;\n \n-impl <T0: core::clone::Clone, T1: core::clone::Clone, > core::clone::Clone for Foo<T0, T1, > {}\"#]],\n+impl <A: core::clone::Clone, B: core::clone::Clone, > core::clone::Clone for Foo<A, B, > where {}\"#]],\n     );\n }\n \n@@ -106,6 +106,6 @@ struct Foo<const X: usize, T>(u32);\n #[derive(Clone)]\n struct Foo<const X: usize, T>(u32);\n \n-impl <const T0: usize, T1: core::clone::Clone, > core::clone::Clone for Foo<T0, T1, > {}\"#]],\n+impl <const X: usize, T: core::clone::Clone, > core::clone::Clone for Foo<X, T, > where {}\"#]],\n     );\n }"}, {"sha": "314bf22b95ee76428066b412da9574ee5f09a6e4", "filename": "crates/hir-def/src/macro_expansion_tests/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "previous_filename": "crates/hir-def/src/macro_expansion_tests.rs"}, {"sha": "6fad01ec2f75de4676923ed29fa0a25d20986e45", "filename": "crates/hir-def/src/nameres/attr_resolution.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -4,7 +4,8 @@ use hir_expand::{attrs::Attr, MacroCallId};\n use syntax::{ast, SmolStr};\n \n use crate::{\n-    attr_macro_as_call_id, builtin_attr,\n+    attr::builtin::{find_builtin_attr_idx, TOOL_MODULES},\n+    attr_macro_as_call_id,\n     db::DefDatabase,\n     item_scope::BuiltinShadowMode,\n     macro_id_to_def_id,\n@@ -76,19 +77,15 @@ impl DefMap {\n             let pred = |n: &_| *n == name;\n \n             let registered = self.registered_tools.iter().map(SmolStr::as_str);\n-            let is_tool = builtin_attr::TOOL_MODULES.iter().copied().chain(registered).any(pred);\n+            let is_tool = TOOL_MODULES.iter().copied().chain(registered).any(pred);\n             // FIXME: tool modules can be shadowed by actual modules\n             if is_tool {\n                 return true;\n             }\n \n             if segments.len() == 1 {\n-                let registered = self.registered_attrs.iter().map(SmolStr::as_str);\n-                let is_inert = builtin_attr::INERT_ATTRIBUTES\n-                    .iter()\n-                    .map(|it| it.name)\n-                    .chain(registered)\n-                    .any(pred);\n+                let mut registered = self.registered_attrs.iter().map(SmolStr::as_str);\n+                let is_inert = find_builtin_attr_idx(&name).is_some() || registered.any(pred);\n                 return is_inert;\n             }\n         }"}, {"sha": "8299d9684bbb75b87c0f9bb02d67f551648d17fe", "filename": "crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -331,11 +331,11 @@ impl DefMap {\n                         Some(local_id) => {\n                             let variant = EnumVariantId { parent: e, local_id };\n                             match &*enum_data.variants[local_id].variant_data {\n-                                crate::adt::VariantData::Record(_) => {\n+                                crate::data::adt::VariantData::Record(_) => {\n                                     PerNs::types(variant.into(), Visibility::Public)\n                                 }\n-                                crate::adt::VariantData::Tuple(_)\n-                                | crate::adt::VariantData::Unit => {\n+                                crate::data::adt::VariantData::Tuple(_)\n+                                | crate::data::adt::VariantData::Unit => {\n                                     PerNs::both(variant.into(), variant.into(), Visibility::Public)\n                                 }\n                             }"}, {"sha": "670495e4d16fa17302f1ce080b88c049c743a59f", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -12,8 +12,8 @@ use crate::{\n     body::scope::{ExprScopes, ScopeId},\n     builtin_type::BuiltinType,\n     db::DefDatabase,\n-    expr::{BindingId, ExprId, LabelId},\n     generics::{GenericParams, TypeOrConstParamData},\n+    hir::{BindingId, ExprId, LabelId},\n     item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\n     lang_item::LangItemTarget,\n     nameres::DefMap,"}, {"sha": "7e753663c01af5ddce30c79aac1d2adc04ea218d", "filename": "crates/hir-expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 111, "deletions": 20, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,11 +1,12 @@\n //! Builtin derives.\n \n use base_db::{CrateOrigin, LangCrateOrigin};\n+use std::collections::HashSet;\n use tracing::debug;\n \n use crate::tt::{self, TokenId};\n use syntax::{\n-    ast::{self, AstNode, HasGenericParams, HasModuleItem, HasName},\n+    ast::{self, AstNode, HasGenericParams, HasModuleItem, HasName, HasTypeBounds, PathType},\n     match_ast,\n };\n \n@@ -60,8 +61,11 @@ pub fn find_builtin_derive(ident: &name::Name) -> Option<BuiltinDeriveExpander>\n \n struct BasicAdtInfo {\n     name: tt::Ident,\n-    /// `Some(ty)` if it's a const param of type `ty`, `None` if it's a type param.\n-    param_types: Vec<Option<tt::Subtree>>,\n+    /// first field is the name, and\n+    /// second field is `Some(ty)` if it's a const param of type `ty`, `None` if it's a type param.\n+    /// third fields is where bounds, if any\n+    param_types: Vec<(tt::Subtree, Option<tt::Subtree>, Option<tt::Subtree>)>,\n+    associated_types: Vec<tt::Subtree>,\n }\n \n fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n@@ -86,46 +90,126 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n             },\n         }\n     };\n-    let name = name.ok_or_else(|| {\n-        debug!(\"parsed item has no name\");\n-        ExpandError::Other(\"missing name\".into())\n-    })?;\n-    let name_token_id =\n-        token_map.token_by_range(name.syntax().text_range()).unwrap_or_else(TokenId::unspecified);\n-    let name_token = tt::Ident { span: name_token_id, text: name.text().into() };\n+    let mut param_type_set: HashSet<String> = HashSet::new();\n     let param_types = params\n         .into_iter()\n         .flat_map(|param_list| param_list.type_or_const_params())\n         .map(|param| {\n-            if let ast::TypeOrConstParam::Const(param) = param {\n+            let name = {\n+                let this = param.name();\n+                match this {\n+                    Some(x) => {\n+                        param_type_set.insert(x.to_string());\n+                        mbe::syntax_node_to_token_tree(x.syntax()).0\n+                    }\n+                    None => tt::Subtree::empty(),\n+                }\n+            };\n+            let bounds = match &param {\n+                ast::TypeOrConstParam::Type(x) => {\n+                    x.type_bound_list().map(|x| mbe::syntax_node_to_token_tree(x.syntax()).0)\n+                }\n+                ast::TypeOrConstParam::Const(_) => None,\n+            };\n+            let ty = if let ast::TypeOrConstParam::Const(param) = param {\n                 let ty = param\n                     .ty()\n                     .map(|ty| mbe::syntax_node_to_token_tree(ty.syntax()).0)\n                     .unwrap_or_else(tt::Subtree::empty);\n                 Some(ty)\n             } else {\n                 None\n-            }\n+            };\n+            (name, ty, bounds)\n         })\n         .collect();\n-    Ok(BasicAdtInfo { name: name_token, param_types })\n+    let is_associated_type = |p: &PathType| {\n+        if let Some(p) = p.path() {\n+            if let Some(parent) = p.qualifier() {\n+                if let Some(x) = parent.segment() {\n+                    if let Some(x) = x.path_type() {\n+                        if let Some(x) = x.path() {\n+                            if let Some(pname) = x.as_single_name_ref() {\n+                                if param_type_set.contains(&pname.to_string()) {\n+                                    // <T as Trait>::Assoc\n+                                    return true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if let Some(pname) = parent.as_single_name_ref() {\n+                    if param_type_set.contains(&pname.to_string()) {\n+                        // T::Assoc\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        false\n+    };\n+    let associated_types = node\n+        .descendants()\n+        .filter_map(PathType::cast)\n+        .filter(is_associated_type)\n+        .map(|x| mbe::syntax_node_to_token_tree(x.syntax()).0)\n+        .collect::<Vec<_>>();\n+    let name = name.ok_or_else(|| {\n+        debug!(\"parsed item has no name\");\n+        ExpandError::Other(\"missing name\".into())\n+    })?;\n+    let name_token_id =\n+        token_map.token_by_range(name.syntax().text_range()).unwrap_or_else(TokenId::unspecified);\n+    let name_token = tt::Ident { span: name_token_id, text: name.text().into() };\n+    Ok(BasicAdtInfo { name: name_token, param_types, associated_types })\n }\n \n+/// Given that we are deriving a trait `DerivedTrait` for a type like:\n+///\n+/// ```ignore (only-for-syntax-highlight)\n+/// struct Struct<'a, ..., 'z, A, B: DeclaredTrait, C, ..., Z> where C: WhereTrait {\n+///     a: A,\n+///     b: B::Item,\n+///     b1: <B as DeclaredTrait>::Item,\n+///     c1: <C as WhereTrait>::Item,\n+///     c2: Option<<C as WhereTrait>::Item>,\n+///     ...\n+/// }\n+/// ```\n+///\n+/// create an impl like:\n+///\n+/// ```ignore (only-for-syntax-highlight)\n+/// impl<'a, ..., 'z, A, B: DeclaredTrait, C, ... Z> where\n+///     C:                       WhereTrait,\n+///     A: DerivedTrait + B1 + ... + BN,\n+///     B: DerivedTrait + B1 + ... + BN,\n+///     C: DerivedTrait + B1 + ... + BN,\n+///     B::Item:                 DerivedTrait + B1 + ... + BN,\n+///     <C as WhereTrait>::Item: DerivedTrait + B1 + ... + BN,\n+///     ...\n+/// {\n+///     ...\n+/// }\n+/// ```\n+///\n+/// where B1, ..., BN are the bounds given by `bounds_paths`.'. Z is a phantom type, and\n+/// therefore does not get bound by the derived trait.\n fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResult<tt::Subtree> {\n     let info = match parse_adt(tt) {\n         Ok(info) => info,\n         Err(e) => return ExpandResult::with_err(tt::Subtree::empty(), e),\n     };\n+    let mut where_block = vec![];\n     let (params, args): (Vec<_>, Vec<_>) = info\n         .param_types\n         .into_iter()\n-        .enumerate()\n-        .map(|(idx, param_ty)| {\n-            let ident = tt::Leaf::Ident(tt::Ident {\n-                span: tt::TokenId::unspecified(),\n-                text: format!(\"T{idx}\").into(),\n-            });\n+        .map(|(ident, param_ty, bound)| {\n             let ident_ = ident.clone();\n+            if let Some(b) = bound {\n+                let ident = ident.clone();\n+                where_block.push(quote! { #ident : #b , });\n+            }\n             if let Some(ty) = param_ty {\n                 (quote! { const #ident : #ty , }, quote! { #ident_ , })\n             } else {\n@@ -134,9 +218,16 @@ fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResu\n             }\n         })\n         .unzip();\n+\n+    where_block.extend(info.associated_types.iter().map(|x| {\n+        let x = x.clone();\n+        let bound = trait_path.clone();\n+        quote! { #x : #bound , }\n+    }));\n+\n     let name = info.name;\n     let expanded = quote! {\n-        impl < ##params > #trait_path for #name < ##args > {}\n+        impl < ##params > #trait_path for #name < ##args > where ##where_block {}\n     };\n     ExpandResult::ok(expanded)\n }"}, {"sha": "929dabcaf62eb866a7aae59b4e7ed14c379235d9", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -55,7 +55,7 @@ pub type ExpandResult<T> = ValueResult<T, ExpandError>;\n pub enum ExpandError {\n     UnresolvedProcMacro(CrateId),\n     Mbe(mbe::ExpandError),\n-    RecursionOverflowPosioned,\n+    RecursionOverflowPoisoned,\n     Other(Box<str>),\n }\n \n@@ -70,7 +70,7 @@ impl fmt::Display for ExpandError {\n         match self {\n             ExpandError::UnresolvedProcMacro(_) => f.write_str(\"unresolved proc-macro\"),\n             ExpandError::Mbe(it) => it.fmt(f),\n-            ExpandError::RecursionOverflowPosioned => {\n+            ExpandError::RecursionOverflowPoisoned => {\n                 f.write_str(\"overflow expanding the original macro\")\n             }\n             ExpandError::Other(it) => f.write_str(it),"}, {"sha": "4e688c431ae22b5c1b285284edd518344d7b9f0f", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -120,8 +120,7 @@ impl Name {\n         use std::sync::atomic::{AtomicUsize, Ordering};\n         static CNT: AtomicUsize = AtomicUsize::new(0);\n         let c = CNT.fetch_add(1, Ordering::Relaxed);\n-        // FIXME: Currently a `__RA_generated_name` in user code will break our analysis\n-        Name::new_text(format!(\"__RA_geneated_name_{c}\").into())\n+        Name::new_text(format!(\"<ra@gennew>{c}\").into())\n     }\n \n     /// Returns the tuple index this name represents if it is a tuple field."}, {"sha": "c30a99e06ca5445000666a0a607d6ddadef792ed", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 44, "deletions": 13, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -9,7 +9,7 @@ use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n \n use base_db::CrateId;\n use hir_def::{\n-    expr::Movability,\n+    hir::Movability,\n     lang_item::{lang_attr, LangItem, LangItemTarget},\n     AssocItemId, BlockId, GenericDefId, HasModule, ItemContainerId, Lookup, TypeAliasId,\n };\n@@ -18,9 +18,10 @@ use hir_expand::name::name;\n use crate::{\n     db::HirDatabase,\n     display::HirDisplay,\n-    from_assoc_type_id, from_chalk_trait_id, make_binders, make_single_type_binders,\n+    from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id, make_binders,\n+    make_single_type_binders,\n     mapping::{from_chalk, ToChalk, TypeAliasAsValue},\n-    method_resolution::{TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n+    method_resolution::{TraitImpls, TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n     to_assoc_type_id, to_chalk_trait_id,\n     traits::ChalkContext,\n     utils::generics,\n@@ -106,6 +107,19 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             _ => self_ty_fp.as_ref().map(std::slice::from_ref).unwrap_or(&[]),\n         };\n \n+        let trait_module = trait_.module(self.db.upcast());\n+        let type_module = match self_ty_fp {\n+            Some(TyFingerprint::Adt(adt_id)) => Some(adt_id.module(self.db.upcast())),\n+            Some(TyFingerprint::ForeignType(type_id)) => {\n+                Some(from_foreign_def_id(type_id).module(self.db.upcast()))\n+            }\n+            Some(TyFingerprint::Dyn(trait_id)) => Some(trait_id.module(self.db.upcast())),\n+            _ => None,\n+        };\n+\n+        let mut def_blocks =\n+            [trait_module.containing_block(), type_module.and_then(|it| it.containing_block())];\n+\n         // Note: Since we're using impls_for_trait, only impls where the trait\n         // can be resolved should ever reach Chalk. impl_datum relies on that\n         // and will panic if the trait can't be resolved.\n@@ -120,25 +134,42 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                 .and_then(|map| map.parent())\n                 .and_then(|module| module.containing_block())\n         })\n+        .inspect(|&block_id| {\n+            // make sure we don't search the same block twice\n+            def_blocks.iter_mut().for_each(|block| {\n+                if *block == Some(block_id) {\n+                    *block = None;\n+                }\n+            });\n+        })\n         .filter_map(|block_id| self.db.trait_impls_in_block(block_id));\n \n         let id_to_chalk = |id: hir_def::ImplId| id.to_chalk(self.db);\n         let mut result = vec![];\n         match fps {\n             [] => {\n                 debug!(\"Unrestricted search for {:?} impls...\", trait_);\n-                impl_maps.into_iter().chain(block_impls).for_each(|impls| {\n+                let mut f = |impls: Arc<TraitImpls>| {\n                     result.extend(impls.for_trait(trait_).map(id_to_chalk));\n-                });\n+                };\n+                impl_maps.into_iter().chain(block_impls).for_each(&mut f);\n+                def_blocks\n+                    .into_iter()\n+                    .filter_map(|it| self.db.trait_impls_in_block(it?))\n+                    .for_each(f);\n             }\n             fps => {\n-                impl_maps.into_iter().chain(block_impls).for_each(|impls| {\n-                    result.extend(\n-                        fps.iter().flat_map(|fp| {\n+                let mut f =\n+                    |impls: Arc<TraitImpls>| {\n+                        result.extend(fps.iter().flat_map(|fp| {\n                             impls.for_trait_and_self_ty(trait_, *fp).map(id_to_chalk)\n-                        }),\n-                    );\n-                });\n+                        }));\n+                    };\n+                impl_maps.into_iter().chain(block_impls).for_each(&mut f);\n+                def_blocks\n+                    .into_iter()\n+                    .filter_map(|it| self.db.trait_impls_in_block(it?))\n+                    .for_each(f);\n             }\n         }\n \n@@ -384,8 +415,8 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         let input_output = crate::make_type_and_const_binders(it, input_output);\n \n         let movability = match self.db.body(parent)[expr] {\n-            hir_def::expr::Expr::Closure {\n-                closure_kind: hir_def::expr::ClosureKind::Generator(movability),\n+            hir_def::hir::Expr::Closure {\n+                closure_kind: hir_def::hir::ClosureKind::Generator(movability),\n                 ..\n             } => movability,\n             _ => unreachable!(\"non generator expression interned as generator\"),"}, {"sha": "d6a56124856513f34fe65eb5436668f0367b2d08", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -12,8 +12,9 @@ use hir_def::{\n use crate::{\n     db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n     from_placeholder_idx, to_chalk_trait_id, utils::generics, AdtId, AliasEq, AliasTy, Binders,\n-    CallableDefId, CallableSig, DynTy, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy,\n-    QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, TypeFlags, WhereClause,\n+    CallableDefId, CallableSig, ClosureId, DynTy, FnPointer, ImplTraitId, Interner, Lifetime,\n+    ProjectionTy, QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, TypeFlags,\n+    WhereClause,\n };\n \n pub trait TyExt {\n@@ -28,6 +29,7 @@ pub trait TyExt {\n     fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)>;\n     fn as_builtin(&self) -> Option<BuiltinType>;\n     fn as_tuple(&self) -> Option<&Substitution>;\n+    fn as_closure(&self) -> Option<ClosureId>;\n     fn as_fn_def(&self, db: &dyn HirDatabase) -> Option<FunctionId>;\n     fn as_reference(&self) -> Option<(&Ty, Lifetime, Mutability)>;\n     fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)>;\n@@ -128,6 +130,13 @@ impl TyExt for Ty {\n         }\n     }\n \n+    fn as_closure(&self) -> Option<ClosureId> {\n+        match self.kind(Interner) {\n+            TyKind::Closure(id, _) => Some(*id),\n+            _ => None,\n+        }\n+    }\n+\n     fn as_fn_def(&self, db: &dyn HirDatabase) -> Option<FunctionId> {\n         match self.callable_def(db) {\n             Some(CallableDefId::FunctionId(func)) => Some(func),"}, {"sha": "78033b4e89b59157370e83eb169ab277ca615400", "filename": "crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -3,7 +3,7 @@\n use base_db::CrateId;\n use chalk_ir::{BoundVar, DebruijnIndex, GenericArgData};\n use hir_def::{\n-    expr::Expr,\n+    hir::Expr,\n     path::Path,\n     resolver::{Resolver, ValueNs},\n     type_ref::ConstRef,"}, {"sha": "d987f41c7064744065bd1cdd91ae6cf6f890fc8f", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1105,6 +1105,81 @@ fn try_block() {\n     );\n }\n \n+#[test]\n+fn closures() {\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    const GOAL: i32 = {\n+        let y = 5;\n+        let c = |x| x + y;\n+        c(2)\n+    };\n+        \"#,\n+        7,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    const GOAL: i32 = {\n+        let y = 5;\n+        let c = |(a, b): &(i32, i32)| *a + *b + y;\n+        c(&(2, 3))\n+    };\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    const GOAL: i32 = {\n+        let mut y = 5;\n+        let c = |x| {\n+            y = y + x;\n+        };\n+        c(2);\n+        c(3);\n+        y\n+    };\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    struct X(i32);\n+    impl X {\n+        fn mult(&mut self, n: i32) {\n+            self.0 = self.0 * n\n+        }\n+    }\n+    const GOAL: i32 = {\n+        let x = X(1);\n+        let c = || {\n+            x.mult(2);\n+            || {\n+                x.mult(3);\n+                || {\n+                    || {\n+                        x.mult(4);\n+                        || {\n+                            x.mult(x.0);\n+                            || {\n+                                x.0\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+        let r = c()()()()()();\n+        r + x.0\n+    };\n+        \"#,\n+        24 * 24 * 2,\n+    );\n+}\n+\n #[test]\n fn or_pattern() {\n     check_number("}, {"sha": "3a8fb665c44f5297488cac79d515a79617b6359f", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -6,7 +6,7 @@ use std::sync::Arc;\n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n     db::DefDatabase,\n-    expr::ExprId,\n+    hir::ExprId,\n     layout::{Layout, LayoutError, TargetDataLayout},\n     AdtId, BlockId, ConstId, ConstParamId, DefWithBodyId, EnumVariantId, FunctionId, GenericDefId,\n     ImplId, LifetimeParamId, LocalFieldId, TypeOrConstParamId, VariantId,\n@@ -19,9 +19,9 @@ use crate::{\n     consteval::ConstEvalError,\n     method_resolution::{InherentImpls, TraitImpls, TyFingerprint},\n     mir::{BorrowckResult, MirBody, MirLowerError},\n-    Binders, CallableDefId, Const, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner,\n-    PolyFnSig, QuantifiedWhereClause, ReturnTypeImplTraits, Substitution, TraitRef, Ty, TyDefId,\n-    ValueTyDefId,\n+    Binders, CallableDefId, ClosureId, Const, FnDefId, GenericArg, ImplTraitId, InferenceResult,\n+    Interner, PolyFnSig, QuantifiedWhereClause, ReturnTypeImplTraits, Substitution, TraitRef, Ty,\n+    TyDefId, ValueTyDefId,\n };\n use hir_expand::name::Name;\n \n@@ -38,8 +38,11 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::cycle(crate::mir::mir_body_recover)]\n     fn mir_body(&self, def: DefWithBodyId) -> Result<Arc<MirBody>, MirLowerError>;\n \n+    #[salsa::invoke(crate::mir::mir_body_for_closure_query)]\n+    fn mir_body_for_closure(&self, def: ClosureId) -> Result<Arc<MirBody>, MirLowerError>;\n+\n     #[salsa::invoke(crate::mir::borrowck_query)]\n-    fn borrowck(&self, def: DefWithBodyId) -> Result<Arc<BorrowckResult>, MirLowerError>;\n+    fn borrowck(&self, def: DefWithBodyId) -> Result<Arc<[BorrowckResult]>, MirLowerError>;\n \n     #[salsa::invoke(crate::lower::ty_query)]\n     #[salsa::cycle(crate::lower::ty_recover)]"}, {"sha": "b3a699e2d1b343909f9b28e9cc807dc1964e80e5", "filename": "crates/hir-ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -16,8 +16,8 @@ use std::fmt;\n \n use base_db::CrateId;\n use hir_def::{\n-    adt::VariantData,\n-    expr::{Pat, PatId},\n+    data::adt::VariantData,\n+    hir::{Pat, PatId},\n     src::HasSource,\n     AdtId, AttrDefId, ConstId, EnumId, FunctionId, ItemContainerId, Lookup, ModuleDefId, StaticId,\n     StructId,"}, {"sha": "d39e077b716ff195c0c9d970b1e21b08ccf69d35", "filename": "crates/hir-ty/src/diagnostics/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -27,7 +27,7 @@ use crate::{\n \n pub(crate) use hir_def::{\n     body::Body,\n-    expr::{Expr, ExprId, MatchArm, Pat, PatId},\n+    hir::{Expr, ExprId, MatchArm, Pat, PatId},\n     LocalFieldId, VariantId,\n };\n "}, {"sha": "202f4aa66bcecee5b8c38e1021486d4ed3d04441", "filename": "crates/hir-ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,6 +1,6 @@\n //! Validation of matches.\n //!\n-//! This module provides lowering from [hir_def::expr::Pat] to [self::Pat] and match\n+//! This module provides lowering from [hir_def::hir::Pat] to [self::Pat] and match\n //! checking algorithm.\n //!\n //! It is modeled on the rustc module `rustc_mir_build::thir::pattern`.\n@@ -12,7 +12,7 @@ pub(crate) mod usefulness;\n \n use chalk_ir::Mutability;\n use hir_def::{\n-    adt::VariantData, body::Body, expr::PatId, AdtId, EnumVariantId, LocalFieldId, VariantId,\n+    body::Body, data::adt::VariantData, hir::PatId, AdtId, EnumVariantId, LocalFieldId, VariantId,\n };\n use hir_expand::name::Name;\n use stdx::{always, never};\n@@ -125,15 +125,15 @@ impl<'a> PatCtxt<'a> {\n         let variant = self.infer.variant_resolution_for_pat(pat);\n \n         let kind = match self.body[pat] {\n-            hir_def::expr::Pat::Wild => PatKind::Wild,\n+            hir_def::hir::Pat::Wild => PatKind::Wild,\n \n-            hir_def::expr::Pat::Lit(expr) => self.lower_lit(expr),\n+            hir_def::hir::Pat::Lit(expr) => self.lower_lit(expr),\n \n-            hir_def::expr::Pat::Path(ref path) => {\n+            hir_def::hir::Pat::Path(ref path) => {\n                 return self.lower_path(pat, path);\n             }\n \n-            hir_def::expr::Pat::Tuple { ref args, ellipsis } => {\n+            hir_def::hir::Pat::Tuple { ref args, ellipsis } => {\n                 let arity = match *ty.kind(Interner) {\n                     TyKind::Tuple(arity, _) => arity,\n                     _ => {\n@@ -146,7 +146,7 @@ impl<'a> PatCtxt<'a> {\n                 PatKind::Leaf { subpatterns }\n             }\n \n-            hir_def::expr::Pat::Bind { id, subpat, .. } => {\n+            hir_def::hir::Pat::Bind { id, subpat, .. } => {\n                 let bm = self.infer.pat_binding_modes[&pat];\n                 let name = &self.body.bindings[id].name;\n                 match (bm, ty.kind(Interner)) {\n@@ -161,13 +161,13 @@ impl<'a> PatCtxt<'a> {\n                 PatKind::Binding { name: name.clone(), subpattern: self.lower_opt_pattern(subpat) }\n             }\n \n-            hir_def::expr::Pat::TupleStruct { ref args, ellipsis, .. } if variant.is_some() => {\n+            hir_def::hir::Pat::TupleStruct { ref args, ellipsis, .. } if variant.is_some() => {\n                 let expected_len = variant.unwrap().variant_data(self.db.upcast()).fields().len();\n                 let subpatterns = self.lower_tuple_subpats(args, expected_len, ellipsis);\n                 self.lower_variant_or_leaf(pat, ty, subpatterns)\n             }\n \n-            hir_def::expr::Pat::Record { ref args, .. } if variant.is_some() => {\n+            hir_def::hir::Pat::Record { ref args, .. } if variant.is_some() => {\n                 let variant_data = variant.unwrap().variant_data(self.db.upcast());\n                 let subpatterns = args\n                     .iter()\n@@ -187,12 +187,12 @@ impl<'a> PatCtxt<'a> {\n                     }\n                 }\n             }\n-            hir_def::expr::Pat::TupleStruct { .. } | hir_def::expr::Pat::Record { .. } => {\n+            hir_def::hir::Pat::TupleStruct { .. } | hir_def::hir::Pat::Record { .. } => {\n                 self.errors.push(PatternError::UnresolvedVariant);\n                 PatKind::Wild\n             }\n \n-            hir_def::expr::Pat::Or(ref pats) => PatKind::Or { pats: self.lower_patterns(pats) },\n+            hir_def::hir::Pat::Or(ref pats) => PatKind::Or { pats: self.lower_patterns(pats) },\n \n             _ => {\n                 self.errors.push(PatternError::Unimplemented);\n@@ -279,8 +279,8 @@ impl<'a> PatCtxt<'a> {\n         }\n     }\n \n-    fn lower_lit(&mut self, expr: hir_def::expr::ExprId) -> PatKind {\n-        use hir_def::expr::{Expr, Literal::Bool};\n+    fn lower_lit(&mut self, expr: hir_def::hir::ExprId) -> PatKind {\n+        use hir_def::hir::{Expr, Literal::Bool};\n \n         match self.body[expr] {\n             Expr::Literal(Bool(value)) => PatKind::LiteralBool { value },"}, {"sha": "7c38e6583a75f2b128b89b259b88763980a1c674", "filename": "crates/hir-ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -3,7 +3,7 @@\n \n use hir_def::{\n     body::Body,\n-    expr::{Expr, ExprId, UnaryOp},\n+    hir::{Expr, ExprId, UnaryOp},\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n     DefWithBodyId,\n };"}, {"sha": "f892a815197082e201d0e1108c993580cea5548d", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 64, "deletions": 15, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -7,8 +7,8 @@ use std::fmt::{self, Debug};\n use base_db::CrateId;\n use chalk_ir::{BoundVar, TyKind};\n use hir_def::{\n-    adt::VariantData,\n     body,\n+    data::adt::VariantData,\n     db::DefDatabase,\n     find_path,\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n@@ -23,6 +23,7 @@ use hir_expand::{hygiene::Hygiene, name::Name};\n use intern::{Internable, Interned};\n use itertools::Itertools;\n use smallvec::SmallVec;\n+use stdx::never;\n \n use crate::{\n     db::HirDatabase,\n@@ -64,6 +65,7 @@ pub struct HirFormatter<'a> {\n     curr_size: usize,\n     pub(crate) max_size: Option<usize>,\n     omit_verbose_types: bool,\n+    closure_style: ClosureStyle,\n     display_target: DisplayTarget,\n }\n \n@@ -87,6 +89,7 @@ pub trait HirDisplay {\n         max_size: Option<usize>,\n         omit_verbose_types: bool,\n         display_target: DisplayTarget,\n+        closure_style: ClosureStyle,\n     ) -> HirDisplayWrapper<'a, Self>\n     where\n         Self: Sized,\n@@ -95,7 +98,14 @@ pub trait HirDisplay {\n             !matches!(display_target, DisplayTarget::SourceCode { .. }),\n             \"HirDisplayWrapper cannot fail with DisplaySourceCodeError, use HirDisplay::hir_fmt directly instead\"\n         );\n-        HirDisplayWrapper { db, t: self, max_size, omit_verbose_types, display_target }\n+        HirDisplayWrapper {\n+            db,\n+            t: self,\n+            max_size,\n+            omit_verbose_types,\n+            display_target,\n+            closure_style,\n+        }\n     }\n \n     /// Returns a `Display`able type that is human-readable.\n@@ -109,6 +119,7 @@ pub trait HirDisplay {\n             t: self,\n             max_size: None,\n             omit_verbose_types: false,\n+            closure_style: ClosureStyle::ImplFn,\n             display_target: DisplayTarget::Diagnostics,\n         }\n     }\n@@ -128,6 +139,7 @@ pub trait HirDisplay {\n             t: self,\n             max_size,\n             omit_verbose_types: true,\n+            closure_style: ClosureStyle::ImplFn,\n             display_target: DisplayTarget::Diagnostics,\n         }\n     }\n@@ -147,6 +159,7 @@ pub trait HirDisplay {\n             curr_size: 0,\n             max_size: None,\n             omit_verbose_types: false,\n+            closure_style: ClosureStyle::ImplFn,\n             display_target: DisplayTarget::SourceCode { module_id },\n         }) {\n             Ok(()) => {}\n@@ -166,6 +179,7 @@ pub trait HirDisplay {\n             t: self,\n             max_size: None,\n             omit_verbose_types: false,\n+            closure_style: ClosureStyle::ImplFn,\n             display_target: DisplayTarget::Test,\n         }\n     }\n@@ -253,7 +267,6 @@ impl DisplayTarget {\n pub enum DisplaySourceCodeError {\n     PathNotFound,\n     UnknownType,\n-    Closure,\n     Generator,\n }\n \n@@ -274,9 +287,23 @@ pub struct HirDisplayWrapper<'a, T> {\n     t: &'a T,\n     max_size: Option<usize>,\n     omit_verbose_types: bool,\n+    closure_style: ClosureStyle,\n     display_target: DisplayTarget,\n }\n \n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub enum ClosureStyle {\n+    /// `impl FnX(i32, i32) -> i32`, where `FnX` is the most special trait between `Fn`, `FnMut`, `FnOnce` that the\n+    /// closure implements. This is the default.\n+    ImplFn,\n+    /// `|i32, i32| -> i32`\n+    RANotation,\n+    /// `{closure#14825}`, useful for some diagnostics (like type mismatch) and internal usage.\n+    ClosureWithId,\n+    /// `\u2026`, which is the `TYPE_HINT_TRUNCATION`\n+    Hide,\n+}\n+\n impl<T: HirDisplay> HirDisplayWrapper<'_, T> {\n     pub fn write_to<F: HirWrite>(&self, f: &mut F) -> Result<(), HirDisplayError> {\n         self.t.hir_fmt(&mut HirFormatter {\n@@ -287,8 +314,14 @@ impl<T: HirDisplay> HirDisplayWrapper<'_, T> {\n             max_size: self.max_size,\n             omit_verbose_types: self.omit_verbose_types,\n             display_target: self.display_target,\n+            closure_style: self.closure_style,\n         })\n     }\n+\n+    pub fn with_closure_style(mut self, c: ClosureStyle) -> Self {\n+        self.closure_style = c;\n+        self\n+    }\n }\n \n impl<'a, T> fmt::Display for HirDisplayWrapper<'a, T>\n@@ -919,26 +952,42 @@ impl HirDisplay for Ty {\n                     }\n                 }\n             }\n-            TyKind::Closure(.., substs) => {\n-                if f.display_target.is_source_code() {\n-                    return Err(HirDisplayError::DisplaySourceCodeError(\n-                        DisplaySourceCodeError::Closure,\n-                    ));\n+            TyKind::Closure(id, substs) => {\n+                if f.display_target.is_source_code() && f.closure_style != ClosureStyle::ImplFn {\n+                    never!(\"Only `impl Fn` is valid for displaying closures in source code\");\n+                }\n+                match f.closure_style {\n+                    ClosureStyle::Hide => return write!(f, \"{TYPE_HINT_TRUNCATION}\"),\n+                    ClosureStyle::ClosureWithId => {\n+                        return write!(f, \"{{closure#{:?}}}\", id.0.as_u32())\n+                    }\n+                    _ => (),\n                 }\n                 let sig = substs.at(Interner, 0).assert_ty_ref(Interner).callable_sig(db);\n                 if let Some(sig) = sig {\n+                    let (def, _) = db.lookup_intern_closure((*id).into());\n+                    let infer = db.infer(def);\n+                    let (_, kind) = infer.closure_info(id);\n+                    match f.closure_style {\n+                        ClosureStyle::ImplFn => write!(f, \"impl {kind:?}(\")?,\n+                        ClosureStyle::RANotation => write!(f, \"|\")?,\n+                        _ => unreachable!(),\n+                    }\n                     if sig.params().is_empty() {\n-                        write!(f, \"||\")?;\n                     } else if f.should_truncate() {\n-                        write!(f, \"|{TYPE_HINT_TRUNCATION}|\")?;\n+                        write!(f, \"{TYPE_HINT_TRUNCATION}\")?;\n                     } else {\n-                        write!(f, \"|\")?;\n                         f.write_joined(sig.params(), \", \")?;\n-                        write!(f, \"|\")?;\n                     };\n-\n-                    write!(f, \" -> \")?;\n-                    sig.ret().hir_fmt(f)?;\n+                    match f.closure_style {\n+                        ClosureStyle::ImplFn => write!(f, \")\")?,\n+                        ClosureStyle::RANotation => write!(f, \"|\")?,\n+                        _ => unreachable!(),\n+                    }\n+                    if f.closure_style == ClosureStyle::RANotation || !sig.ret().is_unit() {\n+                        write!(f, \" -> \")?;\n+                        sig.ret().hir_fmt(f)?;\n+                    }\n                 } else {\n                     write!(f, \"{{closure}}\")?;\n                 }"}, {"sha": "d90ca77b55c0d469013dab5e7b4d33d16a5bcbad", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 95, "deletions": 41, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -18,11 +18,12 @@ use std::{convert::identity, ops::Index};\n \n use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n use either::Either;\n+use hir_def::hir::LabelId;\n use hir_def::{\n     body::Body,\n     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n     data::{ConstData, StaticData},\n-    expr::{BindingAnnotation, BindingId, ExprId, ExprOrPatId, PatId},\n+    hir::{BindingAnnotation, BindingId, ExprId, ExprOrPatId, PatId},\n     lang_item::{LangItem, LangItemTarget},\n     layout::Integer,\n     path::{ModPath, Path},\n@@ -32,15 +33,15 @@ use hir_def::{\n     TraitId, TypeAliasId, VariantId,\n };\n use hir_expand::name::{name, Name};\n-use la_arena::ArenaMap;\n+use la_arena::{ArenaMap, Entry};\n use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::{always, never};\n \n use crate::{\n     db::HirDatabase, fold_tys, infer::coerce::CoerceMany, lower::ImplTraitLoweringMode,\n-    static_lifetime, to_assoc_type_id, AliasEq, AliasTy, DomainGoal, GenericArg, Goal, ImplTraitId,\n-    InEnvironment, Interner, ProjectionTy, RpitId, Substitution, TraitRef, Ty, TyBuilder, TyExt,\n-    TyKind,\n+    static_lifetime, to_assoc_type_id, traits::FnTrait, AliasEq, AliasTy, ClosureId, DomainGoal,\n+    GenericArg, Goal, ImplTraitId, InEnvironment, Interner, ProjectionTy, RpitId, Substitution,\n+    TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -51,6 +52,8 @@ pub use coerce::could_coerce;\n #[allow(unreachable_pub)]\n pub use unify::could_unify;\n \n+pub(crate) use self::closure::{CaptureKind, CapturedItem, CapturedItemWithoutTy};\n+\n pub(crate) mod unify;\n mod path;\n mod expr;\n@@ -102,6 +105,8 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n \n     ctx.infer_mut_body();\n \n+    ctx.infer_closures();\n+\n     Arc::new(ctx.resolve_all())\n }\n \n@@ -188,7 +193,7 @@ pub enum InferenceDiagnostic {\n         /// Contains the type the field resolves to\n         field_with_same_name: Option<Ty>,\n     },\n-    // FIXME: Make this proper\n+    // FIXME: This should be emitted in body lowering\n     BreakOutsideOfLoop {\n         expr: ExprId,\n         is_break: bool,\n@@ -311,6 +316,13 @@ pub enum AutoBorrow {\n     RawPtr(Mutability),\n }\n \n+impl AutoBorrow {\n+    fn mutability(self) -> Mutability {\n+        let (AutoBorrow::Ref(m) | AutoBorrow::RawPtr(m)) = self;\n+        m\n+    }\n+}\n+\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum PointerCast {\n     /// Go from a fn-item type to a fn-pointer type.\n@@ -372,6 +384,9 @@ pub struct InferenceResult {\n     pub pat_adjustments: FxHashMap<PatId, Vec<Ty>>,\n     pub pat_binding_modes: FxHashMap<PatId, BindingMode>,\n     pub expr_adjustments: FxHashMap<ExprId, Vec<Adjustment>>,\n+    pub(crate) closure_info: FxHashMap<ClosureId, (Vec<CapturedItem>, FnTrait)>,\n+    // FIXME: remove this field\n+    pub mutated_bindings_in_closure: FxHashSet<BindingId>,\n }\n \n impl InferenceResult {\n@@ -408,6 +423,9 @@ impl InferenceResult {\n             _ => None,\n         })\n     }\n+    pub(crate) fn closure_info(&self, closure: &ClosureId) -> &(Vec<CapturedItem>, FnTrait) {\n+        self.closure_info.get(closure).unwrap()\n+    }\n }\n \n impl Index<ExprId> for InferenceResult {\n@@ -459,6 +477,14 @@ pub(crate) struct InferenceContext<'a> {\n     resume_yield_tys: Option<(Ty, Ty)>,\n     diverges: Diverges,\n     breakables: Vec<BreakableContext>,\n+\n+    // fields related to closure capture\n+    current_captures: Vec<CapturedItemWithoutTy>,\n+    current_closure: Option<ClosureId>,\n+    /// Stores the list of closure ids that need to be analyzed before this closure. See the\n+    /// comment on `InferenceContext::sort_closures`\n+    closure_dependecies: FxHashMap<ClosureId, Vec<ClosureId>>,\n+    deferred_closures: FxHashMap<ClosureId, Vec<(Ty, Ty, Vec<Ty>, ExprId)>>,\n }\n \n #[derive(Clone, Debug)]\n@@ -468,7 +494,7 @@ struct BreakableContext {\n     /// The coercion target of the context.\n     coerce: Option<CoerceMany>,\n     /// The optional label of the context.\n-    label: Option<name::Name>,\n+    label: Option<LabelId>,\n     kind: BreakableKind,\n }\n \n@@ -483,21 +509,21 @@ enum BreakableKind {\n \n fn find_breakable<'c>(\n     ctxs: &'c mut [BreakableContext],\n-    label: Option<&name::Name>,\n+    label: Option<LabelId>,\n ) -> Option<&'c mut BreakableContext> {\n     let mut ctxs = ctxs\n         .iter_mut()\n         .rev()\n         .take_while(|it| matches!(it.kind, BreakableKind::Block | BreakableKind::Loop));\n     match label {\n-        Some(_) => ctxs.find(|ctx| ctx.label.as_ref() == label),\n+        Some(_) => ctxs.find(|ctx| ctx.label == label),\n         None => ctxs.find(|ctx| matches!(ctx.kind, BreakableKind::Loop)),\n     }\n }\n \n fn find_continuable<'c>(\n     ctxs: &'c mut [BreakableContext],\n-    label: Option<&name::Name>,\n+    label: Option<LabelId>,\n ) -> Option<&'c mut BreakableContext> {\n     match label {\n         Some(_) => find_breakable(ctxs, label).filter(|it| matches!(it.kind, BreakableKind::Loop)),\n@@ -526,6 +552,10 @@ impl<'a> InferenceContext<'a> {\n             resolver,\n             diverges: Diverges::Maybe,\n             breakables: Vec::new(),\n+            current_captures: vec![],\n+            current_closure: None,\n+            deferred_closures: FxHashMap::default(),\n+            closure_dependecies: FxHashMap::default(),\n         }\n     }\n \n@@ -617,7 +647,7 @@ impl<'a> InferenceContext<'a> {\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver)\n             .with_impl_trait_mode(ImplTraitLoweringMode::Param);\n         let mut param_tys =\n-            data.params.iter().map(|(_, type_ref)| ctx.lower_ty(type_ref)).collect::<Vec<_>>();\n+            data.params.iter().map(|type_ref| ctx.lower_ty(type_ref)).collect::<Vec<_>>();\n         // Check if function contains a va_list, if it does then we append it to the parameter types\n         // that are collected from the function data\n         if data.is_varargs() {\n@@ -646,36 +676,16 @@ impl<'a> InferenceContext<'a> {\n         let return_ty = if let Some(rpits) = self.db.return_type_impl_traits(func) {\n             // RPIT opaque types use substitution of their parent function.\n             let fn_placeholders = TyBuilder::placeholder_subst(self.db, func);\n-            fold_tys(\n-                return_ty,\n-                |ty, _| {\n-                    let opaque_ty_id = match ty.kind(Interner) {\n-                        TyKind::OpaqueType(opaque_ty_id, _) => *opaque_ty_id,\n-                        _ => return ty,\n-                    };\n-                    let idx = match self.db.lookup_intern_impl_trait_id(opaque_ty_id.into()) {\n-                        ImplTraitId::ReturnTypeImplTrait(_, idx) => idx,\n-                        _ => unreachable!(),\n-                    };\n-                    let bounds = (*rpits).map_ref(|rpits| {\n-                        rpits.impl_traits[idx].bounds.map_ref(|it| it.into_iter())\n-                    });\n-                    let var = self.table.new_type_var();\n-                    let var_subst = Substitution::from1(Interner, var.clone());\n-                    for bound in bounds {\n-                        let predicate =\n-                            bound.map(|it| it.cloned()).substitute(Interner, &fn_placeholders);\n-                        let (var_predicate, binders) = predicate\n-                            .substitute(Interner, &var_subst)\n-                            .into_value_and_skipped_binders();\n-                        always!(binders.is_empty(Interner)); // quantified where clauses not yet handled\n-                        self.push_obligation(var_predicate.cast(Interner));\n-                    }\n-                    self.result.type_of_rpit.insert(idx, var.clone());\n-                    var\n-                },\n-                DebruijnIndex::INNERMOST,\n-            )\n+            let result =\n+                self.insert_inference_vars_for_rpit(return_ty, rpits.clone(), fn_placeholders);\n+            let rpits = rpits.skip_binders();\n+            for (id, _) in rpits.impl_traits.iter() {\n+                if let Entry::Vacant(e) = self.result.type_of_rpit.entry(id) {\n+                    never!(\"Missed RPIT in `insert_inference_vars_for_rpit`\");\n+                    e.insert(TyKind::Error.intern(Interner));\n+                }\n+            }\n+            result\n         } else {\n             return_ty\n         };\n@@ -684,6 +694,50 @@ impl<'a> InferenceContext<'a> {\n         self.return_coercion = Some(CoerceMany::new(self.return_ty.clone()));\n     }\n \n+    fn insert_inference_vars_for_rpit<T>(\n+        &mut self,\n+        t: T,\n+        rpits: Arc<chalk_ir::Binders<crate::ReturnTypeImplTraits>>,\n+        fn_placeholders: Substitution,\n+    ) -> T\n+    where\n+        T: crate::HasInterner<Interner = Interner> + crate::TypeFoldable<Interner>,\n+    {\n+        fold_tys(\n+            t,\n+            |ty, _| {\n+                let opaque_ty_id = match ty.kind(Interner) {\n+                    TyKind::OpaqueType(opaque_ty_id, _) => *opaque_ty_id,\n+                    _ => return ty,\n+                };\n+                let idx = match self.db.lookup_intern_impl_trait_id(opaque_ty_id.into()) {\n+                    ImplTraitId::ReturnTypeImplTrait(_, idx) => idx,\n+                    _ => unreachable!(),\n+                };\n+                let bounds = (*rpits)\n+                    .map_ref(|rpits| rpits.impl_traits[idx].bounds.map_ref(|it| it.into_iter()));\n+                let var = self.table.new_type_var();\n+                let var_subst = Substitution::from1(Interner, var.clone());\n+                for bound in bounds {\n+                    let predicate =\n+                        bound.map(|it| it.cloned()).substitute(Interner, &fn_placeholders);\n+                    let (var_predicate, binders) =\n+                        predicate.substitute(Interner, &var_subst).into_value_and_skipped_binders();\n+                    always!(binders.is_empty(Interner)); // quantified where clauses not yet handled\n+                    let var_predicate = self.insert_inference_vars_for_rpit(\n+                        var_predicate,\n+                        rpits.clone(),\n+                        fn_placeholders.clone(),\n+                    );\n+                    self.push_obligation(var_predicate.cast(Interner));\n+                }\n+                self.result.type_of_rpit.insert(idx, var.clone());\n+                var\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n+    }\n+\n     fn infer_body(&mut self) {\n         match self.return_coercion {\n             Some(_) => self.infer_return(self.body.body_expr),"}, {"sha": "28cb301f3e49294b8e0b664c9e084c4943e6d2b6", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 718, "deletions": 4, "changes": 722, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,12 +1,29 @@\n //! Inference of closure parameter types based on the closure's expected type.\n \n-use chalk_ir::{cast::Cast, AliasEq, AliasTy, FnSubst, WhereClause};\n-use hir_def::{expr::ExprId, HasModule};\n+use std::{cmp, collections::HashMap, convert::Infallible, mem};\n+\n+use chalk_ir::{cast::Cast, AliasEq, AliasTy, FnSubst, Mutability, TyKind, WhereClause};\n+use hir_def::{\n+    hir::{\n+        Array, BinaryOp, BindingAnnotation, BindingId, CaptureBy, Expr, ExprId, Pat, PatId,\n+        Statement, UnaryOp,\n+    },\n+    lang_item::LangItem,\n+    resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n+    FieldId, HasModule, VariantId,\n+};\n+use hir_expand::name;\n+use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n+use stdx::never;\n \n use crate::{\n-    to_chalk_trait_id, utils, ChalkTraitId, DynTy, FnPointer, FnSig, Interner, Substitution, Ty,\n-    TyExt, TyKind,\n+    mir::{BorrowKind, ProjectionElem},\n+    static_lifetime, to_chalk_trait_id,\n+    traits::FnTrait,\n+    utils::{self, pattern_matching_dereference_count},\n+    Adjust, Adjustment, Canonical, CanonicalVarKinds, ChalkTraitId, ClosureId, DynTy, FnPointer,\n+    FnSig, InEnvironment, Interner, Substitution, Ty, TyBuilder, TyExt,\n };\n \n use super::{Expectation, InferenceContext};\n@@ -86,3 +103,700 @@ impl InferenceContext<'_> {\n         None\n     }\n }\n+\n+// The below functions handle capture and closure kind (Fn, FnMut, ..)\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub(crate) struct HirPlace {\n+    pub(crate) local: BindingId,\n+    pub(crate) projections: Vec<ProjectionElem<Infallible, Ty>>,\n+}\n+impl HirPlace {\n+    fn ty(&self, ctx: &mut InferenceContext<'_>) -> Ty {\n+        let mut ty = ctx.table.resolve_completely(ctx.result[self.local].clone());\n+        for p in &self.projections {\n+            ty = p.projected_ty(ty, ctx.db, |_, _| {\n+                unreachable!(\"Closure field only happens in MIR\");\n+            });\n+        }\n+        ty.clone()\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub(crate) enum CaptureKind {\n+    ByRef(BorrowKind),\n+    ByValue,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub(crate) struct CapturedItem {\n+    pub(crate) place: HirPlace,\n+    pub(crate) kind: CaptureKind,\n+    pub(crate) ty: Ty,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub(crate) struct CapturedItemWithoutTy {\n+    pub(crate) place: HirPlace,\n+    pub(crate) kind: CaptureKind,\n+}\n+\n+impl CapturedItemWithoutTy {\n+    fn with_ty(self, ctx: &mut InferenceContext<'_>) -> CapturedItem {\n+        let ty = self.place.ty(ctx).clone();\n+        let ty = match &self.kind {\n+            CaptureKind::ByValue => ty,\n+            CaptureKind::ByRef(bk) => {\n+                let m = match bk {\n+                    BorrowKind::Mut { .. } => Mutability::Mut,\n+                    _ => Mutability::Not,\n+                };\n+                TyKind::Ref(m, static_lifetime(), ty).intern(Interner)\n+            }\n+        };\n+        CapturedItem { place: self.place, kind: self.kind, ty }\n+    }\n+}\n+\n+impl InferenceContext<'_> {\n+    fn place_of_expr(&mut self, tgt_expr: ExprId) -> Option<HirPlace> {\n+        let r = self.place_of_expr_without_adjust(tgt_expr)?;\n+        let default = vec![];\n+        let adjustments = self.result.expr_adjustments.get(&tgt_expr).unwrap_or(&default);\n+        apply_adjusts_to_place(r, adjustments)\n+    }\n+\n+    fn place_of_expr_without_adjust(&mut self, tgt_expr: ExprId) -> Option<HirPlace> {\n+        match &self.body[tgt_expr] {\n+            Expr::Path(p) => {\n+                let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n+                if let Some(r) = resolver.resolve_path_in_value_ns(self.db.upcast(), p) {\n+                    if let ResolveValueResult::ValueNs(v) = r {\n+                        if let ValueNs::LocalBinding(b) = v {\n+                            return Some(HirPlace { local: b, projections: vec![] });\n+                        }\n+                    }\n+                }\n+            }\n+            Expr::Field { expr, name } => {\n+                let mut place = self.place_of_expr(*expr)?;\n+                if let TyKind::Tuple(..) = self.expr_ty(*expr).kind(Interner) {\n+                    let index = name.as_tuple_index()?;\n+                    place.projections.push(ProjectionElem::TupleOrClosureField(index))\n+                } else {\n+                    let field = self.result.field_resolution(tgt_expr)?;\n+                    place.projections.push(ProjectionElem::Field(field));\n+                }\n+                return Some(place);\n+            }\n+            _ => (),\n+        }\n+        None\n+    }\n+\n+    fn push_capture(&mut self, capture: CapturedItemWithoutTy) {\n+        self.current_captures.push(capture);\n+    }\n+\n+    fn ref_expr(&mut self, expr: ExprId) {\n+        if let Some(place) = self.place_of_expr(expr) {\n+            self.add_capture(place, CaptureKind::ByRef(BorrowKind::Shared));\n+        }\n+        self.walk_expr(expr);\n+    }\n+\n+    fn add_capture(&mut self, place: HirPlace, kind: CaptureKind) {\n+        if self.is_upvar(&place) {\n+            self.push_capture(CapturedItemWithoutTy { place, kind });\n+        }\n+    }\n+\n+    fn mutate_expr(&mut self, expr: ExprId) {\n+        if let Some(place) = self.place_of_expr(expr) {\n+            self.add_capture(\n+                place,\n+                CaptureKind::ByRef(BorrowKind::Mut { allow_two_phase_borrow: false }),\n+            );\n+        }\n+        self.walk_expr(expr);\n+    }\n+\n+    fn consume_expr(&mut self, expr: ExprId) {\n+        if let Some(place) = self.place_of_expr(expr) {\n+            self.consume_place(place);\n+        }\n+        self.walk_expr(expr);\n+    }\n+\n+    fn consume_place(&mut self, place: HirPlace) {\n+        if self.is_upvar(&place) {\n+            let ty = place.ty(self).clone();\n+            let kind = if self.is_ty_copy(ty) {\n+                CaptureKind::ByRef(BorrowKind::Shared)\n+            } else {\n+                CaptureKind::ByValue\n+            };\n+            self.push_capture(CapturedItemWithoutTy { place, kind });\n+        }\n+    }\n+\n+    fn walk_expr_with_adjust(&mut self, tgt_expr: ExprId, adjustment: &[Adjustment]) {\n+        if let Some((last, rest)) = adjustment.split_last() {\n+            match last.kind {\n+                Adjust::NeverToAny | Adjust::Deref(None) | Adjust::Pointer(_) => {\n+                    self.walk_expr_with_adjust(tgt_expr, rest)\n+                }\n+                Adjust::Deref(Some(m)) => match m.0 {\n+                    Some(m) => {\n+                        self.ref_capture_with_adjusts(m, tgt_expr, rest);\n+                    }\n+                    None => unreachable!(),\n+                },\n+                Adjust::Borrow(b) => {\n+                    self.ref_capture_with_adjusts(b.mutability(), tgt_expr, rest);\n+                }\n+            }\n+        } else {\n+            self.walk_expr_without_adjust(tgt_expr);\n+        }\n+    }\n+\n+    fn ref_capture_with_adjusts(&mut self, m: Mutability, tgt_expr: ExprId, rest: &[Adjustment]) {\n+        let capture_kind = match m {\n+            Mutability::Mut => {\n+                CaptureKind::ByRef(BorrowKind::Mut { allow_two_phase_borrow: false })\n+            }\n+            Mutability::Not => CaptureKind::ByRef(BorrowKind::Shared),\n+        };\n+        if let Some(place) = self.place_of_expr_without_adjust(tgt_expr) {\n+            if let Some(place) = apply_adjusts_to_place(place, rest) {\n+                if self.is_upvar(&place) {\n+                    self.push_capture(CapturedItemWithoutTy { place, kind: capture_kind });\n+                }\n+            }\n+        }\n+        self.walk_expr_with_adjust(tgt_expr, rest);\n+    }\n+\n+    fn walk_expr(&mut self, tgt_expr: ExprId) {\n+        if let Some(x) = self.result.expr_adjustments.get_mut(&tgt_expr) {\n+            // FIXME: this take is completely unneeded, and just is here to make borrow checker\n+            // happy. Remove it if you can.\n+            let x_taken = mem::take(x);\n+            self.walk_expr_with_adjust(tgt_expr, &x_taken);\n+            *self.result.expr_adjustments.get_mut(&tgt_expr).unwrap() = x_taken;\n+        } else {\n+            self.walk_expr_without_adjust(tgt_expr);\n+        }\n+    }\n+\n+    fn walk_expr_without_adjust(&mut self, tgt_expr: ExprId) {\n+        match &self.body[tgt_expr] {\n+            Expr::If { condition, then_branch, else_branch } => {\n+                self.consume_expr(*condition);\n+                self.consume_expr(*then_branch);\n+                if let &Some(expr) = else_branch {\n+                    self.consume_expr(expr);\n+                }\n+            }\n+            Expr::Async { statements, tail, .. }\n+            | Expr::Const { statements, tail, .. }\n+            | Expr::Unsafe { statements, tail, .. }\n+            | Expr::Block { statements, tail, .. } => {\n+                for s in statements.iter() {\n+                    match s {\n+                        Statement::Let { pat, type_ref: _, initializer, else_branch } => {\n+                            if let Some(else_branch) = else_branch {\n+                                self.consume_expr(*else_branch);\n+                                if let Some(initializer) = initializer {\n+                                    self.consume_expr(*initializer);\n+                                }\n+                                return;\n+                            }\n+                            if let Some(initializer) = initializer {\n+                                self.walk_expr(*initializer);\n+                                if let Some(place) = self.place_of_expr(*initializer) {\n+                                    let ty = self.expr_ty(*initializer);\n+                                    self.consume_with_pat(\n+                                        place,\n+                                        ty,\n+                                        BindingAnnotation::Unannotated,\n+                                        *pat,\n+                                    );\n+                                }\n+                            }\n+                        }\n+                        Statement::Expr { expr, has_semi: _ } => {\n+                            self.consume_expr(*expr);\n+                        }\n+                    }\n+                }\n+                if let Some(tail) = tail {\n+                    self.consume_expr(*tail);\n+                }\n+            }\n+            Expr::While { condition, body, label: _ }\n+            | Expr::For { iterable: condition, pat: _, body, label: _ } => {\n+                self.consume_expr(*condition);\n+                self.consume_expr(*body);\n+            }\n+            Expr::Call { callee, args, is_assignee_expr: _ } => {\n+                self.consume_expr(*callee);\n+                self.consume_exprs(args.iter().copied());\n+            }\n+            Expr::MethodCall { receiver, args, .. } => {\n+                self.consume_expr(*receiver);\n+                self.consume_exprs(args.iter().copied());\n+            }\n+            Expr::Match { expr, arms } => {\n+                self.consume_expr(*expr);\n+                for arm in arms.iter() {\n+                    self.consume_expr(arm.expr);\n+                }\n+            }\n+            Expr::Break { expr, label: _ }\n+            | Expr::Return { expr }\n+            | Expr::Yield { expr }\n+            | Expr::Yeet { expr } => {\n+                if let &Some(expr) = expr {\n+                    self.consume_expr(expr);\n+                }\n+            }\n+            Expr::RecordLit { fields, spread, .. } => {\n+                if let &Some(expr) = spread {\n+                    self.consume_expr(expr);\n+                }\n+                self.consume_exprs(fields.iter().map(|x| x.expr));\n+            }\n+            Expr::Field { expr, name: _ } => self.select_from_expr(*expr),\n+            Expr::UnaryOp { expr, op: UnaryOp::Deref } => {\n+                if let Some((f, _)) = self.result.method_resolution(tgt_expr) {\n+                    let mutability = 'b: {\n+                        if let Some(deref_trait) =\n+                            self.resolve_lang_item(LangItem::DerefMut).and_then(|x| x.as_trait())\n+                        {\n+                            if let Some(deref_fn) =\n+                                self.db.trait_data(deref_trait).method_by_name(&name![deref_mut])\n+                            {\n+                                break 'b deref_fn == f;\n+                            }\n+                        }\n+                        false\n+                    };\n+                    if mutability {\n+                        self.mutate_expr(*expr);\n+                    } else {\n+                        self.ref_expr(*expr);\n+                    }\n+                } else {\n+                    self.select_from_expr(*expr);\n+                }\n+            }\n+            Expr::UnaryOp { expr, op: _ }\n+            | Expr::Array(Array::Repeat { initializer: expr, repeat: _ })\n+            | Expr::Await { expr }\n+            | Expr::Loop { body: expr, label: _ }\n+            | Expr::Let { pat: _, expr }\n+            | Expr::Box { expr }\n+            | Expr::Cast { expr, type_ref: _ } => {\n+                self.consume_expr(*expr);\n+            }\n+            Expr::Ref { expr, rawness: _, mutability } => match mutability {\n+                hir_def::type_ref::Mutability::Shared => self.ref_expr(*expr),\n+                hir_def::type_ref::Mutability::Mut => self.mutate_expr(*expr),\n+            },\n+            Expr::BinaryOp { lhs, rhs, op } => {\n+                let Some(op) = op else {\n+                    return;\n+                };\n+                if matches!(op, BinaryOp::Assignment { .. }) {\n+                    self.mutate_expr(*lhs);\n+                    self.consume_expr(*rhs);\n+                    return;\n+                }\n+                self.consume_expr(*lhs);\n+                self.consume_expr(*rhs);\n+            }\n+            Expr::Range { lhs, rhs, range_type: _ } => {\n+                if let &Some(expr) = lhs {\n+                    self.consume_expr(expr);\n+                }\n+                if let &Some(expr) = rhs {\n+                    self.consume_expr(expr);\n+                }\n+            }\n+            Expr::Index { base, index } => {\n+                self.select_from_expr(*base);\n+                self.consume_expr(*index);\n+            }\n+            Expr::Closure { .. } => {\n+                let ty = self.expr_ty(tgt_expr);\n+                let TyKind::Closure(id, _) = ty.kind(Interner) else {\n+                    never!(\"closure type is always closure\");\n+                    return;\n+                };\n+                let (captures, _) =\n+                    self.result.closure_info.get(id).expect(\n+                        \"We sort closures, so we should always have data for inner closures\",\n+                    );\n+                let mut cc = mem::take(&mut self.current_captures);\n+                cc.extend(\n+                    captures\n+                        .iter()\n+                        .filter(|x| self.is_upvar(&x.place))\n+                        .map(|x| CapturedItemWithoutTy { place: x.place.clone(), kind: x.kind }),\n+                );\n+                self.current_captures = cc;\n+            }\n+            Expr::Array(Array::ElementList { elements: exprs, is_assignee_expr: _ })\n+            | Expr::Tuple { exprs, is_assignee_expr: _ } => {\n+                self.consume_exprs(exprs.iter().copied())\n+            }\n+            Expr::Missing\n+            | Expr::Continue { .. }\n+            | Expr::Path(_)\n+            | Expr::Literal(_)\n+            | Expr::Underscore => (),\n+        }\n+    }\n+\n+    fn expr_ty(&mut self, expr: ExprId) -> Ty {\n+        self.result[expr].clone()\n+    }\n+\n+    fn is_upvar(&self, place: &HirPlace) -> bool {\n+        let b = &self.body[place.local];\n+        if let Some(c) = self.current_closure {\n+            let (_, root) = self.db.lookup_intern_closure(c.into());\n+            return b.is_upvar(root);\n+        }\n+        false\n+    }\n+\n+    fn is_ty_copy(&self, ty: Ty) -> bool {\n+        if let TyKind::Closure(id, _) = ty.kind(Interner) {\n+            // FIXME: We handle closure as a special case, since chalk consider every closure as copy. We\n+            // should probably let chalk know which closures are copy, but I don't know how doing it\n+            // without creating query cycles.\n+            return self.result.closure_info.get(id).map(|x| x.1 == FnTrait::Fn).unwrap_or(true);\n+        }\n+        let crate_id = self.owner.module(self.db.upcast()).krate();\n+        let Some(copy_trait) = self.db.lang_item(crate_id, LangItem::Copy).and_then(|x| x.as_trait()) else {\n+            return false;\n+        };\n+        let trait_ref = TyBuilder::trait_ref(self.db, copy_trait).push(ty).build();\n+        let env = self.db.trait_environment_for_body(self.owner);\n+        let goal = Canonical {\n+            value: InEnvironment::new(&env.env, trait_ref.cast(Interner)),\n+            binders: CanonicalVarKinds::empty(Interner),\n+        };\n+        self.db.trait_solve(crate_id, None, goal).is_some()\n+    }\n+\n+    fn select_from_expr(&mut self, expr: ExprId) {\n+        self.walk_expr(expr);\n+    }\n+\n+    fn adjust_for_move_closure(&mut self) {\n+        for capture in &mut self.current_captures {\n+            if let Some(first_deref) =\n+                capture.place.projections.iter().position(|proj| *proj == ProjectionElem::Deref)\n+            {\n+                capture.place.projections.truncate(first_deref);\n+            }\n+            capture.kind = CaptureKind::ByValue;\n+        }\n+    }\n+\n+    fn minimize_captures(&mut self) {\n+        self.current_captures.sort_by_key(|x| x.place.projections.len());\n+        let mut hash_map = HashMap::<HirPlace, usize>::new();\n+        let result = mem::take(&mut self.current_captures);\n+        for item in result {\n+            let mut lookup_place = HirPlace { local: item.place.local, projections: vec![] };\n+            let mut it = item.place.projections.iter();\n+            let prev_index = loop {\n+                if let Some(k) = hash_map.get(&lookup_place) {\n+                    break Some(*k);\n+                }\n+                match it.next() {\n+                    Some(x) => lookup_place.projections.push(x.clone()),\n+                    None => break None,\n+                }\n+            };\n+            match prev_index {\n+                Some(p) => {\n+                    self.current_captures[p].kind =\n+                        cmp::max(item.kind, self.current_captures[p].kind);\n+                }\n+                None => {\n+                    hash_map.insert(item.place.clone(), self.current_captures.len());\n+                    self.current_captures.push(item);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn consume_with_pat(\n+        &mut self,\n+        mut place: HirPlace,\n+        mut ty: Ty,\n+        mut bm: BindingAnnotation,\n+        pat: PatId,\n+    ) {\n+        match &self.body[pat] {\n+            Pat::Missing | Pat::Wild => (),\n+            Pat::Tuple { args, ellipsis } => {\n+                pattern_matching_dereference(&mut ty, &mut bm, &mut place);\n+                let (al, ar) = args.split_at(ellipsis.unwrap_or(args.len()));\n+                let subst = match ty.kind(Interner) {\n+                    TyKind::Tuple(_, s) => s,\n+                    _ => return,\n+                };\n+                let fields = subst.iter(Interner).map(|x| x.assert_ty_ref(Interner)).enumerate();\n+                let it = al.iter().zip(fields.clone()).chain(ar.iter().rev().zip(fields.rev()));\n+                for (arg, (i, ty)) in it {\n+                    let mut p = place.clone();\n+                    p.projections.push(ProjectionElem::TupleOrClosureField(i));\n+                    self.consume_with_pat(p, ty.clone(), bm, *arg);\n+                }\n+            }\n+            Pat::Or(pats) => {\n+                for pat in pats.iter() {\n+                    self.consume_with_pat(place.clone(), ty.clone(), bm, *pat);\n+                }\n+            }\n+            Pat::Record { args, .. } => {\n+                pattern_matching_dereference(&mut ty, &mut bm, &mut place);\n+                let subst = match ty.kind(Interner) {\n+                    TyKind::Adt(_, s) => s,\n+                    _ => return,\n+                };\n+                let Some(variant) = self.result.variant_resolution_for_pat(pat) else {\n+                    return;\n+                };\n+                match variant {\n+                    VariantId::EnumVariantId(_) | VariantId::UnionId(_) => {\n+                        self.consume_place(place)\n+                    }\n+                    VariantId::StructId(s) => {\n+                        let vd = &*self.db.struct_data(s).variant_data;\n+                        let field_types = self.db.field_types(variant);\n+                        for field_pat in args.iter() {\n+                            let arg = field_pat.pat;\n+                            let Some(local_id) = vd.field(&field_pat.name) else {\n+                                continue;\n+                            };\n+                            let mut p = place.clone();\n+                            p.projections.push(ProjectionElem::Field(FieldId {\n+                                parent: variant.into(),\n+                                local_id,\n+                            }));\n+                            self.consume_with_pat(\n+                                p,\n+                                field_types[local_id].clone().substitute(Interner, subst),\n+                                bm,\n+                                arg,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+            Pat::Range { .. }\n+            | Pat::Slice { .. }\n+            | Pat::ConstBlock(_)\n+            | Pat::Path(_)\n+            | Pat::Lit(_) => self.consume_place(place),\n+            Pat::Bind { id, subpat: _ } => {\n+                let mode = self.body.bindings[*id].mode;\n+                if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n+                    bm = mode;\n+                }\n+                let capture_kind = match bm {\n+                    BindingAnnotation::Unannotated | BindingAnnotation::Mutable => {\n+                        self.consume_place(place);\n+                        return;\n+                    }\n+                    BindingAnnotation::Ref => BorrowKind::Shared,\n+                    BindingAnnotation::RefMut => BorrowKind::Mut { allow_two_phase_borrow: false },\n+                };\n+                self.add_capture(place, CaptureKind::ByRef(capture_kind));\n+            }\n+            Pat::TupleStruct { path: _, args, ellipsis } => {\n+                pattern_matching_dereference(&mut ty, &mut bm, &mut place);\n+                let subst = match ty.kind(Interner) {\n+                    TyKind::Adt(_, s) => s,\n+                    _ => return,\n+                };\n+                let Some(variant) = self.result.variant_resolution_for_pat(pat) else {\n+                    return;\n+                };\n+                match variant {\n+                    VariantId::EnumVariantId(_) | VariantId::UnionId(_) => {\n+                        self.consume_place(place)\n+                    }\n+                    VariantId::StructId(s) => {\n+                        let vd = &*self.db.struct_data(s).variant_data;\n+                        let (al, ar) = args.split_at(ellipsis.unwrap_or(args.len()));\n+                        let fields = vd.fields().iter();\n+                        let it =\n+                            al.iter().zip(fields.clone()).chain(ar.iter().rev().zip(fields.rev()));\n+                        let field_types = self.db.field_types(variant);\n+                        for (arg, (i, _)) in it {\n+                            let mut p = place.clone();\n+                            p.projections.push(ProjectionElem::Field(FieldId {\n+                                parent: variant.into(),\n+                                local_id: i,\n+                            }));\n+                            self.consume_with_pat(\n+                                p,\n+                                field_types[i].clone().substitute(Interner, subst),\n+                                bm,\n+                                *arg,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+            Pat::Ref { pat, mutability: _ } => {\n+                if let Some((inner, _, _)) = ty.as_reference() {\n+                    ty = inner.clone();\n+                    place.projections.push(ProjectionElem::Deref);\n+                    self.consume_with_pat(place, ty, bm, *pat)\n+                }\n+            }\n+            Pat::Box { .. } => (), // not supported\n+        }\n+    }\n+\n+    fn consume_exprs(&mut self, exprs: impl Iterator<Item = ExprId>) {\n+        for expr in exprs {\n+            self.consume_expr(expr);\n+        }\n+    }\n+\n+    fn closure_kind(&self) -> FnTrait {\n+        let mut r = FnTrait::Fn;\n+        for x in &self.current_captures {\n+            r = cmp::min(\n+                r,\n+                match &x.kind {\n+                    CaptureKind::ByRef(BorrowKind::Unique | BorrowKind::Mut { .. }) => {\n+                        FnTrait::FnMut\n+                    }\n+                    CaptureKind::ByRef(BorrowKind::Shallow | BorrowKind::Shared) => FnTrait::Fn,\n+                    CaptureKind::ByValue => FnTrait::FnOnce,\n+                },\n+            )\n+        }\n+        r\n+    }\n+\n+    fn analyze_closure(&mut self, closure: ClosureId) -> FnTrait {\n+        let (_, root) = self.db.lookup_intern_closure(closure.into());\n+        self.current_closure = Some(closure);\n+        let Expr::Closure { body, capture_by, .. } = &self.body[root] else {\n+            unreachable!(\"Closure expression id is always closure\");\n+        };\n+        self.consume_expr(*body);\n+        for item in &self.current_captures {\n+            if matches!(item.kind, CaptureKind::ByRef(BorrowKind::Mut { .. })) {\n+                // FIXME: remove the `mutated_bindings_in_closure` completely and add proper fake reads in\n+                // MIR. I didn't do that due duplicate diagnostics.\n+                self.result.mutated_bindings_in_closure.insert(item.place.local);\n+            }\n+        }\n+        // closure_kind should be done before adjust_for_move_closure\n+        let closure_kind = self.closure_kind();\n+        match capture_by {\n+            CaptureBy::Value => self.adjust_for_move_closure(),\n+            CaptureBy::Ref => (),\n+        }\n+        self.minimize_captures();\n+        let result = mem::take(&mut self.current_captures);\n+        let captures = result.into_iter().map(|x| x.with_ty(self)).collect::<Vec<_>>();\n+        self.result.closure_info.insert(closure, (captures, closure_kind));\n+        closure_kind\n+    }\n+\n+    pub(crate) fn infer_closures(&mut self) {\n+        let deferred_closures = self.sort_closures();\n+        for (closure, exprs) in deferred_closures.into_iter().rev() {\n+            self.current_captures = vec![];\n+            let kind = self.analyze_closure(closure);\n+\n+            for (derefed_callee, callee_ty, params, expr) in exprs {\n+                if let &Expr::Call { callee, .. } = &self.body[expr] {\n+                    let mut adjustments =\n+                        self.result.expr_adjustments.remove(&callee).unwrap_or_default();\n+                    self.write_fn_trait_method_resolution(\n+                        kind,\n+                        &derefed_callee,\n+                        &mut adjustments,\n+                        &callee_ty,\n+                        &params,\n+                        expr,\n+                    );\n+                    self.result.expr_adjustments.insert(callee, adjustments);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// We want to analyze some closures before others, to have a correct analysis:\n+    /// * We should analyze nested closures before the parent, since the parent should capture some of\n+    ///   the things that its children captures.\n+    /// * If a closure calls another closure, we need to analyze the callee, to find out how we should\n+    ///   capture it (e.g. by move for FnOnce)\n+    ///\n+    /// These dependencies are collected in the main inference. We do a topological sort in this function. It\n+    /// will consume the `deferred_closures` field and return its content in a sorted vector.\n+    fn sort_closures(&mut self) -> Vec<(ClosureId, Vec<(Ty, Ty, Vec<Ty>, ExprId)>)> {\n+        let mut deferred_closures = mem::take(&mut self.deferred_closures);\n+        let mut dependents_count: FxHashMap<ClosureId, usize> =\n+            deferred_closures.keys().map(|x| (*x, 0)).collect();\n+        for (_, deps) in &self.closure_dependecies {\n+            for dep in deps {\n+                *dependents_count.entry(*dep).or_default() += 1;\n+            }\n+        }\n+        let mut queue: Vec<_> =\n+            deferred_closures.keys().copied().filter(|x| dependents_count[x] == 0).collect();\n+        let mut result = vec![];\n+        while let Some(x) = queue.pop() {\n+            if let Some(d) = deferred_closures.remove(&x) {\n+                result.push((x, d));\n+            }\n+            for dep in self.closure_dependecies.get(&x).into_iter().flat_map(|x| x.iter()) {\n+                let cnt = dependents_count.get_mut(dep).unwrap();\n+                *cnt -= 1;\n+                if *cnt == 0 {\n+                    queue.push(*dep);\n+                }\n+            }\n+        }\n+        result\n+    }\n+}\n+\n+fn apply_adjusts_to_place(mut r: HirPlace, adjustments: &[Adjustment]) -> Option<HirPlace> {\n+    for adj in adjustments {\n+        match &adj.kind {\n+            Adjust::Deref(None) => {\n+                r.projections.push(ProjectionElem::Deref);\n+            }\n+            _ => return None,\n+        }\n+    }\n+    Some(r)\n+}\n+\n+fn pattern_matching_dereference(\n+    cond_ty: &mut Ty,\n+    binding_mode: &mut BindingAnnotation,\n+    cond_place: &mut HirPlace,\n+) {\n+    let cnt = pattern_matching_dereference_count(cond_ty, binding_mode);\n+    cond_place.projections.extend((0..cnt).map(|_| ProjectionElem::Deref));\n+}"}, {"sha": "2249d84edbfc92d7944af5a215eac7e1013e2c13", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -7,9 +7,9 @@\n \n use std::{iter, sync::Arc};\n \n-use chalk_ir::{cast::Cast, BoundVar, Goal, Mutability, TyVariableKind};\n+use chalk_ir::{cast::Cast, BoundVar, Goal, Mutability, TyKind, TyVariableKind};\n use hir_def::{\n-    expr::ExprId,\n+    hir::ExprId,\n     lang_item::{LangItem, LangItemTarget},\n };\n use stdx::always;\n@@ -22,7 +22,7 @@ use crate::{\n         TypeError, TypeMismatch,\n     },\n     static_lifetime, Canonical, DomainGoal, FnPointer, FnSig, Guidance, InEnvironment, Interner,\n-    Solution, Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind,\n+    Solution, Substitution, TraitEnvironment, Ty, TyBuilder, TyExt,\n };\n \n use super::unify::InferenceTable;\n@@ -111,6 +111,8 @@ impl CoerceMany {\n         // pointers to have a chance at getting a match. See\n         // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n         let sig = match (self.merged_ty().kind(Interner), expr_ty.kind(Interner)) {\n+            (TyKind::FnDef(x, _), TyKind::FnDef(y, _)) if x == y => None,\n+            (TyKind::Closure(x, _), TyKind::Closure(y, _)) if x == y => None,\n             (TyKind::FnDef(..) | TyKind::Closure(..), TyKind::FnDef(..) | TyKind::Closure(..)) => {\n                 // FIXME: we're ignoring safety here. To be more correct, if we have one FnDef and one Closure,\n                 // we should be coercing the closure to a fn pointer of the safety of the FnDef"}, {"sha": "64f37c761e963cb6a1ac4ccb42c2c645b3bb6c4f", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 93, "deletions": 60, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -10,10 +10,10 @@ use chalk_ir::{\n     cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyKind, TyVariableKind,\n };\n use hir_def::{\n-    expr::{\n+    generics::TypeOrConstParamData,\n+    hir::{\n         ArithOp, Array, BinaryOp, ClosureKind, Expr, ExprId, LabelId, Literal, Statement, UnaryOp,\n     },\n-    generics::TypeOrConstParamData,\n     lang_item::LangItem,\n     path::{GenericArg, GenericArgs},\n     BlockId, ConstParamId, FieldId, ItemContainerId, Lookup,\n@@ -86,10 +86,10 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n-    pub(super) fn infer_expr_coerce_never(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n+    fn infer_expr_coerce_never(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n         let ty = self.infer_expr_inner(expr, expected);\n         // While we don't allow *arbitrary* coercions here, we *do* allow\n-        // coercions from ! to `expected`.\n+        // coercions from `!` to `expected`.\n         if ty.is_never() {\n             if let Some(adjustments) = self.result.expr_adjustments.get(&expr) {\n                 return if let [Adjustment { kind: Adjust::NeverToAny, target }] = &**adjustments {\n@@ -99,13 +99,22 @@ impl<'a> InferenceContext<'a> {\n                 };\n             }\n \n-            let adj_ty = self.table.new_type_var();\n-            self.write_expr_adj(\n-                expr,\n-                vec![Adjustment { kind: Adjust::NeverToAny, target: adj_ty.clone() }],\n-            );\n-            adj_ty\n+            if let Some(target) = expected.only_has_type(&mut self.table) {\n+                self.coerce(Some(expr), &ty, &target)\n+                    .expect(\"never-to-any coercion should always succeed\")\n+            } else {\n+                ty\n+            }\n         } else {\n+            if let Some(expected_ty) = expected.only_has_type(&mut self.table) {\n+                let could_unify = self.unify(&ty, &expected_ty);\n+                if !could_unify {\n+                    self.result.type_mismatches.insert(\n+                        expr.into(),\n+                        TypeMismatch { expected: expected_ty, actual: ty.clone() },\n+                    );\n+                }\n+            }\n             ty\n         }\n     }\n@@ -212,7 +221,7 @@ impl<'a> InferenceContext<'a> {\n                 self.diverges = Diverges::Maybe;\n                 TyBuilder::unit()\n             }\n-            Expr::Closure { body, args, ret_type, arg_types, closure_kind } => {\n+            Expr::Closure { body, args, ret_type, arg_types, closure_kind, capture_by: _ } => {\n                 assert_eq!(args.len(), arg_types.len());\n \n                 let mut sig_tys = Vec::with_capacity(arg_types.len() + 1);\n@@ -247,7 +256,7 @@ impl<'a> InferenceContext<'a> {\n                 })\n                 .intern(Interner);\n \n-                let (ty, resume_yield_tys) = match closure_kind {\n+                let (id, ty, resume_yield_tys) = match closure_kind {\n                     ClosureKind::Generator(_) => {\n                         // FIXME: report error when there are more than 1 parameter.\n                         let resume_ty = match sig_tys.first() {\n@@ -267,7 +276,7 @@ impl<'a> InferenceContext<'a> {\n                         let generator_id = self.db.intern_generator((self.owner, tgt_expr)).into();\n                         let generator_ty = TyKind::Generator(generator_id, subst).intern(Interner);\n \n-                        (generator_ty, Some((resume_ty, yield_ty)))\n+                        (None, generator_ty, Some((resume_ty, yield_ty)))\n                     }\n                     ClosureKind::Closure | ClosureKind::Async => {\n                         let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n@@ -276,8 +285,11 @@ impl<'a> InferenceContext<'a> {\n                             Substitution::from1(Interner, sig_ty.clone()),\n                         )\n                         .intern(Interner);\n-\n-                        (closure_ty, None)\n+                        self.deferred_closures.entry(closure_id).or_default();\n+                        if let Some(c) = self.current_closure {\n+                            self.closure_dependecies.entry(c).or_default().push(closure_id);\n+                        }\n+                        (Some(closure_id), closure_ty, None)\n                     }\n                 };\n \n@@ -293,6 +305,7 @@ impl<'a> InferenceContext<'a> {\n \n                 // FIXME: lift these out into a struct\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+                let prev_closure = mem::replace(&mut self.current_closure, id);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n                 let prev_ret_coercion =\n                     mem::replace(&mut self.return_coercion, Some(CoerceMany::new(ret_ty)));\n@@ -306,6 +319,7 @@ impl<'a> InferenceContext<'a> {\n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n                 self.return_coercion = prev_ret_coercion;\n+                self.current_closure = prev_closure;\n                 self.resume_yield_tys = prev_resume_yield_tys;\n \n                 ty\n@@ -331,43 +345,28 @@ impl<'a> InferenceContext<'a> {\n                 let (param_tys, ret_ty) = match res {\n                     Some((func, params, ret_ty)) => {\n                         let mut adjustments = auto_deref_adjust_steps(&derefs);\n-                        if let Some(fn_x) = func {\n-                            match fn_x {\n-                                FnTrait::FnOnce => (),\n-                                FnTrait::FnMut => {\n-                                    if !matches!(\n-                                        derefed_callee.kind(Interner),\n-                                        TyKind::Ref(Mutability::Mut, _, _)\n-                                    ) {\n-                                        adjustments.push(Adjustment::borrow(\n-                                            Mutability::Mut,\n-                                            derefed_callee.clone(),\n-                                        ));\n-                                    }\n-                                }\n-                                FnTrait::Fn => {\n-                                    if !matches!(\n-                                        derefed_callee.kind(Interner),\n-                                        TyKind::Ref(Mutability::Not, _, _)\n-                                    ) {\n-                                        adjustments.push(Adjustment::borrow(\n-                                            Mutability::Not,\n-                                            derefed_callee.clone(),\n-                                        ));\n-                                    }\n-                                }\n-                            }\n-                            let trait_ = fn_x\n-                                .get_id(self.db, self.table.trait_env.krate)\n-                                .expect(\"We just used it\");\n-                            let trait_data = self.db.trait_data(trait_);\n-                            if let Some(func) = trait_data.method_by_name(&fn_x.method_name()) {\n-                                let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n-                                    .push(callee_ty.clone())\n-                                    .push(TyBuilder::tuple_with(params.iter().cloned()))\n-                                    .build();\n-                                self.write_method_resolution(tgt_expr, func, subst)\n+                        if let TyKind::Closure(c, _) =\n+                            self.table.resolve_completely(callee_ty.clone()).kind(Interner)\n+                        {\n+                            if let Some(par) = self.current_closure {\n+                                self.closure_dependecies.entry(par).or_default().push(*c);\n                             }\n+                            self.deferred_closures.entry(*c).or_default().push((\n+                                derefed_callee.clone(),\n+                                callee_ty.clone(),\n+                                params.clone(),\n+                                tgt_expr,\n+                            ));\n+                        }\n+                        if let Some(fn_x) = func {\n+                            self.write_fn_trait_method_resolution(\n+                                fn_x,\n+                                &derefed_callee,\n+                                &mut adjustments,\n+                                &callee_ty,\n+                                &params,\n+                                tgt_expr,\n+                            );\n                         }\n                         self.write_expr_adj(*callee, adjustments);\n                         (params, ret_ty)\n@@ -459,8 +458,8 @@ impl<'a> InferenceContext<'a> {\n                 self.resolver.reset_to_guard(g);\n                 ty\n             }\n-            Expr::Continue { label } => {\n-                if let None = find_continuable(&mut self.breakables, label.as_ref()) {\n+            &Expr::Continue { label } => {\n+                if let None = find_continuable(&mut self.breakables, label) {\n                     self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                         expr: tgt_expr,\n                         is_break: false,\n@@ -469,9 +468,9 @@ impl<'a> InferenceContext<'a> {\n                 };\n                 self.result.standard_types.never.clone()\n             }\n-            Expr::Break { expr, label } => {\n-                let val_ty = if let Some(expr) = *expr {\n-                    let opt_coerce_to = match find_breakable(&mut self.breakables, label.as_ref()) {\n+            &Expr::Break { expr, label } => {\n+                let val_ty = if let Some(expr) = expr {\n+                    let opt_coerce_to = match find_breakable(&mut self.breakables, label) {\n                         Some(ctxt) => match &ctxt.coerce {\n                             Some(coerce) => coerce.expected_ty(),\n                             None => {\n@@ -490,13 +489,13 @@ impl<'a> InferenceContext<'a> {\n                     TyBuilder::unit()\n                 };\n \n-                match find_breakable(&mut self.breakables, label.as_ref()) {\n+                match find_breakable(&mut self.breakables, label) {\n                     Some(ctxt) => match ctxt.coerce.take() {\n                         Some(mut coerce) => {\n-                            coerce.coerce(self, *expr, &val_ty);\n+                            coerce.coerce(self, expr, &val_ty);\n \n                             // Avoiding borrowck\n-                            let ctxt = find_breakable(&mut self.breakables, label.as_ref())\n+                            let ctxt = find_breakable(&mut self.breakables, label)\n                                 .expect(\"breakable stack changed during coercion\");\n                             ctxt.may_break = true;\n                             ctxt.coerce = Some(coerce);\n@@ -897,6 +896,41 @@ impl<'a> InferenceContext<'a> {\n         TyKind::OpaqueType(opaque_ty_id, Substitution::from1(Interner, inner_ty)).intern(Interner)\n     }\n \n+    pub(crate) fn write_fn_trait_method_resolution(\n+        &mut self,\n+        fn_x: FnTrait,\n+        derefed_callee: &Ty,\n+        adjustments: &mut Vec<Adjustment>,\n+        callee_ty: &Ty,\n+        params: &Vec<Ty>,\n+        tgt_expr: ExprId,\n+    ) {\n+        match fn_x {\n+            FnTrait::FnOnce => (),\n+            FnTrait::FnMut => {\n+                if !matches!(derefed_callee.kind(Interner), TyKind::Ref(Mutability::Mut, _, _)) {\n+                    adjustments.push(Adjustment::borrow(Mutability::Mut, derefed_callee.clone()));\n+                }\n+            }\n+            FnTrait::Fn => {\n+                if !matches!(derefed_callee.kind(Interner), TyKind::Ref(Mutability::Not, _, _)) {\n+                    adjustments.push(Adjustment::borrow(Mutability::Not, derefed_callee.clone()));\n+                }\n+            }\n+        }\n+        let Some(trait_) = fn_x.get_id(self.db, self.table.trait_env.krate) else {\n+            return;\n+        };\n+        let trait_data = self.db.trait_data(trait_);\n+        if let Some(func) = trait_data.method_by_name(&fn_x.method_name()) {\n+            let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n+                .push(callee_ty.clone())\n+                .push(TyBuilder::tuple_with(params.iter().cloned()))\n+                .build();\n+            self.write_method_resolution(tgt_expr, func, subst.clone());\n+        }\n+    }\n+\n     fn infer_expr_array(\n         &mut self,\n         array: &Array,\n@@ -1900,7 +1934,6 @@ impl<'a> InferenceContext<'a> {\n         cb: impl FnOnce(&mut Self) -> T,\n     ) -> (Option<Ty>, T) {\n         self.breakables.push({\n-            let label = label.map(|label| self.body[label].name.clone());\n             BreakableContext { kind, may_break: false, coerce: ty.map(CoerceMany::new), label }\n         });\n         let res = cb(self);"}, {"sha": "f344b0610c99ce1ec420acf0beea2d9a8c5c5029", "filename": "crates/hir-ty/src/infer/mutability.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -3,7 +3,7 @@\n \n use chalk_ir::Mutability;\n use hir_def::{\n-    expr::{Array, BindingAnnotation, Expr, ExprId, PatId, Statement, UnaryOp},\n+    hir::{Array, BinaryOp, BindingAnnotation, Expr, ExprId, PatId, Statement, UnaryOp},\n     lang_item::LangItem,\n };\n use hir_expand::name;\n@@ -80,6 +80,9 @@ impl<'a> InferenceContext<'a> {\n                 self.infer_mut_expr(*expr, m);\n                 for arm in arms.iter() {\n                     self.infer_mut_expr(arm.expr, Mutability::Not);\n+                    if let Some(g) = arm.guard {\n+                        self.infer_mut_expr(g, Mutability::Not);\n+                    }\n                 }\n             }\n             Expr::Yield { expr }\n@@ -158,14 +161,19 @@ impl<'a> InferenceContext<'a> {\n                 let mutability = lower_to_chalk_mutability(*mutability);\n                 self.infer_mut_expr(*expr, mutability);\n             }\n+            Expr::BinaryOp { lhs, rhs, op: Some(BinaryOp::Assignment { .. }) } => {\n+                self.infer_mut_expr(*lhs, Mutability::Mut);\n+                self.infer_mut_expr(*rhs, Mutability::Not);\n+            }\n             Expr::Array(Array::Repeat { initializer: lhs, repeat: rhs })\n             | Expr::BinaryOp { lhs, rhs, op: _ }\n             | Expr::Range { lhs: Some(lhs), rhs: Some(rhs), range_type: _ } => {\n                 self.infer_mut_expr(*lhs, Mutability::Not);\n                 self.infer_mut_expr(*rhs, Mutability::Not);\n             }\n-            // not implemented\n-            Expr::Closure { .. } => (),\n+            Expr::Closure { body, .. } => {\n+                self.infer_mut_expr(*body, Mutability::Not);\n+            }\n             Expr::Tuple { exprs, is_assignee_expr: _ }\n             | Expr::Array(Array::ElementList { elements: exprs, is_assignee_expr: _ }) => {\n                 self.infer_mut_not_expr_iter(exprs.iter().copied());"}, {"sha": "ce179210d34f1cd5a7d49dfa87316a42e55537a3", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -5,7 +5,7 @@ use std::iter::repeat_with;\n use chalk_ir::Mutability;\n use hir_def::{\n     body::Body,\n-    expr::{Binding, BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId},\n+    hir::{Binding, BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId},\n     path::Path,\n };\n use hir_expand::name::Name;"}, {"sha": "25b226bb3b556d1684c4b7b2e7abc6f5f5c1c3ef", "filename": "crates/hir-ty/src/inhabitedness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -6,8 +6,8 @@ use chalk_ir::{\n     DebruijnIndex,\n };\n use hir_def::{\n-    adt::VariantData, attr::Attrs, visibility::Visibility, AdtId, EnumVariantId, HasModule, Lookup,\n-    ModuleId, VariantId,\n+    attr::Attrs, data::adt::VariantData, visibility::Visibility, AdtId, EnumVariantId, HasModule,\n+    Lookup, ModuleId, VariantId,\n };\n use rustc_hash::FxHashSet;\n "}, {"sha": "adfdb01e72afe3ffcfca0238f4bc705cce486a32", "filename": "crates/hir-ty/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flang_items.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,6 +1,6 @@\n //! Functions to detect special lang items\n \n-use hir_def::{adt::StructFlags, lang_item::LangItem, AdtId};\n+use hir_def::{data::adt::StructFlags, lang_item::LangItem, AdtId};\n use hir_expand::name::Name;\n \n use crate::db::HirDatabase;"}, {"sha": "23cad5e6fd38ae96472c8a352ac7e511d9f2ec82", "filename": "crates/hir-ty/src/layout.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -229,11 +229,24 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n                 }\n             }\n         }\n-        TyKind::Closure(_, _) | TyKind::Generator(_, _) | TyKind::GeneratorWitness(_, _) => {\n+        TyKind::Closure(c, _) => {\n+            let (def, _) = db.lookup_intern_closure((*c).into());\n+            let infer = db.infer(def);\n+            let (captures, _) = infer.closure_info(c);\n+            let fields = captures\n+                .iter()\n+                .map(|x| layout_of_ty(db, &x.ty, krate))\n+                .collect::<Result<Vec<_>, _>>()?;\n+            let fields = fields.iter().collect::<Vec<_>>();\n+            let fields = fields.iter().collect::<Vec<_>>();\n+            cx.univariant(dl, &fields, &ReprOptions::default(), StructKind::AlwaysSized)\n+                .ok_or(LayoutError::Unknown)?\n+        }\n+        TyKind::Generator(_, _) | TyKind::GeneratorWitness(_, _) => {\n             return Err(LayoutError::NotImplemented)\n         }\n+        TyKind::Error => return Err(LayoutError::HasErrorType),\n         TyKind::AssociatedType(_, _)\n-        | TyKind::Error\n         | TyKind::Alias(_)\n         | TyKind::Placeholder(_)\n         | TyKind::BoundVar(_)"}, {"sha": "3f3017deee9a34bf89d3c61304fe44dcb6fdc1ac", "filename": "crates/hir-ty/src/layout/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -3,7 +3,7 @@\n use std::ops::Bound;\n \n use hir_def::{\n-    adt::VariantData,\n+    data::adt::VariantData,\n     layout::{Integer, IntegerExt, Layout, LayoutCalculator, LayoutError, RustcEnumVariantIdx},\n     AdtId, EnumVariantId, HasModule, LocalEnumVariantId, VariantId,\n };"}, {"sha": "a0ffab551802a080b0a886471ff0771cde1e853a", "filename": "crates/hir-ty/src/layout/tests.rs", "status": "modified", "additions": 62, "deletions": 3, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -11,6 +11,8 @@ use crate::{db::HirDatabase, test_db::TestDB, Interner, Substitution};\n \n use super::layout_of_ty;\n \n+mod closure;\n+\n fn current_machine_data_layout() -> String {\n     project_model::target_data_layout::get(None, None, &HashMap::default()).unwrap()\n }\n@@ -81,8 +83,8 @@ fn check_size_and_align(ra_fixture: &str, minicore: &str, size: u64, align: u64)\n #[track_caller]\n fn check_size_and_align_expr(ra_fixture: &str, minicore: &str, size: u64, align: u64) {\n     let l = eval_expr(ra_fixture, minicore).unwrap();\n-    assert_eq!(l.size.bytes(), size);\n-    assert_eq!(l.align.abi.bytes(), align);\n+    assert_eq!(l.size.bytes(), size, \"size mismatch\");\n+    assert_eq!(l.align.abi.bytes(), align, \"align mismatch\");\n }\n \n #[track_caller]\n@@ -118,13 +120,31 @@ macro_rules! size_and_align {\n     };\n }\n \n+#[macro_export]\n macro_rules! size_and_align_expr {\n+    (minicore: $($x:tt),*; stmts: [$($s:tt)*] $($t:tt)*) => {\n+        {\n+            #[allow(dead_code)]\n+            #[allow(unused_must_use)]\n+            #[allow(path_statements)]\n+            {\n+                $($s)*\n+                let val = { $($t)* };\n+                $crate::layout::tests::check_size_and_align_expr(\n+                    &format!(\"{{ {} let val = {{ {} }}; val }}\", stringify!($($s)*), stringify!($($t)*)),\n+                    &format!(\"//- minicore: {}\\n\", stringify!($($x),*)),\n+                    ::std::mem::size_of_val(&val) as u64,\n+                    ::std::mem::align_of_val(&val) as u64,\n+                );\n+            }\n+        }\n+    };\n     ($($t:tt)*) => {\n         {\n             #[allow(dead_code)]\n             {\n                 let val = { $($t)* };\n-                check_size_and_align_expr(\n+                $crate::layout::tests::check_size_and_align_expr(\n                     stringify!($($t)*),\n                     \"\",\n                     ::std::mem::size_of_val(&val) as u64,\n@@ -212,6 +232,45 @@ fn return_position_impl_trait() {\n         fn foo() -> (impl T, impl T, impl T) { (2i64, 5i32, 7i32) }\n         foo()\n     }\n+    size_and_align_expr! {\n+        minicore: iterators;\n+        stmts: []\n+        trait Tr {}\n+        impl Tr for i32 {}\n+        fn foo() -> impl Iterator<Item = impl Tr> {\n+            [1, 2, 3].into_iter()\n+        }\n+        let mut iter = foo();\n+        let item = iter.next();\n+        (iter, item)\n+    }\n+    size_and_align_expr! {\n+        minicore: future;\n+        stmts: []\n+        use core::{future::Future, task::{Poll, Context}, pin::pin};\n+        use std::{task::Wake, sync::Arc};\n+        trait Tr {}\n+        impl Tr for i32 {}\n+        async fn f() -> impl Tr {\n+            2\n+        }\n+        fn unwrap_fut<T>(inp: impl Future<Output = T>) -> Poll<T> {\n+            // In a normal test we could use `loop {}` or `panic!()` here,\n+            // but rustc actually runs this code.\n+            let pinned = pin!(inp);\n+            struct EmptyWaker;\n+            impl Wake for EmptyWaker {\n+                fn wake(self: Arc<Self>) {\n+                }\n+            }\n+            let waker = Arc::new(EmptyWaker).into();\n+            let mut context = Context::from_waker(&waker);\n+            let x = pinned.poll(&mut context);\n+            x\n+        }\n+        let x = unwrap_fut(f());\n+        x\n+    }\n     size_and_align_expr! {\n         struct Foo<T>(T, T, (T, T));\n         trait T {}"}, {"sha": "31b6765a7a2b2f11ed56300ee107f525754333a7", "filename": "crates/hir-ty/src/layout/tests/closure.rs", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests%2Fclosure.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -0,0 +1,175 @@\n+use crate::size_and_align_expr;\n+\n+#[test]\n+fn zero_capture_simple() {\n+    size_and_align_expr! {\n+        |x: i32| x + 2\n+    }\n+}\n+\n+#[test]\n+fn move_simple() {\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: []\n+        let y: i32 = 5;\n+        move |x: i32| {\n+            x + y\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ref_simple() {\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: [\n+            let y: i32 = 5;\n+        ]\n+        |x: i32| {\n+            x + y\n+        }\n+    }\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: [\n+            let mut y: i32 = 5;\n+        ]\n+        |x: i32| {\n+            y = y + x;\n+            y\n+        }\n+    }\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: [\n+            struct X(i32, i64);\n+            let x: X = X(2, 6);\n+        ]\n+        || {\n+            x\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ref_then_mut_then_move() {\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: [\n+            struct X(i32, i64);\n+            let mut x: X = X(2, 6);\n+        ]\n+        || {\n+            &x;\n+            &mut x;\n+            x;\n+        }\n+    }\n+}\n+\n+#[test]\n+fn nested_closures() {\n+    size_and_align_expr! {\n+        || {\n+            || {\n+                || {\n+                    let x = 2;\n+                    move || {\n+                        move || {\n+                            x\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn capture_specific_fields() {\n+    size_and_align_expr! {\n+        struct X(i64, i32, (u8, i128));\n+        let y: X = X(2, 5, (7, 3));\n+        move |x: i64| {\n+            y.0 + x + (y.2 .0 as i64)\n+        }\n+    }\n+    size_and_align_expr! {\n+        struct X(i64, i32, (u8, i128));\n+        let y: X = X(2, 5, (7, 3));\n+        move |x: i64| {\n+            let _ = &y;\n+            y.0 + x + (y.2 .0 as i64)\n+        }\n+    }\n+    size_and_align_expr! {\n+        minicore: copy;\n+        stmts: [\n+            struct X(i64, i32, (u8, i128));\n+            let y: X = X(2, 5, (7, 3));\n+        ]\n+        let y = &y;\n+        move |x: i64| {\n+            y.0 + x + (y.2 .0 as i64)\n+        }\n+    }\n+    size_and_align_expr! {\n+        struct X(i64, i32, (u8, i128));\n+        let y: X = X(2, 5, (7, 3));\n+        move |x: i64| {\n+            let X(a, _, (b, _)) = y;\n+            a + x + (b as i64)\n+        }\n+    }\n+    size_and_align_expr! {\n+        struct X(i64, i32, (u8, i128));\n+        let y = &&X(2, 5, (7, 3));\n+        move |x: i64| {\n+            let X(a, _, (b, _)) = y;\n+            *a + x + (*b as i64)\n+        }\n+    }\n+    size_and_align_expr! {\n+        struct X(i64, i32, (u8, i128));\n+        let y: X = X(2, 5, (7, 3));\n+        move |x: i64| {\n+            match y {\n+                X(a, _, (b, _)) => a + x + (b as i64),\n+            }\n+        }\n+    }\n+    size_and_align_expr! {\n+        struct X(i64, i32, (u8, i128));\n+        let y: X = X(2, 5, (7, 3));\n+        move |x: i64| {\n+            let X(a @ 2, _, (b, _)) = y else { return 5 };\n+            a + x + (b as i64)\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ellipsis_pattern() {\n+    size_and_align_expr! {\n+        struct X(i8, u16, i32, u64, i128, u8);\n+        let y: X = X(1, 2, 3, 4, 5, 6);\n+        move |_: i64| {\n+            let X(_a, .., _b, _c) = y;\n+        }\n+    }\n+    size_and_align_expr! {\n+        struct X { a: i32, b: u8, c: i128}\n+        let y: X = X { a: 1, b: 2, c: 3 };\n+        move |_: i64| {\n+            let X { a, b, .. } = y;\n+            _ = (a, b);\n+        }\n+    }\n+    size_and_align_expr! {\n+        let y: (&&&(i8, u16, i32, u64, i128, u8), u16, i32, u64, i128, u8) = (&&&(1, 2, 3, 4, 5, 6), 2, 3, 4, 5, 6);\n+        move |_: i64| {\n+            let ((_a, .., _b, _c), .., _e, _f) = y;\n+        }\n+    }\n+}"}, {"sha": "50fe5a724d090ede9e2ccb87057d1092575fe2f1", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -44,7 +44,7 @@ use chalk_ir::{\n     NoSolution, TyData,\n };\n use either::Either;\n-use hir_def::{expr::ExprId, type_ref::Rawness, TypeOrConstParamId};\n+use hir_def::{hir::ExprId, type_ref::Rawness, TypeOrConstParamId};\n use hir_expand::name;\n use la_arena::{Arena, Idx};\n use mir::MirEvalError;"}, {"sha": "b37fe1d63d5b2c776da4465c8045261359898db1", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -18,9 +18,9 @@ use chalk_ir::{\n \n use either::Either;\n use hir_def::{\n-    adt::StructKind,\n-    body::{Expander, LowerCtx},\n+    body::Expander,\n     builtin_type::BuiltinType,\n+    data::adt::StructKind,\n     generics::{\n         TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n     },\n@@ -380,7 +380,7 @@ impl<'a> TyLoweringContext<'a> {\n                     let macro_call = macro_call.to_node(self.db.upcast());\n                     match expander.enter_expand::<ast::Type>(self.db.upcast(), macro_call) {\n                         Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n-                            let ctx = LowerCtx::new(self.db.upcast(), expander.current_file_id());\n+                            let ctx = expander.ctx(self.db.upcast());\n                             let type_ref = TypeRef::from_ast(&ctx, expanded);\n \n                             drop(expander);\n@@ -988,7 +988,7 @@ impl<'a> TyLoweringContext<'a> {\n                         // ignore `T: Drop` or `T: Destruct` bounds.\n                         // - `T: ~const Drop` has a special meaning in Rust 1.61 that we don't implement.\n                         //   (So ideally, we'd only ignore `~const Drop` here)\n-                        // - `Destruct` impls are built-in in 1.62 (current nightlies as of 08-04-2022), so until\n+                        // - `Destruct` impls are built-in in 1.62 (current nightly as of 08-04-2022), so until\n                         //   the builtin impls are supported by Chalk, we ignore them here.\n                         if let Some(lang) = lang_attr(self.db.upcast(), tr.hir_trait_id()) {\n                             if matches!(lang, LangItem::Drop | LangItem::Destruct) {\n@@ -1082,23 +1082,23 @@ impl<'a> TyLoweringContext<'a> {\n                     associated_ty_id: to_assoc_type_id(associated_ty),\n                     substitution,\n                 };\n-                let mut preds: SmallVec<[_; 1]> = SmallVec::with_capacity(\n+                let mut predicates: SmallVec<[_; 1]> = SmallVec::with_capacity(\n                     binding.type_ref.as_ref().map_or(0, |_| 1) + binding.bounds.len(),\n                 );\n                 if let Some(type_ref) = &binding.type_ref {\n                     let ty = self.lower_ty(type_ref);\n                     let alias_eq =\n                         AliasEq { alias: AliasTy::Projection(projection_ty.clone()), ty };\n-                    preds.push(crate::wrap_empty_binders(WhereClause::AliasEq(alias_eq)));\n+                    predicates.push(crate::wrap_empty_binders(WhereClause::AliasEq(alias_eq)));\n                 }\n                 for bound in binding.bounds.iter() {\n-                    preds.extend(self.lower_type_bound(\n+                    predicates.extend(self.lower_type_bound(\n                         bound,\n                         TyKind::Alias(AliasTy::Projection(projection_ty.clone())).intern(Interner),\n                         false,\n                     ));\n                 }\n-                preds\n+                predicates\n             })\n     }\n \n@@ -1165,7 +1165,7 @@ impl<'a> TyLoweringContext<'a> {\n                 return None;\n             }\n \n-            // As multiple occurrences of the same auto traits *are* permitted, we dedulicate the\n+            // As multiple occurrences of the same auto traits *are* permitted, we deduplicate the\n             // bounds. We shouldn't have repeated elements besides auto traits at this point.\n             bounds.dedup();\n \n@@ -1634,7 +1634,7 @@ fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n     let ctx_params = TyLoweringContext::new(db, &resolver)\n         .with_impl_trait_mode(ImplTraitLoweringMode::Variable)\n         .with_type_param_mode(ParamLoweringMode::Variable);\n-    let params = data.params.iter().map(|(_, tr)| ctx_params.lower_ty(tr)).collect::<Vec<_>>();\n+    let params = data.params.iter().map(|tr| ctx_params.lower_ty(tr)).collect::<Vec<_>>();\n     let ctx_ret = TyLoweringContext::new(db, &resolver)\n         .with_impl_trait_mode(ImplTraitLoweringMode::Opaque)\n         .with_type_param_mode(ParamLoweringMode::Variable);"}, {"sha": "740b6ddc27ab8f87d3ab7dc45dd916a36db55f47", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -7,9 +7,11 @@ use std::{ops::ControlFlow, sync::Arc};\n use base_db::{CrateId, Edition};\n use chalk_ir::{cast::Cast, Mutability, TyKind, UniverseIndex, WhereClause};\n use hir_def::{\n-    adt::StructFlags, data::ImplData, item_scope::ItemScope, nameres::DefMap, AssocItemId, BlockId,\n-    ConstId, FunctionId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId,\n-    TraitId,\n+    data::{adt::StructFlags, ImplData},\n+    item_scope::ItemScope,\n+    nameres::DefMap,\n+    AssocItemId, BlockId, ConstId, FunctionId, HasModule, ImplId, ItemContainerId, Lookup,\n+    ModuleDefId, ModuleId, TraitId,\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -952,7 +954,14 @@ fn iterate_method_candidates_with_autoref(\n         )\n     };\n \n-    iterate_method_candidates_by_receiver(receiver_ty, first_adjustment.clone())?;\n+    let mut maybe_reborrowed = first_adjustment.clone();\n+    if let Some((_, _, m)) = receiver_ty.value.as_reference() {\n+        // Prefer reborrow of references to move\n+        maybe_reborrowed.autoref = Some(m);\n+        maybe_reborrowed.autoderefs += 1;\n+    }\n+\n+    iterate_method_candidates_by_receiver(receiver_ty, maybe_reborrowed)?;\n \n     let refed = Canonical {\n         value: TyKind::Ref(Mutability::Not, static_lifetime(), receiver_ty.value.clone())"}, {"sha": "2fa1bf2b7e6456600061a17f2a08315bfa4cf3d7", "filename": "crates/hir-ty/src/mir.rs", "status": "modified", "additions": 170, "deletions": 28, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -3,11 +3,12 @@\n use std::{fmt::Display, iter};\n \n use crate::{\n-    infer::PointerCast, Const, ConstScalar, InferenceResult, Interner, MemoryMap, Substitution, Ty,\n+    db::HirDatabase, infer::PointerCast, ClosureId, Const, ConstScalar, InferenceResult, Interner,\n+    MemoryMap, Substitution, Ty, TyKind,\n };\n use chalk_ir::Mutability;\n use hir_def::{\n-    expr::{BindingId, Expr, ExprId, Ordering, PatId},\n+    hir::{BindingId, Expr, ExprId, Ordering, PatId},\n     DefWithBodyId, FieldId, UnionId, VariantId,\n };\n use la_arena::{Arena, ArenaMap, Idx, RawIdx};\n@@ -19,9 +20,11 @@ mod pretty;\n \n pub use borrowck::{borrowck_query, BorrowckResult, MutabilityReason};\n pub use eval::{interpret_mir, pad16, Evaluator, MirEvalError};\n-pub use lower::{lower_to_mir, mir_body_query, mir_body_recover, MirLowerError};\n+pub use lower::{\n+    lower_to_mir, mir_body_for_closure_query, mir_body_query, mir_body_recover, MirLowerError,\n+};\n use smallvec::{smallvec, SmallVec};\n-use stdx::impl_from;\n+use stdx::{impl_from, never};\n \n use super::consteval::{intern_const_scalar, try_const_usize};\n \n@@ -89,18 +92,76 @@ impl Operand {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq, Clone)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(FieldId),\n-    TupleField(usize),\n+    // FIXME: get rid of this, and use FieldId for tuples and closures\n+    TupleOrClosureField(usize),\n     Index(V),\n     ConstantIndex { offset: u64, min_length: u64, from_end: bool },\n     Subslice { from: u64, to: u64, from_end: bool },\n     //Downcast(Option<Symbol>, VariantIdx),\n     OpaqueCast(T),\n }\n \n+impl<V, T> ProjectionElem<V, T> {\n+    pub fn projected_ty(\n+        &self,\n+        base: Ty,\n+        db: &dyn HirDatabase,\n+        closure_field: impl FnOnce(ClosureId, usize) -> Ty,\n+    ) -> Ty {\n+        match self {\n+            ProjectionElem::Deref => match &base.data(Interner).kind {\n+                TyKind::Raw(_, inner) | TyKind::Ref(_, _, inner) => inner.clone(),\n+                _ => {\n+                    never!(\"Overloaded deref is not a projection\");\n+                    return TyKind::Error.intern(Interner);\n+                }\n+            },\n+            ProjectionElem::Field(f) => match &base.data(Interner).kind {\n+                TyKind::Adt(_, subst) => {\n+                    db.field_types(f.parent)[f.local_id].clone().substitute(Interner, subst)\n+                }\n+                _ => {\n+                    never!(\"Only adt has field\");\n+                    return TyKind::Error.intern(Interner);\n+                }\n+            },\n+            ProjectionElem::TupleOrClosureField(f) => match &base.data(Interner).kind {\n+                TyKind::Tuple(_, subst) => subst\n+                    .as_slice(Interner)\n+                    .get(*f)\n+                    .map(|x| x.assert_ty_ref(Interner))\n+                    .cloned()\n+                    .unwrap_or_else(|| {\n+                        never!(\"Out of bound tuple field\");\n+                        TyKind::Error.intern(Interner)\n+                    }),\n+                TyKind::Closure(id, _) => closure_field(*id, *f),\n+                _ => {\n+                    never!(\"Only tuple or closure has tuple or closure field\");\n+                    return TyKind::Error.intern(Interner);\n+                }\n+            },\n+            ProjectionElem::Index(_) => match &base.data(Interner).kind {\n+                TyKind::Array(inner, _) | TyKind::Slice(inner) => inner.clone(),\n+                _ => {\n+                    never!(\"Overloaded index is not a projection\");\n+                    return TyKind::Error.intern(Interner);\n+                }\n+            },\n+            ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::Subslice { .. }\n+            | ProjectionElem::OpaqueCast(_) => {\n+                never!(\"We don't emit these yet\");\n+                return TyKind::Error.intern(Interner);\n+            }\n+        }\n+    }\n+}\n+\n type PlaceElem = ProjectionElem<LocalId, Ty>;\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -123,7 +184,7 @@ pub enum AggregateKind {\n     Tuple(Ty),\n     Adt(VariantId, Substitution),\n     Union(UnionId, FieldId),\n-    //Closure(LocalDefId, SubstsRef),\n+    Closure(Ty),\n     //Generator(LocalDefId, SubstsRef, Movability),\n }\n \n@@ -418,7 +479,7 @@ pub enum Terminator {\n     },\n }\n \n-#[derive(Debug, PartialEq, Eq, Clone)]\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, PartialOrd, Ord)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     Shared,\n@@ -588,32 +649,32 @@ impl Display for BinOp {\n     }\n }\n \n-impl From<hir_def::expr::ArithOp> for BinOp {\n-    fn from(value: hir_def::expr::ArithOp) -> Self {\n+impl From<hir_def::hir::ArithOp> for BinOp {\n+    fn from(value: hir_def::hir::ArithOp) -> Self {\n         match value {\n-            hir_def::expr::ArithOp::Add => BinOp::Add,\n-            hir_def::expr::ArithOp::Mul => BinOp::Mul,\n-            hir_def::expr::ArithOp::Sub => BinOp::Sub,\n-            hir_def::expr::ArithOp::Div => BinOp::Div,\n-            hir_def::expr::ArithOp::Rem => BinOp::Rem,\n-            hir_def::expr::ArithOp::Shl => BinOp::Shl,\n-            hir_def::expr::ArithOp::Shr => BinOp::Shr,\n-            hir_def::expr::ArithOp::BitXor => BinOp::BitXor,\n-            hir_def::expr::ArithOp::BitOr => BinOp::BitOr,\n-            hir_def::expr::ArithOp::BitAnd => BinOp::BitAnd,\n+            hir_def::hir::ArithOp::Add => BinOp::Add,\n+            hir_def::hir::ArithOp::Mul => BinOp::Mul,\n+            hir_def::hir::ArithOp::Sub => BinOp::Sub,\n+            hir_def::hir::ArithOp::Div => BinOp::Div,\n+            hir_def::hir::ArithOp::Rem => BinOp::Rem,\n+            hir_def::hir::ArithOp::Shl => BinOp::Shl,\n+            hir_def::hir::ArithOp::Shr => BinOp::Shr,\n+            hir_def::hir::ArithOp::BitXor => BinOp::BitXor,\n+            hir_def::hir::ArithOp::BitOr => BinOp::BitOr,\n+            hir_def::hir::ArithOp::BitAnd => BinOp::BitAnd,\n         }\n     }\n }\n \n-impl From<hir_def::expr::CmpOp> for BinOp {\n-    fn from(value: hir_def::expr::CmpOp) -> Self {\n+impl From<hir_def::hir::CmpOp> for BinOp {\n+    fn from(value: hir_def::hir::CmpOp) -> Self {\n         match value {\n-            hir_def::expr::CmpOp::Eq { negated: false } => BinOp::Eq,\n-            hir_def::expr::CmpOp::Eq { negated: true } => BinOp::Ne,\n-            hir_def::expr::CmpOp::Ord { ordering: Ordering::Greater, strict: false } => BinOp::Ge,\n-            hir_def::expr::CmpOp::Ord { ordering: Ordering::Greater, strict: true } => BinOp::Gt,\n-            hir_def::expr::CmpOp::Ord { ordering: Ordering::Less, strict: false } => BinOp::Le,\n-            hir_def::expr::CmpOp::Ord { ordering: Ordering::Less, strict: true } => BinOp::Lt,\n+            hir_def::hir::CmpOp::Eq { negated: false } => BinOp::Eq,\n+            hir_def::hir::CmpOp::Eq { negated: true } => BinOp::Ne,\n+            hir_def::hir::CmpOp::Ord { ordering: Ordering::Greater, strict: false } => BinOp::Ge,\n+            hir_def::hir::CmpOp::Ord { ordering: Ordering::Greater, strict: true } => BinOp::Gt,\n+            hir_def::hir::CmpOp::Ord { ordering: Ordering::Less, strict: false } => BinOp::Le,\n+            hir_def::hir::CmpOp::Ord { ordering: Ordering::Less, strict: true } => BinOp::Lt,\n         }\n     }\n }\n@@ -847,6 +908,87 @@ pub struct MirBody {\n     pub arg_count: usize,\n     pub binding_locals: ArenaMap<BindingId, LocalId>,\n     pub param_locals: Vec<LocalId>,\n+    /// This field stores the closures directly owned by this body. It is used\n+    /// in traversing every mir body.\n+    pub closures: Vec<ClosureId>,\n+}\n+\n+impl MirBody {\n+    fn walk_places(&mut self, mut f: impl FnMut(&mut Place)) {\n+        fn for_operand(op: &mut Operand, f: &mut impl FnMut(&mut Place)) {\n+            match op {\n+                Operand::Copy(p) | Operand::Move(p) => {\n+                    f(p);\n+                }\n+                Operand::Constant(_) => (),\n+            }\n+        }\n+        for (_, block) in self.basic_blocks.iter_mut() {\n+            for statement in &mut block.statements {\n+                match &mut statement.kind {\n+                    StatementKind::Assign(p, r) => {\n+                        f(p);\n+                        match r {\n+                            Rvalue::ShallowInitBox(o, _)\n+                            | Rvalue::UnaryOp(_, o)\n+                            | Rvalue::Cast(_, o, _)\n+                            | Rvalue::Use(o) => for_operand(o, &mut f),\n+                            Rvalue::CopyForDeref(p)\n+                            | Rvalue::Discriminant(p)\n+                            | Rvalue::Len(p)\n+                            | Rvalue::Ref(_, p) => f(p),\n+                            Rvalue::CheckedBinaryOp(_, o1, o2) => {\n+                                for_operand(o1, &mut f);\n+                                for_operand(o2, &mut f);\n+                            }\n+                            Rvalue::Aggregate(_, ops) => {\n+                                for op in ops {\n+                                    for_operand(op, &mut f);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    StatementKind::Deinit(p) => f(p),\n+                    StatementKind::StorageLive(_)\n+                    | StatementKind::StorageDead(_)\n+                    | StatementKind::Nop => (),\n+                }\n+            }\n+            match &mut block.terminator {\n+                Some(x) => match x {\n+                    Terminator::SwitchInt { discr, .. } => for_operand(discr, &mut f),\n+                    Terminator::FalseEdge { .. }\n+                    | Terminator::FalseUnwind { .. }\n+                    | Terminator::Goto { .. }\n+                    | Terminator::Resume\n+                    | Terminator::GeneratorDrop\n+                    | Terminator::Abort\n+                    | Terminator::Return\n+                    | Terminator::Unreachable => (),\n+                    Terminator::Drop { place, .. } => {\n+                        f(place);\n+                    }\n+                    Terminator::DropAndReplace { place, value, .. } => {\n+                        f(place);\n+                        for_operand(value, &mut f);\n+                    }\n+                    Terminator::Call { func, args, destination, .. } => {\n+                        for_operand(func, &mut f);\n+                        args.iter_mut().for_each(|x| for_operand(x, &mut f));\n+                        f(destination);\n+                    }\n+                    Terminator::Assert { cond, .. } => {\n+                        for_operand(cond, &mut f);\n+                    }\n+                    Terminator::Yield { value, resume_arg, .. } => {\n+                        for_operand(value, &mut f);\n+                        f(resume_arg);\n+                    }\n+                },\n+                None => (),\n+            }\n+        }\n+    }\n }\n \n fn const_as_usize(c: &Const) -> usize {"}, {"sha": "5b2bca955f5938e3e2b55a41e400e2caac671727", "filename": "crates/hir-ty/src/mir/borrowck.rs", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -3,13 +3,13 @@\n // Currently it is an ad-hoc implementation, only useful for mutability analysis. Feel free to remove all of these\n // if needed for implementing a proper borrow checker.\n \n-use std::sync::Arc;\n+use std::{iter, sync::Arc};\n \n use hir_def::DefWithBodyId;\n use la_arena::ArenaMap;\n use stdx::never;\n \n-use crate::db::HirDatabase;\n+use crate::{db::HirDatabase, ClosureId};\n \n use super::{\n     BasicBlockId, BorrowKind, LocalId, MirBody, MirLowerError, MirSpan, Place, ProjectionElem,\n@@ -29,14 +29,48 @@ pub struct BorrowckResult {\n     pub mutability_of_locals: ArenaMap<LocalId, MutabilityReason>,\n }\n \n+fn all_mir_bodies(\n+    db: &dyn HirDatabase,\n+    def: DefWithBodyId,\n+) -> Box<dyn Iterator<Item = Result<Arc<MirBody>, MirLowerError>> + '_> {\n+    fn for_closure(\n+        db: &dyn HirDatabase,\n+        c: ClosureId,\n+    ) -> Box<dyn Iterator<Item = Result<Arc<MirBody>, MirLowerError>> + '_> {\n+        match db.mir_body_for_closure(c) {\n+            Ok(body) => {\n+                let closures = body.closures.clone();\n+                Box::new(\n+                    iter::once(Ok(body))\n+                        .chain(closures.into_iter().flat_map(|x| for_closure(db, x))),\n+                )\n+            }\n+            Err(e) => Box::new(iter::once(Err(e))),\n+        }\n+    }\n+    match db.mir_body(def) {\n+        Ok(body) => {\n+            let closures = body.closures.clone();\n+            Box::new(\n+                iter::once(Ok(body)).chain(closures.into_iter().flat_map(|x| for_closure(db, x))),\n+            )\n+        }\n+        Err(e) => Box::new(iter::once(Err(e))),\n+    }\n+}\n+\n pub fn borrowck_query(\n     db: &dyn HirDatabase,\n     def: DefWithBodyId,\n-) -> Result<Arc<BorrowckResult>, MirLowerError> {\n+) -> Result<Arc<[BorrowckResult]>, MirLowerError> {\n     let _p = profile::span(\"borrowck_query\");\n-    let body = db.mir_body(def)?;\n-    let r = BorrowckResult { mutability_of_locals: mutability_of_locals(&body), mir_body: body };\n-    Ok(Arc::new(r))\n+    let r = all_mir_bodies(db, def)\n+        .map(|body| {\n+            let body = body?;\n+            Ok(BorrowckResult { mutability_of_locals: mutability_of_locals(&body), mir_body: body })\n+        })\n+        .collect::<Result<Vec<_>, MirLowerError>>()?;\n+    Ok(r.into())\n }\n \n fn is_place_direct(lvalue: &Place) -> bool {\n@@ -60,7 +94,7 @@ fn place_case(lvalue: &Place) -> ProjectionCase {\n             ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Field(_)\n-            | ProjectionElem::TupleField(_)\n+            | ProjectionElem::TupleOrClosureField(_)\n             | ProjectionElem::Index(_) => {\n                 is_part_of = true;\n             }"}, {"sha": "8c911b7f7b77841dd33048f602738df4fe9ff10b", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 90, "deletions": 82, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -25,8 +25,8 @@ use crate::{\n     mapping::from_chalk,\n     method_resolution::{is_dyn_method, lookup_impl_method},\n     traits::FnTrait,\n-    CallableDefId, Const, ConstScalar, FnDefId, GenericArgData, Interner, MemoryMap, Substitution,\n-    TraitEnvironment, Ty, TyBuilder, TyExt,\n+    CallableDefId, ClosureId, Const, ConstScalar, FnDefId, GenericArgData, Interner, MemoryMap,\n+    Substitution, TraitEnvironment, Ty, TyBuilder, TyExt,\n };\n \n use super::{\n@@ -92,6 +92,7 @@ pub struct Evaluator<'a> {\n enum Address {\n     Stack(usize),\n     Heap(usize),\n+    Invalid(usize),\n }\n \n use Address::*;\n@@ -169,8 +170,10 @@ impl Address {\n     fn from_usize(x: usize) -> Self {\n         if x > usize::MAX / 2 {\n             Stack(x - usize::MAX / 2)\n+        } else if x > usize::MAX / 4 {\n+            Heap(x - usize::MAX / 4)\n         } else {\n-            Heap(x)\n+            Invalid(x)\n         }\n     }\n \n@@ -181,7 +184,8 @@ impl Address {\n     fn to_usize(&self) -> usize {\n         let as_num = match self {\n             Stack(x) => *x + usize::MAX / 2,\n-            Heap(x) => *x,\n+            Heap(x) => *x + usize::MAX / 4,\n+            Invalid(x) => *x,\n         };\n         as_num\n     }\n@@ -190,6 +194,7 @@ impl Address {\n         match self {\n             Stack(x) => Stack(f(*x)),\n             Heap(x) => Heap(f(*x)),\n+            Invalid(x) => Invalid(f(*x)),\n         }\n     }\n \n@@ -209,6 +214,7 @@ pub enum MirEvalError {\n     UndefinedBehavior(&'static str),\n     Panic(String),\n     MirLowerError(FunctionId, MirLowerError),\n+    MirLowerErrorForClosure(ClosureId, MirLowerError),\n     TypeIsUnsized(Ty, &'static str),\n     NotSupported(String),\n     InvalidConst(Const),\n@@ -238,6 +244,9 @@ impl std::fmt::Debug for MirEvalError {\n             Self::MirLowerError(arg0, arg1) => {\n                 f.debug_tuple(\"MirLowerError\").field(arg0).field(arg1).finish()\n             }\n+            Self::MirLowerErrorForClosure(arg0, arg1) => {\n+                f.debug_tuple(\"MirLowerError\").field(arg0).field(arg1).finish()\n+            }\n             Self::InvalidVTableId(arg0) => f.debug_tuple(\"InvalidVTableId\").field(arg0).finish(),\n             Self::NotSupported(arg0) => f.debug_tuple(\"NotSupported\").field(arg0).finish(),\n             Self::InvalidConst(arg0) => {\n@@ -355,16 +364,15 @@ impl Evaluator<'_> {\n             self.ty_filler(&locals.body.locals[p.local].ty, locals.subst, locals.body.owner)?;\n         let mut metadata = None; // locals are always sized\n         for proj in &p.projection {\n+            let prev_ty = ty.clone();\n+            ty = proj.projected_ty(ty, self.db, |c, f| {\n+                let (def, _) = self.db.lookup_intern_closure(c.into());\n+                let infer = self.db.infer(def);\n+                let (captures, _) = infer.closure_info(&c);\n+                captures.get(f).expect(\"broken closure field\").ty.clone()\n+            });\n             match proj {\n                 ProjectionElem::Deref => {\n-                    ty = match &ty.data(Interner).kind {\n-                        TyKind::Raw(_, inner) | TyKind::Ref(_, _, inner) => inner.clone(),\n-                        _ => {\n-                            return Err(MirEvalError::TypeError(\n-                                \"Overloaded deref in MIR is disallowed\",\n-                            ))\n-                        }\n-                    };\n                     metadata = if self.size_of(&ty, locals)?.is_none() {\n                         Some(Interval { addr: addr.offset(self.ptr_size()), size: self.ptr_size() })\n                     } else {\n@@ -377,78 +385,41 @@ impl Evaluator<'_> {\n                     let offset =\n                         from_bytes!(usize, self.read_memory(locals.ptr[*op], self.ptr_size())?);\n                     metadata = None; // Result of index is always sized\n-                    match &ty.data(Interner).kind {\n-                        TyKind::Ref(_, _, inner) => match &inner.data(Interner).kind {\n-                            TyKind::Slice(inner) => {\n-                                ty = inner.clone();\n-                                let ty_size = self.size_of_sized(\n-                                    &ty,\n-                                    locals,\n-                                    \"slice inner type should be sized\",\n-                                )?;\n-                                let value = self.read_memory(addr, self.ptr_size() * 2)?;\n-                                addr = Address::from_bytes(&value[0..8])?.offset(ty_size * offset);\n-                            }\n-                            x => not_supported!(\"MIR index for ref type {x:?}\"),\n-                        },\n-                        TyKind::Array(inner, _) | TyKind::Slice(inner) => {\n-                            ty = inner.clone();\n-                            let ty_size = self.size_of_sized(\n-                                &ty,\n-                                locals,\n-                                \"array inner type should be sized\",\n-                            )?;\n-                            addr = addr.offset(ty_size * offset);\n+                    let ty_size =\n+                        self.size_of_sized(&ty, locals, \"array inner type should be sized\")?;\n+                    addr = addr.offset(ty_size * offset);\n+                }\n+                &ProjectionElem::TupleOrClosureField(f) => {\n+                    let layout = self.layout(&prev_ty)?;\n+                    let offset = layout.fields.offset(f).bytes_usize();\n+                    addr = addr.offset(offset);\n+                    metadata = None; // tuple field is always sized\n+                }\n+                ProjectionElem::Field(f) => {\n+                    let layout = self.layout(&prev_ty)?;\n+                    let variant_layout = match &layout.variants {\n+                        Variants::Single { .. } => &layout,\n+                        Variants::Multiple { variants, .. } => {\n+                            &variants[match f.parent {\n+                                hir_def::VariantId::EnumVariantId(x) => {\n+                                    RustcEnumVariantIdx(x.local_id)\n+                                }\n+                                _ => {\n+                                    return Err(MirEvalError::TypeError(\n+                                        \"Multivariant layout only happens for enums\",\n+                                    ))\n+                                }\n+                            }]\n                         }\n-                        x => not_supported!(\"MIR index for type {x:?}\"),\n-                    }\n+                    };\n+                    let offset = variant_layout\n+                        .fields\n+                        .offset(u32::from(f.local_id.into_raw()) as usize)\n+                        .bytes_usize();\n+                    addr = addr.offset(offset);\n+                    // FIXME: support structs with unsized fields\n+                    metadata = None;\n                 }\n-                &ProjectionElem::TupleField(f) => match &ty.data(Interner).kind {\n-                    TyKind::Tuple(_, subst) => {\n-                        let layout = self.layout(&ty)?;\n-                        ty = subst\n-                            .as_slice(Interner)\n-                            .get(f)\n-                            .ok_or(MirEvalError::TypeError(\"not enough tuple fields\"))?\n-                            .assert_ty_ref(Interner)\n-                            .clone();\n-                        let offset = layout.fields.offset(f).bytes_usize();\n-                        addr = addr.offset(offset);\n-                        metadata = None; // tuple field is always sized\n-                    }\n-                    _ => return Err(MirEvalError::TypeError(\"Only tuple has tuple fields\")),\n-                },\n-                ProjectionElem::Field(f) => match &ty.data(Interner).kind {\n-                    TyKind::Adt(adt, subst) => {\n-                        let layout = self.layout_adt(adt.0, subst.clone())?;\n-                        let variant_layout = match &layout.variants {\n-                            Variants::Single { .. } => &layout,\n-                            Variants::Multiple { variants, .. } => {\n-                                &variants[match f.parent {\n-                                    hir_def::VariantId::EnumVariantId(x) => {\n-                                        RustcEnumVariantIdx(x.local_id)\n-                                    }\n-                                    _ => {\n-                                        return Err(MirEvalError::TypeError(\n-                                            \"Multivariant layout only happens for enums\",\n-                                        ))\n-                                    }\n-                                }]\n-                            }\n-                        };\n-                        ty = self.db.field_types(f.parent)[f.local_id]\n-                            .clone()\n-                            .substitute(Interner, subst);\n-                        let offset = variant_layout\n-                            .fields\n-                            .offset(u32::from(f.local_id.into_raw()) as usize)\n-                            .bytes_usize();\n-                        addr = addr.offset(offset);\n-                        // FIXME: support structs with unsized fields\n-                        metadata = None;\n-                    }\n-                    _ => return Err(MirEvalError::TypeError(\"Only adt has fields\")),\n-                },\n                 ProjectionElem::ConstantIndex { .. } => {\n                     not_supported!(\"constant index\")\n                 }\n@@ -845,6 +816,15 @@ impl Evaluator<'_> {\n                             values.iter().copied(),\n                         )?)\n                     }\n+                    AggregateKind::Closure(ty) => {\n+                        let layout = self.layout(&ty)?;\n+                        Owned(self.make_by_layout(\n+                            layout.size.bytes_usize(),\n+                            &layout,\n+                            None,\n+                            values.iter().copied(),\n+                        )?)\n+                    }\n                 }\n             }\n             Rvalue::Cast(kind, operand, target_ty) => match kind {\n@@ -1065,6 +1045,9 @@ impl Evaluator<'_> {\n         let (mem, pos) = match addr {\n             Stack(x) => (&self.stack, x),\n             Heap(x) => (&self.heap, x),\n+            Invalid(_) => {\n+                return Err(MirEvalError::UndefinedBehavior(\"read invalid memory address\"))\n+            }\n         };\n         mem.get(pos..pos + size).ok_or(MirEvalError::UndefinedBehavior(\"out of bound memory read\"))\n     }\n@@ -1073,6 +1056,9 @@ impl Evaluator<'_> {\n         let (mem, pos) = match addr {\n             Stack(x) => (&mut self.stack, x),\n             Heap(x) => (&mut self.heap, x),\n+            Invalid(_) => {\n+                return Err(MirEvalError::UndefinedBehavior(\"write invalid memory address\"))\n+            }\n         };\n         mem.get_mut(pos..pos + r.len())\n             .ok_or(MirEvalError::UndefinedBehavior(\"out of bound memory write\"))?\n@@ -1394,6 +1380,25 @@ impl Evaluator<'_> {\n         Ok(())\n     }\n \n+    fn exec_closure(\n+        &mut self,\n+        closure: ClosureId,\n+        closure_data: Interval,\n+        generic_args: &Substitution,\n+        destination: Interval,\n+        args: &[IntervalAndTy],\n+    ) -> Result<()> {\n+        let mir_body = self\n+            .db\n+            .mir_body_for_closure(closure)\n+            .map_err(|x| MirEvalError::MirLowerErrorForClosure(closure, x))?;\n+        let arg_bytes = iter::once(Ok(closure_data.get(self)?.to_owned()))\n+            .chain(args.iter().map(|x| Ok(x.get(&self)?.to_owned())))\n+            .collect::<Result<Vec<_>>>()?;\n+        let bytes = self.interpret_mir(&mir_body, arg_bytes.into_iter(), generic_args.clone())?;\n+        destination.write_from_bytes(self, &bytes)\n+    }\n+\n     fn exec_fn_def(\n         &mut self,\n         def: FnDefId,\n@@ -1546,6 +1551,9 @@ impl Evaluator<'_> {\n             TyKind::Function(_) => {\n                 self.exec_fn_pointer(func_data, destination, &args[1..], locals)?;\n             }\n+            TyKind::Closure(closure, subst) => {\n+                self.exec_closure(*closure, func_data, subst, destination, &args[1..])?;\n+            }\n             x => not_supported!(\"Call FnTrait methods with type {x:?}\"),\n         }\n         Ok(())"}, {"sha": "78a2d90f7fb016673d1306fd751c298fc4ef9a10", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 308, "deletions": 123, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -4,9 +4,9 @@ use std::{iter, mem, sync::Arc};\n \n use chalk_ir::{BoundVar, ConstData, DebruijnIndex, TyKind};\n use hir_def::{\n-    adt::{StructKind, VariantData},\n     body::Body,\n-    expr::{\n+    data::adt::{StructKind, VariantData},\n+    hir::{\n         Array, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm, Pat, PatId,\n         RecordFieldPat, RecordLitField,\n     },\n@@ -21,9 +21,16 @@ use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    consteval::ConstEvalError, db::HirDatabase, display::HirDisplay, infer::TypeMismatch,\n-    inhabitedness::is_ty_uninhabited_from, layout::layout_of_ty, mapping::ToChalk, static_lifetime,\n-    utils::generics, Adjust, Adjustment, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n+    consteval::ConstEvalError,\n+    db::HirDatabase,\n+    display::HirDisplay,\n+    infer::{CaptureKind, CapturedItem, TypeMismatch},\n+    inhabitedness::is_ty_uninhabited_from,\n+    layout::layout_of_ty,\n+    mapping::ToChalk,\n+    static_lifetime,\n+    utils::generics,\n+    Adjust, Adjustment, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n };\n \n use super::*;\n@@ -47,7 +54,7 @@ struct MirLowerCtx<'a> {\n     current_loop_blocks: Option<LoopBlocks>,\n     // FIXME: we should resolve labels in HIR lowering and always work with label id here, not\n     // with raw names.\n-    labeled_loop_blocks: FxHashMap<Name, LoopBlocks>,\n+    labeled_loop_blocks: FxHashMap<LabelId, LoopBlocks>,\n     discr_temp: Option<Place>,\n     db: &'a dyn HirDatabase,\n     body: &'a Body,\n@@ -74,10 +81,12 @@ pub enum MirLowerError {\n     BreakWithoutLoop,\n     Loop,\n     /// Something that should never happen and is definitely a bug, but we don't want to panic if it happened\n-    ImplementationError(&'static str),\n+    ImplementationError(String),\n     LangItemNotFound(LangItem),\n     MutatingRvalue,\n     UnresolvedLabel,\n+    UnresolvedUpvar(Place),\n+    UnaccessableLocal,\n }\n \n macro_rules! not_supported {\n@@ -88,8 +97,8 @@ macro_rules! not_supported {\n \n macro_rules! implementation_error {\n     ($x: expr) => {{\n-        ::stdx::never!(\"MIR lower implementation bug: {}\", $x);\n-        return Err(MirLowerError::ImplementationError($x));\n+        ::stdx::never!(\"MIR lower implementation bug: {}\", format!($x));\n+        return Err(MirLowerError::ImplementationError(format!($x)));\n     }};\n }\n \n@@ -116,7 +125,44 @@ impl MirLowerError {\n \n type Result<T> = std::result::Result<T, MirLowerError>;\n \n-impl MirLowerCtx<'_> {\n+impl<'ctx> MirLowerCtx<'ctx> {\n+    fn new(\n+        db: &'ctx dyn HirDatabase,\n+        owner: DefWithBodyId,\n+        body: &'ctx Body,\n+        infer: &'ctx InferenceResult,\n+    ) -> Self {\n+        let mut basic_blocks = Arena::new();\n+        let start_block = basic_blocks.alloc(BasicBlock {\n+            statements: vec![],\n+            terminator: None,\n+            is_cleanup: false,\n+        });\n+        let locals = Arena::new();\n+        let binding_locals: ArenaMap<BindingId, LocalId> = ArenaMap::new();\n+        let mir = MirBody {\n+            basic_blocks,\n+            locals,\n+            start_block,\n+            binding_locals,\n+            param_locals: vec![],\n+            owner,\n+            arg_count: body.params.len(),\n+            closures: vec![],\n+        };\n+        let ctx = MirLowerCtx {\n+            result: mir,\n+            db,\n+            infer,\n+            body,\n+            owner,\n+            current_loop_blocks: None,\n+            labeled_loop_blocks: Default::default(),\n+            discr_temp: None,\n+        };\n+        ctx\n+    }\n+\n     fn temp(&mut self, ty: Ty) -> Result<LocalId> {\n         if matches!(ty.kind(Interner), TyKind::Slice(_) | TyKind::Dyn(_)) {\n             implementation_error!(\"unsized temporaries\");\n@@ -268,7 +314,7 @@ impl MirLowerCtx<'_> {\n                         self.push_assignment(\n                             current,\n                             place,\n-                            Operand::Copy(self.result.binding_locals[pat_id].into()).into(),\n+                            Operand::Copy(self.binding_local(pat_id)?.into()).into(),\n                             expr_id.into(),\n                         );\n                         Ok(Some(current))\n@@ -579,19 +625,19 @@ impl MirLowerCtx<'_> {\n                     Ok(None)\n                 }\n             },\n-            Expr::Break { expr, label } => {\n+            &Expr::Break { expr, label } => {\n                 if let Some(expr) = expr {\n                     let loop_data = match label {\n-                        Some(l) => self.labeled_loop_blocks.get(l).ok_or(MirLowerError::UnresolvedLabel)?,\n+                        Some(l) => self.labeled_loop_blocks.get(&l).ok_or(MirLowerError::UnresolvedLabel)?,\n                         None => self.current_loop_blocks.as_ref().ok_or(MirLowerError::BreakWithoutLoop)?,\n                     };\n-                    let Some(c) = self.lower_expr_to_place(*expr, loop_data.place.clone(), current)? else {\n+                    let Some(c) = self.lower_expr_to_place(expr, loop_data.place.clone(), current)? else {\n                         return Ok(None);\n                     };\n                     current = c;\n                 }\n                 let end = match label {\n-                    Some(l) => self.labeled_loop_blocks.get(l).ok_or(MirLowerError::UnresolvedLabel)?.end.expect(\"We always generate end for labeled loops\"),\n+                    Some(l) => self.labeled_loop_blocks.get(&l).ok_or(MirLowerError::UnresolvedLabel)?.end.expect(\"We always generate end for labeled loops\"),\n                     None => self.current_loop_end()?,\n                 };\n                 self.set_goto(current, end);\n@@ -713,20 +759,20 @@ impl MirLowerCtx<'_> {\n                 Ok(Some(current))\n             }\n             Expr::Box { .. } => not_supported!(\"box expression\"),\n-            Expr::Field { .. } | Expr::Index { .. } | Expr::UnaryOp { op: hir_def::expr::UnaryOp::Deref, .. } => {\n+            Expr::Field { .. } | Expr::Index { .. } | Expr::UnaryOp { op: hir_def::hir::UnaryOp::Deref, .. } => {\n                 let Some((p, current)) = self.lower_expr_as_place_without_adjust(current, expr_id, true)? else {\n                     return Ok(None);\n                 };\n                 self.push_assignment(current, place, Operand::Copy(p).into(), expr_id.into());\n                 Ok(Some(current))\n             }\n-            Expr::UnaryOp { expr, op: op @ (hir_def::expr::UnaryOp::Not | hir_def::expr::UnaryOp::Neg) } => {\n+            Expr::UnaryOp { expr, op: op @ (hir_def::hir::UnaryOp::Not | hir_def::hir::UnaryOp::Neg) } => {\n                 let Some((operand, current)) = self.lower_expr_to_some_operand(*expr, current)? else {\n                     return Ok(None);\n                 };\n                 let operation = match op {\n-                    hir_def::expr::UnaryOp::Not => UnOp::Not,\n-                    hir_def::expr::UnaryOp::Neg => UnOp::Neg,\n+                    hir_def::hir::UnaryOp::Not => UnOp::Not,\n+                    hir_def::hir::UnaryOp::Neg => UnOp::Neg,\n                     _ => unreachable!(),\n                 };\n                 self.push_assignment(\n@@ -739,7 +785,7 @@ impl MirLowerCtx<'_> {\n             },\n             Expr::BinaryOp { lhs, rhs, op } => {\n                 let op = op.ok_or(MirLowerError::IncompleteExpr)?;\n-                if let hir_def::expr::BinaryOp::Assignment { op } = op {\n+                if let hir_def::hir::BinaryOp::Assignment { op } = op {\n                     if op.is_some() {\n                         not_supported!(\"assignment with arith op (like +=)\");\n                     }\n@@ -765,13 +811,13 @@ impl MirLowerCtx<'_> {\n                     place,\n                     Rvalue::CheckedBinaryOp(\n                         match op {\n-                            hir_def::expr::BinaryOp::LogicOp(op) => match op {\n-                                hir_def::expr::LogicOp::And => BinOp::BitAnd, // FIXME: make these short circuit\n-                                hir_def::expr::LogicOp::Or => BinOp::BitOr,\n+                            hir_def::hir::BinaryOp::LogicOp(op) => match op {\n+                                hir_def::hir::LogicOp::And => BinOp::BitAnd, // FIXME: make these short circuit\n+                                hir_def::hir::LogicOp::Or => BinOp::BitOr,\n                             },\n-                            hir_def::expr::BinaryOp::ArithOp(op) => BinOp::from(op),\n-                            hir_def::expr::BinaryOp::CmpOp(op) => BinOp::from(op),\n-                            hir_def::expr::BinaryOp::Assignment { .. } => unreachable!(), // handled above\n+                            hir_def::hir::BinaryOp::ArithOp(op) => BinOp::from(op),\n+                            hir_def::hir::BinaryOp::CmpOp(op) => BinOp::from(op),\n+                            hir_def::hir::BinaryOp::Assignment { .. } => unreachable!(), // handled above\n                         },\n                         lhs_op,\n                         rhs_op,\n@@ -823,7 +869,51 @@ impl MirLowerCtx<'_> {\n                 );\n                 Ok(Some(current))\n             },\n-            Expr::Closure { .. } => not_supported!(\"closure\"),\n+            Expr::Closure { .. } => {\n+                let ty = self.expr_ty(expr_id);\n+                let TyKind::Closure(id, _) = ty.kind(Interner) else {\n+                    not_supported!(\"closure with non closure type\");\n+                };\n+                self.result.closures.push(*id);\n+                let (captures, _) = self.infer.closure_info(id);\n+                let mut operands = vec![];\n+                for capture in captures.iter() {\n+                    let p = Place {\n+                        local: self.binding_local(capture.place.local)?,\n+                        projection: capture.place.projections.clone().into_iter().map(|x| {\n+                            match x {\n+                                ProjectionElem::Deref => ProjectionElem::Deref,\n+                                ProjectionElem::Field(x) => ProjectionElem::Field(x),\n+                                ProjectionElem::TupleOrClosureField(x) => ProjectionElem::TupleOrClosureField(x),\n+                                ProjectionElem::ConstantIndex { offset, min_length, from_end } => ProjectionElem::ConstantIndex { offset, min_length, from_end },\n+                                ProjectionElem::Subslice { from, to, from_end } => ProjectionElem::Subslice { from, to, from_end },\n+                                ProjectionElem::OpaqueCast(x) => ProjectionElem::OpaqueCast(x),\n+                                ProjectionElem::Index(x) => match x { },\n+                            }\n+                        }).collect(),\n+                    };\n+                    match &capture.kind {\n+                        CaptureKind::ByRef(bk) => {\n+                            let tmp: Place = self.temp(capture.ty.clone())?.into();\n+                            self.push_assignment(\n+                                current,\n+                                tmp.clone(),\n+                                Rvalue::Ref(bk.clone(), p),\n+                                expr_id.into(),\n+                            );\n+                            operands.push(Operand::Move(tmp));\n+                        },\n+                        CaptureKind::ByValue => operands.push(Operand::Move(p)),\n+                    }\n+                }\n+                self.push_assignment(\n+                    current,\n+                    place,\n+                    Rvalue::Aggregate(AggregateKind::Closure(ty), operands),\n+                    expr_id.into(),\n+                );\n+                Ok(Some(current))\n+            },\n             Expr::Tuple { exprs, is_assignee_expr: _ } => {\n                 let Some(values) = exprs\n                         .iter()\n@@ -893,7 +983,7 @@ impl MirLowerCtx<'_> {\n                 let index = name\n                     .as_tuple_index()\n                     .ok_or(MirLowerError::TypeError(\"named field on tuple\"))?;\n-                place.projection.push(ProjectionElem::TupleField(index))\n+                place.projection.push(ProjectionElem::TupleOrClosureField(index))\n             } else {\n                 let field =\n                     self.infer.field_resolution(expr_id).ok_or(MirLowerError::UnresolvedField)?;\n@@ -910,7 +1000,7 @@ impl MirLowerCtx<'_> {\n             .size\n             .bytes_usize();\n         let bytes = match l {\n-            hir_def::expr::Literal::String(b) => {\n+            hir_def::hir::Literal::String(b) => {\n                 let b = b.as_bytes();\n                 let mut data = vec![];\n                 data.extend(0usize.to_le_bytes());\n@@ -919,19 +1009,19 @@ impl MirLowerCtx<'_> {\n                 mm.insert(0, b.to_vec());\n                 return Ok(Operand::from_concrete_const(data, mm, ty));\n             }\n-            hir_def::expr::Literal::ByteString(b) => {\n+            hir_def::hir::Literal::ByteString(b) => {\n                 let mut data = vec![];\n                 data.extend(0usize.to_le_bytes());\n                 data.extend(b.len().to_le_bytes());\n                 let mut mm = MemoryMap::default();\n                 mm.insert(0, b.to_vec());\n                 return Ok(Operand::from_concrete_const(data, mm, ty));\n             }\n-            hir_def::expr::Literal::Char(c) => u32::from(*c).to_le_bytes().into(),\n-            hir_def::expr::Literal::Bool(b) => vec![*b as u8],\n-            hir_def::expr::Literal::Int(x, _) => x.to_le_bytes()[0..size].into(),\n-            hir_def::expr::Literal::Uint(x, _) => x.to_le_bytes()[0..size].into(),\n-            hir_def::expr::Literal::Float(f, _) => match size {\n+            hir_def::hir::Literal::Char(c) => u32::from(*c).to_le_bytes().into(),\n+            hir_def::hir::Literal::Bool(b) => vec![*b as u8],\n+            hir_def::hir::Literal::Int(x, _) => x.to_le_bytes()[0..size].into(),\n+            hir_def::hir::Literal::Uint(x, _) => x.to_le_bytes()[0..size].into(),\n+            hir_def::hir::Literal::Float(f, _) => match size {\n                 8 => f.into_f64().to_le_bytes().into(),\n                 4 => f.into_f32().to_le_bytes().into(),\n                 _ => {\n@@ -1119,19 +1209,18 @@ impl MirLowerCtx<'_> {\n             // bad as we may emit end (unneccessary unreachable block) for unterminating loop, but\n             // it should not affect correctness.\n             self.current_loop_end()?;\n-            self.labeled_loop_blocks.insert(\n-                self.body.labels[label].name.clone(),\n-                self.current_loop_blocks.as_ref().unwrap().clone(),\n-            )\n+            self.labeled_loop_blocks\n+                .insert(label, self.current_loop_blocks.as_ref().unwrap().clone())\n         } else {\n             None\n         };\n         self.set_goto(prev_block, begin);\n         f(self, begin)?;\n-        let my = mem::replace(&mut self.current_loop_blocks, prev)\n-            .ok_or(MirLowerError::ImplementationError(\"current_loop_blocks is corrupt\"))?;\n+        let my = mem::replace(&mut self.current_loop_blocks, prev).ok_or(\n+            MirLowerError::ImplementationError(\"current_loop_blocks is corrupt\".to_string()),\n+        )?;\n         if let Some(prev) = prev_label {\n-            self.labeled_loop_blocks.insert(self.body.labels[label.unwrap()].name.clone(), prev);\n+            self.labeled_loop_blocks.insert(label.unwrap(), prev);\n         }\n         Ok(my.end)\n     }\n@@ -1161,15 +1250,19 @@ impl MirLowerCtx<'_> {\n         let r = match self\n             .current_loop_blocks\n             .as_mut()\n-            .ok_or(MirLowerError::ImplementationError(\"Current loop access out of loop\"))?\n+            .ok_or(MirLowerError::ImplementationError(\n+                \"Current loop access out of loop\".to_string(),\n+            ))?\n             .end\n         {\n             Some(x) => x,\n             None => {\n                 let s = self.new_basic_block();\n                 self.current_loop_blocks\n                     .as_mut()\n-                    .ok_or(MirLowerError::ImplementationError(\"Current loop access out of loop\"))?\n+                    .ok_or(MirLowerError::ImplementationError(\n+                        \"Current loop access out of loop\".to_string(),\n+                    ))?\n                     .end = Some(s);\n                 s\n             }\n@@ -1183,7 +1276,7 @@ impl MirLowerCtx<'_> {\n \n     /// This function push `StorageLive` statement for the binding, and applies changes to add `StorageDead` in\n     /// the appropriated places.\n-    fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId) {\n+    fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId) -> Result<()> {\n         // Current implementation is wrong. It adds no `StorageDead` at the end of scope, and before each break\n         // and continue. It just add a `StorageDead` before the `StorageLive`, which is not wrong, but unneeeded in\n         // the proper implementation. Due this limitation, implementing a borrow checker on top of this mir will falsely\n@@ -1208,9 +1301,10 @@ impl MirLowerCtx<'_> {\n             .copied()\n             .map(MirSpan::PatId)\n             .unwrap_or(MirSpan::Unknown);\n-        let l = self.result.binding_locals[b];\n+        let l = self.binding_local(b)?;\n         self.push_statement(current, StatementKind::StorageDead(l).with_span(span));\n         self.push_statement(current, StatementKind::StorageLive(l).with_span(span));\n+        Ok(())\n     }\n \n     fn resolve_lang_item(&self, item: LangItem) -> Result<LangItemTarget> {\n@@ -1220,14 +1314,14 @@ impl MirLowerCtx<'_> {\n \n     fn lower_block_to_place(\n         &mut self,\n-        statements: &[hir_def::expr::Statement],\n+        statements: &[hir_def::hir::Statement],\n         mut current: BasicBlockId,\n         tail: Option<ExprId>,\n         place: Place,\n     ) -> Result<Option<Idx<BasicBlock>>> {\n         for statement in statements.iter() {\n             match statement {\n-                hir_def::expr::Statement::Let { pat, initializer, else_branch, type_ref: _ } => {\n+                hir_def::hir::Statement::Let { pat, initializer, else_branch, type_ref: _ } => {\n                     if let Some(expr_id) = initializer {\n                         let else_block;\n                         let Some((init_place, c)) =\n@@ -1258,12 +1352,18 @@ impl MirLowerCtx<'_> {\n                             }\n                         }\n                     } else {\n+                        let mut err = None;\n                         self.body.walk_bindings_in_pat(*pat, |b| {\n-                            self.push_storage_live(b, current);\n+                            if let Err(e) = self.push_storage_live(b, current) {\n+                                err = Some(e);\n+                            }\n                         });\n+                        if let Some(e) = err {\n+                            return Err(e);\n+                        }\n                     }\n                 }\n-                hir_def::expr::Statement::Expr { expr, has_semi: _ } => {\n+                hir_def::hir::Statement::Expr { expr, has_semi: _ } => {\n                     let Some((_, c)) = self.lower_expr_as_place(current, *expr, true)? else {\n                         return Ok(None);\n                     };\n@@ -1276,6 +1376,67 @@ impl MirLowerCtx<'_> {\n             None => Ok(Some(current)),\n         }\n     }\n+\n+    fn lower_params_and_bindings(\n+        &mut self,\n+        params: impl Iterator<Item = (PatId, Ty)> + Clone,\n+        pick_binding: impl Fn(BindingId) -> bool,\n+    ) -> Result<BasicBlockId> {\n+        let base_param_count = self.result.param_locals.len();\n+        self.result.param_locals.extend(params.clone().map(|(x, ty)| {\n+            let local_id = self.result.locals.alloc(Local { ty });\n+            if let Pat::Bind { id, subpat: None } = self.body[x] {\n+                if matches!(\n+                    self.body.bindings[id].mode,\n+                    BindingAnnotation::Unannotated | BindingAnnotation::Mutable\n+                ) {\n+                    self.result.binding_locals.insert(id, local_id);\n+                }\n+            }\n+            local_id\n+        }));\n+        // and then rest of bindings\n+        for (id, _) in self.body.bindings.iter() {\n+            if !pick_binding(id) {\n+                continue;\n+            }\n+            if !self.result.binding_locals.contains_idx(id) {\n+                self.result\n+                    .binding_locals\n+                    .insert(id, self.result.locals.alloc(Local { ty: self.infer[id].clone() }));\n+            }\n+        }\n+        let mut current = self.result.start_block;\n+        for ((param, _), local) in\n+            params.zip(self.result.param_locals.clone().into_iter().skip(base_param_count))\n+        {\n+            if let Pat::Bind { id, .. } = self.body[param] {\n+                if local == self.binding_local(id)? {\n+                    continue;\n+                }\n+            }\n+            let r = self.pattern_match(\n+                current,\n+                None,\n+                local.into(),\n+                self.result.locals[local].ty.clone(),\n+                param,\n+                BindingAnnotation::Unannotated,\n+            )?;\n+            if let Some(b) = r.1 {\n+                self.set_terminator(b, Terminator::Unreachable);\n+            }\n+            current = r.0;\n+        }\n+        Ok(current)\n+    }\n+\n+    fn binding_local(&self, b: BindingId) -> Result<LocalId> {\n+        match self.result.binding_locals.get(b) {\n+            Some(x) => Ok(*x),\n+            None => Err(MirLowerError::UnaccessableLocal),\n+        }\n+    }\n }\n \n fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n@@ -1299,6 +1460,87 @@ fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n     })\n }\n \n+pub fn mir_body_for_closure_query(\n+    db: &dyn HirDatabase,\n+    closure: ClosureId,\n+) -> Result<Arc<MirBody>> {\n+    let (owner, expr) = db.lookup_intern_closure(closure.into());\n+    let body = db.body(owner);\n+    let infer = db.infer(owner);\n+    let Expr::Closure { args, body: root, .. } = &body[expr] else {\n+        implementation_error!(\"closure expression is not closure\");\n+    };\n+    let TyKind::Closure(_, substs) = &infer[expr].kind(Interner) else {\n+        implementation_error!(\"closure expression is not closure\");\n+    };\n+    let (captures, _) = infer.closure_info(&closure);\n+    let mut ctx = MirLowerCtx::new(db, owner, &body, &infer);\n+    ctx.result.arg_count = args.len() + 1;\n+    // 0 is return local\n+    ctx.result.locals.alloc(Local { ty: infer[*root].clone() });\n+    ctx.result.locals.alloc(Local { ty: infer[expr].clone() });\n+    let Some(sig) = substs.at(Interner, 0).assert_ty_ref(Interner).callable_sig(db) else {\n+        implementation_error!(\"closure has not callable sig\");\n+    };\n+    let current = ctx.lower_params_and_bindings(\n+        args.iter().zip(sig.params().iter()).map(|(x, y)| (*x, y.clone())),\n+        |_| true,\n+    )?;\n+    if let Some(b) = ctx.lower_expr_to_place(*root, return_slot().into(), current)? {\n+        ctx.set_terminator(b, Terminator::Return);\n+    }\n+    let mut upvar_map: FxHashMap<LocalId, Vec<(&CapturedItem, usize)>> = FxHashMap::default();\n+    for (i, capture) in captures.iter().enumerate() {\n+        let local = ctx.binding_local(capture.place.local)?;\n+        upvar_map.entry(local).or_default().push((capture, i));\n+    }\n+    let mut err = None;\n+    let closure_local = ctx.result.locals.iter().nth(1).unwrap().0;\n+    ctx.result.walk_places(|p| {\n+        if let Some(x) = upvar_map.get(&p.local) {\n+            let r = x.iter().find(|x| {\n+                if p.projection.len() < x.0.place.projections.len() {\n+                    return false;\n+                }\n+                for (x, y) in p.projection.iter().zip(x.0.place.projections.iter()) {\n+                    match (x, y) {\n+                        (ProjectionElem::Deref, ProjectionElem::Deref) => (),\n+                        (ProjectionElem::Field(x), ProjectionElem::Field(y)) if x == y => (),\n+                        (\n+                            ProjectionElem::TupleOrClosureField(x),\n+                            ProjectionElem::TupleOrClosureField(y),\n+                        ) if x == y => (),\n+                        _ => return false,\n+                    }\n+                }\n+                true\n+            });\n+            match r {\n+                Some(x) => {\n+                    p.local = closure_local;\n+                    let prev_projs =\n+                        mem::replace(&mut p.projection, vec![PlaceElem::TupleOrClosureField(x.1)]);\n+                    if x.0.kind != CaptureKind::ByValue {\n+                        p.projection.push(ProjectionElem::Deref);\n+                    }\n+                    p.projection.extend(prev_projs.into_iter().skip(x.0.place.projections.len()));\n+                }\n+                None => err = Some(p.clone()),\n+            }\n+        }\n+    });\n+    ctx.result.binding_locals = ctx\n+        .result\n+        .binding_locals\n+        .into_iter()\n+        .filter(|x| ctx.body[x.0].owner == Some(expr))\n+        .collect();\n+    if let Some(err) = err {\n+        return Err(MirLowerError::UnresolvedUpvar(err));\n+    }\n+    Ok(Arc::new(ctx.result))\n+}\n+\n pub fn mir_body_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Result<Arc<MirBody>> {\n     let _p = profile::span(\"mir_body_query\").detail(|| match def {\n         DefWithBodyId::FunctionId(it) => db.function_data(it).name.to_string(),\n@@ -1336,86 +1578,29 @@ pub fn lower_to_mir(\n     if let Some((_, x)) = infer.type_mismatches().next() {\n         return Err(MirLowerError::TypeMismatch(x.clone()));\n     }\n-    let mut basic_blocks = Arena::new();\n-    let start_block =\n-        basic_blocks.alloc(BasicBlock { statements: vec![], terminator: None, is_cleanup: false });\n-    let mut locals = Arena::new();\n+    let mut ctx = MirLowerCtx::new(db, owner, body, infer);\n     // 0 is return local\n-    locals.alloc(Local { ty: infer[root_expr].clone() });\n-    let mut binding_locals: ArenaMap<BindingId, LocalId> = ArenaMap::new();\n+    ctx.result.locals.alloc(Local { ty: infer[root_expr].clone() });\n+    let binding_picker = |b: BindingId| {\n+        if root_expr == body.body_expr {\n+            body[b].owner.is_none()\n+        } else {\n+            body[b].owner == Some(root_expr)\n+        }\n+    };\n     // 1 to param_len is for params\n-    let param_locals: Vec<LocalId> = if let DefWithBodyId::FunctionId(fid) = owner {\n+    let current = if let DefWithBodyId::FunctionId(fid) = owner {\n         let substs = TyBuilder::placeholder_subst(db, fid);\n         let callable_sig = db.callable_item_signature(fid.into()).substitute(Interner, &substs);\n-        body.params\n-            .iter()\n-            .zip(callable_sig.params().iter())\n-            .map(|(&x, ty)| {\n-                let local_id = locals.alloc(Local { ty: ty.clone() });\n-                if let Pat::Bind { id, subpat: None } = body[x] {\n-                    if matches!(\n-                        body.bindings[id].mode,\n-                        BindingAnnotation::Unannotated | BindingAnnotation::Mutable\n-                    ) {\n-                        binding_locals.insert(id, local_id);\n-                    }\n-                }\n-                local_id\n-            })\n-            .collect()\n+        ctx.lower_params_and_bindings(\n+            body.params.iter().zip(callable_sig.params().iter()).map(|(x, y)| (*x, y.clone())),\n+            binding_picker,\n+        )?\n     } else {\n-        if !body.params.is_empty() {\n-            return Err(MirLowerError::TypeError(\"Unexpected parameter for non function body\"));\n-        }\n-        vec![]\n+        ctx.lower_params_and_bindings([].into_iter(), binding_picker)?\n     };\n-    // and then rest of bindings\n-    for (id, _) in body.bindings.iter() {\n-        if !binding_locals.contains_idx(id) {\n-            binding_locals.insert(id, locals.alloc(Local { ty: infer[id].clone() }));\n-        }\n-    }\n-    let mir = MirBody {\n-        basic_blocks,\n-        locals,\n-        start_block,\n-        binding_locals,\n-        param_locals,\n-        owner,\n-        arg_count: body.params.len(),\n-    };\n-    let mut ctx = MirLowerCtx {\n-        result: mir,\n-        db,\n-        infer,\n-        body,\n-        owner,\n-        current_loop_blocks: None,\n-        labeled_loop_blocks: Default::default(),\n-        discr_temp: None,\n-    };\n-    let mut current = start_block;\n-    for (&param, local) in body.params.iter().zip(ctx.result.param_locals.clone().into_iter()) {\n-        if let Pat::Bind { id, .. } = body[param] {\n-            if local == ctx.result.binding_locals[id] {\n-                continue;\n-            }\n-        }\n-        let r = ctx.pattern_match(\n-            current,\n-            None,\n-            local.into(),\n-            ctx.result.locals[local].ty.clone(),\n-            param,\n-            BindingAnnotation::Unannotated,\n-        )?;\n-        if let Some(b) = r.1 {\n-            ctx.set_terminator(b, Terminator::Unreachable);\n-        }\n-        current = r.0;\n-    }\n     if let Some(b) = ctx.lower_expr_to_place(root_expr, return_slot().into(), current)? {\n-        ctx.result.basic_blocks[b].terminator = Some(Terminator::Return);\n+        ctx.set_terminator(b, Terminator::Return);\n     }\n     Ok(ctx.result)\n }"}, {"sha": "a1574f55936933955a1ab01479f8bb8374d0f013", "filename": "crates/hir-ty/src/mir/lower/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -141,7 +141,7 @@ impl MirLowerCtx<'_> {\n                 }\n             }\n             Expr::UnaryOp { expr, op } => match op {\n-                hir_def::expr::UnaryOp::Deref => {\n+                hir_def::hir::UnaryOp::Deref => {\n                     if !matches!(\n                         self.expr_ty(*expr).kind(Interner),\n                         TyKind::Ref(..) | TyKind::Raw(..)"}, {"sha": "12a77715e9c676adeb1affd7b90f20652c63c50c", "filename": "crates/hir-ty/src/mir/lower/pattern_matching.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,5 +1,7 @@\n //! MIR lowering for patterns\n \n+use crate::utils::pattern_matching_dereference_count;\n+\n use super::*;\n \n macro_rules! not_supported {\n@@ -52,7 +54,7 @@ impl MirLowerCtx<'_> {\n                     args,\n                     *ellipsis,\n                     subst.iter(Interner).enumerate().map(|(i, x)| {\n-                        (PlaceElem::TupleField(i), x.assert_ty_ref(Interner).clone())\n+                        (PlaceElem::TupleOrClosureField(i), x.assert_ty_ref(Interner).clone())\n                     }),\n                     &cond_place,\n                     binding_mode,\n@@ -142,7 +144,7 @@ impl MirLowerCtx<'_> {\n                 if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n                     binding_mode = mode;\n                 }\n-                self.push_storage_live(*id, current);\n+                self.push_storage_live(*id, current)?;\n                 self.push_assignment(\n                     current,\n                     target_place.into(),\n@@ -387,13 +389,6 @@ fn pattern_matching_dereference(\n     binding_mode: &mut BindingAnnotation,\n     cond_place: &mut Place,\n ) {\n-    while let Some((ty, _, mu)) = cond_ty.as_reference() {\n-        if mu == Mutability::Mut && *binding_mode != BindingAnnotation::Ref {\n-            *binding_mode = BindingAnnotation::RefMut;\n-        } else {\n-            *binding_mode = BindingAnnotation::Ref;\n-        }\n-        *cond_ty = ty.clone();\n-        cond_place.projection.push(ProjectionElem::Deref);\n-    }\n+    let cnt = pattern_matching_dereference_count(cond_ty, binding_mode);\n+    cond_place.projection.extend((0..cnt).map(|_| ProjectionElem::Deref));\n }"}, {"sha": "3e1f2ecef1b5bc3658a0eeecab4884bf9a03090e", "filename": "crates/hir-ty/src/mir/pretty.rs", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,8 +1,11 @@\n //! A pretty-printer for MIR.\n \n-use std::fmt::{Debug, Display, Write};\n+use std::{\n+    fmt::{Debug, Display, Write},\n+    mem,\n+};\n \n-use hir_def::{body::Body, expr::BindingId};\n+use hir_def::{body::Body, hir::BindingId};\n use hir_expand::name::Name;\n use la_arena::ArenaMap;\n \n@@ -20,7 +23,7 @@ impl MirBody {\n     pub fn pretty_print(&self, db: &dyn HirDatabase) -> String {\n         let hir_body = db.body(self.owner);\n         let mut ctx = MirPrettyCtx::new(self, &hir_body, db);\n-        ctx.for_body();\n+        ctx.for_body(ctx.body.owner);\n         ctx.result\n     }\n \n@@ -42,7 +45,7 @@ struct MirPrettyCtx<'a> {\n     hir_body: &'a Body,\n     db: &'a dyn HirDatabase,\n     result: String,\n-    ident: String,\n+    indent: String,\n     local_to_binding: ArenaMap<LocalId, BindingId>,\n }\n \n@@ -88,22 +91,43 @@ impl Display for LocalName {\n }\n \n impl<'a> MirPrettyCtx<'a> {\n-    fn for_body(&mut self) {\n-        wln!(self, \"// {:?}\", self.body.owner);\n+    fn for_body(&mut self, name: impl Debug) {\n+        wln!(self, \"// {:?}\", name);\n         self.with_block(|this| {\n             this.locals();\n             wln!(this);\n             this.blocks();\n         });\n+        for &closure in &self.body.closures {\n+            let body = match self.db.mir_body_for_closure(closure) {\n+                Ok(x) => x,\n+                Err(e) => {\n+                    wln!(self, \"// error in {closure:?}: {e:?}\");\n+                    continue;\n+                }\n+            };\n+            let result = mem::take(&mut self.result);\n+            let indent = mem::take(&mut self.indent);\n+            let mut ctx = MirPrettyCtx {\n+                body: &body,\n+                local_to_binding: body.binding_locals.iter().map(|(x, y)| (*y, x)).collect(),\n+                result,\n+                indent,\n+                ..*self\n+            };\n+            ctx.for_body(closure);\n+            self.result = ctx.result;\n+            self.indent = ctx.indent;\n+        }\n     }\n \n     fn with_block(&mut self, f: impl FnOnce(&mut MirPrettyCtx<'_>)) {\n-        self.ident += \"    \";\n+        self.indent += \"    \";\n         wln!(self, \"{{\");\n         f(self);\n         for _ in 0..4 {\n             self.result.pop();\n-            self.ident.pop();\n+            self.indent.pop();\n         }\n         wln!(self, \"}}\");\n     }\n@@ -114,15 +138,15 @@ impl<'a> MirPrettyCtx<'a> {\n             body,\n             db,\n             result: String::new(),\n-            ident: String::new(),\n+            indent: String::new(),\n             local_to_binding,\n             hir_body,\n         }\n     }\n \n     fn write_line(&mut self) {\n         self.result.push('\\n');\n-        self.result += &self.ident;\n+        self.result += &self.indent;\n     }\n \n     fn write(&mut self, line: &str) {\n@@ -247,7 +271,7 @@ impl<'a> MirPrettyCtx<'a> {\n                         }\n                     }\n                 }\n-                ProjectionElem::TupleField(x) => {\n+                ProjectionElem::TupleOrClosureField(x) => {\n                     f(this, local, head);\n                     w!(this, \".{}\", x);\n                 }\n@@ -302,6 +326,11 @@ impl<'a> MirPrettyCtx<'a> {\n                 self.operand_list(x);\n                 w!(self, \")\");\n             }\n+            Rvalue::Aggregate(AggregateKind::Closure(_), x) => {\n+                w!(self, \"Closure(\");\n+                self.operand_list(x);\n+                w!(self, \")\");\n+            }\n             Rvalue::Aggregate(AggregateKind::Union(_, _), x) => {\n                 w!(self, \"Union(\");\n                 self.operand_list(x);"}, {"sha": "1e46bb1d04092ad8c1b54e6c8bc22c95e7f49972", "filename": "crates/hir-ty/src/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -17,7 +17,7 @@ use expect_test::Expect;\n use hir_def::{\n     body::{Body, BodySourceMap, SyntheticSyntax},\n     db::{DefDatabase, InternDatabase},\n-    expr::{ExprId, PatId},\n+    hir::{ExprId, PatId},\n     item_scope::ItemScope,\n     nameres::DefMap,\n     src::HasSource,\n@@ -198,8 +198,8 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n \n         for (expr_or_pat, mismatch) in inference_result.type_mismatches() {\n             let Some(node) = (match expr_or_pat {\n-                hir_def::expr::ExprOrPatId::ExprId(expr) => expr_node(&body_source_map, expr, &db),\n-                hir_def::expr::ExprOrPatId::PatId(pat) => pat_node(&body_source_map, pat, &db),\n+                hir_def::hir::ExprOrPatId::ExprId(expr) => expr_node(&body_source_map, expr, &db),\n+                hir_def::hir::ExprOrPatId::PatId(pat) => pat_node(&body_source_map, pat, &db),\n             }) else { continue; };\n             let range = node.as_ref().original_file_range(&db);\n             let actual = format!("}, {"sha": "16e5ef85d09d5b6a1d32f19de271ae0745bc968b", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -575,7 +575,7 @@ fn two_closures_lub() {\n fn foo(c: i32) {\n     let add = |a: i32, b: i32| a + b;\n     let sub = |a, b| a - b;\n-            //^^^^^^^^^^^^ |i32, i32| -> i32\n+            //^^^^^^^^^^^^ impl Fn(i32, i32) -> i32\n     if c > 42 { add } else { sub };\n   //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ fn(i32, i32) -> i32\n }\n@@ -875,6 +875,16 @@ fn test() {\n fn adjust_index() {\n     check_no_mismatches(\n         r\"\n+//- minicore: index, slice, coerce_unsized\n+fn test() {\n+    let x = [1, 2, 3];\n+    x[2] = 6;\n+ // ^ adjustments: Borrow(Ref(Mut))\n+}\n+    \",\n+    );\n+    check_no_mismatches(\n+        r\"\n //- minicore: index\n struct Struct;\n impl core::ops::Index<usize> for Struct {\n@@ -902,3 +912,32 @@ fn test() {\n }\",\n     );\n }\n+\n+#[test]\n+fn regression_14443_dyn_coercion_block_impls() {\n+    check_no_mismatches(\n+        r#\"\n+//- minicore: coerce_unsized\n+trait T {}\n+\n+fn dyn_t(d: &dyn T) {}\n+\n+fn main() {\n+    struct A;\n+    impl T for A {}\n+\n+    let a = A;\n+\n+    let b = {\n+        struct B;\n+        impl T for B {}\n+\n+        B\n+    };\n+\n+    dyn_t(&a);\n+    dyn_t(&b);\n+}\n+\"#,\n+    )\n+}"}, {"sha": "d45edf730ad5fd3e2f1e945a2c566c6bb4fe65b2", "filename": "crates/hir-ty/src/tests/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -198,7 +198,7 @@ fn expr_macro_def_expanded_in_various_places() {\n             100..119 'for _ ...!() {}': ()\n             104..105 '_': {unknown}\n             117..119 '{}': ()\n-            124..134 '|| spam!()': || -> isize\n+            124..134 '|| spam!()': impl Fn() -> isize\n             140..156 'while ...!() {}': ()\n             154..156 '{}': ()\n             161..174 'break spam!()': !\n@@ -279,7 +279,7 @@ fn expr_macro_rules_expanded_in_various_places() {\n             114..133 'for _ ...!() {}': ()\n             118..119 '_': {unknown}\n             131..133 '{}': ()\n-            138..148 '|| spam!()': || -> isize\n+            138..148 '|| spam!()': impl Fn() -> isize\n             154..170 'while ...!() {}': ()\n             168..170 '{}': ()\n             175..188 'break spam!()': !"}, {"sha": "f62a3cfabe895958f1057f7030b69dd3f6399671", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -388,6 +388,24 @@ mod bar_test {\n     );\n }\n \n+#[test]\n+fn infer_trait_method_multiple_mutable_reference() {\n+    check_types(\n+        r#\"\n+trait Trait {\n+    fn method(&mut self) -> i32 { 5 }\n+}\n+struct S;\n+impl Trait for &mut &mut S {}\n+fn test() {\n+    let s = &mut &mut &mut S;\n+    s.method();\n+  //^^^^^^^^^^ i32\n+}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn infer_trait_method_generic_1() {\n     // the trait implementation is intentionally incomplete -- it shouldn't matter\n@@ -1722,7 +1740,7 @@ fn test() {\n     Foo.foo();\n   //^^^ adjustments: Borrow(Ref(Not))\n     (&Foo).foo();\n-  // ^^^^ adjustments: ,\n+  // ^^^^ adjustments: Deref(None), Borrow(Ref(Not))\n }\n \"#,\n     );"}, {"sha": "c8c31bdea5cbfaa2c2d29c840ebb06eb1bc623de", "filename": "crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -70,8 +70,8 @@ fn infer_pattern() {\n             228..233 '&true': &bool\n             229..233 'true': bool\n             234..236 '{}': ()\n-            246..252 'lambda': |u64, u64, i32| -> i32\n-            255..287 '|a: u6...b; c }': |u64, u64, i32| -> i32\n+            246..252 'lambda': impl Fn(u64, u64, i32) -> i32\n+            255..287 '|a: u6...b; c }': impl Fn(u64, u64, i32) -> i32\n             256..257 'a': u64\n             264..265 'b': u64\n             267..268 'c': i32\n@@ -476,7 +476,7 @@ fn infer_adt_pattern() {\n             183..184 'x': usize\n             190..191 'x': usize\n             201..205 'E::B': E\n-            209..212 'foo': {unknown}\n+            209..212 'foo': bool\n             216..217 '1': usize\n             227..231 'E::B': E\n             235..237 '10': usize\n@@ -677,25 +677,25 @@ fn test() {\n             51..58 'loop {}': !\n             56..58 '{}': ()\n             72..171 '{     ... x); }': ()\n-            78..81 'foo': fn foo<&(i32, &str), i32, |&(i32, &str)| -> i32>(&(i32, &str), |&(i32, &str)| -> i32) -> i32\n+            78..81 'foo': fn foo<&(i32, &str), i32, impl Fn(&(i32, &str)) -> i32>(&(i32, &str), impl Fn(&(i32, &str)) -> i32) -> i32\n             78..105 'foo(&(...y)| x)': i32\n             82..91 '&(1, \"a\")': &(i32, &str)\n             83..91 '(1, \"a\")': (i32, &str)\n             84..85 '1': i32\n             87..90 '\"a\"': &str\n-            93..104 '|&(x, y)| x': |&(i32, &str)| -> i32\n+            93..104 '|&(x, y)| x': impl Fn(&(i32, &str)) -> i32\n             94..101 '&(x, y)': &(i32, &str)\n             95..101 '(x, y)': (i32, &str)\n             96..97 'x': i32\n             99..100 'y': &str\n             103..104 'x': i32\n-            142..145 'foo': fn foo<&(i32, &str), &i32, |&(i32, &str)| -> &i32>(&(i32, &str), |&(i32, &str)| -> &i32) -> &i32\n+            142..145 'foo': fn foo<&(i32, &str), &i32, impl Fn(&(i32, &str)) -> &i32>(&(i32, &str), impl Fn(&(i32, &str)) -> &i32) -> &i32\n             142..168 'foo(&(...y)| x)': &i32\n             146..155 '&(1, \"a\")': &(i32, &str)\n             147..155 '(1, \"a\")': (i32, &str)\n             148..149 '1': i32\n             151..154 '\"a\"': &str\n-            157..167 '|(x, y)| x': |&(i32, &str)| -> &i32\n+            157..167 '|(x, y)| x': impl Fn(&(i32, &str)) -> &i32\n             158..164 '(x, y)': (i32, &str)\n             159..160 'x': &i32\n             162..163 'y': &&str"}, {"sha": "28b87689ecd3be75a0fe9e17440f4020f23ad5ab", "filename": "crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 52, "deletions": 16, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -270,7 +270,7 @@ fn infer_std_crash_5() {\n             61..320 '{     ...     }': ()\n             75..79 'name': &{unknown}\n             82..166 'if doe...     }': &{unknown}\n-            85..98 'doesnt_matter': {unknown}\n+            85..98 'doesnt_matter': bool\n             99..128 '{     ...     }': &{unknown}\n             113..118 'first': &{unknown}\n             134..166 '{     ...     }': &{unknown}\n@@ -279,7 +279,7 @@ fn infer_std_crash_5() {\n             181..188 'content': &{unknown}\n             191..313 'if ICE...     }': &{unknown}\n             194..231 'ICE_RE..._VALUE': {unknown}\n-            194..247 'ICE_RE...&name)': {unknown}\n+            194..247 'ICE_RE...&name)': bool\n             241..246 '&name': &&{unknown}\n             242..246 'name': &{unknown}\n             248..276 '{     ...     }': &{unknown}\n@@ -805,19 +805,19 @@ fn issue_4966() {\n             225..229 'iter': T\n             244..246 '{}': Vec<A>\n             258..402 '{     ...r(); }': ()\n-            268..273 'inner': Map<|&f64| -> f64>\n-            276..300 'Map { ... 0.0 }': Map<|&f64| -> f64>\n-            285..298 '|_: &f64| 0.0': |&f64| -> f64\n+            268..273 'inner': Map<impl Fn(&f64) -> f64>\n+            276..300 'Map { ... 0.0 }': Map<impl Fn(&f64) -> f64>\n+            285..298 '|_: &f64| 0.0': impl Fn(&f64) -> f64\n             286..287 '_': &f64\n             295..298 '0.0': f64\n-            311..317 'repeat': Repeat<Map<|&f64| -> f64>>\n-            320..345 'Repeat...nner }': Repeat<Map<|&f64| -> f64>>\n-            338..343 'inner': Map<|&f64| -> f64>\n-            356..359 'vec': Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n-            362..371 'from_iter': fn from_iter<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>, Repeat<Map<|&f64| -> f64>>>(Repeat<Map<|&f64| -> f64>>) -> Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n-            362..379 'from_i...epeat)': Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n-            372..378 'repeat': Repeat<Map<|&f64| -> f64>>\n-            386..389 'vec': Vec<IntoIterator::Item<Repeat<Map<|&f64| -> f64>>>>\n+            311..317 'repeat': Repeat<Map<impl Fn(&f64) -> f64>>\n+            320..345 'Repeat...nner }': Repeat<Map<impl Fn(&f64) -> f64>>\n+            338..343 'inner': Map<impl Fn(&f64) -> f64>\n+            356..359 'vec': Vec<IntoIterator::Item<Repeat<Map<impl Fn(&f64) -> f64>>>>\n+            362..371 'from_iter': fn from_iter<IntoIterator::Item<Repeat<Map<impl Fn(&f64) -> f64>>>, Repeat<Map<impl Fn(&f64) -> f64>>>(Repeat<Map<impl Fn(&f64) -> f64>>) -> Vec<IntoIterator::Item<Repeat<Map<impl Fn(&f64) -> f64>>>>\n+            362..379 'from_i...epeat)': Vec<IntoIterator::Item<Repeat<Map<impl Fn(&f64) -> f64>>>>\n+            372..378 'repeat': Repeat<Map<impl Fn(&f64) -> f64>>\n+            386..389 'vec': Vec<IntoIterator::Item<Repeat<Map<impl Fn(&f64) -> f64>>>>\n             386..399 'vec.foo_bar()': {unknown}\n         \"#]],\n     );\n@@ -852,7 +852,7 @@ fn main() {\n             123..126 'S()': S<i32>\n             132..133 's': S<i32>\n             132..144 's.g(|_x| {})': ()\n-            136..143 '|_x| {}': |&i32| -> ()\n+            136..143 '|_x| {}': impl Fn(&i32)\n             137..139 '_x': &i32\n             141..143 '{}': ()\n             150..151 's': S<i32>\n@@ -1067,6 +1067,23 @@ fn parse_arule() {\n     )\n }\n \n+#[test]\n+fn nested_closure() {\n+    check_types(\n+        r#\"\n+//- minicore: fn, option\n+\n+fn map<T, U>(o: Option<T>, f: impl FnOnce(T) -> U) -> Option<U> { loop {} }\n+\n+fn test() {\n+    let o = Some(Some(2));\n+    map(o, |s| map(s, |x| x));\n+                    // ^ i32\n+}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn call_expected_type_closure() {\n     check_types(\n@@ -1759,13 +1776,14 @@ const C: usize = 2 + 2;\n \n #[test]\n fn regression_14456() {\n-    check_no_mismatches(\n+    check_types(\n         r#\"\n //- minicore: future\n async fn x() {}\n fn f() {\n     let fut = x();\n-    let t = [0u8; 2 + 2];\n+    let t = [0u8; { let a = 2 + 2; a }];\n+      //^ [u8; 4]\n }\n \"#,\n     );\n@@ -1802,3 +1820,21 @@ where\n \"#,\n     );\n }\n+\n+#[test]\n+fn match_ergonomics_with_binding_modes_interaction() {\n+    check_types(\n+        r\"\n+enum E { A }\n+fn foo() {\n+    match &E::A {\n+        b @ (x @ E::A | x) => {\n+            b;\n+          //^ &E\n+            x;\n+          //^ &E\n+        }\n+    }\n+}\",\n+    );\n+}"}, {"sha": "2b14a28a67221f49f7e0546b5ba2013598858f3e", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 197, "deletions": 11, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1906,8 +1906,8 @@ fn closure_return() {\n         \"#,\n         expect![[r#\"\n             16..58 '{     ...; }; }': u32\n-            26..27 'x': || -> usize\n-            30..55 '|| -> ...n 1; }': || -> usize\n+            26..27 'x': impl Fn() -> usize\n+            30..55 '|| -> ...n 1; }': impl Fn() -> usize\n             42..55 '{ return 1; }': usize\n             44..52 'return 1': !\n             51..52 '1': usize\n@@ -1925,8 +1925,8 @@ fn closure_return_unit() {\n         \"#,\n         expect![[r#\"\n             16..47 '{     ...; }; }': u32\n-            26..27 'x': || -> ()\n-            30..44 '|| { return; }': || -> ()\n+            26..27 'x': impl Fn()\n+            30..44 '|| { return; }': impl Fn()\n             33..44 '{ return; }': ()\n             35..41 'return': !\n         \"#]],\n@@ -1943,8 +1943,8 @@ fn closure_return_inferred() {\n         \"#,\n         expect![[r#\"\n             16..46 '{     ...\" }; }': u32\n-            26..27 'x': || -> &str\n-            30..43 '|| { \"test\" }': || -> &str\n+            26..27 'x': impl Fn() -> &str\n+            30..43 '|| { \"test\" }': impl Fn() -> &str\n             33..43 '{ \"test\" }': &str\n             35..41 '\"test\"': &str\n         \"#]],\n@@ -2050,7 +2050,7 @@ fn fn_pointer_return() {\n             47..120 '{     ...hod; }': ()\n             57..63 'vtable': Vtable\n             66..90 'Vtable...| {} }': Vtable\n-            83..88 '|| {}': || -> ()\n+            83..88 '|| {}': impl Fn()\n             86..88 '{}': ()\n             100..101 'm': fn()\n             104..110 'vtable': Vtable\n@@ -2142,9 +2142,9 @@ fn main() {\n             149..151 'Ok': Ok<(), ()>(()) -> Result<(), ()>\n             149..155 'Ok(())': Result<(), ()>\n             152..154 '()': ()\n-            167..171 'test': fn test<(), (), || -> impl Future<Output = Result<(), ()>>, impl Future<Output = Result<(), ()>>>(|| -> impl Future<Output = Result<(), ()>>)\n+            167..171 'test': fn test<(), (), impl Fn() -> impl Future<Output = Result<(), ()>>, impl Future<Output = Result<(), ()>>>(impl Fn() -> impl Future<Output = Result<(), ()>>)\n             167..228 'test(|...    })': ()\n-            172..227 '|| asy...     }': || -> impl Future<Output = Result<(), ()>>\n+            172..227 '|| asy...     }': impl Fn() -> impl Future<Output = Result<(), ()>>\n             175..227 'async ...     }': impl Future<Output = Result<(), ()>>\n             191..205 'return Err(())': !\n             198..201 'Err': Err<(), ()>(()) -> Result<(), ()>\n@@ -2270,8 +2270,8 @@ fn infer_labelled_break_with_val() {\n         \"#,\n         expect![[r#\"\n             9..335 '{     ...  }; }': ()\n-            19..21 '_x': || -> bool\n-            24..332 '|| 'ou...     }': || -> bool\n+            19..21 '_x': impl Fn() -> bool\n+            24..332 '|| 'ou...     }': impl Fn() -> bool\n             27..332 ''outer...     }': bool\n             40..332 '{     ...     }': ()\n             54..59 'inner': i8\n@@ -2695,6 +2695,179 @@ impl B for Astruct {}\n     )\n }\n \n+#[test]\n+fn capture_kinds_simple() {\n+    check_types(\n+        r#\"\n+struct S;\n+\n+impl S {\n+    fn read(&self) -> &S { self }\n+    fn write(&mut self) -> &mut S { self }\n+    fn consume(self) -> S { self }\n+}\n+\n+fn f() {\n+    let x = S;\n+    let c1 = || x.read();\n+      //^^ impl Fn() -> &S\n+    let c2 = || x.write();\n+      //^^ impl FnMut() -> &mut S\n+    let c3 = || x.consume();\n+      //^^ impl FnOnce() -> S\n+    let c3 = || x.consume().consume().consume();\n+      //^^ impl FnOnce() -> S\n+    let c3 = || x.consume().write().read();\n+      //^^ impl FnOnce() -> &S\n+    let x = &mut x;\n+    let c1 = || x.write();\n+      //^^ impl FnMut() -> &mut S\n+    let x = S;\n+    let c1 = || { let ref t = x; t };\n+      //^^ impl Fn() -> &S\n+    let c2 = || { let ref mut t = x; t };\n+      //^^ impl FnMut() -> &mut S\n+    let c3 = || { let t = x; t };\n+      //^^ impl FnOnce() -> S\n+}\n+    \"#,\n+    )\n+}\n+\n+#[test]\n+fn capture_kinds_closure() {\n+    check_types(\n+        r#\"\n+//- minicore: copy, fn\n+fn f() {\n+    let mut x = 2;\n+    x = 5;\n+    let mut c1 = || { x = 3; x };\n+      //^^^^^^ impl FnMut() -> i32\n+    let mut c2 = || { c1() };\n+      //^^^^^^ impl FnMut() -> i32\n+    let mut c1 = || { x };\n+      //^^^^^^ impl Fn() -> i32\n+    let mut c2 = || { c1() };\n+      //^^^^^^ impl Fn() -> i32\n+    struct X;\n+    let x = X;\n+    let mut c1 = || { x };\n+      //^^^^^^ impl FnOnce() -> X\n+    let mut c2 = || { c1() };\n+      //^^^^^^ impl FnOnce() -> X\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn capture_kinds_overloaded_deref() {\n+    check_types(\n+        r#\"\n+//- minicore: fn, deref_mut\n+use core::ops::{Deref, DerefMut};\n+\n+struct Foo;\n+impl Deref for Foo {\n+    type Target = (i32, u8);\n+    fn deref(&self) -> &(i32, u8) {\n+        &(5, 2)\n+    }\n+}\n+impl DerefMut for Foo {\n+    fn deref_mut(&mut self) -> &mut (i32, u8) {\n+        &mut (5, 2)\n+    }\n+}\n+fn test() {\n+    let mut x = Foo;\n+    let c1 = || *x;\n+      //^^ impl Fn() -> (i32, u8)\n+    let c2 = || { *x = (2, 5); };\n+      //^^ impl FnMut()\n+    let c3 = || { x.1 };\n+      //^^ impl Fn() -> u8\n+    let c4 = || { x.1 = 6; };\n+      //^^ impl FnMut()\n+}\n+       \"#,\n+    );\n+}\n+\n+#[test]\n+fn capture_kinds_with_copy_types() {\n+    check_types(\n+        r#\"\n+//- minicore: copy, clone, derive\n+#[derive(Clone, Copy)]\n+struct Copy;\n+struct NotCopy;\n+#[derive(Clone, Copy)]\n+struct Generic<T>(T);\n+\n+trait Tr {\n+    type Assoc;\n+}\n+\n+impl Tr for Copy {\n+    type Assoc = NotCopy;\n+}\n+\n+#[derive(Clone, Copy)]\n+struct AssocGeneric<T: Tr>(T::Assoc);\n+\n+fn f() {\n+    let a = Copy;\n+    let b = NotCopy;\n+    let c = Generic(Copy);\n+    let d = Generic(NotCopy);\n+    let e: AssocGeneric<Copy> = AssocGeneric(NotCopy);\n+    let c1 = || a;\n+      //^^ impl Fn() -> Copy\n+    let c2 = || b;\n+      //^^ impl FnOnce() -> NotCopy\n+    let c3 = || c;\n+      //^^ impl Fn() -> Generic<Copy>\n+    let c3 = || d;\n+      //^^ impl FnOnce() -> Generic<NotCopy>\n+    let c3 = || e;\n+      //^^ impl FnOnce() -> AssocGeneric<Copy>\n+}\n+    \"#,\n+    )\n+}\n+\n+#[test]\n+fn derive_macro_should_work_for_associated_type() {\n+    check_types(\n+        r#\"\n+//- minicore: copy, clone, derive\n+#[derive(Clone)]\n+struct X;\n+#[derive(Clone)]\n+struct Y;\n+\n+trait Tr {\n+    type Assoc;\n+}\n+\n+impl Tr for X {\n+    type Assoc = Y;\n+}\n+\n+#[derive(Clone)]\n+struct AssocGeneric<T: Tr>(T::Assoc);\n+\n+fn f() {\n+    let e: AssocGeneric<X> = AssocGeneric(Y);\n+    let e_clone = e.clone();\n+      //^^^^^^^ AssocGeneric<X>\n+}\n+    \"#,\n+    )\n+}\n+\n #[test]\n fn cfgd_out_assoc_items() {\n     check_types(\n@@ -3291,6 +3464,19 @@ fn f<T>(t: Ark<T>) {\n     );\n }\n \n+#[test]\n+fn const_dependent_on_local() {\n+    check_types(\n+        r#\"\n+fn main() {\n+    let s = 5;\n+    let t = [2; s];\n+      //^ [i32; _]\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn issue_14275() {\n     // FIXME: evaluate const generic"}, {"sha": "fdfae44c2d13ea19891684fb371d3331abc34afc", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 126, "deletions": 37, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -90,7 +90,7 @@ fn infer_async_closure() {\n async fn test() {\n     let f = async move |x: i32| x + 42;\n     f;\n-//  ^ |i32| -> impl Future<Output = i32>\n+//  ^ impl Fn(i32) -> impl Future<Output = i32>\n     let a = f(4);\n     a;\n //  ^ impl Future<Output = i32>\n@@ -99,7 +99,7 @@ async fn test() {\n //  ^ i32\n     let f = async move || 42;\n     f;\n-//  ^ || -> impl Future<Output = i32>\n+//  ^ impl Fn() -> impl Future<Output = i32>\n     let a = f();\n     a;\n //  ^ impl Future<Output = i32>\n@@ -116,7 +116,7 @@ async fn test() {\n     };\n     let _: Option<u64> = c().await;\n     c;\n-//  ^ || -> impl Future<Output = Option<u64>>\n+//  ^ impl Fn() -> impl Future<Output = Option<u64>>\n }\n \"#,\n     );\n@@ -550,7 +550,7 @@ fn test() -> u64 {\n             53..54 'a': S\n             57..58 'S': S(fn(u32) -> u64) -> S\n             57..74 'S(|i| ...s u64)': S\n-            59..73 '|i| 2*i as u64': |u32| -> u64\n+            59..73 '|i| 2*i as u64': impl Fn(u32) -> u64\n             60..61 'i': u32\n             63..64 '2': u64\n             63..73 '2*i as u64': u64\n@@ -1333,9 +1333,9 @@ fn foo<const C: u8, T>() -> (impl FnOnce(&str, T), impl Trait<u8>) {\n }\n \"#,\n         expect![[r#\"\n-            134..165 '{     ...(C)) }': (|&str, T| -> (), Bar<u8>)\n-            140..163 '(|inpu...ar(C))': (|&str, T| -> (), Bar<u8>)\n-            141..154 '|input, t| {}': |&str, T| -> ()\n+            134..165 '{     ...(C)) }': (impl Fn(&str, T), Bar<u8>)\n+            140..163 '(|inpu...ar(C))': (impl Fn(&str, T), Bar<u8>)\n+            141..154 '|input, t| {}': impl Fn(&str, T)\n             142..147 'input': &str\n             149..150 't': T\n             152..154 '{}': ()\n@@ -1506,8 +1506,8 @@ fn main() {\n             71..105 '{     ...()); }': ()\n             77..78 'f': fn f(&dyn Fn(S))\n             77..102 'f(&|nu...foo())': ()\n-            79..101 '&|numb....foo()': &|S| -> ()\n-            80..101 '|numbe....foo()': |S| -> ()\n+            79..101 '&|numb....foo()': &impl Fn(S)\n+            80..101 '|numbe....foo()': impl Fn(S)\n             81..87 'number': S\n             89..95 'number': S\n             89..101 'number.foo()': ()\n@@ -1912,13 +1912,13 @@ fn test() {\n             131..132 'f': F\n             151..153 '{}': Lazy<T, F>\n             251..497 '{     ...o(); }': ()\n-            261..266 'lazy1': Lazy<Foo, || -> Foo>\n-            283..292 'Lazy::new': fn new<Foo, || -> Foo>(|| -> Foo) -> Lazy<Foo, || -> Foo>\n-            283..300 'Lazy::...| Foo)': Lazy<Foo, || -> Foo>\n-            293..299 '|| Foo': || -> Foo\n+            261..266 'lazy1': Lazy<Foo, impl Fn() -> Foo>\n+            283..292 'Lazy::new': fn new<Foo, impl Fn() -> Foo>(impl Fn() -> Foo) -> Lazy<Foo, impl Fn() -> Foo>\n+            283..300 'Lazy::...| Foo)': Lazy<Foo, impl Fn() -> Foo>\n+            293..299 '|| Foo': impl Fn() -> Foo\n             296..299 'Foo': Foo\n             310..312 'r1': usize\n-            315..320 'lazy1': Lazy<Foo, || -> Foo>\n+            315..320 'lazy1': Lazy<Foo, impl Fn() -> Foo>\n             315..326 'lazy1.foo()': usize\n             368..383 'make_foo_fn_ptr': fn() -> Foo\n             399..410 'make_foo_fn': fn make_foo_fn() -> Foo\n@@ -1963,20 +1963,20 @@ fn test() {\n             163..167 '1u32': u32\n             174..175 'x': Option<u32>\n             174..190 'x.map(...v + 1)': Option<u32>\n-            180..189 '|v| v + 1': |u32| -> u32\n+            180..189 '|v| v + 1': impl Fn(u32) -> u32\n             181..182 'v': u32\n             184..185 'v': u32\n             184..189 'v + 1': u32\n             188..189 '1': u32\n             196..197 'x': Option<u32>\n             196..212 'x.map(... 1u64)': Option<u64>\n-            202..211 '|_v| 1u64': |u32| -> u64\n+            202..211 '|_v| 1u64': impl Fn(u32) -> u64\n             203..205 '_v': u32\n             207..211 '1u64': u64\n             222..223 'y': Option<i64>\n             239..240 'x': Option<u32>\n             239..252 'x.map(|_v| 1)': Option<i64>\n-            245..251 '|_v| 1': |u32| -> i64\n+            245..251 '|_v| 1': impl Fn(u32) -> i64\n             246..248 '_v': u32\n             250..251 '1': i64\n         \"#]],\n@@ -2005,11 +2005,11 @@ fn test<F: FnOnce(u32) -> u64>(f: F) {\n   //^^^^ u64\n     let g = |v| v + 1;\n               //^^^^^ u64\n-          //^^^^^^^^^ |u64| -> u64\n+          //^^^^^^^^^ impl Fn(u64) -> u64\n     g(1u64);\n   //^^^^^^^ u64\n     let h = |v| 1u128 + v;\n-          //^^^^^^^^^^^^^ |u128| -> u128\n+          //^^^^^^^^^^^^^ impl Fn(u128) -> u128\n }\"#,\n     );\n }\n@@ -2062,17 +2062,17 @@ fn test() {\n             312..314 '{}': ()\n             330..489 '{     ... S); }': ()\n             340..342 'x1': u64\n-            345..349 'foo1': fn foo1<S, u64, |S| -> u64>(S, |S| -> u64) -> u64\n+            345..349 'foo1': fn foo1<S, u64, impl Fn(S) -> u64>(S, impl Fn(S) -> u64) -> u64\n             345..368 'foo1(S...hod())': u64\n             350..351 'S': S\n-            353..367 '|s| s.method()': |S| -> u64\n+            353..367 '|s| s.method()': impl Fn(S) -> u64\n             354..355 's': S\n             357..358 's': S\n             357..367 's.method()': u64\n             378..380 'x2': u64\n-            383..387 'foo2': fn foo2<S, u64, |S| -> u64>(|S| -> u64, S) -> u64\n+            383..387 'foo2': fn foo2<S, u64, impl Fn(S) -> u64>(impl Fn(S) -> u64, S) -> u64\n             383..406 'foo2(|...(), S)': u64\n-            388..402 '|s| s.method()': |S| -> u64\n+            388..402 '|s| s.method()': impl Fn(S) -> u64\n             389..390 's': S\n             392..393 's': S\n             392..402 's.method()': u64\n@@ -2081,14 +2081,14 @@ fn test() {\n             421..422 'S': S\n             421..446 'S.foo1...hod())': u64\n             428..429 'S': S\n-            431..445 '|s| s.method()': |S| -> u64\n+            431..445 '|s| s.method()': impl Fn(S) -> u64\n             432..433 's': S\n             435..436 's': S\n             435..445 's.method()': u64\n             456..458 'x4': u64\n             461..462 'S': S\n             461..486 'S.foo2...(), S)': u64\n-            468..482 '|s| s.method()': |S| -> u64\n+            468..482 '|s| s.method()': impl Fn(S) -> u64\n             469..470 's': S\n             472..473 's': S\n             472..482 's.method()': u64\n@@ -2562,9 +2562,9 @@ fn main() {\n             72..74 '_v': F\n             117..120 '{ }': ()\n             132..163 '{     ... }); }': ()\n-            138..148 'f::<(), _>': fn f<(), |&()| -> ()>(|&()| -> ())\n+            138..148 'f::<(), _>': fn f<(), impl Fn(&())>(impl Fn(&()))\n             138..160 'f::<()... z; })': ()\n-            149..159 '|z| { z; }': |&()| -> ()\n+            149..159 '|z| { z; }': impl Fn(&())\n             150..151 'z': &()\n             153..159 '{ z; }': ()\n             155..156 'z': &()\n@@ -2721,9 +2721,9 @@ fn main() {\n             983..998 'Vec::<i32>::new': fn new<i32>() -> Vec<i32>\n             983..1000 'Vec::<...:new()': Vec<i32>\n             983..1012 'Vec::<...iter()': IntoIter<i32>\n-            983..1075 'Vec::<...one })': FilterMap<IntoIter<i32>, |i32| -> Option<u32>>\n+            983..1075 'Vec::<...one })': FilterMap<IntoIter<i32>, impl Fn(i32) -> Option<u32>>\n             983..1101 'Vec::<... y; })': ()\n-            1029..1074 '|x| if...None }': |i32| -> Option<u32>\n+            1029..1074 '|x| if...None }': impl Fn(i32) -> Option<u32>\n             1030..1031 'x': i32\n             1033..1074 'if x >...None }': Option<u32>\n             1036..1037 'x': i32\n@@ -2736,7 +2736,7 @@ fn main() {\n             1049..1057 'x as u32': u32\n             1066..1074 '{ None }': Option<u32>\n             1068..1072 'None': Option<u32>\n-            1090..1100 '|y| { y; }': |u32| -> ()\n+            1090..1100 '|y| { y; }': impl Fn(u32)\n             1091..1092 'y': u32\n             1094..1100 '{ y; }': ()\n             1096..1097 'y': u32\n@@ -2979,13 +2979,13 @@ fn foo() {\n             52..126 '{     ...)(s) }': ()\n             62..63 's': Option<i32>\n             66..78 'Option::None': Option<i32>\n-            88..89 'f': |Option<i32>| -> ()\n-            92..111 '|x: Op...2>| {}': |Option<i32>| -> ()\n+            88..89 'f': impl Fn(Option<i32>)\n+            92..111 '|x: Op...2>| {}': impl Fn(Option<i32>)\n             93..94 'x': Option<i32>\n             109..111 '{}': ()\n             117..124 '(&f)(s)': ()\n-            118..120 '&f': &|Option<i32>| -> ()\n-            119..120 'f': |Option<i32>| -> ()\n+            118..120 '&f': &impl Fn(Option<i32>)\n+            119..120 'f': impl Fn(Option<i32>)\n             122..123 's': Option<i32>\n         \"#]],\n     );\n@@ -3072,15 +3072,15 @@ fn foo() {\n             228..229 's': Option<i32>\n             232..236 'None': Option<i32>\n             246..247 'f': Box<dyn FnOnce(&Option<i32>)>\n-            281..294 'box (|ps| {})': Box<|&Option<i32>| -> ()>\n-            286..293 '|ps| {}': |&Option<i32>| -> ()\n+            281..294 'box (|ps| {})': Box<impl Fn(&Option<i32>)>\n+            286..293 '|ps| {}': impl Fn(&Option<i32>)\n             287..289 'ps': &Option<i32>\n             291..293 '{}': ()\n             300..301 'f': Box<dyn FnOnce(&Option<i32>)>\n             300..305 'f(&s)': ()\n             302..304 '&s': &Option<i32>\n             303..304 's': Option<i32>\n-            281..294: expected Box<dyn FnOnce(&Option<i32>)>, got Box<|&Option<i32>| -> ()>\n+            281..294: expected Box<dyn FnOnce(&Option<i32>)>, got Box<impl Fn(&Option<i32>)>\n         \"#]],\n     );\n }\n@@ -3811,6 +3811,35 @@ fn f() {\n     );\n }\n \n+#[test]\n+fn regression_14443_trait_solve() {\n+    check_no_mismatches(\n+        r#\"\n+trait T {\n+    fn f(&self) {}\n+}\n+\n+\n+fn main() {\n+    struct A;\n+    impl T for A {}\n+\n+    let a = A;\n+\n+    let b = {\n+        struct B;\n+        impl T for B {}\n+\n+        B\n+    };\n+\n+    a.f();\n+    b.f();\n+}\n+\"#,\n+    )\n+}\n+\n #[test]\n fn associated_type_sized_bounds() {\n     check_infer(\n@@ -4286,3 +4315,63 @@ impl Trait for () {\n     \"#,\n     );\n }\n+\n+#[test]\n+fn derive_macro_bounds() {\n+    check_types(\n+        r#\"\n+        //- minicore: clone, derive\n+        #[derive(Clone)]\n+        struct Copy;\n+        struct NotCopy;\n+        #[derive(Clone)]\n+        struct Generic<T>(T);\n+        trait Tr {\n+            type Assoc;\n+        }\n+        impl Tr for Copy {\n+            type Assoc = NotCopy;\n+        }\n+        #[derive(Clone)]\n+        struct AssocGeneric<T: Tr>(T::Assoc);\n+\n+        #[derive(Clone)]\n+        struct AssocGeneric2<T: Tr>(<T as Tr>::Assoc);\n+\n+        #[derive(Clone)]\n+        struct AssocGeneric3<T: Tr>(Generic<T::Assoc>);\n+\n+        #[derive(Clone)]\n+        struct Vec<T>();\n+\n+        #[derive(Clone)]\n+        struct R1(Vec<R2>);\n+        #[derive(Clone)]\n+        struct R2(R1);\n+\n+        fn f() {\n+            let x = (&Copy).clone();\n+              //^ Copy\n+            let x = (&NotCopy).clone();\n+              //^ &NotCopy\n+            let x = (&Generic(Copy)).clone();\n+              //^ Generic<Copy>\n+            let x = (&Generic(NotCopy)).clone();\n+              //^ &Generic<NotCopy>\n+            let x: &AssocGeneric<Copy> = &AssocGeneric(NotCopy);\n+            let x = x.clone();\n+              //^ &AssocGeneric<Copy>\n+            let x: &AssocGeneric2<Copy> = &AssocGeneric2(NotCopy);\n+            let x = x.clone();\n+              //^ &AssocGeneric2<Copy>\n+            let x: &AssocGeneric3<Copy> = &AssocGeneric3(Generic(NotCopy));\n+            let x = x.clone();\n+              //^ &AssocGeneric3<Copy>\n+            let x = (&R1(Vec())).clone();\n+              //^ R1\n+            let x = (&R2(R1(Vec()))).clone();\n+              //^ R2\n+        }\n+        \"#,\n+    );\n+}"}, {"sha": "8bc38aca4722b459854378253675a54e5388e796", "filename": "crates/hir-ty/src/traits.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -4,7 +4,7 @@ use std::{env::var, sync::Arc};\n \n use chalk_ir::GoalData;\n use chalk_recursive::Cache;\n-use chalk_solve::{logging_db::LoggingRustIrDatabase, Solver};\n+use chalk_solve::{logging_db::LoggingRustIrDatabase, rust_ir, Solver};\n \n use base_db::CrateId;\n use hir_def::{\n@@ -177,8 +177,10 @@ fn is_chalk_print() -> bool {\n     std::env::var(\"CHALK_PRINT\").is_ok()\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\n pub enum FnTrait {\n+    // Warning: Order is important. If something implements `x` it should also implement\n+    // `y` if `y <= x`.\n     FnOnce,\n     FnMut,\n     Fn,\n@@ -193,6 +195,14 @@ impl FnTrait {\n         }\n     }\n \n+    pub const fn to_chalk_ir(self) -> rust_ir::ClosureKind {\n+        match self {\n+            FnTrait::FnOnce => rust_ir::ClosureKind::FnOnce,\n+            FnTrait::FnMut => rust_ir::ClosureKind::FnMut,\n+            FnTrait::Fn => rust_ir::ClosureKind::Fn,\n+        }\n+    }\n+\n     pub fn method_name(self) -> Name {\n         match self {\n             FnTrait::FnOnce => name!(call_once),"}, {"sha": "3b2a726688d01a2f56999d7b94c29acf03071db5", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -4,14 +4,15 @@\n use std::iter;\n \n use base_db::CrateId;\n-use chalk_ir::{cast::Cast, fold::Shift, BoundVar, DebruijnIndex};\n+use chalk_ir::{cast::Cast, fold::Shift, BoundVar, DebruijnIndex, Mutability};\n use either::Either;\n use hir_def::{\n     db::DefDatabase,\n     generics::{\n         GenericParams, TypeOrConstParamData, TypeParamProvenance, WherePredicate,\n         WherePredicateTypeTarget,\n     },\n+    hir::BindingAnnotation,\n     lang_item::LangItem,\n     resolver::{HasResolver, TypeNs},\n     type_ref::{TraitBoundModifier, TypeRef},\n@@ -24,7 +25,8 @@ use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};\n \n use crate::{\n-    db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, WhereClause,\n+    db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, Ty, TyExt,\n+    WhereClause,\n };\n \n pub(crate) fn fn_traits(\n@@ -352,3 +354,20 @@ pub fn is_fn_unsafe_to_call(db: &dyn HirDatabase, func: FunctionId) -> bool {\n         _ => false,\n     }\n }\n+\n+pub(crate) fn pattern_matching_dereference_count(\n+    cond_ty: &mut Ty,\n+    binding_mode: &mut BindingAnnotation,\n+) -> usize {\n+    let mut r = 0;\n+    while let Some((ty, _, mu)) = cond_ty.as_reference() {\n+        if mu == Mutability::Mut && *binding_mode != BindingAnnotation::Ref {\n+            *binding_mode = BindingAnnotation::RefMut;\n+        } else {\n+            *binding_mode = BindingAnnotation::Ref;\n+        }\n+        *cond_ty = ty.clone();\n+        r += 1;\n+    }\n+    r\n+}"}, {"sha": "f756832f0ff825f05b9df8567ddfbea9fa3664de", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -50,7 +50,9 @@ diagnostics![\n     PrivateField,\n     ReplaceFilterMapNextWithFindMap,\n     TypeMismatch,\n+    UndeclaredLabel,\n     UnimplementedBuiltinMacro,\n+    UnreachableLabel,\n     UnresolvedExternCrate,\n     UnresolvedField,\n     UnresolvedImport,\n@@ -61,6 +63,13 @@ diagnostics![\n     UnusedMut,\n ];\n \n+#[derive(Debug)]\n+pub struct BreakOutsideOfLoop {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub is_break: bool,\n+    pub bad_value_break: bool,\n+}\n+\n #[derive(Debug)]\n pub struct UnresolvedModule {\n     pub decl: InFile<AstPtr<ast::Module>>,\n@@ -84,6 +93,17 @@ pub struct UnresolvedMacroCall {\n     pub path: ModPath,\n     pub is_bang: bool,\n }\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct UnreachableLabel {\n+    pub node: InFile<AstPtr<ast::Lifetime>>,\n+    pub name: Name,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct UndeclaredLabel {\n+    pub node: InFile<AstPtr<ast::Lifetime>>,\n+    pub name: Name,\n+}\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct InactiveCode {\n@@ -166,13 +186,6 @@ pub struct PrivateField {\n     pub field: Field,\n }\n \n-#[derive(Debug)]\n-pub struct BreakOutsideOfLoop {\n-    pub expr: InFile<AstPtr<ast::Expr>>,\n-    pub is_break: bool,\n-    pub bad_value_break: bool,\n-}\n-\n #[derive(Debug)]\n pub struct MissingUnsafe {\n     pub expr: InFile<AstPtr<ast::Expr>>,"}, {"sha": "49165ca70ec454cb6ef30dca8e0077d527e2e610", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,13 +1,14 @@\n //! HirDisplay implementations for various hir types.\n use hir_def::{\n-    adt::VariantData,\n+    data::adt::VariantData,\n     generics::{\n         TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n     },\n     lang_item::LangItem,\n     type_ref::{TypeBound, TypeRef},\n     AdtId, GenericDefId,\n };\n+use hir_expand::name;\n use hir_ty::{\n     display::{\n         write_bounds_like_dyn_trait_with_prefix, write_visibility, HirDisplay, HirDisplayError,\n@@ -76,22 +77,22 @@ impl HirDisplay for Function {\n         };\n \n         let mut first = true;\n-        for (name, type_ref) in &data.params {\n+        // FIXME: Use resolved `param.ty` once we no longer discard lifetimes\n+        for (type_ref, param) in data.params.iter().zip(self.assoc_fn_params(db)) {\n+            let local = param.as_local(db).map(|it| it.name(db));\n             if !first {\n                 f.write_str(\", \")?;\n             } else {\n                 first = false;\n-                if data.has_self_param() {\n+                if local == Some(name!(self)) {\n                     write_self_param(type_ref, f)?;\n                     continue;\n                 }\n             }\n-            match name {\n+            match local {\n                 Some(name) => write!(f, \"{name}: \")?,\n                 None => f.write_str(\"_: \")?,\n             }\n-            // FIXME: Use resolved `param.ty` or raw `type_ref`?\n-            // The former will ignore lifetime arguments currently.\n             type_ref.hir_fmt(f)?;\n         }\n "}, {"sha": "883e6a29b06a64bc1225210e03e21aae83b2e7f4", "filename": "crates/hir/src/from_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Ffrom_id.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -4,7 +4,7 @@\n //! are splitting the hir.\n \n use hir_def::{\n-    expr::{BindingId, LabelId},\n+    hir::{BindingId, LabelId},\n     AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, GenericDefId, GenericParamId,\n     ModuleDefId, VariantId,\n };"}, {"sha": "db923cb0fe23337c3464e5cc651813f5a9e215aa", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 72, "deletions": 54, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -39,10 +39,10 @@ use arrayvec::ArrayVec;\n use base_db::{CrateDisplayName, CrateId, CrateOrigin, Edition, FileId, ProcMacroKind};\n use either::Either;\n use hir_def::{\n-    adt::VariantData,\n     body::{BodyDiagnostic, SyntheticSyntax},\n-    expr::{BindingAnnotation, BindingId, ExprOrPatId, LabelId, Pat},\n+    data::adt::VariantData,\n     generics::{LifetimeParamData, TypeOrConstParamData, TypeParamProvenance},\n+    hir::{BindingAnnotation, BindingId, ExprOrPatId, LabelId, Pat},\n     item_tree::ItemTreeNode,\n     lang_item::{LangItem, LangItemTarget},\n     layout::{Layout, LayoutError, ReprOptions},\n@@ -88,9 +88,10 @@ pub use crate::{\n         AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncoherentImpl,\n         IncorrectCase, InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount,\n         MissingFields, MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem,\n-        PrivateField, ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n-        UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n-        UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro, UnusedMut,\n+        PrivateField, ReplaceFilterMapNextWithFindMap, TypeMismatch, UndeclaredLabel,\n+        UnimplementedBuiltinMacro, UnreachableLabel, UnresolvedExternCrate, UnresolvedField,\n+        UnresolvedImport, UnresolvedMacroCall, UnresolvedMethodCall, UnresolvedModule,\n+        UnresolvedProcMacro, UnusedMut,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -108,9 +109,8 @@ pub use crate::{\n pub use {\n     cfg::{CfgAtom, CfgExpr, CfgOptions},\n     hir_def::{\n-        adt::StructKind,\n-        attr::{Attrs, AttrsWithOwner, Documentation},\n-        builtin_attr::AttributeTemplate,\n+        attr::{builtin::AttributeTemplate, Attrs, AttrsWithOwner, Documentation},\n+        data::adt::StructKind,\n         find_path::PrefixKind,\n         import_map,\n         nameres::ModuleSource,\n@@ -129,7 +129,7 @@ pub use {\n         ExpandResult, HirFileId, InFile, MacroFile, Origin,\n     },\n     hir_ty::{\n-        display::{HirDisplay, HirDisplayError, HirWrite},\n+        display::{ClosureStyle, HirDisplay, HirDisplayError, HirWrite},\n         mir::MirEvalError,\n         PointerCast, Safety,\n     },\n@@ -1393,6 +1393,12 @@ impl DefWithBody {\n                     }\n                     .into(),\n                 ),\n+                BodyDiagnostic::UnreachableLabel { node, name } => {\n+                    acc.push(UnreachableLabel { node: node.clone(), name: name.clone() }.into())\n+                }\n+                BodyDiagnostic::UndeclaredLabel { node, name } => {\n+                    acc.push(UndeclaredLabel { node: node.clone(), name: name.clone() }.into())\n+                }\n             }\n         }\n \n@@ -1405,14 +1411,6 @@ impl DefWithBody {\n                     let field = source_map.field_syntax(expr);\n                     acc.push(NoSuchField { field }.into())\n                 }\n-                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop {\n-                    expr,\n-                    is_break,\n-                    bad_value_break,\n-                } => {\n-                    let expr = expr_syntax(expr);\n-                    acc.push(BreakOutsideOfLoop { expr, is_break, bad_value_break }.into())\n-                }\n                 &hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n                     acc.push(\n                         MismatchedArgCount { call_expr: expr_syntax(call_expr), expected, found }\n@@ -1484,6 +1482,14 @@ impl DefWithBody {\n                         .into(),\n                     )\n                 }\n+                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop {\n+                    expr,\n+                    is_break,\n+                    bad_value_break,\n+                } => {\n+                    let expr = expr_syntax(expr);\n+                    acc.push(BreakOutsideOfLoop { expr, is_break, bad_value_break }.into())\n+                }\n             }\n         }\n         for (pat_or_expr, mismatch) in infer.type_mismatches() {\n@@ -1524,35 +1530,44 @@ impl DefWithBody {\n \n         let hir_body = db.body(self.into());\n \n-        if let Ok(borrowck_result) = db.borrowck(self.into()) {\n-            let mir_body = &borrowck_result.mir_body;\n-            let mol = &borrowck_result.mutability_of_locals;\n-            for (binding_id, _) in hir_body.bindings.iter() {\n-                let need_mut = &mol[mir_body.binding_locals[binding_id]];\n-                let local = Local { parent: self.into(), binding_id };\n-                match (need_mut, local.is_mut(db)) {\n-                    (mir::MutabilityReason::Mut { .. }, true)\n-                    | (mir::MutabilityReason::Not, false) => (),\n-                    (mir::MutabilityReason::Mut { spans }, false) => {\n-                        for span in spans {\n-                            let span: InFile<SyntaxNodePtr> = match span {\n-                                mir::MirSpan::ExprId(e) => match source_map.expr_syntax(*e) {\n-                                    Ok(s) => s.map(|x| x.into()),\n-                                    Err(_) => continue,\n-                                },\n-                                mir::MirSpan::PatId(p) => match source_map.pat_syntax(*p) {\n-                                    Ok(s) => s.map(|x| match x {\n-                                        Either::Left(e) => e.into(),\n-                                        Either::Right(e) => e.into(),\n-                                    }),\n-                                    Err(_) => continue,\n-                                },\n-                                mir::MirSpan::Unknown => continue,\n-                            };\n-                            acc.push(NeedMut { local, span }.into());\n+        if let Ok(borrowck_results) = db.borrowck(self.into()) {\n+            for borrowck_result in borrowck_results.iter() {\n+                let mir_body = &borrowck_result.mir_body;\n+                let mol = &borrowck_result.mutability_of_locals;\n+                for (binding_id, _) in hir_body.bindings.iter() {\n+                    let Some(&local) = mir_body.binding_locals.get(binding_id) else {\n+                        continue;\n+                    };\n+                    let need_mut = &mol[local];\n+                    let local = Local { parent: self.into(), binding_id };\n+                    match (need_mut, local.is_mut(db)) {\n+                        (mir::MutabilityReason::Mut { .. }, true)\n+                        | (mir::MutabilityReason::Not, false) => (),\n+                        (mir::MutabilityReason::Mut { spans }, false) => {\n+                            for span in spans {\n+                                let span: InFile<SyntaxNodePtr> = match span {\n+                                    mir::MirSpan::ExprId(e) => match source_map.expr_syntax(*e) {\n+                                        Ok(s) => s.map(|x| x.into()),\n+                                        Err(_) => continue,\n+                                    },\n+                                    mir::MirSpan::PatId(p) => match source_map.pat_syntax(*p) {\n+                                        Ok(s) => s.map(|x| match x {\n+                                            Either::Left(e) => e.into(),\n+                                            Either::Right(e) => e.into(),\n+                                        }),\n+                                        Err(_) => continue,\n+                                    },\n+                                    mir::MirSpan::Unknown => continue,\n+                                };\n+                                acc.push(NeedMut { local, span }.into());\n+                            }\n+                        }\n+                        (mir::MutabilityReason::Not, true) => {\n+                            if !infer.mutated_bindings_in_closure.contains(&binding_id) {\n+                                acc.push(UnusedMut { local }.into())\n+                            }\n                         }\n                     }\n-                    (mir::MutabilityReason::Not, true) => acc.push(UnusedMut { local }.into()),\n                 }\n             }\n         }\n@@ -1838,7 +1853,7 @@ impl Param {\n     }\n \n     pub fn name(&self, db: &dyn HirDatabase) -> Option<Name> {\n-        db.function_data(self.func.id).params[self.idx].0.clone()\n+        Some(self.as_local(db)?.name(db))\n     }\n \n     pub fn as_local(&self, db: &dyn HirDatabase) -> Option<Local> {\n@@ -1879,7 +1894,7 @@ impl SelfParam {\n         func_data\n             .params\n             .first()\n-            .map(|(_, param)| match &**param {\n+            .map(|param| match &**param {\n                 TypeRef::Reference(.., mutability) => match mutability {\n                     hir_def::type_ref::Mutability::Shared => Access::Shared,\n                     hir_def::type_ref::Mutability::Mut => Access::Exclusive,\n@@ -2690,24 +2705,22 @@ impl BuiltinAttr {\n     }\n \n     fn builtin(name: &str) -> Option<Self> {\n-        hir_def::builtin_attr::INERT_ATTRIBUTES\n-            .iter()\n-            .position(|tool| tool.name == name)\n+        hir_def::attr::builtin::find_builtin_attr_idx(name)\n             .map(|idx| BuiltinAttr { krate: None, idx: idx as u32 })\n     }\n \n     pub fn name(&self, db: &dyn HirDatabase) -> SmolStr {\n         // FIXME: Return a `Name` here\n         match self.krate {\n             Some(krate) => db.crate_def_map(krate).registered_attrs()[self.idx as usize].clone(),\n-            None => SmolStr::new(hir_def::builtin_attr::INERT_ATTRIBUTES[self.idx as usize].name),\n+            None => SmolStr::new(hir_def::attr::builtin::INERT_ATTRIBUTES[self.idx as usize].name),\n         }\n     }\n \n     pub fn template(&self, _: &dyn HirDatabase) -> Option<AttributeTemplate> {\n         match self.krate {\n             Some(_) => None,\n-            None => Some(hir_def::builtin_attr::INERT_ATTRIBUTES[self.idx as usize].template),\n+            None => Some(hir_def::attr::builtin::INERT_ATTRIBUTES[self.idx as usize].template),\n         }\n     }\n }\n@@ -2730,7 +2743,7 @@ impl ToolModule {\n     }\n \n     fn builtin(name: &str) -> Option<Self> {\n-        hir_def::builtin_attr::TOOL_MODULES\n+        hir_def::attr::builtin::TOOL_MODULES\n             .iter()\n             .position(|&tool| tool == name)\n             .map(|idx| ToolModule { krate: None, idx: idx as u32 })\n@@ -2740,7 +2753,7 @@ impl ToolModule {\n         // FIXME: Return a `Name` here\n         match self.krate {\n             Some(krate) => db.crate_def_map(krate).registered_tools()[self.idx as usize].clone(),\n-            None => SmolStr::new(hir_def::builtin_attr::TOOL_MODULES[self.idx as usize]),\n+            None => SmolStr::new(hir_def::attr::builtin::TOOL_MODULES[self.idx as usize]),\n         }\n     }\n }\n@@ -3379,7 +3392,12 @@ impl Type {\n     }\n \n     pub fn as_callable(&self, db: &dyn HirDatabase) -> Option<Callable> {\n+        let mut the_ty = &self.ty;\n         let callee = match self.ty.kind(Interner) {\n+            TyKind::Ref(_, _, ty) if ty.as_closure().is_some() => {\n+                the_ty = ty;\n+                Callee::Closure(ty.as_closure().unwrap())\n+            }\n             TyKind::Closure(id, _) => Callee::Closure(*id),\n             TyKind::Function(_) => Callee::FnPtr,\n             TyKind::FnDef(..) => Callee::Def(self.ty.callable_def(db)?),\n@@ -3394,7 +3412,7 @@ impl Type {\n             }\n         };\n \n-        let sig = self.ty.callable_sig(db)?;\n+        let sig = the_ty.callable_sig(db)?;\n         Some(Callable { ty: self.clone(), sig, callee, is_bound_method: false })\n     }\n "}, {"sha": "ffd0b0ad7adc41d24a782e0f0327999756615946", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -8,7 +8,7 @@ use base_db::{FileId, FileRange};\n use either::Either;\n use hir_def::{\n     body,\n-    expr::Expr,\n+    hir::Expr,\n     macro_id_to_def_id,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n     type_ref::Mutability,\n@@ -1065,7 +1065,7 @@ impl<'db> SemanticsImpl<'db> {\n \n     fn resolve_type(&self, ty: &ast::Type) -> Option<Type> {\n         let analyze = self.analyze(ty.syntax())?;\n-        let ctx = body::LowerCtx::new(self.db.upcast(), analyze.file_id);\n+        let ctx = body::LowerCtx::with_file_id(self.db.upcast(), analyze.file_id);\n         let ty = hir_ty::TyLoweringContext::new(self.db, &analyze.resolver)\n             .lower_ty(&crate::TypeRef::from_ast(&ctx, ty.clone()));\n         Some(Type::new_with_resolver(self.db, &analyze.resolver, ty))\n@@ -1672,7 +1672,7 @@ impl<'a> SemanticsScope<'a> {\n     /// Resolve a path as-if it was written at the given scope. This is\n     /// necessary a heuristic, as it doesn't take hygiene into account.\n     pub fn speculative_resolve(&self, path: &ast::Path) -> Option<PathResolution> {\n-        let ctx = body::LowerCtx::new(self.db.upcast(), self.file_id);\n+        let ctx = body::LowerCtx::with_file_id(self.db.upcast(), self.file_id);\n         let path = Path::from_src(path.clone(), &ctx)?;\n         resolve_hir_path(self.db, &self.resolver, &path)\n     }"}, {"sha": "c50ffa4f8b70349d6252c0f4a55c32f501d3a4b3", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -14,7 +14,7 @@\n //! expression, an item definition.\n //!\n //! Knowing only the syntax gives us relatively little info. For example,\n-//! looking at the syntax of the function we can realise that it is a part of an\n+//! looking at the syntax of the function we can realize that it is a part of an\n //! `impl` block, but we won't be able to tell what trait function the current\n //! function overrides, and whether it does that correctly. For that, we need to\n //! go from [`ast::Fn`] to [`crate::Function`], and that's exactly what this\n@@ -88,9 +88,11 @@\n use base_db::FileId;\n use hir_def::{\n     child_by_source::ChildBySource,\n-    dyn_map::DynMap,\n-    expr::{BindingId, LabelId},\n-    keys::{self, Key},\n+    dyn_map::{\n+        keys::{self, Key},\n+        DynMap,\n+    },\n+    hir::{BindingId, LabelId},\n     AdtId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, FieldId, FunctionId,\n     GenericDefId, GenericParamId, ImplId, LifetimeParamId, MacroId, ModuleId, StaticId, StructId,\n     TraitAliasId, TraitId, TypeAliasId, TypeParamId, UnionId, VariantId,"}, {"sha": "2a7a0ae4c43c7a27ec9a4f7bc4898c64689dee2d", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -17,7 +17,7 @@ use hir_def::{\n         scope::{ExprScopes, ScopeId},\n         Body, BodySourceMap,\n     },\n-    expr::{ExprId, Pat, PatId},\n+    hir::{ExprId, Pat, PatId},\n     lang_item::LangItem,\n     macro_id_to_def_id,\n     path::{ModPath, Path, PathKind},\n@@ -463,7 +463,7 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         macro_call: InFile<&ast::MacroCall>,\n     ) -> Option<Macro> {\n-        let ctx = body::LowerCtx::new(db.upcast(), macro_call.file_id);\n+        let ctx = body::LowerCtx::with_file_id(db.upcast(), macro_call.file_id);\n         let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &ctx))?;\n         self.resolver.resolve_path_as_macro(db.upcast(), path.mod_path()?).map(|it| it.into())\n     }"}, {"sha": "399f87c8f509dd7d177316e3b4b8f3f670b62825", "filename": "crates/ide-assists/src/handlers/convert_nested_function_to_closure.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_nested_function_to_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_nested_function_to_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_nested_function_to_closure.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -0,0 +1,209 @@\n+use ide_db::assists::{AssistId, AssistKind};\n+use syntax::ast::{self, HasGenericParams, HasName};\n+use syntax::{AstNode, SyntaxKind};\n+\n+use crate::assist_context::{AssistContext, Assists};\n+\n+// Assist: convert_nested_function_to_closure\n+//\n+// Converts a function that is defined within the body of another function into a closure.\n+//\n+// ```\n+// fn main() {\n+//     fn fo$0o(label: &str, number: u64) {\n+//         println!(\"{}: {}\", label, number);\n+//     }\n+//\n+//     foo(\"Bar\", 100);\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let foo = |label: &str, number: u64| {\n+//         println!(\"{}: {}\", label, number);\n+//     };\n+//\n+//     foo(\"Bar\", 100);\n+// }\n+// ```\n+pub(crate) fn convert_nested_function_to_closure(\n+    acc: &mut Assists,\n+    ctx: &AssistContext<'_>,\n+) -> Option<()> {\n+    let name = ctx.find_node_at_offset::<ast::Name>()?;\n+    let function = name.syntax().parent().and_then(ast::Fn::cast)?;\n+\n+    if !is_nested_function(&function) || is_generic(&function) || has_modifiers(&function) {\n+        return None;\n+    }\n+\n+    let target = function.syntax().text_range();\n+    let body = function.body()?;\n+    let name = function.name()?;\n+    let param_list = function.param_list()?;\n+\n+    acc.add(\n+        AssistId(\"convert_nested_function_to_closure\", AssistKind::RefactorRewrite),\n+        \"Convert nested function to closure\",\n+        target,\n+        |edit| {\n+            let params = &param_list.syntax().text().to_string();\n+            let params = params.strip_prefix(\"(\").unwrap_or(params);\n+            let params = params.strip_suffix(\")\").unwrap_or(params);\n+\n+            let mut body = body.to_string();\n+            if !has_semicolon(&function) {\n+                body.push(';');\n+            }\n+            edit.replace(target, format!(\"let {name} = |{params}| {body}\"));\n+        },\n+    )\n+}\n+\n+/// Returns whether the given function is nested within the body of another function.\n+fn is_nested_function(function: &ast::Fn) -> bool {\n+    function.syntax().ancestors().skip(1).find_map(ast::Item::cast).map_or(false, |it| {\n+        matches!(it, ast::Item::Fn(_) | ast::Item::Static(_) | ast::Item::Const(_))\n+    })\n+}\n+\n+/// Returns whether the given nested function has generic parameters.\n+fn is_generic(function: &ast::Fn) -> bool {\n+    function.generic_param_list().is_some()\n+}\n+\n+/// Returns whether the given nested function has any modifiers:\n+///\n+/// - `async`,\n+/// - `const` or\n+/// - `unsafe`\n+fn has_modifiers(function: &ast::Fn) -> bool {\n+    function.async_token().is_some()\n+        || function.const_token().is_some()\n+        || function.unsafe_token().is_some()\n+}\n+\n+/// Returns whether the given nested function has a trailing semicolon.\n+fn has_semicolon(function: &ast::Fn) -> bool {\n+    function\n+        .syntax()\n+        .next_sibling_or_token()\n+        .map(|t| t.kind() == SyntaxKind::SEMICOLON)\n+        .unwrap_or(false)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::convert_nested_function_to_closure;\n+\n+    #[test]\n+    fn convert_nested_function_to_closure_works() {\n+        check_assist(\n+            convert_nested_function_to_closure,\n+            r#\"\n+fn main() {\n+    fn $0foo(a: u64, b: u64) -> u64 {\n+        2 * (a + b)\n+    }\n+\n+    _ = foo(3, 4);\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let foo = |a: u64, b: u64| {\n+        2 * (a + b)\n+    };\n+\n+    _ = foo(3, 4);\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_nested_function_to_closure_works_with_existing_semicolon() {\n+        check_assist(\n+            convert_nested_function_to_closure,\n+            r#\"\n+fn main() {\n+    fn foo$0(a: u64, b: u64) -> u64 {\n+        2 * (a + b)\n+    };\n+\n+    _ = foo(3, 4);\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let foo = |a: u64, b: u64| {\n+        2 * (a + b)\n+    };\n+\n+    _ = foo(3, 4);\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_nested_function_to_closure_is_not_suggested_on_top_level_function() {\n+        check_assist_not_applicable(\n+            convert_nested_function_to_closure,\n+            r#\"\n+fn ma$0in() {}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_nested_function_to_closure_is_not_suggested_when_cursor_off_name() {\n+        check_assist_not_applicable(\n+            convert_nested_function_to_closure,\n+            r#\"\n+fn main() {\n+    fn foo(a: u64, $0b: u64) -> u64 {\n+        2 * (a + b)\n+    }\n+\n+    _ = foo(3, 4);\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_nested_function_to_closure_is_not_suggested_if_function_has_generic_params() {\n+        check_assist_not_applicable(\n+            convert_nested_function_to_closure,\n+            r#\"\n+fn main() {\n+    fn fo$0o<S: Into<String>>(s: S) -> String {\n+        s.into()\n+    }\n+\n+    _ = foo(\"hello\");\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_nested_function_to_closure_is_not_suggested_if_function_has_modifier() {\n+        check_assist_not_applicable(\n+            convert_nested_function_to_closure,\n+            r#\"\n+fn main() {\n+    const fn fo$0o(s: String) -> String {\n+        s\n+    }\n+\n+    _ = foo(\"hello\");\n+}\n+            \"#,\n+        );\n+    }\n+}"}, {"sha": "bfa2890676beafa0636038c3a2a8be8fa5b2aa6c", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -70,6 +70,11 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n     }\n \n     let node = ctx.covering_element();\n+    if matches!(node.kind(), T!['{'] | T!['}'] | T!['('] | T![')'] | T!['['] | T![']']) {\n+        cov_mark::hit!(extract_function_in_braces_is_not_applicable);\n+        return None;\n+    }\n+\n     if node.kind() == COMMENT {\n         cov_mark::hit!(extract_function_in_comment_is_not_applicable);\n         return None;\n@@ -5800,4 +5805,40 @@ fn $0fun_name() -> ControlFlow<()> {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn in_left_curly_is_not_applicable() {\n+        cov_mark::check!(extract_function_in_braces_is_not_applicable);\n+        check_assist_not_applicable(extract_function, r\"fn foo() { $0}$0\");\n+    }\n+\n+    #[test]\n+    fn in_right_curly_is_not_applicable() {\n+        cov_mark::check!(extract_function_in_braces_is_not_applicable);\n+        check_assist_not_applicable(extract_function, r\"fn foo() $0{$0 }\");\n+    }\n+\n+    #[test]\n+    fn in_left_paren_is_not_applicable() {\n+        cov_mark::check!(extract_function_in_braces_is_not_applicable);\n+        check_assist_not_applicable(extract_function, r\"fn foo( $0)$0 { }\");\n+    }\n+\n+    #[test]\n+    fn in_right_paren_is_not_applicable() {\n+        cov_mark::check!(extract_function_in_braces_is_not_applicable);\n+        check_assist_not_applicable(extract_function, r\"fn foo $0($0 ) { }\");\n+    }\n+\n+    #[test]\n+    fn in_left_brack_is_not_applicable() {\n+        cov_mark::check!(extract_function_in_braces_is_not_applicable);\n+        check_assist_not_applicable(extract_function, r\"fn foo(arr: &mut [i32$0]$0) {}\");\n+    }\n+\n+    #[test]\n+    fn in_right_brack_is_not_applicable() {\n+        cov_mark::check!(extract_function_in_braces_is_not_applicable);\n+        check_assist_not_applicable(extract_function, r\"fn foo(arr: &mut $0[$0i32]) {}\");\n+    }\n }"}, {"sha": "014c23197face98e68e03c32ec31aa835290bde6", "filename": "crates/ide-assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,3 +1,4 @@\n+use hir::TypeInfo;\n use stdx::format_to;\n use syntax::{\n     ast::{self, AstNode},\n@@ -46,21 +47,24 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n         .take_while(|it| ctx.selection_trimmed().contains_range(it.text_range()))\n         .find_map(valid_target_expr)?;\n \n-    if let Some(ty_info) = ctx.sema.type_of_expr(&to_extract) {\n-        if ty_info.adjusted().is_unit() {\n-            return None;\n-        }\n+    let ty = ctx.sema.type_of_expr(&to_extract).map(TypeInfo::adjusted);\n+    if matches!(&ty, Some(ty_info) if ty_info.is_unit()) {\n+        return None;\n     }\n \n-    let reference_modifier = match get_receiver_type(ctx, &to_extract) {\n+    let parent = to_extract.syntax().parent().and_then(ast::Expr::cast);\n+    let needs_adjust = parent\n+        .as_ref()\n+        .map_or(false, |it| matches!(it, ast::Expr::FieldExpr(_) | ast::Expr::MethodCallExpr(_)));\n+\n+    let reference_modifier = match ty.filter(|_| needs_adjust) {\n         Some(receiver_type) if receiver_type.is_mutable_reference() => \"&mut \",\n         Some(receiver_type) if receiver_type.is_reference() => \"&\",\n         _ => \"\",\n     };\n \n-    let parent_ref_expr = to_extract.syntax().parent().and_then(ast::RefExpr::cast);\n-    let var_modifier = match parent_ref_expr {\n-        Some(expr) if expr.mut_token().is_some() => \"mut \",\n+    let var_modifier = match parent {\n+        Some(ast::Expr::RefExpr(expr)) if expr.mut_token().is_some() => \"mut \",\n         _ => \"\",\n     };\n \n@@ -164,22 +168,6 @@ fn valid_target_expr(node: SyntaxNode) -> Option<ast::Expr> {\n     }\n }\n \n-fn get_receiver_type(ctx: &AssistContext<'_>, expression: &ast::Expr) -> Option<hir::Type> {\n-    let receiver = get_receiver(expression.clone())?;\n-    Some(ctx.sema.type_of_expr(&receiver)?.original())\n-}\n-\n-/// In the expression `a.b.c.x()`, find `a`\n-fn get_receiver(expression: ast::Expr) -> Option<ast::Expr> {\n-    match expression {\n-        ast::Expr::FieldExpr(field) if field.expr().is_some() => {\n-            let nested_expression = &field.expr()?;\n-            get_receiver(nested_expression.to_owned())\n-        }\n-        _ => Some(expression),\n-    }\n-}\n-\n #[derive(Debug)]\n enum Anchor {\n     Before(SyntaxNode),\n@@ -944,6 +932,11 @@ struct S {\n     vec: Vec<u8>\n }\n \n+struct Vec<T>;\n+impl<T> Vec<T> {\n+    fn push(&mut self, _:usize) {}\n+}\n+\n fn foo(s: &mut S) {\n     $0s.vec$0.push(0);\n }\"#,\n@@ -952,6 +945,11 @@ struct S {\n     vec: Vec<u8>\n }\n \n+struct Vec<T>;\n+impl<T> Vec<T> {\n+    fn push(&mut self, _:usize) {}\n+}\n+\n fn foo(s: &mut S) {\n     let $0vec = &mut s.vec;\n     vec.push(0);\n@@ -973,6 +971,10 @@ struct X {\n struct S {\n     vec: Vec<u8>\n }\n+struct Vec<T>;\n+impl<T> Vec<T> {\n+    fn push(&mut self, _:usize) {}\n+}\n \n fn foo(f: &mut Y) {\n     $0f.field.field.vec$0.push(0);\n@@ -987,6 +989,10 @@ struct X {\n struct S {\n     vec: Vec<u8>\n }\n+struct Vec<T>;\n+impl<T> Vec<T> {\n+    fn push(&mut self, _:usize) {}\n+}\n \n fn foo(f: &mut Y) {\n     let $0vec = &mut f.field.field.vec;\n@@ -1123,7 +1129,7 @@ struct S {\n }\n \n fn foo(s: S) {\n-    let $0x = s.sub;\n+    let $0x = &s.sub;\n     x.do_thing();\n }\"#,\n         );\n@@ -1189,7 +1195,7 @@ impl X {\n \n fn foo() {\n     let local = &mut S::new();\n-    let $0x = &mut local.sub;\n+    let $0x = &local.sub;\n     x.do_thing();\n }\"#,\n         );"}, {"sha": "2372fe28e1974578b45507d691e47bd082f9b760", "filename": "crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1910,7 +1910,6 @@ fn bar(new: fn) ${0:-> _} {\n \n     #[test]\n     fn add_function_with_closure_arg() {\n-        // FIXME: The argument in `bar` is wrong.\n         check_assist(\n             generate_function,\n             r\"\n@@ -1925,7 +1924,7 @@ fn foo() {\n     bar(closure)\n }\n \n-fn bar(closure: _) {\n+fn bar(closure: impl Fn(i64) -> i64) {\n     ${0:todo!()}\n }\n \","}, {"sha": "af96950761ea0ab74ac37535252e24b8353550c3", "filename": "crates/ide-assists/src/handlers/reorder_impl_items.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -21,7 +21,7 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // }\n //\n // struct Bar;\n-// $0impl Foo for Bar {\n+// $0impl Foo for Bar$0 {\n //     const B: u8 = 17;\n //     fn c() {}\n //     type A = String;\n@@ -45,6 +45,16 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n pub(crate) fn reorder_impl_items(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let impl_ast = ctx.find_node_at_offset::<ast::Impl>()?;\n     let items = impl_ast.assoc_item_list()?;\n+\n+    // restrict the range\n+    // if cursor is in assoc_items, abort\n+    let assoc_range = items.syntax().text_range();\n+    let cursor_position = ctx.offset();\n+    if assoc_range.contains_inclusive(cursor_position) {\n+        cov_mark::hit!(not_applicable_editing_assoc_items);\n+        return None;\n+    }\n+\n     let assoc_items = items.assoc_items().collect::<Vec<_>>();\n \n     let path = impl_ast\n@@ -264,9 +274,9 @@ trait Bar {\n }\n \n struct Foo;\n-impl Bar for Foo {\n+$0impl Bar for Foo {\n     type Fooo = ();\n-    type Foo = ();$0\n+    type Foo = ();\n }\"#,\n             r#\"\n trait Bar {\n@@ -281,4 +291,29 @@ impl Bar for Foo {\n }\"#,\n         )\n     }\n+\n+    #[test]\n+    fn not_applicable_editing_assoc_items() {\n+        cov_mark::check!(not_applicable_editing_assoc_items);\n+        check_assist_not_applicable(\n+            reorder_impl_items,\n+            r#\"\n+trait Bar {\n+    type T;\n+    const C: ();\n+    fn a() {}\n+    fn z() {}\n+    fn b() {}\n+}\n+struct Foo;\n+impl Bar for Foo {\n+    type T = ();$0\n+    const C: () = ();\n+    fn z() {}\n+    fn a() {}\n+    fn b() {}\n+}\n+        \"#,\n+        )\n+    }\n }"}, {"sha": "63e350e155fc8307392b15048bac6e832366cd1a", "filename": "crates/ide-assists/src/handlers/sort_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fsort_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fsort_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fsort_items.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -116,9 +116,11 @@ trait AddRewrite {\n         new: Vec<T>,\n         target: TextRange,\n     ) -> Option<()>;\n+    fn yeet() {}\n }\n \n impl AddRewrite for Assists {\n+    fn yeet() {}\n     fn add_rewrite<T: AstNode>(\n         &mut self,\n         label: &str,"}, {"sha": "fc03903e593fc8fcd739b0f2459b599f0b5d5895", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -122,6 +122,7 @@ mod handlers {\n     mod convert_iter_for_each_to_for;\n     mod convert_let_else_to_match;\n     mod convert_match_to_let_else;\n+    mod convert_nested_function_to_closure;\n     mod convert_tuple_struct_to_named_struct;\n     mod convert_named_struct_to_tuple_struct;\n     mod convert_to_guarded_return;\n@@ -228,8 +229,9 @@ mod handlers {\n             convert_iter_for_each_to_for::convert_iter_for_each_to_for,\n             convert_iter_for_each_to_for::convert_for_loop_with_for_each,\n             convert_let_else_to_match::convert_let_else_to_match,\n-            convert_named_struct_to_tuple_struct::convert_named_struct_to_tuple_struct,\n             convert_match_to_let_else::convert_match_to_let_else,\n+            convert_named_struct_to_tuple_struct::convert_named_struct_to_tuple_struct,\n+            convert_nested_function_to_closure::convert_nested_function_to_closure,\n             convert_to_guarded_return::convert_to_guarded_return,\n             convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n             convert_two_arm_bool_match_to_matches_macro::convert_two_arm_bool_match_to_matches_macro,"}, {"sha": "0096254ecb781a258204c110b260b594a5385ae7", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -494,6 +494,31 @@ impl Point {\n     )\n }\n \n+#[test]\n+fn doctest_convert_nested_function_to_closure() {\n+    check_doc_test(\n+        \"convert_nested_function_to_closure\",\n+        r#####\"\n+fn main() {\n+    fn fo$0o(label: &str, number: u64) {\n+        println!(\"{}: {}\", label, number);\n+    }\n+\n+    foo(\"Bar\", 100);\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    let foo = |label: &str, number: u64| {\n+        println!(\"{}: {}\", label, number);\n+    };\n+\n+    foo(\"Bar\", 100);\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_convert_to_guarded_return() {\n     check_doc_test(\n@@ -2116,7 +2141,7 @@ trait Foo {\n }\n \n struct Bar;\n-$0impl Foo for Bar {\n+$0impl Foo for Bar$0 {\n     const B: u8 = 17;\n     fn c() {}\n     type A = String;"}, {"sha": "3da90e9052f2f29b80f321b94df3ea152b8e2966", "filename": "crates/ide-assists/src/tests/sourcegen.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Ftests%2Fsourcegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-assists%2Fsrc%2Ftests%2Fsourcegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fsourcegen.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -90,8 +90,6 @@ impl Assist {\n             let comment_blocks = sourcegen::CommentBlock::extract(\"Assist\", &text);\n \n             for block in comment_blocks {\n-                // FIXME: doesn't support blank lines yet, need to tweak\n-                // `extract_comment_blocks` for that.\n                 let id = block.id;\n                 assert!(\n                     id.chars().all(|it| it.is_ascii_lowercase() || it == '_'),"}, {"sha": "bc7a94cd337bba28ec196786bcb15ee4b4a08767", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -23,7 +23,7 @@ pub(crate) mod env_vars;\n \n use std::iter;\n \n-use hir::{known, ScopeDef, Variant};\n+use hir::{known, HasAttrs, ScopeDef, Variant};\n use ide_db::{imports::import_assets::LocatedImport, SymbolKind};\n use syntax::ast;\n \n@@ -173,6 +173,9 @@ impl Completions {\n         resolution: hir::ScopeDef,\n         doc_aliases: Vec<syntax::SmolStr>,\n     ) {\n+        if !ctx.check_stability(resolution.attrs(ctx.db).as_deref()) {\n+            return;\n+        }\n         let is_private_editable = match ctx.def_is_visible(&resolution) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -198,6 +201,9 @@ impl Completions {\n         local_name: hir::Name,\n         resolution: hir::ScopeDef,\n     ) {\n+        if !ctx.check_stability(resolution.attrs(ctx.db).as_deref()) {\n+            return;\n+        }\n         let is_private_editable = match ctx.def_is_visible(&resolution) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -220,6 +226,9 @@ impl Completions {\n         path_ctx: &PathCompletionCtx,\n         e: hir::Enum,\n     ) {\n+        if !ctx.check_stability(Some(&e.attrs(ctx.db))) {\n+            return;\n+        }\n         e.variants(ctx.db)\n             .into_iter()\n             .for_each(|variant| self.add_enum_variant(ctx, path_ctx, variant, None));\n@@ -233,6 +242,9 @@ impl Completions {\n         local_name: hir::Name,\n         doc_aliases: Vec<syntax::SmolStr>,\n     ) {\n+        if !ctx.check_stability(Some(&module.attrs(ctx.db))) {\n+            return;\n+        }\n         self.add_path_resolution(\n             ctx,\n             path_ctx,\n@@ -249,6 +261,9 @@ impl Completions {\n         mac: hir::Macro,\n         local_name: hir::Name,\n     ) {\n+        if !ctx.check_stability(Some(&mac.attrs(ctx.db))) {\n+            return;\n+        }\n         let is_private_editable = match ctx.is_visible(&mac) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -272,6 +287,9 @@ impl Completions {\n         func: hir::Function,\n         local_name: Option<hir::Name>,\n     ) {\n+        if !ctx.check_stability(Some(&func.attrs(ctx.db))) {\n+            return;\n+        }\n         let is_private_editable = match ctx.is_visible(&func) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -296,6 +314,9 @@ impl Completions {\n         receiver: Option<hir::Name>,\n         local_name: Option<hir::Name>,\n     ) {\n+        if !ctx.check_stability(Some(&func.attrs(ctx.db))) {\n+            return;\n+        }\n         let is_private_editable = match ctx.is_visible(&func) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -320,6 +341,9 @@ impl Completions {\n         func: hir::Function,\n         import: LocatedImport,\n     ) {\n+        if !ctx.check_stability(Some(&func.attrs(ctx.db))) {\n+            return;\n+        }\n         let is_private_editable = match ctx.is_visible(&func) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -340,6 +364,9 @@ impl Completions {\n     }\n \n     pub(crate) fn add_const(&mut self, ctx: &CompletionContext<'_>, konst: hir::Const) {\n+        if !ctx.check_stability(Some(&konst.attrs(ctx.db))) {\n+            return;\n+        }\n         let is_private_editable = match ctx.is_visible(&konst) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -356,6 +383,9 @@ impl Completions {\n         ctx: &CompletionContext<'_>,\n         type_alias: hir::TypeAlias,\n     ) {\n+        if !ctx.check_stability(Some(&type_alias.attrs(ctx.db))) {\n+            return;\n+        }\n         let is_private_editable = match ctx.is_visible(&type_alias) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -372,6 +402,9 @@ impl Completions {\n         ctx: &CompletionContext<'_>,\n         type_alias: hir::TypeAlias,\n     ) {\n+        if !ctx.check_stability(Some(&type_alias.attrs(ctx.db))) {\n+            return;\n+        }\n         self.add_opt(render_type_alias_with_eq(RenderContext::new(ctx), type_alias));\n     }\n \n@@ -382,6 +415,9 @@ impl Completions {\n         variant: hir::Variant,\n         path: hir::ModPath,\n     ) {\n+        if !ctx.check_stability(Some(&variant.attrs(ctx.db))) {\n+            return;\n+        }\n         if let Some(builder) =\n             render_variant_lit(RenderContext::new(ctx), path_ctx, None, variant, Some(path))\n         {\n@@ -396,6 +432,9 @@ impl Completions {\n         variant: hir::Variant,\n         local_name: Option<hir::Name>,\n     ) {\n+        if !ctx.check_stability(Some(&variant.attrs(ctx.db))) {\n+            return;\n+        }\n         if let PathCompletionCtx { kind: PathKind::Pat { pat_ctx }, .. } = path_ctx {\n             cov_mark::hit!(enum_variant_pattern_path);\n             self.add_variant_pat(ctx, pat_ctx, Some(path_ctx), variant, local_name);\n@@ -417,6 +456,9 @@ impl Completions {\n         field: hir::Field,\n         ty: &hir::Type,\n     ) {\n+        if !ctx.check_stability(Some(&field.attrs(ctx.db))) {\n+            return;\n+        }\n         let is_private_editable = match ctx.is_visible(&field) {\n             Visible::Yes => false,\n             Visible::Editable => true,\n@@ -441,6 +483,9 @@ impl Completions {\n         path: Option<hir::ModPath>,\n         local_name: Option<hir::Name>,\n     ) {\n+        if !ctx.check_stability(Some(&strukt.attrs(ctx.db))) {\n+            return;\n+        }\n         if let Some(builder) =\n             render_struct_literal(RenderContext::new(ctx), path_ctx, strukt, path, local_name)\n         {\n@@ -455,6 +500,9 @@ impl Completions {\n         path: Option<hir::ModPath>,\n         local_name: Option<hir::Name>,\n     ) {\n+        if !ctx.check_stability(Some(&un.attrs(ctx.db))) {\n+            return;\n+        }\n         let item = render_union_literal(RenderContext::new(ctx), un, path, local_name);\n         self.add_opt(item);\n     }\n@@ -466,6 +514,8 @@ impl Completions {\n         field: usize,\n         ty: &hir::Type,\n     ) {\n+        // Only used for (unnamed) tuples, whose all fields *are* stable. No need to check\n+        // stability here.\n         let item = render_tuple_field(RenderContext::new(ctx), receiver, field, ty);\n         self.add(item);\n     }\n@@ -487,6 +537,9 @@ impl Completions {\n         variant: hir::Variant,\n         local_name: Option<hir::Name>,\n     ) {\n+        if !ctx.check_stability(Some(&variant.attrs(ctx.db))) {\n+            return;\n+        }\n         self.add_opt(render_variant_pat(\n             RenderContext::new(ctx),\n             pattern_ctx,\n@@ -504,6 +557,9 @@ impl Completions {\n         variant: hir::Variant,\n         path: hir::ModPath,\n     ) {\n+        if !ctx.check_stability(Some(&variant.attrs(ctx.db))) {\n+            return;\n+        }\n         let path = Some(&path);\n         self.add_opt(render_variant_pat(\n             RenderContext::new(ctx),\n@@ -522,6 +578,9 @@ impl Completions {\n         strukt: hir::Struct,\n         local_name: Option<hir::Name>,\n     ) {\n+        if !ctx.check_stability(Some(&strukt.attrs(ctx.db))) {\n+            return;\n+        }\n         self.add_opt(render_struct_pat(RenderContext::new(ctx), pattern_ctx, strukt, local_name));\n     }\n }"}, {"sha": "ba7663401613a659cd08ad6deac239b87bf6fe0c", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -172,6 +172,43 @@ fn foo(s: S) { s.$0 }\n         );\n     }\n \n+    #[test]\n+    fn no_unstable_method_on_stable() {\n+        check(\n+            r#\"\n+//- /main.rs crate:main deps:std\n+fn foo(s: std::S) { s.$0 }\n+//- /std.rs crate:std\n+pub struct S;\n+impl S {\n+    #[unstable]\n+    pub fn bar(&self) {}\n+}\n+\"#,\n+            expect![\"\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn unstable_method_on_nightly() {\n+        check(\n+            r#\"\n+//- toolchain:nightly\n+//- /main.rs crate:main deps:std\n+fn foo(s: std::S) { s.$0 }\n+//- /std.rs crate:std\n+pub struct S;\n+impl S {\n+    #[unstable]\n+    pub fn bar(&self) {}\n+}\n+\"#,\n+            expect![[r#\"\n+                me bar() fn(&self)\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_struct_field_completion_self() {\n         check("}, {"sha": "c525e0c80764c0577b14c5782946d245a9b45b20", "filename": "crates/ide-completion/src/completions/env_vars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -37,9 +37,9 @@ pub(crate) fn complete_cargo_env_vars(\n     guard_env_macro(expanded, &ctx.sema)?;\n     let range = expanded.text_range_between_quotes()?;\n \n-    CARGO_DEFINED_VARS.iter().for_each(|(var, detail)| {\n+    CARGO_DEFINED_VARS.into_iter().for_each(|&(var, detail)| {\n         let mut item = CompletionItem::new(CompletionItemKind::Keyword, range, var);\n-        item.detail(*detail);\n+        item.detail(detail);\n         item.add_to(acc);\n     });\n "}, {"sha": "1edf636aea0f0a7824e5664e52caf4b12c667e8b", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -262,8 +262,10 @@ fn import_on_the_fly(\n         .into_iter()\n         .filter(ns_filter)\n         .filter(|import| {\n+            let original_item = &import.original_item;\n             !ctx.is_item_hidden(&import.item_to_import)\n-                && !ctx.is_item_hidden(&import.original_item)\n+                && !ctx.is_item_hidden(original_item)\n+                && ctx.check_stability(original_item.attrs(ctx.db).as_deref())\n         })\n         .sorted_by_key(|located_import| {\n             compute_fuzzy_completion_order_key(&located_import.import_path, &user_input_lowercased)\n@@ -302,8 +304,10 @@ fn import_on_the_fly_pat_(\n         .into_iter()\n         .filter(ns_filter)\n         .filter(|import| {\n+            let original_item = &import.original_item;\n             !ctx.is_item_hidden(&import.item_to_import)\n-                && !ctx.is_item_hidden(&import.original_item)\n+                && !ctx.is_item_hidden(original_item)\n+                && ctx.check_stability(original_item.attrs(ctx.db).as_deref())\n         })\n         .sorted_by_key(|located_import| {\n             compute_fuzzy_completion_order_key(&located_import.import_path, &user_input_lowercased)"}, {"sha": "e82908a361e60b97fa0774b3598fa356be3f7d1d", "filename": "crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -150,21 +150,24 @@ fn complete_trait_impl(\n     impl_def: &ast::Impl,\n ) {\n     if let Some(hir_impl) = ctx.sema.to_def(impl_def) {\n-        get_missing_assoc_items(&ctx.sema, impl_def).into_iter().for_each(|item| {\n-            use self::ImplCompletionKind::*;\n-            match (item, kind) {\n-                (hir::AssocItem::Function(func), All | Fn) => {\n-                    add_function_impl(acc, ctx, replacement_range, func, hir_impl)\n+        get_missing_assoc_items(&ctx.sema, impl_def)\n+            .into_iter()\n+            .filter(|item| ctx.check_stability(Some(&item.attrs(ctx.db))))\n+            .for_each(|item| {\n+                use self::ImplCompletionKind::*;\n+                match (item, kind) {\n+                    (hir::AssocItem::Function(func), All | Fn) => {\n+                        add_function_impl(acc, ctx, replacement_range, func, hir_impl)\n+                    }\n+                    (hir::AssocItem::TypeAlias(type_alias), All | TypeAlias) => {\n+                        add_type_alias_impl(acc, ctx, replacement_range, type_alias, hir_impl)\n+                    }\n+                    (hir::AssocItem::Const(const_), All | Const) => {\n+                        add_const_impl(acc, ctx, replacement_range, const_, hir_impl)\n+                    }\n+                    _ => {}\n                 }\n-                (hir::AssocItem::TypeAlias(type_alias), All | TypeAlias) => {\n-                    add_type_alias_impl(acc, ctx, replacement_range, type_alias, hir_impl)\n-                }\n-                (hir::AssocItem::Const(const_), All | Const) => {\n-                    add_const_impl(acc, ctx, replacement_range, const_, hir_impl)\n-                }\n-                _ => {}\n-            }\n-        });\n+            });\n     }\n }\n "}, {"sha": "45be4fb20540cf9f54231740c3e7648ead98e604", "filename": "crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -52,6 +52,9 @@ pub(crate) fn complete_use_path(\n                         )\n                     };\n                     for (name, def) in module_scope {\n+                        if !ctx.check_stability(def.attrs(ctx.db).as_deref()) {\n+                            continue;\n+                        }\n                         let is_name_already_imported = name\n                             .as_text()\n                             .map_or(false, |text| already_imported_names.contains(text.as_str()));"}, {"sha": "7b145f3c14e32d7618babebe5f5454ee264c9637", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -367,6 +367,8 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) krate: hir::Crate,\n     /// The module of the `scope`.\n     pub(super) module: hir::Module,\n+    /// Whether nightly toolchain is used. Cached since this is looked up a lot.\n+    is_nightly: bool,\n \n     /// The expected name of what we are completing.\n     /// This is usually the parameter name of the function argument we are completing.\n@@ -386,7 +388,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) depth_from_crate_root: usize,\n }\n \n-impl<'a> CompletionContext<'a> {\n+impl CompletionContext<'_> {\n     /// The range of the identifier that is being completed.\n     pub(crate) fn source_range(&self) -> TextRange {\n         let kind = self.original_token.kind();\n@@ -459,6 +461,12 @@ impl<'a> CompletionContext<'a> {\n         }\n     }\n \n+    /// Checks whether this item should be listed in regards to stability. Returns `true` if we should.\n+    pub(crate) fn check_stability(&self, attrs: Option<&hir::Attrs>) -> bool {\n+        let Some(attrs) = attrs else { return true; };\n+        !attrs.is_unstable() || self.is_nightly\n+    }\n+\n     /// Whether the given trait is an operator trait or not.\n     pub(crate) fn is_ops_trait(&self, trait_: hir::Trait) -> bool {\n         match trait_.attrs(self.db).lang() {\n@@ -632,6 +640,11 @@ impl<'a> CompletionContext<'a> {\n         let krate = scope.krate();\n         let module = scope.module();\n \n+        let toolchain = db.crate_graph()[krate.into()].channel;\n+        // `toolchain == None` means we're in some detached files. Since we have no information on\n+        // the toolchain being used, let's just allow unstable items to be listed.\n+        let is_nightly = matches!(toolchain, Some(base_db::ReleaseChannel::Nightly) | None);\n+\n         let mut locals = FxHashMap::default();\n         scope.process_all_names(&mut |name, scope| {\n             if let ScopeDef::Local(local) = scope {\n@@ -651,6 +664,7 @@ impl<'a> CompletionContext<'a> {\n             token,\n             krate,\n             module,\n+            is_nightly,\n             expected_name,\n             expected_type,\n             qualifier_ctx,"}, {"sha": "79c1f98f3bde6c8aad37a9850507aa07c7e27844", "filename": "crates/ide-completion/src/tests.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -23,6 +23,7 @@ mod type_pos;\n mod use_tree;\n mod visibility;\n \n+use expect_test::Expect;\n use hir::PrefixKind;\n use ide_db::{\n     base_db::{fixture::ChangeFixture, FileLoader, FilePosition},\n@@ -215,6 +216,11 @@ pub(crate) fn check_edit_with_config(\n     assert_eq_text!(&ra_fixture_after, &actual)\n }\n \n+fn check_empty(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual);\n+}\n+\n pub(crate) fn get_all_items(\n     config: CompletionConfig,\n     code: &str,"}, {"sha": "36465be23d84db45e996db6cfba5c784ff526e91", "filename": "crates/ide-completion/src/tests/expression.rs", "status": "modified", "additions": 103, "deletions": 6, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,18 +1,13 @@\n //! Completion tests for expressions.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{check_edit, completion_list, BASE_ITEMS_FIXTURE};\n+use crate::tests::{check_edit, check_empty, completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}{ra_fixture}\"));\n     expect.assert_eq(&actual)\n }\n \n-fn check_empty(ra_fixture: &str, expect: Expect) {\n-    let actual = completion_list(ra_fixture);\n-    expect.assert_eq(&actual);\n-}\n-\n #[test]\n fn complete_literal_struct_with_a_private_field() {\n     // `FooDesc.bar` is private, the completion should not be triggered.\n@@ -997,3 +992,105 @@ fn foo() { if foo {} el$0 { let x = 92; } }\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn expr_no_unstable_item_on_stable() {\n+    check_empty(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+use std::*;\n+fn main() {\n+    $0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct UnstableThisShouldNotBeListed;\n+\"#,\n+        expect![[r#\"\n+            fn main()      fn()\n+            md std\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn expr_unstable_item_on_nightly() {\n+    check_empty(\n+        r#\"\n+//- toolchain:nightly\n+//- /main.rs crate:main deps:std\n+use std::*;\n+fn main() {\n+    $0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct UnstableButWeAreOnNightlyAnyway;\n+\"#,\n+        expect![[r#\"\n+            fn main()                 fn()\n+            md std\n+            st UnstableButWeAreOnNightlyAnyway\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+}"}, {"sha": "d727320b5148959002f69744bea960ca17fc30ba", "filename": "crates/ide-completion/src/tests/flyimport.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1107,6 +1107,41 @@ fn function() {\n     );\n }\n \n+#[test]\n+fn flyimport_pattern_no_unstable_item_on_stable() {\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+fn function() {\n+    let foo$0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct FooStruct {}\n+\"#,\n+        expect![\"\"],\n+    );\n+}\n+\n+#[test]\n+fn flyimport_pattern_unstable_item_on_nightly() {\n+    check(\n+        r#\"\n+//- toolchain:nightly\n+//- /main.rs crate:main deps:std\n+fn function() {\n+    let foo$0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct FooStruct {}\n+\"#,\n+        expect![[r#\"\n+            st FooStruct (use std::FooStruct)\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn flyimport_item_name() {\n     check("}, {"sha": "2b5b4dd773c878c9b6b7f1af041766e472be80be", "filename": "crates/ide-completion/src/tests/item_list.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fitem_list.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,7 +1,7 @@\n //! Completion tests for item list position.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{check_edit, completion_list, BASE_ITEMS_FIXTURE};\n+use crate::tests::{check_edit, check_empty, completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}{ra_fixture}\"));\n@@ -297,6 +297,58 @@ impl Test for () {\n     );\n }\n \n+#[test]\n+fn in_trait_impl_no_unstable_item_on_stable() {\n+    check_empty(\n+        r#\"\n+trait Test {\n+    #[unstable]\n+    type Type;\n+    #[unstable]\n+    const CONST: ();\n+    #[unstable]\n+    fn function();\n+}\n+\n+impl Test for () {\n+    $0\n+}\n+\"#,\n+        expect![[r#\"\n+            kw crate::\n+            kw self::\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn in_trait_impl_unstable_item_on_nightly() {\n+    check_empty(\n+        r#\"\n+//- toolchain:nightly\n+trait Test {\n+    #[unstable]\n+    type Type;\n+    #[unstable]\n+    const CONST: ();\n+    #[unstable]\n+    fn function();\n+}\n+\n+impl Test for () {\n+    $0\n+}\n+\"#,\n+        expect![[r#\"\n+            ct const CONST: () =\n+            fn fn function()\n+            ta type Type =\n+            kw crate::\n+            kw self::\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn after_unit_struct() {\n     check("}, {"sha": "8af6cce98f6358529d641bcd523448b94687f876", "filename": "crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,12 +1,7 @@\n //! Completion tests for pattern position.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{check_edit, completion_list, BASE_ITEMS_FIXTURE};\n-\n-fn check_empty(ra_fixture: &str, expect: Expect) {\n-    let actual = completion_list(ra_fixture);\n-    expect.assert_eq(&actual)\n-}\n+use crate::tests::{check_edit, check_empty, completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}\\n{ra_fixture}\"));\n@@ -742,3 +737,56 @@ fn f(x: EnumAlias<u8>) {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn pat_no_unstable_item_on_stable() {\n+    check_empty(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+use std::*;\n+fn foo() {\n+    let a$0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct S;\n+#[unstable]\n+pub enum Enum {\n+    Variant\n+}\n+\"#,\n+        expect![[r#\"\n+            md std\n+            kw mut\n+            kw ref\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn pat_unstable_item_on_nightly() {\n+    check_empty(\n+        r#\"\n+//- toolchain:nightly\n+//- /main.rs crate:main deps:std\n+use std::*;\n+fn foo() {\n+    let a$0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct S;\n+#[unstable]\n+pub enum Enum {\n+    Variant\n+}\n+\"#,\n+        expect![[r#\"\n+            en Enum\n+            md std\n+            st S\n+            kw mut\n+            kw ref\n+        \"#]],\n+    );\n+}"}, {"sha": "789ad66345b12dd3199975ee47b4fb4daeeda127", "filename": "crates/ide-completion/src/tests/predicate.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fpredicate.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,7 +1,7 @@\n //! Completion tests for predicates and bounds.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n+use crate::tests::{check_empty, completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}\\n{ra_fixture}\"));\n@@ -129,3 +129,43 @@ impl Record {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn pred_no_unstable_item_on_stable() {\n+    check_empty(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+use std::*;\n+struct Foo<T> where T: $0 {}\n+//- /std.rs crate:std\n+#[unstable]\n+pub trait Trait {}\n+\"#,\n+        expect![[r#\"\n+            md std\n+            kw crate::\n+            kw self::\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn pred_unstable_item_on_nightly() {\n+    check_empty(\n+        r#\"\n+//- toolchain:nightly\n+//- /main.rs crate:main deps:std\n+use std::*;\n+struct Foo<T> where T: $0 {}\n+//- /std.rs crate:std\n+#[unstable]\n+pub trait Trait {}\n+\"#,\n+        expect![[r#\"\n+            md std\n+            tt Trait\n+            kw crate::\n+            kw self::\n+        \"#]],\n+    );\n+}"}, {"sha": "8cb1ff4a125f70c66fec059923ef2bab18979ff4", "filename": "crates/ide-completion/src/tests/type_pos.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,7 +1,7 @@\n //! Completion tests for type position.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n+use crate::tests::{check_empty, completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(&format!(\"{BASE_ITEMS_FIXTURE}\\n{ra_fixture}\"));\n@@ -669,3 +669,53 @@ fn f(t: impl MyTrait<Item1 = u8, Item2 = $0\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn type_pos_no_unstable_type_on_stable() {\n+    check_empty(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+use std::*;\n+struct Foo {\n+    f: $0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct S;\n+\"#,\n+        expect![[r#\"\n+            md std\n+            sp Self\n+            st Foo\n+            bt u32\n+            kw crate::\n+            kw self::\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn type_pos_unstable_type_on_nightly() {\n+    check_empty(\n+        r#\"\n+//- toolchain:nightly\n+//- /main.rs crate:main deps:std\n+use std::*;\n+struct Foo {\n+    f: $0\n+}\n+//- /std.rs crate:std\n+#[unstable]\n+pub struct S;\n+\"#,\n+        expect![[r#\"\n+            md std\n+            sp Self\n+            st Foo\n+            st S\n+            bt u32\n+            kw crate::\n+            kw self::\n+        \"#]],\n+    )\n+}"}, {"sha": "ba2e047999ef1c17b535a088a68738ba804dc768", "filename": "crates/ide-completion/src/tests/use_tree.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests%2Fuse_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-completion%2Fsrc%2Ftests%2Fuse_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fuse_tree.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -382,3 +382,51 @@ use self::foo::impl$0\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn use_tree_no_unstable_items_on_stable() {\n+    check(\n+        r#\"\n+//- toolchain:stable\n+//- /lib.rs crate:main deps:std\n+use std::$0\n+//- /std.rs crate:std\n+#[unstable]\n+pub mod simd {}\n+#[unstable]\n+pub struct S;\n+#[unstable]\n+pub fn foo() {}\n+#[unstable]\n+#[macro_export]\n+marco_rules! m { () => {} }\n+\"#,\n+        expect![\"\"],\n+    );\n+}\n+\n+#[test]\n+fn use_tree_unstable_items_on_nightly() {\n+    check(\n+        r#\"\n+//- toolchain:nightly\n+//- /lib.rs crate:main deps:std\n+use std::$0\n+//- /std.rs crate:std\n+#[unstable]\n+pub mod simd {}\n+#[unstable]\n+pub struct S;\n+#[unstable]\n+pub fn foo() {}\n+#[unstable]\n+#[macro_export]\n+marco_rules! m { () => {} }\n+\"#,\n+        expect![[r#\"\n+            fn foo  fn()\n+            md simd\n+            st S\n+        \"#]],\n+    );\n+}"}, {"sha": "89aa437d75d98a13cbb5950af4590ae3428d4853", "filename": "crates/ide-diagnostics/src/handlers/break_outside_of_loop.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -31,12 +31,8 @@ mod tests {\n fn foo() {\n     break;\n   //^^^^^ error: break outside of loop\n-    break 'a;\n-  //^^^^^^^^ error: break outside of loop\n     continue;\n   //^^^^^^^^ error: continue outside of loop\n-    continue 'a;\n-  //^^^^^^^^^^^ error: continue outside of loop\n }\n \"#,\n         );\n@@ -51,12 +47,8 @@ fn foo() {\n         async {\n                 break;\n               //^^^^^ error: break outside of loop\n-                break 'a;\n-              //^^^^^^^^ error: break outside of loop\n                 continue;\n               //^^^^^^^^ error: continue outside of loop\n-                continue 'a;\n-              //^^^^^^^^^^^ error: continue outside of loop\n         };\n     }\n }\n@@ -73,12 +65,8 @@ fn foo() {\n         || {\n                 break;\n               //^^^^^ error: break outside of loop\n-                break 'a;\n-              //^^^^^^^^ error: break outside of loop\n                 continue;\n               //^^^^^^^^ error: continue outside of loop\n-                continue 'a;\n-              //^^^^^^^^^^^ error: continue outside of loop\n         };\n     }\n }\n@@ -94,9 +82,7 @@ fn foo() {\n     'a: loop {\n         {\n             break;\n-            break 'a;\n             continue;\n-            continue 'a;\n         }\n     }\n }\n@@ -112,9 +98,7 @@ fn foo() {\n     'a: loop {\n         try {\n                 break;\n-                break 'a;\n                 continue;\n-                continue 'a;\n         };\n     }\n }\n@@ -130,11 +114,8 @@ fn foo() {\n     'a: {\n         break;\n       //^^^^^ error: break outside of loop\n-        break 'a;\n         continue;\n       //^^^^^^^^ error: continue outside of loop\n-        continue 'a;\n-      //^^^^^^^^^^^ error: continue outside of loop\n     }\n }\n \"#,"}, {"sha": "8c4ca23e06e8d4ce33b20337cc8483538588e15e", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -771,6 +771,88 @@ fn fn_once(mut x: impl FnOnce(u8) -> u8) -> u8 {\n         );\n     }\n \n+    #[test]\n+    fn closure() {\n+        // FIXME: Diagnositc spans are too large\n+        check_diagnostics(\n+            r#\"\n+        //- minicore: copy, fn\n+        struct X;\n+\n+        impl X {\n+            fn mutate(&mut self) {}\n+        }\n+\n+        fn f() {\n+            let x = 5;\n+            let closure1 = || { x = 2; };\n+                         //^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+            let _ = closure1();\n+                  //^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `closure1`\n+            let closure2 = || { x = x; };\n+                         //^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+            let closure3 = || {\n+                let x = 2;\n+                x = 5;\n+              //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+                x\n+            };\n+            let x = X;\n+            let closure4 = || { x.mutate(); };\n+                         //^^^^^^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+        }\n+                    \"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+        //- minicore: copy, fn\n+        fn f() {\n+            let mut x = 5;\n+              //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            let mut y = 2;\n+            y = 7;\n+            let closure = || {\n+                let mut z = 8;\n+                z = 3;\n+                let mut k = z;\n+                  //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            };\n+        }\n+                    \"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- minicore: copy, fn\n+fn f() {\n+    let closure = || {\n+        || {\n+            || {\n+                let x = 2;\n+                || { || { x = 5; } }\n+              //^^^^^^^^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+            }\n+        }\n+    };\n+}\n+            \"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- minicore: copy, fn\n+fn f() {\n+    struct X;\n+    let mut x = X;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    let c1 = || x;\n+    let mut x = X;\n+    let c2 = || { x = X; x };\n+    let mut x = X;\n+    let c2 = move || { x = X; };\n+}\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn respect_allow_unused_mut() {\n         // FIXME: respect"}, {"sha": "738339cfa6b5cd24ce24d944d28ed68579f03382", "filename": "crates/ide-diagnostics/src/handlers/replace_filter_map_next_with_find_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -115,7 +115,7 @@ fn foo() {\n             r#\"\n //- minicore: iterators\n fn foo() {\n-    let m = core::iter::repeat(())\n+    let mut m = core::iter::repeat(())\n         .filter_map(|()| Some(92));\n     let n = m.next();\n }"}, {"sha": "c5fa1cb027e142376b58268fefe5ea26f0a137d6", "filename": "crates/ide-diagnostics/src/handlers/type_mismatch.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,5 +1,5 @@\n use either::Either;\n-use hir::{db::ExpandDatabase, HirDisplay, InFile, Type};\n+use hir::{db::ExpandDatabase, ClosureStyle, HirDisplay, InFile, Type};\n use ide_db::{famous_defs::FamousDefs, source_change::SourceChange};\n use syntax::{\n     ast::{self, BlockExpr, ExprStmt},\n@@ -32,8 +32,8 @@ pub(crate) fn type_mismatch(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch)\n         \"type-mismatch\",\n         format!(\n             \"expected {}, found {}\",\n-            d.expected.display(ctx.sema.db),\n-            d.actual.display(ctx.sema.db)\n+            d.expected.display(ctx.sema.db).with_closure_style(ClosureStyle::ClosureWithId),\n+            d.actual.display(ctx.sema.db).with_closure_style(ClosureStyle::ClosureWithId),\n         ),\n         display_range,\n     )\n@@ -596,6 +596,19 @@ fn test() -> String {\n         );\n     }\n \n+    #[test]\n+    fn closure_mismatch_show_different_type() {\n+        check_diagnostics(\n+            r#\"\n+fn f() {\n+    let mut x = (|| 1, 2);\n+    x = (|| 3, 4);\n+       //^^^^ error: expected {closure#0}, found {closure#1}\n+}\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn type_mismatch_on_block() {\n         cov_mark::check!(type_mismatch_on_block);"}, {"sha": "dbedf1e6c1ed9f4b05a836ada24e5af1b48a14e7", "filename": "crates/ide-diagnostics/src/handlers/undeclared_label.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fundeclared_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fundeclared_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fundeclared_label.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -0,0 +1,63 @@\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: undeclared-label\n+pub(crate) fn undeclared_label(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UndeclaredLabel,\n+) -> Diagnostic {\n+    let name = &d.name;\n+    Diagnostic::new(\n+        \"undeclared-label\",\n+        format!(\"use of undeclared label `{name}`\"),\n+        ctx.sema.diagnostics_display_range(d.node.clone().map(|it| it.into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn smoke_test() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    break 'a;\n+  //^^^^^^^^ error: break outside of loop\n+        //^^ error: use of undeclared label `'a`\n+    continue 'a;\n+  //^^^^^^^^^^^ error: continue outside of loop\n+           //^^ error: use of undeclared label `'a`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_operator_desugar_works() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: option, try\n+fn foo() {\n+    None?;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- minicore: option, try, future\n+async fn foo() {\n+    None?;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- minicore: option, try, future, fn\n+async fn foo() {\n+    || None?;\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "b9c5384ea1eec8d0606ce7eb7f1c7a36b369ed37", "filename": "crates/ide-diagnostics/src/handlers/unlinked_file.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -10,7 +10,7 @@ use ide_db::{\n };\n use syntax::{\n     ast::{self, edit::IndentLevel, HasModuleItem, HasName},\n-    AstNode, TextRange, TextSize,\n+    AstNode, TextRange,\n };\n use text_edit::TextEdit;\n \n@@ -27,14 +27,28 @@ pub(crate) fn unlinked_file(\n ) {\n     // Limit diagnostic to the first few characters in the file. This matches how VS Code\n     // renders it with the full span, but on other editors, and is less invasive.\n+    let fixes = fixes(ctx, file_id);\n+    // FIXME: This is a hack for the vscode extension to notice whether there is an autofix or not before having to resolve diagnostics.\n+    // This is to prevent project linking popups from appearing when there is an autofix. https://github.com/rust-lang/rust-analyzer/issues/14523\n+    let message = if fixes.is_none() {\n+        \"file not included in crate hierarchy\"\n+    } else {\n+        \"file not included in module tree\"\n+    };\n+\n     let range = ctx.sema.db.parse(file_id).syntax_node().text_range();\n-    // FIXME: This is wrong if one of the first three characters is not ascii: `//\u042b`.\n-    let range = range.intersect(TextRange::up_to(TextSize::of(\"...\"))).unwrap_or(range);\n+    let range = FileLoader::file_text(ctx.sema.db, file_id)\n+        .char_indices()\n+        .take(3)\n+        .last()\n+        .map(|(i, _)| i)\n+        .map(|i| TextRange::up_to(i.try_into().unwrap()))\n+        .unwrap_or(range);\n \n     acc.push(\n-        Diagnostic::new(\"unlinked-file\", \"file not included in module tree\", range)\n+        Diagnostic::new(\"unlinked-file\", message, range)\n             .severity(Severity::WeakWarning)\n-            .with_fixes(fixes(ctx, file_id)),\n+            .with_fixes(fixes),\n     );\n }\n "}, {"sha": "5933a9b694a37e48437df9e1e78bd3e1087ae22c", "filename": "crates/ide-diagnostics/src/handlers/unreachable_label.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funreachable_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funreachable_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funreachable_label.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -0,0 +1,91 @@\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: unreachable-label\n+pub(crate) fn unreachable_label(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnreachableLabel,\n+) -> Diagnostic {\n+    let name = &d.name;\n+    Diagnostic::new(\n+        \"unreachable-label\",\n+        format!(\"use of unreachable label `{name}`\"),\n+        ctx.sema.diagnostics_display_range(d.node.clone().map(|it| it.into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn async_blocks_are_borders() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        async {\n+            break 'a;\n+          //^^^^^^^^ error: break outside of loop\n+               // ^^ error: use of unreachable label `'a`\n+            continue 'a;\n+          //^^^^^^^^^^^ error: continue outside of loop\n+                  // ^^ error: use of unreachable label `'a`\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn closures_are_borders() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        || {\n+            break 'a;\n+          //^^^^^^^^ error: break outside of loop\n+               // ^^ error: use of unreachable label `'a`\n+            continue 'a;\n+          //^^^^^^^^^^^ error: continue outside of loop\n+                  // ^^ error: use of unreachable label `'a`\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn blocks_pass_through() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        {\n+          break 'a;\n+          continue 'a;\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_blocks_pass_through() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        try {\n+            break 'a;\n+            continue 'a;\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "70116f15a75609e992f2d3e7ae6bee48d91d59fa", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -52,6 +52,8 @@ mod handlers {\n     pub(crate) mod unresolved_macro_call;\n     pub(crate) mod unresolved_module;\n     pub(crate) mod unresolved_proc_macro;\n+    pub(crate) mod undeclared_label;\n+    pub(crate) mod unreachable_label;\n \n     // The handlers below are unusual, the implement the diagnostics as well.\n     pub(crate) mod field_shorthand;\n@@ -253,36 +255,38 @@ pub fn diagnostics(\n     for diag in diags {\n         #[rustfmt::skip]\n         let d = match diag {\n-            AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n             AnyDiagnostic::ExpectedFunction(d) => handlers::expected_function::expected_function(&ctx, &d),\n-            AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n+            AnyDiagnostic::InactiveCode(d) => match handlers::inactive_code::inactive_code(&ctx, &d) {\n+                Some(it) => it,\n+                None => continue,\n+            }\n             AnyDiagnostic::IncoherentImpl(d) => handlers::incoherent_impl::incoherent_impl(&ctx, &d),\n+            AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n+            AnyDiagnostic::InvalidDeriveTarget(d) => handlers::invalid_derive_target::invalid_derive_target(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => handlers::mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => handlers::missing_fields::missing_fields(&ctx, &d),\n             AnyDiagnostic::MissingMatchArms(d) => handlers::missing_match_arms::missing_match_arms(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => handlers::missing_unsafe::missing_unsafe(&ctx, &d),\n+            AnyDiagnostic::NeedMut(d) => handlers::mutability_errors::need_mut(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => handlers::no_such_field::no_such_field(&ctx, &d),\n             AnyDiagnostic::PrivateAssocItem(d) => handlers::private_assoc_item::private_assoc_item(&ctx, &d),\n             AnyDiagnostic::PrivateField(d) => handlers::private_field::private_field(&ctx, &d),\n             AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => handlers::replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n             AnyDiagnostic::TypeMismatch(d) => handlers::type_mismatch::type_mismatch(&ctx, &d),\n+            AnyDiagnostic::UndeclaredLabel(d) => handlers::undeclared_label::undeclared_label(&ctx, &d),\n             AnyDiagnostic::UnimplementedBuiltinMacro(d) => handlers::unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),\n+            AnyDiagnostic::UnreachableLabel(d) => handlers::unreachable_label:: unreachable_label(&ctx, &d),\n             AnyDiagnostic::UnresolvedExternCrate(d) => handlers::unresolved_extern_crate::unresolved_extern_crate(&ctx, &d),\n+            AnyDiagnostic::UnresolvedField(d) => handlers::unresolved_field::unresolved_field(&ctx, &d),\n             AnyDiagnostic::UnresolvedImport(d) => handlers::unresolved_import::unresolved_import(&ctx, &d),\n             AnyDiagnostic::UnresolvedMacroCall(d) => handlers::unresolved_macro_call::unresolved_macro_call(&ctx, &d),\n+            AnyDiagnostic::UnresolvedMethodCall(d) => handlers::unresolved_method::unresolved_method(&ctx, &d),\n             AnyDiagnostic::UnresolvedModule(d) => handlers::unresolved_module::unresolved_module(&ctx, &d),\n             AnyDiagnostic::UnresolvedProcMacro(d) => handlers::unresolved_proc_macro::unresolved_proc_macro(&ctx, &d, config.proc_macros_enabled, config.proc_attr_macros_enabled),\n-            AnyDiagnostic::InvalidDeriveTarget(d) => handlers::invalid_derive_target::invalid_derive_target(&ctx, &d),\n-            AnyDiagnostic::UnresolvedField(d) => handlers::unresolved_field::unresolved_field(&ctx, &d),\n-            AnyDiagnostic::UnresolvedMethodCall(d) => handlers::unresolved_method::unresolved_method(&ctx, &d),\n-            AnyDiagnostic::NeedMut(d) => handlers::mutability_errors::need_mut(&ctx, &d),\n             AnyDiagnostic::UnusedMut(d) => handlers::mutability_errors::unused_mut(&ctx, &d),\n-            AnyDiagnostic::InactiveCode(d) => match handlers::inactive_code::inactive_code(&ctx, &d) {\n-                Some(it) => it,\n-                None => continue,\n-            }\n+            AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n         };\n         res.push(d)\n     }"}, {"sha": "b6b46c4508888c2094d6c5d7bb42cfa6d2700a56", "filename": "crates/ide/src/doc_links/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fdoc_links%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fdoc_links%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links%2Ftests.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -116,7 +116,7 @@ fn external_docs_doc_url_std_crate() {\n //- /main.rs crate:std\n use self$0;\n \"#,\n-        expect![[r#\"https://doc.rust-lang.org/nightly/std/index.html\"#]],\n+        expect![\"https://doc.rust-lang.org/stable/std/index.html\"],\n     );\n }\n "}, {"sha": "91af5716ca54f19861914c1f6b3b10bc4b8e17c3", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -471,7 +471,7 @@ struct Foo {}\n \"#,\n             expect![[r#\"\n                 Clone\n-                impl < >core::clone::Clone for Foo< >{}\n+                impl < >core::clone::Clone for Foo< >where{}\n             \"#]],\n         );\n     }\n@@ -488,7 +488,7 @@ struct Foo {}\n \"#,\n             expect![[r#\"\n                 Copy\n-                impl < >core::marker::Copy for Foo< >{}\n+                impl < >core::marker::Copy for Foo< >where{}\n             \"#]],\n         );\n     }\n@@ -504,7 +504,7 @@ struct Foo {}\n \"#,\n             expect![[r#\"\n                 Copy\n-                impl < >core::marker::Copy for Foo< >{}\n+                impl < >core::marker::Copy for Foo< >where{}\n             \"#]],\n         );\n         check(\n@@ -516,7 +516,7 @@ struct Foo {}\n \"#,\n             expect![[r#\"\n                 Clone\n-                impl < >core::clone::Clone for Foo< >{}\n+                impl < >core::clone::Clone for Foo< >where{}\n             \"#]],\n         );\n     }"}, {"sha": "73ab3d2e16fe267319a7ac152783846cc94bade1", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -225,7 +225,7 @@ fn main() {\n                 *iter*\n \n                 ```rust\n-                let mut iter: Iter<Scan<OtherStruct<OtherStruct<i32>>, |&mut u32, &u32, &mut u32| -> Option<u32>, u32>>\n+                let mut iter: Iter<Scan<OtherStruct<OtherStruct<i32>>, impl Fn(&mut u32, &u32, &mut u32) -> Option<u32>, u32>>\n                 ```\n             \"#]],\n     );\n@@ -4242,7 +4242,7 @@ fn foo() {\n /// [threads]: ../book/ch16-01-threads.html#using-move-closures-with-threads\n mod move_keyword {}\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n             *move*\n \n             ```rust\n@@ -4251,11 +4251,11 @@ mod move_keyword {}\n \n             ---\n \n-            [closure](https://doc.rust-lang.org/nightly/book/ch13-01-closures.html)\n-            [closures](https://doc.rust-lang.org/nightly/book/ch13-01-closures.html)\n-            [threads](https://doc.rust-lang.org/nightly/book/ch16-01-threads.html#using-move-closures-with-threads)\n+            [closure](https://doc.rust-lang.org/stable/book/ch13-01-closures.html)\n+            [closures](https://doc.rust-lang.org/stable/book/ch13-01-closures.html)\n+            [threads](https://doc.rust-lang.org/stable/book/ch16-01-threads.html#using-move-closures-with-threads)\n             <https://doc.rust-lang.org/nightly/book/ch13-01-closures.html>\n-        \"##]],\n+        \"#]],\n     );\n }\n "}, {"sha": "e6360bc6ec1c9f5d5bddfc51c387cf11ba5fdd0a", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -5,7 +5,8 @@ use std::{\n \n use either::Either;\n use hir::{\n-    known, HasVisibility, HirDisplay, HirDisplayError, HirWrite, ModuleDef, ModuleDefId, Semantics,\n+    known, ClosureStyle, HasVisibility, HirDisplay, HirDisplayError, HirWrite, ModuleDef,\n+    ModuleDefId, Semantics,\n };\n use ide_db::{base_db::FileRange, famous_defs::FamousDefs, RootDatabase};\n use itertools::Itertools;\n@@ -45,6 +46,7 @@ pub struct InlayHintsConfig {\n     pub param_names_for_lifetime_elision_hints: bool,\n     pub hide_named_constructor_hints: bool,\n     pub hide_closure_initialization_hints: bool,\n+    pub closure_style: ClosureStyle,\n     pub max_length: Option<usize>,\n     pub closing_brace_hints_min_lines: Option<usize>,\n }\n@@ -291,6 +293,7 @@ fn label_of_ty(\n         mut max_length: Option<usize>,\n         ty: hir::Type,\n         label_builder: &mut InlayHintLabelBuilder<'_>,\n+        config: &InlayHintsConfig,\n     ) -> Result<(), HirDisplayError> {\n         let iter_item_type = hint_iterator(sema, famous_defs, &ty);\n         match iter_item_type {\n@@ -321,11 +324,14 @@ fn label_of_ty(\n                 label_builder.write_str(LABEL_ITEM)?;\n                 label_builder.end_location_link();\n                 label_builder.write_str(LABEL_MIDDLE2)?;\n-                rec(sema, famous_defs, max_length, ty, label_builder)?;\n+                rec(sema, famous_defs, max_length, ty, label_builder, config)?;\n                 label_builder.write_str(LABEL_END)?;\n                 Ok(())\n             }\n-            None => ty.display_truncated(sema.db, max_length).write_to(label_builder),\n+            None => ty\n+                .display_truncated(sema.db, max_length)\n+                .with_closure_style(config.closure_style)\n+                .write_to(label_builder),\n         }\n     }\n \n@@ -335,7 +341,7 @@ fn label_of_ty(\n         location: None,\n         result: InlayHintLabel::default(),\n     };\n-    let _ = rec(sema, famous_defs, config.max_length, ty, &mut label_builder);\n+    let _ = rec(sema, famous_defs, config.max_length, ty, &mut label_builder, config);\n     let r = label_builder.finish();\n     Some(r)\n }\n@@ -481,6 +487,7 @@ fn closure_has_block_body(closure: &ast::ClosureExpr) -> bool {\n #[cfg(test)]\n mod tests {\n     use expect_test::Expect;\n+    use hir::ClosureStyle;\n     use itertools::Itertools;\n     use test_utils::extract_annotations;\n \n@@ -504,6 +511,7 @@ mod tests {\n         binding_mode_hints: false,\n         hide_named_constructor_hints: false,\n         hide_closure_initialization_hints: false,\n+        closure_style: ClosureStyle::ImplFn,\n         param_names_for_lifetime_elision_hints: false,\n         max_length: None,\n         closing_brace_hints_min_lines: None,"}, {"sha": "0b1460919566df21189b310d787fe42e6ada56f6", "filename": "crates/ide/src/inlay_hints/adjustment.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -315,13 +315,17 @@ fn main() {\n     (&Struct).consume();\n    //^^^^^^^*\n     (&Struct).by_ref();\n+   //^^^^^^^&\n+   //^^^^^^^*\n \n     (&mut Struct).consume();\n    //^^^^^^^^^^^*\n     (&mut Struct).by_ref();\n    //^^^^^^^^^^^&\n    //^^^^^^^^^^^*\n     (&mut Struct).by_ref_mut();\n+   //^^^^^^^^^^^&mut $\n+   //^^^^^^^^^^^*\n \n     // Check that block-like expressions don't duplicate hints\n     let _: &mut [u32] = (&mut []);\n@@ -414,6 +418,10 @@ fn main() {\n    //^^^^^^^)\n    //^^^^^^^.*\n     (&Struct).by_ref();\n+   //^^^^^^^(\n+   //^^^^^^^)\n+   //^^^^^^^.*\n+   //^^^^^^^.&\n \n     (&mut Struct).consume();\n    //^^^^^^^^^^^(\n@@ -425,6 +433,10 @@ fn main() {\n    //^^^^^^^^^^^.*\n    //^^^^^^^^^^^.&\n     (&mut Struct).by_ref_mut();\n+   //^^^^^^^^^^^(\n+   //^^^^^^^^^^^)\n+   //^^^^^^^^^^^.*\n+   //^^^^^^^^^^^.&mut\n \n     // Check that block-like expressions don't duplicate hints\n     let _: &mut [u32] = (&mut []);"}, {"sha": "5f571d0448211a0610b805a01d0d86ba04b55b57", "filename": "crates/ide/src/inlay_hints/bind_pat.rs", "status": "modified", "additions": 97, "deletions": 8, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -176,6 +176,7 @@ fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::IdentPat, pat_ty: &hir\n mod tests {\n     // This module also contains tests for super::closure_ret\n \n+    use hir::ClosureStyle;\n     use syntax::{TextRange, TextSize};\n     use test_utils::extract_annotations;\n \n@@ -235,7 +236,7 @@ fn main() {\n     let zz_ref = &zz;\n       //^^^^^^ &Test<i32>\n     let test = || zz;\n-      //^^^^ || -> Test<i32>\n+      //^^^^ impl FnOnce() -> Test<i32>\n }\"#,\n         );\n     }\n@@ -753,7 +754,7 @@ fn main() {\n     let func = times2;\n     //  ^^^^ fn times2(i32) -> i32\n     let closure = |x: i32| x * 2;\n-    //  ^^^^^^^ |i32| -> i32\n+    //  ^^^^^^^ impl Fn(i32) -> i32\n }\n \n fn fallible() -> ControlFlow<()> {\n@@ -821,7 +822,7 @@ fn main() {\n                    //^^^^^^^^^ i32\n \n     let multiply =\n-      //^^^^^^^^ |i32, i32| -> i32\n+      //^^^^^^^^ impl Fn(i32, i32) -> i32\n       | a,     b| a * b\n       //^ i32  ^ i32\n \n@@ -830,10 +831,10 @@ fn main() {\n     let _: i32 = multiply(1,  2);\n                         //^ a ^ b\n     let multiply_ref = &multiply;\n-      //^^^^^^^^^^^^ &|i32, i32| -> i32\n+      //^^^^^^^^^^^^ &impl Fn(i32, i32) -> i32\n \n     let return_42 = || 42;\n-      //^^^^^^^^^ || -> i32\n+      //^^^^^^^^^ impl Fn() -> i32\n       || { 42 };\n     //^^ i32\n }\"#,\n@@ -857,6 +858,94 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn closure_style() {\n+        check_with_config(\n+            InlayHintsConfig { type_hints: true, ..DISABLED_CONFIG },\n+            r#\"\n+//- minicore: fn\n+fn main() {\n+    let x = || 2;\n+      //^ impl Fn() -> i32\n+    let y = |t: i32| x() + t;\n+      //^ impl Fn(i32) -> i32\n+    let mut t = 5;\n+          //^ i32\n+    let z = |k: i32| { t += k; };\n+      //^ impl FnMut(i32)\n+    let p = (y, z);\n+      //^ (impl Fn(i32) -> i32, impl FnMut(i32))\n+}\n+            \"#,\n+        );\n+        check_with_config(\n+            InlayHintsConfig {\n+                type_hints: true,\n+                closure_style: ClosureStyle::RANotation,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+//- minicore: fn\n+fn main() {\n+    let x = || 2;\n+      //^ || -> i32\n+    let y = |t: i32| x() + t;\n+      //^ |i32| -> i32\n+    let mut t = 5;\n+          //^ i32\n+    let z = |k: i32| { t += k; };\n+      //^ |i32| -> ()\n+    let p = (y, z);\n+      //^ (|i32| -> i32, |i32| -> ())\n+}\n+            \"#,\n+        );\n+        check_with_config(\n+            InlayHintsConfig {\n+                type_hints: true,\n+                closure_style: ClosureStyle::ClosureWithId,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+//- minicore: fn\n+fn main() {\n+    let x = || 2;\n+      //^ {closure#0}\n+    let y = |t: i32| x() + t;\n+      //^ {closure#1}\n+    let mut t = 5;\n+          //^ i32\n+    let z = |k: i32| { t += k; };\n+      //^ {closure#2}\n+    let p = (y, z);\n+      //^ ({closure#1}, {closure#2})\n+}\n+            \"#,\n+        );\n+        check_with_config(\n+            InlayHintsConfig {\n+                type_hints: true,\n+                closure_style: ClosureStyle::Hide,\n+                ..DISABLED_CONFIG\n+            },\n+            r#\"\n+//- minicore: fn\n+fn main() {\n+    let x = || 2;\n+      //^ \u2026\n+    let y = |t: i32| x() + t;\n+      //^ \u2026\n+    let mut t = 5;\n+          //^ i32\n+    let z = |k: i32| { t += k; };\n+      //^ \u2026\n+    let p = (y, z);\n+      //^ (\u2026, \u2026)\n+}\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn skip_closure_type_hints() {\n         check_with_config(\n@@ -871,13 +960,13 @@ fn main() {\n     let multiple_2 = |x: i32| { x * 2 };\n \n     let multiple_2 = |x: i32| x * 2;\n-    //  ^^^^^^^^^^ |i32| -> i32\n+    //  ^^^^^^^^^^ impl Fn(i32) -> i32\n \n     let (not) = (|x: bool| { !x });\n-    //   ^^^ |bool| -> bool\n+    //   ^^^ impl Fn(bool) -> bool\n \n     let (is_zero, _b) = (|x: usize| { x == 0 }, false);\n-    //   ^^^^^^^ |usize| -> bool\n+    //   ^^^^^^^ impl Fn(usize) -> bool\n     //            ^^ bool\n \n     let plus_one = |x| { x + 1 };"}, {"sha": "cdee705cbfdaad403850f4710362602033def689", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1227,6 +1227,24 @@ fn main() {\n         )\n     }\n \n+    #[test]\n+    fn call_info_for_fn_def_over_reference() {\n+        check(\n+            r#\"\n+struct S;\n+fn foo(s: S) -> i32 { 92 }\n+fn main() {\n+    let bar = &&&&&foo;\n+    bar($0);\n+}\n+        \"#,\n+            expect![[r#\"\n+                fn foo(s: S) -> i32\n+                       ^^^^\n+            \"#]],\n+        )\n+    }\n+\n     #[test]\n     fn call_info_for_fn_ptr() {\n         check("}, {"sha": "774b07775b9dc684c0c492251056ca6dbc6fd5e7", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -118,6 +118,7 @@ impl StaticIndex<'_> {\n                     adjustment_hints_hide_outside_unsafe: false,\n                     hide_named_constructor_hints: false,\n                     hide_closure_initialization_hints: false,\n+                    closure_style: hir::ClosureStyle::ImplFn,\n                     param_names_for_lifetime_elision_hints: false,\n                     binding_mode_hints: false,\n                     max_length: Some(25),"}, {"sha": "5821bb1202f17fc8e99af95361f2d721b21aa630", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -21,8 +21,11 @@ use syntax::{\n \n use crate::{\n     syntax_highlighting::{\n-        escape::highlight_escape_string, format::highlight_format_string, highlights::Highlights,\n-        macro_::MacroHighlighter, tags::Highlight,\n+        escape::{highlight_escape_char, highlight_escape_string},\n+        format::highlight_format_string,\n+        highlights::Highlights,\n+        macro_::MacroHighlighter,\n+        tags::Highlight,\n     },\n     FileId, HlMod, HlOperator, HlPunct, HlTag,\n };\n@@ -427,6 +430,14 @@ fn traverse(\n                 if let Some(byte_string) = ast::ByteString::cast(token) {\n                     highlight_escape_string(hl, &byte_string, range.start());\n                 }\n+            } else if ast::Char::can_cast(token.kind())\n+                && ast::Char::can_cast(descended_token.kind())\n+            {\n+                let Some(char) = ast::Char::cast(token) else {\n+                    continue;\n+                };\n+\n+                highlight_escape_char(hl, &char, range.start())\n             }\n         }\n "}, {"sha": "211e3588095cf455815c0ba596cacef99d310f8e", "filename": "crates/ide/src/syntax_highlighting/escape.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fescape.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,8 +1,8 @@\n //! Syntax highlighting for escape sequences\n use crate::syntax_highlighting::highlights::Highlights;\n use crate::{HlRange, HlTag};\n-use syntax::ast::IsString;\n-use syntax::TextSize;\n+use syntax::ast::{Char, IsString};\n+use syntax::{AstToken, TextRange, TextSize};\n \n pub(super) fn highlight_escape_string<T: IsString>(\n     stack: &mut Highlights,\n@@ -23,3 +23,23 @@ pub(super) fn highlight_escape_string<T: IsString>(\n         }\n     });\n }\n+\n+pub(super) fn highlight_escape_char(stack: &mut Highlights, char: &Char, start: TextSize) {\n+    if char.value().is_none() {\n+        return;\n+    }\n+\n+    let text = char.text();\n+    if !text.starts_with('\\'') || !text.ends_with('\\'') {\n+        return;\n+    }\n+\n+    let text = &text[1..text.len() - 1];\n+    if !text.starts_with('\\\\') {\n+        return;\n+    }\n+\n+    let range =\n+        TextRange::new(start + TextSize::from(1), start + TextSize::from(text.len() as u32 + 1));\n+    stack.add(HlRange { range, highlight: HlTag::EscapeSequence.into(), binding_hash: None })\n+}"}, {"sha": "936362914aec068aeacff47a85f47f5e5af81084", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -675,14 +675,12 @@ fn is_consumed_lvalue(node: &SyntaxNode, local: &hir::Local, db: &RootDatabase)\n \n /// Returns true if the parent nodes of `node` all match the `SyntaxKind`s in `kinds` exactly.\n fn parents_match(mut node: NodeOrToken<SyntaxNode, SyntaxToken>, mut kinds: &[SyntaxKind]) -> bool {\n-    while let (Some(parent), [kind, rest @ ..]) = (&node.parent(), kinds) {\n+    while let (Some(parent), [kind, rest @ ..]) = (node.parent(), kinds) {\n         if parent.kind() != *kind {\n             return false;\n         }\n \n-        // FIXME: Would be nice to get parent out of the match, but binding by-move and by-value\n-        // in the same pattern is unstable: rust-lang/rust#68354.\n-        node = node.parent().unwrap().into();\n+        node = parent.into();\n         kinds = rest;\n     }\n "}, {"sha": "d34f5cffbf12a3d2100d0cc8c53e2a815351b0d9", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_strings.html", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -93,6 +93,16 @@\n <span class=\"brace\">}</span>\n \n <span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span><span class=\"parenthesis\">(</span><span class=\"parenthesis\">)</span> <span class=\"brace\">{</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"char_literal\">'</span><span class=\"escape_sequence\">\\n</span><span class=\"char_literal\">'</span><span class=\"semicolon\">;</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"char_literal\">'</span><span class=\"escape_sequence\">\\t</span><span class=\"char_literal\">'</span><span class=\"semicolon\">;</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"char_literal\">'\\e'</span><span class=\"semicolon\">;</span> <span class=\"comment\">// invalid escape</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"char_literal\">'e'</span><span class=\"semicolon\">;</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"char_literal\">' '</span><span class=\"semicolon\">;</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"char_literal\">'</span><span class=\"escape_sequence\">\\u{48}</span><span class=\"char_literal\">'</span><span class=\"semicolon\">;</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"char_literal\">'</span><span class=\"escape_sequence\">\\u{4823}</span><span class=\"char_literal\">'</span><span class=\"semicolon\">;</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"char_literal\">'</span><span class=\"escape_sequence\">\\x65</span><span class=\"char_literal\">'</span><span class=\"semicolon\">;</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"char_literal\">'</span><span class=\"escape_sequence\">\\x00</span><span class=\"char_literal\">'</span><span class=\"semicolon\">;</span>\n+\n     <span class=\"macro\">println</span><span class=\"macro_bang\">!</span><span class=\"parenthesis\">(</span><span class=\"string_literal\">\"Hello </span><span class=\"escape_sequence\">{{</span><span class=\"string_literal\">Hello</span><span class=\"escape_sequence\">}}</span><span class=\"string_literal\">\"</span><span class=\"parenthesis\">)</span><span class=\"semicolon\">;</span>\n     <span class=\"comment\">// from https://doc.rust-lang.org/std/fmt/index.html</span>\n     <span class=\"macro\">println</span><span class=\"macro_bang\">!</span><span class=\"parenthesis\">(</span><span class=\"string_literal\">\"Hello\"</span><span class=\"parenthesis\">)</span><span class=\"semicolon\">;</span>                 <span class=\"comment\">// =&gt; \"Hello\"</span>"}, {"sha": "12205d47e5d8e3aa72e5de69a503566bdf5cae45", "filename": "crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -439,6 +439,16 @@ macro_rules! toho {\n }\n \n fn main() {\n+    let a = '\\n';\n+    let a = '\\t';\n+    let a = '\\e'; // invalid escape\n+    let a = 'e';\n+    let a = ' ';\n+    let a = '\\u{48}';\n+    let a = '\\u{4823}';\n+    let a = '\\x65';\n+    let a = '\\x00';\n+\n     println!(\"Hello {{Hello}}\");\n     // from https://doc.rust-lang.org/std/fmt/index.html\n     println!(\"Hello\");                 // => \"Hello\""}, {"sha": "8f03c6ec7b572694893abaacaacab3705ab6d086", "filename": "crates/proc-macro-srv-cli/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv-cli%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv-cli%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv-cli%2FCargo.toml?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -10,6 +10,7 @@ rust-version.workspace = true\n \n [dependencies]\n proc-macro-srv.workspace = true\n+proc-macro-api.workspace = true\n \n [features]\n sysroot-abi = [\"proc-macro-srv/sysroot-abi\"]"}, {"sha": "b307701e19fbbafe513d2784a8d1d7e5c5d22577", "filename": "crates/proc-macro-srv-cli/src/lib.rs", "status": "renamed", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv-cli%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv-cli%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv-cli%2Fsrc%2Flib.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -3,10 +3,9 @@ use std::io;\n \n use proc_macro_api::msg::{self, Message};\n \n-use crate::ProcMacroSrv;\n-\n+#[cfg(feature = \"sysroot-abi\")]\n pub fn run() -> io::Result<()> {\n-    let mut srv = ProcMacroSrv::default();\n+    let mut srv = proc_macro_srv::ProcMacroSrv::default();\n     let mut buf = String::new();\n \n     while let Some(req) = read_request(&mut buf)? {\n@@ -24,6 +23,27 @@ pub fn run() -> io::Result<()> {\n \n     Ok(())\n }\n+#[cfg(not(feature = \"sysroot-abi\"))]\n+pub fn run() -> io::Result<()> {\n+    let mut buf = String::new();\n+\n+    while let Some(req) = read_request(&mut buf)? {\n+        let res = match req {\n+            msg::Request::ListMacros { .. } => {\n+                msg::Response::ListMacros(Err(\"server is built without sysroot support\".to_owned()))\n+            }\n+            msg::Request::ExpandMacro(..) => msg::Response::ExpandMacro(Err(msg::PanicMessage(\n+                \"server is built without sysroot support\".to_owned(),\n+            ))),\n+            msg::Request::ApiVersionCheck {} => {\n+                msg::Response::ApiVersionCheck(proc_macro_api::msg::CURRENT_API_VERSION)\n+            }\n+        };\n+        write_response(res)?\n+    }\n+\n+    Ok(())\n+}\n \n fn read_request(buf: &mut String) -> io::Result<Option<msg::Request>> {\n     msg::Request::read(&mut io::stdin().lock(), buf)", "previous_filename": "crates/proc-macro-srv/src/cli.rs"}, {"sha": "cc83c60f15c4d0f4ecfc335229c32bd42e1dfc0c", "filename": "crates/proc-macro-srv-cli/src/main.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv-cli%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv-cli%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv-cli%2Fsrc%2Fmain.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,6 +1,5 @@\n //! A standalone binary for `proc-macro-srv`.\n-\n-use proc_macro_srv::cli;\n+//! Driver for proc macro server\n \n fn main() -> std::io::Result<()> {\n     let v = std::env::var(\"RUST_ANALYZER_INTERNALS_DO_NOT_USE\");\n@@ -15,5 +14,5 @@ fn main() -> std::io::Result<()> {\n         }\n     }\n \n-    cli::run()\n+    proc_macro_srv_cli::run()\n }"}, {"sha": "93805c89354a5d7fff1b4463e1776c0d8083bfa5", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/mod.rs", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fmod.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,106 +0,0 @@\n-//! Macro ABI for version 1.63 of rustc\n-\n-#[allow(dead_code)]\n-#[doc(hidden)]\n-mod proc_macro;\n-\n-#[allow(dead_code)]\n-#[doc(hidden)]\n-mod ra_server;\n-\n-use libloading::Library;\n-use proc_macro_api::ProcMacroKind;\n-\n-use super::tt;\n-use super::PanicMessage;\n-\n-pub use ra_server::TokenStream;\n-\n-pub(crate) struct Abi {\n-    exported_macros: Vec<proc_macro::bridge::client::ProcMacro>,\n-}\n-\n-impl From<proc_macro::bridge::PanicMessage> for PanicMessage {\n-    fn from(p: proc_macro::bridge::PanicMessage) -> Self {\n-        Self { message: p.as_str().map(|s| s.to_string()) }\n-    }\n-}\n-\n-impl Abi {\n-    pub unsafe fn from_lib(lib: &Library, symbol_name: String) -> Result<Abi, libloading::Error> {\n-        let macros: libloading::Symbol<'_, &&[proc_macro::bridge::client::ProcMacro]> =\n-            lib.get(symbol_name.as_bytes())?;\n-        Ok(Self { exported_macros: macros.to_vec() })\n-    }\n-\n-    pub fn expand(\n-        &self,\n-        macro_name: &str,\n-        macro_body: &tt::Subtree,\n-        attributes: Option<&tt::Subtree>,\n-    ) -> Result<tt::Subtree, PanicMessage> {\n-        let parsed_body = TokenStream::with_subtree(macro_body.clone());\n-\n-        let parsed_attributes =\n-            attributes.map_or(TokenStream::new(), |attr| TokenStream::with_subtree(attr.clone()));\n-\n-        for proc_macro in &self.exported_macros {\n-            match proc_macro {\n-                proc_macro::bridge::client::ProcMacro::CustomDerive {\n-                    trait_name, client, ..\n-                } if *trait_name == macro_name => {\n-                    let res = client.run(\n-                        &proc_macro::bridge::server::SameThread,\n-                        ra_server::RustAnalyzer::default(),\n-                        parsed_body,\n-                        true,\n-                    );\n-                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n-                }\n-                proc_macro::bridge::client::ProcMacro::Bang { name, client }\n-                    if *name == macro_name =>\n-                {\n-                    let res = client.run(\n-                        &proc_macro::bridge::server::SameThread,\n-                        ra_server::RustAnalyzer::default(),\n-                        parsed_body,\n-                        true,\n-                    );\n-                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n-                }\n-                proc_macro::bridge::client::ProcMacro::Attr { name, client }\n-                    if *name == macro_name =>\n-                {\n-                    let res = client.run(\n-                        &proc_macro::bridge::server::SameThread,\n-                        ra_server::RustAnalyzer::default(),\n-                        parsed_attributes,\n-                        parsed_body,\n-                        true,\n-                    );\n-                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n-                }\n-                _ => continue,\n-            }\n-        }\n-\n-        Err(proc_macro::bridge::PanicMessage::String(\"Nothing to expand\".to_string()).into())\n-    }\n-\n-    pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n-        self.exported_macros\n-            .iter()\n-            .map(|proc_macro| match proc_macro {\n-                proc_macro::bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n-                    (trait_name.to_string(), ProcMacroKind::CustomDerive)\n-                }\n-                proc_macro::bridge::client::ProcMacro::Bang { name, .. } => {\n-                    (name.to_string(), ProcMacroKind::FuncLike)\n-                }\n-                proc_macro::bridge::client::ProcMacro::Attr { name, .. } => {\n-                    (name.to_string(), ProcMacroKind::Attr)\n-                }\n-            })\n-            .collect()\n-    }\n-}"}, {"sha": "48030f8d82dcaa3671ec67631991774c36ed5098", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/buffer.rs", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fbuffer.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,156 +0,0 @@\n-//! Buffer management for same-process client<->server communication.\n-\n-use std::io::{self, Write};\n-use std::mem;\n-use std::ops::{Deref, DerefMut};\n-use std::slice;\n-\n-#[repr(C)]\n-pub struct Buffer {\n-    data: *mut u8,\n-    len: usize,\n-    capacity: usize,\n-    reserve: extern \"C\" fn(Buffer, usize) -> Buffer,\n-    drop: extern \"C\" fn(Buffer),\n-}\n-\n-unsafe impl Sync for Buffer {}\n-unsafe impl Send for Buffer {}\n-\n-impl Default for Buffer {\n-    #[inline]\n-    fn default() -> Self {\n-        Self::from(vec![])\n-    }\n-}\n-\n-impl Deref for Buffer {\n-    type Target = [u8];\n-    #[inline]\n-    fn deref(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts(self.data as *const u8, self.len) }\n-    }\n-}\n-\n-impl DerefMut for Buffer {\n-    #[inline]\n-    fn deref_mut(&mut self) -> &mut [u8] {\n-        unsafe { slice::from_raw_parts_mut(self.data, self.len) }\n-    }\n-}\n-\n-impl Buffer {\n-    #[inline]\n-    pub(super) fn new() -> Self {\n-        Self::default()\n-    }\n-\n-    #[inline]\n-    pub(super) fn clear(&mut self) {\n-        self.len = 0;\n-    }\n-\n-    #[inline]\n-    pub(super) fn take(&mut self) -> Self {\n-        mem::take(self)\n-    }\n-\n-    // We have the array method separate from extending from a slice. This is\n-    // because in the case of small arrays, codegen can be more efficient\n-    // (avoiding a memmove call). With extend_from_slice, LLVM at least\n-    // currently is not able to make that optimization.\n-    #[inline]\n-    pub(super) fn extend_from_array<const N: usize>(&mut self, xs: &[u8; N]) {\n-        if xs.len() > (self.capacity - self.len) {\n-            let b = self.take();\n-            *self = (b.reserve)(b, xs.len());\n-        }\n-        unsafe {\n-            xs.as_ptr().copy_to_nonoverlapping(self.data.add(self.len), xs.len());\n-            self.len += xs.len();\n-        }\n-    }\n-\n-    #[inline]\n-    pub(super) fn extend_from_slice(&mut self, xs: &[u8]) {\n-        if xs.len() > (self.capacity - self.len) {\n-            let b = self.take();\n-            *self = (b.reserve)(b, xs.len());\n-        }\n-        unsafe {\n-            xs.as_ptr().copy_to_nonoverlapping(self.data.add(self.len), xs.len());\n-            self.len += xs.len();\n-        }\n-    }\n-\n-    #[inline]\n-    pub(super) fn push(&mut self, v: u8) {\n-        // The code here is taken from Vec::push, and we know that reserve()\n-        // will panic if we're exceeding isize::MAX bytes and so there's no need\n-        // to check for overflow.\n-        if self.len == self.capacity {\n-            let b = self.take();\n-            *self = (b.reserve)(b, 1);\n-        }\n-        unsafe {\n-            *self.data.add(self.len) = v;\n-            self.len += 1;\n-        }\n-    }\n-}\n-\n-impl Write for Buffer {\n-    #[inline]\n-    fn write(&mut self, xs: &[u8]) -> io::Result<usize> {\n-        self.extend_from_slice(xs);\n-        Ok(xs.len())\n-    }\n-\n-    #[inline]\n-    fn write_all(&mut self, xs: &[u8]) -> io::Result<()> {\n-        self.extend_from_slice(xs);\n-        Ok(())\n-    }\n-\n-    #[inline]\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-impl Drop for Buffer {\n-    #[inline]\n-    fn drop(&mut self) {\n-        let b = self.take();\n-        (b.drop)(b);\n-    }\n-}\n-\n-impl From<Vec<u8>> for Buffer {\n-    fn from(mut v: Vec<u8>) -> Self {\n-        let (data, len, capacity) = (v.as_mut_ptr(), v.len(), v.capacity());\n-        mem::forget(v);\n-\n-        // This utility function is nested in here because it can *only*\n-        // be safely called on `Buffer`s created by *this* `proc_macro`.\n-        fn to_vec(b: Buffer) -> Vec<u8> {\n-            unsafe {\n-                let Buffer { data, len, capacity, .. } = b;\n-                mem::forget(b);\n-                Vec::from_raw_parts(data, len, capacity)\n-            }\n-        }\n-\n-        extern \"C\" fn reserve(b: Buffer, additional: usize) -> Buffer {\n-            let mut v = to_vec(b);\n-            v.reserve(additional);\n-            Buffer::from(v)\n-        }\n-\n-        extern \"C\" fn drop(b: Buffer) {\n-            mem::drop(to_vec(b));\n-        }\n-\n-        Buffer { data, len, capacity, reserve, drop }\n-    }\n-}"}, {"sha": "b346c2c18969804ad54fd96a56dbe2fb4238e9e1", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/client.rs", "status": "removed", "additions": 0, "deletions": 510, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fclient.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,510 +0,0 @@\n-//! Client-side types.\n-\n-use super::*;\n-\n-use std::marker::PhantomData;\n-\n-macro_rules! define_handles {\n-    (\n-        'owned: $($oty:ident,)*\n-        'interned: $($ity:ident,)*\n-    ) => {\n-        #[repr(C)]\n-        #[allow(non_snake_case)]\n-        pub struct HandleCounters {\n-            $($oty: AtomicUsize,)*\n-            $($ity: AtomicUsize,)*\n-        }\n-\n-        impl HandleCounters {\n-            // FIXME(eddyb) use a reference to the `static COUNTERS`, instead of\n-            // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n-            extern \"C\" fn get() -> &'static Self {\n-                static COUNTERS: HandleCounters = HandleCounters {\n-                    $($oty: AtomicUsize::new(1),)*\n-                    $($ity: AtomicUsize::new(1),)*\n-                };\n-                &COUNTERS\n-            }\n-        }\n-\n-        // FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n-        #[repr(C)]\n-        #[allow(non_snake_case)]\n-        pub(super) struct HandleStore<S: server::Types> {\n-            $($oty: handle::OwnedStore<S::$oty>,)*\n-            $($ity: handle::InternedStore<S::$ity>,)*\n-        }\n-\n-        impl<S: server::Types> HandleStore<S> {\n-            pub(super) fn new(handle_counters: &'static HandleCounters) -> Self {\n-                HandleStore {\n-                    $($oty: handle::OwnedStore::new(&handle_counters.$oty),)*\n-                    $($ity: handle::InternedStore::new(&handle_counters.$ity),)*\n-                }\n-            }\n-        }\n-\n-        $(\n-            #[repr(C)]\n-            pub(crate) struct $oty {\n-                handle: handle::Handle,\n-                // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual\n-                // way of doing this, but that requires unstable features.\n-                // rust-analyzer uses this code and avoids unstable features.\n-                _marker: PhantomData<*mut ()>,\n-            }\n-\n-            // Forward `Drop::drop` to the inherent `drop` method.\n-            impl Drop for $oty {\n-                fn drop(&mut self) {\n-                    $oty {\n-                        handle: self.handle,\n-                        _marker: PhantomData,\n-                    }.drop();\n-                }\n-            }\n-\n-            impl<S> Encode<S> for $oty {\n-                fn encode(self, w: &mut Writer, s: &mut S) {\n-                    let handle = self.handle;\n-                    mem::forget(self);\n-                    handle.encode(w, s);\n-                }\n-            }\n-\n-            impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n-                for Marked<S::$oty, $oty>\n-            {\n-                fn decode(r: &mut Reader<'_>, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n-                    s.$oty.take(handle::Handle::decode(r, &mut ()))\n-                }\n-            }\n-\n-            impl<S> Encode<S> for &$oty {\n-                fn encode(self, w: &mut Writer, s: &mut S) {\n-                    self.handle.encode(w, s);\n-                }\n-            }\n-\n-            impl<'s, S: server::Types> Decode<'_, 's, HandleStore<server::MarkedTypes<S>>>\n-                for &'s Marked<S::$oty, $oty>\n-            {\n-                fn decode(r: &mut Reader<'_>, s: &'s HandleStore<server::MarkedTypes<S>>) -> Self {\n-                    &s.$oty[handle::Handle::decode(r, &mut ())]\n-                }\n-            }\n-\n-            impl<S> Encode<S> for &mut $oty {\n-                fn encode(self, w: &mut Writer, s: &mut S) {\n-                    self.handle.encode(w, s);\n-                }\n-            }\n-\n-            impl<'s, S: server::Types> DecodeMut<'_, 's, HandleStore<server::MarkedTypes<S>>>\n-                for &'s mut Marked<S::$oty, $oty>\n-            {\n-                fn decode(\n-                    r: &mut Reader<'_>,\n-                    s: &'s mut HandleStore<server::MarkedTypes<S>>\n-                ) -> Self {\n-                    &mut s.$oty[handle::Handle::decode(r, &mut ())]\n-                }\n-            }\n-\n-            impl<S: server::Types> Encode<HandleStore<server::MarkedTypes<S>>>\n-                for Marked<S::$oty, $oty>\n-            {\n-                fn encode(self, w: &mut Writer, s: &mut HandleStore<server::MarkedTypes<S>>) {\n-                    s.$oty.alloc(self).encode(w, s);\n-                }\n-            }\n-\n-            impl<S> DecodeMut<'_, '_, S> for $oty {\n-                fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-                    $oty {\n-                        handle: handle::Handle::decode(r, s),\n-                        _marker: PhantomData,\n-                    }\n-                }\n-            }\n-        )*\n-\n-        $(\n-            #[repr(C)]\n-            #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-            pub(crate) struct $ity {\n-                handle: handle::Handle,\n-                // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual\n-                // way of doing this, but that requires unstable features.\n-                // rust-analyzer uses this code and avoids unstable features.\n-                _marker: PhantomData<*mut ()>,\n-            }\n-\n-            impl<S> Encode<S> for $ity {\n-                fn encode(self, w: &mut Writer, s: &mut S) {\n-                    self.handle.encode(w, s);\n-                }\n-            }\n-\n-            impl<S: server::Types> DecodeMut<'_, '_, HandleStore<server::MarkedTypes<S>>>\n-                for Marked<S::$ity, $ity>\n-            {\n-                fn decode(r: &mut Reader<'_>, s: &mut HandleStore<server::MarkedTypes<S>>) -> Self {\n-                    s.$ity.copy(handle::Handle::decode(r, &mut ()))\n-                }\n-            }\n-\n-            impl<S: server::Types> Encode<HandleStore<server::MarkedTypes<S>>>\n-                for Marked<S::$ity, $ity>\n-            {\n-                fn encode(self, w: &mut Writer, s: &mut HandleStore<server::MarkedTypes<S>>) {\n-                    s.$ity.alloc(self).encode(w, s);\n-                }\n-            }\n-\n-            impl<S> DecodeMut<'_, '_, S> for $ity {\n-                fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-                    $ity {\n-                        handle: handle::Handle::decode(r, s),\n-                        _marker: PhantomData,\n-                    }\n-                }\n-            }\n-        )*\n-    }\n-}\n-define_handles! {\n-    'owned:\n-    FreeFunctions,\n-    TokenStream,\n-    Group,\n-    Literal,\n-    SourceFile,\n-    MultiSpan,\n-    Diagnostic,\n-\n-    'interned:\n-    Punct,\n-    Ident,\n-    Span,\n-}\n-\n-// FIXME(eddyb) generate these impls by pattern-matching on the\n-// names of methods - also could use the presence of `fn drop`\n-// to distinguish between 'owned and 'interned, above.\n-// Alternatively, special \"modes\" could be listed of types in with_api\n-// instead of pattern matching on methods, here and in server decl.\n-\n-impl Clone for TokenStream {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n-impl Clone for Group {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n-impl Clone for Literal {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n-impl fmt::Debug for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Literal\")\n-            // format the kind without quotes, as in `kind: Float`\n-            .field(\"kind\", &format_args!(\"{}\", &self.debug_kind()))\n-            .field(\"symbol\", &self.symbol())\n-            // format `Some(\"...\")` on one line even in {:#?} mode\n-            .field(\"suffix\", &format_args!(\"{:?}\", &self.suffix()))\n-            .field(\"span\", &self.span())\n-            .finish()\n-    }\n-}\n-\n-impl Clone for SourceFile {\n-    fn clone(&self) -> Self {\n-        self.clone()\n-    }\n-}\n-\n-impl fmt::Debug for Span {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.debug())\n-    }\n-}\n-\n-macro_rules! define_client_side {\n-    ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)*;)*\n-    }),* $(,)?) => {\n-        $(impl $name {\n-            $(pub(crate) fn $method($($arg: $arg_ty),*) $(-> $ret_ty)* {\n-                Bridge::with(|bridge| {\n-                    let mut buf = bridge.cached_buffer.take();\n-\n-                    buf.clear();\n-                    api_tags::Method::$name(api_tags::$name::$method).encode(&mut buf, &mut ());\n-                    reverse_encode!(buf; $($arg),*);\n-\n-                    buf = bridge.dispatch.call(buf);\n-\n-                    let r = Result::<_, PanicMessage>::decode(&mut &buf[..], &mut ());\n-\n-                    bridge.cached_buffer = buf;\n-\n-                    r.unwrap_or_else(|e| panic::resume_unwind(e.into()))\n-                })\n-            })*\n-        })*\n-    }\n-}\n-with_api!(self, self, define_client_side);\n-\n-enum BridgeState<'a> {\n-    /// No server is currently connected to this client.\n-    NotConnected,\n-\n-    /// A server is connected and available for requests.\n-    Connected(Bridge<'a>),\n-\n-    /// Access to the bridge is being exclusively acquired\n-    /// (e.g., during `BridgeState::with`).\n-    InUse,\n-}\n-\n-enum BridgeStateL {}\n-\n-impl<'a> scoped_cell::ApplyL<'a> for BridgeStateL {\n-    type Out = BridgeState<'a>;\n-}\n-\n-thread_local! {\n-    static BRIDGE_STATE: scoped_cell::ScopedCell<BridgeStateL> =\n-        scoped_cell::ScopedCell::new(BridgeState::NotConnected);\n-}\n-\n-impl BridgeState<'_> {\n-    /// Take exclusive control of the thread-local\n-    /// `BridgeState`, and pass it to `f`, mutably.\n-    /// The state will be restored after `f` exits, even\n-    /// by panic, including modifications made to it by `f`.\n-    ///\n-    /// N.B., while `f` is running, the thread-local state\n-    /// is `BridgeState::InUse`.\n-    fn with<R>(f: impl FnOnce(&mut BridgeState<'_>) -> R) -> R {\n-        BRIDGE_STATE.with(|state| {\n-            state.replace(BridgeState::InUse, |mut state| {\n-                // FIXME(#52812) pass `f` directly to `replace` when `RefMutL` is gone\n-                f(&mut state)\n-            })\n-        })\n-    }\n-}\n-\n-impl Bridge<'_> {\n-    pub(crate) fn is_available() -> bool {\n-        BridgeState::with(|state| match state {\n-            BridgeState::Connected(_) | BridgeState::InUse => true,\n-            BridgeState::NotConnected => false,\n-        })\n-    }\n-\n-    fn enter<R>(self, f: impl FnOnce() -> R) -> R {\n-        let force_show_panics = self.force_show_panics;\n-        // Hide the default panic output within `proc_macro` expansions.\n-        // NB. the server can't do this because it may use a different libstd.\n-        static HIDE_PANICS_DURING_EXPANSION: Once = Once::new();\n-        HIDE_PANICS_DURING_EXPANSION.call_once(|| {\n-            let prev = panic::take_hook();\n-            panic::set_hook(Box::new(move |info| {\n-                let show = BridgeState::with(|state| match state {\n-                    BridgeState::NotConnected => true,\n-                    BridgeState::Connected(_) | BridgeState::InUse => force_show_panics,\n-                });\n-                if show {\n-                    prev(info)\n-                }\n-            }));\n-        });\n-\n-        BRIDGE_STATE.with(|state| state.set(BridgeState::Connected(self), f))\n-    }\n-\n-    fn with<R>(f: impl FnOnce(&mut Bridge<'_>) -> R) -> R {\n-        BridgeState::with(|state| match state {\n-            BridgeState::NotConnected => {\n-                panic!(\"procedural macro API is used outside of a procedural macro\");\n-            }\n-            BridgeState::InUse => {\n-                panic!(\"procedural macro API is used while it's already in use\");\n-            }\n-            BridgeState::Connected(bridge) => f(bridge),\n-        })\n-    }\n-}\n-\n-/// A client-side RPC entry-point, which may be using a different `proc_macro`\n-/// from the one used by the server, but can be invoked compatibly.\n-///\n-/// Note that the (phantom) `I` (\"input\") and `O` (\"output\") type parameters\n-/// decorate the `Client<I, O>` with the RPC \"interface\" of the entry-point, but\n-/// do not themselves participate in ABI, at all, only facilitate type-checking.\n-///\n-/// E.g. `Client<TokenStream, TokenStream>` is the common proc macro interface,\n-/// used for `#[proc_macro] fn foo(input: TokenStream) -> TokenStream`,\n-/// indicating that the RPC input and output will be serialized token streams,\n-/// and forcing the use of APIs that take/return `S::TokenStream`, server-side.\n-#[repr(C)]\n-pub struct Client<I, O> {\n-    // FIXME(eddyb) use a reference to the `static COUNTERS`, instead of\n-    // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n-    pub(super) get_handle_counters: extern \"C\" fn() -> &'static HandleCounters,\n-\n-    pub(super) run: extern \"C\" fn(Bridge<'_>) -> Buffer,\n-\n-    pub(super) _marker: PhantomData<fn(I) -> O>,\n-}\n-\n-impl<I, O> Copy for Client<I, O> {}\n-impl<I, O> Clone for Client<I, O> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-/// Client-side helper for handling client panics, entering the bridge,\n-/// deserializing input and serializing output.\n-// FIXME(eddyb) maybe replace `Bridge::enter` with this?\n-fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n-    mut bridge: Bridge<'_>,\n-    f: impl FnOnce(A) -> R,\n-) -> Buffer {\n-    // The initial `cached_buffer` contains the input.\n-    let mut buf = bridge.cached_buffer.take();\n-\n-    panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-        bridge.enter(|| {\n-            let reader = &mut &buf[..];\n-            let input = A::decode(reader, &mut ());\n-\n-            // Put the `cached_buffer` back in the `Bridge`, for requests.\n-            Bridge::with(|bridge| bridge.cached_buffer = buf.take());\n-\n-            let output = f(input);\n-\n-            // Take the `cached_buffer` back out, for the output value.\n-            buf = Bridge::with(|bridge| bridge.cached_buffer.take());\n-\n-            // HACK(eddyb) Separate encoding a success value (`Ok(output)`)\n-            // from encoding a panic (`Err(e: PanicMessage)`) to avoid\n-            // having handles outside the `bridge.enter(|| ...)` scope, and\n-            // to catch panics that could happen while encoding the success.\n-            //\n-            // Note that panics should be impossible beyond this point, but\n-            // this is defensively trying to avoid any accidental panicking\n-            // reaching the `extern \"C\"` (which should `abort` but might not\n-            // at the moment, so this is also potentially preventing UB).\n-            buf.clear();\n-            Ok::<_, ()>(output).encode(&mut buf, &mut ());\n-        })\n-    }))\n-    .map_err(PanicMessage::from)\n-    .unwrap_or_else(|e| {\n-        buf.clear();\n-        Err::<(), _>(e).encode(&mut buf, &mut ());\n-    });\n-    buf\n-}\n-\n-impl Client<super::super::TokenStream, super::super::TokenStream> {\n-    pub const fn expand1(\n-        f: impl Fn(super::super::TokenStream) -> super::super::TokenStream + Copy,\n-    ) -> Self {\n-        Client {\n-            get_handle_counters: HandleCounters::get,\n-            run: super::selfless_reify::reify_to_extern_c_fn_hrt_bridge(move |bridge| {\n-                run_client(bridge, |input| f(super::super::TokenStream(input)).0)\n-            }),\n-            _marker: PhantomData,\n-        }\n-    }\n-}\n-\n-impl Client<(super::super::TokenStream, super::super::TokenStream), super::super::TokenStream> {\n-    pub const fn expand2(\n-        f: impl Fn(super::super::TokenStream, super::super::TokenStream) -> super::super::TokenStream\n-            + Copy,\n-    ) -> Self {\n-        Client {\n-            get_handle_counters: HandleCounters::get,\n-            run: super::selfless_reify::reify_to_extern_c_fn_hrt_bridge(move |bridge| {\n-                run_client(bridge, |(input, input2)| {\n-                    f(super::super::TokenStream(input), super::super::TokenStream(input2)).0\n-                })\n-            }),\n-            _marker: PhantomData,\n-        }\n-    }\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-pub enum ProcMacro {\n-    CustomDerive {\n-        trait_name: &'static str,\n-        attributes: &'static [&'static str],\n-        client: Client<super::super::TokenStream, super::super::TokenStream>,\n-    },\n-\n-    Attr {\n-        name: &'static str,\n-        client: Client<\n-            (super::super::TokenStream, super::super::TokenStream),\n-            super::super::TokenStream,\n-        >,\n-    },\n-\n-    Bang {\n-        name: &'static str,\n-        client: Client<super::super::TokenStream, super::super::TokenStream>,\n-    },\n-}\n-\n-impl ProcMacro {\n-    pub fn name(&self) -> &'static str {\n-        match self {\n-            ProcMacro::CustomDerive { trait_name, .. } => trait_name,\n-            ProcMacro::Attr { name, .. } => name,\n-            ProcMacro::Bang { name, .. } => name,\n-        }\n-    }\n-\n-    pub const fn custom_derive(\n-        trait_name: &'static str,\n-        attributes: &'static [&'static str],\n-        expand: impl Fn(super::super::TokenStream) -> super::super::TokenStream + Copy,\n-    ) -> Self {\n-        ProcMacro::CustomDerive { trait_name, attributes, client: Client::expand1(expand) }\n-    }\n-\n-    pub const fn attr(\n-        name: &'static str,\n-        expand: impl Fn(super::super::TokenStream, super::super::TokenStream) -> super::super::TokenStream\n-            + Copy,\n-    ) -> Self {\n-        ProcMacro::Attr { name, client: Client::expand2(expand) }\n-    }\n-\n-    pub const fn bang(\n-        name: &'static str,\n-        expand: impl Fn(super::super::TokenStream) -> super::super::TokenStream + Copy,\n-    ) -> Self {\n-        ProcMacro::Bang { name, client: Client::expand1(expand) }\n-    }\n-}"}, {"sha": "d371ae3cea0981a01f38cb261fc39e203b495130", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/closure.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fclosure.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,32 +0,0 @@\n-//! Closure type (equivalent to `&mut dyn FnMut(A) -> R`) that's `repr(C)`.\n-\n-use std::marker::PhantomData;\n-\n-#[repr(C)]\n-pub struct Closure<'a, A, R> {\n-    call: unsafe extern \"C\" fn(*mut Env, A) -> R,\n-    env: *mut Env,\n-    // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual way of doing\n-    // this, but that requires unstable features. rust-analyzer uses this code\n-    // and avoids unstable features.\n-    //\n-    // The `'a` lifetime parameter represents the lifetime of `Env`.\n-    _marker: PhantomData<*mut &'a mut ()>,\n-}\n-\n-struct Env;\n-\n-impl<'a, A, R, F: FnMut(A) -> R> From<&'a mut F> for Closure<'a, A, R> {\n-    fn from(f: &'a mut F) -> Self {\n-        unsafe extern \"C\" fn call<A, R, F: FnMut(A) -> R>(env: *mut Env, arg: A) -> R {\n-            (*(env as *mut _ as *mut F))(arg)\n-        }\n-        Closure { call: call::<A, R, F>, env: f as *mut _ as *mut Env, _marker: PhantomData }\n-    }\n-}\n-\n-impl<'a, A, R> Closure<'a, A, R> {\n-    pub fn call(&mut self, arg: A) -> R {\n-        unsafe { (self.call)(self.env, arg) }\n-    }\n-}"}, {"sha": "c219a9465d39f2d091133298a697049cd0712c67", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/handle.rs", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fhandle.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,89 +0,0 @@\n-//! Server-side handles and storage for per-handle data.\n-\n-use std::collections::{BTreeMap, HashMap};\n-use std::hash::{BuildHasher, Hash};\n-use std::num::NonZeroU32;\n-use std::ops::{Index, IndexMut};\n-use std::sync::atomic::{AtomicUsize, Ordering};\n-\n-pub(super) type Handle = NonZeroU32;\n-\n-/// A store that associates values of type `T` with numeric handles. A value can\n-/// be looked up using its handle.\n-pub(super) struct OwnedStore<T: 'static> {\n-    counter: &'static AtomicUsize,\n-    data: BTreeMap<Handle, T>,\n-}\n-\n-impl<T> OwnedStore<T> {\n-    pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n-        // Ensure the handle counter isn't 0, which would panic later,\n-        // when `NonZeroU32::new` (aka `Handle::new`) is called in `alloc`.\n-        assert_ne!(counter.load(Ordering::SeqCst), 0);\n-\n-        OwnedStore { counter, data: BTreeMap::new() }\n-    }\n-}\n-\n-impl<T> OwnedStore<T> {\n-    pub(super) fn alloc(&mut self, x: T) -> Handle {\n-        let counter = self.counter.fetch_add(1, Ordering::SeqCst);\n-        let handle = Handle::new(counter as u32).expect(\"`proc_macro` handle counter overflowed\");\n-        assert!(self.data.insert(handle, x).is_none());\n-        handle\n-    }\n-\n-    pub(super) fn take(&mut self, h: Handle) -> T {\n-        self.data.remove(&h).expect(\"use-after-free in `proc_macro` handle\")\n-    }\n-}\n-\n-impl<T> Index<Handle> for OwnedStore<T> {\n-    type Output = T;\n-    fn index(&self, h: Handle) -> &T {\n-        self.data.get(&h).expect(\"use-after-free in `proc_macro` handle\")\n-    }\n-}\n-\n-impl<T> IndexMut<Handle> for OwnedStore<T> {\n-    fn index_mut(&mut self, h: Handle) -> &mut T {\n-        self.data.get_mut(&h).expect(\"use-after-free in `proc_macro` handle\")\n-    }\n-}\n-\n-// HACK(eddyb) deterministic `std::collections::hash_map::RandomState` replacement\n-// that doesn't require adding any dependencies to `proc_macro` (like `rustc-hash`).\n-#[derive(Clone)]\n-struct NonRandomState;\n-\n-impl BuildHasher for NonRandomState {\n-    type Hasher = std::collections::hash_map::DefaultHasher;\n-    #[inline]\n-    fn build_hasher(&self) -> Self::Hasher {\n-        Self::Hasher::new()\n-    }\n-}\n-\n-/// Like `OwnedStore`, but avoids storing any value more than once.\n-pub(super) struct InternedStore<T: 'static> {\n-    owned: OwnedStore<T>,\n-    interner: HashMap<T, Handle, NonRandomState>,\n-}\n-\n-impl<T: Copy + Eq + Hash> InternedStore<T> {\n-    pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n-        InternedStore {\n-            owned: OwnedStore::new(counter),\n-            interner: HashMap::with_hasher(NonRandomState),\n-        }\n-    }\n-\n-    pub(super) fn alloc(&mut self, x: T) -> Handle {\n-        let owned = &mut self.owned;\n-        *self.interner.entry(x).or_insert_with(|| owned.alloc(x))\n-    }\n-\n-    pub(super) fn copy(&mut self, h: Handle) -> T {\n-        self.owned[h]\n-    }\n-}"}, {"sha": "4967da4931a28758c03226f211931b6e540ecf09", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/mod.rs", "status": "removed", "additions": 0, "deletions": 451, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fmod.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,451 +0,0 @@\n-//! Internal interface for communicating between a `proc_macro` client\n-//! (a proc macro crate) and a `proc_macro` server (a compiler front-end).\n-//!\n-//! Serialization (with C ABI buffers) and unique integer handles are employed\n-//! to allow safely interfacing between two copies of `proc_macro` built\n-//! (from the same source) by different compilers with potentially mismatching\n-//! Rust ABIs (e.g., stage0/bin/rustc vs stage1/bin/rustc during bootstrap).\n-\n-#![deny(unsafe_code)]\n-\n-pub use super::{Delimiter, Level, LineColumn, Spacing};\n-use std::fmt;\n-use std::hash::Hash;\n-use std::marker;\n-use std::mem;\n-use std::ops::Bound;\n-use std::panic;\n-use std::sync::atomic::AtomicUsize;\n-use std::sync::Once;\n-use std::thread;\n-\n-/// Higher-order macro describing the server RPC API, allowing automatic\n-/// generation of type-safe Rust APIs, both client-side and server-side.\n-///\n-/// `with_api!(MySelf, my_self, my_macro)` expands to:\n-/// ```rust,ignore (pseudo-code)\n-/// my_macro! {\n-///     // ...\n-///     Literal {\n-///         // ...\n-///         fn character(ch: char) -> MySelf::Literal;\n-///         // ...\n-///         fn span(my_self: &MySelf::Literal) -> MySelf::Span;\n-///         fn set_span(my_self: &mut MySelf::Literal, span: MySelf::Span);\n-///     },\n-///     // ...\n-/// }\n-/// ```\n-///\n-/// The first two arguments serve to customize the arguments names\n-/// and argument/return types, to enable several different usecases:\n-///\n-/// If `my_self` is just `self`, then each `fn` signature can be used\n-/// as-is for a method. If it's anything else (`self_` in practice),\n-/// then the signatures don't have a special `self` argument, and\n-/// can, therefore, have a different one introduced.\n-///\n-/// If `MySelf` is just `Self`, then the types are only valid inside\n-/// a trait or a trait impl, where the trait has associated types\n-/// for each of the API types. If non-associated types are desired,\n-/// a module name (`self` in practice) can be used instead of `Self`.\n-macro_rules! with_api {\n-    ($S:ident, $self:ident, $m:ident) => {\n-        $m! {\n-            FreeFunctions {\n-                fn drop($self: $S::FreeFunctions);\n-                fn track_env_var(var: &str, value: Option<&str>);\n-                fn track_path(path: &str);\n-            },\n-            TokenStream {\n-                fn drop($self: $S::TokenStream);\n-                fn clone($self: &$S::TokenStream) -> $S::TokenStream;\n-                fn is_empty($self: &$S::TokenStream) -> bool;\n-                fn expand_expr($self: &$S::TokenStream) -> Result<$S::TokenStream, ()>;\n-                fn from_str(src: &str) -> $S::TokenStream;\n-                fn to_string($self: &$S::TokenStream) -> String;\n-                fn from_token_tree(\n-                    tree: TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>,\n-                ) -> $S::TokenStream;\n-                fn concat_trees(\n-                    base: Option<$S::TokenStream>,\n-                    trees: Vec<TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>>,\n-                ) -> $S::TokenStream;\n-                fn concat_streams(\n-                    base: Option<$S::TokenStream>,\n-                    streams: Vec<$S::TokenStream>,\n-                ) -> $S::TokenStream;\n-                fn into_trees(\n-                    $self: $S::TokenStream\n-                ) -> Vec<TokenTree<$S::Group, $S::Punct, $S::Ident, $S::Literal>>;\n-            },\n-            Group {\n-                fn drop($self: $S::Group);\n-                fn clone($self: &$S::Group) -> $S::Group;\n-                fn new(delimiter: Delimiter, stream: Option<$S::TokenStream>) -> $S::Group;\n-                fn delimiter($self: &$S::Group) -> Delimiter;\n-                fn stream($self: &$S::Group) -> $S::TokenStream;\n-                fn span($self: &$S::Group) -> $S::Span;\n-                fn span_open($self: &$S::Group) -> $S::Span;\n-                fn span_close($self: &$S::Group) -> $S::Span;\n-                fn set_span($self: &mut $S::Group, span: $S::Span);\n-            },\n-            Punct {\n-                fn new(ch: char, spacing: Spacing) -> $S::Punct;\n-                fn as_char($self: $S::Punct) -> char;\n-                fn spacing($self: $S::Punct) -> Spacing;\n-                fn span($self: $S::Punct) -> $S::Span;\n-                fn with_span($self: $S::Punct, span: $S::Span) -> $S::Punct;\n-            },\n-            Ident {\n-                fn new(string: &str, span: $S::Span, is_raw: bool) -> $S::Ident;\n-                fn span($self: $S::Ident) -> $S::Span;\n-                fn with_span($self: $S::Ident, span: $S::Span) -> $S::Ident;\n-            },\n-            Literal {\n-                fn drop($self: $S::Literal);\n-                fn clone($self: &$S::Literal) -> $S::Literal;\n-                fn from_str(s: &str) -> Result<$S::Literal, ()>;\n-                fn to_string($self: &$S::Literal) -> String;\n-                fn debug_kind($self: &$S::Literal) -> String;\n-                fn symbol($self: &$S::Literal) -> String;\n-                fn suffix($self: &$S::Literal) -> Option<String>;\n-                fn integer(n: &str) -> $S::Literal;\n-                fn typed_integer(n: &str, kind: &str) -> $S::Literal;\n-                fn float(n: &str) -> $S::Literal;\n-                fn f32(n: &str) -> $S::Literal;\n-                fn f64(n: &str) -> $S::Literal;\n-                fn string(string: &str) -> $S::Literal;\n-                fn character(ch: char) -> $S::Literal;\n-                fn byte_string(bytes: &[u8]) -> $S::Literal;\n-                fn span($self: &$S::Literal) -> $S::Span;\n-                fn set_span($self: &mut $S::Literal, span: $S::Span);\n-                fn subspan(\n-                    $self: &$S::Literal,\n-                    start: Bound<usize>,\n-                    end: Bound<usize>,\n-                ) -> Option<$S::Span>;\n-            },\n-            SourceFile {\n-                fn drop($self: $S::SourceFile);\n-                fn clone($self: &$S::SourceFile) -> $S::SourceFile;\n-                fn eq($self: &$S::SourceFile, other: &$S::SourceFile) -> bool;\n-                fn path($self: &$S::SourceFile) -> String;\n-                fn is_real($self: &$S::SourceFile) -> bool;\n-            },\n-            MultiSpan {\n-                fn drop($self: $S::MultiSpan);\n-                fn new() -> $S::MultiSpan;\n-                fn push($self: &mut $S::MultiSpan, span: $S::Span);\n-            },\n-            Diagnostic {\n-                fn drop($self: $S::Diagnostic);\n-                fn new(level: Level, msg: &str, span: $S::MultiSpan) -> $S::Diagnostic;\n-                fn sub(\n-                    $self: &mut $S::Diagnostic,\n-                    level: Level,\n-                    msg: &str,\n-                    span: $S::MultiSpan,\n-                );\n-                fn emit($self: $S::Diagnostic);\n-            },\n-            Span {\n-                fn debug($self: $S::Span) -> String;\n-                fn def_site() -> $S::Span;\n-                fn call_site() -> $S::Span;\n-                fn mixed_site() -> $S::Span;\n-                fn source_file($self: $S::Span) -> $S::SourceFile;\n-                fn parent($self: $S::Span) -> Option<$S::Span>;\n-                fn source($self: $S::Span) -> $S::Span;\n-                fn start($self: $S::Span) -> LineColumn;\n-                fn end($self: $S::Span) -> LineColumn;\n-                fn before($self: $S::Span) -> $S::Span;\n-                fn after($self: $S::Span) -> $S::Span;\n-                fn join($self: $S::Span, other: $S::Span) -> Option<$S::Span>;\n-                fn resolved_at($self: $S::Span, at: $S::Span) -> $S::Span;\n-                fn source_text($self: $S::Span) -> Option<String>;\n-                fn save_span($self: $S::Span) -> usize;\n-                fn recover_proc_macro_span(id: usize) -> $S::Span;\n-            },\n-        }\n-    };\n-}\n-\n-// FIXME(eddyb) this calls `encode` for each argument, but in reverse,\n-// to match the ordering in `reverse_decode`.\n-macro_rules! reverse_encode {\n-    ($writer:ident;) => {};\n-    ($writer:ident; $first:ident $(, $rest:ident)*) => {\n-        reverse_encode!($writer; $($rest),*);\n-        $first.encode(&mut $writer, &mut ());\n-    }\n-}\n-\n-// FIXME(eddyb) this calls `decode` for each argument, but in reverse,\n-// to avoid borrow conflicts from borrows started by `&mut` arguments.\n-macro_rules! reverse_decode {\n-    ($reader:ident, $s:ident;) => {};\n-    ($reader:ident, $s:ident; $first:ident: $first_ty:ty $(, $rest:ident: $rest_ty:ty)*) => {\n-        reverse_decode!($reader, $s; $($rest: $rest_ty),*);\n-        let $first = <$first_ty>::decode(&mut $reader, $s);\n-    }\n-}\n-\n-#[allow(unsafe_code)]\n-mod buffer;\n-#[forbid(unsafe_code)]\n-pub mod client;\n-#[allow(unsafe_code)]\n-mod closure;\n-#[forbid(unsafe_code)]\n-mod handle;\n-#[macro_use]\n-#[forbid(unsafe_code)]\n-mod rpc;\n-#[allow(unsafe_code)]\n-mod scoped_cell;\n-#[allow(unsafe_code)]\n-mod selfless_reify;\n-#[forbid(unsafe_code)]\n-pub mod server;\n-\n-use buffer::Buffer;\n-pub use rpc::PanicMessage;\n-use rpc::{Decode, DecodeMut, Encode, Reader, Writer};\n-\n-/// An active connection between a server and a client.\n-/// The server creates the bridge (`Bridge::run_server` in `server.rs`),\n-/// then passes it to the client through the function pointer in the `run`\n-/// field of `client::Client`. The client holds its copy of the `Bridge`\n-/// in TLS during its execution (`Bridge::{enter, with}` in `client.rs`).\n-#[repr(C)]\n-pub struct Bridge<'a> {\n-    /// Reusable buffer (only `clear`-ed, never shrunk), primarily\n-    /// used for making requests, but also for passing input to client.\n-    cached_buffer: Buffer,\n-\n-    /// Server-side function that the client uses to make requests.\n-    dispatch: closure::Closure<'a, Buffer, Buffer>,\n-\n-    /// If 'true', always invoke the default panic hook\n-    force_show_panics: bool,\n-\n-    // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual way of doing\n-    // this, but that requires unstable features. rust-analyzer uses this code\n-    // and avoids unstable features.\n-    _marker: marker::PhantomData<*mut ()>,\n-}\n-\n-#[forbid(unsafe_code)]\n-#[allow(non_camel_case_types)]\n-mod api_tags {\n-    use super::rpc::{DecodeMut, Encode, Reader, Writer};\n-\n-    macro_rules! declare_tags {\n-        ($($name:ident {\n-            $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)*;)*\n-        }),* $(,)?) => {\n-            $(\n-                pub(super) enum $name {\n-                    $($method),*\n-                }\n-                rpc_encode_decode!(enum $name { $($method),* });\n-            )*\n-\n-            pub(super) enum Method {\n-                $($name($name)),*\n-            }\n-            rpc_encode_decode!(enum Method { $($name(m)),* });\n-        }\n-    }\n-    with_api!(self, self, declare_tags);\n-}\n-\n-/// Helper to wrap associated types to allow trait impl dispatch.\n-/// That is, normally a pair of impls for `T::Foo` and `T::Bar`\n-/// can overlap, but if the impls are, instead, on types like\n-/// `Marked<T::Foo, Foo>` and `Marked<T::Bar, Bar>`, they can't.\n-trait Mark {\n-    type Unmarked;\n-    fn mark(unmarked: Self::Unmarked) -> Self;\n-}\n-\n-/// Unwrap types wrapped by `Mark::mark` (see `Mark` for details).\n-trait Unmark {\n-    type Unmarked;\n-    fn unmark(self) -> Self::Unmarked;\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-struct Marked<T, M> {\n-    value: T,\n-    _marker: marker::PhantomData<M>,\n-}\n-\n-impl<T, M> Mark for Marked<T, M> {\n-    type Unmarked = T;\n-    fn mark(unmarked: Self::Unmarked) -> Self {\n-        Marked { value: unmarked, _marker: marker::PhantomData }\n-    }\n-}\n-impl<T, M> Unmark for Marked<T, M> {\n-    type Unmarked = T;\n-    fn unmark(self) -> Self::Unmarked {\n-        self.value\n-    }\n-}\n-impl<'a, T, M> Unmark for &'a Marked<T, M> {\n-    type Unmarked = &'a T;\n-    fn unmark(self) -> Self::Unmarked {\n-        &self.value\n-    }\n-}\n-impl<'a, T, M> Unmark for &'a mut Marked<T, M> {\n-    type Unmarked = &'a mut T;\n-    fn unmark(self) -> Self::Unmarked {\n-        &mut self.value\n-    }\n-}\n-\n-impl<T: Mark> Mark for Vec<T> {\n-    type Unmarked = Vec<T::Unmarked>;\n-    fn mark(unmarked: Self::Unmarked) -> Self {\n-        // Should be a no-op due to std's in-place collect optimizations.\n-        unmarked.into_iter().map(T::mark).collect()\n-    }\n-}\n-impl<T: Unmark> Unmark for Vec<T> {\n-    type Unmarked = Vec<T::Unmarked>;\n-    fn unmark(self) -> Self::Unmarked {\n-        // Should be a no-op due to std's in-place collect optimizations.\n-        self.into_iter().map(T::unmark).collect()\n-    }\n-}\n-\n-macro_rules! mark_noop {\n-    ($($ty:ty),* $(,)?) => {\n-        $(\n-            impl Mark for $ty {\n-                type Unmarked = Self;\n-                fn mark(unmarked: Self::Unmarked) -> Self {\n-                    unmarked\n-                }\n-            }\n-            impl Unmark for $ty {\n-                type Unmarked = Self;\n-                fn unmark(self) -> Self::Unmarked {\n-                    self\n-                }\n-            }\n-        )*\n-    }\n-}\n-mark_noop! {\n-    (),\n-    bool,\n-    char,\n-    &'_ [u8],\n-    &'_ str,\n-    String,\n-    usize,\n-    Delimiter,\n-    Level,\n-    LineColumn,\n-    Spacing,\n-}\n-\n-rpc_encode_decode!(\n-    enum Delimiter {\n-        Parenthesis,\n-        Brace,\n-        Bracket,\n-        None,\n-    }\n-);\n-rpc_encode_decode!(\n-    enum Level {\n-        Error,\n-        Warning,\n-        Note,\n-        Help,\n-    }\n-);\n-rpc_encode_decode!(struct LineColumn { line, column });\n-rpc_encode_decode!(\n-    enum Spacing {\n-        Alone,\n-        Joint,\n-    }\n-);\n-\n-macro_rules! mark_compound {\n-    (enum $name:ident <$($T:ident),+> { $($variant:ident $(($field:ident))?),* $(,)? }) => {\n-        impl<$($T: Mark),+> Mark for $name <$($T),+> {\n-            type Unmarked = $name <$($T::Unmarked),+>;\n-            fn mark(unmarked: Self::Unmarked) -> Self {\n-                match unmarked {\n-                    $($name::$variant $(($field))? => {\n-                        $name::$variant $((Mark::mark($field)))?\n-                    })*\n-                }\n-            }\n-        }\n-\n-        impl<$($T: Unmark),+> Unmark for $name <$($T),+> {\n-            type Unmarked = $name <$($T::Unmarked),+>;\n-            fn unmark(self) -> Self::Unmarked {\n-                match self {\n-                    $($name::$variant $(($field))? => {\n-                        $name::$variant $((Unmark::unmark($field)))?\n-                    })*\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-macro_rules! compound_traits {\n-    ($($t:tt)*) => {\n-        rpc_encode_decode!($($t)*);\n-        mark_compound!($($t)*);\n-    };\n-}\n-\n-compound_traits!(\n-    enum Bound<T> {\n-        Included(x),\n-        Excluded(x),\n-        Unbounded,\n-    }\n-);\n-\n-compound_traits!(\n-    enum Option<T> {\n-        Some(t),\n-        None,\n-    }\n-);\n-\n-compound_traits!(\n-    enum Result<T, E> {\n-        Ok(t),\n-        Err(e),\n-    }\n-);\n-\n-#[derive(Clone)]\n-pub enum TokenTree<G, P, I, L> {\n-    Group(G),\n-    Punct(P),\n-    Ident(I),\n-    Literal(L),\n-}\n-\n-compound_traits!(\n-    enum TokenTree<G, P, I, L> {\n-        Group(tt),\n-        Punct(tt),\n-        Ident(tt),\n-        Literal(tt),\n-    }\n-);"}, {"sha": "e9d7a46c06f6d270d66e848788e9f01fbd776e54", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/rpc.rs", "status": "removed", "additions": 0, "deletions": 304, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Frpc.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,304 +0,0 @@\n-//! Serialization for client-server communication.\n-\n-use std::any::Any;\n-use std::char;\n-use std::io::Write;\n-use std::num::NonZeroU32;\n-use std::str;\n-\n-pub(super) type Writer = super::buffer::Buffer;\n-\n-pub(super) trait Encode<S>: Sized {\n-    fn encode(self, w: &mut Writer, s: &mut S);\n-}\n-\n-pub(super) type Reader<'a> = &'a [u8];\n-\n-pub(super) trait Decode<'a, 's, S>: Sized {\n-    fn decode(r: &mut Reader<'a>, s: &'s S) -> Self;\n-}\n-\n-pub(super) trait DecodeMut<'a, 's, S>: Sized {\n-    fn decode(r: &mut Reader<'a>, s: &'s mut S) -> Self;\n-}\n-\n-macro_rules! rpc_encode_decode {\n-    (le $ty:ty) => {\n-        impl<S> Encode<S> for $ty {\n-            fn encode(self, w: &mut Writer, _: &mut S) {\n-                w.extend_from_array(&self.to_le_bytes());\n-            }\n-        }\n-\n-        impl<S> DecodeMut<'_, '_, S> for $ty {\n-            fn decode(r: &mut Reader<'_>, _: &mut S) -> Self {\n-                const N: usize = ::std::mem::size_of::<$ty>();\n-\n-                let mut bytes = [0; N];\n-                bytes.copy_from_slice(&r[..N]);\n-                *r = &r[N..];\n-\n-                Self::from_le_bytes(bytes)\n-            }\n-        }\n-    };\n-    (struct $name:ident $(<$($T:ident),+>)? { $($field:ident),* $(,)? }) => {\n-        impl<S, $($($T: Encode<S>),+)?> Encode<S> for $name $(<$($T),+>)? {\n-            fn encode(self, w: &mut Writer, s: &mut S) {\n-                $(self.$field.encode(w, s);)*\n-            }\n-        }\n-\n-        impl<'a, S, $($($T: for<'s> DecodeMut<'a, 's, S>),+)?> DecodeMut<'a, '_, S>\n-            for $name $(<$($T),+>)?\n-        {\n-            fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-                $name {\n-                    $($field: DecodeMut::decode(r, s)),*\n-                }\n-            }\n-        }\n-    };\n-    (enum $name:ident $(<$($T:ident),+>)? { $($variant:ident $(($field:ident))*),* $(,)? }) => {\n-        impl<S, $($($T: Encode<S>),+)?> Encode<S> for $name $(<$($T),+>)? {\n-            fn encode(self, w: &mut Writer, s: &mut S) {\n-                // HACK(eddyb): `Tag` enum duplicated between the\n-                // two impls as there's no other place to stash it.\n-                #[allow(non_upper_case_globals)]\n-                mod tag {\n-                    #[repr(u8)] enum Tag { $($variant),* }\n-\n-                    $(pub const $variant: u8 = Tag::$variant as u8;)*\n-                }\n-\n-                match self {\n-                    $($name::$variant $(($field))* => {\n-                        tag::$variant.encode(w, s);\n-                        $($field.encode(w, s);)*\n-                    })*\n-                }\n-            }\n-        }\n-\n-        impl<'a, S, $($($T: for<'s> DecodeMut<'a, 's, S>),+)?> DecodeMut<'a, '_, S>\n-            for $name $(<$($T),+>)?\n-        {\n-            fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-                // HACK(eddyb): `Tag` enum duplicated between the\n-                // two impls as there's no other place to stash it.\n-                #[allow(non_upper_case_globals)]\n-                mod tag {\n-                    #[repr(u8)] enum Tag { $($variant),* }\n-\n-                    $(pub const $variant: u8 = Tag::$variant as u8;)*\n-                }\n-\n-                match u8::decode(r, s) {\n-                    $(tag::$variant => {\n-                        $(let $field = DecodeMut::decode(r, s);)*\n-                        $name::$variant $(($field))*\n-                    })*\n-                    _ => unreachable!(),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<S> Encode<S> for () {\n-    fn encode(self, _: &mut Writer, _: &mut S) {}\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for () {\n-    fn decode(_: &mut Reader<'_>, _: &mut S) -> Self {}\n-}\n-\n-impl<S> Encode<S> for u8 {\n-    fn encode(self, w: &mut Writer, _: &mut S) {\n-        w.push(self);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for u8 {\n-    fn decode(r: &mut Reader<'_>, _: &mut S) -> Self {\n-        let x = r[0];\n-        *r = &r[1..];\n-        x\n-    }\n-}\n-\n-rpc_encode_decode!(le u32);\n-rpc_encode_decode!(le usize);\n-\n-impl<S> Encode<S> for bool {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        (self as u8).encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for bool {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        match u8::decode(r, s) {\n-            0 => false,\n-            1 => true,\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n-impl<S> Encode<S> for char {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        (self as u32).encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for char {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        char::from_u32(u32::decode(r, s)).unwrap()\n-    }\n-}\n-\n-impl<S> Encode<S> for NonZeroU32 {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.get().encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for NonZeroU32 {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        Self::new(u32::decode(r, s)).unwrap()\n-    }\n-}\n-\n-impl<S, A: Encode<S>, B: Encode<S>> Encode<S> for (A, B) {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.0.encode(w, s);\n-        self.1.encode(w, s);\n-    }\n-}\n-\n-impl<'a, S, A: for<'s> DecodeMut<'a, 's, S>, B: for<'s> DecodeMut<'a, 's, S>> DecodeMut<'a, '_, S>\n-    for (A, B)\n-{\n-    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-        (DecodeMut::decode(r, s), DecodeMut::decode(r, s))\n-    }\n-}\n-\n-impl<S> Encode<S> for &[u8] {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.len().encode(w, s);\n-        w.write_all(self).unwrap();\n-    }\n-}\n-\n-impl<'a, S> DecodeMut<'a, '_, S> for &'a [u8] {\n-    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-        let len = usize::decode(r, s);\n-        let xs = &r[..len];\n-        *r = &r[len..];\n-        xs\n-    }\n-}\n-\n-impl<S> Encode<S> for &str {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.as_bytes().encode(w, s);\n-    }\n-}\n-\n-impl<'a, S> DecodeMut<'a, '_, S> for &'a str {\n-    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-        str::from_utf8(<&[u8]>::decode(r, s)).unwrap()\n-    }\n-}\n-\n-impl<S> Encode<S> for String {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self[..].encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for String {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        <&str>::decode(r, s).to_string()\n-    }\n-}\n-\n-impl<S, T: Encode<S>> Encode<S> for Vec<T> {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.len().encode(w, s);\n-        for x in self {\n-            x.encode(w, s);\n-        }\n-    }\n-}\n-\n-impl<'a, S, T: for<'s> DecodeMut<'a, 's, S>> DecodeMut<'a, '_, S> for Vec<T> {\n-    fn decode(r: &mut Reader<'a>, s: &mut S) -> Self {\n-        let len = usize::decode(r, s);\n-        let mut vec = Vec::with_capacity(len);\n-        for _ in 0..len {\n-            vec.push(T::decode(r, s));\n-        }\n-        vec\n-    }\n-}\n-\n-/// Simplified version of panic payloads, ignoring\n-/// types other than `&'static str` and `String`.\n-pub enum PanicMessage {\n-    StaticStr(&'static str),\n-    String(String),\n-    Unknown,\n-}\n-\n-impl From<Box<dyn Any + Send>> for PanicMessage {\n-    fn from(payload: Box<dyn Any + Send + 'static>) -> Self {\n-        if let Some(s) = payload.downcast_ref::<&'static str>() {\n-            return PanicMessage::StaticStr(s);\n-        }\n-        if let Ok(s) = payload.downcast::<String>() {\n-            return PanicMessage::String(*s);\n-        }\n-        PanicMessage::Unknown\n-    }\n-}\n-\n-impl Into<Box<dyn Any + Send>> for PanicMessage {\n-    fn into(self) -> Box<dyn Any + Send> {\n-        match self {\n-            PanicMessage::StaticStr(s) => Box::new(s),\n-            PanicMessage::String(s) => Box::new(s),\n-            PanicMessage::Unknown => {\n-                struct UnknownPanicMessage;\n-                Box::new(UnknownPanicMessage)\n-            }\n-        }\n-    }\n-}\n-\n-impl PanicMessage {\n-    pub fn as_str(&self) -> Option<&str> {\n-        match self {\n-            PanicMessage::StaticStr(s) => Some(s),\n-            PanicMessage::String(s) => Some(s),\n-            PanicMessage::Unknown => None,\n-        }\n-    }\n-}\n-\n-impl<S> Encode<S> for PanicMessage {\n-    fn encode(self, w: &mut Writer, s: &mut S) {\n-        self.as_str().encode(w, s);\n-    }\n-}\n-\n-impl<S> DecodeMut<'_, '_, S> for PanicMessage {\n-    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n-        match Option::<String>::decode(r, s) {\n-            Some(s) => PanicMessage::String(s),\n-            None => PanicMessage::Unknown,\n-        }\n-    }\n-}"}, {"sha": "2cde1f65adf9c484ab0aee45fe6c978fda30cbb9", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/scoped_cell.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fscoped_cell.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,81 +0,0 @@\n-//! `Cell` variant for (scoped) existential lifetimes.\n-\n-use std::cell::Cell;\n-use std::mem;\n-use std::ops::{Deref, DerefMut};\n-\n-/// Type lambda application, with a lifetime.\n-#[allow(unused_lifetimes)]\n-pub trait ApplyL<'a> {\n-    type Out;\n-}\n-\n-/// Type lambda taking a lifetime, i.e., `Lifetime -> Type`.\n-pub trait LambdaL: for<'a> ApplyL<'a> {}\n-\n-impl<T: for<'a> ApplyL<'a>> LambdaL for T {}\n-\n-// HACK(eddyb) work around projection limitations with a newtype\n-// FIXME(#52812) replace with `&'a mut <T as ApplyL<'b>>::Out`\n-pub struct RefMutL<'a, 'b, T: LambdaL>(&'a mut <T as ApplyL<'b>>::Out);\n-\n-impl<'a, 'b, T: LambdaL> Deref for RefMutL<'a, 'b, T> {\n-    type Target = <T as ApplyL<'b>>::Out;\n-    fn deref(&self) -> &Self::Target {\n-        self.0\n-    }\n-}\n-\n-impl<'a, 'b, T: LambdaL> DerefMut for RefMutL<'a, 'b, T> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.0\n-    }\n-}\n-\n-pub struct ScopedCell<T: LambdaL>(Cell<<T as ApplyL<'static>>::Out>);\n-\n-impl<T: LambdaL> ScopedCell<T> {\n-    pub const fn new(value: <T as ApplyL<'static>>::Out) -> Self {\n-        ScopedCell(Cell::new(value))\n-    }\n-\n-    /// Sets the value in `self` to `replacement` while\n-    /// running `f`, which gets the old value, mutably.\n-    /// The old value will be restored after `f` exits, even\n-    /// by panic, including modifications made to it by `f`.\n-    pub fn replace<'a, R>(\n-        &self,\n-        replacement: <T as ApplyL<'a>>::Out,\n-        f: impl for<'b, 'c> FnOnce(RefMutL<'b, 'c, T>) -> R,\n-    ) -> R {\n-        /// Wrapper that ensures that the cell always gets filled\n-        /// (with the original state, optionally changed by `f`),\n-        /// even if `f` had panicked.\n-        struct PutBackOnDrop<'a, T: LambdaL> {\n-            cell: &'a ScopedCell<T>,\n-            value: Option<<T as ApplyL<'static>>::Out>,\n-        }\n-\n-        impl<'a, T: LambdaL> Drop for PutBackOnDrop<'a, T> {\n-            fn drop(&mut self) {\n-                self.cell.0.set(self.value.take().unwrap());\n-            }\n-        }\n-\n-        let mut put_back_on_drop = PutBackOnDrop {\n-            cell: self,\n-            value: Some(self.0.replace(unsafe {\n-                let erased = mem::transmute_copy(&replacement);\n-                mem::forget(replacement);\n-                erased\n-            })),\n-        };\n-\n-        f(RefMutL(put_back_on_drop.value.as_mut().unwrap()))\n-    }\n-\n-    /// Sets the value in `self` to `value` while running `f`.\n-    pub fn set<R>(&self, value: <T as ApplyL<'_>>::Out, f: impl FnOnce() -> R) -> R {\n-        self.replace(value, |_| f())\n-    }\n-}"}, {"sha": "4ee4bb87c2bbdd348c552a0aa95703c4f0a8b3f1", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/selfless_reify.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fselfless_reify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fselfless_reify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fselfless_reify.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,83 +0,0 @@\n-//! Abstraction for creating `fn` pointers from any callable that *effectively*\n-//! has the equivalent of implementing `Default`, even if the compiler neither\n-//! provides `Default` nor allows reifying closures (i.e. creating `fn` pointers)\n-//! other than those with absolutely no captures.\n-//!\n-//! More specifically, for a closure-like type to be \"effectively `Default`\":\n-//! * it must be a ZST (zero-sized type): no information contained within, so\n-//!   that `Default`'s return value (if it were implemented) is unambiguous\n-//! * it must be `Copy`: no captured \"unique ZST tokens\" or any other similar\n-//!   types that would make duplicating values at will unsound\n-//!   * combined with the ZST requirement, this confers a kind of \"telecopy\"\n-//!     ability: similar to `Copy`, but without keeping the value around, and\n-//!     instead \"reconstructing\" it (a noop given it's a ZST) when needed\n-//! * it must be *provably* inhabited: no captured uninhabited types or any\n-//!   other types that cannot be constructed by the user of this abstraction\n-//!   * the proof is a value of the closure-like type itself, in a sense the\n-//!     \"seed\" for the \"telecopy\" process made possible by ZST + `Copy`\n-//!   * this requirement is the only reason an abstraction limited to a specific\n-//!     usecase is required: ZST + `Copy` can be checked with *at worst* a panic\n-//!     at the \"attempted `::default()` call\" time, but that doesn't guarantee\n-//!     that the value can be soundly created, and attempting to use the typical\n-//!     \"proof ZST token\" approach leads yet again to having a ZST + `Copy` type\n-//!     that is not proof of anything without a value (i.e. isomorphic to a\n-//!     newtype of the type it's trying to prove the inhabitation of)\n-//!\n-//! A more flexible (and safer) solution to the general problem could exist once\n-//! `const`-generic parameters can have type parameters in their types:\n-//!\n-//! ```rust,ignore (needs future const-generics)\n-//! extern \"C\" fn ffi_wrapper<\n-//!     A, R,\n-//!     F: Fn(A) -> R,\n-//!     const f: F, // <-- this `const`-generic is not yet allowed\n-//! >(arg: A) -> R {\n-//!     f(arg)\n-//! }\n-//! ```\n-\n-use std::mem;\n-\n-// FIXME(eddyb) this could be `trait` impls except for the `const fn` requirement.\n-macro_rules! define_reify_functions {\n-    ($(\n-        fn $name:ident $(<$($param:ident),*>)?\n-            for $(extern $abi:tt)? fn($($arg:ident: $arg_ty:ty),*) -> $ret_ty:ty;\n-    )+) => {\n-        $(pub const fn $name<\n-            $($($param,)*)?\n-            F: Fn($($arg_ty),*) -> $ret_ty + Copy\n-        >(f: F) -> $(extern $abi)? fn($($arg_ty),*) -> $ret_ty {\n-            // FIXME(eddyb) describe the `F` type (e.g. via `type_name::<F>`) once panic\n-            // formatting becomes possible in `const fn`.\n-            assert!(mem::size_of::<F>() == 0, \"selfless_reify: closure must be zero-sized\");\n-\n-            $(extern $abi)? fn wrapper<\n-                $($($param,)*)?\n-                F: Fn($($arg_ty),*) -> $ret_ty + Copy\n-            >($($arg: $arg_ty),*) -> $ret_ty {\n-                let f = unsafe {\n-                    // SAFETY: `F` satisfies all criteria for \"out of thin air\"\n-                    // reconstructability (see module-level doc comment).\n-                    mem::MaybeUninit::<F>::uninit().assume_init()\n-                };\n-                f($($arg),*)\n-            }\n-            let _f_proof = f;\n-            wrapper::<\n-                $($($param,)*)?\n-                F\n-            >\n-        })+\n-    }\n-}\n-\n-define_reify_functions! {\n-    fn _reify_to_extern_c_fn_unary<A, R> for extern \"C\" fn(arg: A) -> R;\n-\n-    // HACK(eddyb) this abstraction is used with `for<'a> fn(Bridge<'a>) -> T`\n-    // but that doesn't work with just `reify_to_extern_c_fn_unary` because of\n-    // the `fn` pointer type being \"higher-ranked\" (i.e. the `for<'a>` binder).\n-    // FIXME(eddyb) try to remove the lifetime from `Bridge`, that'd help.\n-    fn reify_to_extern_c_fn_hrt_bridge<R> for extern \"C\" fn(bridge: super::Bridge<'_>) -> R;\n-}"}, {"sha": "0fb3c6985894789c86770c043aceeabcf8924bfa", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/bridge/server.rs", "status": "removed", "additions": 0, "deletions": 332, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fbridge%2Fserver.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,332 +0,0 @@\n-//! Server-side traits.\n-\n-use super::*;\n-\n-// FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n-use super::client::HandleStore;\n-\n-pub trait Types {\n-    type FreeFunctions: 'static;\n-    type TokenStream: 'static + Clone;\n-    type Group: 'static + Clone;\n-    type Punct: 'static + Copy + Eq + Hash;\n-    type Ident: 'static + Copy + Eq + Hash;\n-    type Literal: 'static + Clone;\n-    type SourceFile: 'static + Clone;\n-    type MultiSpan: 'static;\n-    type Diagnostic: 'static;\n-    type Span: 'static + Copy + Eq + Hash;\n-}\n-\n-/// Declare an associated fn of one of the traits below, adding necessary\n-/// default bodies.\n-macro_rules! associated_fn {\n-    (fn drop(&mut self, $arg:ident: $arg_ty:ty)) =>\n-        (fn drop(&mut self, $arg: $arg_ty) { mem::drop($arg) });\n-\n-    (fn clone(&mut self, $arg:ident: $arg_ty:ty) -> $ret_ty:ty) =>\n-        (fn clone(&mut self, $arg: $arg_ty) -> $ret_ty { $arg.clone() });\n-\n-    ($($item:tt)*) => ($($item)*;)\n-}\n-\n-macro_rules! declare_server_traits {\n-    ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n-    }),* $(,)?) => {\n-        $(pub trait $name: Types {\n-            $(associated_fn!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n-        })*\n-\n-        pub trait Server: Types $(+ $name)* {}\n-        impl<S: Types $(+ $name)*> Server for S {}\n-    }\n-}\n-with_api!(Self, self_, declare_server_traits);\n-\n-pub(super) struct MarkedTypes<S: Types>(S);\n-\n-macro_rules! define_mark_types_impls {\n-    ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n-    }),* $(,)?) => {\n-        impl<S: Types> Types for MarkedTypes<S> {\n-            $(type $name = Marked<S::$name, client::$name>;)*\n-        }\n-\n-        $(impl<S: $name> $name for MarkedTypes<S> {\n-            $(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)? {\n-                <_>::mark($name::$method(&mut self.0, $($arg.unmark()),*))\n-            })*\n-        })*\n-    }\n-}\n-with_api!(Self, self_, define_mark_types_impls);\n-\n-struct Dispatcher<S: Types> {\n-    handle_store: HandleStore<S>,\n-    server: S,\n-}\n-\n-macro_rules! define_dispatcher_impl {\n-    ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n-    }),* $(,)?) => {\n-        // FIXME(eddyb) `pub` only for `ExecutionStrategy` below.\n-        pub trait DispatcherTrait {\n-            // HACK(eddyb) these are here to allow `Self::$name` to work below.\n-            $(type $name;)*\n-            fn dispatch(&mut self, buf: Buffer) -> Buffer;\n-        }\n-\n-        impl<S: Server> DispatcherTrait for Dispatcher<MarkedTypes<S>> {\n-            $(type $name = <MarkedTypes<S> as Types>::$name;)*\n-            fn dispatch(&mut self, mut buf: Buffer) -> Buffer {\n-                let Dispatcher { handle_store, server } = self;\n-\n-                let mut reader = &buf[..];\n-                match api_tags::Method::decode(&mut reader, &mut ()) {\n-                    $(api_tags::Method::$name(m) => match m {\n-                        $(api_tags::$name::$method => {\n-                            let mut call_method = || {\n-                                reverse_decode!(reader, handle_store; $($arg: $arg_ty),*);\n-                                $name::$method(server, $($arg),*)\n-                            };\n-                            // HACK(eddyb) don't use `panic::catch_unwind` in a panic.\n-                            // If client and server happen to use the same `libstd`,\n-                            // `catch_unwind` asserts that the panic counter was 0,\n-                            // even when the closure passed to it didn't panic.\n-                            let r = if thread::panicking() {\n-                                Ok(call_method())\n-                            } else {\n-                                panic::catch_unwind(panic::AssertUnwindSafe(call_method))\n-                                    .map_err(PanicMessage::from)\n-                            };\n-\n-                            buf.clear();\n-                            r.encode(&mut buf, handle_store);\n-                        })*\n-                    }),*\n-                }\n-                buf\n-            }\n-        }\n-    }\n-}\n-with_api!(Self, self_, define_dispatcher_impl);\n-\n-pub trait ExecutionStrategy {\n-    fn run_bridge_and_client(\n-        &self,\n-        dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n-        force_show_panics: bool,\n-    ) -> Buffer;\n-}\n-\n-pub struct SameThread;\n-\n-impl ExecutionStrategy for SameThread {\n-    fn run_bridge_and_client(\n-        &self,\n-        dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n-        force_show_panics: bool,\n-    ) -> Buffer {\n-        let mut dispatch = |buf| dispatcher.dispatch(buf);\n-\n-        run_client(Bridge {\n-            cached_buffer: input,\n-            dispatch: (&mut dispatch).into(),\n-            force_show_panics,\n-            _marker: marker::PhantomData,\n-        })\n-    }\n-}\n-\n-// NOTE(eddyb) Two implementations are provided, the second one is a bit\n-// faster but neither is anywhere near as fast as same-thread execution.\n-\n-pub struct CrossThread1;\n-\n-impl ExecutionStrategy for CrossThread1 {\n-    fn run_bridge_and_client(\n-        &self,\n-        dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n-        force_show_panics: bool,\n-    ) -> Buffer {\n-        use std::sync::mpsc::channel;\n-\n-        let (req_tx, req_rx) = channel();\n-        let (res_tx, res_rx) = channel();\n-\n-        let join_handle = thread::spawn(move || {\n-            let mut dispatch = |buf| {\n-                req_tx.send(buf).unwrap();\n-                res_rx.recv().unwrap()\n-            };\n-\n-            run_client(Bridge {\n-                cached_buffer: input,\n-                dispatch: (&mut dispatch).into(),\n-                force_show_panics,\n-                _marker: marker::PhantomData,\n-            })\n-        });\n-\n-        for b in req_rx {\n-            res_tx.send(dispatcher.dispatch(b)).unwrap();\n-        }\n-\n-        join_handle.join().unwrap()\n-    }\n-}\n-\n-pub struct CrossThread2;\n-\n-impl ExecutionStrategy for CrossThread2 {\n-    fn run_bridge_and_client(\n-        &self,\n-        dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n-        force_show_panics: bool,\n-    ) -> Buffer {\n-        use std::sync::{Arc, Mutex};\n-\n-        enum State<T> {\n-            Req(T),\n-            Res(T),\n-        }\n-\n-        let mut state = Arc::new(Mutex::new(State::Res(Buffer::new())));\n-\n-        let server_thread = thread::current();\n-        let state2 = state.clone();\n-        let join_handle = thread::spawn(move || {\n-            let mut dispatch = |b| {\n-                *state2.lock().unwrap() = State::Req(b);\n-                server_thread.unpark();\n-                loop {\n-                    thread::park();\n-                    if let State::Res(b) = &mut *state2.lock().unwrap() {\n-                        break b.take();\n-                    }\n-                }\n-            };\n-\n-            let r = run_client(Bridge {\n-                cached_buffer: input,\n-                dispatch: (&mut dispatch).into(),\n-                force_show_panics,\n-                _marker: marker::PhantomData,\n-            });\n-\n-            // Wake up the server so it can exit the dispatch loop.\n-            drop(state2);\n-            server_thread.unpark();\n-\n-            r\n-        });\n-\n-        // Check whether `state2` was dropped, to know when to stop.\n-        while Arc::get_mut(&mut state).is_none() {\n-            thread::park();\n-            let mut b = match &mut *state.lock().unwrap() {\n-                State::Req(b) => b.take(),\n-                _ => continue,\n-            };\n-            b = dispatcher.dispatch(b.take());\n-            *state.lock().unwrap() = State::Res(b);\n-            join_handle.thread().unpark();\n-        }\n-\n-        join_handle.join().unwrap()\n-    }\n-}\n-\n-fn run_server<\n-    S: Server,\n-    I: Encode<HandleStore<MarkedTypes<S>>>,\n-    O: for<'a, 's> DecodeMut<'a, 's, HandleStore<MarkedTypes<S>>>,\n->(\n-    strategy: &impl ExecutionStrategy,\n-    handle_counters: &'static client::HandleCounters,\n-    server: S,\n-    input: I,\n-    run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n-    force_show_panics: bool,\n-) -> Result<O, PanicMessage> {\n-    let mut dispatcher =\n-        Dispatcher { handle_store: HandleStore::new(handle_counters), server: MarkedTypes(server) };\n-\n-    let mut buf = Buffer::new();\n-    input.encode(&mut buf, &mut dispatcher.handle_store);\n-\n-    buf = strategy.run_bridge_and_client(&mut dispatcher, buf, run_client, force_show_panics);\n-\n-    Result::decode(&mut &buf[..], &mut dispatcher.handle_store)\n-}\n-\n-impl client::Client<super::super::TokenStream, super::super::TokenStream> {\n-    pub fn run<S>(\n-        &self,\n-        strategy: &impl ExecutionStrategy,\n-        server: S,\n-        input: S::TokenStream,\n-        force_show_panics: bool,\n-    ) -> Result<S::TokenStream, PanicMessage>\n-    where\n-        S: Server,\n-        S::TokenStream: Default,\n-    {\n-        let client::Client { get_handle_counters, run, _marker } = *self;\n-        run_server(\n-            strategy,\n-            get_handle_counters(),\n-            server,\n-            <MarkedTypes<S> as Types>::TokenStream::mark(input),\n-            run,\n-            force_show_panics,\n-        )\n-        .map(|s| <Option<<MarkedTypes<S> as Types>::TokenStream>>::unmark(s).unwrap_or_default())\n-    }\n-}\n-\n-impl\n-    client::Client<\n-        (super::super::TokenStream, super::super::TokenStream),\n-        super::super::TokenStream,\n-    >\n-{\n-    pub fn run<S>(\n-        &self,\n-        strategy: &impl ExecutionStrategy,\n-        server: S,\n-        input: S::TokenStream,\n-        input2: S::TokenStream,\n-        force_show_panics: bool,\n-    ) -> Result<S::TokenStream, PanicMessage>\n-    where\n-        S: Server,\n-        S::TokenStream: Default,\n-    {\n-        let client::Client { get_handle_counters, run, _marker } = *self;\n-        run_server(\n-            strategy,\n-            get_handle_counters(),\n-            server,\n-            (\n-                <MarkedTypes<S> as Types>::TokenStream::mark(input),\n-                <MarkedTypes<S> as Types>::TokenStream::mark(input2),\n-            ),\n-            run,\n-            force_show_panics,\n-        )\n-        .map(|s| <Option<<MarkedTypes<S> as Types>::TokenStream>>::unmark(s).unwrap_or_default())\n-    }\n-}"}, {"sha": "3fade2dc4f9ccdd4dbac7ef201b49ba8992d09a8", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/diagnostic.rs", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fdiagnostic.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,166 +0,0 @@\n-//! lib-proc-macro diagnostic\n-//!\n-//! Copy from <https://github.com/rust-lang/rust/blob/e45d9973b2665897a768312e971b82cc62633103/src/libproc_macro/diagnostic.rs>\n-//! augmented with removing unstable features\n-\n-use super::Span;\n-\n-/// An enum representing a diagnostic level.\n-#[derive(Copy, Clone, Debug)]\n-#[non_exhaustive]\n-pub enum Level {\n-    /// An error.\n-    Error,\n-    /// A warning.\n-    Warning,\n-    /// A note.\n-    Note,\n-    /// A help message.\n-    Help,\n-}\n-\n-/// Trait implemented by types that can be converted into a set of `Span`s.\n-pub trait MultiSpan {\n-    /// Converts `self` into a `Vec<Span>`.\n-    fn into_spans(self) -> Vec<Span>;\n-}\n-\n-impl MultiSpan for Span {\n-    fn into_spans(self) -> Vec<Span> {\n-        vec![self]\n-    }\n-}\n-\n-impl MultiSpan for Vec<Span> {\n-    fn into_spans(self) -> Vec<Span> {\n-        self\n-    }\n-}\n-\n-impl<'a> MultiSpan for &'a [Span] {\n-    fn into_spans(self) -> Vec<Span> {\n-        self.to_vec()\n-    }\n-}\n-\n-/// A structure representing a diagnostic message and associated children\n-/// messages.\n-#[derive(Clone, Debug)]\n-pub struct Diagnostic {\n-    level: Level,\n-    message: String,\n-    spans: Vec<Span>,\n-    children: Vec<Diagnostic>,\n-}\n-\n-macro_rules! diagnostic_child_methods {\n-    ($spanned:ident, $regular:ident, $level:expr) => {\n-        #[doc = concat!(\"Adds a new child diagnostics message to `self` with the [`\",\n-                        stringify!($level), \"`] level, and the given `spans` and `message`.\")]\n-        pub fn $spanned<S, T>(mut self, spans: S, message: T) -> Diagnostic\n-        where\n-            S: MultiSpan,\n-            T: Into<String>,\n-        {\n-            self.children.push(Diagnostic::spanned(spans, $level, message));\n-            self\n-        }\n-\n-        #[doc = concat!(\"Adds a new child diagnostic message to `self` with the [`\",\n-                        stringify!($level), \"`] level, and the given `message`.\")]\n-        pub fn $regular<T: Into<String>>(mut self, message: T) -> Diagnostic {\n-            self.children.push(Diagnostic::new($level, message));\n-            self\n-        }\n-    };\n-}\n-\n-/// Iterator over the children diagnostics of a `Diagnostic`.\n-#[derive(Debug, Clone)]\n-pub struct Children<'a>(std::slice::Iter<'a, Diagnostic>);\n-\n-impl<'a> Iterator for Children<'a> {\n-    type Item = &'a Diagnostic;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.0.next()\n-    }\n-}\n-\n-impl Diagnostic {\n-    /// Creates a new diagnostic with the given `level` and `message`.\n-    pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n-        Diagnostic { level, message: message.into(), spans: vec![], children: vec![] }\n-    }\n-\n-    /// Creates a new diagnostic with the given `level` and `message` pointing to\n-    /// the given set of `spans`.\n-    pub fn spanned<S, T>(spans: S, level: Level, message: T) -> Diagnostic\n-    where\n-        S: MultiSpan,\n-        T: Into<String>,\n-    {\n-        Diagnostic { level, message: message.into(), spans: spans.into_spans(), children: vec![] }\n-    }\n-\n-    diagnostic_child_methods!(span_error, error, Level::Error);\n-    diagnostic_child_methods!(span_warning, warning, Level::Warning);\n-    diagnostic_child_methods!(span_note, note, Level::Note);\n-    diagnostic_child_methods!(span_help, help, Level::Help);\n-\n-    /// Returns the diagnostic `level` for `self`.\n-    pub fn level(&self) -> Level {\n-        self.level\n-    }\n-\n-    /// Sets the level in `self` to `level`.\n-    pub fn set_level(&mut self, level: Level) {\n-        self.level = level;\n-    }\n-\n-    /// Returns the message in `self`.\n-    pub fn message(&self) -> &str {\n-        &self.message\n-    }\n-\n-    /// Sets the message in `self` to `message`.\n-    pub fn set_message<T: Into<String>>(&mut self, message: T) {\n-        self.message = message.into();\n-    }\n-\n-    /// Returns the `Span`s in `self`.\n-    pub fn spans(&self) -> &[Span] {\n-        &self.spans\n-    }\n-\n-    /// Sets the `Span`s in `self` to `spans`.\n-    pub fn set_spans<S: MultiSpan>(&mut self, spans: S) {\n-        self.spans = spans.into_spans();\n-    }\n-\n-    /// Returns an iterator over the children diagnostics of `self`.\n-    pub fn children(&self) -> Children<'_> {\n-        Children(self.children.iter())\n-    }\n-\n-    /// Emit the diagnostic.\n-    pub fn emit(self) {\n-        fn to_internal(spans: Vec<Span>) -> super::bridge::client::MultiSpan {\n-            let mut multi_span = super::bridge::client::MultiSpan::new();\n-            for span in spans {\n-                multi_span.push(span.0);\n-            }\n-            multi_span\n-        }\n-\n-        let mut diag = super::bridge::client::Diagnostic::new(\n-            self.level,\n-            &self.message[..],\n-            to_internal(self.spans),\n-        );\n-        for c in self.children {\n-            diag.sub(c.level, &c.message[..], to_internal(c.spans));\n-        }\n-        diag.emit();\n-    }\n-}"}, {"sha": "89bd10da5e4863392935b1d96517ebd39db5608b", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/mod.rs", "status": "removed", "additions": 0, "deletions": 1106, "changes": 1106, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fmod.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,1106 +0,0 @@\n-//! A support library for macro authors when defining new macros.\n-//!\n-//! This library, provided by the standard distribution, provides the types\n-//! consumed in the interfaces of procedurally defined macro definitions such as\n-//! function-like macros `#[proc_macro]`, macro attributes `#[proc_macro_attribute]` and\n-//! custom derive attributes`#[proc_macro_derive]`.\n-//!\n-//! See [the book] for more.\n-//!\n-//! [the book]: ../book/ch19-06-macros.html#procedural-macros-for-generating-code-from-attributes\n-\n-#[doc(hidden)]\n-pub mod bridge;\n-\n-mod diagnostic;\n-\n-pub use diagnostic::{Diagnostic, Level, MultiSpan};\n-\n-use std::cmp::Ordering;\n-use std::ops::RangeBounds;\n-use std::path::PathBuf;\n-use std::str::FromStr;\n-use std::{error, fmt, iter, mem};\n-\n-/// Determines whether proc_macro has been made accessible to the currently\n-/// running program.\n-///\n-/// The proc_macro crate is only intended for use inside the implementation of\n-/// procedural macros. All the functions in this crate panic if invoked from\n-/// outside of a procedural macro, such as from a build script or unit test or\n-/// ordinary Rust binary.\n-///\n-/// With consideration for Rust libraries that are designed to support both\n-/// macro and non-macro use cases, `proc_macro::is_available()` provides a\n-/// non-panicking way to detect whether the infrastructure required to use the\n-/// API of proc_macro is presently available. Returns true if invoked from\n-/// inside of a procedural macro, false if invoked from any other binary.\n-pub fn is_available() -> bool {\n-    bridge::Bridge::is_available()\n-}\n-\n-/// The main type provided by this crate, representing an abstract stream of\n-/// tokens, or, more specifically, a sequence of token trees.\n-/// The type provide interfaces for iterating over those token trees and, conversely,\n-/// collecting a number of token trees into one stream.\n-///\n-/// This is both the input and output of `#[proc_macro]`, `#[proc_macro_attribute]`\n-/// and `#[proc_macro_derive]` definitions.\n-#[derive(Clone)]\n-pub struct TokenStream(Option<bridge::client::TokenStream>);\n-\n-/// Error returned from `TokenStream::from_str`.\n-#[non_exhaustive]\n-#[derive(Debug)]\n-pub struct LexError;\n-\n-impl fmt::Display for LexError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(\"cannot parse string into token stream\")\n-    }\n-}\n-\n-impl error::Error for LexError {}\n-\n-/// Error returned from `TokenStream::expand_expr`.\n-#[non_exhaustive]\n-#[derive(Debug)]\n-pub struct ExpandError;\n-\n-impl fmt::Display for ExpandError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(\"macro expansion failed\")\n-    }\n-}\n-\n-impl error::Error for ExpandError {}\n-\n-impl TokenStream {\n-    /// Returns an empty `TokenStream` containing no token trees.\n-    pub fn new() -> TokenStream {\n-        TokenStream(None)\n-    }\n-\n-    /// Checks if this `TokenStream` is empty.\n-    pub fn is_empty(&self) -> bool {\n-        self.0.as_ref().map(|h| h.is_empty()).unwrap_or(true)\n-    }\n-\n-    /// Parses this `TokenStream` as an expression and attempts to expand any\n-    /// macros within it. Returns the expanded `TokenStream`.\n-    ///\n-    /// Currently only expressions expanding to literals will succeed, although\n-    /// this may be relaxed in the future.\n-    ///\n-    /// NOTE: In error conditions, `expand_expr` may leave macros unexpanded,\n-    /// report an error, failing compilation, and/or return an `Err(..)`. The\n-    /// specific behavior for any error condition, and what conditions are\n-    /// considered errors, is unspecified and may change in the future.\n-    pub fn expand_expr(&self) -> Result<TokenStream, ExpandError> {\n-        let stream = self.0.as_ref().ok_or(ExpandError)?;\n-        match bridge::client::TokenStream::expand_expr(stream) {\n-            Ok(stream) => Ok(TokenStream(Some(stream))),\n-            Err(_) => Err(ExpandError),\n-        }\n-    }\n-}\n-\n-/// Attempts to break the string into tokens and parse those tokens into a token stream.\n-/// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n-/// or characters not existing in the language.\n-/// All tokens in the parsed stream get `Span::call_site()` spans.\n-///\n-/// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n-/// change these errors into `LexError`s later.\n-impl FromStr for TokenStream {\n-    type Err = LexError;\n-\n-    fn from_str(src: &str) -> Result<TokenStream, LexError> {\n-        Ok(TokenStream(Some(bridge::client::TokenStream::from_str(src))))\n-    }\n-}\n-\n-/// Prints the token stream as a string that is supposed to be losslessly convertible back\n-/// into the same token stream (modulo spans), except for possibly `TokenTree::Group`s\n-/// with `Delimiter::None` delimiters and negative numeric literals.\n-impl fmt::Display for TokenStream {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        unimplemented!()\n-    }\n-}\n-\n-/// Prints token in a form convenient for debugging.\n-impl fmt::Debug for TokenStream {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(\"TokenStream \")?;\n-        f.debug_list().entries(self.clone()).finish()\n-    }\n-}\n-\n-impl Default for TokenStream {\n-    fn default() -> Self {\n-        TokenStream::new()\n-    }\n-}\n-\n-pub use quote::{quote, quote_span};\n-\n-fn tree_to_bridge_tree(\n-    tree: TokenTree,\n-) -> bridge::TokenTree<\n-    bridge::client::Group,\n-    bridge::client::Punct,\n-    bridge::client::Ident,\n-    bridge::client::Literal,\n-> {\n-    match tree {\n-        TokenTree::Group(tt) => bridge::TokenTree::Group(tt.0),\n-        TokenTree::Punct(tt) => bridge::TokenTree::Punct(tt.0),\n-        TokenTree::Ident(tt) => bridge::TokenTree::Ident(tt.0),\n-        TokenTree::Literal(tt) => bridge::TokenTree::Literal(tt.0),\n-    }\n-}\n-\n-/// Creates a token stream containing a single token tree.\n-impl From<TokenTree> for TokenStream {\n-    fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream(Some(bridge::client::TokenStream::from_token_tree(tree_to_bridge_tree(tree))))\n-    }\n-}\n-\n-/// Non-generic helper for implementing `FromIterator<TokenStream>` and\n-/// `Extend<TokenStream>` with less monomorphization in calling crates.\n-struct ConcatStreamsHelper {\n-    streams: Vec<bridge::client::TokenStream>,\n-}\n-\n-impl ConcatStreamsHelper {\n-    fn new(capacity: usize) -> Self {\n-        ConcatStreamsHelper { streams: Vec::with_capacity(capacity) }\n-    }\n-\n-    fn push(&mut self, stream: TokenStream) {\n-        if let Some(stream) = stream.0 {\n-            self.streams.push(stream);\n-        }\n-    }\n-\n-    fn build(mut self) -> TokenStream {\n-        if self.streams.len() <= 1 {\n-            TokenStream(self.streams.pop())\n-        } else {\n-            TokenStream(Some(bridge::client::TokenStream::concat_streams(None, self.streams)))\n-        }\n-    }\n-\n-    fn append_to(mut self, stream: &mut TokenStream) {\n-        if self.streams.is_empty() {\n-            return;\n-        }\n-        let base = stream.0.take();\n-        if base.is_none() && self.streams.len() == 1 {\n-            stream.0 = self.streams.pop();\n-        } else {\n-            stream.0 = Some(bridge::client::TokenStream::concat_streams(base, self.streams));\n-        }\n-    }\n-}\n-\n-/// Collects a number of token trees into a single stream.\n-impl FromIterator<TokenTree> for TokenStream {\n-    fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n-        trees.into_iter().map(TokenStream::from).collect()\n-    }\n-}\n-\n-/// A \"flattening\" operation on token streams, collects token trees\n-/// from multiple token streams into a single stream.\n-impl FromIterator<TokenStream> for TokenStream {\n-    fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n-        let iter = streams.into_iter();\n-        let mut builder = ConcatStreamsHelper::new(iter.size_hint().0);\n-        iter.for_each(|stream| builder.push(stream));\n-        builder.build()\n-    }\n-}\n-\n-impl Extend<TokenTree> for TokenStream {\n-    fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, trees: I) {\n-        self.extend(trees.into_iter().map(TokenStream::from));\n-    }\n-}\n-\n-impl Extend<TokenStream> for TokenStream {\n-    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n-        // FIXME(eddyb) Use an optimized implementation if/when possible.\n-        *self = iter::once(mem::replace(self, Self::new())).chain(streams).collect();\n-    }\n-}\n-\n-/// Public implementation details for the `TokenStream` type, such as iterators.\n-pub mod token_stream {\n-    use super::{bridge, Group, Ident, Literal, Punct, TokenStream, TokenTree};\n-\n-    /// An iterator over `TokenStream`'s `TokenTree`s.\n-    /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n-    /// and returns whole groups as token trees.\n-    #[derive(Clone)]\n-    pub struct IntoIter(\n-        std::vec::IntoIter<\n-            bridge::TokenTree<\n-                bridge::client::Group,\n-                bridge::client::Punct,\n-                bridge::client::Ident,\n-                bridge::client::Literal,\n-            >,\n-        >,\n-    );\n-\n-    impl Iterator for IntoIter {\n-        type Item = TokenTree;\n-\n-        fn next(&mut self) -> Option<TokenTree> {\n-            self.0.next().map(|tree| match tree {\n-                bridge::TokenTree::Group(tt) => TokenTree::Group(Group(tt)),\n-                bridge::TokenTree::Punct(tt) => TokenTree::Punct(Punct(tt)),\n-                bridge::TokenTree::Ident(tt) => TokenTree::Ident(Ident(tt)),\n-                bridge::TokenTree::Literal(tt) => TokenTree::Literal(Literal(tt)),\n-            })\n-        }\n-    }\n-\n-    impl IntoIterator for TokenStream {\n-        type Item = TokenTree;\n-        type IntoIter = IntoIter;\n-\n-        fn into_iter(self) -> IntoIter {\n-            IntoIter(self.0.map(|v| v.into_trees()).unwrap_or_default().into_iter())\n-        }\n-    }\n-}\n-\n-#[doc(hidden)]\n-mod quote;\n-\n-/// A region of source code, along with macro expansion information.\n-#[derive(Copy, Clone)]\n-pub struct Span(bridge::client::Span);\n-\n-macro_rules! diagnostic_method {\n-    ($name:ident, $level:expr) => {\n-        /// Creates a new `Diagnostic` with the given `message` at the span\n-        /// `self`.\n-        pub fn $name<T: Into<String>>(self, message: T) -> Diagnostic {\n-            Diagnostic::spanned(self, $level, message)\n-        }\n-    };\n-}\n-\n-impl Span {\n-    /// A span that resolves at the macro definition site.\n-    pub fn def_site() -> Span {\n-        Span(bridge::client::Span::def_site())\n-    }\n-\n-    /// The span of the invocation of the current procedural macro.\n-    /// Identifiers created with this span will be resolved as if they were written\n-    /// directly at the macro call location (call-site hygiene) and other code\n-    /// at the macro call site will be able to refer to them as well.\n-    pub fn call_site() -> Span {\n-        Span(bridge::client::Span::call_site())\n-    }\n-\n-    /// A span that represents `macro_rules` hygiene, and sometimes resolves at the macro\n-    /// definition site (local variables, labels, `$crate`) and sometimes at the macro\n-    /// call site (everything else).\n-    /// The span location is taken from the call-site.\n-    pub fn mixed_site() -> Span {\n-        Span(bridge::client::Span::mixed_site())\n-    }\n-\n-    /// The original source file into which this span points.\n-    pub fn source_file(&self) -> SourceFile {\n-        SourceFile(self.0.source_file())\n-    }\n-\n-    /// The `Span` for the tokens in the previous macro expansion from which\n-    /// `self` was generated from, if any.\n-    pub fn parent(&self) -> Option<Span> {\n-        self.0.parent().map(Span)\n-    }\n-\n-    /// The span for the origin source code that `self` was generated from. If\n-    /// this `Span` wasn't generated from other macro expansions then the return\n-    /// value is the same as `*self`.\n-    pub fn source(&self) -> Span {\n-        Span(self.0.source())\n-    }\n-\n-    /// Gets the starting line/column in the source file for this span.\n-    pub fn start(&self) -> LineColumn {\n-        self.0.start().add_1_to_column()\n-    }\n-\n-    /// Gets the ending line/column in the source file for this span.\n-    pub fn end(&self) -> LineColumn {\n-        self.0.end().add_1_to_column()\n-    }\n-\n-    /// Creates an empty span pointing to directly before this span.\n-    pub fn before(&self) -> Span {\n-        Span(self.0.before())\n-    }\n-\n-    /// Creates an empty span pointing to directly after this span.\n-    pub fn after(&self) -> Span {\n-        Span(self.0.after())\n-    }\n-\n-    /// Creates a new span encompassing `self` and `other`.\n-    ///\n-    /// Returns `None` if `self` and `other` are from different files.\n-    pub fn join(&self, other: Span) -> Option<Span> {\n-        self.0.join(other.0).map(Span)\n-    }\n-\n-    /// Creates a new span with the same line/column information as `self` but\n-    /// that resolves symbols as though it were at `other`.\n-    pub fn resolved_at(&self, other: Span) -> Span {\n-        Span(self.0.resolved_at(other.0))\n-    }\n-\n-    /// Creates a new span with the same name resolution behavior as `self` but\n-    /// with the line/column information of `other`.\n-    pub fn located_at(&self, other: Span) -> Span {\n-        other.resolved_at(*self)\n-    }\n-\n-    /// Compares to spans to see if they're equal.\n-    pub fn eq(&self, other: &Span) -> bool {\n-        self.0 == other.0\n-    }\n-\n-    /// Returns the source text behind a span. This preserves the original source\n-    /// code, including spaces and comments. It only returns a result if the span\n-    /// corresponds to real source code.\n-    ///\n-    /// Note: The observable result of a macro should only rely on the tokens and\n-    /// not on this source text. The result of this function is a best effort to\n-    /// be used for diagnostics only.\n-    pub fn source_text(&self) -> Option<String> {\n-        self.0.source_text()\n-    }\n-\n-    // Used by the implementation of `Span::quote`\n-    #[doc(hidden)]\n-    pub fn save_span(&self) -> usize {\n-        self.0.save_span()\n-    }\n-\n-    // Used by the implementation of `Span::quote`\n-    #[doc(hidden)]\n-    pub fn recover_proc_macro_span(id: usize) -> Span {\n-        Span(bridge::client::Span::recover_proc_macro_span(id))\n-    }\n-\n-    diagnostic_method!(error, Level::Error);\n-    diagnostic_method!(warning, Level::Warning);\n-    diagnostic_method!(note, Level::Note);\n-    diagnostic_method!(help, Level::Help);\n-}\n-\n-/// Prints a span in a form convenient for debugging.\n-impl fmt::Debug for Span {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0.fmt(f)\n-    }\n-}\n-\n-/// A line-column pair representing the start or end of a `Span`.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct LineColumn {\n-    /// The 1-indexed line in the source file on which the span starts or ends (inclusive).\n-    pub line: usize,\n-    /// The 1-indexed column (number of bytes in UTF-8 encoding) in the source\n-    /// file on which the span starts or ends (inclusive).\n-    pub column: usize,\n-}\n-\n-impl LineColumn {\n-    fn add_1_to_column(self) -> Self {\n-        LineColumn { line: self.line, column: self.column + 1 }\n-    }\n-}\n-\n-impl Ord for LineColumn {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.line.cmp(&other.line).then(self.column.cmp(&other.column))\n-    }\n-}\n-\n-impl PartialOrd for LineColumn {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-/// The source file of a given `Span`.\n-#[derive(Clone)]\n-pub struct SourceFile(bridge::client::SourceFile);\n-\n-impl SourceFile {\n-    /// Gets the path to this source file.\n-    ///\n-    /// ### Note\n-    /// If the code span associated with this `SourceFile` was generated by an external macro, this\n-    /// macro, this might not be an actual path on the filesystem. Use [`is_real`] to check.\n-    ///\n-    /// Also note that even if `is_real` returns `true`, if `--remap-path-prefix` was passed on\n-    /// the command line, the path as given might not actually be valid.\n-    ///\n-    /// [`is_real`]: Self::is_real\n-    pub fn path(&self) -> PathBuf {\n-        PathBuf::from(self.0.path())\n-    }\n-\n-    /// Returns `true` if this source file is a real source file, and not generated by an external\n-    /// macro's expansion.\n-    pub fn is_real(&self) -> bool {\n-        // This is a hack until intercrate spans are implemented and we can have real source files\n-        // for spans generated in external macros.\n-        // https://github.com/rust-lang/rust/pull/43604#issuecomment-333334368\n-        self.0.is_real()\n-    }\n-}\n-\n-impl fmt::Debug for SourceFile {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SourceFile\")\n-            .field(\"path\", &self.path())\n-            .field(\"is_real\", &self.is_real())\n-            .finish()\n-    }\n-}\n-\n-impl PartialEq for SourceFile {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.0.eq(&other.0)\n-    }\n-}\n-\n-impl Eq for SourceFile {}\n-\n-/// A single token or a delimited sequence of token trees (e.g., `[1, (), ..]`).\n-#[derive(Clone)]\n-pub enum TokenTree {\n-    /// A token stream surrounded by bracket delimiters.\n-    Group(Group),\n-    /// An identifier.\n-    Ident(Ident),\n-    /// A single punctuation character (`+`, `,`, `$`, etc.).\n-    Punct(Punct),\n-    /// A literal character (`'a'`), string (`\"hello\"`), number (`2.3`), etc.\n-    Literal(Literal),\n-}\n-\n-impl TokenTree {\n-    /// Returns the span of this tree, delegating to the `span` method of\n-    /// the contained token or a delimited stream.\n-    pub fn span(&self) -> Span {\n-        match *self {\n-            TokenTree::Group(ref t) => t.span(),\n-            TokenTree::Ident(ref t) => t.span(),\n-            TokenTree::Punct(ref t) => t.span(),\n-            TokenTree::Literal(ref t) => t.span(),\n-        }\n-    }\n-\n-    /// Configures the span for *only this token*.\n-    ///\n-    /// Note that if this token is a `Group` then this method will not configure\n-    /// the span of each of the internal tokens, this will simply delegate to\n-    /// the `set_span` method of each variant.\n-    pub fn set_span(&mut self, span: Span) {\n-        match *self {\n-            TokenTree::Group(ref mut t) => t.set_span(span),\n-            TokenTree::Ident(ref mut t) => t.set_span(span),\n-            TokenTree::Punct(ref mut t) => t.set_span(span),\n-            TokenTree::Literal(ref mut t) => t.set_span(span),\n-        }\n-    }\n-}\n-\n-/// Prints token tree in a form convenient for debugging.\n-impl fmt::Debug for TokenTree {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Each of these has the name in the struct type in the derived debug,\n-        // so don't bother with an extra layer of indirection\n-        match *self {\n-            TokenTree::Group(ref tt) => tt.fmt(f),\n-            TokenTree::Ident(ref tt) => tt.fmt(f),\n-            TokenTree::Punct(ref tt) => tt.fmt(f),\n-            TokenTree::Literal(ref tt) => tt.fmt(f),\n-        }\n-    }\n-}\n-\n-impl From<Group> for TokenTree {\n-    fn from(g: Group) -> TokenTree {\n-        TokenTree::Group(g)\n-    }\n-}\n-\n-impl From<Ident> for TokenTree {\n-    fn from(g: Ident) -> TokenTree {\n-        TokenTree::Ident(g)\n-    }\n-}\n-\n-impl From<Punct> for TokenTree {\n-    fn from(g: Punct) -> TokenTree {\n-        TokenTree::Punct(g)\n-    }\n-}\n-\n-impl From<Literal> for TokenTree {\n-    fn from(g: Literal) -> TokenTree {\n-        TokenTree::Literal(g)\n-    }\n-}\n-\n-/// Prints the token tree as a string that is supposed to be losslessly convertible back\n-/// into the same token tree (modulo spans), except for possibly `TokenTree::Group`s\n-/// with `Delimiter::None` delimiters and negative numeric literals.\n-impl fmt::Display for TokenTree {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        unimplemented!()\n-    }\n-}\n-\n-/// A delimited token stream.\n-///\n-/// A `Group` internally contains a `TokenStream` which is surrounded by `Delimiter`s.\n-#[derive(Clone)]\n-pub struct Group(bridge::client::Group);\n-\n-/// Describes how a sequence of token trees is delimited.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Delimiter {\n-    /// `( ... )`\n-    Parenthesis,\n-    /// `{ ... }`\n-    Brace,\n-    /// `[ ... ]`\n-    Bracket,\n-    /// `\u00d8 ... \u00d8`\n-    /// An invisible delimiter, that may, for example, appear around tokens coming from a\n-    /// \"macro variable\" `$var`. It is important to preserve operator priorities in cases like\n-    /// `$var * 3` where `$var` is `1 + 2`.\n-    /// Invisible delimiters might not survive roundtrip of a token stream through a string.\n-    None,\n-}\n-\n-impl Group {\n-    /// Creates a new `Group` with the given delimiter and token stream.\n-    ///\n-    /// This constructor will set the span for this group to\n-    /// `Span::call_site()`. To change the span you can use the `set_span`\n-    /// method below.\n-    pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group {\n-        Group(bridge::client::Group::new(delimiter, stream.0))\n-    }\n-\n-    /// Returns the delimiter of this `Group`\n-    pub fn delimiter(&self) -> Delimiter {\n-        self.0.delimiter()\n-    }\n-\n-    /// Returns the `TokenStream` of tokens that are delimited in this `Group`.\n-    ///\n-    /// Note that the returned token stream does not include the delimiter\n-    /// returned above.\n-    pub fn stream(&self) -> TokenStream {\n-        TokenStream(Some(self.0.stream()))\n-    }\n-\n-    /// Returns the span for the delimiters of this token stream, spanning the\n-    /// entire `Group`.\n-    ///\n-    /// ```text\n-    /// pub fn span(&self) -> Span {\n-    ///            ^^^^^^^\n-    /// ```\n-    pub fn span(&self) -> Span {\n-        Span(self.0.span())\n-    }\n-\n-    /// Returns the span pointing to the opening delimiter of this group.\n-    ///\n-    /// ```text\n-    /// pub fn span_open(&self) -> Span {\n-    ///                 ^\n-    /// ```\n-    pub fn span_open(&self) -> Span {\n-        Span(self.0.span_open())\n-    }\n-\n-    /// Returns the span pointing to the closing delimiter of this group.\n-    ///\n-    /// ```text\n-    /// pub fn span_close(&self) -> Span {\n-    ///                        ^\n-    /// ```\n-    pub fn span_close(&self) -> Span {\n-        Span(self.0.span_close())\n-    }\n-\n-    /// Configures the span for this `Group`'s delimiters, but not its internal\n-    /// tokens.\n-    ///\n-    /// This method will **not** set the span of all the internal tokens spanned\n-    /// by this group, but rather it will only set the span of the delimiter\n-    /// tokens at the level of the `Group`.\n-    pub fn set_span(&mut self, span: Span) {\n-        self.0.set_span(span.0);\n-    }\n-}\n-\n-/// Prints the group as a string that should be losslessly convertible back\n-/// into the same group (modulo spans), except for possibly `TokenTree::Group`s\n-/// with `Delimiter::None` delimiters.\n-impl fmt::Display for Group {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        unimplemented!()\n-    }\n-}\n-\n-impl fmt::Debug for Group {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Group\")\n-            .field(\"delimiter\", &self.delimiter())\n-            .field(\"stream\", &self.stream())\n-            .field(\"span\", &self.span())\n-            .finish()\n-    }\n-}\n-\n-/// A `Punct` is a single punctuation character such as `+`, `-` or `#`.\n-///\n-/// Multi-character operators like `+=` are represented as two instances of `Punct` with different\n-/// forms of `Spacing` returned.\n-#[derive(Clone)]\n-pub struct Punct(bridge::client::Punct);\n-\n-/// Describes whether a `Punct` is followed immediately by another `Punct` ([`Spacing::Joint`]) or\n-/// by a different token or whitespace ([`Spacing::Alone`]).\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Spacing {\n-    /// A `Punct` is not immediately followed by another `Punct`.\n-    /// E.g. `+` is `Alone` in `+ =`, `+ident` and `+()`.\n-    Alone,\n-    /// A `Punct` is immediately followed by another `Punct`.\n-    /// E.g. `+` is `Joint` in `+=` and `++`.\n-    ///\n-    /// Additionally, single quote `'` can join with identifiers to form lifetimes: `'ident`.\n-    Joint,\n-}\n-\n-impl Punct {\n-    /// Creates a new `Punct` from the given character and spacing.\n-    /// The `ch` argument must be a valid punctuation character permitted by the language,\n-    /// otherwise the function will panic.\n-    ///\n-    /// The returned `Punct` will have the default span of `Span::call_site()`\n-    /// which can be further configured with the `set_span` method below.\n-    pub fn new(ch: char, spacing: Spacing) -> Punct {\n-        Punct(bridge::client::Punct::new(ch, spacing))\n-    }\n-\n-    /// Returns the value of this punctuation character as `char`.\n-    pub fn as_char(&self) -> char {\n-        self.0.as_char()\n-    }\n-\n-    /// Returns the spacing of this punctuation character, indicating whether it's immediately\n-    /// followed by another `Punct` in the token stream, so they can potentially be combined into\n-    /// a multi-character operator (`Joint`), or it's followed by some other token or whitespace\n-    /// (`Alone`) so the operator has certainly ended.\n-    pub fn spacing(&self) -> Spacing {\n-        self.0.spacing()\n-    }\n-\n-    /// Returns the span for this punctuation character.\n-    pub fn span(&self) -> Span {\n-        Span(self.0.span())\n-    }\n-\n-    /// Configure the span for this punctuation character.\n-    pub fn set_span(&mut self, span: Span) {\n-        self.0 = self.0.with_span(span.0);\n-    }\n-}\n-\n-/// Prints the punctuation character as a string that should be losslessly convertible\n-/// back into the same character.\n-impl fmt::Display for Punct {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        unimplemented!()\n-    }\n-}\n-\n-impl fmt::Debug for Punct {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Punct\")\n-            .field(\"ch\", &self.as_char())\n-            .field(\"spacing\", &self.spacing())\n-            .field(\"span\", &self.span())\n-            .finish()\n-    }\n-}\n-\n-impl PartialEq<char> for Punct {\n-    fn eq(&self, rhs: &char) -> bool {\n-        self.as_char() == *rhs\n-    }\n-}\n-\n-impl PartialEq<Punct> for char {\n-    fn eq(&self, rhs: &Punct) -> bool {\n-        *self == rhs.as_char()\n-    }\n-}\n-\n-/// An identifier (`ident`).\n-#[derive(Clone)]\n-pub struct Ident(bridge::client::Ident);\n-\n-impl Ident {\n-    /// Creates a new `Ident` with the given `string` as well as the specified\n-    /// `span`.\n-    /// The `string` argument must be a valid identifier permitted by the\n-    /// language (including keywords, e.g. `self` or `fn`). Otherwise, the function will panic.\n-    ///\n-    /// Note that `span`, currently in rustc, configures the hygiene information\n-    /// for this identifier.\n-    ///\n-    /// As of this time `Span::call_site()` explicitly opts-in to \"call-site\" hygiene\n-    /// meaning that identifiers created with this span will be resolved as if they were written\n-    /// directly at the location of the macro call, and other code at the macro call site will be\n-    /// able to refer to them as well.\n-    ///\n-    /// Later spans like `Span::def_site()` will allow to opt-in to \"definition-site\" hygiene\n-    /// meaning that identifiers created with this span will be resolved at the location of the\n-    /// macro definition and other code at the macro call site will not be able to refer to them.\n-    ///\n-    /// Due to the current importance of hygiene this constructor, unlike other\n-    /// tokens, requires a `Span` to be specified at construction.\n-    pub fn new(string: &str, span: Span) -> Ident {\n-        Ident(bridge::client::Ident::new(string, span.0, false))\n-    }\n-\n-    /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n-    /// The `string` argument be a valid identifier permitted by the language\n-    /// (including keywords, e.g. `fn`). Keywords which are usable in path segments\n-    /// (e.g. `self`, `super`) are not supported, and will cause a panic.\n-    pub fn new_raw(string: &str, span: Span) -> Ident {\n-        Ident(bridge::client::Ident::new(string, span.0, true))\n-    }\n-\n-    /// Returns the span of this `Ident`, encompassing the entire string returned\n-    /// by [`to_string`](Self::to_string).\n-    pub fn span(&self) -> Span {\n-        Span(self.0.span())\n-    }\n-\n-    /// Configures the span of this `Ident`, possibly changing its hygiene context.\n-    pub fn set_span(&mut self, span: Span) {\n-        self.0 = self.0.with_span(span.0);\n-    }\n-}\n-\n-/// Prints the identifier as a string that should be losslessly convertible\n-/// back into the same identifier.\n-impl fmt::Display for Ident {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        unimplemented!()\n-    }\n-}\n-\n-impl fmt::Debug for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Ident\")\n-            .field(\"ident\", &self.to_string())\n-            .field(\"span\", &self.span())\n-            .finish()\n-    }\n-}\n-\n-/// A literal string (`\"hello\"`), byte string (`b\"hello\"`),\n-/// character (`'a'`), byte character (`b'a'`), an integer or floating point number\n-/// with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`).\n-/// Boolean literals like `true` and `false` do not belong here, they are `Ident`s.\n-#[derive(Clone)]\n-pub struct Literal(bridge::client::Literal);\n-\n-macro_rules! suffixed_int_literals {\n-    ($($name:ident => $kind:ident,)*) => ($(\n-        /// Creates a new suffixed integer literal with the specified value.\n-        ///\n-        /// This function will create an integer like `1u32` where the integer\n-        /// value specified is the first part of the token and the integral is\n-        /// also suffixed at the end.\n-        /// Literals created from negative numbers might not survive round-trips through\n-        /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-        ///\n-        /// Literals created through this method have the `Span::call_site()`\n-        /// span by default, which can be configured with the `set_span` method\n-        /// below.\n-        pub fn $name(n: $kind) -> Literal {\n-            Literal(bridge::client::Literal::typed_integer(&n.to_string(), stringify!($kind)))\n-        }\n-    )*)\n-}\n-\n-macro_rules! unsuffixed_int_literals {\n-    ($($name:ident => $kind:ident,)*) => ($(\n-        /// Creates a new unsuffixed integer literal with the specified value.\n-        ///\n-        /// This function will create an integer like `1` where the integer\n-        /// value specified is the first part of the token. No suffix is\n-        /// specified on this token, meaning that invocations like\n-        /// `Literal::i8_unsuffixed(1)` are equivalent to\n-        /// `Literal::u32_unsuffixed(1)`.\n-        /// Literals created from negative numbers might not survive rountrips through\n-        /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-        ///\n-        /// Literals created through this method have the `Span::call_site()`\n-        /// span by default, which can be configured with the `set_span` method\n-        /// below.\n-        pub fn $name(n: $kind) -> Literal {\n-            Literal(bridge::client::Literal::integer(&n.to_string()))\n-        }\n-    )*)\n-}\n-\n-impl Literal {\n-    suffixed_int_literals! {\n-        u8_suffixed => u8,\n-        u16_suffixed => u16,\n-        u32_suffixed => u32,\n-        u64_suffixed => u64,\n-        u128_suffixed => u128,\n-        usize_suffixed => usize,\n-        i8_suffixed => i8,\n-        i16_suffixed => i16,\n-        i32_suffixed => i32,\n-        i64_suffixed => i64,\n-        i128_suffixed => i128,\n-        isize_suffixed => isize,\n-    }\n-\n-    unsuffixed_int_literals! {\n-        u8_unsuffixed => u8,\n-        u16_unsuffixed => u16,\n-        u32_unsuffixed => u32,\n-        u64_unsuffixed => u64,\n-        u128_unsuffixed => u128,\n-        usize_unsuffixed => usize,\n-        i8_unsuffixed => i8,\n-        i16_unsuffixed => i16,\n-        i32_unsuffixed => i32,\n-        i64_unsuffixed => i64,\n-        i128_unsuffixed => i128,\n-        isize_unsuffixed => isize,\n-    }\n-\n-    /// Creates a new unsuffixed floating-point literal.\n-    ///\n-    /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n-    /// the float's value is emitted directly into the token but no suffix is\n-    /// used, so it may be inferred to be a `f64` later in the compiler.\n-    /// Literals created from negative numbers might not survive rountrips through\n-    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function requires that the specified float is finite, for\n-    /// example if it is infinity or NaN this function will panic.\n-    pub fn f32_unsuffixed(n: f32) -> Literal {\n-        if !n.is_finite() {\n-            panic!(\"Invalid float literal {n}\");\n-        }\n-        let mut repr = n.to_string();\n-        if !repr.contains('.') {\n-            repr.push_str(\".0\");\n-        }\n-        Literal(bridge::client::Literal::float(&repr))\n-    }\n-\n-    /// Creates a new suffixed floating-point literal.\n-    ///\n-    /// This constructor will create a literal like `1.0f32` where the value\n-    /// specified is the preceding part of the token and `f32` is the suffix of\n-    /// the token. This token will always be inferred to be an `f32` in the\n-    /// compiler.\n-    /// Literals created from negative numbers might not survive rountrips through\n-    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function requires that the specified float is finite, for\n-    /// example if it is infinity or NaN this function will panic.\n-    pub fn f32_suffixed(n: f32) -> Literal {\n-        if !n.is_finite() {\n-            panic!(\"Invalid float literal {n}\");\n-        }\n-        Literal(bridge::client::Literal::f32(&n.to_string()))\n-    }\n-\n-    /// Creates a new unsuffixed floating-point literal.\n-    ///\n-    /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n-    /// the float's value is emitted directly into the token but no suffix is\n-    /// used, so it may be inferred to be a `f64` later in the compiler.\n-    /// Literals created from negative numbers might not survive rountrips through\n-    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function requires that the specified float is finite, for\n-    /// example if it is infinity or NaN this function will panic.\n-    pub fn f64_unsuffixed(n: f64) -> Literal {\n-        if !n.is_finite() {\n-            panic!(\"Invalid float literal {n}\");\n-        }\n-        let mut repr = n.to_string();\n-        if !repr.contains('.') {\n-            repr.push_str(\".0\");\n-        }\n-        Literal(bridge::client::Literal::float(&repr))\n-    }\n-\n-    /// Creates a new suffixed floating-point literal.\n-    ///\n-    /// This constructor will create a literal like `1.0f64` where the value\n-    /// specified is the preceding part of the token and `f64` is the suffix of\n-    /// the token. This token will always be inferred to be an `f64` in the\n-    /// compiler.\n-    /// Literals created from negative numbers might not survive rountrips through\n-    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function requires that the specified float is finite, for\n-    /// example if it is infinity or NaN this function will panic.\n-    pub fn f64_suffixed(n: f64) -> Literal {\n-        if !n.is_finite() {\n-            panic!(\"Invalid float literal {n}\");\n-        }\n-        Literal(bridge::client::Literal::f64(&n.to_string()))\n-    }\n-\n-    /// String literal.\n-    pub fn string(string: &str) -> Literal {\n-        Literal(bridge::client::Literal::string(string))\n-    }\n-\n-    /// Character literal.\n-    pub fn character(ch: char) -> Literal {\n-        Literal(bridge::client::Literal::character(ch))\n-    }\n-\n-    /// Byte string literal.\n-    pub fn byte_string(bytes: &[u8]) -> Literal {\n-        Literal(bridge::client::Literal::byte_string(bytes))\n-    }\n-\n-    /// Returns the span encompassing this literal.\n-    pub fn span(&self) -> Span {\n-        Span(self.0.span())\n-    }\n-\n-    /// Configures the span associated for this literal.\n-    pub fn set_span(&mut self, span: Span) {\n-        self.0.set_span(span.0);\n-    }\n-\n-    /// Returns a `Span` that is a subset of `self.span()` containing only the\n-    /// source bytes in range `range`. Returns `None` if the would-be trimmed\n-    /// span is outside the bounds of `self`.\n-    // FIXME(SergioBenitez): check that the byte range starts and ends at a\n-    // UTF-8 boundary of the source. otherwise, it's likely that a panic will\n-    // occur elsewhere when the source text is printed.\n-    // FIXME(SergioBenitez): there is no way for the user to know what\n-    // `self.span()` actually maps to, so this method can currently only be\n-    // called blindly. For example, `to_string()` for the character 'c' returns\n-    // \"'\\u{63}'\"; there is no way for the user to know whether the source text\n-    // was 'c' or whether it was '\\u{63}'.\n-    pub fn subspan<R: RangeBounds<usize>>(&self, range: R) -> Option<Span> {\n-        self.0.subspan(range.start_bound().cloned(), range.end_bound().cloned()).map(Span)\n-    }\n-}\n-\n-/// Parse a single literal from its stringified representation.\n-///\n-/// In order to parse successfully, the input string must not contain anything\n-/// but the literal token. Specifically, it must not contain whitespace or\n-/// comments in addition to the literal.\n-///\n-/// The resulting literal token will have a `Span::call_site()` span.\n-///\n-/// NOTE: some errors may cause panics instead of returning `LexError`. We\n-/// reserve the right to change these errors into `LexError`s later.\n-impl FromStr for Literal {\n-    type Err = LexError;\n-\n-    fn from_str(src: &str) -> Result<Self, LexError> {\n-        match bridge::client::Literal::from_str(src) {\n-            Ok(literal) => Ok(Literal(literal)),\n-            Err(()) => Err(LexError),\n-        }\n-    }\n-}\n-\n-/// Prints the literal as a string that should be losslessly convertible\n-/// back into the same literal (except for possible rounding for floating point literals).\n-impl fmt::Display for Literal {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        unimplemented!()\n-    }\n-}\n-\n-impl fmt::Debug for Literal {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0.fmt(f)\n-    }\n-}\n-\n-/// Tracked access to environment variables.\n-pub mod tracked_env {\n-    use std::env::{self, VarError};\n-    use std::ffi::OsStr;\n-\n-    /// Retrieve an environment variable and add it to build dependency info.\n-    /// Build system executing the compiler will know that the variable was accessed during\n-    /// compilation, and will be able to rerun the build when the value of that variable changes.\n-    /// Besides the dependency tracking this function should be equivalent to `env::var` from the\n-    /// standard library, except that the argument must be UTF-8.\n-    pub fn var<K: AsRef<OsStr> + AsRef<str>>(key: K) -> Result<String, VarError> {\n-        let key: &str = key.as_ref();\n-        let value = env::var(key);\n-        super::bridge::client::FreeFunctions::track_env_var(key, value.as_deref().ok());\n-        value\n-    }\n-}\n-\n-/// Tracked access to additional files.\n-pub mod tracked_path {\n-\n-    /// Track a file explicitly.\n-    ///\n-    /// Commonly used for tracking asset preprocessing.\n-    pub fn path<P: AsRef<str>>(path: P) {\n-        let path: &str = path.as_ref();\n-        super::bridge::client::FreeFunctions::track_path(path);\n-    }\n-}"}, {"sha": "39309faa412133f1c3638332f1a0502cdc9f6248", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/proc_macro/quote.rs", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fproc_macro%2Fquote.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,139 +0,0 @@\n-//! # Quasiquoter\n-//! This file contains the implementation internals of the quasiquoter provided by `quote!`.\n-\n-//! This quasiquoter uses macros 2.0 hygiene to reliably access\n-//! items from `proc_macro`, to build a `proc_macro::TokenStream`.\n-\n-use super::{Delimiter, Group, Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree};\n-\n-macro_rules! quote_tt {\n-    (($($t:tt)*)) => { Group::new(Delimiter::Parenthesis, quote!($($t)*)) };\n-    ([$($t:tt)*]) => { Group::new(Delimiter::Bracket, quote!($($t)*)) };\n-    ({$($t:tt)*}) => { Group::new(Delimiter::Brace, quote!($($t)*)) };\n-    (,) => { Punct::new(',', Spacing::Alone) };\n-    (.) => { Punct::new('.', Spacing::Alone) };\n-    (;) => { Punct::new(';', Spacing::Alone) };\n-    (!) => { Punct::new('!', Spacing::Alone) };\n-    (<) => { Punct::new('<', Spacing::Alone) };\n-    (>) => { Punct::new('>', Spacing::Alone) };\n-    (&) => { Punct::new('&', Spacing::Alone) };\n-    (=) => { Punct::new('=', Spacing::Alone) };\n-    ($i:ident) => { Ident::new(stringify!($i), Span::def_site()) };\n-}\n-\n-macro_rules! quote_ts {\n-    ((@ $($t:tt)*)) => { $($t)* };\n-    (::) => {\n-        [\n-            TokenTree::from(Punct::new(':', Spacing::Joint)),\n-            TokenTree::from(Punct::new(':', Spacing::Alone)),\n-        ].iter()\n-            .cloned()\n-            .map(|mut x| {\n-                x.set_span(Span::def_site());\n-                x\n-            })\n-            .collect::<TokenStream>()\n-    };\n-    ($t:tt) => { TokenTree::from(quote_tt!($t)) };\n-}\n-\n-/// Simpler version of the real `quote!` macro, implemented solely\n-/// through `macro_rules`, for bootstrapping the real implementation\n-/// (see the `quote` function), which does not have access to the\n-/// real `quote!` macro due to the `proc_macro` crate not being\n-/// able to depend on itself.\n-///\n-/// Note: supported tokens are a subset of the real `quote!`, but\n-/// unquoting is different: instead of `$x`, this uses `(@ expr)`.\n-macro_rules! quote {\n-    () => { TokenStream::new() };\n-    ($($t:tt)*) => {\n-        [\n-            $(TokenStream::from(quote_ts!($t)),)*\n-        ].iter().cloned().collect::<TokenStream>()\n-    };\n-}\n-\n-/// Quote a `TokenStream` into a `TokenStream`.\n-/// This is the actual implementation of the `quote!()` proc macro.\n-///\n-/// It is loaded by the compiler in `register_builtin_macros`.\n-pub fn quote(stream: TokenStream) -> TokenStream {\n-    if stream.is_empty() {\n-        return quote!(super::TokenStream::new());\n-    }\n-    let proc_macro_crate = quote!(crate);\n-    let mut after_dollar = false;\n-    let tokens = stream\n-        .into_iter()\n-        .filter_map(|tree| {\n-            if after_dollar {\n-                after_dollar = false;\n-                match tree {\n-                    TokenTree::Ident(_) => {\n-                        return Some(quote!(Into::<super::TokenStream>::into(\n-                        Clone::clone(&(@ tree))),));\n-                    }\n-                    TokenTree::Punct(ref tt) if tt.as_char() == '$' => {}\n-                    _ => panic!(\"`$` must be followed by an ident or `$` in `quote!`\"),\n-                }\n-            } else if let TokenTree::Punct(ref tt) = tree {\n-                if tt.as_char() == '$' {\n-                    after_dollar = true;\n-                    return None;\n-                }\n-            }\n-\n-            Some(quote!(super::TokenStream::from((@ match tree {\n-                TokenTree::Punct(tt) => quote!(super::TokenTree::Punct(super::Punct::new(\n-                    (@ TokenTree::from(Literal::character(tt.as_char()))),\n-                    (@ match tt.spacing() {\n-                        Spacing::Alone => quote!(super::Spacing::Alone),\n-                        Spacing::Joint => quote!(super::Spacing::Joint),\n-                    }),\n-                ))),\n-                TokenTree::Group(tt) => quote!(super::TokenTree::Group(super::Group::new(\n-                    (@ match tt.delimiter() {\n-                        Delimiter::Parenthesis => quote!(super::Delimiter::Parenthesis),\n-                        Delimiter::Brace => quote!(super::Delimiter::Brace),\n-                        Delimiter::Bracket => quote!(super::Delimiter::Bracket),\n-                        Delimiter::None => quote!(super::Delimiter::None),\n-                    }),\n-                    (@ quote(tt.stream())),\n-                ))),\n-                TokenTree::Ident(tt) => quote!(super::TokenTree::Ident(super::Ident::new(\n-                    (@ TokenTree::from(Literal::string(&tt.to_string()))),\n-                    (@ quote_span(proc_macro_crate.clone(), tt.span())),\n-                ))),\n-                TokenTree::Literal(tt) => quote!(super::TokenTree::Literal({\n-                    let mut iter = (@ TokenTree::from(Literal::string(&tt.to_string())))\n-                        .parse::<super::TokenStream>()\n-                        .unwrap()\n-                        .into_iter();\n-                    if let (Some(super::TokenTree::Literal(mut lit)), None) =\n-                        (iter.next(), iter.next())\n-                    {\n-                        lit.set_span((@ quote_span(proc_macro_crate.clone(), tt.span())));\n-                        lit\n-                    } else {\n-                        unreachable!()\n-                    }\n-                }))\n-            })),))\n-        })\n-        .collect::<TokenStream>();\n-\n-    if after_dollar {\n-        panic!(\"unexpected trailing `$` in `quote!`\");\n-    }\n-\n-    quote!([(@ tokens)].iter().cloned().collect::<super::TokenStream>())\n-}\n-\n-/// Quote a `Span` into a `TokenStream`.\n-/// This is needed to implement a custom quoter.\n-pub fn quote_span(proc_macro_crate: TokenStream, span: Span) -> TokenStream {\n-    let id = span.save_span();\n-    quote!((@ proc_macro_crate ) ::Span::recover_proc_macro_span((@ TokenTree::from(Literal::usize_unsuffixed(id)))))\n-}"}, {"sha": "30baf3a13f57f5399857619510ac6ed8cd37e5be", "filename": "crates/proc-macro-srv/src/abis/abi_1_63/ra_server.rs", "status": "removed", "additions": 0, "deletions": 840, "changes": 840, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_1_63%2Fra_server.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,840 +0,0 @@\n-//! Rustc proc-macro server implementation with tt\n-//!\n-//! Based on idea from <https://github.com/fedochet/rust-proc-macro-expander>\n-//! The lib-proc-macro server backend is `TokenStream`-agnostic, such that\n-//! we could provide any TokenStream implementation.\n-//! The original idea from fedochet is using proc-macro2 as backend,\n-//! we use tt instead for better integration with RA.\n-//!\n-//! FIXME: No span and source file information is implemented yet\n-\n-use super::proc_macro::bridge::{self, server};\n-\n-use std::collections::HashMap;\n-use std::hash::Hash;\n-use std::ops::Bound;\n-use std::{ascii, vec::IntoIter};\n-\n-use crate::tt;\n-\n-type Group = tt::Subtree;\n-type TokenTree = tt::TokenTree;\n-type Punct = tt::Punct;\n-type Spacing = tt::Spacing;\n-type Literal = tt::Literal;\n-type Span = tt::TokenId;\n-\n-#[derive(Debug, Default, Clone)]\n-pub struct TokenStream {\n-    pub token_trees: Vec<TokenTree>,\n-}\n-\n-impl TokenStream {\n-    pub fn new() -> Self {\n-        TokenStream::default()\n-    }\n-\n-    pub fn with_subtree(subtree: tt::Subtree) -> Self {\n-        if subtree.delimiter.kind != tt::DelimiterKind::Invisible {\n-            TokenStream { token_trees: vec![TokenTree::Subtree(subtree)] }\n-        } else {\n-            TokenStream { token_trees: subtree.token_trees }\n-        }\n-    }\n-\n-    pub fn into_subtree(self) -> tt::Subtree {\n-        tt::Subtree { delimiter: tt::Delimiter::UNSPECIFIED, token_trees: self.token_trees }\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.token_trees.is_empty()\n-    }\n-}\n-\n-/// Creates a token stream containing a single token tree.\n-impl From<TokenTree> for TokenStream {\n-    fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream { token_trees: vec![tree] }\n-    }\n-}\n-\n-/// Collects a number of token trees into a single stream.\n-impl FromIterator<TokenTree> for TokenStream {\n-    fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n-        trees.into_iter().map(TokenStream::from).collect()\n-    }\n-}\n-\n-/// A \"flattening\" operation on token streams, collects token trees\n-/// from multiple token streams into a single stream.\n-impl FromIterator<TokenStream> for TokenStream {\n-    fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n-        let mut builder = TokenStreamBuilder::new();\n-        streams.into_iter().for_each(|stream| builder.push(stream));\n-        builder.build()\n-    }\n-}\n-\n-impl Extend<TokenTree> for TokenStream {\n-    fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, trees: I) {\n-        self.extend(trees.into_iter().map(TokenStream::from));\n-    }\n-}\n-\n-impl Extend<TokenStream> for TokenStream {\n-    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n-        for item in streams {\n-            for tkn in item {\n-                match tkn {\n-                    tt::TokenTree::Subtree(subtree)\n-                        if subtree.delimiter.kind == tt::DelimiterKind::Invisible =>\n-                    {\n-                        self.token_trees.extend(subtree.token_trees);\n-                    }\n-                    _ => {\n-                        self.token_trees.push(tkn);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct SourceFile {\n-    // FIXME stub\n-}\n-\n-type Level = super::proc_macro::Level;\n-type LineColumn = super::proc_macro::LineColumn;\n-\n-/// A structure representing a diagnostic message and associated children\n-/// messages.\n-#[derive(Clone, Debug)]\n-pub struct Diagnostic {\n-    level: Level,\n-    message: String,\n-    spans: Vec<Span>,\n-    children: Vec<Diagnostic>,\n-}\n-\n-impl Diagnostic {\n-    /// Creates a new diagnostic with the given `level` and `message`.\n-    pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n-        Diagnostic { level, message: message.into(), spans: vec![], children: vec![] }\n-    }\n-}\n-\n-// Rustc Server Ident has to be `Copyable`\n-// We use a stub here for bypassing\n-#[derive(Hash, Eq, PartialEq, Copy, Clone)]\n-pub struct IdentId(u32);\n-\n-#[derive(Clone, Hash, Eq, PartialEq)]\n-struct IdentData(tt::Ident);\n-\n-#[derive(Default)]\n-struct IdentInterner {\n-    idents: HashMap<IdentData, u32>,\n-    ident_data: Vec<IdentData>,\n-}\n-\n-impl IdentInterner {\n-    fn intern(&mut self, data: &IdentData) -> u32 {\n-        if let Some(index) = self.idents.get(data) {\n-            return *index;\n-        }\n-\n-        let index = self.idents.len() as u32;\n-        self.ident_data.push(data.clone());\n-        self.idents.insert(data.clone(), index);\n-        index\n-    }\n-\n-    fn get(&self, index: u32) -> &IdentData {\n-        &self.ident_data[index as usize]\n-    }\n-\n-    #[allow(unused)]\n-    fn get_mut(&mut self, index: u32) -> &mut IdentData {\n-        self.ident_data.get_mut(index as usize).expect(\"Should be consistent\")\n-    }\n-}\n-\n-pub struct TokenStreamBuilder {\n-    acc: TokenStream,\n-}\n-\n-/// Public implementation details for the `TokenStream` type, such as iterators.\n-pub mod token_stream {\n-    use std::str::FromStr;\n-\n-    use super::{tt, TokenStream, TokenTree};\n-\n-    /// An iterator over `TokenStream`'s `TokenTree`s.\n-    /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n-    /// and returns whole groups as token trees.\n-    impl IntoIterator for TokenStream {\n-        type Item = TokenTree;\n-        type IntoIter = super::IntoIter<TokenTree>;\n-\n-        fn into_iter(self) -> Self::IntoIter {\n-            self.token_trees.into_iter()\n-        }\n-    }\n-\n-    type LexError = String;\n-\n-    /// Attempts to break the string into tokens and parse those tokens into a token stream.\n-    /// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n-    /// or characters not existing in the language.\n-    /// All tokens in the parsed stream get `Span::call_site()` spans.\n-    ///\n-    /// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n-    /// change these errors into `LexError`s later.\n-    impl FromStr for TokenStream {\n-        type Err = LexError;\n-\n-        fn from_str(src: &str) -> Result<TokenStream, LexError> {\n-            let (subtree, _token_map) =\n-                mbe::parse_to_token_tree(src).ok_or(\"Failed to parse from mbe\")?;\n-\n-            let subtree = subtree_replace_token_ids_with_unspecified(subtree);\n-            Ok(TokenStream::with_subtree(subtree))\n-        }\n-    }\n-\n-    impl ToString for TokenStream {\n-        fn to_string(&self) -> String {\n-            ::tt::pretty(&self.token_trees)\n-        }\n-    }\n-\n-    fn subtree_replace_token_ids_with_unspecified(subtree: tt::Subtree) -> tt::Subtree {\n-        tt::Subtree {\n-            delimiter: tt::Delimiter {\n-                open: tt::TokenId::UNSPECIFIED,\n-                close: tt::TokenId::UNSPECIFIED,\n-                ..subtree.delimiter\n-            },\n-            token_trees: subtree\n-                .token_trees\n-                .into_iter()\n-                .map(token_tree_replace_token_ids_with_unspecified)\n-                .collect(),\n-        }\n-    }\n-\n-    fn token_tree_replace_token_ids_with_unspecified(tt: tt::TokenTree) -> tt::TokenTree {\n-        match tt {\n-            tt::TokenTree::Leaf(leaf) => {\n-                tt::TokenTree::Leaf(leaf_replace_token_ids_with_unspecified(leaf))\n-            }\n-            tt::TokenTree::Subtree(subtree) => {\n-                tt::TokenTree::Subtree(subtree_replace_token_ids_with_unspecified(subtree))\n-            }\n-        }\n-    }\n-\n-    fn leaf_replace_token_ids_with_unspecified(leaf: tt::Leaf) -> tt::Leaf {\n-        match leaf {\n-            tt::Leaf::Literal(lit) => {\n-                tt::Leaf::Literal(tt::Literal { span: tt::TokenId::unspecified(), ..lit })\n-            }\n-            tt::Leaf::Punct(punct) => {\n-                tt::Leaf::Punct(tt::Punct { span: tt::TokenId::unspecified(), ..punct })\n-            }\n-            tt::Leaf::Ident(ident) => {\n-                tt::Leaf::Ident(tt::Ident { span: tt::TokenId::unspecified(), ..ident })\n-            }\n-        }\n-    }\n-}\n-\n-impl TokenStreamBuilder {\n-    fn new() -> TokenStreamBuilder {\n-        TokenStreamBuilder { acc: TokenStream::new() }\n-    }\n-\n-    fn push(&mut self, stream: TokenStream) {\n-        self.acc.extend(stream.into_iter())\n-    }\n-\n-    fn build(self) -> TokenStream {\n-        self.acc\n-    }\n-}\n-\n-pub struct FreeFunctions;\n-\n-#[derive(Clone)]\n-pub struct TokenStreamIter {\n-    trees: IntoIter<TokenTree>,\n-}\n-\n-#[derive(Default)]\n-pub struct RustAnalyzer {\n-    ident_interner: IdentInterner,\n-    // FIXME: store span information here.\n-}\n-\n-impl server::Types for RustAnalyzer {\n-    type FreeFunctions = FreeFunctions;\n-    type TokenStream = TokenStream;\n-    type Group = Group;\n-    type Punct = Punct;\n-    type Ident = IdentId;\n-    type Literal = Literal;\n-    type SourceFile = SourceFile;\n-    type Diagnostic = Diagnostic;\n-    type Span = Span;\n-    type MultiSpan = Vec<Span>;\n-}\n-\n-impl server::FreeFunctions for RustAnalyzer {\n-    fn track_env_var(&mut self, _var: &str, _value: Option<&str>) {\n-        // FIXME: track env var accesses\n-        // https://github.com/rust-lang/rust/pull/71858\n-    }\n-    fn track_path(&mut self, _path: &str) {}\n-}\n-\n-impl server::TokenStream for RustAnalyzer {\n-    fn is_empty(&mut self, stream: &Self::TokenStream) -> bool {\n-        stream.is_empty()\n-    }\n-    fn from_str(&mut self, src: &str) -> Self::TokenStream {\n-        use std::str::FromStr;\n-\n-        Self::TokenStream::from_str(src).expect(\"cannot parse string\")\n-    }\n-    fn to_string(&mut self, stream: &Self::TokenStream) -> String {\n-        stream.to_string()\n-    }\n-    fn from_token_tree(\n-        &mut self,\n-        tree: bridge::TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>,\n-    ) -> Self::TokenStream {\n-        match tree {\n-            bridge::TokenTree::Group(group) => {\n-                let tree = TokenTree::from(group);\n-                Self::TokenStream::from_iter(vec![tree])\n-            }\n-\n-            bridge::TokenTree::Ident(IdentId(index)) => {\n-                let IdentData(ident) = self.ident_interner.get(index).clone();\n-                let ident: tt::Ident = ident;\n-                let leaf = tt::Leaf::from(ident);\n-                let tree = TokenTree::from(leaf);\n-                Self::TokenStream::from_iter(vec![tree])\n-            }\n-\n-            bridge::TokenTree::Literal(literal) => {\n-                let leaf = tt::Leaf::from(literal);\n-                let tree = TokenTree::from(leaf);\n-                Self::TokenStream::from_iter(vec![tree])\n-            }\n-\n-            bridge::TokenTree::Punct(p) => {\n-                let leaf = tt::Leaf::from(p);\n-                let tree = TokenTree::from(leaf);\n-                Self::TokenStream::from_iter(vec![tree])\n-            }\n-        }\n-    }\n-\n-    fn expand_expr(&mut self, self_: &Self::TokenStream) -> Result<Self::TokenStream, ()> {\n-        Ok(self_.clone())\n-    }\n-\n-    fn concat_trees(\n-        &mut self,\n-        base: Option<Self::TokenStream>,\n-        trees: Vec<bridge::TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>>,\n-    ) -> Self::TokenStream {\n-        let mut builder = TokenStreamBuilder::new();\n-        if let Some(base) = base {\n-            builder.push(base);\n-        }\n-        for tree in trees {\n-            builder.push(self.from_token_tree(tree));\n-        }\n-        builder.build()\n-    }\n-\n-    fn concat_streams(\n-        &mut self,\n-        base: Option<Self::TokenStream>,\n-        streams: Vec<Self::TokenStream>,\n-    ) -> Self::TokenStream {\n-        let mut builder = TokenStreamBuilder::new();\n-        if let Some(base) = base {\n-            builder.push(base);\n-        }\n-        for stream in streams {\n-            builder.push(stream);\n-        }\n-        builder.build()\n-    }\n-\n-    fn into_trees(\n-        &mut self,\n-        stream: Self::TokenStream,\n-    ) -> Vec<bridge::TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>> {\n-        stream\n-            .into_iter()\n-            .map(|tree| match tree {\n-                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n-                    bridge::TokenTree::Ident(IdentId(self.ident_interner.intern(&IdentData(ident))))\n-                }\n-                tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) => bridge::TokenTree::Literal(lit),\n-                tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => bridge::TokenTree::Punct(punct),\n-                tt::TokenTree::Subtree(subtree) => bridge::TokenTree::Group(subtree),\n-            })\n-            .collect()\n-    }\n-}\n-\n-fn delim_to_internal(d: bridge::Delimiter) -> tt::Delimiter {\n-    let kind = match d {\n-        bridge::Delimiter::Parenthesis => tt::DelimiterKind::Parenthesis,\n-        bridge::Delimiter::Brace => tt::DelimiterKind::Brace,\n-        bridge::Delimiter::Bracket => tt::DelimiterKind::Bracket,\n-        bridge::Delimiter::None => tt::DelimiterKind::Invisible,\n-    };\n-    tt::Delimiter { open: tt::TokenId::unspecified(), close: tt::TokenId::unspecified(), kind }\n-}\n-\n-fn delim_to_external(d: tt::Delimiter) -> bridge::Delimiter {\n-    match d.kind {\n-        tt::DelimiterKind::Parenthesis => bridge::Delimiter::Parenthesis,\n-        tt::DelimiterKind::Brace => bridge::Delimiter::Brace,\n-        tt::DelimiterKind::Bracket => bridge::Delimiter::Bracket,\n-        tt::DelimiterKind::Invisible => bridge::Delimiter::None,\n-    }\n-}\n-\n-fn spacing_to_internal(spacing: bridge::Spacing) -> Spacing {\n-    match spacing {\n-        bridge::Spacing::Alone => Spacing::Alone,\n-        bridge::Spacing::Joint => Spacing::Joint,\n-    }\n-}\n-\n-fn spacing_to_external(spacing: Spacing) -> bridge::Spacing {\n-    match spacing {\n-        Spacing::Alone => bridge::Spacing::Alone,\n-        Spacing::Joint => bridge::Spacing::Joint,\n-    }\n-}\n-\n-impl server::Group for RustAnalyzer {\n-    fn new(\n-        &mut self,\n-        delimiter: bridge::Delimiter,\n-        stream: Option<Self::TokenStream>,\n-    ) -> Self::Group {\n-        Self::Group {\n-            delimiter: delim_to_internal(delimiter),\n-            token_trees: stream.unwrap_or_default().token_trees,\n-        }\n-    }\n-    fn delimiter(&mut self, group: &Self::Group) -> bridge::Delimiter {\n-        delim_to_external(group.delimiter)\n-    }\n-\n-    // NOTE: Return value of do not include delimiter\n-    fn stream(&mut self, group: &Self::Group) -> Self::TokenStream {\n-        TokenStream { token_trees: group.token_trees.clone() }\n-    }\n-\n-    fn span(&mut self, group: &Self::Group) -> Self::Span {\n-        group.delimiter.open\n-    }\n-\n-    fn set_span(&mut self, group: &mut Self::Group, span: Self::Span) {\n-        group.delimiter.open = span;\n-    }\n-\n-    fn span_open(&mut self, group: &Self::Group) -> Self::Span {\n-        group.delimiter.open\n-    }\n-\n-    fn span_close(&mut self, group: &Self::Group) -> Self::Span {\n-        group.delimiter.close\n-    }\n-}\n-\n-impl server::Punct for RustAnalyzer {\n-    fn new(&mut self, ch: char, spacing: bridge::Spacing) -> Self::Punct {\n-        tt::Punct {\n-            char: ch,\n-            spacing: spacing_to_internal(spacing),\n-            span: tt::TokenId::unspecified(),\n-        }\n-    }\n-    fn as_char(&mut self, punct: Self::Punct) -> char {\n-        punct.char\n-    }\n-    fn spacing(&mut self, punct: Self::Punct) -> bridge::Spacing {\n-        spacing_to_external(punct.spacing)\n-    }\n-    fn span(&mut self, punct: Self::Punct) -> Self::Span {\n-        punct.span\n-    }\n-    fn with_span(&mut self, punct: Self::Punct, span: Self::Span) -> Self::Punct {\n-        tt::Punct { span: span, ..punct }\n-    }\n-}\n-\n-impl server::Ident for RustAnalyzer {\n-    fn new(&mut self, string: &str, span: Self::Span, is_raw: bool) -> Self::Ident {\n-        IdentId(self.ident_interner.intern(&IdentData(tt::Ident {\n-            text: if is_raw { ::tt::SmolStr::from_iter([\"r#\", string]) } else { string.into() },\n-            span,\n-        })))\n-    }\n-\n-    fn span(&mut self, ident: Self::Ident) -> Self::Span {\n-        self.ident_interner.get(ident.0).0.span\n-    }\n-    fn with_span(&mut self, ident: Self::Ident, span: Self::Span) -> Self::Ident {\n-        let data = self.ident_interner.get(ident.0);\n-        let new = IdentData(tt::Ident { span: span, ..data.0.clone() });\n-        IdentId(self.ident_interner.intern(&new))\n-    }\n-}\n-\n-impl server::Literal for RustAnalyzer {\n-    fn debug_kind(&mut self, _literal: &Self::Literal) -> String {\n-        // r-a: debug_kind and suffix are unsupported; corresponding client code has been changed to not call these.\n-        // They must still be present to be ABI-compatible and work with upstream proc_macro.\n-        \"\".to_owned()\n-    }\n-    fn from_str(&mut self, s: &str) -> Result<Self::Literal, ()> {\n-        Ok(Literal { text: s.into(), span: tt::TokenId::unspecified() })\n-    }\n-    fn symbol(&mut self, literal: &Self::Literal) -> String {\n-        literal.text.to_string()\n-    }\n-    fn suffix(&mut self, _literal: &Self::Literal) -> Option<String> {\n-        None\n-    }\n-\n-    fn to_string(&mut self, literal: &Self::Literal) -> String {\n-        literal.to_string()\n-    }\n-\n-    fn integer(&mut self, n: &str) -> Self::Literal {\n-        let n = match n.parse::<i128>() {\n-            Ok(n) => n.to_string(),\n-            Err(_) => n.parse::<u128>().unwrap().to_string(),\n-        };\n-        Literal { text: n.into(), span: tt::TokenId::unspecified() }\n-    }\n-\n-    fn typed_integer(&mut self, n: &str, kind: &str) -> Self::Literal {\n-        macro_rules! def_suffixed_integer {\n-            ($kind:ident, $($ty:ty),*) => {\n-                match $kind {\n-                    $(\n-                        stringify!($ty) => {\n-                            let n: $ty = n.parse().unwrap();\n-                            format!(concat!(\"{}\", stringify!($ty)), n)\n-                        }\n-                    )*\n-                    _ => unimplemented!(\"unknown args for typed_integer: n {}, kind {}\", n, $kind),\n-                }\n-            }\n-        }\n-\n-        let text = def_suffixed_integer! {kind, u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize};\n-\n-        Literal { text: text.into(), span: tt::TokenId::unspecified() }\n-    }\n-\n-    fn float(&mut self, n: &str) -> Self::Literal {\n-        let n: f64 = n.parse().unwrap();\n-        let mut text = f64::to_string(&n);\n-        if !text.contains('.') {\n-            text += \".0\"\n-        }\n-        Literal { text: text.into(), span: tt::TokenId::unspecified() }\n-    }\n-\n-    fn f32(&mut self, n: &str) -> Self::Literal {\n-        let n: f32 = n.parse().unwrap();\n-        let text = format!(\"{n}f32\");\n-        Literal { text: text.into(), span: tt::TokenId::unspecified() }\n-    }\n-\n-    fn f64(&mut self, n: &str) -> Self::Literal {\n-        let n: f64 = n.parse().unwrap();\n-        let text = format!(\"{n}f64\");\n-        Literal { text: text.into(), span: tt::TokenId::unspecified() }\n-    }\n-\n-    fn string(&mut self, string: &str) -> Self::Literal {\n-        let mut escaped = String::new();\n-        for ch in string.chars() {\n-            escaped.extend(ch.escape_debug());\n-        }\n-        Literal { text: format!(\"\\\"{escaped}\\\"\").into(), span: tt::TokenId::unspecified() }\n-    }\n-\n-    fn character(&mut self, ch: char) -> Self::Literal {\n-        Literal { text: format!(\"'{ch}'\").into(), span: tt::TokenId::unspecified() }\n-    }\n-\n-    fn byte_string(&mut self, bytes: &[u8]) -> Self::Literal {\n-        let string = bytes\n-            .iter()\n-            .cloned()\n-            .flat_map(ascii::escape_default)\n-            .map(Into::<char>::into)\n-            .collect::<String>();\n-\n-        Literal { text: format!(\"b\\\"{string}\\\"\").into(), span: tt::TokenId::unspecified() }\n-    }\n-\n-    fn span(&mut self, literal: &Self::Literal) -> Self::Span {\n-        literal.span\n-    }\n-\n-    fn set_span(&mut self, literal: &mut Self::Literal, span: Self::Span) {\n-        literal.span = span;\n-    }\n-\n-    fn subspan(\n-        &mut self,\n-        _literal: &Self::Literal,\n-        _start: Bound<usize>,\n-        _end: Bound<usize>,\n-    ) -> Option<Self::Span> {\n-        // FIXME handle span\n-        None\n-    }\n-}\n-\n-impl server::SourceFile for RustAnalyzer {\n-    // FIXME these are all stubs\n-    fn eq(&mut self, _file1: &Self::SourceFile, _file2: &Self::SourceFile) -> bool {\n-        true\n-    }\n-    fn path(&mut self, _file: &Self::SourceFile) -> String {\n-        String::new()\n-    }\n-    fn is_real(&mut self, _file: &Self::SourceFile) -> bool {\n-        true\n-    }\n-}\n-\n-impl server::Diagnostic for RustAnalyzer {\n-    fn new(&mut self, level: Level, msg: &str, spans: Self::MultiSpan) -> Self::Diagnostic {\n-        let mut diag = Diagnostic::new(level, msg);\n-        diag.spans = spans;\n-        diag\n-    }\n-\n-    fn sub(\n-        &mut self,\n-        _diag: &mut Self::Diagnostic,\n-        _level: Level,\n-        _msg: &str,\n-        _spans: Self::MultiSpan,\n-    ) {\n-        // FIXME handle diagnostic\n-        //\n-    }\n-\n-    fn emit(&mut self, _diag: Self::Diagnostic) {\n-        // FIXME handle diagnostic\n-        // diag.emit()\n-    }\n-}\n-\n-impl server::Span for RustAnalyzer {\n-    fn debug(&mut self, span: Self::Span) -> String {\n-        format!(\"{:?}\", span.0)\n-    }\n-    fn def_site(&mut self) -> Self::Span {\n-        // MySpan(self.span_interner.intern(&MySpanData(Span::def_site())))\n-        // FIXME handle span\n-        tt::TokenId::unspecified()\n-    }\n-    fn call_site(&mut self) -> Self::Span {\n-        // MySpan(self.span_interner.intern(&MySpanData(Span::call_site())))\n-        // FIXME handle span\n-        tt::TokenId::unspecified()\n-    }\n-    fn source_file(&mut self, _span: Self::Span) -> Self::SourceFile {\n-        SourceFile {}\n-    }\n-    fn save_span(&mut self, _span: Self::Span) -> usize {\n-        // FIXME stub\n-        0\n-    }\n-    fn recover_proc_macro_span(&mut self, _id: usize) -> Self::Span {\n-        // FIXME stub\n-        tt::TokenId::unspecified()\n-    }\n-    /// Recent feature, not yet in the proc_macro\n-    ///\n-    /// See PR:\n-    /// https://github.com/rust-lang/rust/pull/55780\n-    fn source_text(&mut self, _span: Self::Span) -> Option<String> {\n-        None\n-    }\n-\n-    fn parent(&mut self, _span: Self::Span) -> Option<Self::Span> {\n-        // FIXME handle span\n-        None\n-    }\n-    fn source(&mut self, span: Self::Span) -> Self::Span {\n-        // FIXME handle span\n-        span\n-    }\n-    fn start(&mut self, _span: Self::Span) -> LineColumn {\n-        // FIXME handle span\n-        LineColumn { line: 0, column: 0 }\n-    }\n-    fn end(&mut self, _span: Self::Span) -> LineColumn {\n-        // FIXME handle span\n-        LineColumn { line: 0, column: 0 }\n-    }\n-    fn join(&mut self, first: Self::Span, _second: Self::Span) -> Option<Self::Span> {\n-        // Just return the first span again, because some macros will unwrap the result.\n-        Some(first)\n-    }\n-    fn resolved_at(&mut self, _span: Self::Span, _at: Self::Span) -> Self::Span {\n-        // FIXME handle span\n-        tt::TokenId::unspecified()\n-    }\n-\n-    fn mixed_site(&mut self) -> Self::Span {\n-        // FIXME handle span\n-        tt::TokenId::unspecified()\n-    }\n-\n-    fn after(&mut self, _self_: Self::Span) -> Self::Span {\n-        tt::TokenId::unspecified()\n-    }\n-\n-    fn before(&mut self, _self_: Self::Span) -> Self::Span {\n-        tt::TokenId::unspecified()\n-    }\n-}\n-\n-impl server::MultiSpan for RustAnalyzer {\n-    fn new(&mut self) -> Self::MultiSpan {\n-        // FIXME handle span\n-        vec![]\n-    }\n-\n-    fn push(&mut self, other: &mut Self::MultiSpan, span: Self::Span) {\n-        //TODP\n-        other.push(span)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::super::proc_macro::bridge::server::Literal;\n-    use super::*;\n-\n-    #[test]\n-    fn test_ra_server_literals() {\n-        let mut srv = RustAnalyzer { ident_interner: IdentInterner::default() };\n-        assert_eq!(srv.integer(\"1234\").text, \"1234\");\n-\n-        assert_eq!(srv.typed_integer(\"12\", \"u8\").text, \"12u8\");\n-        assert_eq!(srv.typed_integer(\"255\", \"u16\").text, \"255u16\");\n-        assert_eq!(srv.typed_integer(\"1234\", \"u32\").text, \"1234u32\");\n-        assert_eq!(srv.typed_integer(\"15846685\", \"u64\").text, \"15846685u64\");\n-        assert_eq!(srv.typed_integer(\"15846685258\", \"u128\").text, \"15846685258u128\");\n-        assert_eq!(srv.typed_integer(\"156788984\", \"usize\").text, \"156788984usize\");\n-        assert_eq!(srv.typed_integer(\"127\", \"i8\").text, \"127i8\");\n-        assert_eq!(srv.typed_integer(\"255\", \"i16\").text, \"255i16\");\n-        assert_eq!(srv.typed_integer(\"1234\", \"i32\").text, \"1234i32\");\n-        assert_eq!(srv.typed_integer(\"15846685\", \"i64\").text, \"15846685i64\");\n-        assert_eq!(srv.typed_integer(\"15846685258\", \"i128\").text, \"15846685258i128\");\n-        assert_eq!(srv.float(\"0\").text, \"0.0\");\n-        assert_eq!(srv.float(\"15684.5867\").text, \"15684.5867\");\n-        assert_eq!(srv.f32(\"15684.58\").text, \"15684.58f32\");\n-        assert_eq!(srv.f64(\"15684.58\").text, \"15684.58f64\");\n-\n-        assert_eq!(srv.string(\"hello_world\").text, \"\\\"hello_world\\\"\");\n-        assert_eq!(srv.character('c').text, \"'c'\");\n-        assert_eq!(srv.byte_string(b\"1234586\\x88\").text, \"b\\\"1234586\\\\x88\\\"\");\n-\n-        // u128::max\n-        assert_eq!(\n-            srv.integer(\"340282366920938463463374607431768211455\").text,\n-            \"340282366920938463463374607431768211455\"\n-        );\n-        // i128::min\n-        assert_eq!(\n-            srv.integer(\"-170141183460469231731687303715884105728\").text,\n-            \"-170141183460469231731687303715884105728\"\n-        );\n-    }\n-\n-    #[test]\n-    fn test_ra_server_to_string() {\n-        let s = TokenStream {\n-            token_trees: vec![\n-                tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                    text: \"struct\".into(),\n-                    span: tt::TokenId::unspecified(),\n-                })),\n-                tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                    text: \"T\".into(),\n-                    span: tt::TokenId::unspecified(),\n-                })),\n-                tt::TokenTree::Subtree(tt::Subtree {\n-                    delimiter: tt::Delimiter {\n-                        open: tt::TokenId::unspecified(),\n-                        close: tt::TokenId::unspecified(),\n-                        kind: tt::DelimiterKind::Brace,\n-                    },\n-                    token_trees: vec![],\n-                }),\n-            ],\n-        };\n-\n-        assert_eq!(s.to_string(), \"struct T {}\");\n-    }\n-\n-    #[test]\n-    fn test_ra_server_from_str() {\n-        use std::str::FromStr;\n-        let subtree_paren_a = tt::TokenTree::Subtree(tt::Subtree {\n-            delimiter: tt::Delimiter {\n-                open: tt::TokenId::unspecified(),\n-                close: tt::TokenId::unspecified(),\n-                kind: tt::DelimiterKind::Parenthesis,\n-            },\n-            token_trees: vec![tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                text: \"a\".into(),\n-                span: tt::TokenId::unspecified(),\n-            }))],\n-        });\n-\n-        let t1 = TokenStream::from_str(\"(a)\").unwrap();\n-        assert_eq!(t1.token_trees.len(), 1);\n-        assert_eq!(t1.token_trees[0], subtree_paren_a);\n-\n-        let t2 = TokenStream::from_str(\"(a);\").unwrap();\n-        assert_eq!(t2.token_trees.len(), 2);\n-        assert_eq!(t2.token_trees[0], subtree_paren_a);\n-\n-        let underscore = TokenStream::from_str(\"_\").unwrap();\n-        assert_eq!(\n-            underscore.token_trees[0],\n-            tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n-                text: \"_\".into(),\n-                span: tt::TokenId::unspecified(),\n-            }))\n-        );\n-    }\n-}"}, {"sha": "04be39cffa4adbba3b179dc9a9cf872553c719a8", "filename": "crates/proc-macro-srv/src/abis/mod.rs", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ee157f3b05865984957953df21f4711f8e5cd6/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs?ref=33ee157f3b05865984957953df21f4711f8e5cd6", "patch": "@@ -1,146 +0,0 @@\n-//! Procedural macros are implemented by compiling the macro providing crate\n-//! to a dynamic library with a particular ABI which the compiler uses to expand\n-//! macros. Unfortunately this ABI is not specified and can change from version\n-//! to version of the compiler. To support this we copy the ABI from the rust\n-//! compiler into submodules of this module (e.g proc_macro_srv::abis::abi_1_47).\n-//!\n-//! All of these ABIs are subsumed in the `Abi` enum, which exposes a simple\n-//! interface the rest of rust-analyzer can use to talk to the macro\n-//! provider.\n-//!\n-//! # Adding a new ABI\n-//!\n-//! To add a new ABI you'll need to copy the source of the target proc_macro\n-//! crate from the source tree of the Rust compiler into this directory tree.\n-//! Then you'll need to modify it\n-//! - Remove any feature! or other things which won't compile on stable\n-//! - change any absolute imports to relative imports within the ABI tree\n-//!\n-//! Then you'll need to add a branch to the `Abi` enum and an implementation of\n-//! `Abi::expand`, `Abi::list_macros` and `Abi::from_lib` for the new ABI. See\n-//! `proc_macro_srv/src/abis/abi_1_47/mod.rs` for an example. Finally you'll\n-//! need to update the conditionals in `Abi::from_lib` to return your new ABI\n-//! for the relevant versions of the rust compiler\n-//!\n-\n-mod abi_1_63;\n-#[cfg(feature = \"sysroot-abi\")]\n-mod abi_sysroot;\n-\n-// see `build.rs`\n-include!(concat!(env!(\"OUT_DIR\"), \"/rustc_version.rs\"));\n-\n-// Used by `test/utils.rs`\n-#[cfg(all(test, feature = \"sysroot-abi\"))]\n-pub(crate) use abi_sysroot::TokenStream as TestTokenStream;\n-\n-use super::dylib::LoadProcMacroDylibError;\n-pub(crate) use abi_1_63::Abi as Abi_1_63;\n-#[cfg(feature = \"sysroot-abi\")]\n-pub(crate) use abi_sysroot::Abi as Abi_Sysroot;\n-use libloading::Library;\n-use proc_macro_api::{ProcMacroKind, RustCInfo};\n-\n-use crate::tt;\n-\n-pub struct PanicMessage {\n-    message: Option<String>,\n-}\n-\n-impl PanicMessage {\n-    pub fn as_str(&self) -> Option<String> {\n-        self.message.clone()\n-    }\n-}\n-\n-pub(crate) enum Abi {\n-    Abi1_63(Abi_1_63),\n-    #[cfg(feature = \"sysroot-abi\")]\n-    AbiSysroot(Abi_Sysroot),\n-}\n-\n-impl Abi {\n-    /// Load a new ABI.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// *`lib` - The dynamic library containing the macro implementations\n-    /// *`symbol_name` - The symbol name the macros can be found attributes\n-    /// *`info` - RustCInfo about the compiler that was used to compile the\n-    ///           macro crate. This is the information we use to figure out\n-    ///           which ABI to return\n-    pub fn from_lib(\n-        lib: &Library,\n-        symbol_name: String,\n-        info: RustCInfo,\n-    ) -> Result<Abi, LoadProcMacroDylibError> {\n-        // the sysroot ABI relies on `extern proc_macro` with unstable features,\n-        // instead of a snapshot of the proc macro bridge's source code. it's only\n-        // enabled if we have an exact version match.\n-        #[cfg(feature = \"sysroot-abi\")]\n-        {\n-            if info.version_string == RUSTC_VERSION_STRING {\n-                let inner = unsafe { Abi_Sysroot::from_lib(lib, symbol_name) }?;\n-                return Ok(Abi::AbiSysroot(inner));\n-            }\n-\n-            // if we reached this point, versions didn't match. in testing, we\n-            // want that to panic - this could mean that the format of `rustc\n-            // --version` no longer matches the format of the version string\n-            // stored in the `.rustc` section, and we want to catch that in-tree\n-            // with `x.py test`\n-            #[cfg(test)]\n-            {\n-                let allow_mismatch = std::env::var(\"PROC_MACRO_SRV_ALLOW_SYSROOT_MISMATCH\");\n-                if let Ok(\"1\") = allow_mismatch.as_deref() {\n-                    // only used by rust-analyzer developers, when working on the\n-                    // sysroot ABI from the rust-analyzer repository - which should\n-                    // only happen pre-subtree. this can be removed later.\n-                } else {\n-                    panic!(\n-                        \"sysroot ABI mismatch: dylib rustc version (read from .rustc section): {:?} != proc-macro-srv version (read from 'rustc --version'): {:?}\",\n-                        info.version_string, RUSTC_VERSION_STRING\n-                    );\n-                }\n-            }\n-        }\n-\n-        // FIXME: this should use exclusive ranges when they're stable\n-        // https://github.com/rust-lang/rust/issues/37854\n-        match (info.version.0, info.version.1) {\n-            (1, 63) => {\n-                let inner = unsafe { Abi_1_63::from_lib(lib, symbol_name) }?;\n-                Ok(Abi::Abi1_63(inner))\n-            }\n-            _ => Err(LoadProcMacroDylibError::UnsupportedABI(info.version_string)),\n-        }\n-    }\n-\n-    pub fn expand(\n-        &self,\n-        macro_name: &str,\n-        macro_body: &tt::Subtree,\n-        attributes: Option<&tt::Subtree>,\n-    ) -> Result<tt::Subtree, PanicMessage> {\n-        match self {\n-            Self::Abi1_63(abi) => abi.expand(macro_name, macro_body, attributes),\n-            #[cfg(feature = \"sysroot-abi\")]\n-            Self::AbiSysroot(abi) => abi.expand(macro_name, macro_body, attributes),\n-        }\n-    }\n-\n-    pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n-        match self {\n-            Self::Abi1_63(abi) => abi.list_macros(),\n-            #[cfg(feature = \"sysroot-abi\")]\n-            Self::AbiSysroot(abi) => abi.list_macros(),\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_version_check() {\n-    let path = paths::AbsPathBuf::assert(crate::proc_macro_test_dylib_path());\n-    let info = proc_macro_api::read_dylib_info(&path).unwrap();\n-    assert!(info.version.1 >= 50);\n-}"}, {"sha": "dd05e250c2def3074b54a736492bf4fd4d82a10d", "filename": "crates/proc-macro-srv/src/dylib.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fdylib.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -13,10 +13,6 @@ use object::Object;\n use paths::AbsPath;\n use proc_macro_api::{read_dylib_info, ProcMacroKind};\n \n-use crate::tt;\n-\n-use super::abis::Abi;\n-\n const NEW_REGISTRAR_SYMBOL: &str = \"_rustc_proc_macro_decls_\";\n \n fn invalid_data_err(e: impl Into<Box<dyn std::error::Error + Send + Sync>>) -> io::Error {\n@@ -82,14 +78,17 @@ fn load_library(file: &Path) -> Result<Library, libloading::Error> {\n pub enum LoadProcMacroDylibError {\n     Io(io::Error),\n     LibLoading(libloading::Error),\n-    UnsupportedABI(String),\n+    AbiMismatch(String),\n }\n \n impl fmt::Display for LoadProcMacroDylibError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Self::Io(e) => e.fmt(f),\n-            Self::UnsupportedABI(v) => write!(f, \"unsupported ABI `{v}`\"),\n+            Self::AbiMismatch(v) => {\n+                use crate::RUSTC_VERSION_STRING;\n+                write!(f, \"mismatched ABI expected: `{RUSTC_VERSION_STRING}`, got `{v}`\")\n+            }\n             Self::LibLoading(e) => e.fmt(f),\n         }\n     }\n@@ -110,7 +109,7 @@ impl From<libloading::Error> for LoadProcMacroDylibError {\n struct ProcMacroLibraryLibloading {\n     // Hold on to the library so it doesn't unload\n     _lib: Library,\n-    abi: Abi,\n+    proc_macros: crate::proc_macros::ProcMacros,\n }\n \n impl ProcMacroLibraryLibloading {\n@@ -125,8 +124,9 @@ impl ProcMacroLibraryLibloading {\n         let version_info = read_dylib_info(abs_file)?;\n \n         let lib = load_library(file).map_err(invalid_data_err)?;\n-        let abi = Abi::from_lib(&lib, symbol_name, version_info)?;\n-        Ok(ProcMacroLibraryLibloading { _lib: lib, abi })\n+        let proc_macros =\n+            crate::proc_macros::ProcMacros::from_lib(&lib, symbol_name, version_info)?;\n+        Ok(ProcMacroLibraryLibloading { _lib: lib, proc_macros })\n     }\n }\n \n@@ -150,15 +150,15 @@ impl Expander {\n     pub fn expand(\n         &self,\n         macro_name: &str,\n-        macro_body: &tt::Subtree,\n-        attributes: Option<&tt::Subtree>,\n-    ) -> Result<tt::Subtree, String> {\n-        let result = self.inner.abi.expand(macro_name, macro_body, attributes);\n+        macro_body: &crate::tt::Subtree,\n+        attributes: Option<&crate::tt::Subtree>,\n+    ) -> Result<crate::tt::Subtree, String> {\n+        let result = self.inner.proc_macros.expand(macro_name, macro_body, attributes);\n         result.map_err(|e| e.as_str().unwrap_or_else(|| \"<unknown error>\".to_string()))\n     }\n \n     pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n-        self.inner.abi.list_macros()\n+        self.inner.proc_macros.list_macros()\n     }\n }\n "}, {"sha": "2aac379031302a6b748d665c59afab8154de6610", "filename": "crates/proc-macro-srv/src/lib.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -10,17 +10,16 @@\n //! * By **copying** the whole rustc `lib_proc_macro` code, we are able to build this with `stable`\n //!   rustc rather than `unstable`. (Although in general ABI compatibility is still an issue)\u2026\n \n+#![cfg(feature = \"sysroot-abi\")]\n+#![feature(proc_macro_internals, proc_macro_diagnostic, proc_macro_span)]\n #![warn(rust_2018_idioms, unused_lifetimes, semicolon_in_expressions_from_macros)]\n-#![cfg_attr(\n-    feature = \"sysroot-abi\",\n-    feature(proc_macro_internals, proc_macro_diagnostic, proc_macro_span)\n-)]\n #![allow(unreachable_pub)]\n \n-mod dylib;\n-mod abis;\n+extern crate proc_macro;\n \n-pub mod cli;\n+mod dylib;\n+mod server;\n+mod proc_macros;\n \n use std::{\n     collections::{hash_map::Entry, HashMap},\n@@ -32,25 +31,25 @@ use std::{\n     time::SystemTime,\n };\n \n-use proc_macro_api::{\n-    msg::{ExpandMacro, FlatTree, PanicMessage},\n-    ProcMacroKind,\n-};\n+use proc_macro_api::{msg, ProcMacroKind};\n \n use ::tt::token_id as tt;\n \n+// see `build.rs`\n+include!(concat!(env!(\"OUT_DIR\"), \"/rustc_version.rs\"));\n+\n #[derive(Default)]\n-pub(crate) struct ProcMacroSrv {\n+pub struct ProcMacroSrv {\n     expanders: HashMap<(PathBuf, SystemTime), dylib::Expander>,\n }\n \n const EXPANDER_STACK_SIZE: usize = 8 * 1024 * 1024;\n \n impl ProcMacroSrv {\n-    pub fn expand(&mut self, task: ExpandMacro) -> Result<FlatTree, PanicMessage> {\n+    pub fn expand(&mut self, task: msg::ExpandMacro) -> Result<msg::FlatTree, msg::PanicMessage> {\n         let expander = self.expander(task.lib.as_ref()).map_err(|err| {\n             debug_assert!(false, \"should list macros before asking to expand\");\n-            PanicMessage(format!(\"failed to load macro: {err}\"))\n+            msg::PanicMessage(format!(\"failed to load macro: {err}\"))\n         })?;\n \n         let prev_env = EnvSnapshot::new();\n@@ -77,7 +76,7 @@ impl ProcMacroSrv {\n                 .spawn_scoped(s, || {\n                     expander\n                         .expand(&task.macro_name, &macro_body, attributes.as_ref())\n-                        .map(|it| FlatTree::new(&it))\n+                        .map(|it| msg::FlatTree::new(&it))\n                 });\n             let res = match thread {\n                 Ok(handle) => handle.join(),\n@@ -102,10 +101,10 @@ impl ProcMacroSrv {\n             }\n         }\n \n-        result.map_err(PanicMessage)\n+        result.map_err(msg::PanicMessage)\n     }\n \n-    pub(crate) fn list_macros(\n+    pub fn list_macros(\n         &mut self,\n         dylib_path: &Path,\n     ) -> Result<Vec<(String, ProcMacroKind)>, String> {\n@@ -129,6 +128,16 @@ impl ProcMacroSrv {\n     }\n }\n \n+pub struct PanicMessage {\n+    message: Option<String>,\n+}\n+\n+impl PanicMessage {\n+    pub fn as_str(&self) -> Option<String> {\n+        self.message.clone()\n+    }\n+}\n+\n struct EnvSnapshot {\n     vars: HashMap<OsString, OsString>,\n }\n@@ -138,24 +147,27 @@ impl EnvSnapshot {\n         EnvSnapshot { vars: env::vars_os().collect() }\n     }\n \n-    fn rollback(self) {\n-        let mut old_vars = self.vars;\n+    fn rollback(self) {}\n+}\n+\n+impl Drop for EnvSnapshot {\n+    fn drop(&mut self) {\n         for (name, value) in env::vars_os() {\n-            let old_value = old_vars.remove(&name);\n+            let old_value = self.vars.remove(&name);\n             if old_value != Some(value) {\n                 match old_value {\n                     None => env::remove_var(name),\n                     Some(old_value) => env::set_var(name, old_value),\n                 }\n             }\n         }\n-        for (name, old_value) in old_vars {\n+        for (name, old_value) in self.vars.drain() {\n             env::set_var(name, old_value)\n         }\n     }\n }\n \n-#[cfg(all(feature = \"sysroot-abi\", test))]\n+#[cfg(test)]\n mod tests;\n \n #[cfg(test)]"}, {"sha": "3c6f320331928fbcf93147dccceccb7a77ea6422", "filename": "crates/proc-macro-srv/src/proc_macros.rs", "status": "renamed", "additions": 52, "deletions": 29, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv%2Fsrc%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv%2Fsrc%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fproc_macros.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,45 +1,55 @@\n //! Proc macro ABI\n \n-extern crate proc_macro;\n-\n-#[allow(dead_code)]\n-#[doc(hidden)]\n-mod ra_server;\n-\n use libloading::Library;\n-use proc_macro_api::ProcMacroKind;\n+use proc_macro_api::{ProcMacroKind, RustCInfo};\n \n-use super::{tt, PanicMessage};\n+use crate::{dylib::LoadProcMacroDylibError, server::SYMBOL_INTERNER, tt};\n \n-pub use ra_server::TokenStream;\n-\n-pub(crate) struct Abi {\n+pub(crate) struct ProcMacros {\n     exported_macros: Vec<proc_macro::bridge::client::ProcMacro>,\n }\n \n-impl From<proc_macro::bridge::PanicMessage> for PanicMessage {\n+impl From<proc_macro::bridge::PanicMessage> for crate::PanicMessage {\n     fn from(p: proc_macro::bridge::PanicMessage) -> Self {\n         Self { message: p.as_str().map(|s| s.to_string()) }\n     }\n }\n \n-impl Abi {\n-    pub unsafe fn from_lib(lib: &Library, symbol_name: String) -> Result<Abi, libloading::Error> {\n-        let macros: libloading::Symbol<'_, &&[proc_macro::bridge::client::ProcMacro]> =\n-            lib.get(symbol_name.as_bytes())?;\n-        Ok(Self { exported_macros: macros.to_vec() })\n+impl ProcMacros {\n+    /// Load a new ABI.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// *`lib` - The dynamic library containing the macro implementations\n+    /// *`symbol_name` - The symbol name the macros can be found attributes\n+    /// *`info` - RustCInfo about the compiler that was used to compile the\n+    ///           macro crate. This is the information we use to figure out\n+    ///           which ABI to return\n+    pub(crate) fn from_lib(\n+        lib: &Library,\n+        symbol_name: String,\n+        info: RustCInfo,\n+    ) -> Result<ProcMacros, LoadProcMacroDylibError> {\n+        if info.version_string == crate::RUSTC_VERSION_STRING {\n+            let macros = unsafe {\n+                lib.get::<&&[proc_macro::bridge::client::ProcMacro]>(symbol_name.as_bytes())\n+            }?;\n+\n+            return Ok(Self { exported_macros: macros.to_vec() });\n+        }\n+        Err(LoadProcMacroDylibError::AbiMismatch(info.version_string))\n     }\n \n-    pub fn expand(\n+    pub(crate) fn expand(\n         &self,\n         macro_name: &str,\n         macro_body: &tt::Subtree,\n         attributes: Option<&tt::Subtree>,\n-    ) -> Result<tt::Subtree, PanicMessage> {\n-        let parsed_body = ra_server::TokenStream::with_subtree(macro_body.clone());\n+    ) -> Result<tt::Subtree, crate::PanicMessage> {\n+        let parsed_body = crate::server::TokenStream::with_subtree(macro_body.clone());\n \n-        let parsed_attributes = attributes.map_or(ra_server::TokenStream::new(), |attr| {\n-            ra_server::TokenStream::with_subtree(attr.clone())\n+        let parsed_attributes = attributes.map_or(crate::server::TokenStream::new(), |attr| {\n+            crate::server::TokenStream::with_subtree(attr.clone())\n         });\n \n         for proc_macro in &self.exported_macros {\n@@ -49,34 +59,34 @@ impl Abi {\n                 } if *trait_name == macro_name => {\n                     let res = client.run(\n                         &proc_macro::bridge::server::SameThread,\n-                        ra_server::RustAnalyzer::default(),\n+                        crate::server::RustAnalyzer { interner: &SYMBOL_INTERNER },\n                         parsed_body,\n                         true,\n                     );\n-                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                    return res.map(|it| it.into_subtree()).map_err(crate::PanicMessage::from);\n                 }\n                 proc_macro::bridge::client::ProcMacro::Bang { name, client }\n                     if *name == macro_name =>\n                 {\n                     let res = client.run(\n                         &proc_macro::bridge::server::SameThread,\n-                        ra_server::RustAnalyzer::default(),\n+                        crate::server::RustAnalyzer { interner: &SYMBOL_INTERNER },\n                         parsed_body,\n                         true,\n                     );\n-                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                    return res.map(|it| it.into_subtree()).map_err(crate::PanicMessage::from);\n                 }\n                 proc_macro::bridge::client::ProcMacro::Attr { name, client }\n                     if *name == macro_name =>\n                 {\n                     let res = client.run(\n                         &proc_macro::bridge::server::SameThread,\n-                        ra_server::RustAnalyzer::default(),\n+                        crate::server::RustAnalyzer { interner: &SYMBOL_INTERNER },\n                         parsed_attributes,\n                         parsed_body,\n                         true,\n                     );\n-                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                    return res.map(|it| it.into_subtree()).map_err(crate::PanicMessage::from);\n                 }\n                 _ => continue,\n             }\n@@ -85,7 +95,7 @@ impl Abi {\n         Err(proc_macro::bridge::PanicMessage::String(\"Nothing to expand\".to_string()).into())\n     }\n \n-    pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n+    pub(crate) fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n         self.exported_macros\n             .iter()\n             .map(|proc_macro| match proc_macro {\n@@ -102,3 +112,16 @@ impl Abi {\n             .collect()\n     }\n }\n+\n+#[test]\n+fn test_version_check() {\n+    let path = paths::AbsPathBuf::assert(crate::proc_macro_test_dylib_path());\n+    let info = proc_macro_api::read_dylib_info(&path).unwrap();\n+    assert_eq!(\n+        info.version_string,\n+        crate::RUSTC_VERSION_STRING,\n+        \"sysroot ABI mismatch: dylib rustc version (read from .rustc section): {:?} != proc-macro-srv version (read from 'rustc --version'): {:?}\",\n+        info.version_string,\n+        crate::RUSTC_VERSION_STRING,\n+    );\n+}", "previous_filename": "crates/proc-macro-srv/src/abis/abi_sysroot/mod.rs"}, {"sha": "5b659ab849816a9e9e26d1a3b30a5a05617d2c0b", "filename": "crates/proc-macro-srv/src/server.rs", "status": "renamed", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv%2Fsrc%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv%2Fsrc%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fserver.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -8,9 +8,9 @@\n //!\n //! FIXME: No span and source file information is implemented yet\n \n-use super::proc_macro::{\n-    self,\n+use proc_macro::{\n     bridge::{self, server},\n+    LineColumn,\n };\n \n mod token_stream;\n@@ -26,8 +26,10 @@ use crate::tt;\n \n type Group = tt::Subtree;\n type TokenTree = tt::TokenTree;\n+#[allow(unused)]\n type Punct = tt::Punct;\n type Spacing = tt::Spacing;\n+#[allow(unused)]\n type Literal = tt::Literal;\n type Span = tt::TokenId;\n \n@@ -36,14 +38,11 @@ pub struct SourceFile {\n     // FIXME stub\n }\n \n-type Level = super::proc_macro::Level;\n-type LineColumn = super::proc_macro::LineColumn;\n-\n pub struct FreeFunctions;\n \n-#[derive(Default)]\n pub struct RustAnalyzer {\n     // FIXME: store span information here.\n+    pub(crate) interner: SymbolInternerRef,\n }\n \n impl server::Types for RustAnalyzer {\n@@ -68,7 +67,7 @@ impl server::FreeFunctions for RustAnalyzer {\n         // FIXME: keep track of LitKind and Suffix\n         Ok(bridge::Literal {\n             kind: bridge::LitKind::Err,\n-            symbol: Symbol::intern(s),\n+            symbol: Symbol::intern(self.interner, s),\n             suffix: None,\n             span: tt::TokenId::unspecified(),\n         })\n@@ -109,7 +108,7 @@ impl server::TokenStream for RustAnalyzer {\n             }\n \n             bridge::TokenTree::Ident(ident) => {\n-                let text = ident.sym.text();\n+                let text = ident.sym.text(self.interner);\n                 let text =\n                     if ident.is_raw { ::tt::SmolStr::from_iter([\"r#\", &text]) } else { text };\n                 let ident: tt::Ident = tt::Ident { text, span: ident.span };\n@@ -120,8 +119,9 @@ impl server::TokenStream for RustAnalyzer {\n \n             bridge::TokenTree::Literal(literal) => {\n                 let literal = LiteralFormatter(literal);\n-                let text = literal\n-                    .with_stringify_parts(|parts| ::tt::SmolStr::from_iter(parts.iter().copied()));\n+                let text = literal.with_stringify_parts(self.interner, |parts| {\n+                    ::tt::SmolStr::from_iter(parts.iter().copied())\n+                });\n \n                 let literal = tt::Literal { text, span: literal.0.span };\n                 let leaf = tt::Leaf::from(literal);\n@@ -185,7 +185,7 @@ impl server::TokenStream for RustAnalyzer {\n             .map(|tree| match tree {\n                 tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n                     bridge::TokenTree::Ident(bridge::Ident {\n-                        sym: Symbol::intern(ident.text.trim_start_matches(\"r#\")),\n+                        sym: Symbol::intern(self.interner, ident.text.trim_start_matches(\"r#\")),\n                         is_raw: ident.text.starts_with(\"r#\"),\n                         span: ident.span,\n                     })\n@@ -194,7 +194,7 @@ impl server::TokenStream for RustAnalyzer {\n                     bridge::TokenTree::Literal(bridge::Literal {\n                         // FIXME: handle literal kinds\n                         kind: bridge::LitKind::Err,\n-                        symbol: Symbol::intern(&lit.text),\n+                        symbol: Symbol::intern(self.interner, &lit.text),\n                         // FIXME: handle suffixes\n                         suffix: None,\n                         span: lit.span,\n@@ -240,13 +240,15 @@ fn delim_to_external(d: tt::Delimiter) -> proc_macro::Delimiter {\n     }\n }\n \n+#[allow(unused)]\n fn spacing_to_internal(spacing: proc_macro::Spacing) -> Spacing {\n     match spacing {\n         proc_macro::Spacing::Alone => Spacing::Alone,\n         proc_macro::Spacing::Joint => Spacing::Joint,\n     }\n }\n \n+#[allow(unused)]\n fn spacing_to_external(spacing: Spacing) -> proc_macro::Spacing {\n     match spacing {\n         Spacing::Alone => proc_macro::Spacing::Alone,\n@@ -350,11 +352,13 @@ impl server::Server for RustAnalyzer {\n     }\n \n     fn intern_symbol(ident: &str) -> Self::Symbol {\n-        Symbol::intern(&::tt::SmolStr::from(ident))\n+        // FIXME: should be self.interner once the proc-macro api allows is\n+        Symbol::intern(&SYMBOL_INTERNER, &::tt::SmolStr::from(ident))\n     }\n \n     fn with_symbol_string(symbol: &Self::Symbol, f: impl FnOnce(&str)) {\n-        f(symbol.text().as_str())\n+        // FIXME: should be self.interner once the proc-macro api allows is\n+        f(symbol.text(&SYMBOL_INTERNER).as_str())\n     }\n }\n \n@@ -365,7 +369,11 @@ impl LiteralFormatter {\n     /// literal's representation. This is done to allow the `ToString` and\n     /// `Display` implementations to borrow references to symbol values, and\n     /// both be optimized to reduce overhead.\n-    fn with_stringify_parts<R>(&self, f: impl FnOnce(&[&str]) -> R) -> R {\n+    fn with_stringify_parts<R>(\n+        &self,\n+        interner: SymbolInternerRef,\n+        f: impl FnOnce(&[&str]) -> R,\n+    ) -> R {\n         /// Returns a string containing exactly `num` '#' characters.\n         /// Uses a 256-character source string literal which is always safe to\n         /// index with a `u8` index.\n@@ -380,7 +388,7 @@ impl LiteralFormatter {\n             &HASHES[..num as usize]\n         }\n \n-        self.with_symbol_and_suffix(|symbol, suffix| match self.0.kind {\n+        self.with_symbol_and_suffix(interner, |symbol, suffix| match self.0.kind {\n             bridge::LitKind::Byte => f(&[\"b'\", symbol, \"'\", suffix]),\n             bridge::LitKind::Char => f(&[\"'\", symbol, \"'\", suffix]),\n             bridge::LitKind::Str => f(&[\"\\\"\", symbol, \"\\\"\", suffix]),\n@@ -397,9 +405,13 @@ impl LiteralFormatter {\n         })\n     }\n \n-    fn with_symbol_and_suffix<R>(&self, f: impl FnOnce(&str, &str) -> R) -> R {\n-        let symbol = self.0.symbol.text();\n-        let suffix = self.0.suffix.map(|s| s.text()).unwrap_or_default();\n+    fn with_symbol_and_suffix<R>(\n+        &self,\n+        interner: SymbolInternerRef,\n+        f: impl FnOnce(&str, &str) -> R,\n+    ) -> R {\n+        let symbol = self.0.symbol.text(interner);\n+        let suffix = self.0.suffix.map(|s| s.text(interner)).unwrap_or_default();\n         f(symbol.as_str(), suffix.as_str())\n     }\n }", "previous_filename": "crates/proc-macro-srv/src/abis/abi_sysroot/ra_server.rs"}, {"sha": "540d06457f2f39f8ea940e3f2a7d78c3dd50a407", "filename": "crates/proc-macro-srv/src/server/symbol.rs", "status": "renamed", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv%2Fsrc%2Fserver%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv%2Fsrc%2Fserver%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fserver%2Fsymbol.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,28 +1,30 @@\n //! Symbol interner for proc-macro-srv\n \n-use std::{cell::RefCell, collections::HashMap};\n+use std::{cell::RefCell, collections::HashMap, thread::LocalKey};\n use tt::SmolStr;\n \n thread_local! {\n-    static SYMBOL_INTERNER: RefCell<SymbolInterner> = Default::default();\n+    pub(crate) static SYMBOL_INTERNER: RefCell<SymbolInterner> = Default::default();\n }\n \n // ID for an interned symbol.\n #[derive(Hash, Eq, PartialEq, Copy, Clone)]\n pub struct Symbol(u32);\n \n+pub(crate) type SymbolInternerRef = &'static LocalKey<RefCell<SymbolInterner>>;\n+\n impl Symbol {\n-    pub fn intern(data: &str) -> Symbol {\n-        SYMBOL_INTERNER.with(|i| i.borrow_mut().intern(data))\n+    pub(super) fn intern(interner: SymbolInternerRef, data: &str) -> Symbol {\n+        interner.with(|i| i.borrow_mut().intern(data))\n     }\n \n-    pub fn text(&self) -> SmolStr {\n-        SYMBOL_INTERNER.with(|i| i.borrow().get(self).clone())\n+    pub(super) fn text(&self, interner: SymbolInternerRef) -> SmolStr {\n+        interner.with(|i| i.borrow().get(self).clone())\n     }\n }\n \n #[derive(Default)]\n-struct SymbolInterner {\n+pub(crate) struct SymbolInterner {\n     idents: HashMap<SmolStr, u32>,\n     ident_data: Vec<SmolStr>,\n }", "previous_filename": "crates/proc-macro-srv/src/abis/abi_sysroot/ra_server/symbol.rs"}, {"sha": "2589d8b64d489ee4410071eee5a734c451b37d07", "filename": "crates/proc-macro-srv/src/server/token_stream.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv%2Fsrc%2Fserver%2Ftoken_stream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv%2Fsrc%2Fserver%2Ftoken_stream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fserver%2Ftoken_stream.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -4,27 +4,27 @@ use crate::tt::{self, TokenTree};\n \n #[derive(Debug, Default, Clone)]\n pub struct TokenStream {\n-    pub token_trees: Vec<TokenTree>,\n+    pub(super) token_trees: Vec<TokenTree>,\n }\n \n impl TokenStream {\n-    pub fn new() -> Self {\n+    pub(crate) fn new() -> Self {\n         TokenStream::default()\n     }\n \n-    pub fn with_subtree(subtree: tt::Subtree) -> Self {\n+    pub(crate) fn with_subtree(subtree: tt::Subtree) -> Self {\n         if subtree.delimiter.kind != tt::DelimiterKind::Invisible {\n             TokenStream { token_trees: vec![TokenTree::Subtree(subtree)] }\n         } else {\n             TokenStream { token_trees: subtree.token_trees }\n         }\n     }\n \n-    pub fn into_subtree(self) -> tt::Subtree {\n+    pub(crate) fn into_subtree(self) -> tt::Subtree {\n         tt::Subtree { delimiter: tt::Delimiter::UNSPECIFIED, token_trees: self.token_trees }\n     }\n \n-    pub fn is_empty(&self) -> bool {\n+    pub(super) fn is_empty(&self) -> bool {\n         self.token_trees.is_empty()\n     }\n }\n@@ -78,12 +78,12 @@ impl Extend<TokenStream> for TokenStream {\n     }\n }\n \n-pub struct TokenStreamBuilder {\n+pub(super) struct TokenStreamBuilder {\n     acc: TokenStream,\n }\n \n-/// Public implementation details for the `TokenStream` type, such as iterators.\n-pub mod token_stream {\n+/// pub(super)lic implementation details for the `TokenStream` type, such as iterators.\n+pub(super) mod token_stream {\n     use std::str::FromStr;\n \n     use super::{tt, TokenStream, TokenTree};", "previous_filename": "crates/proc-macro-srv/src/abis/abi_sysroot/ra_server/token_stream.rs"}, {"sha": "49b4d973b63bb9241d197c555a3f6097e2c1a35e", "filename": "crates/proc-macro-srv/src/tests/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Futils.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -5,14 +5,14 @@ use std::str::FromStr;\n \n use crate::{dylib, proc_macro_test_dylib_path, ProcMacroSrv};\n \n-fn parse_string(code: &str) -> Option<crate::abis::TestTokenStream> {\n+fn parse_string(code: &str) -> Option<crate::server::TokenStream> {\n     // This is a bit strange. We need to parse a string into a token stream into\n     // order to create a tt::SubTree from it in fixtures. `into_subtree` is\n     // implemented by all the ABIs we have so we arbitrarily choose one ABI to\n     // write a `parse_string` function for and use that. The tests don't really\n     // care which ABI we're using as the `into_subtree` function isn't part of\n     // the ABI and shouldn't change between ABI versions.\n-    crate::abis::TestTokenStream::from_str(code).ok()\n+    crate::server::TokenStream::from_str(code).ok()\n }\n \n pub fn assert_expand(macro_name: &str, ra_fixture: &str, expect: Expect) {"}, {"sha": "fe4cbfc88672d6548ea3c00d38876bb3ad22b931", "filename": "crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -415,7 +415,6 @@ impl WorkspaceBuildScripts {\n                     let dir_entry = entry.ok()?;\n                     if dir_entry.file_type().ok()?.is_file() {\n                         let path = dir_entry.path();\n-                        tracing::info!(\"p{:?}\", path);\n                         let extension = path.extension()?;\n                         if extension == std::env::consts::DLL_EXTENSION {\n                             let name = path.file_stem()?.to_str()?.split_once('-')?.0.to_owned();"}, {"sha": "3f2cfed806f651600bda9ab092c3e88f5ee17568", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -67,7 +67,7 @@ ide-db.workspace = true\n ide-ssr.workspace = true\n ide.workspace = true\n proc-macro-api.workspace = true\n-proc-macro-srv.workspace = true\n+proc-macro-srv-cli.workspace = true\n profile.workspace = true\n project-model.workspace = true\n stdx.workspace = true\n@@ -95,8 +95,9 @@ mbe.workspace = true\n [features]\n jemalloc = [\"jemallocator\", \"profile/jemalloc\"]\n force-always-assert = [\"always-assert/force\"]\n+sysroot-abi = [\"proc-macro-srv-cli/sysroot-abi\"]\n in-rust-tree = [\n-    \"proc-macro-srv/sysroot-abi\",\n+    \"sysroot-abi\",\n     \"ide/in-rust-tree\",\n     \"syntax/in-rust-tree\",\n ]"}, {"sha": "3506bed2c74e0dfdcbbba35a0ada66c8b9a9ca10", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -77,7 +77,7 @@ fn try_main(flags: flags::RustAnalyzer) -> Result<()> {\n             with_extra_thread(\"LspServer\", run_server)?;\n         }\n         flags::RustAnalyzerCmd::ProcMacro(flags::ProcMacro) => {\n-            with_extra_thread(\"MacroExpander\", || proc_macro_srv::cli::run().map_err(Into::into))?;\n+            with_extra_thread(\"MacroExpander\", || proc_macro_srv_cli::run().map_err(Into::into))?;\n         }\n         flags::RustAnalyzerCmd::Parse(cmd) => cmd.run()?,\n         flags::RustAnalyzerCmd::Symbols(cmd) => cmd.run()?,"}, {"sha": "bd477775717251dbe70a2543721a8fbf8c9bb4ac", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -13,7 +13,7 @@ use hir::{\n };\n use hir_def::{\n     body::{BodySourceMap, SyntheticSyntax},\n-    expr::{ExprId, PatId},\n+    hir::{ExprId, PatId},\n     FunctionId,\n };\n use hir_ty::{Interner, TyExt, TypeFlags};"}, {"sha": "27445d1f712d832078c3fc39bcc9f71a7c9aeea0", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -338,6 +338,8 @@ config_data! {\n         inlayHints_closingBraceHints_minLines: usize               = \"25\",\n         /// Whether to show inlay type hints for return types of closures.\n         inlayHints_closureReturnTypeHints_enable: ClosureReturnTypeHintsDef  = \"\\\"never\\\"\",\n+        /// Closure notation in type and chaining inaly hints.\n+        inlayHints_closureStyle: ClosureStyle                                = \"\\\"impl_fn\\\"\",\n         /// Whether to show enum variant discriminant hints.\n         inlayHints_discriminantHints_enable: DiscriminantHintsDef            = \"\\\"never\\\"\",\n         /// Whether to show inlay hints for type adjustments.\n@@ -1301,6 +1303,12 @@ impl Config {\n             hide_closure_initialization_hints: self\n                 .data\n                 .inlayHints_typeHints_hideClosureInitialization,\n+            closure_style: match self.data.inlayHints_closureStyle {\n+                ClosureStyle::ImplFn => hir::ClosureStyle::ImplFn,\n+                ClosureStyle::RustAnalyzer => hir::ClosureStyle::RANotation,\n+                ClosureStyle::WithId => hir::ClosureStyle::ClosureWithId,\n+                ClosureStyle::Hide => hir::ClosureStyle::Hide,\n+            },\n             adjustment_hints: match self.data.inlayHints_expressionAdjustmentHints_enable {\n                 AdjustmentHintsDef::Always => ide::AdjustmentHints::Always,\n                 AdjustmentHintsDef::Never => match self.data.inlayHints_reborrowHints_enable {\n@@ -1807,6 +1815,15 @@ enum ClosureReturnTypeHintsDef {\n     WithBlock,\n }\n \n+#[derive(Deserialize, Debug, Clone)]\n+#[serde(rename_all = \"snake_case\")]\n+enum ClosureStyle {\n+    ImplFn,\n+    RustAnalyzer,\n+    WithId,\n+    Hide,\n+}\n+\n #[derive(Deserialize, Debug, Clone)]\n #[serde(untagged)]\n enum ReborrowHintsDef {\n@@ -2288,6 +2305,16 @@ fn field_props(field: &str, ty: &str, doc: &[&str], default: &str) -> serde_json\n                 },\n             ],\n         },\n+        \"ClosureStyle\" => set! {\n+            \"type\": \"string\",\n+            \"enum\": [\"impl_fn\", \"rust_analyzer\", \"with_id\", \"hide\"],\n+            \"enumDescriptions\": [\n+                \"`impl_fn`: `impl FnMut(i32, u64) -> i8`\",\n+                \"`rust_analyzer`: `|i32, u64| -> i8`\",\n+                \"`with_id`: `{closure#14352}`, where that id is the unique number of the closure in r-a internals\",\n+                \"`hide`: Shows `...` for every closure type\",\n+            ],\n+        },\n         _ => panic!(\"missing entry for {ty}: {default}\"),\n     }\n "}, {"sha": "ddf130e08dd60c0f002106b38b465689e562128a", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -114,6 +114,10 @@ impl GlobalState {\n             status.health = lsp_ext::Health::Warning;\n             message.push_str(\"Failed to run build scripts of some packages.\\n\\n\");\n         }\n+        if self.proc_macro_clients.iter().any(|it| it.is_err()) {\n+            status.health = lsp_ext::Health::Warning;\n+            message.push_str(\"Failed to spawn one or more proc-macro servers.\\n\\n\");\n+        }\n         if !self.config.cargo_autoreload()\n             && self.is_quiescent()\n             && self.fetch_workspaces_queue.op_requested()\n@@ -384,18 +388,23 @@ impl GlobalState {\n                     .workspaces\n                     .iter()\n                     .map(|ws| {\n-                        let (path, args): (_, &[_]) = if path_manually_set {\n+                        let path = if path_manually_set {\n                             tracing::debug!(\n                                 \"Pro-macro server path explicitly set: {}\",\n                                 path.display()\n                             );\n-                            (path.clone(), &[])\n+                            path.clone()\n                         } else {\n                             match ws.find_sysroot_proc_macro_srv() {\n-                                Some(server_path) => (server_path, &[]),\n-                                None => (path.clone(), &[\"proc-macro\"]),\n+                                Some(server_path) => server_path,\n+                                None => path.clone(),\n                             }\n                         };\n+                        let args: &[_] = if path.file_stem() == Some(\"rust-analyzer\".as_ref()) {\n+                            &[\"proc-macro\"]\n+                        } else {\n+                            &[]\n+                        };\n \n                         tracing::info!(?args, \"Using proc-macro server at {}\", path.display(),);\n                         ProcMacroServer::spawn(path.clone(), args).map_err(|err| {\n@@ -447,7 +456,7 @@ impl GlobalState {\n             let mut proc_macros = Vec::default();\n             for ws in &**self.workspaces {\n                 let (other, mut crate_proc_macros) =\n-                    ws.to_crate_graph(&mut load, &self.config.cargo().extra_env);\n+                    ws.to_crate_graph(&mut load, &self.config.extra_env());\n                 crate_graph.extend(other, &mut crate_proc_macros);\n                 proc_macros.push(crate_proc_macros);\n             }"}, {"sha": "54a91df23e5db2922e30d54e4578a839ddd400a5", "filename": "crates/rust-analyzer/tests/slow-tests/main.rs", "status": "modified", "additions": 46, "deletions": 27, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -59,7 +59,7 @@ use std::collections::Spam;\n \"#,\n     )\n     .with_config(serde_json::json!({\n-        \"cargo\": { \"sysroot\": \"discover\" }\n+        \"cargo\": { \"sysroot\": \"discover\" },\n     }))\n     .server()\n     .wait_until_workspace_is_loaded();\n@@ -508,7 +508,7 @@ fn main() {}\n #[test]\n fn test_missing_module_code_action_in_json_project() {\n     if skip_slow_tests() {\n-        // return;\n+        return;\n     }\n \n     let tmp_dir = TestDir::new();\n@@ -612,7 +612,7 @@ fn main() {{}}\n \"#\n     ))\n     .with_config(serde_json::json!({\n-        \"cargo\": { \"sysroot\": \"discover\" }\n+        \"cargo\": { \"sysroot\": \"discover\" },\n     }))\n     .server()\n     .wait_until_workspace_is_loaded();\n@@ -685,7 +685,7 @@ version = \\\"0.0.0\\\"\n #[test]\n fn out_dirs_check() {\n     if skip_slow_tests() {\n-        // return;\n+        return;\n     }\n \n     let server = Project::with_fixture(\n@@ -711,10 +711,21 @@ fn main() {\n     println!(\"cargo:rerun-if-changed=build.rs\");\n }\n //- /src/main.rs\n-#[rustc_builtin_macro] macro_rules! include {}\n-#[rustc_builtin_macro] macro_rules! include_str {}\n-#[rustc_builtin_macro] macro_rules! concat {}\n-#[rustc_builtin_macro] macro_rules! env {}\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#[rustc_builtin_macro] macro_rules! include {\n+    ($file:expr $(,)?) => {{ /* compiler built-in */ }};\n+}\n+#[rustc_builtin_macro] macro_rules! include_str {\n+    ($file:expr $(,)?) => {{ /* compiler built-in */ }};\n+}\n+#[rustc_builtin_macro] macro_rules! concat {\n+    ($($e:ident),+ $(,)?) => {{ /* compiler built-in */ }};\n+}\n+#[rustc_builtin_macro] macro_rules! env {\n+    ($name:expr $(,)?) => {{ /* compiler built-in */ }};\n+    ($name:expr, $error_msg:expr $(,)?) => {{ /* compiler built-in */ }};\n+}\n \n include!(concat!(env!(\"OUT_DIR\"), \"/hello.rs\"));\n \n@@ -749,7 +760,7 @@ fn main() {\n     let res = server.send_request::<HoverRequest>(HoverParams {\n         text_document_position_params: TextDocumentPositionParams::new(\n             server.doc_id(\"src/main.rs\"),\n-            Position::new(19, 10),\n+            Position::new(30, 10),\n         ),\n         work_done_progress_params: Default::default(),\n     });\n@@ -758,7 +769,7 @@ fn main() {\n     let res = server.send_request::<HoverRequest>(HoverParams {\n         text_document_position_params: TextDocumentPositionParams::new(\n             server.doc_id(\"src/main.rs\"),\n-            Position::new(20, 10),\n+            Position::new(31, 10),\n         ),\n         work_done_progress_params: Default::default(),\n     });\n@@ -768,23 +779,23 @@ fn main() {\n         GotoDefinitionParams {\n             text_document_position_params: TextDocumentPositionParams::new(\n                 server.doc_id(\"src/main.rs\"),\n-                Position::new(17, 9),\n+                Position::new(28, 9),\n             ),\n             work_done_progress_params: Default::default(),\n             partial_result_params: Default::default(),\n         },\n         json!([{\n             \"originSelectionRange\": {\n-                \"end\": { \"character\": 10, \"line\": 17 },\n-                \"start\": { \"character\": 8, \"line\": 17 }\n+                \"end\": { \"character\": 10, \"line\": 28 },\n+                \"start\": { \"character\": 8, \"line\": 28 }\n             },\n             \"targetRange\": {\n-                \"end\": { \"character\": 9, \"line\": 8 },\n-                \"start\": { \"character\": 0, \"line\": 7 }\n+                \"end\": { \"character\": 9, \"line\": 19 },\n+                \"start\": { \"character\": 0, \"line\": 18 }\n             },\n             \"targetSelectionRange\": {\n-                \"end\": { \"character\": 8, \"line\": 8 },\n-                \"start\": { \"character\": 7, \"line\": 8 }\n+                \"end\": { \"character\": 8, \"line\": 19 },\n+                \"start\": { \"character\": 7, \"line\": 19 }\n             },\n             \"targetUri\": \"file:///[..]src/main.rs\"\n         }]),\n@@ -794,32 +805,31 @@ fn main() {\n         GotoDefinitionParams {\n             text_document_position_params: TextDocumentPositionParams::new(\n                 server.doc_id(\"src/main.rs\"),\n-                Position::new(18, 9),\n+                Position::new(29, 9),\n             ),\n             work_done_progress_params: Default::default(),\n             partial_result_params: Default::default(),\n         },\n         json!([{\n             \"originSelectionRange\": {\n-                \"end\": { \"character\": 10, \"line\": 18 },\n-                \"start\": { \"character\": 8, \"line\": 18 }\n+                \"end\": { \"character\": 10, \"line\": 29 },\n+                \"start\": { \"character\": 8, \"line\": 29 }\n             },\n             \"targetRange\": {\n-                \"end\": { \"character\": 9, \"line\": 12 },\n-                \"start\": { \"character\": 0, \"line\":11 }\n+                \"end\": { \"character\": 9, \"line\": 23 },\n+                \"start\": { \"character\": 0, \"line\": 22 }\n             },\n             \"targetSelectionRange\": {\n-                \"end\": { \"character\": 8, \"line\": 12 },\n-                \"start\": { \"character\": 7, \"line\": 12 }\n+                \"end\": { \"character\": 8, \"line\": 23 },\n+                \"start\": { \"character\": 7, \"line\": 23 }\n             },\n             \"targetUri\": \"file:///[..]src/main.rs\"\n         }]),\n     );\n }\n \n #[test]\n-// FIXME: Re-enable once we can run proc-macro tests on rust-lang/rust-analyzer again\n-#[cfg(any())]\n+#[cfg(feature = \"sysroot-abi\")]\n fn resolve_proc_macro() {\n     use expect_test::expect;\n     if skip_slow_tests() {\n@@ -837,6 +847,7 @@ edition = \"2021\"\n bar = {path = \"../bar\"}\n \n //- /foo/src/main.rs\n+#![feature(rustc_attrs, decl_macro)]\n use bar::Bar;\n \n #[rustc_builtin_macro]\n@@ -913,7 +924,7 @@ pub fn foo(_input: TokenStream) -> TokenStream {\n     let res = server.send_request::<HoverRequest>(HoverParams {\n         text_document_position_params: TextDocumentPositionParams::new(\n             server.doc_id(\"foo/src/main.rs\"),\n-            Position::new(10, 9),\n+            Position::new(11, 9),\n         ),\n         work_done_progress_params: Default::default(),\n     });\n@@ -1083,10 +1094,18 @@ version = \"0.0.0\"\n \n //- /bar/src/lib.rs\n pub fn bar() {}\n+\n+//- /baz/Cargo.toml\n+[package]\n+name = \"baz\"\n+version = \"0.0.0\"\n+\n+//- /baz/src/lib.rs\n \"#,\n     )\n     .root(\"foo\")\n     .root(\"bar\")\n+    .root(\"baz\")\n     .with_config(json!({\n        \"files\": {\n            \"excludeDirs\": [\"foo\", \"bar\"]"}, {"sha": "df62dcd7ddc15c97fb775ff1669c96b7dbe35dec", "filename": "crates/rust-analyzer/tests/slow-tests/support.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -13,7 +13,7 @@ use project_model::ProjectManifest;\n use rust_analyzer::{config::Config, lsp_ext, main_loop};\n use serde::Serialize;\n use serde_json::{json, to_string_pretty, Value};\n-use test_utils::Fixture;\n+use test_utils::FixtureWithProjectMeta;\n use vfs::AbsPathBuf;\n \n use crate::testdir::TestDir;\n@@ -37,8 +37,12 @@ impl<'a> Project<'a> {\n                     \"sysroot\": null,\n                     // Can't use test binary as rustc wrapper.\n                     \"buildScripts\": {\n-                        \"useRustcWrapper\": false\n+                        \"useRustcWrapper\": false,\n+                        \"enable\": false,\n                     },\n+                },\n+                \"procMacro\": {\n+                    \"enable\": false,\n                 }\n             }),\n         }\n@@ -80,10 +84,12 @@ impl<'a> Project<'a> {\n             profile::init_from(crate::PROFILE);\n         });\n \n-        let (mini_core, proc_macros, fixtures) = Fixture::parse(self.fixture);\n-        assert!(proc_macros.is_empty());\n+        let FixtureWithProjectMeta { fixture, mini_core, proc_macro_names, toolchain } =\n+            FixtureWithProjectMeta::parse(self.fixture);\n+        assert!(proc_macro_names.is_empty());\n         assert!(mini_core.is_none());\n-        for entry in fixtures {\n+        assert!(toolchain.is_none());\n+        for entry in fixture {\n             let path = tmp_dir.path().join(&entry.path['/'.len_utf8()..]);\n             fs::create_dir_all(path.parent().unwrap()).unwrap();\n             fs::write(path.as_path(), entry.text.as_bytes()).unwrap();\n@@ -251,6 +257,9 @@ impl Server {\n                     .clone()\n                     .extract::<lsp_ext::ServerStatusParams>(\"experimental/serverStatus\")\n                     .unwrap();\n+                if status.health != lsp_ext::Health::Ok {\n+                    panic!(\"server errored/warned while loading workspace: {:?}\", status.message);\n+                }\n                 status.quiescent\n             }\n             _ => false,"}, {"sha": "c5da6ceb4d1980c45c78d162e201886aee8542a9", "filename": "crates/sourcegen/src/lib.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fsourcegen%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fsourcegen%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsourcegen%2Fsrc%2Flib.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -58,21 +58,19 @@ impl CommentBlock {\n         assert!(tag.starts_with(char::is_uppercase));\n \n         let tag = format!(\"{tag}:\");\n-        // Would be nice if we had `.retain_mut` here!\n-        CommentBlock::extract_untagged(text)\n-            .into_iter()\n-            .filter_map(|mut block| {\n-                let first = block.contents.remove(0);\n-                first.strip_prefix(&tag).map(|id| {\n-                    if block.is_doc {\n-                        panic!(\"Use plain (non-doc) comments with tags like {tag}:\\n    {first}\");\n-                    }\n+        let mut blocks = CommentBlock::extract_untagged(text);\n+        blocks.retain_mut(|block| {\n+            let first = block.contents.remove(0);\n+            let Some(id) = first.strip_prefix(&tag) else { return false; };\n+\n+            if block.is_doc {\n+                panic!(\"Use plain (non-doc) comments with tags like {tag}:\\n    {first}\");\n+            }\n \n-                    block.id = id.trim().to_string();\n-                    block\n-                })\n-            })\n-            .collect()\n+            block.id = id.trim().to_string();\n+            true\n+        });\n+        blocks\n     }\n \n     pub fn extract_untagged(text: &str) -> Vec<CommentBlock> {"}, {"sha": "9109507f75e4585c9639d93e3889b57927840e0e", "filename": "crates/syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2FCargo.toml?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -21,7 +21,7 @@ rustc_lexer = { version = \"727.0.0\", package = \"rustc-ap-rustc_lexer\" }\n rustc-hash = \"1.1.0\"\n once_cell = \"1.17.0\"\n indexmap = \"1.9.1\"\n-smol_str = \"0.1.23\"\n+smol_str.workspace = true\n \n parser.workspace = true\n profile.workspace = true"}, {"sha": "09c080c0c2301d2f02fb444610772a13ad144d65", "filename": "crates/syntax/src/token_text.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fsyntax%2Fsrc%2Ftoken_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Fsyntax%2Fsrc%2Ftoken_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Ftoken_text.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -3,6 +3,7 @@\n use std::{cmp::Ordering, fmt, ops};\n \n use rowan::GreenToken;\n+use smol_str::SmolStr;\n \n pub struct TokenText<'a>(pub(crate) Repr<'a>);\n \n@@ -47,6 +48,12 @@ impl From<TokenText<'_>> for String {\n     }\n }\n \n+impl From<TokenText<'_>> for SmolStr {\n+    fn from(token_text: TokenText<'_>) -> Self {\n+        SmolStr::new(token_text.as_str())\n+    }\n+}\n+\n impl PartialEq<&'_ str> for TokenText<'_> {\n     fn eq(&self, other: &&str) -> bool {\n         self.as_str() == *other"}, {"sha": "dffc7fccdab1801a3e050fe52a3603d156d69f82", "filename": "crates/test-utils/src/fixture.rs", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Ftest-utils%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Ftest-utils%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Ffixture.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -86,7 +86,14 @@ pub struct MiniCore {\n     valid_flags: Vec<String>,\n }\n \n-impl Fixture {\n+pub struct FixtureWithProjectMeta {\n+    pub fixture: Vec<Fixture>,\n+    pub mini_core: Option<MiniCore>,\n+    pub proc_macro_names: Vec<String>,\n+    pub toolchain: Option<String>,\n+}\n+\n+impl FixtureWithProjectMeta {\n     /// Parses text which looks like this:\n     ///\n     ///  ```not_rust\n@@ -96,37 +103,40 @@ impl Fixture {\n     ///  //- other meta\n     ///  ```\n     ///\n-    /// Fixture can also start with a proc_macros and minicore declaration(in that order):\n+    /// Fixture can also start with a proc_macros and minicore declaration (in that order):\n     ///\n     /// ```\n+    /// //- toolchain: nightly\n     /// //- proc_macros: identity\n     /// //- minicore: sized\n     /// ```\n     ///\n     /// That will include predefined proc macros and a subset of `libcore` into the fixture, see\n     /// `minicore.rs` for what's available.\n-    pub fn parse(ra_fixture: &str) -> (Option<MiniCore>, Vec<String>, Vec<Fixture>) {\n+    pub fn parse(ra_fixture: &str) -> Self {\n         let fixture = trim_indent(ra_fixture);\n         let mut fixture = fixture.as_str();\n+        let mut toolchain = None;\n         let mut mini_core = None;\n         let mut res: Vec<Fixture> = Vec::new();\n-        let mut test_proc_macros = vec![];\n-\n-        if fixture.starts_with(\"//- proc_macros:\") {\n-            let first_line = fixture.split_inclusive('\\n').next().unwrap();\n-            test_proc_macros = first_line\n-                .strip_prefix(\"//- proc_macros:\")\n-                .unwrap()\n-                .split(',')\n-                .map(|it| it.trim().to_string())\n-                .collect();\n-            fixture = &fixture[first_line.len()..];\n+        let mut proc_macro_names = vec![];\n+\n+        if let Some(meta) = fixture.strip_prefix(\"//- toolchain:\") {\n+            let (meta, remain) = meta.split_once('\\n').unwrap();\n+            toolchain = Some(meta.trim().to_string());\n+            fixture = remain;\n         }\n \n-        if fixture.starts_with(\"//- minicore:\") {\n-            let first_line = fixture.split_inclusive('\\n').next().unwrap();\n-            mini_core = Some(MiniCore::parse(first_line));\n-            fixture = &fixture[first_line.len()..];\n+        if let Some(meta) = fixture.strip_prefix(\"//- proc_macros:\") {\n+            let (meta, remain) = meta.split_once('\\n').unwrap();\n+            proc_macro_names = meta.split(',').map(|it| it.trim().to_string()).collect();\n+            fixture = remain;\n+        }\n+\n+        if let Some(meta) = fixture.strip_prefix(\"//- minicore:\") {\n+            let (meta, remain) = meta.split_once('\\n').unwrap();\n+            mini_core = Some(MiniCore::parse(meta));\n+            fixture = remain;\n         }\n \n         let default = if fixture.contains(\"//-\") { None } else { Some(\"//- /main.rs\") };\n@@ -142,7 +152,7 @@ impl Fixture {\n             }\n \n             if line.starts_with(\"//-\") {\n-                let meta = Fixture::parse_meta_line(line);\n+                let meta = Self::parse_meta_line(line);\n                 res.push(meta);\n             } else {\n                 if line.starts_with(\"// \")\n@@ -160,7 +170,7 @@ impl Fixture {\n             }\n         }\n \n-        (mini_core, test_proc_macros, res)\n+        Self { fixture: res, mini_core, proc_macro_names, toolchain }\n     }\n \n     //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo\n@@ -257,8 +267,7 @@ impl MiniCore {\n     fn parse(line: &str) -> MiniCore {\n         let mut res = MiniCore { activated_flags: Vec::new(), valid_flags: Vec::new() };\n \n-        let line = line.strip_prefix(\"//- minicore:\").unwrap().trim();\n-        for entry in line.split(\", \") {\n+        for entry in line.trim().split(\", \") {\n             if res.has_flag(entry) {\n                 panic!(\"duplicate minicore flag: {entry:?}\");\n             }\n@@ -372,7 +381,7 @@ impl MiniCore {\n #[test]\n #[should_panic]\n fn parse_fixture_checks_further_indented_metadata() {\n-    Fixture::parse(\n+    FixtureWithProjectMeta::parse(\n         r\"\n         //- /lib.rs\n           mod bar;\n@@ -386,15 +395,18 @@ fn parse_fixture_checks_further_indented_metadata() {\n \n #[test]\n fn parse_fixture_gets_full_meta() {\n-    let (mini_core, proc_macros, parsed) = Fixture::parse(\n-        r#\"\n+    let FixtureWithProjectMeta { fixture: parsed, mini_core, proc_macro_names, toolchain } =\n+        FixtureWithProjectMeta::parse(\n+            r#\"\n+//- toolchain: nightly\n //- proc_macros: identity\n //- minicore: coerce_unsized\n //- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b,atom env:OUTDIR=path/to,OTHER=foo\n mod m;\n \"#,\n-    );\n-    assert_eq!(proc_macros, vec![\"identity\".to_string()]);\n+        );\n+    assert_eq!(toolchain, Some(\"nightly\".to_string()));\n+    assert_eq!(proc_macro_names, vec![\"identity\".to_string()]);\n     assert_eq!(mini_core.unwrap().activated_flags, vec![\"coerce_unsized\".to_string()]);\n     assert_eq!(1, parsed.len());\n "}, {"sha": "5abadaad6295e2d20fd32483a1baf854a69f123a", "filename": "crates/test-utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Ftest-utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Ftest-utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Flib.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -27,7 +27,7 @@ pub use rustc_hash::FxHashMap;\n \n pub use crate::{\n     assert_linear::AssertLinear,\n-    fixture::{Fixture, MiniCore},\n+    fixture::{Fixture, FixtureWithProjectMeta, MiniCore},\n };\n \n pub const CURSOR_MARKER: &str = \"$0\";"}, {"sha": "308dc5892e5eed0245da4c99872bc7fa0e63346a", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -143,6 +143,12 @@ pub mod clone {\n     pub trait Clone: Sized {\n         fn clone(&self) -> Self;\n     }\n+\n+    impl<T> Clone for &T {\n+        fn clone(&self) -> Self {\n+            *self\n+        }\n+    }\n     // region:derive\n     #[rustc_builtin_macro]\n     pub macro Clone($item:item) {}\n@@ -885,12 +891,19 @@ pub mod iter {\n                     self\n                 }\n             }\n-            pub struct IntoIter<T, const N: usize>([T; N]);\n+            struct IndexRange {\n+                start: usize,\n+                end: usize,\n+            }\n+            pub struct IntoIter<T, const N: usize> {\n+                data: [T; N],\n+                range: IndexRange,\n+            }\n             impl<T, const N: usize> IntoIterator for [T; N] {\n                 type Item = T;\n                 type IntoIter = IntoIter<T, N>;\n                 fn into_iter(self) -> I {\n-                    IntoIter(self)\n+                    IntoIter { data: self, range: IndexRange { start: 0, end: self.len() } }\n                 }\n             }\n             impl<T, const N: usize> Iterator for IntoIter<T, N> {"}, {"sha": "a28ee5f1ca2bbcee5b85c1bd434f14daf1f76f8b", "filename": "crates/tt/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Ftt%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/crates%2Ftt%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftt%2FCargo.toml?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -12,6 +12,6 @@ rust-version.workspace = true\n doctest = false\n \n [dependencies]\n-smol_str = \"0.1.23\"\n+smol_str.workspace = true\n \n stdx.workspace = true"}, {"sha": "e92e6ae92cce34a8e7c08983df48d618ad4d985d", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -474,6 +474,11 @@ to always show them).\n --\n Whether to show inlay type hints for return types of closures.\n --\n+[[rust-analyzer.inlayHints.closureStyle]]rust-analyzer.inlayHints.closureStyle (default: `\"impl_fn\"`)::\n++\n+--\n+Closure notation in type and chaining inaly hints.\n+--\n [[rust-analyzer.inlayHints.discriminantHints.enable]]rust-analyzer.inlayHints.discriminantHints.enable (default: `\"never\"`)::\n +\n --"}, {"sha": "087fd1296b3100060315a42620a7e6a566760023", "filename": "editors/code/package.json", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1028,6 +1028,23 @@\n                         \"Only show type hints for return types of closures with blocks.\"\n                     ]\n                 },\n+                \"rust-analyzer.inlayHints.closureStyle\": {\n+                    \"markdownDescription\": \"Closure notation in type and chaining inaly hints.\",\n+                    \"default\": \"impl_fn\",\n+                    \"type\": \"string\",\n+                    \"enum\": [\n+                        \"impl_fn\",\n+                        \"rust_analyzer\",\n+                        \"with_id\",\n+                        \"hide\"\n+                    ],\n+                    \"enumDescriptions\": [\n+                        \"`impl_fn`: `impl FnMut(i32, u64) -> i8`\",\n+                        \"`rust_analyzer`: `|i32, u64| -> i8`\",\n+                        \"`with_id`: `{closure#14352}`, where that id is the unique number of the closure in r-a internals\",\n+                        \"`hide`: Shows `...` for every closure type\"\n+                    ]\n+                },\n                 \"rust-analyzer.inlayHints.discriminantHints.enable\": {\n                     \"markdownDescription\": \"Whether to show enum variant discriminant hints.\",\n                     \"default\": \"never\","}, {"sha": "b27d9f5494394c44a7c584ae36b6466b8ca282bd", "filename": "editors/code/src/client.ts", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/editors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/editors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fclient.ts?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -125,7 +125,11 @@ export async function createClient(\n                         typeof diag.code === \"string\" || typeof diag.code === \"number\"\n                             ? diag.code\n                             : diag.code?.value;\n-                    if (value === \"unlinked-file\" && !unlinkedFiles.includes(uri)) {\n+                    if (\n+                        value === \"unlinked-file\" &&\n+                        !unlinkedFiles.includes(uri) &&\n+                        diag.message !== \"file not included in module tree\"\n+                    ) {\n                         const config = vscode.workspace.getConfiguration(\"rust-analyzer\");\n                         if (config.get(\"showUnlinkedFileNotification\")) {\n                             unlinkedFiles.push(uri);"}, {"sha": "4438d475ad914bdfaae791406580606b2d0524da", "filename": "editors/code/src/commands.ts", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/editors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/editors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands.ts?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -761,12 +761,13 @@ export function addProject(ctx: CtxInit): Cmd {\n         }\n \n         const workspaces: JsonProject[] = await Promise.all(\n-            vscode.workspace.workspaceFolders!.map(async (folder): Promise<JsonProject> => {\n-                const rustDocuments = vscode.workspace.textDocuments.filter(isRustDocument);\n-                return discoverWorkspace(rustDocuments, discoverProjectCommand, {\n-                    cwd: folder.uri.fsPath,\n-                });\n-            })\n+            vscode.workspace.textDocuments\n+                .filter(isRustDocument)\n+                .map(async (file): Promise<JsonProject> => {\n+                    return discoverWorkspace([file], discoverProjectCommand, {\n+                        cwd: path.dirname(file.uri.fsPath),\n+                    });\n+                })\n         );\n \n         ctx.addToDiscoveredWorkspaces(workspaces);"}, {"sha": "0ffa42c2a5a1f551b64dc75e304e8a2ed3f55ef5", "filename": "editors/code/src/ctx.ts", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/editors%2Fcode%2Fsrc%2Fctx.ts", "raw_url": "https://github.com/rust-lang/rust/raw/398af0259f7614ff8a0d603edd5d94ce9aecd5f2/editors%2Fcode%2Fsrc%2Fctx.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fctx.ts?ref=398af0259f7614ff8a0d603edd5d94ce9aecd5f2", "patch": "@@ -1,6 +1,7 @@\n import * as vscode from \"vscode\";\n import * as lc from \"vscode-languageclient/node\";\n import * as ra from \"./lsp_ext\";\n+import * as path from \"path\";\n \n import { Config, prepareVSCodeConfig } from \"./config\";\n import { createClient } from \"./client\";\n@@ -192,12 +193,13 @@ export class Ctx {\n             const discoverProjectCommand = this.config.discoverProjectCommand;\n             if (discoverProjectCommand) {\n                 const workspaces: JsonProject[] = await Promise.all(\n-                    vscode.workspace.workspaceFolders!.map(async (folder): Promise<JsonProject> => {\n-                        const rustDocuments = vscode.workspace.textDocuments.filter(isRustDocument);\n-                        return discoverWorkspace(rustDocuments, discoverProjectCommand, {\n-                            cwd: folder.uri.fsPath,\n-                        });\n-                    })\n+                    vscode.workspace.textDocuments\n+                        .filter(isRustDocument)\n+                        .map(async (file): Promise<JsonProject> => {\n+                            return discoverWorkspace([file], discoverProjectCommand, {\n+                                cwd: path.dirname(file.uri.fsPath),\n+                            });\n+                        })\n                 );\n \n                 this.addToDiscoveredWorkspaces(workspaces);"}]}