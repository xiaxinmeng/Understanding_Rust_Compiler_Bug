{"sha": "15d1f811963649c2f18a88c8e0b39958ec02fd70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZDFmODExOTYzNjQ5YzJmMThhODhjOGUwYjM5OTU4ZWMwMmZkNzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-21T04:08:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-21T04:08:35Z"}, "message": "Auto merge of #80253 - Dylan-DPC:rollup-bkmn74z, r=Dylan-DPC\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #80159 (Add array search aliases)\n - #80166 (Edit rustc_middle docs)\n - #80170 (Fix ICE when lookup method in trait for type that have bound vars)\n - #80171 (Edit rustc_middle::ty::TyKind docs)\n - #80199 (also const-check FakeRead)\n - #80211 (Handle desugaring in impl trait bound suggestion)\n - #80236 (Use pointer type in AtomicPtr::swap implementation)\n - #80239 (Update Clippy)\n - #80240 (make sure installer only creates directories in DESTDIR)\n - #80244 (Cleanup markdown span handling)\n - #80250 (Minor cleanups in LateResolver)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7e1ae9d989015760f73bb7b35ddfa59da9c94c05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e1ae9d989015760f73bb7b35ddfa59da9c94c05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15d1f811963649c2f18a88c8e0b39958ec02fd70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15d1f811963649c2f18a88c8e0b39958ec02fd70", "html_url": "https://github.com/rust-lang/rust/commit/15d1f811963649c2f18a88c8e0b39958ec02fd70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15d1f811963649c2f18a88c8e0b39958ec02fd70/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8135455c4a96b1d2570198619f38185c063579d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8135455c4a96b1d2570198619f38185c063579d", "html_url": "https://github.com/rust-lang/rust/commit/c8135455c4a96b1d2570198619f38185c063579d"}, {"sha": "0947e0572392133784b98f1dc3396b92af354840", "url": "https://api.github.com/repos/rust-lang/rust/commits/0947e0572392133784b98f1dc3396b92af354840", "html_url": "https://github.com/rust-lang/rust/commit/0947e0572392133784b98f1dc3396b92af354840"}], "stats": {"total": 4807, "additions": 3573, "deletions": 1234}, "files": [{"sha": "80e3ed75b8585de8c7f5e2341ccceca7c9f39eee", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -524,8 +524,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         };\n \n                         let ty = substs.type_at(0);\n-                        if int_type_width_signed(ty, bx.tcx()).is_some() {\n-                            bx.atomic_rmw(atom_op, args[0].immediate(), args[1].immediate(), order)\n+                        if int_type_width_signed(ty, bx.tcx()).is_some()\n+                            || (ty.is_unsafe_ptr() && op == \"xchg\")\n+                        {\n+                            let mut ptr = args[0].immediate();\n+                            let mut val = args[1].immediate();\n+                            if ty.is_unsafe_ptr() {\n+                                // Some platforms do not support atomic operations on pointers,\n+                                // so we cast to integer first.\n+                                let ptr_llty = bx.type_ptr_to(bx.type_isize());\n+                                ptr = bx.pointercast(ptr, ptr_llty);\n+                                val = bx.ptrtoint(val, bx.type_isize());\n+                            }\n+                            bx.atomic_rmw(atom_op, ptr, val, order)\n                         } else {\n                             return invalid_monomorphization(ty);\n                         }"}, {"sha": "1e2e9df88c584e40ceca08ee97db682d60d5d315", "filename": "compiler/rustc_middle/src/hir/place.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -17,13 +17,13 @@ use rustc_target::abi::VariantIdx;\n     HashStable\n )]\n pub enum PlaceBase {\n-    /// A temporary variable\n+    /// A temporary variable.\n     Rvalue,\n-    /// A named `static` item\n+    /// A named `static` item.\n     StaticItem,\n-    /// A named local variable\n+    /// A named local variable.\n     Local(HirId),\n-    /// An upvar referenced by closure env\n+    /// An upvar referenced by closure env.\n     Upvar(ty::UpvarId),\n }\n \n@@ -40,7 +40,7 @@ pub enum PlaceBase {\n     HashStable\n )]\n pub enum ProjectionKind {\n-    /// A dereference of a pointer, reference or `Box<T>` of the given type\n+    /// A dereference of a pointer, reference or `Box<T>` of the given type.\n     Deref,\n \n     /// `B.F` where `B` is the base expression and `F` is\n@@ -71,16 +71,16 @@ pub enum ProjectionKind {\n     HashStable\n )]\n pub struct Projection<'tcx> {\n-    /// Type after the projection is being applied.\n+    /// Type after the projection is applied.\n     pub ty: Ty<'tcx>,\n \n-    /// Defines the type of access\n+    /// Defines the kind of access made by the projection.\n     pub kind: ProjectionKind,\n }\n \n /// A `Place` represents how a value is located in memory.\n ///\n-/// This is an HIR version of `mir::Place`\n+/// This is an HIR version of [`rustc_middle::mir::Place`].\n #[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct Place<'tcx> {\n     /// The type of the `PlaceBase`\n@@ -93,13 +93,13 @@ pub struct Place<'tcx> {\n \n /// A `PlaceWithHirId` represents how a value is located in memory.\n ///\n-/// This is an HIR version of `mir::Place`\n+/// This is an HIR version of [`rustc_middle::mir::Place`].\n #[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct PlaceWithHirId<'tcx> {\n     /// `HirId` of the expression or pattern producing this value.\n     pub hir_id: HirId,\n \n-    /// Information about the `Place`\n+    /// Information about the `Place`.\n     pub place: Place<'tcx>,\n }\n "}, {"sha": "dc72a713a7d865ec75de96e0b68d8cda9dc0bc9d", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -88,6 +88,8 @@ impl BoundRegionKind {\n     }\n }\n \n+/// Defines the kinds of types.\n+///\n /// N.B., if you change this, you'll probably want to change the corresponding\n /// AST structure in `librustc_ast/ast.rs` as well.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable, Debug)]\n@@ -110,7 +112,7 @@ pub enum TyKind<'tcx> {\n     /// A primitive floating-point type. For example, `f64`.\n     Float(ast::FloatTy),\n \n-    /// Structures, enumerations and unions.\n+    /// Algebraic data types (ADT). For example: structures, enumerations and unions.\n     ///\n     /// InternalSubsts here, possibly against intuition, *may* contain `Param`s.\n     /// That is, even after substitution it is possible that there are type\n@@ -170,11 +172,11 @@ pub enum TyKind<'tcx> {\n     /// `|a| yield a`.\n     Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n \n-    /// A type representin the types stored inside a generator.\n+    /// A type representing the types stored inside a generator.\n     /// This should only appear in GeneratorInteriors.\n     GeneratorWitness(Binder<&'tcx List<Ty<'tcx>>>),\n \n-    /// The never type `!`\n+    /// The never type `!`.\n     Never,\n \n     /// A tuple type. For example, `(i32, bool)`."}, {"sha": "90688ebbd0acbf0d8d097b52bfc6850713317034", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -722,17 +722,16 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: statement={:?} location={:?}\", statement, location);\n \n-        match statement.kind {\n-            StatementKind::Assign(..) | StatementKind::SetDiscriminant { .. } => {\n-                self.super_statement(statement, location);\n-            }\n+        self.super_statement(statement, location);\n \n+        match statement.kind {\n             StatementKind::LlvmInlineAsm { .. } => {\n-                self.super_statement(statement, location);\n                 self.check_op(ops::InlineAsm);\n             }\n \n-            StatementKind::FakeRead(..)\n+            StatementKind::Assign(..)\n+            | StatementKind::SetDiscriminant { .. }\n+            | StatementKind::FakeRead(..)\n             | StatementKind::StorageLive(_)\n             | StatementKind::StorageDead(_)\n             | StatementKind::Retag { .. }"}, {"sha": "b13462587bc618ef55762577dd16a818ebb424a1", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -29,7 +29,7 @@ use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n \n use rustc_span::source_map::{respan, Spanned};\n-use std::collections::BTreeSet;\n+use std::collections::{hash_map::Entry, BTreeSet};\n use std::mem::{replace, take};\n use tracing::debug;\n \n@@ -953,8 +953,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                             });\n                         };\n \n-                        for item in trait_items {\n-                            this.with_trait_items(trait_items, |this| {\n+                        this.with_trait_items(trait_items, |this| {\n+                            for item in trait_items {\n                                 match &item.kind {\n                                     AssocItemKind::Const(_, ty, default) => {\n                                         this.visit_ty(ty);\n@@ -983,8 +983,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                         panic!(\"unexpanded macro in resolve!\")\n                                     }\n                                 };\n-                            });\n-                        }\n+                            }\n+                        });\n                     });\n                 });\n             }\n@@ -1060,36 +1060,29 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 continue;\n             }\n \n-            let def_kind = match param.kind {\n-                GenericParamKind::Type { .. } => DefKind::TyParam,\n-                GenericParamKind::Const { .. } => DefKind::ConstParam,\n-                _ => unreachable!(),\n-            };\n-\n             let ident = param.ident.normalize_to_macros_2_0();\n             debug!(\"with_generic_param_rib: {}\", param.id);\n \n-            if seen_bindings.contains_key(&ident) {\n-                let span = seen_bindings.get(&ident).unwrap();\n-                let err = ResolutionError::NameAlreadyUsedInParameterList(ident.name, *span);\n-                self.report_error(param.ident.span, err);\n+            match seen_bindings.entry(ident) {\n+                Entry::Occupied(entry) => {\n+                    let span = *entry.get();\n+                    let err = ResolutionError::NameAlreadyUsedInParameterList(ident.name, span);\n+                    self.report_error(param.ident.span, err);\n+                }\n+                Entry::Vacant(entry) => {\n+                    entry.insert(param.ident.span);\n+                }\n             }\n-            seen_bindings.entry(ident).or_insert(param.ident.span);\n \n             // Plain insert (no renaming).\n-            let res = Res::Def(def_kind, self.r.local_def_id(param.id).to_def_id());\n-\n-            match param.kind {\n-                GenericParamKind::Type { .. } => {\n-                    function_type_rib.bindings.insert(ident, res);\n-                    self.r.record_partial_res(param.id, PartialRes::new(res));\n-                }\n-                GenericParamKind::Const { .. } => {\n-                    function_value_rib.bindings.insert(ident, res);\n-                    self.r.record_partial_res(param.id, PartialRes::new(res));\n-                }\n+            let (rib, def_kind) = match param.kind {\n+                GenericParamKind::Type { .. } => (&mut function_type_rib, DefKind::TyParam),\n+                GenericParamKind::Const { .. } => (&mut function_value_rib, DefKind::ConstParam),\n                 _ => unreachable!(),\n-            }\n+            };\n+            let res = Res::Def(def_kind, self.r.local_def_id(param.id).to_def_id());\n+            self.r.record_partial_res(param.id, PartialRes::new(res));\n+            rib.bindings.insert(ident, res);\n         }\n \n         self.ribs[ValueNS].push(function_value_rib);\n@@ -1778,7 +1771,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             path\n         );\n         let ns = source.namespace();\n-        let is_expected = &|res| source.is_expected(res);\n \n         let report_errors = |this: &mut Self, res: Option<Res>| {\n             if this.should_report_errs() {\n@@ -1881,7 +1873,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             crate_lint,\n         ) {\n             Ok(Some(partial_res)) if partial_res.unresolved_segments() == 0 => {\n-                if is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err {\n+                if source.is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err\n+                {\n                     partial_res\n                 } else {\n                     report_errors(self, Some(partial_res.base_res()))\n@@ -1898,11 +1891,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     self.r.trait_map.insert(id, traits);\n                 }\n \n-                let mut std_path = vec![Segment::from_ident(Ident::with_dummy_span(sym::std))];\n-\n-                std_path.extend(path);\n-\n                 if self.r.primitive_type_table.primitive_types.contains_key(&path[0].ident.name) {\n+                    let mut std_path = Vec::with_capacity(1 + path.len());\n+\n+                    std_path.push(Segment::from_ident(Ident::with_dummy_span(sym::std)));\n+                    std_path.extend(path);\n                     if let PathResult::Module(_) | PathResult::NonModule(_) =\n                         self.resolve_path(&std_path, Some(ns), false, span, CrateLint::No)\n                     {\n@@ -1983,7 +1976,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     ) -> Result<Option<PartialRes>, Spanned<ResolutionError<'a>>> {\n         let mut fin_res = None;\n \n-        for (i, ns) in [primary_ns, TypeNS, ValueNS].iter().cloned().enumerate() {\n+        for (i, &ns) in [primary_ns, TypeNS, ValueNS].iter().enumerate() {\n             if i == 0 || ns != primary_ns {\n                 match self.resolve_qpath(id, qself, path, ns, span, crate_lint)? {\n                     Some(partial_res)\n@@ -1993,7 +1986,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     }\n                     partial_res => {\n                         if fin_res.is_none() {\n-                            fin_res = partial_res\n+                            fin_res = partial_res;\n                         }\n                     }\n                 }"}, {"sha": "79fea83a6674d3021b6e19122e4bd7ad8f62b346", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -254,27 +254,21 @@ fn suggest_restriction(\n         let pred = trait_ref.without_const().to_predicate(tcx).to_string();\n         let pred = pred.replace(&impl_trait_str, &type_param_name);\n         let mut sugg = vec![\n+            // Find the last of the generic parameters contained within the span of\n+            // the generics\n             match generics\n                 .params\n                 .iter()\n-                .filter(|p| match p.kind {\n-                    hir::GenericParamKind::Type {\n-                        synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                        ..\n-                    } => false,\n-                    _ => true,\n-                })\n-                .last()\n+                .map(|p| p.bounds_span().unwrap_or(p.span))\n+                .filter(|&span| generics.span.contains(span) && span.desugaring_kind().is_none())\n+                .max_by_key(|span| span.hi())\n             {\n                 // `fn foo(t: impl Trait)`\n                 //        ^ suggest `<T: Trait>` here\n                 None => (generics.span, format!(\"<{}>\", type_param)),\n                 // `fn foo<A>(t: impl Trait)`\n                 //        ^^^ suggest `<A, T: Trait>` here\n-                Some(param) => (\n-                    param.bounds_span().unwrap_or(param.span).shrink_to_hi(),\n-                    format!(\", {}\", type_param),\n-                ),\n+                Some(span) => (span.shrink_to_hi(), format!(\", {}\", type_param)),\n             },\n             // `fn foo(t: impl Trait)`\n             //                       ^ suggest `where <T as Trait>::A: Bound`"}, {"sha": "6467e04407939400018df59daecc245cba23084b", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -31,7 +31,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => (false, false, false),\n         };\n \n-        // Type check the descriminant and get its type.\n+        // Type check the discriminant and get its type.\n         let scrutinee_ty = if force_scrutinee_bool {\n             // Here we want to ensure:\n             //"}, {"sha": "9ab056c0d74b3a3d7ef8bc8e683707b16d780542", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -503,8 +503,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if !self.tcx.has_typeck_results(def_id) {\n                 return false;\n             }\n-            // We're emitting a suggestion, so we can just ignore regions\n-            let fn_sig = self.tcx.fn_sig(def_id).skip_binder();\n+            // FIXME: Instead of exiting early when encountering bound vars in\n+            // the function signature, consider keeping the binder here and\n+            // propagating it downwards.\n+            let fn_sig = if let Some(fn_sig) = self.tcx.fn_sig(def_id).no_bound_vars() {\n+                fn_sig\n+            } else {\n+                return false;\n+            };\n \n             let other_ty = if let FnDef(def_id, _) = *other_ty.kind() {\n                 if !self.tcx.has_typeck_results(def_id) {"}, {"sha": "a96da9aa6dc73c3879acbffcab9a0fc082c3ed3d", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1040,8 +1040,16 @@ impl<T> AtomicPtr<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"ptr\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n+        #[cfg(bootstrap)]\n         // SAFETY: data races are prevented by atomic intrinsics.\n-        unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n+        unsafe {\n+            atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T\n+        }\n+        #[cfg(not(bootstrap))]\n+        // SAFETY: data races are prevented by atomic intrinsics.\n+        unsafe {\n+            atomic_swap(self.p.get(), ptr, order)\n+        }\n     }\n \n     /// Stores a value into the pointer if the current value is the same as the `current` value."}, {"sha": "ec12e9f09d8b1eab4da8b50547a44ae75bfcb8a3", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -478,8 +478,10 @@ mod prim_unit {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_pointer {}\n \n+#[doc(alias = \"[]\")]\n+#[doc(alias = \"[T;N]\")] // unfortunately, rustdoc doesn't have fuzzy search for aliases\n+#[doc(alias = \"[T; N]\")]\n #[doc(primitive = \"array\")]\n-//\n /// A fixed-size array, denoted `[T; N]`, for the element type, `T`, and the\n /// non-negative compile-time constant size, `N`.\n ///"}, {"sha": "8f2b128b3688e745ceddbd54785797a19bf669fd", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -73,12 +73,7 @@ fn install_sh(\n     let docdir_default = datadir_default.join(\"doc/rust\");\n     let libdir_default = PathBuf::from(\"lib\");\n     let mandir_default = datadir_default.join(\"man\");\n-    let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {\n-        fs::create_dir_all(p)\n-            .unwrap_or_else(|err| panic!(\"could not create {}: {}\", p.display(), err));\n-        fs::canonicalize(p)\n-            .unwrap_or_else(|err| panic!(\"could not canonicalize {}: {}\", p.display(), err))\n-    });\n+    let prefix = builder.config.prefix.as_ref().unwrap_or(&prefix_default);\n     let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n     let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);\n     let docdir = builder.config.docdir.as_ref().unwrap_or(&docdir_default);\n@@ -103,6 +98,13 @@ fn install_sh(\n     let libdir = add_destdir(&libdir, &destdir);\n     let mandir = add_destdir(&mandir, &destdir);\n \n+    let prefix = {\n+        fs::create_dir_all(&prefix)\n+            .unwrap_or_else(|err| panic!(\"could not create {}: {}\", prefix.display(), err));\n+        fs::canonicalize(&prefix)\n+            .unwrap_or_else(|err| panic!(\"could not canonicalize {}: {}\", prefix.display(), err))\n+    };\n+\n     let empty_dir = builder.out.join(\"tmp/empty_dir\");\n \n     t!(fs::create_dir_all(&empty_dir));"}, {"sha": "0e87dd72ef1f2035990215ea645f77f2877905a5", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 66, "deletions": 69, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -447,61 +447,61 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n }\n \n /// Make headings links with anchor IDs and build up TOC.\n-struct HeadingLinks<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> {\n+struct HeadingLinks<'a, 'b, 'ids, I> {\n     inner: I,\n     toc: Option<&'b mut TocBuilder>,\n-    buf: VecDeque<Event<'a>>,\n+    buf: VecDeque<(Event<'a>, Range<usize>)>,\n     id_map: &'ids mut IdMap,\n }\n \n-impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> HeadingLinks<'a, 'b, 'ids, I> {\n+impl<'a, 'b, 'ids, I> HeadingLinks<'a, 'b, 'ids, I> {\n     fn new(iter: I, toc: Option<&'b mut TocBuilder>, ids: &'ids mut IdMap) -> Self {\n         HeadingLinks { inner: iter, toc, buf: VecDeque::new(), id_map: ids }\n     }\n }\n \n-impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, 'ids, I> {\n-    type Item = Event<'a>;\n+impl<'a, 'b, 'ids, I: Iterator<Item = (Event<'a>, Range<usize>)>> Iterator\n+    for HeadingLinks<'a, 'b, 'ids, I>\n+{\n+    type Item = (Event<'a>, Range<usize>);\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(e) = self.buf.pop_front() {\n             return Some(e);\n         }\n \n         let event = self.inner.next();\n-        if let Some(Event::Start(Tag::Heading(level))) = event {\n+        if let Some((Event::Start(Tag::Heading(level)), _)) = event {\n             let mut id = String::new();\n             for event in &mut self.inner {\n-                match &event {\n+                match &event.0 {\n                     Event::End(Tag::Heading(..)) => break,\n+                    Event::Start(Tag::Link(_, _, _)) | Event::End(Tag::Link(..)) => {}\n                     Event::Text(text) | Event::Code(text) => {\n                         id.extend(text.chars().filter_map(slugify));\n+                        self.buf.push_back(event);\n                     }\n-                    _ => {}\n-                }\n-                match event {\n-                    Event::Start(Tag::Link(_, _, _)) | Event::End(Tag::Link(..)) => {}\n-                    event => self.buf.push_back(event),\n+                    _ => self.buf.push_back(event),\n                 }\n             }\n             let id = self.id_map.derive(id);\n \n             if let Some(ref mut builder) = self.toc {\n                 let mut html_header = String::new();\n-                html::push_html(&mut html_header, self.buf.iter().cloned());\n+                html::push_html(&mut html_header, self.buf.iter().map(|(ev, _)| ev.clone()));\n                 let sec = builder.push(level as u32, html_header, id.clone());\n-                self.buf.push_front(Event::Html(format!(\"{} \", sec).into()));\n+                self.buf.push_front((Event::Html(format!(\"{} \", sec).into()), 0..0));\n             }\n \n-            self.buf.push_back(Event::Html(format!(\"</a></h{}>\", level).into()));\n+            self.buf.push_back((Event::Html(format!(\"</a></h{}>\", level).into()), 0..0));\n \n             let start_tags = format!(\n                 \"<h{level} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n                     <a href=\\\"#{id}\\\">\",\n                 id = id,\n                 level = level\n             );\n-            return Some(Event::Html(start_tags.into()));\n+            return Some((Event::Html(start_tags.into()), 0..0));\n         }\n         event\n     }\n@@ -575,39 +575,40 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for SummaryLine<'a, I> {\n \n /// Moves all footnote definitions to the end and add back links to the\n /// references.\n-struct Footnotes<'a, I: Iterator<Item = Event<'a>>> {\n+struct Footnotes<'a, I> {\n     inner: I,\n     footnotes: FxHashMap<String, (Vec<Event<'a>>, u16)>,\n }\n \n-impl<'a, I: Iterator<Item = Event<'a>>> Footnotes<'a, I> {\n+impl<'a, I> Footnotes<'a, I> {\n     fn new(iter: I) -> Self {\n         Footnotes { inner: iter, footnotes: FxHashMap::default() }\n     }\n+\n     fn get_entry(&mut self, key: &str) -> &mut (Vec<Event<'a>>, u16) {\n         let new_id = self.footnotes.keys().count() + 1;\n         let key = key.to_owned();\n         self.footnotes.entry(key).or_insert((Vec::new(), new_id as u16))\n     }\n }\n \n-impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n-    type Item = Event<'a>;\n+impl<'a, I: Iterator<Item = (Event<'a>, Range<usize>)>> Iterator for Footnotes<'a, I> {\n+    type Item = (Event<'a>, Range<usize>);\n \n     fn next(&mut self) -> Option<Self::Item> {\n         loop {\n             match self.inner.next() {\n-                Some(Event::FootnoteReference(ref reference)) => {\n+                Some((Event::FootnoteReference(ref reference), range)) => {\n                     let entry = self.get_entry(&reference);\n                     let reference = format!(\n                         \"<sup id=\\\"fnref{0}\\\"><a href=\\\"#fn{0}\\\">{0}</a></sup>\",\n                         (*entry).1\n                     );\n-                    return Some(Event::Html(reference.into()));\n+                    return Some((Event::Html(reference.into()), range));\n                 }\n-                Some(Event::Start(Tag::FootnoteDefinition(def))) => {\n+                Some((Event::Start(Tag::FootnoteDefinition(def)), _)) => {\n                     let mut content = Vec::new();\n-                    for event in &mut self.inner {\n+                    for (event, _) in &mut self.inner {\n                         if let Event::End(Tag::FootnoteDefinition(..)) = event {\n                             break;\n                         }\n@@ -638,7 +639,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n                             ret.push_str(\"</li>\");\n                         }\n                         ret.push_str(\"</ol></div>\");\n-                        return Some(Event::Html(ret.into()));\n+                        return Some((Event::Html(ret.into()), 0..0));\n                     } else {\n                         return None;\n                     }\n@@ -946,13 +947,14 @@ impl Markdown<'_> {\n         };\n \n         let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut replacer));\n+        let p = p.into_offset_iter();\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n-        let p = LinkReplacer::new(p, links);\n-        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n+        let p = LinkReplacer::new(p.map(|(ev, _)| ev), links);\n+        let p = CodeBlocks::new(p, codes, edition, playground);\n         html::push_html(&mut s, p);\n \n         s\n@@ -963,16 +965,16 @@ impl MarkdownWithToc<'_> {\n     crate fn into_string(self) -> String {\n         let MarkdownWithToc(md, mut ids, codes, edition, playground) = self;\n \n-        let p = Parser::new_ext(md, opts());\n+        let p = Parser::new_ext(md, opts()).into_offset_iter();\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let mut toc = TocBuilder::new();\n \n         {\n             let p = HeadingLinks::new(p, Some(&mut toc), &mut ids);\n-            let p = CodeBlocks::new(p, codes, edition, playground);\n             let p = Footnotes::new(p);\n+            let p = CodeBlocks::new(p.map(|(ev, _)| ev), codes, edition, playground);\n             html::push_html(&mut s, p);\n         }\n \n@@ -988,19 +990,19 @@ impl MarkdownHtml<'_> {\n         if md.is_empty() {\n             return String::new();\n         }\n-        let p = Parser::new_ext(md, opts());\n+        let p = Parser::new_ext(md, opts()).into_offset_iter();\n \n         // Treat inline HTML as plain text.\n-        let p = p.map(|event| match event {\n-            Event::Html(text) => Event::Text(text),\n+        let p = p.map(|event| match event.0 {\n+            Event::Html(text) => (Event::Text(text), event.1),\n             _ => event,\n         });\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n-        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n+        let p = CodeBlocks::new(p.map(|(ev, _)| ev), codes, edition, playground);\n         html::push_html(&mut s, p);\n \n         s\n@@ -1153,50 +1155,45 @@ crate fn plain_text_summary(md: &str) -> String {\n     s\n }\n \n-crate fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n+crate fn markdown_links(md: &str) -> Vec<(String, Range<usize>)> {\n     if md.is_empty() {\n         return vec![];\n     }\n \n     let mut links = vec![];\n+    // Used to avoid mutable borrow issues in the `push` closure\n+    // Probably it would be more efficient to use a `RefCell` but it doesn't seem worth the churn.\n     let mut shortcut_links = vec![];\n \n-    {\n-        let locate = |s: &str| unsafe {\n-            let s_start = s.as_ptr();\n-            let s_end = s_start.add(s.len());\n-            let md_start = md.as_ptr();\n-            let md_end = md_start.add(md.len());\n-            if md_start <= s_start && s_end <= md_end {\n-                let start = s_start.offset_from(md_start) as usize;\n-                let end = s_end.offset_from(md_start) as usize;\n-                Some(start..end)\n-            } else {\n-                None\n-            }\n-        };\n-\n-        let mut push = |link: BrokenLink<'_>| {\n-            // FIXME: use `link.span` instead of `locate`\n-            // (doing it now includes the `[]` as well as the text)\n-            shortcut_links.push((link.reference.to_owned(), locate(link.reference)));\n-            None\n-        };\n-        let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut push));\n-\n-        // There's no need to thread an IdMap through to here because\n-        // the IDs generated aren't going to be emitted anywhere.\n-        let mut ids = IdMap::new();\n-        let iter = Footnotes::new(HeadingLinks::new(p, None, &mut ids));\n-\n-        for ev in iter {\n-            if let Event::Start(Tag::Link(_, dest, _)) = ev {\n-                debug!(\"found link: {}\", dest);\n-                links.push(match dest {\n-                    CowStr::Borrowed(s) => (s.to_owned(), locate(s)),\n-                    s @ (CowStr::Boxed(..) | CowStr::Inlined(..)) => (s.into_string(), None),\n-                });\n+    let span_for_link = |link: &str, span: Range<usize>| {\n+        // Pulldown includes the `[]` as well as the URL. Only highlight the relevant span.\n+        // NOTE: uses `rfind` in case the title and url are the same: `[Ok][Ok]`\n+        match md[span.clone()].rfind(link) {\n+            Some(start) => {\n+                let start = span.start + start;\n+                start..start + link.len()\n             }\n+            // This can happen for things other than intra-doc links, like `#1` expanded to `https://github.com/rust-lang/rust/issues/1`.\n+            None => span,\n+        }\n+    };\n+    let mut push = |link: BrokenLink<'_>| {\n+        let span = span_for_link(link.reference, link.span);\n+        shortcut_links.push((link.reference.to_owned(), span));\n+        None\n+    };\n+    let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut push));\n+\n+    // There's no need to thread an IdMap through to here because\n+    // the IDs generated aren't going to be emitted anywhere.\n+    let mut ids = IdMap::new();\n+    let iter = Footnotes::new(HeadingLinks::new(p.into_offset_iter(), None, &mut ids));\n+\n+    for ev in iter {\n+        if let Event::Start(Tag::Link(_, dest, _)) = ev.0 {\n+            debug!(\"found link: {}\", dest);\n+            let span = span_for_link(&dest, ev.1);\n+            links.push((dest.into_string(), span));\n         }\n     }\n "}, {"sha": "a8adfe08b2561168c42f00904cc7a5f5ba75b371", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -180,7 +180,7 @@ struct DiagnosticInfo<'a> {\n     item: &'a Item,\n     dox: &'a str,\n     ori_link: &'a str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n }\n \n #[derive(Clone, Debug, Hash)]\n@@ -920,7 +920,7 @@ impl LinkCollector<'_, '_> {\n         parent_node: Option<DefId>,\n         krate: CrateNum,\n         ori_link: String,\n-        link_range: Option<Range<usize>>,\n+        link_range: Range<usize>,\n     ) -> Option<ItemLink> {\n         trace!(\"considering link '{}'\", ori_link);\n \n@@ -1566,7 +1566,7 @@ fn report_diagnostic(\n     msg: &str,\n     item: &Item,\n     dox: &str,\n-    link_range: &Option<Range<usize>>,\n+    link_range: &Range<usize>,\n     decorate: impl FnOnce(&mut DiagnosticBuilder<'_>, Option<rustc_span::Span>),\n ) {\n     let hir_id = match cx.as_local_hir_id(item.def_id) {\n@@ -1584,31 +1584,26 @@ fn report_diagnostic(\n     cx.tcx.struct_span_lint_hir(lint, hir_id, sp, |lint| {\n         let mut diag = lint.build(msg);\n \n-        let span = link_range\n-            .as_ref()\n-            .and_then(|range| super::source_span_for_markdown_range(cx, dox, range, attrs));\n-\n-        if let Some(link_range) = link_range {\n-            if let Some(sp) = span {\n-                diag.set_span(sp);\n-            } else {\n-                // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n-                //                       ^     ~~~~\n-                //                       |     link_range\n-                //                       last_new_line_offset\n-                let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n-                let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n-\n-                // Print the line containing the `link_range` and manually mark it with '^'s.\n-                diag.note(&format!(\n-                    \"the link appears in this line:\\n\\n{line}\\n\\\n-                     {indicator: <before$}{indicator:^<found$}\",\n-                    line = line,\n-                    indicator = \"\",\n-                    before = link_range.start - last_new_line_offset,\n-                    found = link_range.len(),\n-                ));\n-            }\n+        let span = super::source_span_for_markdown_range(cx, dox, link_range, attrs);\n+        if let Some(sp) = span {\n+            diag.set_span(sp);\n+        } else {\n+            // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n+            //                       ^     ~~~~\n+            //                       |     link_range\n+            //                       last_new_line_offset\n+            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n+\n+            // Print the line containing the `link_range` and manually mark it with '^'s.\n+            diag.note(&format!(\n+                \"the link appears in this line:\\n\\n{line}\\n\\\n+                    {indicator: <before$}{indicator:^<found$}\",\n+                line = line,\n+                indicator = \"\",\n+                before = link_range.start - last_new_line_offset,\n+                found = link_range.len(),\n+            ));\n         }\n \n         decorate(&mut diag, span);\n@@ -1628,7 +1623,7 @@ fn resolution_failure(\n     path_str: &str,\n     disambiguator: Option<Disambiguator>,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n     kinds: SmallVec<[ResolutionFailure<'_>; 3]>,\n ) {\n     report_diagnostic(\n@@ -1862,7 +1857,7 @@ fn anchor_failure(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n     failure: AnchorFailure,\n ) {\n     let msg = match failure {\n@@ -1887,7 +1882,7 @@ fn ambiguity_error(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n     candidates: Vec<Res>,\n ) {\n     let mut msg = format!(\"`{}` is \", path_str);\n@@ -1936,13 +1931,12 @@ fn suggest_disambiguator(\n     path_str: &str,\n     dox: &str,\n     sp: Option<rustc_span::Span>,\n-    link_range: &Option<Range<usize>>,\n+    link_range: &Range<usize>,\n ) {\n     let suggestion = disambiguator.suggestion();\n     let help = format!(\"to link to the {}, {}\", disambiguator.descr(), suggestion.descr());\n \n     if let Some(sp) = sp {\n-        let link_range = link_range.as_ref().expect(\"must have a link range if we have a span\");\n         let msg = if dox.bytes().nth(link_range.start) == Some(b'`') {\n             format!(\"`{}`\", suggestion.as_help(path_str))\n         } else {\n@@ -1961,7 +1955,7 @@ fn privacy_error(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n ) {\n     let sym;\n     let item_name = match item.name {"}, {"sha": "d786e3358598446d63d07ccaf7b0584937a1bea5", "filename": "src/test/ui/binop/issue-77910-1.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,11 @@\n+fn foo(s: &i32) -> &i32 {\n+    let xs;\n+    xs\n+}\n+fn main() {\n+    let y;\n+    // we shouldn't ice with the bound var here.\n+    assert_eq!(foo, y);\n+    //~^ ERROR binary operation `==` cannot be applied to type\n+    //~| ERROR `for<'r> fn(&'r i32) -> &'r i32 {foo}` doesn't implement `Debug`\n+}"}, {"sha": "e48d3e19996f36fb4bbfaafce086967dce3b2e63", "filename": "src/test/ui/binop/issue-77910-1.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,26 @@\n+error[E0369]: binary operation `==` cannot be applied to type `for<'r> fn(&'r i32) -> &'r i32 {foo}`\n+  --> $DIR/issue-77910-1.rs:8:5\n+   |\n+LL |     assert_eq!(foo, y);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     for<'r> fn(&'r i32) -> &'r i32 {foo}\n+   |     _\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: `for<'r> fn(&'r i32) -> &'r i32 {foo}` doesn't implement `Debug`\n+  --> $DIR/issue-77910-1.rs:8:5\n+   |\n+LL |     assert_eq!(foo, y);\n+   |     ^^^^^^^^^^^^^^^^^^^ `for<'r> fn(&'r i32) -> &'r i32 {foo}` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   |\n+   = help: the trait `Debug` is not implemented for `for<'r> fn(&'r i32) -> &'r i32 {foo}`\n+   = note: required because of the requirements on the impl of `Debug` for `&for<'r> fn(&'r i32) -> &'r i32 {foo}`\n+   = note: required by `std::fmt::Debug::fmt`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0277, E0369.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "2bb48d3657617df7f6fee9e21aed428d8f69f541", "filename": "src/test/ui/binop/issue-77910-2.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,9 @@\n+fn foo(s: &i32) -> &i32 {\n+    let xs;\n+    xs\n+}\n+fn main() {\n+    let y;\n+    if foo == y {}\n+    //~^ ERROR binary operation `==` cannot be applied to type\n+}"}, {"sha": "5477a5762a8fd0fc424ff3fbb5ffd11605c1d175", "filename": "src/test/ui/binop/issue-77910-2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,11 @@\n+error[E0369]: binary operation `==` cannot be applied to type `for<'r> fn(&'r i32) -> &'r i32 {foo}`\n+  --> $DIR/issue-77910-2.rs:7:12\n+   |\n+LL |     if foo == y {}\n+   |        --- ^^ - _\n+   |        |\n+   |        for<'r> fn(&'r i32) -> &'r i32 {foo}\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "b65e50eb9f4199465241d38648c7fbf34c95d0f0", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static_cross_crate.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static_cross_crate.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -146,6 +146,11 @@ help: skipping check that does not even have a feature gate\n    |\n LL |     unsafe { match static_cross_crate::OPT_ZERO { Some(ref u) => u, None => panic!() } }\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: skipping check that does not even have a feature gate\n+  --> $DIR/const_refers_to_static_cross_crate.rs:32:20\n+   |\n+LL |     unsafe { match static_cross_crate::OPT_ZERO { Some(ref u) => u, None => panic!() } }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: skipping check for `const_panic` feature\n   --> $DIR/const_refers_to_static_cross_crate.rs:32:77\n    |"}, {"sha": "58ed3c2c7227fd1f96647e2fd51cd7eb87a4d5bb", "filename": "src/test/ui/error-codes/E0396.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Ferror-codes%2FE0396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Ferror-codes%2FE0396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0396.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -5,5 +5,16 @@ const REG_ADDR: *const u8 = 0x5f3759df as *const u8;\n const VALUE: u8 = unsafe { *REG_ADDR };\n //~^ ERROR dereferencing raw pointers in constants is unstable\n \n+const unsafe fn unreachable() -> ! {\n+    use std::convert::Infallible;\n+\n+    const INFALLIBLE: *const Infallible = [].as_ptr();\n+    match *INFALLIBLE {}\n+    //~^ ERROR dereferencing raw pointers in constant functions is unstable\n+\n+    const BAD: () = unsafe { match *INFALLIBLE {} };\n+    //~^ ERROR dereferencing raw pointers in constants is unstable\n+}\n+\n fn main() {\n }"}, {"sha": "20dad1b983c1c917d02193df92ac5e1b7905e877", "filename": "src/test/ui/error-codes/E0396.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Ferror-codes%2FE0396.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Ferror-codes%2FE0396.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0396.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -7,6 +7,24 @@ LL | const VALUE: u8 = unsafe { *REG_ADDR };\n    = note: see issue #51911 <https://github.com/rust-lang/rust/issues/51911> for more information\n    = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n \n-error: aborting due to previous error\n+error[E0658]: dereferencing raw pointers in constant functions is unstable\n+  --> $DIR/E0396.rs:12:11\n+   |\n+LL |     match *INFALLIBLE {}\n+   |           ^^^^^^^^^^^\n+   |\n+   = note: see issue #51911 <https://github.com/rust-lang/rust/issues/51911> for more information\n+   = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n+\n+error[E0658]: dereferencing raw pointers in constants is unstable\n+  --> $DIR/E0396.rs:15:36\n+   |\n+LL |     const BAD: () = unsafe { match *INFALLIBLE {} };\n+   |                                    ^^^^^^^^^^^\n+   |\n+   = note: see issue #51911 <https://github.com/rust-lang/rust/issues/51911> for more information\n+   = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "949b23600715a7f9a980d88cb3f60b505efe30d1", "filename": "src/test/ui/suggestions/impl-trait-with-missing-bounds.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -39,6 +39,14 @@ fn bak(constraints: impl  Iterator + std::fmt::Debug) {\n     }\n }\n \n+#[rustfmt::skip]\n+fn baw<>(constraints: impl Iterator) {\n+    for constraint in constraints {\n+        qux(constraint);\n+//~^ ERROR `<impl Iterator as Iterator>::Item` doesn't implement `Debug`\n+    }\n+}\n+\n fn qux(_: impl std::fmt::Debug) {}\n \n fn main() {}"}, {"sha": "0de3b9aec19e1aeca8775a916c5bfdd962f878d7", "filename": "src/test/ui/suggestions/impl-trait-with-missing-bounds.stderr", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-with-missing-bounds.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -73,6 +73,21 @@ help: introduce a type parameter with a trait bound instead of using `impl Trait\n LL | fn bak<I: Iterator + std::fmt::Debug>(constraints: I) where <I as Iterator>::Item: Debug {\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^              ^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 5 previous errors\n+error[E0277]: `<impl Iterator as Iterator>::Item` doesn't implement `Debug`\n+  --> $DIR/impl-trait-with-missing-bounds.rs:45:13\n+   |\n+LL |         qux(constraint);\n+   |             ^^^^^^^^^^ `<impl Iterator as Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+...\n+LL | fn qux(_: impl std::fmt::Debug) {}\n+   |                --------------- required by this bound in `qux`\n+   |\n+   = help: the trait `Debug` is not implemented for `<impl Iterator as Iterator>::Item`\n+help: introduce a type parameter with a trait bound instead of using `impl Trait`\n+   |\n+LL | fn baw<I: Iterator>(constraints: I) where <I as Iterator>::Item: Debug {\n+   |       ^^^^^^^^^^^^^              ^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "3cd6d336e13456ec8ff25b26b1752e9ab6544eaf", "filename": "src/test/ui/suggestions/issue-79843-impl-trait-with-missing-bounds-on-async-fn.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fsuggestions%2Fissue-79843-impl-trait-with-missing-bounds-on-async-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fsuggestions%2Fissue-79843-impl-trait-with-missing-bounds-on-async-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-79843-impl-trait-with-missing-bounds-on-async-fn.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,32 @@\n+// Regression test: if we suggest replacing an `impl Trait` argument to an async\n+// fn with a named type parameter in order to add bounds, the suggested function\n+// signature should be well-formed.\n+//\n+// edition:2018\n+\n+trait Foo {\n+    type Bar;\n+    fn bar(&self) -> Self::Bar;\n+}\n+\n+async fn run(_: &(), foo: impl Foo) -> std::io::Result<()> {\n+    let bar = foo.bar();\n+    assert_is_send(&bar);\n+//~^ ERROR: `<impl Foo as Foo>::Bar` cannot be sent between threads safely\n+\n+    Ok(())\n+}\n+\n+// Test our handling of cases where there is a generic parameter list in the\n+// source, but only synthetic generic parameters\n+async fn run2< >(_: &(), foo: impl Foo) -> std::io::Result<()> {\n+    let bar = foo.bar();\n+    assert_is_send(&bar);\n+//~^ ERROR: `<impl Foo as Foo>::Bar` cannot be sent between threads safely\n+\n+    Ok(())\n+}\n+\n+fn assert_is_send<T: Send>(_: &T) {}\n+\n+fn main() {}"}, {"sha": "9404c3bb583172fa2b9d0170b904ca34a09106cd", "filename": "src/test/ui/suggestions/issue-79843-impl-trait-with-missing-bounds-on-async-fn.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fsuggestions%2Fissue-79843-impl-trait-with-missing-bounds-on-async-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftest%2Fui%2Fsuggestions%2Fissue-79843-impl-trait-with-missing-bounds-on-async-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-79843-impl-trait-with-missing-bounds-on-async-fn.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,33 @@\n+error[E0277]: `<impl Foo as Foo>::Bar` cannot be sent between threads safely\n+  --> $DIR/issue-79843-impl-trait-with-missing-bounds-on-async-fn.rs:14:20\n+   |\n+LL |     assert_is_send(&bar);\n+   |                    ^^^^ `<impl Foo as Foo>::Bar` cannot be sent between threads safely\n+...\n+LL | fn assert_is_send<T: Send>(_: &T) {}\n+   |                      ---- required by this bound in `assert_is_send`\n+   |\n+   = help: the trait `Send` is not implemented for `<impl Foo as Foo>::Bar`\n+help: introduce a type parameter with a trait bound instead of using `impl Trait`\n+   |\n+LL | async fn run<F: Foo>(_: &(), foo: F) -> std::io::Result<()> where <F as Foo>::Bar: Send {\n+   |             ^^^^^^^^              ^                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `<impl Foo as Foo>::Bar` cannot be sent between threads safely\n+  --> $DIR/issue-79843-impl-trait-with-missing-bounds-on-async-fn.rs:24:20\n+   |\n+LL |     assert_is_send(&bar);\n+   |                    ^^^^ `<impl Foo as Foo>::Bar` cannot be sent between threads safely\n+...\n+LL | fn assert_is_send<T: Send>(_: &T) {}\n+   |                      ---- required by this bound in `assert_is_send`\n+   |\n+   = help: the trait `Send` is not implemented for `<impl Foo as Foo>::Bar`\n+help: introduce a type parameter with a trait bound instead of using `impl Trait`\n+   |\n+LL | async fn run2<F: Foo>(_: &(), foo: F) -> std::io::Result<()> where <F as Foo>::Bar: Send {\n+   |              ^^^^^^^^              ^                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "530e60001f726b1a7525c42c667aa4b0684b4faf", "filename": "src/tools/clippy/.github/workflows/clippy.yml", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy.yml?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -35,29 +35,11 @@ jobs:\n       with:\n         github_token: \"${{ secrets.github_token }}\"\n \n-    - name: rust-toolchain\n-      uses: actions-rs/toolchain@v1.0.6\n-      with:\n-        toolchain: nightly\n-        target: x86_64-unknown-linux-gnu\n-        profile: minimal\n-\n     - name: Checkout\n       uses: actions/checkout@v2.3.3\n \n-    - name: Run cargo update\n-      run: cargo update\n-\n-    - name: Cache cargo dir\n-      uses: actions/cache@v2\n-      with:\n-        path: ~/.cargo\n-        key: ${{ runner.os }}-x86_64-unknown-linux-gnu-${{ hashFiles('Cargo.lock') }}\n-        restore-keys: |\n-          ${{ runner.os }}-x86_64-unknown-linux-gnu\n-\n-    - name: Master Toolchain Setup\n-      run: bash setup-toolchain.sh\n+    - name: Install toolchain\n+      run: rustup show active-toolchain\n \n     # Run\n     - name: Set LD_LIBRARY_PATH (Linux)\n@@ -66,13 +48,13 @@ jobs:\n         echo \"LD_LIBRARY_PATH=${SYSROOT}/lib${LD_LIBRARY_PATH+:${LD_LIBRARY_PATH}}\" >> $GITHUB_ENV\n \n     - name: Build\n-      run: cargo build --features deny-warnings\n+      run: cargo build --features deny-warnings,internal-lints\n \n     - name: Test\n-      run: cargo test --features deny-warnings\n+      run: cargo test --features deny-warnings,internal-lints\n \n     - name: Test clippy_lints\n-      run: cargo test --features deny-warnings\n+      run: cargo test --features deny-warnings,internal-lints\n       working-directory: clippy_lints\n \n     - name: Test rustc_tools_util\n@@ -98,9 +80,3 @@ jobs:\n         cargo dev new_lint --name new_late_pass --pass late\n         cargo check\n         git reset --hard HEAD\n-\n-    # Cleanup\n-    - name: Run cargo-cache --autoclean\n-      run: |\n-        cargo +nightly install cargo-cache --no-default-features --features ci-autoclean cargo-cache\n-        cargo cache"}, {"sha": "5d846eb64c78e5c0f78d72e682a961605879f928", "filename": "src/tools/clippy/.github/workflows/clippy_bors.yml", "status": "modified", "additions": 13, "deletions": 84, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -23,6 +23,7 @@ jobs:\n     - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n       with:\n         github_token: \"${{ secrets.github_token }}\"\n+\n     - name: Checkout\n       uses: actions/checkout@v2.3.3\n       with:\n@@ -84,31 +85,11 @@ jobs:\n         sudo apt-get install gcc-multilib libssl-dev:i386 libgit2-dev:i386\n       if: matrix.host == 'i686-unknown-linux-gnu'\n \n-    - name: rust-toolchain\n-      uses: actions-rs/toolchain@v1.0.6\n-      with:\n-        toolchain: nightly\n-        target: ${{ matrix.host }}\n-        profile: minimal\n-\n     - name: Checkout\n       uses: actions/checkout@v2.3.3\n \n-    - name: Run cargo update\n-      run: cargo update\n-\n-    - name: Cache cargo dir\n-      uses: actions/cache@v2\n-      with:\n-        path: ~/.cargo\n-        key: ${{ runner.os }}-${{ matrix.host }}-${{ hashFiles('Cargo.lock') }}\n-        restore-keys: |\n-          ${{ runner.os }}-${{ matrix.host }}\n-\n-    - name: Master Toolchain Setup\n-      run: bash setup-toolchain.sh\n-      env:\n-        HOST_TOOLCHAIN: ${{ matrix.host }}\n+    - name: Install toolchain\n+      run: rustup show active-toolchain\n \n     # Run\n     - name: Set LD_LIBRARY_PATH (Linux)\n@@ -128,13 +109,13 @@ jobs:\n         SYSROOT=$(rustc --print sysroot)\n         echo \"$SYSROOT/bin\" >> $GITHUB_PATH\n \n-    - name: Build with internal lints\n+    - name: Build\n       run: cargo build --features deny-warnings,internal-lints\n \n-    - name: Test with internal lints\n+    - name: Test\n       run: cargo test --features deny-warnings,internal-lints\n \n-    - name: Test clippy_lints with internal lints\n+    - name: Test clippy_lints\n       run: cargo test --features deny-warnings,internal-lints\n       working-directory: clippy_lints\n \n@@ -155,12 +136,6 @@ jobs:\n       env:\n         OS: ${{ runner.os }}\n \n-    # Cleanup\n-    - name: Run cargo-cache --autoclean\n-      run: |\n-        cargo +nightly install cargo-cache --no-default-features --features ci-autoclean cargo-cache\n-        cargo cache\n-\n   integration_build:\n     needs: changelog\n     runs-on: ubuntu-latest\n@@ -171,29 +146,11 @@ jobs:\n       with:\n         github_token: \"${{ secrets.github_token }}\"\n \n-    - name: rust-toolchain\n-      uses: actions-rs/toolchain@v1.0.6\n-      with:\n-        toolchain: nightly\n-        target: x86_64-unknown-linux-gnu\n-        profile: minimal\n-\n     - name: Checkout\n       uses: actions/checkout@v2.3.3\n \n-    - name: Run cargo update\n-      run: cargo update\n-\n-    - name: Cache cargo dir\n-      uses: actions/cache@v2\n-      with:\n-        path: ~/.cargo\n-        key: ${{ runner.os }}-x86_64-unknown-linux-gnu-${{ hashFiles('Cargo.lock') }}\n-        restore-keys: |\n-          ${{ runner.os }}-x86_64-unknown-linux-gnu\n-\n-    - name: Master Toolchain Setup\n-      run: bash setup-toolchain.sh\n+    - name: Install toolchain\n+      run: rustup show active-toolchain\n \n     # Run\n     - name: Build Integration Test\n@@ -214,11 +171,6 @@ jobs:\n         name: target\n         path: target\n \n-    # Cleanup\n-    - name: Run cargo-cache --autoclean\n-      run: |\n-        cargo +nightly install cargo-cache --no-default-features --features ci-autoclean cargo-cache\n-        cargo cache\n   integration:\n     needs: integration_build\n     strategy:\n@@ -252,29 +204,11 @@ jobs:\n       with:\n         github_token: \"${{ secrets.github_token }}\"\n \n-    - name: rust-toolchain\n-      uses: actions-rs/toolchain@v1.0.6\n-      with:\n-        toolchain: nightly\n-        target: x86_64-unknown-linux-gnu\n-        profile: minimal\n-\n     - name: Checkout\n       uses: actions/checkout@v2.3.3\n \n-    - name: Run cargo update\n-      run: cargo update\n-\n-    - name: Cache cargo dir\n-      uses: actions/cache@v2\n-      with:\n-        path: ~/.cargo\n-        key: ${{ runner.os }}-x86_64-unknown-linux-gnu-${{ hashFiles('Cargo.lock') }}\n-        restore-keys: |\n-          ${{ runner.os }}-x86_64-unknown-linux-gnu\n-\n-    - name: Master Toolchain Setup\n-      run: bash setup-toolchain.sh\n+    - name: Install toolchain\n+      run: rustup show active-toolchain\n \n     # Download\n     - name: Download target dir\n@@ -288,16 +222,11 @@ jobs:\n \n     # Run\n     - name: Test ${{ matrix.integration }}\n-      run: $CARGO_TARGET_DIR/debug/integration\n+      run: |\n+        RUSTUP_TOOLCHAIN=\"$(rustup show active-toolchain | grep -o -E \"nightly-[0-9]{4}-[0-9]{2}-[0-9]{2}\")\" \\\n+          $CARGO_TARGET_DIR/debug/integration\n       env:\n         INTEGRATION: ${{ matrix.integration }}\n-        RUSTUP_TOOLCHAIN: master\n-\n-    # Cleanup\n-    - name: Run cargo-cache --autoclean\n-      run: |\n-        cargo +nightly install cargo-cache --no-default-features --features ci-autoclean cargo-cache\n-        cargo cache\n \n   # These jobs doesn't actually test anything, but they're only used to tell\n   # bors the build completed, as there is no practical way to detect when a"}, {"sha": "95da775b7bc360ce4fcdb59e6fbb6a3935aa4766", "filename": "src/tools/clippy/.github/workflows/clippy_dev.yml", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_dev.yml?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -22,16 +22,20 @@ jobs:\n \n     steps:\n     # Setup\n+    - name: Checkout\n+      uses: actions/checkout@v2.3.3\n+\n+    - name: remove toolchain file\n+      run: rm rust-toolchain\n+\n     - name: rust-toolchain\n       uses: actions-rs/toolchain@v1.0.6\n       with:\n         toolchain: nightly\n         target: x86_64-unknown-linux-gnu\n         profile: minimal\n         components: rustfmt\n-\n-    - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+        default: true\n \n     # Run\n     - name: Build"}, {"sha": "af3b1c1db2aedb79bcb117754f4e1f82fb4d2298", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -2006,6 +2006,7 @@ Released 2018-09-13\n [`possible_missing_comma`]: https://rust-lang.github.io/rust-clippy/master/index.html#possible_missing_comma\n [`precedence`]: https://rust-lang.github.io/rust-clippy/master/index.html#precedence\n [`print_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_literal\n+[`print_stderr`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_stderr\n [`print_stdout`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_stdout\n [`print_with_newline`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_with_newline\n [`println_empty_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#println_empty_string\n@@ -2024,6 +2025,7 @@ Released 2018-09-13\n [`redundant_closure`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure\n [`redundant_closure_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure_call\n [`redundant_closure_for_method_calls`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure_for_method_calls\n+[`redundant_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_else\n [`redundant_field_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names\n [`redundant_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern\n [`redundant_pattern_matching`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_pattern_matching\n@@ -2169,5 +2171,6 @@ Released 2018-09-13\n [`zero_divided_by_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_divided_by_zero\n [`zero_prefixed_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_prefixed_literal\n [`zero_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_ptr\n+[`zero_sized_map_values`]: https://rust-lang.github.io/rust-clippy/master/index.html#zero_sized_map_values\n [`zst_offset`]: https://rust-lang.github.io/rust-clippy/master/index.html#zst_offset\n <!-- end autogenerated links to lint list -->"}, {"sha": "4cfeaa153a01b922dcc3c352e68a4ebeb8ab1291", "filename": "src/tools/clippy/CONTRIBUTING.md", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCONTRIBUTING.md?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -19,10 +19,10 @@ All contributors are expected to follow the [Rust Code of Conduct].\n   - [Writing code](#writing-code)\n   - [Getting code-completion for rustc internals to work](#getting-code-completion-for-rustc-internals-to-work)\n   - [How Clippy works](#how-clippy-works)\n-  - [Fixing build failures caused by Rust](#fixing-build-failures-caused-by-rust)\n+  - [Syncing changes between Clippy and `rust-lang/rust`](#syncing-changes-between-clippy-and-rust-langrust)\n     - [Patching git-subtree to work with big repos](#patching-git-subtree-to-work-with-big-repos)\n-    - [Performing the sync](#performing-the-sync)\n-    - [Syncing back changes in Clippy to [`rust-lang/rust`]](#syncing-back-changes-in-clippy-to-rust-langrust)\n+    - [Performing the sync from `rust-lang/rust` to Clippy](#performing-the-sync-from-rust-langrust-to-clippy)\n+    - [Performing the sync from Clippy to `rust-lang/rust`](#performing-the-sync-from-clippy-to-rust-langrust)\n     - [Defining remotes](#defining-remotes)\n   - [Issue and PR triage](#issue-and-pr-triage)\n   - [Bors and Homu](#bors-and-homu)\n@@ -49,7 +49,7 @@ first read the [Basics docs](doc/basics.md).**\n All issues on Clippy are mentored, if you want help with a bug just ask\n @Manishearth, @flip1995, @phansch or @yaahc.\n \n-Some issues are easier than others. The [`good first issue`] label can be used to find the easy issues.\n+Some issues are easier than others. The [`good-first-issue`] label can be used to find the easy issues.\n If you want to work on an issue, please leave a comment so that we can assign it to you!\n \n There are also some abandoned PRs, marked with [`S-inactive-closed`].\n@@ -68,16 +68,16 @@ To figure out how this syntax structure is encoded in the AST, it is recommended\n Usually the lint will end up to be a nested series of matches and ifs, [like so][deep-nesting].\n But we can make it nest-less by using [if_chain] macro, [like this][nest-less].\n \n-[`E-medium`] issues are generally pretty easy too, though it's recommended you work on an [`good first issue`]\n+[`E-medium`] issues are generally pretty easy too, though it's recommended you work on an [`good-first-issue`]\n first. Sometimes they are only somewhat involved code wise, but not difficult per-se.\n-Note that [`E-medium`] issues may require some knowledge of Clippy internals or some \n-debugging to find the actual problem behind the issue. \n+Note that [`E-medium`] issues may require some knowledge of Clippy internals or some\n+debugging to find the actual problem behind the issue.\n \n [`T-middle`] issues can be more involved and require verifying types. The [`ty`] module contains a\n lot of methods that are useful, though one of the most useful would be `expr_ty` (gives the type of\n an AST expression). `match_def_path()` in Clippy's `utils` module can also be useful.\n \n-[`good first issue`]: https://github.com/rust-lang/rust-clippy/labels/good%20first%20issue\n+[`good-first-issue`]: https://github.com/rust-lang/rust-clippy/labels/good-first-issue\n [`S-inactive-closed`]: https://github.com/rust-lang/rust-clippy/pulls?q=is%3Aclosed+label%3AS-inactive-closed\n [`T-AST`]: https://github.com/rust-lang/rust-clippy/labels/T-AST\n [`T-middle`]: https://github.com/rust-lang/rust-clippy/labels/T-middle\n@@ -111,7 +111,7 @@ To work around this, you need to have a copy of the [rustc-repo][rustc_repo] ava\n `git clone https://github.com/rust-lang/rust/`.\n Then you can run a `cargo dev` command to automatically make Clippy use the rustc-repo via path-dependencies\n which rust-analyzer will be able to understand.\n-Run `cargo dev ra-setup --repo-path <repo-path>` where `<repo-path>` is an absolute path to the rustc repo\n+Run `cargo dev ra_setup --repo-path <repo-path>` where `<repo-path>` is an absolute path to the rustc repo\n you just cloned.\n The command will add path-dependencies pointing towards rustc-crates inside the rustc repo to\n Clippys `Cargo.toml`s and should allow rust-analyzer to understand most of the types that Clippy uses.\n@@ -182,18 +182,26 @@ That's why the `else_if_without_else` example uses the `register_early_pass` fun\n [early_lint_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html\n [late_lint_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html\n \n-## Fixing build failures caused by Rust\n+## Syncing changes between Clippy and [`rust-lang/rust`]\n \n-Clippy currently gets built with `rustc` of the `rust-lang/rust` `master`\n-branch. Most of the times we have to adapt to the changes and only very rarely\n-there's an actual bug in Rust.\n+Clippy currently gets built with a pinned nightly version.\n \n-If you decide to make Clippy work again with a Rust commit that breaks it, you\n-have to sync the `rust-lang/rust-clippy` repository with the `subtree` copy of\n-Clippy in the `rust-lang/rust` repository.\n+In the `rust-lang/rust` repository, where rustc resides, there's a copy of Clippy\n+that compiler hackers modify from time to time to adapt to changes in the unstable\n+API of the compiler.\n \n-For general information about `subtree`s in the Rust repository see [Rust's\n-`CONTRIBUTING.md`][subtree].\n+We need to sync these changes back to this repository periodically, and the changes\n+made to this repository in the meantime also need to be synced to the `rust-lang/rust` repository.\n+\n+To avoid flooding the `rust-lang/rust` PR queue, this two-way sync process is done\n+in a bi-weekly basis if there's no urgent changes. This is done starting on the day of\n+the Rust stable release and then every other week. That way we guarantee that we keep\n+this repo up to date with the latest compiler API, and every feature in Clippy is available\n+for 2 weeks in nightly, before it can get to beta. For reference, the first sync\n+following this cadence was performed the 2020-08-27.\n+\n+This process is described in detail in the following sections. For general information\n+about `subtree`s in the Rust repository see [Rust's `CONTRIBUTING.md`][subtree].\n \n ### Patching git-subtree to work with big repos\n \n@@ -222,13 +230,14 @@ This shell has a hardcoded recursion limit set to 1000. In order to make this pr\n you need to force the script to run `bash` instead. You can do this by editing the first\n line of the `git-subtree` script and changing `sh` to `bash`.\n \n-### Performing the sync\n+### Performing the sync from [`rust-lang/rust`] to Clippy\n \n Here is a TL;DR version of the sync process (all of the following commands have\n to be run inside the `rust` directory):\n \n-1. Clone the [`rust-lang/rust`] repository\n-2. Sync the changes to the rust-copy of Clippy to your Clippy fork:\n+1. Clone the [`rust-lang/rust`] repository or make sure it is up to date.\n+2. Checkout the commit from the latest available nightly. You can get it using `rustup check`.\n+3. Sync the changes to the rust-copy of Clippy to your Clippy fork:\n     ```bash\n     # Make sure to change `your-github-name` to your github name in the following command\n     git subtree push -P src/tools/clippy git@github.com:your-github-name/rust-clippy sync-from-rust\n@@ -246,17 +255,11 @@ to be run inside the `rust` directory):\n     git checkout sync-from-rust\n     git merge upstream/master\n     ```\n-3. Open a PR to `rust-lang/rust-clippy` and wait for it to get merged (to\n+4. Open a PR to `rust-lang/rust-clippy` and wait for it to get merged (to\n    accelerate the process ping the `@rust-lang/clippy` team in your PR and/or\n    ~~annoy~~ ask them in the [Zulip] stream.)\n-   \n-### Syncing back changes in Clippy to [`rust-lang/rust`]\n \n-To avoid flooding the [`rust-lang/rust`] PR queue, changes in Clippy's repo are synced back\n-in a bi-weekly basis if there's no urgent changes. This is done starting on the day of\n-the Rust stable release and then every other week. That way we guarantee that\n-every feature in Clippy is available for 2 weeks in nightly, before it can get to beta.\n-For reference, the first sync following this cadence was performed the 2020-08-27.\n+### Performing the sync from Clippy to [`rust-lang/rust`]\n \n All of the following commands have to be run inside the `rust` directory.\n "}, {"sha": "7f9d22e594b9c0f4af731ae72e91219b85bd819e", "filename": "src/tools/clippy/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCargo.toml?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -20,7 +20,6 @@ publish = false\n \n [[bin]]\n name = \"cargo-clippy\"\n-test = false\n path = \"src/main.rs\"\n \n [[bin]]"}, {"sha": "dc931963726b26723495db2c50a8e6bad75c7e64", "filename": "src/tools/clippy/README.md", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FREADME.md?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -82,6 +82,22 @@ Note that this is still experimental and only supported on the nightly channel:\n cargo clippy --fix -Z unstable-options\n ```\n \n+#### Workspaces\n+\n+All the usual workspace options should work with Clippy. For example the following command\n+will run Clippy on the `example` crate:\n+\n+```terminal\n+cargo clippy -p example\n+```\n+\n+As with `cargo check`, this includes dependencies that are members of the workspace, like path dependencies.\n+If you want to run Clippy **only** on the given crate, use the `--no-deps` option like this:\n+\n+```terminal\n+cargo clippy -p example -- --no-deps \n+```\n+\n ### Running Clippy from the command line without installing it\n \n To have cargo compile your crate with Clippy without Clippy installation\n@@ -192,7 +208,6 @@ the lint(s) you are interested in:\n ```terminal\n cargo clippy -- -A clippy::all -W clippy::useless_format -W clippy::...\n ```\n-Note that if you've run clippy before, this may only take effect after you've modified a file or ran `cargo clean`.\n \n ### Specifying the minimum supported Rust version\n "}, {"sha": "645098e4cfcd2703c2e6db29522257b637825033", "filename": "src/tools/clippy/clippy_dev/src/bless.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,74 @@\n+//! `bless` updates the reference files in the repo with changed output files\n+//! from the last test run.\n+\n+use std::env;\n+use std::ffi::OsStr;\n+use std::fs;\n+use std::lazy::SyncLazy;\n+use std::path::PathBuf;\n+use walkdir::WalkDir;\n+\n+use crate::clippy_project_root;\n+\n+// NOTE: this is duplicated with tests/cargo/mod.rs What to do?\n+pub static CARGO_TARGET_DIR: SyncLazy<PathBuf> = SyncLazy::new(|| match env::var_os(\"CARGO_TARGET_DIR\") {\n+    Some(v) => v.into(),\n+    None => env::current_dir().unwrap().join(\"target\"),\n+});\n+\n+pub fn bless() {\n+    let test_dirs = [\n+        clippy_project_root().join(\"tests\").join(\"ui\"),\n+        clippy_project_root().join(\"tests\").join(\"ui-toml\"),\n+        clippy_project_root().join(\"tests\").join(\"ui-cargo\"),\n+    ];\n+    for test_dir in &test_dirs {\n+        WalkDir::new(test_dir)\n+            .into_iter()\n+            .filter_map(Result::ok)\n+            .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n+            .for_each(|f| {\n+                update_reference_file(f.path().with_extension(\"stdout\"));\n+                update_reference_file(f.path().with_extension(\"stderr\"));\n+                update_reference_file(f.path().with_extension(\"fixed\"));\n+            });\n+    }\n+}\n+\n+fn update_reference_file(reference_file_path: PathBuf) {\n+    let test_output_path = build_dir().join(PathBuf::from(reference_file_path.file_name().unwrap()));\n+    let relative_reference_file_path = reference_file_path.strip_prefix(clippy_project_root()).unwrap();\n+\n+    // If compiletest did not write any changes during the test run,\n+    // we don't have to update anything\n+    if !test_output_path.exists() {\n+        return;\n+    }\n+\n+    let test_output_file = fs::read(&test_output_path).expect(\"Unable to read test output file\");\n+    let reference_file = fs::read(&reference_file_path).unwrap_or_default();\n+\n+    if test_output_file != reference_file {\n+        // If a test run caused an output file to change, update the reference file\n+        println!(\"updating {}\", &relative_reference_file_path.display());\n+        fs::copy(test_output_path, &reference_file_path).expect(\"Could not update reference file\");\n+\n+        // We need to re-read the file now because it was potentially updated from copying\n+        let reference_file = fs::read(&reference_file_path).unwrap_or_default();\n+\n+        if reference_file.is_empty() {\n+            // If we copied over an empty output file, we remove the now empty reference file\n+            println!(\"removing {}\", &relative_reference_file_path.display());\n+            fs::remove_file(reference_file_path).expect(\"Could not remove reference file\");\n+        }\n+    }\n+}\n+\n+fn build_dir() -> PathBuf {\n+    let profile = env::var(\"PROFILE\").unwrap_or_else(|_| \"debug\".to_string());\n+    let mut path = PathBuf::new();\n+    path.push(CARGO_TARGET_DIR.clone());\n+    path.push(profile);\n+    path.push(\"test_build_base\");\n+    path\n+}"}, {"sha": "6b528d219df27d62a37f859f0900f3f6402b2b58", "filename": "src/tools/clippy/clippy_dev/src/fmt.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Ffmt.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,9 +1,9 @@\n use crate::clippy_project_root;\n use shell_escape::escape;\n use std::ffi::OsStr;\n-use std::io;\n use std::path::Path;\n use std::process::{self, Command};\n+use std::{fs, io};\n use walkdir::WalkDir;\n \n #[derive(Debug)]\n@@ -12,6 +12,7 @@ pub enum CliError {\n     IoError(io::Error),\n     RustfmtNotInstalled,\n     WalkDirError(walkdir::Error),\n+    RaSetupActive,\n }\n \n impl From<io::Error> for CliError {\n@@ -31,12 +32,23 @@ struct FmtContext {\n     verbose: bool,\n }\n \n+// the \"main\" function of cargo dev fmt\n pub fn run(check: bool, verbose: bool) {\n     fn try_run(context: &FmtContext) -> Result<bool, CliError> {\n         let mut success = true;\n \n         let project_root = clippy_project_root();\n \n+        // if we added a local rustc repo as path dependency to clippy for rust analyzer, we do NOT want to\n+        // format because rustfmt would also format the entire rustc repo as it is a local\n+        // dependency\n+        if fs::read_to_string(project_root.join(\"Cargo.toml\"))\n+            .expect(\"Failed to read clippy Cargo.toml\")\n+            .contains(&\"[target.'cfg(NOT_A_PLATFORM)'.dependencies]\")\n+        {\n+            return Err(CliError::RaSetupActive);\n+        }\n+\n         rustfmt_test(context)?;\n \n         success &= cargo_fmt(context, project_root.as_path())?;\n@@ -75,6 +87,13 @@ pub fn run(check: bool, verbose: bool) {\n             CliError::WalkDirError(err) => {\n                 eprintln!(\"error: {}\", err);\n             },\n+            CliError::RaSetupActive => {\n+                eprintln!(\n+                    \"error: a local rustc repo is enabled as path dependency via `cargo dev ra_setup`.\n+Not formatting because that would format the local repo as well!\n+Please revert the changes to Cargo.tomls first.\"\n+                );\n+            },\n         }\n     }\n "}, {"sha": "17cc08ee10fea312f5b3d392991f61326be4f362", "filename": "src/tools/clippy/clippy_dev/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -10,6 +10,7 @@ use std::lazy::SyncLazy;\n use std::path::{Path, PathBuf};\n use walkdir::WalkDir;\n \n+pub mod bless;\n pub mod fmt;\n pub mod new_lint;\n pub mod ra_setup;"}, {"sha": "4fdae38e3ab7a409f5cf7ca8c8fbbc3e27038b57", "filename": "src/tools/clippy/clippy_dev/src/main.rs", "status": "modified", "additions": 55, "deletions": 47, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,10 +1,53 @@\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n \n-use clap::{App, Arg, SubCommand};\n-use clippy_dev::{fmt, new_lint, ra_setup, serve, stderr_length_check, update_lints};\n+use clap::{App, Arg, ArgMatches, SubCommand};\n+use clippy_dev::{bless, fmt, new_lint, ra_setup, serve, stderr_length_check, update_lints};\n \n fn main() {\n-    let matches = App::new(\"Clippy developer tooling\")\n+    let matches = get_clap_config();\n+\n+    match matches.subcommand() {\n+        (\"bless\", Some(_)) => {\n+            bless::bless();\n+        },\n+        (\"fmt\", Some(matches)) => {\n+            fmt::run(matches.is_present(\"check\"), matches.is_present(\"verbose\"));\n+        },\n+        (\"update_lints\", Some(matches)) => {\n+            if matches.is_present(\"print-only\") {\n+                update_lints::print_lints();\n+            } else if matches.is_present(\"check\") {\n+                update_lints::run(update_lints::UpdateMode::Check);\n+            } else {\n+                update_lints::run(update_lints::UpdateMode::Change);\n+            }\n+        },\n+        (\"new_lint\", Some(matches)) => {\n+            match new_lint::create(\n+                matches.value_of(\"pass\"),\n+                matches.value_of(\"name\"),\n+                matches.value_of(\"category\"),\n+            ) {\n+                Ok(_) => update_lints::run(update_lints::UpdateMode::Change),\n+                Err(e) => eprintln!(\"Unable to create lint: {}\", e),\n+            }\n+        },\n+        (\"limit_stderr_length\", _) => {\n+            stderr_length_check::check();\n+        },\n+        (\"ra_setup\", Some(matches)) => ra_setup::run(matches.value_of(\"rustc-repo-path\")),\n+        (\"serve\", Some(matches)) => {\n+            let port = matches.value_of(\"port\").unwrap().parse().unwrap();\n+            let lint = matches.value_of(\"lint\");\n+            serve::run(port, lint);\n+        },\n+        _ => {},\n+    }\n+}\n+\n+fn get_clap_config<'a>() -> ArgMatches<'a> {\n+    App::new(\"Clippy developer tooling\")\n+        .subcommand(SubCommand::with_name(\"bless\").about(\"bless the test output changes\"))\n         .subcommand(\n             SubCommand::with_name(\"fmt\")\n                 .about(\"Run rustfmt on all projects and tests\")\n@@ -25,16 +68,16 @@ fn main() {\n                 .about(\"Updates lint registration and information from the source code\")\n                 .long_about(\n                     \"Makes sure that:\\n \\\n-                     * the lint count in README.md is correct\\n \\\n-                     * the changelog contains markdown link references at the bottom\\n \\\n-                     * all lint groups include the correct lints\\n \\\n-                     * lint modules in `clippy_lints/*` are visible in `src/lib.rs` via `pub mod`\\n \\\n-                     * all lints are registered in the lint store\",\n+                 * the lint count in README.md is correct\\n \\\n+                 * the changelog contains markdown link references at the bottom\\n \\\n+                 * all lint groups include the correct lints\\n \\\n+                 * lint modules in `clippy_lints/*` are visible in `src/lifb.rs` via `pub mod`\\n \\\n+                 * all lints are registered in the lint store\",\n                 )\n                 .arg(Arg::with_name(\"print-only\").long(\"print-only\").help(\n                     \"Print a table of lints to STDOUT. \\\n-                     This does not include deprecated and internal lints. \\\n-                     (Does not modify any files)\",\n+                 This does not include deprecated and internal lints. \\\n+                 (Does not modify any files)\",\n                 ))\n                 .arg(\n                     Arg::with_name(\"check\")\n@@ -88,7 +131,7 @@ fn main() {\n                 .about(\"Ensures that stderr files do not grow longer than a certain amount of lines.\"),\n         )\n         .subcommand(\n-            SubCommand::with_name(\"ra-setup\")\n+            SubCommand::with_name(\"ra_setup\")\n                 .about(\"Alter dependencies so rust-analyzer can find rustc internals\")\n                 .arg(\n                     Arg::with_name(\"rustc-repo-path\")\n@@ -113,40 +156,5 @@ fn main() {\n                 )\n                 .arg(Arg::with_name(\"lint\").help(\"Which lint's page to load initially (optional)\")),\n         )\n-        .get_matches();\n-\n-    match matches.subcommand() {\n-        (\"fmt\", Some(matches)) => {\n-            fmt::run(matches.is_present(\"check\"), matches.is_present(\"verbose\"));\n-        },\n-        (\"update_lints\", Some(matches)) => {\n-            if matches.is_present(\"print-only\") {\n-                update_lints::print_lints();\n-            } else if matches.is_present(\"check\") {\n-                update_lints::run(update_lints::UpdateMode::Check);\n-            } else {\n-                update_lints::run(update_lints::UpdateMode::Change);\n-            }\n-        },\n-        (\"new_lint\", Some(matches)) => {\n-            match new_lint::create(\n-                matches.value_of(\"pass\"),\n-                matches.value_of(\"name\"),\n-                matches.value_of(\"category\"),\n-            ) {\n-                Ok(_) => update_lints::run(update_lints::UpdateMode::Change),\n-                Err(e) => eprintln!(\"Unable to create lint: {}\", e),\n-            }\n-        },\n-        (\"limit_stderr_length\", _) => {\n-            stderr_length_check::check();\n-        },\n-        (\"ra-setup\", Some(matches)) => ra_setup::run(matches.value_of(\"rustc-repo-path\")),\n-        (\"serve\", Some(matches)) => {\n-            let port = matches.value_of(\"port\").unwrap().parse().unwrap();\n-            let lint = matches.value_of(\"lint\");\n-            serve::run(port, lint);\n-        },\n-        _ => {},\n-    }\n+        .get_matches()\n }"}, {"sha": "40bf4a9505a88632027b1878405dd49ad8e0bc19", "filename": "src/tools/clippy/clippy_dev/src/ra_setup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fra_setup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fra_setup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fra_setup.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -52,7 +52,7 @@ fn inject_deps_into_manifest(\n     // do not inject deps if we have aleady done so\n     if cargo_toml.contains(\"[target.'cfg(NOT_A_PLATFORM)'.dependencies]\") {\n         eprintln!(\n-            \"cargo dev ra-setup: warning: deps already found inside {}, doing nothing.\",\n+            \"cargo dev ra_setup: warning: deps already found inside {}, doing nothing.\",\n             manifest_path\n         );\n         return Ok(());"}, {"sha": "f136aa4572a87b21bbea89bf3579049a79cf34bc", "filename": "src/tools/clippy/clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -99,7 +99,11 @@ impl LateLintPass<'_> for AwaitHolding {\n             };\n             let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n             let typeck_results = cx.tcx.typeck(def_id);\n-            check_interior_types(cx, &typeck_results.generator_interior_types.as_ref().skip_binder(), body.value.span);\n+            check_interior_types(\n+                cx,\n+                &typeck_results.generator_interior_types.as_ref().skip_binder(),\n+                body.value.span,\n+            );\n         }\n     }\n }"}, {"sha": "54bc69e058bc79460966385bec88e8cfce71f6bb", "filename": "src/tools/clippy/clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -6,9 +6,12 @@ use rustc_errors::Applicability;\n use rustc_hir::{BinOp, BinOpKind, Expr, ExprKind, QPath, TyKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n-use crate::utils::{snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n+use crate::utils::{meets_msrv, snippet_with_applicability, span_lint_and_sugg, SpanlessEq};\n+\n+const CHECKED_CONVERSIONS_MSRV: RustcVersion = RustcVersion::new(1, 34, 0);\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for explicit bounds checking when casting.\n@@ -39,10 +42,25 @@ declare_clippy_lint! {\n     \"`try_from` could replace manual bounds checking when casting\"\n }\n \n-declare_lint_pass!(CheckedConversions => [CHECKED_CONVERSIONS]);\n+pub struct CheckedConversions {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl CheckedConversions {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(CheckedConversions => [CHECKED_CONVERSIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for CheckedConversions {\n     fn check_expr(&mut self, cx: &LateContext<'_>, item: &Expr<'_>) {\n+        if !meets_msrv(self.msrv.as_ref(), &CHECKED_CONVERSIONS_MSRV) {\n+            return;\n+        }\n+\n         let result = if_chain! {\n             if !in_external_macro(cx.sess(), item.span);\n             if let ExprKind::Binary(op, ref left, ref right) = &item.kind;\n@@ -74,6 +92,8 @@ impl<'tcx> LateLintPass<'tcx> for CheckedConversions {\n             }\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }\n \n /// Searches for a single check from unsigned to _ is done"}, {"sha": "200b6a565cc43e53e29184ae7da416bd79440213", "filename": "src/tools/clippy/clippy_lints/src/create_dir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcreate_dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcreate_dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcreate_dir.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -8,7 +8,7 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n declare_clippy_lint! {\n     /// **What it does:** Checks usage of `std::fs::create_dir` and suggest using `std::fs::create_dir_all` instead.\n     ///\n-    /// **Why is this bad?** Sometimes `std::fs::crate_dir` is mistakenly chosen over `std::fs::create_dir_all`.\n+    /// **Why is this bad?** Sometimes `std::fs::create_dir` is mistakenly chosen over `std::fs::create_dir_all`.\n     ///\n     /// **Known problems:** None.\n     ///"}, {"sha": "aba655327959022632877be9d012706876adfc2b", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 79, "deletions": 60, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -14,6 +14,7 @@ use rustc_middle::ty;\n use rustc_parse::maybe_new_parser_from_source_str;\n use rustc_session::parse::ParseSess;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::edition::Edition;\n use rustc_span::source_map::{BytePos, FilePathMapping, MultiSpan, SourceMap, Span};\n use rustc_span::{sym, FileName, Pos};\n use std::io;\n@@ -377,7 +378,7 @@ fn check_attrs<'a>(cx: &LateContext<'_>, valid_idents: &FxHashSet<String>, attrs\n     check_doc(cx, valid_idents, events, &spans)\n }\n \n-const RUST_CODE: &[&str] = &[\"rust\", \"no_run\", \"should_panic\", \"compile_fail\", \"edition2018\"];\n+const RUST_CODE: &[&str] = &[\"rust\", \"no_run\", \"should_panic\", \"compile_fail\"];\n \n fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize>)>>(\n     cx: &LateContext<'_>,\n@@ -400,13 +401,24 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n     let mut in_link = None;\n     let mut in_heading = false;\n     let mut is_rust = false;\n+    let mut edition = None;\n     for (event, range) in events {\n         match event {\n             Start(CodeBlock(ref kind)) => {\n                 in_code = true;\n                 if let CodeBlockKind::Fenced(lang) = kind {\n-                    is_rust =\n-                        lang.is_empty() || !lang.contains(\"ignore\") && lang.split(',').any(|i| RUST_CODE.contains(&i));\n+                    for item in lang.split(',') {\n+                        if item == \"ignore\" {\n+                            is_rust = false;\n+                            break;\n+                        }\n+                        if let Some(stripped) = item.strip_prefix(\"edition\") {\n+                            is_rust = true;\n+                            edition = stripped.parse::<Edition>().ok();\n+                        } else if item.is_empty() || RUST_CODE.contains(&item) {\n+                            is_rust = true;\n+                        }\n+                    }\n                 }\n             },\n             End(CodeBlock(_)) => {\n@@ -436,7 +448,8 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n                 let (begin, span) = spans[index];\n                 if in_code {\n                     if is_rust {\n-                        check_code(cx, &text, span);\n+                        let edition = edition.unwrap_or_else(|| cx.tcx.sess.edition());\n+                        check_code(cx, &text, edition, span);\n                     }\n                 } else {\n                     // Adjust for the beginning of the current `Event`\n@@ -450,67 +463,73 @@ fn check_doc<'a, Events: Iterator<Item = (pulldown_cmark::Event<'a>, Range<usize\n     headers\n }\n \n-fn check_code(cx: &LateContext<'_>, text: &str, span: Span) {\n-    fn has_needless_main(code: &str) -> bool {\n-        let filename = FileName::anon_source_code(code);\n-\n-        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-        let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n-        let handler = Handler::with_emitter(false, None, box emitter);\n-        let sess = ParseSess::with_span_handler(handler, sm);\n-\n-        let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code.into()) {\n-            Ok(p) => p,\n-            Err(errs) => {\n-                for mut err in errs {\n-                    err.cancel();\n-                }\n-                return false;\n-            },\n-        };\n-\n-        let mut relevant_main_found = false;\n-        loop {\n-            match parser.parse_item() {\n-                Ok(Some(item)) => match &item.kind {\n-                    // Tests with one of these items are ignored\n-                    ItemKind::Static(..)\n-                    | ItemKind::Const(..)\n-                    | ItemKind::ExternCrate(..)\n-                    | ItemKind::ForeignMod(..) => return false,\n-                    // We found a main function ...\n-                    ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym::main => {\n-                        let is_async = matches!(sig.header.asyncness, Async::Yes{..});\n-                        let returns_nothing = match &sig.decl.output {\n-                            FnRetTy::Default(..) => true,\n-                            FnRetTy::Ty(ty) if ty.kind.is_unit() => true,\n-                            _ => false,\n-                        };\n-\n-                        if returns_nothing && !is_async && !block.stmts.is_empty() {\n-                            // This main function should be linted, but only if there are no other functions\n-                            relevant_main_found = true;\n-                        } else {\n-                            // This main function should not be linted, we're done\n-                            return false;\n+fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n+    fn has_needless_main(code: &str, edition: Edition) -> bool {\n+        rustc_driver::catch_fatal_errors(|| {\n+            rustc_span::with_session_globals(edition, || {\n+                let filename = FileName::anon_source_code(code);\n+\n+                let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+                let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n+                let handler = Handler::with_emitter(false, None, box emitter);\n+                let sess = ParseSess::with_span_handler(handler, sm);\n+\n+                let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code.into()) {\n+                    Ok(p) => p,\n+                    Err(errs) => {\n+                        for mut err in errs {\n+                            err.cancel();\n                         }\n+                        return false;\n                     },\n-                    // Another function was found; this case is ignored too\n-                    ItemKind::Fn(..) => return false,\n-                    _ => {},\n-                },\n-                Ok(None) => break,\n-                Err(mut e) => {\n-                    e.cancel();\n-                    return false;\n-                },\n-            }\n-        }\n+                };\n+\n+                let mut relevant_main_found = false;\n+                loop {\n+                    match parser.parse_item() {\n+                        Ok(Some(item)) => match &item.kind {\n+                            // Tests with one of these items are ignored\n+                            ItemKind::Static(..)\n+                            | ItemKind::Const(..)\n+                            | ItemKind::ExternCrate(..)\n+                            | ItemKind::ForeignMod(..) => return false,\n+                            // We found a main function ...\n+                            ItemKind::Fn(_, sig, _, Some(block)) if item.ident.name == sym::main => {\n+                                let is_async = matches!(sig.header.asyncness, Async::Yes { .. });\n+                                let returns_nothing = match &sig.decl.output {\n+                                    FnRetTy::Default(..) => true,\n+                                    FnRetTy::Ty(ty) if ty.kind.is_unit() => true,\n+                                    _ => false,\n+                                };\n+\n+                                if returns_nothing && !is_async && !block.stmts.is_empty() {\n+                                    // This main function should be linted, but only if there are no other functions\n+                                    relevant_main_found = true;\n+                                } else {\n+                                    // This main function should not be linted, we're done\n+                                    return false;\n+                                }\n+                            },\n+                            // Another function was found; this case is ignored too\n+                            ItemKind::Fn(..) => return false,\n+                            _ => {},\n+                        },\n+                        Ok(None) => break,\n+                        Err(mut e) => {\n+                            e.cancel();\n+                            return false;\n+                        },\n+                    }\n+                }\n \n-        relevant_main_found\n+                relevant_main_found\n+            })\n+        })\n+        .ok()\n+        .unwrap_or_default()\n     }\n \n-    if has_needless_main(text) {\n+    if has_needless_main(text, edition) {\n         span_lint(cx, NEEDLESS_DOCTEST_MAIN, span, \"needless `fn main` in doctest\");\n     }\n }"}, {"sha": "fd93548b55c6db3a327b2a9ac29fc7464476967b", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -405,13 +405,10 @@ impl<'tcx> Functions {\n                     break;\n                 }\n                 if in_comment {\n-                    match line.find(\"*/\") {\n-                        Some(i) => {\n-                            line = &line[i + 2..];\n-                            in_comment = false;\n-                            continue;\n-                        },\n-                        None => break,\n+                    if let Some(i) = line.find(\"*/\") {\n+                        line = &line[i + 2..];\n+                        in_comment = false;\n+                        continue;\n                     }\n                 } else {\n                     let multi_idx = line.find(\"/*\").unwrap_or_else(|| line.len());\n@@ -423,8 +420,8 @@ impl<'tcx> Functions {\n                         in_comment = true;\n                         continue;\n                     }\n-                    break;\n                 }\n+                break;\n             }\n             if code_in_line {\n                 line_count += 1;"}, {"sha": "6fe5335109045acfd799b46e75a994d0c5416255", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -222,9 +222,8 @@ fn check_impl_items(cx: &LateContext<'_>, item: &Item<'_>, impl_items: &[ImplIte\n     let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, \"is_empty\")) {\n         if cx.access_levels.is_exported(is_empty.id.hir_id) {\n             return;\n-        } else {\n-            \"a private\"\n         }\n+        \"a private\"\n     } else {\n         \"no corresponding\"\n     };"}, {"sha": "02ba422a2f5b8c0287913a80aad522f5256c8152", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -27,6 +27,7 @@ extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n extern crate rustc_attr;\n extern crate rustc_data_structures;\n+extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_hir;\n extern crate rustc_hir_pretty;\n@@ -294,6 +295,7 @@ mod question_mark;\n mod ranges;\n mod redundant_clone;\n mod redundant_closure_call;\n+mod redundant_else;\n mod redundant_field_names;\n mod redundant_pub_crate;\n mod redundant_static_lifetimes;\n@@ -344,6 +346,7 @@ mod wildcard_dependencies;\n mod wildcard_imports;\n mod write;\n mod zero_div_zero;\n+mod zero_sized_map_values;\n // end lints modules, do not remove this comment, it\u2019s used in `update_lints`\n \n pub use crate::utils::conf::Conf;\n@@ -509,6 +512,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         #[cfg(feature = \"internal-lints\")]\n         &utils::internal_lints::DEFAULT_LINT,\n         #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::INTERNING_DEFINED_SYMBOL,\n+        #[cfg(feature = \"internal-lints\")]\n         &utils::internal_lints::INVALID_PATHS,\n         #[cfg(feature = \"internal-lints\")]\n         &utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n@@ -831,6 +836,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &ranges::REVERSED_EMPTY_RANGES,\n         &redundant_clone::REDUNDANT_CLONE,\n         &redundant_closure_call::REDUNDANT_CLOSURE_CALL,\n+        &redundant_else::REDUNDANT_ELSE,\n         &redundant_field_names::REDUNDANT_FIELD_NAMES,\n         &redundant_pub_crate::REDUNDANT_PUB_CRATE,\n         &redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES,\n@@ -934,13 +940,15 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &wildcard_imports::WILDCARD_IMPORTS,\n         &write::PRINTLN_EMPTY_STRING,\n         &write::PRINT_LITERAL,\n+        &write::PRINT_STDERR,\n         &write::PRINT_STDOUT,\n         &write::PRINT_WITH_NEWLINE,\n         &write::USE_DEBUG,\n         &write::WRITELN_EMPTY_STRING,\n         &write::WRITE_LITERAL,\n         &write::WRITE_WITH_NEWLINE,\n         &zero_div_zero::ZERO_DIVIDED_BY_ZERO,\n+        &zero_sized_map_values::ZERO_SIZED_MAP_VALUES,\n     ]);\n     // end register lints, do not remove this comment, it\u2019s used in `update_lints`\n \n@@ -953,6 +961,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n         store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n         store.register_late_pass(|| box utils::internal_lints::InvalidPaths);\n+        store.register_late_pass(|| box utils::internal_lints::InterningDefinedSymbol::default());\n         store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n         store.register_late_pass(|| box utils::internal_lints::MatchTypeOnDiagItem);\n         store.register_late_pass(|| box utils::internal_lints::OuterExpnDataPass);\n@@ -1000,6 +1009,14 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box matches::Matches::new(msrv));\n     store.register_early_pass(move || box manual_non_exhaustive::ManualNonExhaustive::new(msrv));\n     store.register_late_pass(move || box manual_strip::ManualStrip::new(msrv));\n+    store.register_early_pass(move || box redundant_static_lifetimes::RedundantStaticLifetimes::new(msrv));\n+    store.register_early_pass(move || box redundant_field_names::RedundantFieldNames::new(msrv));\n+    store.register_late_pass(move || box checked_conversions::CheckedConversions::new(msrv));\n+    store.register_late_pass(move || box mem_replace::MemReplace::new(msrv));\n+    store.register_late_pass(move || box ranges::Ranges::new(msrv));\n+    store.register_late_pass(move || box use_self::UseSelf::new(msrv));\n+    store.register_late_pass(move || box missing_const_for_fn::MissingConstForFn::new(msrv));\n+\n     store.register_late_pass(|| box size_of_in_element_count::SizeOfInElementCount);\n     store.register_late_pass(|| box map_clone::MapClone);\n     store.register_late_pass(|| box map_err_ignore::MapErrIgnore);\n@@ -1010,7 +1027,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box main_recursion::MainRecursion::default());\n     store.register_late_pass(|| box lifetimes::Lifetimes);\n     store.register_late_pass(|| box entry::HashMapPass);\n-    store.register_late_pass(|| box ranges::Ranges);\n     store.register_late_pass(|| box types::Casts);\n     let type_complexity_threshold = conf.type_complexity_threshold;\n     store.register_late_pass(move || box types::TypeComplexity::new(type_complexity_threshold));\n@@ -1055,7 +1071,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box neg_multiply::NegMultiply);\n     store.register_late_pass(|| box mem_discriminant::MemDiscriminant);\n     store.register_late_pass(|| box mem_forget::MemForget);\n-    store.register_late_pass(|| box mem_replace::MemReplace);\n     store.register_late_pass(|| box arithmetic::Arithmetic::default());\n     store.register_late_pass(|| box assign_ops::AssignOps);\n     store.register_late_pass(|| box let_if_seq::LetIfSeq);\n@@ -1077,7 +1092,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box pass_by_ref_or_value);\n     store.register_late_pass(|| box ref_option_ref::RefOptionRef);\n     store.register_late_pass(|| box try_err::TryErr);\n-    store.register_late_pass(|| box use_self::UseSelf);\n     store.register_late_pass(|| box bytecount::ByteCount);\n     store.register_late_pass(|| box infinite_iter::InfiniteIter);\n     store.register_late_pass(|| box inline_fn_without_body::InlineFnWithoutBody);\n@@ -1103,10 +1117,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box unnecessary_wraps::UnnecessaryWraps);\n     store.register_late_pass(|| box types::RefToMut);\n     store.register_late_pass(|| box assertions_on_constants::AssertionsOnConstants);\n-    store.register_late_pass(|| box missing_const_for_fn::MissingConstForFn);\n     store.register_late_pass(|| box transmuting_null::TransmutingNull);\n     store.register_late_pass(|| box path_buf_push_overwrite::PathBufPushOverwrite);\n-    store.register_late_pass(|| box checked_conversions::CheckedConversions);\n     store.register_late_pass(|| box integer_division::IntegerDivision);\n     store.register_late_pass(|| box inherent_to_string::InherentToString);\n     let max_trait_bounds = conf.max_trait_bounds;\n@@ -1132,9 +1144,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box items_after_statements::ItemsAfterStatements);\n     store.register_early_pass(|| box precedence::Precedence);\n     store.register_early_pass(|| box needless_continue::NeedlessContinue);\n+    store.register_early_pass(|| box redundant_else::RedundantElse);\n     store.register_late_pass(|| box create_dir::CreateDir);\n     store.register_early_pass(|| box needless_arbitrary_self_type::NeedlessArbitrarySelfType);\n-    store.register_early_pass(|| box redundant_static_lifetimes::RedundantStaticLifetimes);\n     store.register_late_pass(|| box cargo_common_metadata::CargoCommonMetadata);\n     store.register_late_pass(|| box multiple_crate_versions::MultipleCrateVersions);\n     store.register_late_pass(|| box wildcard_dependencies::WildcardDependencies);\n@@ -1174,7 +1186,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box mut_mutex_lock::MutMutexLock);\n     store.register_late_pass(|| box match_on_vec_items::MatchOnVecItems);\n     store.register_late_pass(|| box manual_async_fn::ManualAsyncFn);\n-    store.register_early_pass(|| box redundant_field_names::RedundantFieldNames);\n     store.register_late_pass(|| box vec_resize_to_zero::VecResizeToZero);\n     store.register_late_pass(|| box panic_in_result_fn::PanicInResultFn);\n     let single_char_binding_names_threshold = conf.single_char_binding_names_threshold;\n@@ -1200,6 +1211,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box undropped_manually_drops::UndroppedManuallyDrops);\n     store.register_late_pass(|| box strings::StrToString);\n     store.register_late_pass(|| box strings::StringToString);\n+    store.register_late_pass(|| box zero_sized_map_values::ZeroSizedMapValues);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1247,6 +1259,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::RC_BUFFER),\n         LintId::of(&unwrap_in_result::UNWRAP_IN_RESULT),\n         LintId::of(&verbose_file_reads::VERBOSE_FILE_READS),\n+        LintId::of(&write::PRINT_STDERR),\n         LintId::of(&write::PRINT_STDOUT),\n         LintId::of(&write::USE_DEBUG),\n     ]);\n@@ -1308,6 +1321,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),\n         LintId::of(&ranges::RANGE_MINUS_ONE),\n         LintId::of(&ranges::RANGE_PLUS_ONE),\n+        LintId::of(&redundant_else::REDUNDANT_ELSE),\n         LintId::of(&ref_option_ref::REF_OPTION_REF),\n         LintId::of(&shadow::SHADOW_UNRELATED),\n         LintId::of(&strings::STRING_ADD_ASSIGN),\n@@ -1330,6 +1344,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&unused_self::UNUSED_SELF),\n         LintId::of(&wildcard_imports::ENUM_GLOB_USE),\n         LintId::of(&wildcard_imports::WILDCARD_IMPORTS),\n+        LintId::of(&zero_sized_map_values::ZERO_SIZED_MAP_VALUES),\n     ]);\n \n     #[cfg(feature = \"internal-lints\")]\n@@ -1338,6 +1353,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS),\n         LintId::of(&utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n         LintId::of(&utils::internal_lints::DEFAULT_LINT),\n+        LintId::of(&utils::internal_lints::INTERNING_DEFINED_SYMBOL),\n         LintId::of(&utils::internal_lints::INVALID_PATHS),\n         LintId::of(&utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n         LintId::of(&utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),"}, {"sha": "b97d97ea1a5ef140eb6bfa2aa6d103c76fa3eb30", "filename": "src/tools/clippy/clippy_lints/src/manual_ok_or.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_ok_or.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -8,6 +8,7 @@ use rustc_lint::LintContext;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::sym;\n \n declare_clippy_lint! {\n     /// **What it does:**\n@@ -51,7 +52,7 @@ impl LateLintPass<'_> for ManualOkOr {\n             if args.len() == 3;\n             let method_receiver = &args[0];\n             let ty = cx.typeck_results().expr_ty(method_receiver);\n-            if is_type_diagnostic_item(cx, ty, sym!(option_type));\n+            if is_type_diagnostic_item(cx, ty, sym::option_type);\n             let or_expr = &args[1];\n             if is_ok_wrapping(cx, &args[2]);\n             if let ExprKind::Call(Expr { kind: ExprKind::Path(err_path), .. }, &[ref err_arg]) = or_expr.kind;"}, {"sha": "04b35835c6b8eeed5325e41c2e01763c2d9ba99b", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -4,8 +4,8 @@ use crate::utils::usage::is_unused;\n use crate::utils::{\n     expr_block, get_arg_name, get_parent_expr, in_macro, indent_of, is_allowed, is_expn_of, is_refutable,\n     is_type_diagnostic_item, is_wild, match_qpath, match_type, match_var, meets_msrv, multispan_sugg, remove_blocks,\n-    snippet, snippet_block, snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg,\n-    span_lint_and_then,\n+    snippet, snippet_block, snippet_opt, snippet_with_applicability, span_lint_and_help, span_lint_and_note,\n+    span_lint_and_sugg, span_lint_and_then,\n };\n use crate::utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use if_chain::if_chain;\n@@ -689,10 +689,9 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n             if stmts.len() == 1 && block_expr.is_none() || stmts.is_empty() && block_expr.is_some() {\n                 // single statement/expr \"else\" block, don't lint\n                 return;\n-            } else {\n-                // block with 2+ statements or 1 expr and 1+ statement\n-                Some(els)\n             }\n+            // block with 2+ statements or 1 expr and 1+ statement\n+            Some(els)\n         } else {\n             // not a block, don't lint\n             return;\n@@ -1238,6 +1237,24 @@ fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[A\n     if in_macro(expr.span) || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n         return;\n     }\n+\n+    // HACK:\n+    // This is a hack to deal with arms that are excluded by macros like `#[cfg]`. It is only used here\n+    // to prevent false positives as there is currently no better way to detect if code was excluded by\n+    // a macro. See PR #6435\n+    if_chain! {\n+        if let Some(match_snippet) = snippet_opt(cx, expr.span);\n+        if let Some(arm_snippet) = snippet_opt(cx, arms[0].span);\n+        if let Some(ex_snippet) = snippet_opt(cx, ex.span);\n+        let rest_snippet = match_snippet.replace(&arm_snippet, \"\").replace(&ex_snippet, \"\");\n+        if rest_snippet.contains(\"=>\");\n+        then {\n+            // The code it self contains another thick arrow \"=>\"\n+            // -> Either another arm or a comment\n+            return;\n+        }\n+    }\n+\n     let matched_vars = ex.span;\n     let bind_names = arms[0].pat.span;\n     let match_body = remove_blocks(&arms[0].body);"}, {"sha": "19087b02077142fb84d86a62c87beffa7ac844d7", "filename": "src/tools/clippy/clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_replace.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,13 +1,14 @@\n use crate::utils::{\n-    in_macro, match_def_path, match_qpath, paths, snippet, snippet_with_applicability, span_lint_and_help,\n+    in_macro, match_def_path, match_qpath, meets_msrv, paths, snippet, snippet_with_applicability, span_lint_and_help,\n     span_lint_and_sugg, span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::sym;\n \n@@ -94,7 +95,7 @@ declare_clippy_lint! {\n     \"replacing a value of type `T` with `T::default()` instead of using `std::mem::take`\"\n }\n \n-declare_lint_pass!(MemReplace =>\n+impl_lint_pass!(MemReplace =>\n     [MEM_REPLACE_OPTION_WITH_NONE, MEM_REPLACE_WITH_UNINIT, MEM_REPLACE_WITH_DEFAULT]);\n \n fn check_replace_option_with_none(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n@@ -224,6 +225,19 @@ fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<\n     }\n }\n \n+const MEM_REPLACE_WITH_DEFAULT_MSRV: RustcVersion = RustcVersion::new(1, 40, 0);\n+\n+pub struct MemReplace {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl MemReplace {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for MemReplace {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n@@ -236,8 +250,11 @@ impl<'tcx> LateLintPass<'tcx> for MemReplace {\n             then {\n                 check_replace_option_with_none(cx, src, dest, expr.span);\n                 check_replace_with_uninit(cx, src, dest, expr.span);\n-                check_replace_with_default(cx, src, dest, expr.span);\n+                if meets_msrv(self.msrv.as_ref(), &MEM_REPLACE_WITH_DEFAULT_MSRV) {\n+                    check_replace_with_default(cx, src, dest, expr.span);\n+                }\n             }\n         }\n     }\n+    extract_msrv_attr!(LateContext);\n }"}, {"sha": "e99fe1b97ff6498a7884a02a4507786e0cbbde87", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 105, "deletions": 48, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -22,6 +22,7 @@ use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, SymbolStr};\n+use rustc_typeck::hir_ty_to_ty;\n \n use crate::consts::{constant, Constant};\n use crate::utils::eager_or_lazy::is_lazyness_candidate;\n@@ -1487,7 +1488,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"expect\", ..] => lint_expect(cx, expr, arg_lists[0]),\n             [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n             [\"unwrap_or_else\", \"map\"] => {\n-                if !lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]) {\n+                if !lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0], self.msrv.as_ref()) {\n                     unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], \"unwrap_or\");\n                 }\n             },\n@@ -1509,7 +1510,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"next\", \"iter\"] => lint_iter_next(cx, expr, arg_lists[1]),\n             [\"map\", \"filter\"] => lint_filter_map(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"map\", \"filter_map\"] => lint_filter_map_map(cx, expr, arg_lists[1], arg_lists[0]),\n-            [\"next\", \"filter_map\"] => lint_filter_map_next(cx, expr, arg_lists[1]),\n+            [\"next\", \"filter_map\"] => lint_filter_map_next(cx, expr, arg_lists[1], self.msrv.as_ref()),\n             [\"map\", \"find\"] => lint_find_map(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"flat_map\", \"filter\"] => lint_filter_flat_map(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"flat_map\", \"filter_map\"] => lint_filter_map_flat_map(cx, expr, arg_lists[1], arg_lists[0]),\n@@ -1568,7 +1569,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 lint_expect_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n \n                 let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n-                if args.len() == 1 && method_call.ident.name == sym!(clone) {\n+                if args.len() == 1 && method_call.ident.name == sym::clone {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n                     lint_clone_on_ref_ptr(cx, expr, &args[0]);\n                 }\n@@ -1592,7 +1593,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                             }\n                         }\n                     },\n-                    ty::Ref(..) if method_call.ident.name == sym!(into_iter) => {\n+                    ty::Ref(..) if method_call.ident.name == sym::into_iter => {\n                         lint_into_iter(cx, expr, self_ty, *method_span);\n                     },\n                     _ => (),\n@@ -1623,10 +1624,15 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         let item = cx.tcx.hir().expect_item(parent);\n         let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         let self_ty = cx.tcx.type_of(def_id);\n+\n+        // if this impl block implements a trait, lint in trait definition instead\n+        if let hir::ItemKind::Impl { of_trait: Some(_), .. } = item.kind {\n+            return;\n+        }\n+\n         if_chain! {\n             if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind;\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n-            if let hir::ItemKind::Impl{ of_trait: None, .. } = item.kind;\n \n             let method_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n             let method_sig = cx.tcx.fn_sig(method_def_id);\n@@ -1668,40 +1674,17 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     }\n                 }\n \n-                if let Some((ref conv, self_kinds)) = &CONVENTIONS\n-                    .iter()\n-                    .find(|(ref conv, _)| conv.check(&name))\n-                {\n-                    if !self_kinds.iter().any(|k| k.matches(cx, self_ty, first_arg_ty)) {\n-                        let lint = if item.vis.node.is_pub() {\n-                            WRONG_PUB_SELF_CONVENTION\n-                        } else {\n-                            WRONG_SELF_CONVENTION\n-                        };\n-\n-                        span_lint(\n-                            cx,\n-                            lint,\n-                            first_arg.pat.span,\n-                            &format!(\"methods called `{}` usually take {}; consider choosing a less ambiguous name\",\n-                                conv,\n-                                &self_kinds\n-                                    .iter()\n-                                    .map(|k| k.description())\n-                                    .collect::<Vec<_>>()\n-                                    .join(\" or \")\n-                            ),\n-                        );\n-                    }\n-                }\n+                lint_wrong_self_convention(\n+                    cx,\n+                    &name,\n+                    item.vis.node.is_pub(),\n+                    self_ty,\n+                    first_arg_ty,\n+                    first_arg.pat.span\n+                );\n             }\n         }\n \n-        // if this impl block implements a trait, lint in trait definition instead\n-        if let hir::ItemKind::Impl { of_trait: Some(_), .. } = item.kind {\n-            return;\n-        }\n-\n         if let hir::ImplItemKind::Fn(_, _) = impl_item.kind {\n             let ret_ty = return_ty(cx, impl_item.hir_id);\n \n@@ -1735,8 +1718,23 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n+        if in_external_macro(cx.tcx.sess, item.span) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let TraitItemKind::Fn(ref sig, _) = item.kind;\n+            if let Some(first_arg_ty) = sig.decl.inputs.iter().next();\n+            let first_arg_span = first_arg_ty.span;\n+            let first_arg_ty = hir_ty_to_ty(cx.tcx, first_arg_ty);\n+            let self_ty = TraitRef::identity(cx.tcx, item.hir_id.owner.to_def_id()).self_ty();\n+\n+            then {\n+                lint_wrong_self_convention(cx, &item.ident.name.as_str(), false, self_ty, first_arg_ty, first_arg_span);\n+            }\n+        }\n+\n         if_chain! {\n-            if !in_external_macro(cx.tcx.sess, item.span);\n             if item.ident.name == sym::new;\n             if let TraitItemKind::Fn(_, _) = item.kind;\n             let ret_ty = return_ty(cx, item.hir_id);\n@@ -1757,6 +1755,39 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n     extract_msrv_attr!(LateContext);\n }\n \n+fn lint_wrong_self_convention<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    item_name: &str,\n+    is_pub: bool,\n+    self_ty: &'tcx TyS<'tcx>,\n+    first_arg_ty: &'tcx TyS<'tcx>,\n+    first_arg_span: Span,\n+) {\n+    let lint = if is_pub {\n+        WRONG_PUB_SELF_CONVENTION\n+    } else {\n+        WRONG_SELF_CONVENTION\n+    };\n+    if let Some((ref conv, self_kinds)) = &CONVENTIONS.iter().find(|(ref conv, _)| conv.check(item_name)) {\n+        if !self_kinds.iter().any(|k| k.matches(cx, self_ty, first_arg_ty)) {\n+            span_lint(\n+                cx,\n+                lint,\n+                first_arg_span,\n+                &format!(\n+                    \"methods called `{}` usually take {}; consider choosing a less ambiguous name\",\n+                    conv,\n+                    &self_kinds\n+                        .iter()\n+                        .map(|k| k.description())\n+                        .collect::<Vec<_>>()\n+                        .join(\" or \")\n+                ),\n+            );\n+        }\n+    }\n+}\n+\n /// Checks for the `OR_FUN_CALL` lint.\n #[allow(clippy::too_many_lines)]\n fn lint_or_fun_call<'tcx>(\n@@ -2100,8 +2131,11 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n                 cx,\n                 CLONE_DOUBLE_REF,\n                 expr.span,\n-                \"using `clone` on a double-reference; \\\n-                this will copy the reference instead of cloning the inner type\",\n+                &format!(\n+                    \"using `clone` on a double-reference; \\\n+                    this will copy the reference of type `{}` instead of cloning the inner type\",\n+                    ty\n+                ),\n                 |diag| {\n                     if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n                         let mut ty = innermost;\n@@ -2174,11 +2208,17 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n         } else {\n             snip = None;\n         }\n-        span_lint_and_then(cx, CLONE_ON_COPY, expr.span, \"using `clone` on a `Copy` type\", |diag| {\n-            if let Some((text, snip)) = snip {\n-                diag.span_suggestion(expr.span, text, snip, Applicability::MachineApplicable);\n-            }\n-        });\n+        span_lint_and_then(\n+            cx,\n+            CLONE_ON_COPY,\n+            expr.span,\n+            &format!(\"using `clone` on type `{}` which implements the `Copy` trait\", ty),\n+            |diag| {\n+                if let Some((text, snip)) = snip {\n+                    diag.span_suggestion(expr.span, text, snip, Applicability::MachineApplicable);\n+                }\n+            },\n+        );\n     }\n }\n \n@@ -2638,9 +2678,9 @@ fn lint_unwrap(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::E\n fn lint_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n     let obj_ty = cx.typeck_results().expr_ty(&expect_args[0]).peel_refs();\n \n-    let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n         Some((EXPECT_USED, \"an Option\", \"None\"))\n-    } else if is_type_diagnostic_item(cx, obj_ty, sym!(result_type)) {\n+    } else if is_type_diagnostic_item(cx, obj_ty, sym::result_type) {\n         Some((EXPECT_USED, \"a Result\", \"Err\"))\n     } else {\n         None\n@@ -2733,14 +2773,20 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     }\n }\n \n+const MAP_UNWRAP_OR_MSRV: RustcVersion = RustcVersion::new(1, 41, 0);\n+\n /// lint use of `map().unwrap_or_else()` for `Option`s and `Result`s\n /// Return true if lint triggered\n fn lint_map_unwrap_or_else<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     map_args: &'tcx [hir::Expr<'_>],\n     unwrap_args: &'tcx [hir::Expr<'_>],\n+    msrv: Option<&RustcVersion>,\n ) -> bool {\n+    if !meets_msrv(msrv, &MAP_UNWRAP_OR_MSRV) {\n+        return false;\n+    }\n     // lint if the caller of `map()` is an `Option`\n     let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type);\n     let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::result_type);\n@@ -2923,9 +2969,20 @@ fn lint_filter_map<'tcx>(\n     }\n }\n \n+const FILTER_MAP_NEXT_MSRV: RustcVersion = RustcVersion::new(1, 30, 0);\n+\n /// lint use of `filter_map().next()` for `Iterators`\n-fn lint_filter_map_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, filter_args: &'tcx [hir::Expr<'_>]) {\n+fn lint_filter_map_next<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    filter_args: &'tcx [hir::Expr<'_>],\n+    msrv: Option<&RustcVersion>,\n+) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        if !meets_msrv(msrv, &FILTER_MAP_NEXT_MSRV) {\n+            return;\n+        }\n+\n         let msg = \"called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n                    `.find_map(..)` instead.\";\n         let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n@@ -3116,7 +3173,7 @@ fn lint_search_is_some<'tcx>(\n     else if search_method == \"find\" {\n         let is_string_or_str_slice = |e| {\n             let self_ty = cx.typeck_results().expr_ty(e).peel_refs();\n-            if is_type_diagnostic_item(cx, self_ty, sym!(string_type)) {\n+            if is_type_diagnostic_item(cx, self_ty, sym::string_type) {\n                 true\n             } else {\n                 *self_ty.kind() == ty::Str"}, {"sha": "d082a88cd2db55a9d56e48160d78696a03722500", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -69,10 +69,9 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n                             }\n                         }\n                         return (true, false);\n-                    } else {\n-                        // We don't know. It might do anything.\n-                        return (true, true);\n                     }\n+                    // We don't know. It might do anything.\n+                    return (true, true);\n                 }\n             }\n             (true, true)"}, {"sha": "6ebeaced62a335fcb806115cf1a1ec9c9ae291bd", "filename": "src/tools/clippy/clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,14 +1,19 @@\n use crate::utils::qualify_min_const_fn::is_min_const_fn;\n-use crate::utils::{fn_has_unsatisfiable_preds, has_drop, is_entrypoint_fn, span_lint, trait_ref_of_method};\n+use crate::utils::{\n+    fn_has_unsatisfiable_preds, has_drop, is_entrypoint_fn, meets_msrv, span_lint, trait_ref_of_method,\n+};\n use rustc_hir as hir;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, Constness, FnDecl, GenericParamKind, HirId};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n use rustc_typeck::hir_ty_to_ty;\n \n+const MISSING_CONST_FOR_FN_MSRV: RustcVersion = RustcVersion::new(1, 37, 0);\n+\n declare_clippy_lint! {\n     /// **What it does:**\n     ///\n@@ -69,7 +74,18 @@ declare_clippy_lint! {\n     \"Lint functions definitions that could be made `const fn`\"\n }\n \n-declare_lint_pass!(MissingConstForFn => [MISSING_CONST_FOR_FN]);\n+impl_lint_pass!(MissingConstForFn => [MISSING_CONST_FOR_FN]);\n+\n+pub struct MissingConstForFn {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl MissingConstForFn {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n \n impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n     fn check_fn(\n@@ -81,6 +97,10 @@ impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n         span: Span,\n         hir_id: HirId,\n     ) {\n+        if !meets_msrv(self.msrv.as_ref(), &MISSING_CONST_FOR_FN_MSRV) {\n+            return;\n+        }\n+\n         let def_id = cx.tcx.hir().local_def_id(hir_id);\n \n         if in_external_macro(cx.tcx.sess, span) || is_entrypoint_fn(cx, def_id.to_def_id()) {\n@@ -99,7 +119,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n                 let has_const_generic_params = generics\n                     .params\n                     .iter()\n-                    .any(|param| matches!(param.kind, GenericParamKind::Const{ .. }));\n+                    .any(|param| matches!(param.kind, GenericParamKind::Const { .. }));\n \n                 if already_const(header) || has_const_generic_params {\n                     return;\n@@ -126,6 +146,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n             span_lint(cx, MISSING_CONST_FOR_FN, span, \"this could be a `const fn`\");\n         }\n     }\n+    extract_msrv_attr!(LateContext);\n }\n \n /// Returns true if any of the method parameters is a type that implements `Drop`. The method"}, {"sha": "27f1074a0dd8a398b1e575c42ff98cd6781181eb", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -2,7 +2,7 @@\n // *rustc*'s\n // [`missing_doc`].\n //\n-// [`missing_doc`]: https://github.com/rust-lang/rust/blob/d6d05904697d89099b55da3331155392f1db9c00/src/librustc_lint/builtin.rs#L246\n+// [`missing_doc`]: https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler/rustc_lint/src/builtin.rs#L415\n //\n \n use crate::utils::span_lint;\n@@ -70,7 +70,14 @@ impl MissingDoc {\n         }\n     }\n \n-    fn check_missing_docs_attrs(&self, cx: &LateContext<'_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n+    fn check_missing_docs_attrs(\n+        &self,\n+        cx: &LateContext<'_>,\n+        attrs: &[ast::Attribute],\n+        sp: Span,\n+        article: &'static str,\n+        desc: &'static str,\n+    ) {\n         // If we're building a test harness, then warning about\n         // documentation is probably not really relevant right now.\n         if cx.sess().opts.test {\n@@ -94,7 +101,7 @@ impl MissingDoc {\n                 cx,\n                 MISSING_DOCS_IN_PRIVATE_ITEMS,\n                 sp,\n-                &format!(\"missing documentation for {}\", desc),\n+                &format!(\"missing documentation for {} {}\", article, desc),\n             );\n         }\n     }\n@@ -120,13 +127,11 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &LateContext<'tcx>, krate: &'tcx hir::Crate<'_>) {\n-        self.check_missing_docs_attrs(cx, &krate.item.attrs, krate.item.span, \"crate\");\n+        self.check_missing_docs_attrs(cx, &krate.item.attrs, krate.item.span, \"the\", \"crate\");\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, it: &'tcx hir::Item<'_>) {\n-        let desc = match it.kind {\n-            hir::ItemKind::Const(..) => \"a constant\",\n-            hir::ItemKind::Enum(..) => \"an enum\",\n+        match it.kind {\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n                 if it.ident.name == sym::main {\n@@ -136,34 +141,35 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n                         return;\n                     }\n                 }\n-                \"a function\"\n             },\n-            hir::ItemKind::Mod(..) => \"a module\",\n-            hir::ItemKind::Static(..) => \"a static\",\n-            hir::ItemKind::Struct(..) => \"a struct\",\n-            hir::ItemKind::Trait(..) => \"a trait\",\n-            hir::ItemKind::TraitAlias(..) => \"a trait alias\",\n-            hir::ItemKind::TyAlias(..) => \"a type alias\",\n-            hir::ItemKind::Union(..) => \"a union\",\n-            hir::ItemKind::OpaqueTy(..) => \"an existential type\",\n+            hir::ItemKind::Const(..)\n+            | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Mod(..)\n+            | hir::ItemKind::Static(..)\n+            | hir::ItemKind::Struct(..)\n+            | hir::ItemKind::Trait(..)\n+            | hir::ItemKind::TraitAlias(..)\n+            | hir::ItemKind::TyAlias(..)\n+            | hir::ItemKind::Union(..)\n+            | hir::ItemKind::OpaqueTy(..) => {},\n             hir::ItemKind::ExternCrate(..)\n             | hir::ItemKind::ForeignMod { .. }\n             | hir::ItemKind::GlobalAsm(..)\n             | hir::ItemKind::Impl { .. }\n             | hir::ItemKind::Use(..) => return,\n         };\n \n-        self.check_missing_docs_attrs(cx, &it.attrs, it.span, desc);\n+        let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+\n+        self.check_missing_docs_attrs(cx, &it.attrs, it.span, article, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx hir::TraitItem<'_>) {\n-        let desc = match trait_item.kind {\n-            hir::TraitItemKind::Const(..) => \"an associated constant\",\n-            hir::TraitItemKind::Fn(..) => \"a trait method\",\n-            hir::TraitItemKind::Type(..) => \"an associated type\",\n-        };\n+        let def_id = cx.tcx.hir().local_def_id(trait_item.hir_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, &trait_item.attrs, trait_item.span, desc);\n+        self.check_missing_docs_attrs(cx, &trait_item.attrs, trait_item.span, article, desc);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n@@ -178,21 +184,17 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             },\n         }\n \n-        let desc = match impl_item.kind {\n-            hir::ImplItemKind::Const(..) => \"an associated constant\",\n-            hir::ImplItemKind::Fn(..) => \"a method\",\n-            hir::ImplItemKind::TyAlias(_) => \"an associated type\",\n-        };\n-        self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, desc);\n+        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, article, desc);\n     }\n \n     fn check_struct_field(&mut self, cx: &LateContext<'tcx>, sf: &'tcx hir::StructField<'_>) {\n         if !sf.is_positional() {\n-            self.check_missing_docs_attrs(cx, &sf.attrs, sf.span, \"a struct field\");\n+            self.check_missing_docs_attrs(cx, &sf.attrs, sf.span, \"a\", \"struct field\");\n         }\n     }\n \n     fn check_variant(&mut self, cx: &LateContext<'tcx>, v: &'tcx hir::Variant<'_>) {\n-        self.check_missing_docs_attrs(cx, &v.attrs, v.span, \"a variant\");\n+        self.check_missing_docs_attrs(cx, &v.attrs, v.span, \"a\", \"variant\");\n     }\n }"}, {"sha": "bff53eb8ccada92e7cc8580e2f545a617a9cf2f9", "filename": "src/tools/clippy/clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n             return;\n         }\n         if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = e.kind {\n-            if let ty::Ref(..) = cx.typeck_results().expr_ty(inner).kind() {\n+            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty(inner).kind() {\n                 for adj3 in cx.typeck_results().expr_adjustments(e).windows(3) {\n                     if let [Adjustment {\n                         kind: Adjust::Deref(_), ..\n@@ -62,8 +62,11 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n                             cx,\n                             NEEDLESS_BORROW,\n                             e.span,\n-                            \"this expression borrows a reference that is immediately dereferenced \\\n+                            &format!(\n+                                \"this expression borrows a reference (`&{}`) that is immediately dereferenced \\\n                              by the compiler\",\n+                                ty\n+                            ),\n                             |diag| {\n                                 if let Some(snippet) = snippet_opt(cx, inner.span) {\n                                     diag.span_suggestion("}, {"sha": "5043b7b1fc3c1858743ee4862127e67aed09a4a0", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -90,9 +90,10 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n \n         // Exclude non-inherent impls\n         if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-            if matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), .. } |\n-                ItemKind::Trait(..))\n-            {\n+            if matches!(\n+                item.kind,\n+                ItemKind::Impl { of_trait: Some(_), .. } | ItemKind::Trait(..)\n+            ) {\n                 return;\n             }\n         }"}, {"sha": "41cf541ecf5ef59d8e814bae9ffde7d72d56f511", "filename": "src/tools/clippy/clippy_lints/src/needless_update.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -8,6 +8,9 @@ declare_clippy_lint! {\n     /// **What it does:** Checks for needlessly including a base struct on update\n     /// when all fields are changed anyway.\n     ///\n+    /// This lint is not applied to structs marked with\n+    /// [non_exhaustive](https://doc.rust-lang.org/reference/attributes/type_system.html).\n+    ///\n     /// **Why is this bad?** This will cost resources (because the base has to be\n     /// somewhere), and make the code less readable.\n     ///\n@@ -49,7 +52,9 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessUpdate {\n         if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.kind {\n             let ty = cx.typeck_results().expr_ty(expr);\n             if let ty::Adt(def, _) = ty.kind() {\n-                if fields.len() == def.non_enum_variant().fields.len() {\n+                if fields.len() == def.non_enum_variant().fields.len()\n+                    && !def.variants[0_usize.into()].is_field_list_non_exhaustive()\n+                {\n                     span_lint(\n                         cx,\n                         NEEDLESS_UPDATE,"}, {"sha": "446426b3e611f84e8ccad4a21cedab263ffda6ee", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -409,11 +409,10 @@ fn levenstein_not_1(a_name: &str, b_name: &str) -> bool {\n         if let Some(b2) = b_chars.next() {\n             // check if there's just one character inserted\n             return a != b2 || a_chars.ne(b_chars);\n-        } else {\n-            // tuple\n-            // ntuple\n-            return true;\n         }\n+        // tuple\n+        // ntuple\n+        return true;\n     }\n     // for item in items\n     true"}, {"sha": "37e2b50def17a389b7473a280f59527f6ed2785b", "filename": "src/tools/clippy/clippy_lints/src/panic_in_result_fn.rs", "status": "modified", "additions": 31, "deletions": 37, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpanic_in_result_fn.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,18 +1,16 @@\n-use crate::utils::{is_expn_of, is_type_diagnostic_item, return_ty, span_lint_and_then};\n+use crate::utils::{find_macro_calls, is_type_diagnostic_item, return_ty, span_lint_and_then};\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, FnKind, NestedVisitorMap, Visitor};\n-use rustc_hir::Expr;\n+use rustc_hir::intravisit::FnKind;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for usage of `panic!`, `unimplemented!`, `todo!` or `unreachable!` in a function of type result.\n+    /// **What it does:** Checks for usage of `panic!`, `unimplemented!`, `todo!`, `unreachable!` or assertions in a function of type result.\n     ///\n-    /// **Why is this bad?** For some codebases, it is desirable for functions of type result to return an error instead of crashing. Hence unimplemented, panic and unreachable should be avoided.\n+    /// **Why is this bad?** For some codebases, it is desirable for functions of type result to return an error instead of crashing. Hence panicking macros should be avoided.\n     ///\n-    /// **Known problems:** None.\n+    /// **Known problems:** Functions called from a function returning a `Result` may invoke a panicking macro. This is not checked.\n     ///\n     /// **Example:**\n     ///\n@@ -22,9 +20,15 @@ declare_clippy_lint! {\n     ///     panic!(\"error\");\n     /// }\n     /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn result_without_panic() -> Result<bool, String> {\n+    ///     Err(String::from(\"error\"))\n+    /// }\n+    /// ```\n     pub PANIC_IN_RESULT_FN,\n     restriction,\n-    \"functions of type `Result<..>` that contain `panic!()`, `todo!()` or `unreachable()` or `unimplemented()` \"\n+    \"functions of type `Result<..>` that contain `panic!()`, `todo!()`, `unreachable()`, `unimplemented()` or assertion\"\n }\n \n declare_lint_pass!(PanicInResultFn  => [PANIC_IN_RESULT_FN]);\n@@ -47,43 +51,33 @@ impl<'tcx> LateLintPass<'tcx> for PanicInResultFn {\n     }\n }\n \n-struct FindPanicUnimplementedUnreachable {\n-    result: Vec<Span>,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for FindPanicUnimplementedUnreachable {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if [\"unimplemented\", \"unreachable\", \"panic\", \"todo\"]\n-            .iter()\n-            .any(|fun| is_expn_of(expr.span, fun).is_some())\n-        {\n-            self.result.push(expr.span);\n-        }\n-        // and check sub-expressions\n-        intravisit::walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, body: &'tcx hir::Body<'tcx>) {\n-    let mut panics = FindPanicUnimplementedUnreachable { result: Vec::new() };\n-    panics.visit_expr(&body.value);\n-    if !panics.result.is_empty() {\n+    let panics = find_macro_calls(\n+        &[\n+            \"unimplemented\",\n+            \"unreachable\",\n+            \"panic\",\n+            \"todo\",\n+            \"assert\",\n+            \"assert_eq\",\n+            \"assert_ne\",\n+            \"debug_assert\",\n+            \"debug_assert_eq\",\n+            \"debug_assert_ne\",\n+        ],\n+        body,\n+    );\n+    if !panics.is_empty() {\n         span_lint_and_then(\n             cx,\n             PANIC_IN_RESULT_FN,\n             impl_span,\n-            \"used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\",\n+            \"used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\",\n             move |diag| {\n                 diag.help(\n-                    \"`unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\",\n+                    \"`unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\",\n                 );\n-                diag.span_note(panics.result, \"return Err() instead of panicking\");\n+                diag.span_note(panics, \"return Err() instead of panicking\");\n             },\n         );\n     }"}, {"sha": "6a17d654ac943e55f3964cfd9a8b7865c296b53e", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -244,9 +244,10 @@ impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n \n         // Exclude non-inherent impls\n         if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-            if matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), .. } |\n-            ItemKind::Trait(..))\n-            {\n+            if matches!(\n+                item.kind,\n+                ItemKind::Impl { of_trait: Some(_), .. } | ItemKind::Trait(..)\n+            ) {\n                 return;\n             }\n         }"}, {"sha": "3e454eecd970e37b85dfb0d150f13e3715b5d136", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -3,18 +3,19 @@ use if_chain::if_chain;\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::sym;\n use rustc_span::symbol::Ident;\n use std::cmp::Ordering;\n \n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    get_parent_expr, is_integer_const, single_segment_path, snippet, snippet_opt, snippet_with_applicability,\n-    span_lint, span_lint_and_sugg, span_lint_and_then,\n+    get_parent_expr, in_constant, is_integer_const, meets_msrv, single_segment_path, snippet, snippet_opt,\n+    snippet_with_applicability, span_lint, span_lint_and_sugg, span_lint_and_then,\n };\n use crate::utils::{higher, SpanlessEq};\n \n@@ -160,7 +161,20 @@ declare_clippy_lint! {\n     \"manually reimplementing {`Range`, `RangeInclusive`}`::contains`\"\n }\n \n-declare_lint_pass!(Ranges => [\n+const MANUAL_RANGE_CONTAINS_MSRV: RustcVersion = RustcVersion::new(1, 35, 0);\n+\n+pub struct Ranges {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl Ranges {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(Ranges => [\n     RANGE_ZIP_WITH_LEN,\n     RANGE_PLUS_ONE,\n     RANGE_MINUS_ONE,\n@@ -175,7 +189,9 @@ impl<'tcx> LateLintPass<'tcx> for Ranges {\n                 check_range_zip_with_len(cx, path, args, expr.span);\n             },\n             ExprKind::Binary(ref op, ref l, ref r) => {\n-                check_possible_range_contains(cx, op.node, l, r, expr.span);\n+                if meets_msrv(self.msrv.as_ref(), &MANUAL_RANGE_CONTAINS_MSRV) {\n+                    check_possible_range_contains(cx, op.node, l, r, expr);\n+                }\n             },\n             _ => {},\n         }\n@@ -184,9 +200,15 @@ impl<'tcx> LateLintPass<'tcx> for Ranges {\n         check_inclusive_range_minus_one(cx, expr);\n         check_reversed_empty_range(cx, expr);\n     }\n+    extract_msrv_attr!(LateContext);\n }\n \n-fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'_>, r: &Expr<'_>, span: Span) {\n+fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'_>, r: &Expr<'_>, expr: &Expr<'_>) {\n+    if in_constant(cx, expr.hir_id) {\n+        return;\n+    }\n+\n+    let span = expr.span;\n     let combine_and = match op {\n         BinOpKind::And | BinOpKind::BitAnd => true,\n         BinOpKind::Or | BinOpKind::BitOr => false,"}, {"sha": "06adbb523d706288c4e1a98b8a990fb188af7313", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -390,7 +390,10 @@ impl<'tcx> mir::visit::Visitor<'tcx> for LocalUseVisitor {\n         let local = place.local;\n \n         if local == self.used.0\n-            && !matches!(ctx, PlaceContext::MutatingUse(MutatingUseContext::Drop) | PlaceContext::NonUse(_))\n+            && !matches!(\n+                ctx,\n+                PlaceContext::MutatingUse(MutatingUseContext::Drop) | PlaceContext::NonUse(_)\n+            )\n         {\n             self.used.1 = true;\n         }"}, {"sha": "3d585cd27a3d07c9a5e808526767eae4cdaacd8d", "filename": "src/tools/clippy/clippy_lints/src/redundant_else.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_else.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,135 @@\n+use crate::utils::span_lint_and_help;\n+use rustc_ast::ast::{Block, Expr, ExprKind, Stmt, StmtKind};\n+use rustc_ast::visit::{walk_expr, Visitor};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `else` blocks that can be removed without changing semantics.\n+    ///\n+    /// **Why is this bad?** The `else` block adds unnecessary indentation and verbosity.\n+    ///\n+    /// **Known problems:** Some may prefer to keep the `else` block for clarity.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// fn my_func(count: u32) {\n+    ///     if count == 0 {\n+    ///         print!(\"Nothing to do\");\n+    ///         return;\n+    ///     } else {\n+    ///         print!(\"Moving on...\");\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn my_func(count: u32) {\n+    ///     if count == 0 {\n+    ///         print!(\"Nothing to do\");\n+    ///         return;\n+    ///     }\n+    ///     print!(\"Moving on...\");\n+    /// }\n+    /// ```\n+    pub REDUNDANT_ELSE,\n+    pedantic,\n+    \"`else` branch that can be removed without changing semantics\"\n+}\n+\n+declare_lint_pass!(RedundantElse => [REDUNDANT_ELSE]);\n+\n+impl EarlyLintPass for RedundantElse {\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &Stmt) {\n+        if in_external_macro(cx.sess, stmt.span) {\n+            return;\n+        }\n+        // Only look at expressions that are a whole statement\n+        let expr: &Expr = match &stmt.kind {\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr,\n+            _ => return,\n+        };\n+        // if else\n+        let (mut then, mut els): (&Block, &Expr) = match &expr.kind {\n+            ExprKind::If(_, then, Some(els)) => (then, els),\n+            _ => return,\n+        };\n+        loop {\n+            if !BreakVisitor::default().check_block(then) {\n+                // then block does not always break\n+                return;\n+            }\n+            match &els.kind {\n+                // else if else\n+                ExprKind::If(_, next_then, Some(next_els)) => {\n+                    then = next_then;\n+                    els = next_els;\n+                    continue;\n+                },\n+                // else if without else\n+                ExprKind::If(..) => return,\n+                // done\n+                _ => break,\n+            }\n+        }\n+        span_lint_and_help(\n+            cx,\n+            REDUNDANT_ELSE,\n+            els.span,\n+            \"redundant else block\",\n+            None,\n+            \"remove the `else` block and move the contents out\",\n+        );\n+    }\n+}\n+\n+/// Call `check` functions to check if an expression always breaks control flow\n+#[derive(Default)]\n+struct BreakVisitor {\n+    is_break: bool,\n+}\n+\n+impl<'ast> Visitor<'ast> for BreakVisitor {\n+    fn visit_block(&mut self, block: &'ast Block) {\n+        self.is_break = match block.stmts.as_slice() {\n+            [.., last] => self.check_stmt(last),\n+            _ => false,\n+        };\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'ast Expr) {\n+        self.is_break = match expr.kind {\n+            ExprKind::Break(..) | ExprKind::Continue(..) | ExprKind::Ret(..) => true,\n+            ExprKind::Match(_, ref arms) => arms.iter().all(|arm| self.check_expr(&arm.body)),\n+            ExprKind::If(_, ref then, Some(ref els)) => self.check_block(then) && self.check_expr(els),\n+            ExprKind::If(_, _, None)\n+            // ignore loops for simplicity\n+            | ExprKind::While(..) | ExprKind::ForLoop(..) | ExprKind::Loop(..) => false,\n+            _ => {\n+                walk_expr(self, expr);\n+                return;\n+            },\n+        };\n+    }\n+}\n+\n+impl BreakVisitor {\n+    fn check<T>(&mut self, item: T, visit: fn(&mut Self, T)) -> bool {\n+        visit(self, item);\n+        std::mem::replace(&mut self.is_break, false)\n+    }\n+\n+    fn check_block(&mut self, block: &Block) -> bool {\n+        self.check(block, Self::visit_block)\n+    }\n+\n+    fn check_expr(&mut self, expr: &Expr) -> bool {\n+        self.check(expr, Self::visit_expr)\n+    }\n+\n+    fn check_stmt(&mut self, stmt: &Stmt) -> bool {\n+        self.check(stmt, Self::visit_stmt)\n+    }\n+}"}, {"sha": "38dcf7a192c823beadf6e5a07e43f3c013eac754", "filename": "src/tools/clippy/clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,9 +1,12 @@\n-use crate::utils::span_lint_and_sugg;\n+use crate::utils::{meets_msrv, span_lint_and_sugg};\n use rustc_ast::ast::{Expr, ExprKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+const REDUNDANT_FIELD_NAMES_MSRV: RustcVersion = RustcVersion::new(1, 17, 0);\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for fields in struct literals where shorthands\n@@ -33,10 +36,25 @@ declare_clippy_lint! {\n     \"checks for fields in struct literals where shorthands could be used\"\n }\n \n-declare_lint_pass!(RedundantFieldNames => [REDUNDANT_FIELD_NAMES]);\n+pub struct RedundantFieldNames {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl RedundantFieldNames {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(RedundantFieldNames => [REDUNDANT_FIELD_NAMES]);\n \n impl EarlyLintPass for RedundantFieldNames {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if !meets_msrv(self.msrv.as_ref(), &REDUNDANT_FIELD_NAMES_MSRV) {\n+            return;\n+        }\n+\n         if in_external_macro(cx.sess, expr.span) {\n             return;\n         }\n@@ -64,4 +82,5 @@ impl EarlyLintPass for RedundantFieldNames {\n             }\n         }\n     }\n+    extract_msrv_attr!(EarlyContext);\n }"}, {"sha": "fcfa3c12755af37e0979aac06021a48ee8473d99", "filename": "src/tools/clippy/clippy_lints/src/redundant_static_lifetimes.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,8 +1,11 @@\n-use crate::utils::{snippet, span_lint_and_then};\n+use crate::utils::{meets_msrv, snippet, span_lint_and_then};\n use rustc_ast::ast::{Item, ItemKind, Ty, TyKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+const REDUNDANT_STATIC_LIFETIMES_MSRV: RustcVersion = RustcVersion::new(1, 17, 0);\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for constants and statics with an explicit `'static` lifetime.\n@@ -29,7 +32,18 @@ declare_clippy_lint! {\n     \"Using explicit `'static` lifetime for constants or statics when elision rules would allow omitting them.\"\n }\n \n-declare_lint_pass!(RedundantStaticLifetimes => [REDUNDANT_STATIC_LIFETIMES]);\n+pub struct RedundantStaticLifetimes {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl RedundantStaticLifetimes {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(RedundantStaticLifetimes => [REDUNDANT_STATIC_LIFETIMES]);\n \n impl RedundantStaticLifetimes {\n     // Recursively visit types\n@@ -84,6 +98,10 @@ impl RedundantStaticLifetimes {\n \n impl EarlyLintPass for RedundantStaticLifetimes {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        if !meets_msrv(self.msrv.as_ref(), &REDUNDANT_STATIC_LIFETIMES_MSRV) {\n+            return;\n+        }\n+\n         if !item.span.from_expansion() {\n             if let ItemKind::Const(_, ref var_type, _) = item.kind {\n                 self.visit_type(var_type, cx, \"constants have by default a `'static` lifetime\");\n@@ -96,4 +114,6 @@ impl EarlyLintPass for RedundantStaticLifetimes {\n             }\n         }\n     }\n+\n+    extract_msrv_attr!(EarlyContext);\n }"}, {"sha": "803ebada54b790cd2f172e3455cc6f3123e5347d", "filename": "src/tools/clippy/clippy_lints/src/ref_option_ref.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fref_option_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fref_option_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fref_option_ref.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -2,6 +2,7 @@ use crate::utils::{last_path_segment, snippet, span_lint_and_sugg};\n use rustc_hir::{GenericArg, Mutability, Ty, TyKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::sym;\n \n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -41,7 +42,7 @@ impl<'tcx> LateLintPass<'tcx> for RefOptionRef {\n             if let Some(res) = last.res;\n             if let Some(def_id) = res.opt_def_id();\n \n-            if cx.tcx.is_diagnostic_item(sym!(option_type), def_id);\n+            if cx.tcx.is_diagnostic_item(sym::option_type, def_id);\n             if let Some(ref params) = last_path_segment(qpath).args ;\n             if !params.parenthesized;\n             if let Some(inner_ty) = params.args.iter().find_map(|arg| match arg {"}, {"sha": "31dd5965473d3e9c0affb5c1f2a627de8cda1ff8", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -372,7 +372,7 @@ impl LateLintPass<'_> for StringToString {\n             if let ExprKind::MethodCall(path, _, args, _) = &expr.kind;\n             if path.ident.name == sym!(to_string);\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n-            if is_type_diagnostic_item(cx, ty, sym!(string_type));\n+            if is_type_diagnostic_item(cx, ty, sym::string_type);\n             then {\n                 span_lint_and_help(\n                     cx,"}, {"sha": "fd74783335d57599bd57b3a1fd4d1fc9b7f75e31", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1104,7 +1104,9 @@ fn is_empty_block(expr: &Expr<'_>) -> bool {\n         expr.kind,\n         ExprKind::Block(\n             Block {\n-                stmts: &[], expr: None, ..\n+                stmts: &[],\n+                expr: None,\n+                ..\n             },\n             _,\n         )"}, {"sha": "5b9a80f92db69963ec0256e8c8e404549d9f1a87", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -9,6 +9,7 @@ use rustc_hir::{Body, ExprKind, FnDecl, HirId, ItemKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n declare_clippy_lint! {\n@@ -74,14 +75,17 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n         }\n \n         if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-            if matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), ..} | ItemKind::Trait(..)) {\n+            if matches!(\n+                item.kind,\n+                ItemKind::Impl { of_trait: Some(_), .. } | ItemKind::Trait(..)\n+            ) {\n                 return;\n             }\n         }\n \n-        let (return_type, path) = if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(option_type)) {\n+        let (return_type, path) = if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::option_type) {\n             (\"Option\", &paths::OPTION_SOME)\n-        } else if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(result_type)) {\n+        } else if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::result_type) {\n             (\"Result\", &paths::RESULT_OK)\n         } else {\n             return;"}, {"sha": "3b23f885e08d9584d9434efd03aa31c93ef7b345", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -12,11 +12,12 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_middle::ty::{DefIdTree, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::kw;\n use rustc_typeck::hir_ty_to_ty;\n \n-use crate::utils::{differing_macro_contexts, span_lint_and_sugg};\n+use crate::utils::{differing_macro_contexts, meets_msrv, span_lint_and_sugg};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for unnecessary repetition of structure name when a\n@@ -53,7 +54,7 @@ declare_clippy_lint! {\n     \"unnecessary structure name repetition whereas `Self` is applicable\"\n }\n \n-declare_lint_pass!(UseSelf => [USE_SELF]);\n+impl_lint_pass!(UseSelf => [USE_SELF]);\n \n const SEGMENTS_MSG: &str = \"segments should be composed of at least 1 element\";\n \n@@ -157,8 +158,25 @@ fn check_trait_method_impl_decl<'tcx>(\n     }\n }\n \n+const USE_SELF_MSRV: RustcVersion = RustcVersion::new(1, 37, 0);\n+\n+pub struct UseSelf {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl UseSelf {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for UseSelf {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        if !meets_msrv(self.msrv.as_ref(), &USE_SELF_MSRV) {\n+            return;\n+        }\n+\n         if in_external_macro(cx.sess(), item.span) {\n             return;\n         }\n@@ -204,6 +222,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n             }\n         }\n     }\n+    extract_msrv_attr!(LateContext);\n }\n \n struct UseSelfVisitor<'a, 'tcx> {"}, {"sha": "f0267e4c792893b36869f19ed32f5103c8c5569b", "filename": "src/tools/clippy/clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -408,7 +408,10 @@ pub fn eq_use_tree_kind(l: &UseTreeKind, r: &UseTreeKind) -> bool {\n }\n \n pub fn eq_defaultness(l: Defaultness, r: Defaultness) -> bool {\n-    matches!((l, r), (Defaultness::Final, Defaultness::Final) | (Defaultness::Default(_), Defaultness::Default(_)))\n+    matches!(\n+        (l, r),\n+        (Defaultness::Final, Defaultness::Final) | (Defaultness::Default(_), Defaultness::Default(_))\n+    )\n }\n \n pub fn eq_vis(l: &Visibility, r: &Visibility) -> bool {"}, {"sha": "32d7840a451c6c60ae6e893b1477477cf0d9866c", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -106,7 +106,7 @@ macro_rules! define_Conf {\n \n pub use self::helpers::Conf;\n define_Conf! {\n-    /// Lint: MANUAL_NON_EXHAUSTIVE, MANUAL_STRIP, OPTION_AS_REF_DEREF, MATCH_LIKE_MATCHES_MACRO. The minimum rust version that the project supports\n+    /// Lint: REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN. The minimum rust version that the project supports\n     (msrv, \"msrv\": Option<String>, None),\n     /// Lint: BLACKLISTED_NAME. The list of blacklisted names to lint about. NB: `bar` is not here since it has legitimate uses\n     (blacklisted_names, \"blacklisted_names\": Vec<String>, [\"foo\", \"baz\", \"quux\"].iter().map(ToString::to_string).collect()),"}, {"sha": "9ba39f73ee884e8806576e1d8a19331d19975d49", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -15,6 +15,7 @@ use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::{Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Node, Path, StmtKind, Ty, TyKind};\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n+use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n@@ -247,6 +248,30 @@ declare_clippy_lint! {\n     \"invalid path\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks for interning symbols that have already been pre-interned and defined as constants.\n+    ///\n+    /// **Why is this bad?**\n+    /// It's faster and easier to use the symbol constant.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust,ignore\n+    /// let _ = sym!(f32);\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust,ignore\n+    /// let _ = sym::f32;\n+    /// ```\n+    pub INTERNING_DEFINED_SYMBOL,\n+    internal,\n+    \"interning a symbol that is pre-interned and defined as a constant\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -840,3 +865,56 @@ impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n         }\n     }\n }\n+\n+#[derive(Default)]\n+pub struct InterningDefinedSymbol {\n+    // Maps the symbol value to the constant name.\n+    symbol_map: FxHashMap<u32, String>,\n+}\n+\n+impl_lint_pass!(InterningDefinedSymbol => [INTERNING_DEFINED_SYMBOL]);\n+\n+impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n+    fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n+        if !self.symbol_map.is_empty() {\n+            return;\n+        }\n+\n+        if let Some(Res::Def(_, def_id)) = path_to_res(cx, &paths::SYM_MODULE) {\n+            for item in cx.tcx.item_children(def_id).iter() {\n+                if_chain! {\n+                    if let Res::Def(DefKind::Const, item_def_id) = item.res;\n+                    let ty = cx.tcx.type_of(item_def_id);\n+                    if match_type(cx, ty, &paths::SYMBOL);\n+                    if let Ok(ConstValue::Scalar(value)) = cx.tcx.const_eval_poly(item_def_id);\n+                    if let Ok(value) = value.to_u32();\n+                    then {\n+                        self.symbol_map.insert(value, item.ident.to_string());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Call(func, [arg]) = &expr.kind;\n+            if let ty::FnDef(def_id, _) = cx.typeck_results().expr_ty(func).kind();\n+            if match_def_path(cx, *def_id, &paths::SYMBOL_INTERN);\n+            if let Some(Constant::Str(arg)) = constant_simple(cx, cx.typeck_results(), arg);\n+            let value = Symbol::intern(&arg).as_u32();\n+            if let Some(symbol_const) = self.symbol_map.get(&value);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    INTERNING_DEFINED_SYMBOL,\n+                    is_expn_of(expr.span, \"sym\").unwrap_or(expr.span),\n+                    \"interning a defined symbol\",\n+                    \"try\",\n+                    format!(\"rustc_span::symbol::sym::{}\", symbol_const),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "424856090f261f598dfe200fc7fd65652f6fa04e", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -41,7 +41,7 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::Node;\n use rustc_hir::{\n     def, Arm, Block, Body, Constness, Crate, Expr, ExprKind, FnDecl, HirId, ImplItem, ImplItemKind, Item, ItemKind,\n@@ -603,6 +603,37 @@ pub fn contains_return(expr: &hir::Expr<'_>) -> bool {\n     visitor.found\n }\n \n+struct FindMacroCalls<'a, 'b> {\n+    names: &'a [&'b str],\n+    result: Vec<Span>,\n+}\n+\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for FindMacroCalls<'a, 'b> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.names.iter().any(|fun| is_expn_of(expr.span, fun).is_some()) {\n+            self.result.push(expr.span);\n+        }\n+        // and check sub-expressions\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Finds calls of the specified macros in a function body.\n+pub fn find_macro_calls(names: &[&str], body: &Body<'_>) -> Vec<Span> {\n+    let mut fmc = FindMacroCalls {\n+        names,\n+        result: Vec::new(),\n+    };\n+    fmc.visit_expr(&body.value);\n+    fmc.result\n+}\n+\n /// Converts a span to a code snippet if available, otherwise use default.\n ///\n /// This is useful if you want to provide suggestions for your lint or more generally, if you want\n@@ -1500,7 +1531,7 @@ pub fn is_no_std_crate(krate: &Crate<'_>) -> bool {\n /// ```\n pub fn is_trait_impl_item(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n     if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-        matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), .. })\n+        matches!(item.kind, ItemKind::Impl { of_trait: Some(_), .. })\n     } else {\n         false\n     }"}, {"sha": "2080a49a11cd668ffc27626fd85be35bd9759803", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -146,6 +146,12 @@ pub const STR_FROM_UTF8: [&str; 4] = [\"core\", \"str\", \"converts\", \"from_utf8\"];\n pub const STR_LEN: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"len\"];\n pub const STR_STARTS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"starts_with\"];\n #[cfg(feature = \"internal-lints\")]\n+pub const SYMBOL: [&str; 3] = [\"rustc_span\", \"symbol\", \"Symbol\"];\n+#[cfg(feature = \"internal-lints\")]\n+pub const SYMBOL_INTERN: [&str; 4] = [\"rustc_span\", \"symbol\", \"Symbol\", \"intern\"];\n+#[cfg(feature = \"internal-lints\")]\n+pub const SYM_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"sym\"];\n+#[cfg(feature = \"internal-lints\")]\n pub const SYNTAX_CONTEXT: [&str; 3] = [\"rustc_span\", \"hygiene\", \"SyntaxContext\"];\n pub const TO_OWNED: [&str; 3] = [\"alloc\", \"borrow\", \"ToOwned\"];\n pub const TO_OWNED_METHOD: [&str; 4] = [\"alloc\", \"borrow\", \"ToOwned\", \"to_owned\"];"}, {"sha": "fc0db7f64ec9550dbc0dc830c6fb5c833a2a6a24", "filename": "src/tools/clippy/clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -116,20 +116,27 @@ pub struct ParamBindingIdCollector {\n }\n impl<'tcx> ParamBindingIdCollector {\n     fn collect_binding_hir_ids(body: &'tcx hir::Body<'tcx>) -> Vec<hir::HirId> {\n-        let mut finder = ParamBindingIdCollector {\n-            binding_hir_ids: Vec::new(),\n-        };\n-        finder.visit_body(body);\n-        finder.binding_hir_ids\n+        let mut hir_ids: Vec<hir::HirId> = Vec::new();\n+        for param in body.params.iter() {\n+            let mut finder = ParamBindingIdCollector {\n+                binding_hir_ids: Vec::new(),\n+            };\n+            finder.visit_param(param);\n+            for hir_id in &finder.binding_hir_ids {\n+                hir_ids.push(*hir_id);\n+            }\n+        }\n+        hir_ids\n     }\n }\n impl<'tcx> intravisit::Visitor<'tcx> for ParamBindingIdCollector {\n     type Map = Map<'tcx>;\n \n-    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        if let hir::PatKind::Binding(_, hir_id, ..) = param.pat.kind {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n+        if let hir::PatKind::Binding(_, hir_id, ..) = pat.kind {\n             self.binding_hir_ids.push(hir_id);\n         }\n+        intravisit::walk_pat(self, pat);\n     }\n \n     fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {"}, {"sha": "337f7a229b906c6244cbd265802812289b22b31f", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 70, "deletions": 37, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -75,6 +75,24 @@ declare_clippy_lint! {\n     \"printing on stdout\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for printing on *stderr*. The purpose of this lint\n+    /// is to catch debugging remnants.\n+    ///\n+    /// **Why is this bad?** People often print on *stderr* while debugging an\n+    /// application and might forget to remove those prints afterward.\n+    ///\n+    /// **Known problems:** Only catches `eprint!` and `eprintln!` calls.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// eprintln!(\"Hello world!\");\n+    /// ```\n+    pub PRINT_STDERR,\n+    restriction,\n+    \"printing on stderr\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for use of `Debug` formatting. The purpose of this\n     /// lint is to catch debugging remnants.\n@@ -201,6 +219,7 @@ impl_lint_pass!(Write => [\n     PRINT_WITH_NEWLINE,\n     PRINTLN_EMPTY_STRING,\n     PRINT_STDOUT,\n+    PRINT_STDERR,\n     USE_DEBUG,\n     PRINT_LITERAL,\n     WRITE_WITH_NEWLINE,\n@@ -243,47 +262,22 @@ impl EarlyLintPass for Write {\n                 .map_or(false, |crate_name| crate_name == \"build_script_build\")\n         }\n \n-        if mac.path == sym!(println) {\n-            if !is_build_script(cx) {\n-                span_lint(cx, PRINT_STDOUT, mac.span(), \"use of `println!`\");\n-            }\n-            if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n-                if fmt_str.symbol == Symbol::intern(\"\") {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        PRINTLN_EMPTY_STRING,\n-                        mac.span(),\n-                        \"using `println!(\\\"\\\")`\",\n-                        \"replace it with\",\n-                        \"println!()\".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        } else if mac.path == sym!(print) {\n+        if mac.path == sym!(print) {\n             if !is_build_script(cx) {\n                 span_lint(cx, PRINT_STDOUT, mac.span(), \"use of `print!`\");\n             }\n-            if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n-                if check_newlines(&fmt_str) {\n-                    span_lint_and_then(\n-                        cx,\n-                        PRINT_WITH_NEWLINE,\n-                        mac.span(),\n-                        \"using `print!()` with a format string that ends in a single newline\",\n-                        |err| {\n-                            err.multipart_suggestion(\n-                                \"use `println!` instead\",\n-                                vec![\n-                                    (mac.path.span, String::from(\"println\")),\n-                                    (newline_span(&fmt_str), String::new()),\n-                                ],\n-                                Applicability::MachineApplicable,\n-                            );\n-                        },\n-                    );\n-                }\n+            self.lint_print_with_newline(cx, mac);\n+        } else if mac.path == sym!(println) {\n+            if !is_build_script(cx) {\n+                span_lint(cx, PRINT_STDOUT, mac.span(), \"use of `println!`\");\n             }\n+            self.lint_println_empty_string(cx, mac);\n+        } else if mac.path == sym!(eprint) {\n+            span_lint(cx, PRINT_STDERR, mac.span(), \"use of `eprint!`\");\n+            self.lint_print_with_newline(cx, mac);\n+        } else if mac.path == sym!(eprintln) {\n+            span_lint(cx, PRINT_STDERR, mac.span(), \"use of `eprintln!`\");\n+            self.lint_println_empty_string(cx, mac);\n         } else if mac.path == sym!(write) {\n             if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), true) {\n                 if check_newlines(&fmt_str) {\n@@ -487,6 +481,45 @@ impl Write {\n             }\n         }\n     }\n+\n+    fn lint_println_empty_string(&self, cx: &EarlyContext<'_>, mac: &MacCall) {\n+        if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n+            if fmt_str.symbol == Symbol::intern(\"\") {\n+                let name = mac.path.segments[0].ident.name;\n+                span_lint_and_sugg(\n+                    cx,\n+                    PRINTLN_EMPTY_STRING,\n+                    mac.span(),\n+                    &format!(\"using `{}!(\\\"\\\")`\", name),\n+                    \"replace it with\",\n+                    format!(\"{}!()\", name),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+\n+    fn lint_print_with_newline(&self, cx: &EarlyContext<'_>, mac: &MacCall) {\n+        if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n+            if check_newlines(&fmt_str) {\n+                let name = mac.path.segments[0].ident.name;\n+                let suggested = format!(\"{}ln\", name);\n+                span_lint_and_then(\n+                    cx,\n+                    PRINT_WITH_NEWLINE,\n+                    mac.span(),\n+                    &format!(\"using `{}!()` with a format string that ends in a single newline\", name),\n+                    |err| {\n+                        err.multipart_suggestion(\n+                            &format!(\"use `{}!` instead\", suggested),\n+                            vec![(mac.path.span, suggested), (newline_span(&fmt_str), String::new())],\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n+                );\n+            }\n+        }\n+    }\n }\n \n /// Checks if the format string contains a single newline that terminates it."}, {"sha": "1d5fa8d06a996092ba5ff39d066a68fb40c319c2", "filename": "src/tools/clippy/clippy_lints/src/zero_sized_map_values.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,82 @@\n+use if_chain::if_chain;\n+use rustc_hir::{self as hir, HirId, ItemKind, Node};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{Adt, Ty};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_target::abi::LayoutOf as _;\n+use rustc_typeck::hir_ty_to_ty;\n+\n+use crate::utils::{is_type_diagnostic_item, match_type, paths, span_lint_and_help};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for maps with zero-sized value types anywhere in the code.\n+    ///\n+    /// **Why is this bad?** Since there is only a single value for a zero-sized type, a map\n+    /// containing zero sized values is effectively a set. Using a set in that case improves\n+    /// readability and communicates intent more clearly.\n+    ///\n+    /// **Known problems:**\n+    /// * A zero-sized type cannot be recovered later if it contains private fields.\n+    /// * This lints the signature of public items\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// fn unique_words(text: &str) -> HashMap<&str, ()> {\n+    ///     todo!();\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// fn unique_words(text: &str) -> HashSet<&str> {\n+    ///     todo!();\n+    /// }\n+    /// ```\n+    pub ZERO_SIZED_MAP_VALUES,\n+    pedantic,\n+    \"usage of map with zero-sized value type\"\n+}\n+\n+declare_lint_pass!(ZeroSizedMapValues => [ZERO_SIZED_MAP_VALUES]);\n+\n+impl LateLintPass<'_> for ZeroSizedMapValues {\n+    fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>) {\n+        if_chain! {\n+            if !hir_ty.span.from_expansion();\n+            if !in_trait_impl(cx, hir_ty.hir_id);\n+            let ty = ty_from_hir_ty(cx, hir_ty);\n+            if is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) || match_type(cx, ty, &paths::BTREEMAP);\n+            if let Adt(_, ref substs) = ty.kind();\n+            let ty = substs.type_at(1);\n+            if let Ok(layout) = cx.layout_of(ty);\n+            if layout.is_zst();\n+            then {\n+                span_lint_and_help(cx, ZERO_SIZED_MAP_VALUES, hir_ty.span, \"map with zero-sized value type\", None, \"consider using a set instead\");\n+            }\n+        }\n+    }\n+}\n+\n+fn in_trait_impl(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n+    let parent_id = cx.tcx.hir().get_parent_item(hir_id);\n+    if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_item(parent_id)) {\n+        if let ItemKind::Impl { of_trait: Some(_), .. } = item.kind {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+fn ty_from_hir_ty<'tcx>(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n+    cx.maybe_typeck_results()\n+        .and_then(|results| {\n+            if results.hir_owner == hir_ty.hir_id.owner {\n+                results.node_type_opt(hir_ty.hir_id)\n+            } else {\n+                None\n+            }\n+        })\n+        .unwrap_or_else(|| hir_ty_to_ty(cx.tcx, hir_ty))\n+}"}, {"sha": "85a91cd2decd59ffdad366977375be13f2fe52a5", "filename": "src/tools/clippy/clippy_workspace_tests/path_dep/Cargo.toml", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fpath_dep%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fpath_dep%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fpath_dep%2FCargo.toml?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,3 @@\n+[package]\n+name = \"path_dep\"\n+version = \"0.1.0\""}, {"sha": "35ce524f2b10c367c0b3d71e4449f05458542261", "filename": "src/tools/clippy/clippy_workspace_tests/path_dep/src/lib.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fpath_dep%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fpath_dep%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fpath_dep%2Fsrc%2Flib.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,6 @@\n+#![deny(clippy::empty_loop)]\n+\n+#[cfg(feature = \"primary_package_test\")]\n+pub fn lint_me() {\n+    loop {}\n+}"}, {"sha": "45362c11b856e3615cfa77348c12b251d127526b", "filename": "src/tools/clippy/clippy_workspace_tests/subcrate/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fsubcrate%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fsubcrate%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_workspace_tests%2Fsubcrate%2FCargo.toml?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,3 +1,6 @@\n [package]\n name = \"subcrate\"\n version = \"0.1.0\"\n+\n+[dependencies]\n+path_dep = { path = \"../path_dep\" }"}, {"sha": "60dfdb76650a1e2d0363ecd5786560a9da9990a2", "filename": "src/tools/clippy/doc/adding_lints.md", "status": "modified", "additions": 60, "deletions": 10, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fadding_lints.md?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -98,12 +98,12 @@ While we are working on implementing our lint, we can keep running the UI\n test. That allows us to check if the output is turning into what we want.\n \n Once we are satisfied with the output, we need to run\n-`tests/ui/update-all-references.sh` to update the `.stderr` file for our lint.\n+`cargo dev bless` to update the `.stderr` file for our lint.\n Please note that, we should run `TESTNAME=foo_functions cargo uitest`\n-every time before running `tests/ui/update-all-references.sh`.\n+every time before running `cargo dev bless`.\n Running `TESTNAME=foo_functions cargo uitest` should pass then. When we commit\n our lint, we need to commit the generated `.stderr` files, too. In general, you\n-should only commit files changed by `tests/ui/update-all-references.sh` for the\n+should only commit files changed by `cargo dev bless` for the\n specific lint you are creating/editing. Note that if the generated files are\n empty, they should be removed.\n \n@@ -122,8 +122,7 @@ we will find by default two new crates, each with its manifest file:\n If you need more cases, you can copy one of those crates (under `foo_categories`) and rename it.\n \n The process of generating the `.stderr` file is the same, and prepending the `TESTNAME`\n-variable to `cargo uitest` works too, but the script to update the references\n-is in another path: `tests/ui-cargo/update-all-references.sh`.\n+variable to `cargo uitest` works too.\n \n ## Rustfix tests\n \n@@ -133,7 +132,7 @@ additionally run [rustfix] for that test. Rustfix will apply the suggestions\n from the lint to the code of the test file and compare that to the contents of\n a `.fixed` file.\n \n-Use `tests/ui/update-all-references.sh` to automatically generate the\n+Use `cargo dev bless` to automatically generate the\n `.fixed` file after running the tests.\n \n [rustfix]: https://github.com/rust-lang/rustfix\n@@ -226,13 +225,13 @@ store.register_early_pass(|| box foo_functions::FooFunctions);\n ```\n \n As one may expect, there is a corresponding `register_late_pass` method\n-available as well. Without a call to one of `register_early_pass` or \n+available as well. Without a call to one of `register_early_pass` or\n `register_late_pass`, the lint pass in question will not be run.\n \n-One reason that `cargo dev` does not automate this step is that multiple lints \n+One reason that `cargo dev` does not automate this step is that multiple lints\n can use the same lint pass, so registering the lint pass may already be done\n when adding a new lint. Another reason that this step is not automated is that\n-the order that the passes are registered determines the order the passes \n+the order that the passes are registered determines the order the passes\n actually run, which in turn affects the order that any emitted lints are output\n in.\n \n@@ -368,7 +367,7 @@ fn is_foo_fn(fn_kind: FnKind<'_>) -> bool {\n \n Now we should also run the full test suite with `cargo test`. At this point\n running `cargo test` should produce the expected output. Remember to run\n-`tests/ui/update-all-references.sh` to update the `.stderr` file.\n+`cargo dev bless` to update the `.stderr` file.\n \n `cargo test` (as opposed to `cargo uitest`) will also ensure that our lint\n implementation is not violating any Clippy lints itself.\n@@ -380,6 +379,57 @@ pass.\n [`FnKind::Fn`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/visit/enum.FnKind.html#variant.Fn\n [ident]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Ident.html\n \n+## Specifying the lint's minimum supported Rust version (msrv)\n+\n+Projects supporting older versions of Rust would need to disable a lint if it targets features\n+present in later versions. Support for this can be added by specifying an msrv in your lint like so,\n+\n+```rust\n+const MANUAL_STRIP_MSRV: RustcVersion = RustcVersion::new(1, 45, 0);\n+```\n+\n+The project's msrv will also have to be an attribute in the lint so you'll have to add a struct\n+and constructor for your lint. The project's msrv needs to be passed when the lint is registered\n+in `lib.rs`\n+\n+```rust\n+pub struct ManualStrip {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl ManualStrip {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+```\n+\n+The project's msrv can then be matched against the lint's msrv in the LintPass using the `meets_msrv` utility\n+function.\n+\n+``` rust\n+if !meets_msrv(self.msrv.as_ref(), &MANUAL_STRIP_MSRV) {\n+    return;\n+}\n+```\n+\n+The project's msrv can also be specified as an inner attribute, which overrides the value from\n+`clippy.toml`. This can be accounted for using the `extract_msrv_attr!(LintContext)` macro and passing\n+LateContext/EarlyContext.\n+\n+```rust\n+impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        ...\n+    }\n+    extract_msrv_attr!(LateContext);\n+}\n+```\n+\n+Once the msrv is added to the lint, a relevant test case should be added to `tests/ui/min_rust_version_attr.rs`\n+which verifies that the lint isn't emitted if the project's msrv is lower.\n+\n ## Author lint\n \n If you have trouble implementing your lint, there is also the internal `author`"}, {"sha": "954474a17aa8e35b31bafc2765f08ab2a14781aa", "filename": "src/tools/clippy/doc/basics.md", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fdoc%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fdoc%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fbasics.md?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,16 +1,14 @@\n # Basics for hacking on Clippy\n \n This document explains the basics for hacking on Clippy. Besides others, this\n-includes how to set-up the development environment, how to build and how to test\n-Clippy. For a more in depth description on the codebase take a look at [Adding\n-Lints] or [Common Tools].\n+includes how to build and test Clippy. For a more in depth description on\n+the codebase take a look at [Adding Lints] or [Common Tools].\n \n [Adding Lints]: https://github.com/rust-lang/rust-clippy/blob/master/doc/adding_lints.md\n [Common Tools]: https://github.com/rust-lang/rust-clippy/blob/master/doc/common_tools_writing_lints.md\n \n - [Basics for hacking on Clippy](#basics-for-hacking-on-clippy)\n-  - [Get the code](#get-the-code)\n-  - [Setup](#setup)\n+  - [Get the Code](#get-the-code)\n   - [Building and Testing](#building-and-testing)\n   - [`cargo dev`](#cargo-dev)\n   - [PR](#pr)\n@@ -38,29 +36,9 @@ git rebase upstream/master\n git push\n ```\n \n-## Setup\n-\n-Next we need to setup the toolchain to compile Clippy. Since Clippy heavily\n-relies on compiler internals it is build with the latest rustc master. To get\n-this toolchain, you can just use the `setup-toolchain.sh` script or use\n-`rustup-toolchain-install-master`:\n-\n-```bash\n-bash setup-toolchain.sh\n-# OR\n-cargo install rustup-toolchain-install-master\n-# For better IDE integration also add `-c rustfmt -c rust-src` (optional)\n-rustup-toolchain-install-master -f -n master -c rustc-dev -c llvm-tools\n-rustup override set master\n-```\n-\n-_Note:_ Sometimes you may get compiler errors when building Clippy, even if you\n-didn't change anything. Normally those will be fixed by a maintainer in a few hours. \n-\n ## Building and Testing\n \n-Once the `master` toolchain is installed, you can build and test Clippy like\n-every other Rust project:\n+You can build and test Clippy like every other Rust project:\n \n ```bash\n cargo build  # builds Clippy\n@@ -83,7 +61,7 @@ If the output of a [UI test] differs from the expected output, you can update th\n reference file with:\n \n ```bash\n-sh tests/ui/update-all-references.sh\n+cargo dev bless\n ```\n \n For example, this is necessary, if you fix a typo in an error message of a lint\n@@ -109,7 +87,7 @@ cargo dev update_lints\n # create a new lint and register it\n cargo dev new_lint\n # (experimental) Setup Clippy to work with rust-analyzer\n-cargo dev ra-setup\n+cargo dev ra_setup\n ```\n \n ## PR"}, {"sha": "d2e84132f4ed9baee6717728dced000c97015530", "filename": "src/tools/clippy/rust-toolchain", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frust-toolchain?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1 +1,3 @@\n-nightly\n+[toolchain]\n+channel = \"nightly-2020-12-20\"\n+components = [\"llvm-tools-preview\", \"rustc-dev\", \"rust-src\", \"rustfmt\"]"}, {"sha": "191ea4315a6b5a8a29e56f6440f88115c466e8b9", "filename": "src/tools/clippy/setup-toolchain.sh", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c8135455c4a96b1d2570198619f38185c063579d/src%2Ftools%2Fclippy%2Fsetup-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c8135455c4a96b1d2570198619f38185c063579d/src%2Ftools%2Fclippy%2Fsetup-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsetup-toolchain.sh?ref=c8135455c4a96b1d2570198619f38185c063579d", "patch": "@@ -1,36 +0,0 @@\n-#!/usr/bin/env bash\n-# Set up the appropriate rustc toolchain\n-\n-set -e\n-\n-cd \"$(dirname \"$0\")\"\n-\n-RTIM_PATH=$(command -v rustup-toolchain-install-master) || INSTALLED=false\n-CARGO_HOME=${CARGO_HOME:-$HOME/.cargo}\n-\n-# Check if RTIM is not installed or installed in other locations not in ~/.cargo/bin\n-if [[ \"$INSTALLED\" == false || \"$RTIM_PATH\" == $CARGO_HOME/bin/rustup-toolchain-install-master ]]; then\n-    cargo +nightly install rustup-toolchain-install-master\n-else\n-    VERSION=$(rustup-toolchain-install-master -V | grep -o \"[0-9.]*\")\n-    REMOTE=$(cargo +nightly search rustup-toolchain-install-master | grep -o \"[0-9.]*\")\n-    echo \"info: skipping updating rustup-toolchain-install-master at $RTIM_PATH\"\n-    echo \"      current version : $VERSION\"\n-    echo \"      remote version  : $REMOTE\"\n-fi\n-\n-RUST_COMMIT=$(git ls-remote https://github.com/rust-lang/rust master | awk '{print $1}')\n-\n-if rustc +master -Vv 2>/dev/null | grep -q \"$RUST_COMMIT\"; then\n-    echo \"info: master toolchain is up-to-date\"\n-    exit 0\n-fi\n-\n-if [[ -n \"$HOST_TOOLCHAIN\" ]]; then\n-    TOOLCHAIN=('--host' \"$HOST_TOOLCHAIN\")\n-else\n-    TOOLCHAIN=()\n-fi\n-\n-rustup-toolchain-install-master -f -n master \"${TOOLCHAIN[@]}\" -c rustc-dev -c llvm-tools -- \"$RUST_COMMIT\"\n-rustup override set master"}, {"sha": "40f1b802e60e6aeeabec3fa11539c672c4a97cdd", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 107, "deletions": 37, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,5 +1,6 @@\n #![feature(rustc_private)]\n #![feature(once_cell)]\n+#![feature(bool_to_option)]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n // warn on lints, that are included in `rust-lang/rust`s bootstrap\n #![warn(rust_2018_idioms, unused_lifetimes)]\n@@ -19,6 +20,7 @@ use rustc_tools_util::VersionInfo;\n \n use std::borrow::Cow;\n use std::env;\n+use std::iter;\n use std::lazy::SyncLazy;\n use std::ops::Deref;\n use std::panic;\n@@ -41,26 +43,12 @@ fn arg_value<'a, T: Deref<Target = str>>(\n \n         match arg.next().or_else(|| args.next()) {\n             Some(v) if pred(v) => return Some(v),\n-            _ => {}\n+            _ => {},\n         }\n     }\n     None\n }\n \n-#[test]\n-fn test_arg_value() {\n-    let args = &[\"--bar=bar\", \"--foobar\", \"123\", \"--foo\"];\n-\n-    assert_eq!(arg_value(&[] as &[&str], \"--foobar\", |_| true), None);\n-    assert_eq!(arg_value(args, \"--bar\", |_| false), None);\n-    assert_eq!(arg_value(args, \"--bar\", |_| true), Some(\"bar\"));\n-    assert_eq!(arg_value(args, \"--bar\", |p| p == \"bar\"), Some(\"bar\"));\n-    assert_eq!(arg_value(args, \"--bar\", |p| p == \"foo\"), None);\n-    assert_eq!(arg_value(args, \"--foobar\", |p| p == \"foo\"), None);\n-    assert_eq!(arg_value(args, \"--foobar\", |p| p == \"123\"), Some(\"123\"));\n-    assert_eq!(arg_value(args, \"--foo\", |_| true), None);\n-}\n-\n struct DefaultCallbacks;\n impl rustc_driver::Callbacks for DefaultCallbacks {}\n \n@@ -121,12 +109,11 @@ You can use tool lints to allow or deny lints from your code, eg.:\n \n const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust-clippy/issues/new\";\n \n-static ICE_HOOK: SyncLazy<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> =\n-    SyncLazy::new(|| {\n-        let hook = panic::take_hook();\n-        panic::set_hook(Box::new(|info| report_clippy_ice(info, BUG_REPORT_URL)));\n-        hook\n-    });\n+static ICE_HOOK: SyncLazy<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> = SyncLazy::new(|| {\n+    let hook = panic::take_hook();\n+    panic::set_hook(Box::new(|info| report_clippy_ice(info, BUG_REPORT_URL)));\n+    hook\n+});\n \n fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     // Invoke our ICE handler, which prints the actual panic message and optionally a backtrace\n@@ -183,6 +170,29 @@ fn toolchain_path(home: Option<String>, toolchain: Option<String>) -> Option<Pat\n     })\n }\n \n+fn remove_clippy_args<'a, T, U, I>(args: &mut Vec<T>, clippy_args: I)\n+where\n+    T: AsRef<str>,\n+    U: AsRef<str> + ?Sized + 'a,\n+    I: Iterator<Item = &'a U> + Clone,\n+{\n+    let args_iter = clippy_args.map(AsRef::as_ref);\n+    let args_count = args_iter.clone().count();\n+\n+    if args_count > 0 {\n+        if let Some(start) = args.windows(args_count).enumerate().find_map(|(current, window)| {\n+            window\n+                .iter()\n+                .map(AsRef::as_ref)\n+                .eq(args_iter.clone())\n+                .then_some(current)\n+        }) {\n+            args.drain(start..start + args_count);\n+        }\n+    }\n+}\n+\n+#[allow(clippy::too_many_lines)]\n pub fn main() {\n     rustc_driver::init_rustc_env_logger();\n     SyncLazy::force(&ICE_HOOK);\n@@ -258,17 +268,14 @@ pub fn main() {\n \n         // Setting RUSTC_WRAPPER causes Cargo to pass 'rustc' as the first argument.\n         // We're invoking the compiler programmatically, so we ignore this/\n-        let wrapper_mode =\n-            orig_args.get(1).map(Path::new).and_then(Path::file_stem) == Some(\"rustc\".as_ref());\n+        let wrapper_mode = orig_args.get(1).map(Path::new).and_then(Path::file_stem) == Some(\"rustc\".as_ref());\n \n         if wrapper_mode {\n             // we still want to be able to invoke it normally though\n             orig_args.remove(1);\n         }\n \n-        if !wrapper_mode\n-            && (orig_args.iter().any(|a| a == \"--help\" || a == \"-h\") || orig_args.len() == 1)\n-        {\n+        if !wrapper_mode && (orig_args.iter().any(|a| a == \"--help\" || a == \"-h\") || orig_args.len() == 1) {\n             display_help();\n             exit(0);\n         }\n@@ -281,25 +288,88 @@ pub fn main() {\n             args.extend(vec![\"--sysroot\".into(), sys_root]);\n         };\n \n-        // this check ensures that dependencies are built but not linted and the final\n-        // crate is linted but not built\n-        let clippy_enabled = env::var(\"CLIPPY_TESTS\").map_or(false, |val| val == \"true\")\n-            || arg_value(&orig_args, \"--cap-lints\", |val| val == \"allow\").is_none();\n+        let clippy_args = env::var(\"CLIPPY_ARGS\").unwrap_or_default();\n+        let clippy_args = clippy_args.split_whitespace();\n+        let no_deps = clippy_args.clone().any(|flag| flag == \"--no-deps\");\n+\n+        // We enable Clippy if one of the following conditions is met\n+        // - IF Clippy is run on its test suite OR\n+        // - IF Clippy is run on the main crate, not on deps (`!cap_lints_allow`) THEN\n+        //    - IF `--no-deps` is not set (`!no_deps`) OR\n+        //    - IF `--no-deps` is set and Clippy is run on the specified primary package\n+        let clippy_tests_set = env::var(\"CLIPPY_TESTS\").map_or(false, |val| val == \"true\");\n+        let cap_lints_allow = arg_value(&orig_args, \"--cap-lints\", |val| val == \"allow\").is_some();\n+        let in_primary_package = env::var(\"CARGO_PRIMARY_PACKAGE\").is_ok();\n \n+        let clippy_enabled = clippy_tests_set || (!cap_lints_allow && (!no_deps || in_primary_package));\n         if clippy_enabled {\n+            remove_clippy_args(&mut args, iter::once(\"--no-deps\"));\n             args.extend(vec![\"--cfg\".into(), r#\"feature=\"cargo-clippy\"\"#.into()]);\n-            if let Ok(extra_args) = env::var(\"CLIPPY_ARGS\") {\n-                args.extend(\n-                    extra_args\n-                        .split(\"__CLIPPY_HACKERY__\")\n-                        .filter_map(|s| if s.is_empty() { None } else { Some(s.to_string()) }),\n-                );\n-            }\n+        } else {\n+            // Remove all flags passed through RUSTFLAGS if Clippy is not enabled.\n+            remove_clippy_args(&mut args, clippy_args);\n         }\n+\n         let mut clippy = ClippyCallbacks;\n         let mut default = DefaultCallbacks;\n         let callbacks: &mut (dyn rustc_driver::Callbacks + Send) =\n             if clippy_enabled { &mut clippy } else { &mut default };\n+\n         rustc_driver::RunCompiler::new(&args, callbacks).run()\n     }))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_arg_value() {\n+        let args = &[\"--bar=bar\", \"--foobar\", \"123\", \"--foo\"];\n+\n+        assert_eq!(arg_value(&[] as &[&str], \"--foobar\", |_| true), None);\n+        assert_eq!(arg_value(args, \"--bar\", |_| false), None);\n+        assert_eq!(arg_value(args, \"--bar\", |_| true), Some(\"bar\"));\n+        assert_eq!(arg_value(args, \"--bar\", |p| p == \"bar\"), Some(\"bar\"));\n+        assert_eq!(arg_value(args, \"--bar\", |p| p == \"foo\"), None);\n+        assert_eq!(arg_value(args, \"--foobar\", |p| p == \"foo\"), None);\n+        assert_eq!(arg_value(args, \"--foobar\", |p| p == \"123\"), Some(\"123\"));\n+        assert_eq!(arg_value(args, \"--foo\", |_| true), None);\n+    }\n+\n+    #[test]\n+    fn removes_clippy_args_from_start() {\n+        let mut args = vec![\"-D\", \"clippy::await_holding_lock\", \"--cfg\", r#\"feature=\"some_feat\"\"#];\n+        let clippy_args = [\"-D\", \"clippy::await_holding_lock\"].iter();\n+\n+        remove_clippy_args(&mut args, clippy_args);\n+        assert_eq!(args, &[\"--cfg\", r#\"feature=\"some_feat\"\"#]);\n+    }\n+\n+    #[test]\n+    fn removes_clippy_args_from_end() {\n+        let mut args = vec![\"-Zui-testing\", \"-A\", \"clippy::empty_loop\", \"--no-deps\"];\n+        let clippy_args = [\"-A\", \"clippy::empty_loop\", \"--no-deps\"].iter();\n+\n+        remove_clippy_args(&mut args, clippy_args);\n+        assert_eq!(args, &[\"-Zui-testing\"]);\n+    }\n+\n+    #[test]\n+    fn removes_clippy_args_from_middle() {\n+        let mut args = vec![\"-Zui-testing\", \"-W\", \"clippy::filter_map\", \"-L\", \"serde\"];\n+        let clippy_args = [\"-W\", \"clippy::filter_map\"].iter();\n+\n+        remove_clippy_args(&mut args, clippy_args);\n+        assert_eq!(args, &[\"-Zui-testing\", \"-L\", \"serde\"]);\n+    }\n+\n+    #[test]\n+    fn no_clippy_args_to_remove() {\n+        let mut args = vec![\"-Zui-testing\", \"-L\", \"serde\"];\n+        let clippy_args: [&str; 0] = [];\n+\n+        remove_clippy_args(&mut args, clippy_args.iter());\n+        assert_eq!(args, &[\"-Zui-testing\", \"-L\", \"serde\"]);\n+    }\n+}"}, {"sha": "1c0e04689a9fe495edbfc7ef1a276a9d524ba2b6", "filename": "src/tools/clippy/src/main.rs", "status": "modified", "additions": 100, "deletions": 6, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fmain.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,3 +1,5 @@\n+#![feature(bool_to_option)]\n+#![feature(command_access)]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n // warn on lints, that are included in `rust-lang/rust`s bootstrap\n #![warn(rust_2018_idioms, unused_lifetimes)]\n@@ -62,7 +64,7 @@ struct ClippyCmd {\n     unstable_options: bool,\n     cargo_subcommand: &'static str,\n     args: Vec<String>,\n-    clippy_args: String,\n+    clippy_args: Option<String>,\n }\n \n impl ClippyCmd {\n@@ -99,13 +101,17 @@ impl ClippyCmd {\n             args.insert(0, \"+nightly\".to_string());\n         }\n \n-        let clippy_args: String = old_args.map(|arg| format!(\"{}__CLIPPY_HACKERY__\", arg)).collect();\n+        let mut clippy_args = old_args.collect::<Vec<String>>().join(\" \");\n+        if cargo_subcommand == \"fix\" && !clippy_args.contains(\"--no-deps\") {\n+            clippy_args = format!(\"{} --no-deps\", clippy_args);\n+        }\n \n+        let has_args = !clippy_args.is_empty();\n         ClippyCmd {\n             unstable_options,\n             cargo_subcommand,\n             args,\n-            clippy_args,\n+            clippy_args: has_args.then_some(clippy_args),\n         }\n     }\n \n@@ -145,15 +151,24 @@ impl ClippyCmd {\n             .map(|p| (\"CARGO_TARGET_DIR\", p))\n     }\n \n-    fn into_std_cmd(self) -> Command {\n+    fn into_std_cmd(self, rustflags: Option<String>) -> Command {\n         let mut cmd = Command::new(\"cargo\");\n \n         cmd.env(self.path_env(), Self::path())\n             .envs(ClippyCmd::target_dir())\n-            .env(\"CLIPPY_ARGS\", self.clippy_args)\n             .arg(self.cargo_subcommand)\n             .args(&self.args);\n \n+        // HACK: pass Clippy args to the driver *also* through RUSTFLAGS.\n+        // This guarantees that new builds will be triggered when Clippy flags change.\n+        if let Some(clippy_args) = self.clippy_args {\n+            cmd.env(\n+                \"RUSTFLAGS\",\n+                rustflags.map_or(clippy_args.clone(), |flags| format!(\"{} {}\", clippy_args, flags)),\n+            );\n+            cmd.env(\"CLIPPY_ARGS\", clippy_args);\n+        }\n+\n         cmd\n     }\n }\n@@ -164,7 +179,7 @@ where\n {\n     let cmd = ClippyCmd::new(old_args);\n \n-    let mut cmd = cmd.into_std_cmd();\n+    let mut cmd = cmd.into_std_cmd(env::var(\"RUSTFLAGS\").ok());\n \n     let exit_status = cmd\n         .spawn()\n@@ -182,6 +197,7 @@ where\n #[cfg(test)]\n mod tests {\n     use super::ClippyCmd;\n+    use std::ffi::OsStr;\n \n     #[test]\n     #[should_panic]\n@@ -196,15 +212,37 @@ mod tests {\n             .split_whitespace()\n             .map(ToString::to_string);\n         let cmd = ClippyCmd::new(args);\n+\n         assert_eq!(\"fix\", cmd.cargo_subcommand);\n         assert_eq!(\"RUSTC_WORKSPACE_WRAPPER\", cmd.path_env());\n         assert!(cmd.args.iter().any(|arg| arg.ends_with(\"unstable-options\")));\n     }\n \n+    #[test]\n+    fn fix_implies_no_deps() {\n+        let args = \"cargo clippy --fix -Zunstable-options\"\n+            .split_whitespace()\n+            .map(ToString::to_string);\n+        let cmd = ClippyCmd::new(args);\n+\n+        assert!(cmd.clippy_args.unwrap().contains(\"--no-deps\"));\n+    }\n+\n+    #[test]\n+    fn no_deps_not_duplicated_with_fix() {\n+        let args = \"cargo clippy --fix -Zunstable-options -- --no-deps\"\n+            .split_whitespace()\n+            .map(ToString::to_string);\n+        let cmd = ClippyCmd::new(args);\n+\n+        assert_eq!(1, cmd.clippy_args.unwrap().matches(\"--no-deps\").count());\n+    }\n+\n     #[test]\n     fn check() {\n         let args = \"cargo clippy\".split_whitespace().map(ToString::to_string);\n         let cmd = ClippyCmd::new(args);\n+\n         assert_eq!(\"check\", cmd.cargo_subcommand);\n         assert_eq!(\"RUSTC_WRAPPER\", cmd.path_env());\n     }\n@@ -215,7 +253,63 @@ mod tests {\n             .split_whitespace()\n             .map(ToString::to_string);\n         let cmd = ClippyCmd::new(args);\n+\n         assert_eq!(\"check\", cmd.cargo_subcommand);\n         assert_eq!(\"RUSTC_WORKSPACE_WRAPPER\", cmd.path_env());\n     }\n+\n+    #[test]\n+    fn clippy_args_into_rustflags() {\n+        let args = \"cargo clippy -- -W clippy::as_conversions\"\n+            .split_whitespace()\n+            .map(ToString::to_string);\n+        let cmd = ClippyCmd::new(args);\n+\n+        let rustflags = None;\n+        let cmd = cmd.into_std_cmd(rustflags);\n+\n+        assert!(cmd\n+            .get_envs()\n+            .any(|(key, val)| key == \"RUSTFLAGS\" && val == Some(OsStr::new(\"-W clippy::as_conversions\"))));\n+    }\n+\n+    #[test]\n+    fn clippy_args_respect_existing_rustflags() {\n+        let args = \"cargo clippy -- -D clippy::await_holding_lock\"\n+            .split_whitespace()\n+            .map(ToString::to_string);\n+        let cmd = ClippyCmd::new(args);\n+\n+        let rustflags = Some(r#\"--cfg feature=\"some_feat\"\"#.into());\n+        let cmd = cmd.into_std_cmd(rustflags);\n+\n+        assert!(cmd.get_envs().any(|(key, val)| key == \"RUSTFLAGS\"\n+            && val == Some(OsStr::new(r#\"-D clippy::await_holding_lock --cfg feature=\"some_feat\"\"#))));\n+    }\n+\n+    #[test]\n+    fn no_env_change_if_no_clippy_args() {\n+        let args = \"cargo clippy\".split_whitespace().map(ToString::to_string);\n+        let cmd = ClippyCmd::new(args);\n+\n+        let rustflags = Some(r#\"--cfg feature=\"some_feat\"\"#.into());\n+        let cmd = cmd.into_std_cmd(rustflags);\n+\n+        assert!(!cmd\n+            .get_envs()\n+            .any(|(key, _)| key == \"RUSTFLAGS\" || key == \"CLIPPY_ARGS\"));\n+    }\n+\n+    #[test]\n+    fn no_env_change_if_no_clippy_args_nor_rustflags() {\n+        let args = \"cargo clippy\".split_whitespace().map(ToString::to_string);\n+        let cmd = ClippyCmd::new(args);\n+\n+        let rustflags = None;\n+        let cmd = cmd.into_std_cmd(rustflags);\n+\n+        assert!(!cmd\n+            .get_envs()\n+            .any(|(key, _)| key == \"RUSTFLAGS\" || key == \"CLIPPY_ARGS\"))\n+    }\n }"}, {"sha": "fda1413868e82549eb76bfc2ce699fe0aa419f46", "filename": "src/tools/clippy/tests/dogfood.rs", "status": "modified", "additions": 71, "deletions": 2, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fdogfood.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -3,7 +3,7 @@\n #![feature(once_cell)]\n \n use std::lazy::SyncLazy;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n \n mod cargo;\n@@ -23,7 +23,7 @@ fn dogfood_clippy() {\n         .current_dir(root_dir)\n         .env(\"CLIPPY_DOGFOOD\", \"1\")\n         .env(\"CARGO_INCREMENTAL\", \"0\")\n-        .arg(\"clippy-preview\")\n+        .arg(\"clippy\")\n         .arg(\"--all-targets\")\n         .arg(\"--all-features\")\n         .arg(\"--\")\n@@ -47,12 +47,77 @@ fn dogfood_clippy() {\n \n #[test]\n fn dogfood_subprojects() {\n+    fn test_no_deps_ignores_path_deps_in_workspaces() {\n+        fn clean(cwd: &Path, target_dir: &Path) {\n+            Command::new(\"cargo\")\n+                .current_dir(cwd)\n+                .env(\"CARGO_TARGET_DIR\", target_dir)\n+                .arg(\"clean\")\n+                .args(&[\"-p\", \"subcrate\"])\n+                .args(&[\"-p\", \"path_dep\"])\n+                .output()\n+                .unwrap();\n+        }\n+\n+        if cargo::is_rustc_test_suite() {\n+            return;\n+        }\n+        let root = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n+        let target_dir = root.join(\"target\").join(\"dogfood\");\n+        let cwd = root.join(\"clippy_workspace_tests\");\n+\n+        // Make sure we start with a clean state\n+        clean(&cwd, &target_dir);\n+\n+        // `path_dep` is a path dependency of `subcrate` that would trigger a denied lint.\n+        // Make sure that with the `--no-deps` argument Clippy does not run on `path_dep`.\n+        let output = Command::new(&*CLIPPY_PATH)\n+            .current_dir(&cwd)\n+            .env(\"CLIPPY_DOGFOOD\", \"1\")\n+            .env(\"CARGO_INCREMENTAL\", \"0\")\n+            .arg(\"clippy\")\n+            .args(&[\"-p\", \"subcrate\"])\n+            .arg(\"--\")\n+            .arg(\"--no-deps\")\n+            .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n+            .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n+            .output()\n+            .unwrap();\n+        println!(\"status: {}\", output.status);\n+        println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n+        println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n+\n+        assert!(output.status.success());\n+\n+        // Make sure we start with a clean state\n+        clean(&cwd, &target_dir);\n+\n+        // Test that without the `--no-deps` argument, `path_dep` is linted.\n+        let output = Command::new(&*CLIPPY_PATH)\n+            .current_dir(&cwd)\n+            .env(\"CLIPPY_DOGFOOD\", \"1\")\n+            .env(\"CARGO_INCREMENTAL\", \"0\")\n+            .arg(\"clippy\")\n+            .args(&[\"-p\", \"subcrate\"])\n+            .arg(\"--\")\n+            .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n+            .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n+            .output()\n+            .unwrap();\n+        println!(\"status: {}\", output.status);\n+        println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n+        println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n+\n+        assert!(!output.status.success());\n+    }\n+\n     // run clippy on remaining subprojects and fail the test if lint warnings are reported\n     if cargo::is_rustc_test_suite() {\n         return;\n     }\n     let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n \n+    // NOTE: `path_dep` crate is omitted on purpose here\n     for d in &[\n         \"clippy_workspace_tests\",\n         \"clippy_workspace_tests/src\",\n@@ -78,4 +143,8 @@ fn dogfood_subprojects() {\n \n         assert!(output.status.success());\n     }\n+\n+    // NOTE: Since tests run in parallel we can't run cargo commands on the same workspace at the\n+    // same time, so we test this immediately after the dogfood for workspaces.\n+    test_no_deps_ignores_path_deps_in_workspaces();\n }"}, {"sha": "1718089e8bd27db39c2d7e4c64d15810547b988d", "filename": "src/tools/clippy/tests/integration.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fintegration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fintegration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fintegration.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -72,6 +72,8 @@ fn integration_test() {\n         panic!(\"incompatible crate versions\");\n     } else if stderr.contains(\"failed to run `rustc` to learn about target-specific information\") {\n         panic!(\"couldn't find librustc_driver, consider setting `LD_LIBRARY_PATH`\");\n+    } else if stderr.contains(\"toolchain\") && stderr.contains(\"is not installed\") {\n+        panic!(\"missing required toolchain\");\n     }\n \n     match output.status.code() {"}, {"sha": "4391499a1e1f8e779470f3d1927dcd95c88eadd1", "filename": "src/tools/clippy/tests/ui-cargo/update-all-references.sh", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fupdate-all-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fupdate-all-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fupdate-all-references.sh?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,18 +1,3 @@\n #!/bin/bash\n-#\n-# A script to update the references for all tests. The idea is that\n-# you do a run, which will generate files in the build directory\n-# containing the (normalized) actual output of the compiler. You then\n-# run this script, which will copy those files over. If you find\n-# yourself manually editing a foo.stderr file, you're doing it wrong.\n-#\n-# See all `update-references.sh`, if you just want to update a single test.\n \n-if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" ]]; then\n-    echo \"usage: $0\"\n-fi\n-\n-BUILD_DIR=$PWD/target/debug/test_build_base\n-MY_DIR=$(dirname \"$0\")\n-cd \"$MY_DIR\" || exit\n-find . -name '*.rs' -exec ./update-references.sh \"$BUILD_DIR\" {} +\n+echo \"Please use 'cargo dev bless' instead.\""}, {"sha": "2ab51168bcaa61c4fd96d093a6e3adf50371ae9d", "filename": "src/tools/clippy/tests/ui-cargo/update-references.sh", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c8135455c4a96b1d2570198619f38185c063579d/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c8135455c4a96b1d2570198619f38185c063579d/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fupdate-references.sh?ref=c8135455c4a96b1d2570198619f38185c063579d", "patch": "@@ -1,46 +0,0 @@\n-#!/bin/bash\n-\n-# A script to update the references for particular tests. The idea is\n-# that you do a run, which will generate files in the build directory\n-# containing the (normalized) actual output of the compiler. This\n-# script will then copy that output and replace the \"expected output\"\n-# files. You can then commit the changes.\n-#\n-# If you find yourself manually editing a foo.stderr file, you're\n-# doing it wrong.\n-\n-if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" || \"$1\" == \"\" || \"$2\" == \"\" ]]; then\n-    echo \"usage: $0 <build-directory> <relative-path-to-rs-files>\"\n-    echo \"\"\n-    echo \"For example:\"\n-    echo \"   $0 ../../../build/x86_64-apple-darwin/test/ui *.rs */*.rs\"\n-fi\n-\n-MYDIR=$(dirname \"$0\")\n-\n-BUILD_DIR=\"$1\"\n-shift\n-\n-while [[ \"$1\" != \"\" ]]; do\n-    STDERR_NAME=\"${1/%.rs/.stderr}\"\n-    STDOUT_NAME=\"${1/%.rs/.stdout}\"\n-    shift\n-    if [[ -f \"$BUILD_DIR\"/\"$STDOUT_NAME\" ]] && \\\n-           ! (cmp -s -- \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"); then\n-        echo updating \"$MYDIR\"/\"$STDOUT_NAME\"\n-        cp \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"\n-        if [[ ! -s \"$MYDIR\"/\"$STDOUT_NAME\" ]]; then\n-            echo removing \"$MYDIR\"/\"$STDOUT_NAME\"\n-            rm \"$MYDIR\"/\"$STDOUT_NAME\"\n-        fi\n-    fi\n-    if [[ -f \"$BUILD_DIR\"/\"$STDERR_NAME\" ]] && \\\n-           ! (cmp -s -- \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"); then\n-        echo updating \"$MYDIR\"/\"$STDERR_NAME\"\n-        cp \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"\n-        if [[ ! -s \"$MYDIR\"/\"$STDERR_NAME\" ]]; then\n-            echo removing \"$MYDIR\"/\"$STDERR_NAME\"\n-            rm \"$MYDIR\"/\"$STDERR_NAME\"\n-        fi\n-    fi\n-done"}, {"sha": "c6b84d2ef650b890d5bd29b31192cc5ceaff6488", "filename": "src/tools/clippy/tests/ui-internal/interning_defined_symbol.fixed", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Finterning_defined_symbol.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Finterning_defined_symbol.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Finterning_defined_symbol.fixed?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,33 @@\n+// run-rustfix\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+extern crate rustc_span;\n+\n+use rustc_span::symbol::Symbol;\n+\n+macro_rules! sym {\n+    ($tt:tt) => {\n+        rustc_span::symbol::Symbol::intern(stringify!($tt))\n+    };\n+}\n+\n+fn main() {\n+    // Direct use of Symbol::intern\n+    let _ = rustc_span::symbol::sym::f32;\n+\n+    // Using a sym macro\n+    let _ = rustc_span::symbol::sym::f32;\n+\n+    // Correct suggestion when symbol isn't stringified constant name\n+    let _ = rustc_span::symbol::sym::proc_dash_macro;\n+\n+    // Interning a symbol that is not defined\n+    let _ = Symbol::intern(\"xyz123\");\n+    let _ = sym!(xyz123);\n+\n+    // Using a different `intern` function\n+    let _ = intern(\"f32\");\n+}\n+\n+fn intern(_: &str) {}"}, {"sha": "9ec82d4ad0baed230a4e6f1e542e43471d6c6d2a", "filename": "src/tools/clippy/tests/ui-internal/interning_defined_symbol.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Finterning_defined_symbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Finterning_defined_symbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Finterning_defined_symbol.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,33 @@\n+// run-rustfix\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+extern crate rustc_span;\n+\n+use rustc_span::symbol::Symbol;\n+\n+macro_rules! sym {\n+    ($tt:tt) => {\n+        rustc_span::symbol::Symbol::intern(stringify!($tt))\n+    };\n+}\n+\n+fn main() {\n+    // Direct use of Symbol::intern\n+    let _ = Symbol::intern(\"f32\");\n+\n+    // Using a sym macro\n+    let _ = sym!(f32);\n+\n+    // Correct suggestion when symbol isn't stringified constant name\n+    let _ = Symbol::intern(\"proc-macro\");\n+\n+    // Interning a symbol that is not defined\n+    let _ = Symbol::intern(\"xyz123\");\n+    let _ = sym!(xyz123);\n+\n+    // Using a different `intern` function\n+    let _ = intern(\"f32\");\n+}\n+\n+fn intern(_: &str) {}"}, {"sha": "74b906c8a5797205bc9b46ff4ee55e3ed5d1c9c1", "filename": "src/tools/clippy/tests/ui-internal/interning_defined_symbol.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Finterning_defined_symbol.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Finterning_defined_symbol.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-internal%2Finterning_defined_symbol.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,27 @@\n+error: interning a defined symbol\n+  --> $DIR/interning_defined_symbol.rs:17:13\n+   |\n+LL |     let _ = Symbol::intern(\"f32\");\n+   |             ^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::symbol::sym::f32`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/interning_defined_symbol.rs:2:9\n+   |\n+LL | #![deny(clippy::internal)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: `#[deny(clippy::interning_defined_symbol)]` implied by `#[deny(clippy::internal)]`\n+\n+error: interning a defined symbol\n+  --> $DIR/interning_defined_symbol.rs:20:13\n+   |\n+LL |     let _ = sym!(f32);\n+   |             ^^^^^^^^^ help: try: `rustc_span::symbol::sym::f32`\n+\n+error: interning a defined symbol\n+  --> $DIR/interning_defined_symbol.rs:23:13\n+   |\n+LL |     let _ = Symbol::intern(\"proc-macro\");\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `rustc_span::symbol::sym::proc_dash_macro`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "4391499a1e1f8e779470f3d1927dcd95c88eadd1", "filename": "src/tools/clippy/tests/ui-toml/update-all-references.sh", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupdate-all-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupdate-all-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupdate-all-references.sh?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,18 +1,3 @@\n #!/bin/bash\n-#\n-# A script to update the references for all tests. The idea is that\n-# you do a run, which will generate files in the build directory\n-# containing the (normalized) actual output of the compiler. You then\n-# run this script, which will copy those files over. If you find\n-# yourself manually editing a foo.stderr file, you're doing it wrong.\n-#\n-# See all `update-references.sh`, if you just want to update a single test.\n \n-if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" ]]; then\n-    echo \"usage: $0\"\n-fi\n-\n-BUILD_DIR=$PWD/target/debug/test_build_base\n-MY_DIR=$(dirname \"$0\")\n-cd \"$MY_DIR\" || exit\n-find . -name '*.rs' -exec ./update-references.sh \"$BUILD_DIR\" {} +\n+echo \"Please use 'cargo dev bless' instead.\""}, {"sha": "2ab51168bcaa61c4fd96d093a6e3adf50371ae9d", "filename": "src/tools/clippy/tests/ui-toml/update-references.sh", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c8135455c4a96b1d2570198619f38185c063579d/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c8135455c4a96b1d2570198619f38185c063579d/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Fupdate-references.sh?ref=c8135455c4a96b1d2570198619f38185c063579d", "patch": "@@ -1,46 +0,0 @@\n-#!/bin/bash\n-\n-# A script to update the references for particular tests. The idea is\n-# that you do a run, which will generate files in the build directory\n-# containing the (normalized) actual output of the compiler. This\n-# script will then copy that output and replace the \"expected output\"\n-# files. You can then commit the changes.\n-#\n-# If you find yourself manually editing a foo.stderr file, you're\n-# doing it wrong.\n-\n-if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" || \"$1\" == \"\" || \"$2\" == \"\" ]]; then\n-    echo \"usage: $0 <build-directory> <relative-path-to-rs-files>\"\n-    echo \"\"\n-    echo \"For example:\"\n-    echo \"   $0 ../../../build/x86_64-apple-darwin/test/ui *.rs */*.rs\"\n-fi\n-\n-MYDIR=$(dirname \"$0\")\n-\n-BUILD_DIR=\"$1\"\n-shift\n-\n-while [[ \"$1\" != \"\" ]]; do\n-    STDERR_NAME=\"${1/%.rs/.stderr}\"\n-    STDOUT_NAME=\"${1/%.rs/.stdout}\"\n-    shift\n-    if [[ -f \"$BUILD_DIR\"/\"$STDOUT_NAME\" ]] && \\\n-           ! (cmp -s -- \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"); then\n-        echo updating \"$MYDIR\"/\"$STDOUT_NAME\"\n-        cp \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"\n-        if [[ ! -s \"$MYDIR\"/\"$STDOUT_NAME\" ]]; then\n-            echo removing \"$MYDIR\"/\"$STDOUT_NAME\"\n-            rm \"$MYDIR\"/\"$STDOUT_NAME\"\n-        fi\n-    fi\n-    if [[ -f \"$BUILD_DIR\"/\"$STDERR_NAME\" ]] && \\\n-           ! (cmp -s -- \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"); then\n-        echo updating \"$MYDIR\"/\"$STDERR_NAME\"\n-        cp \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"\n-        if [[ ! -s \"$MYDIR\"/\"$STDERR_NAME\" ]]; then\n-            echo removing \"$MYDIR\"/\"$STDERR_NAME\"\n-            rm \"$MYDIR\"/\"$STDERR_NAME\"\n-        fi\n-    fi\n-done"}, {"sha": "14a700886a7bc1a4171bea3873ae0c053c9847aa", "filename": "src/tools/clippy/tests/ui/clone_on_copy.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,30 +1,30 @@\n-error: using `clone` on a `Copy` type\n+error: using `clone` on type `i32` which implements the `Copy` trait\n   --> $DIR/clone_on_copy.rs:22:5\n    |\n LL |     42.clone();\n    |     ^^^^^^^^^^ help: try removing the `clone` call: `42`\n    |\n    = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n \n-error: using `clone` on a `Copy` type\n+error: using `clone` on type `i32` which implements the `Copy` trait\n   --> $DIR/clone_on_copy.rs:26:5\n    |\n LL |     (&42).clone();\n    |     ^^^^^^^^^^^^^ help: try dereferencing it: `*(&42)`\n \n-error: using `clone` on a `Copy` type\n+error: using `clone` on type `i32` which implements the `Copy` trait\n   --> $DIR/clone_on_copy.rs:29:5\n    |\n LL |     rc.borrow().clone();\n    |     ^^^^^^^^^^^^^^^^^^^ help: try dereferencing it: `*rc.borrow()`\n \n-error: using `clone` on a `Copy` type\n+error: using `clone` on type `char` which implements the `Copy` trait\n   --> $DIR/clone_on_copy.rs:35:14\n    |\n LL |     is_ascii('z'.clone());\n    |              ^^^^^^^^^^^ help: try removing the `clone` call: `'z'`\n \n-error: using `clone` on a `Copy` type\n+error: using `clone` on type `i32` which implements the `Copy` trait\n   --> $DIR/clone_on_copy.rs:39:14\n    |\n LL |     vec.push(42.clone());"}, {"sha": "8df32649ad948b3d85aa3fae9a2bc468def694eb", "filename": "src/tools/clippy/tests/ui/eprint_with_newline.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feprint_with_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feprint_with_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feprint_with_newline.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,49 @@\n+#![allow(clippy::print_literal)]\n+#![warn(clippy::print_with_newline)]\n+\n+fn main() {\n+    eprint!(\"Hello\\n\");\n+    eprint!(\"Hello {}\\n\", \"world\");\n+    eprint!(\"Hello {} {}\\n\", \"world\", \"#2\");\n+    eprint!(\"{}\\n\", 1265);\n+    eprint!(\"\\n\");\n+\n+    // these are all fine\n+    eprint!(\"\");\n+    eprint!(\"Hello\");\n+    eprintln!(\"Hello\");\n+    eprintln!(\"Hello\\n\");\n+    eprintln!(\"Hello {}\\n\", \"world\");\n+    eprint!(\"Issue\\n{}\", 1265);\n+    eprint!(\"{}\", 1265);\n+    eprint!(\"\\n{}\", 1275);\n+    eprint!(\"\\n\\n\");\n+    eprint!(\"like eof\\n\\n\");\n+    eprint!(\"Hello {} {}\\n\\n\", \"world\", \"#2\");\n+    eprintln!(\"\\ndon't\\nwarn\\nfor\\nmultiple\\nnewlines\\n\"); // #3126\n+    eprintln!(\"\\nbla\\n\\n\"); // #3126\n+\n+    // Escaping\n+    eprint!(\"\\\\n\"); // #3514\n+    eprint!(\"\\\\\\n\"); // should fail\n+    eprint!(\"\\\\\\\\n\");\n+\n+    // Raw strings\n+    eprint!(r\"\\n\"); // #3778\n+\n+    // Literal newlines should also fail\n+    eprint!(\n+        \"\n+\"\n+    );\n+    eprint!(\n+        r\"\n+\"\n+    );\n+\n+    // Don't warn on CRLF (#4208)\n+    eprint!(\"\\r\\n\");\n+    eprint!(\"foo\\r\\n\");\n+    eprint!(\"\\\\r\\n\"); //~ ERROR\n+    eprint!(\"foo\\rbar\\n\") // ~ ERROR\n+}"}, {"sha": "31811d1d92a04285321bf4d5c0c6e3dead552d0a", "filename": "src/tools/clippy/tests/ui/eprint_with_newline.stderr", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feprint_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feprint_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feprint_with_newline.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,121 @@\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:5:5\n+   |\n+LL |     eprint!(\"Hello/n\");\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::print-with-newline` implied by `-D warnings`\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\"Hello\");\n+   |     ^^^^^^^^       --\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:6:5\n+   |\n+LL |     eprint!(\"Hello {}/n\", \"world\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\"Hello {}\", \"world\");\n+   |     ^^^^^^^^          --\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:7:5\n+   |\n+LL |     eprint!(\"Hello {} {}/n\", \"world\", \"#2\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\"Hello {} {}\", \"world\", \"#2\");\n+   |     ^^^^^^^^             --\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:8:5\n+   |\n+LL |     eprint!(\"{}/n\", 1265);\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\"{}\", 1265);\n+   |     ^^^^^^^^    --\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:9:5\n+   |\n+LL |     eprint!(\"/n\");\n+   |     ^^^^^^^^^^^^^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!();\n+   |     ^^^^^^^^ --\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:28:5\n+   |\n+LL |     eprint!(\"//n\"); // should fail\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\"/\"); // should fail\n+   |     ^^^^^^^^    --\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:35:5\n+   |\n+LL | /     eprint!(\n+LL | |         \"\n+LL | | \"\n+LL | |     );\n+   | |_____^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\n+LL |         \"\"\n+   |\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:39:5\n+   |\n+LL | /     eprint!(\n+LL | |         r\"\n+LL | | \"\n+LL | |     );\n+   | |_____^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\n+LL |         r\"\"\n+   |\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:47:5\n+   |\n+LL |     eprint!(\"/r/n\"); //~ ERROR\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\"/r\"); //~ ERROR\n+   |     ^^^^^^^^     --\n+\n+error: using `eprint!()` with a format string that ends in a single newline\n+  --> $DIR/eprint_with_newline.rs:48:5\n+   |\n+LL |     eprint!(\"foo/rbar/n\") // ~ ERROR\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `eprintln!` instead\n+   |\n+LL |     eprintln!(\"foo/rbar\") // ~ ERROR\n+   |     ^^^^^^^^          --\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "16aa1b07733d5d8049b25a5c2ca56ad0f1323fc7", "filename": "src/tools/clippy/tests/ui/eta.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feta.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -12,7 +12,7 @@ error: redundant closure found\n LL |     meta(|a| foo(a));\n    |          ^^^^^^^^^^ help: remove closure as shown: `foo`\n \n-error: this expression borrows a reference that is immediately dereferenced by the compiler\n+error: this expression borrows a reference (`&u8`) that is immediately dereferenced by the compiler\n   --> $DIR/eta.rs:24:21\n    |\n LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted"}, {"sha": "0d14807ff1cfcf1f2745b521f0c101c7ca85eddb", "filename": "src/tools/clippy/tests/ui/formatting.rs", "status": "modified", "additions": 1, "deletions": 86, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformatting.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -10,91 +10,6 @@ fn foo() -> bool {\n \n #[rustfmt::skip]\n fn main() {\n-    // weird `else` formatting:\n-    if foo() {\n-    } {\n-    }\n-\n-    if foo() {\n-    } if foo() {\n-    }\n-\n-    let _ = { // if as the last expression\n-        let _ = 0;\n-\n-        if foo() {\n-        } if foo() {\n-        }\n-        else {\n-        }\n-    };\n-\n-    let _ = { // if in the middle of a block\n-        if foo() {\n-        } if foo() {\n-        }\n-        else {\n-        }\n-\n-        let _ = 0;\n-    };\n-\n-    if foo() {\n-    } else\n-    {\n-    }\n-\n-    if foo() {\n-    }\n-    else\n-    {\n-    }\n-\n-    if foo() {\n-    } else\n-    if foo() { // the span of the above error should continue here\n-    }\n-\n-    if foo() {\n-    }\n-    else\n-    if foo() { // the span of the above error should continue here\n-    }\n-\n-    // those are ok:\n-    if foo() {\n-    }\n-    {\n-    }\n-\n-    if foo() {\n-    } else {\n-    }\n-\n-    if foo() {\n-    }\n-    else {\n-    }\n-\n-    if foo() {\n-    }\n-    if foo() {\n-    }\n-\n-    if foo() {\n-    } else if foo() {\n-    }\n-\n-    if foo() {\n-    }\n-    else if foo() {\n-    }\n-\n-    if foo() {\n-    }\n-    else if\n-    foo() {}\n-\n     // weird op_eq formatting:\n     let mut a = 42;\n     a =- 35;\n@@ -146,7 +61,7 @@ fn main() {\n \n     // don't lint if the indentation suggests not to\n     let _ = &[\n-        1 + 2, 3 \n+        1 + 2, 3\n                 - 4, 5\n     ];\n     // lint if it doesn't"}, {"sha": "bde434c7e2e78737ae451a9c8dd776712aba5090", "filename": "src/tools/clippy/tests/ui/formatting.stderr", "status": "modified", "additions": 7, "deletions": 82, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformatting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformatting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fformatting.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,80 +1,5 @@\n-error: this looks like an `else {..}` but the `else` is missing\n-  --> $DIR/formatting.rs:15:6\n-   |\n-LL |     } {\n-   |      ^\n-   |\n-   = note: `-D clippy::suspicious-else-formatting` implied by `-D warnings`\n-   = note: to remove this lint, add the missing `else` or add a new line before the next block\n-\n-error: this looks like an `else if` but the `else` is missing\n-  --> $DIR/formatting.rs:19:6\n-   |\n-LL |     } if foo() {\n-   |      ^\n-   |\n-   = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n-\n-error: this looks like an `else if` but the `else` is missing\n-  --> $DIR/formatting.rs:26:10\n-   |\n-LL |         } if foo() {\n-   |          ^\n-   |\n-   = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n-\n-error: this looks like an `else if` but the `else` is missing\n-  --> $DIR/formatting.rs:34:10\n-   |\n-LL |         } if foo() {\n-   |          ^\n-   |\n-   = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n-\n-error: this is an `else {..}` but the formatting might hide it\n-  --> $DIR/formatting.rs:43:6\n-   |\n-LL |       } else\n-   |  ______^\n-LL | |     {\n-   | |____^\n-   |\n-   = note: to remove this lint, remove the `else` or remove the new line between `else` and `{..}`\n-\n-error: this is an `else {..}` but the formatting might hide it\n-  --> $DIR/formatting.rs:48:6\n-   |\n-LL |       }\n-   |  ______^\n-LL | |     else\n-LL | |     {\n-   | |____^\n-   |\n-   = note: to remove this lint, remove the `else` or remove the new line between `else` and `{..}`\n-\n-error: this is an `else if` but the formatting might hide it\n-  --> $DIR/formatting.rs:54:6\n-   |\n-LL |       } else\n-   |  ______^\n-LL | |     if foo() { // the span of the above error should continue here\n-   | |____^\n-   |\n-   = note: to remove this lint, remove the `else` or remove the new line between `else` and `if`\n-\n-error: this is an `else if` but the formatting might hide it\n-  --> $DIR/formatting.rs:59:6\n-   |\n-LL |       }\n-   |  ______^\n-LL | |     else\n-LL | |     if foo() { // the span of the above error should continue here\n-   | |____^\n-   |\n-   = note: to remove this lint, remove the `else` or remove the new line between `else` and `if`\n-\n error: this looks like you are trying to use `.. -= ..`, but you really are doing `.. = (- ..)`\n-  --> $DIR/formatting.rs:100:6\n+  --> $DIR/formatting.rs:15:6\n    |\n LL |     a =- 35;\n    |      ^^^^\n@@ -83,23 +8,23 @@ LL |     a =- 35;\n    = note: to remove this lint, use either `-=` or `= -`\n \n error: this looks like you are trying to use `.. *= ..`, but you really are doing `.. = (* ..)`\n-  --> $DIR/formatting.rs:101:6\n+  --> $DIR/formatting.rs:16:6\n    |\n LL |     a =* &191;\n    |      ^^^^\n    |\n    = note: to remove this lint, use either `*=` or `= *`\n \n error: this looks like you are trying to use `.. != ..`, but you really are doing `.. = (! ..)`\n-  --> $DIR/formatting.rs:104:6\n+  --> $DIR/formatting.rs:19:6\n    |\n LL |     b =! false;\n    |      ^^^^\n    |\n    = note: to remove this lint, use either `!=` or `= !`\n \n error: possibly missing a comma here\n-  --> $DIR/formatting.rs:113:19\n+  --> $DIR/formatting.rs:28:19\n    |\n LL |         -1, -2, -3 // <= no comma here\n    |                   ^\n@@ -108,20 +33,20 @@ LL |         -1, -2, -3 // <= no comma here\n    = note: to remove this lint, add a comma or write the expr in a single line\n \n error: possibly missing a comma here\n-  --> $DIR/formatting.rs:117:19\n+  --> $DIR/formatting.rs:32:19\n    |\n LL |         -1, -2, -3 // <= no comma here\n    |                   ^\n    |\n    = note: to remove this lint, add a comma or write the expr in a single line\n \n error: possibly missing a comma here\n-  --> $DIR/formatting.rs:154:11\n+  --> $DIR/formatting.rs:69:11\n    |\n LL |         -1\n    |           ^\n    |\n    = note: to remove this lint, add a comma or write the expr in a single line\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "526e94b10bd0ee460bf57dc993222fc47da3b2c8", "filename": "src/tools/clippy/tests/ui/match_single_binding.fixed", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_single_binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_single_binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_single_binding.fixed?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -87,4 +87,32 @@ fn main() {\n             unwrapped\n         })\n         .collect::<Vec<u8>>();\n+    // Ok\n+    let x = 1;\n+    match x {\n+        #[cfg(disabled_feature)]\n+        0 => println!(\"Disabled branch\"),\n+        _ => println!(\"Enabled branch\"),\n+    }\n+    // Lint\n+    let x = 1;\n+    let y = 1;\n+    println!(\"Single branch\");\n+    // Ok\n+    let x = 1;\n+    let y = 1;\n+    match match y {\n+        0 => 1,\n+        _ => 2,\n+    } {\n+        #[cfg(disabled_feature)]\n+        0 => println!(\"Array index start\"),\n+        _ => println!(\"Not an array index start\"),\n+    }\n+    // False negative\n+    let x = 1;\n+    match x {\n+        // =>\n+        _ => println!(\"Not an array index start\"),\n+    }\n }"}, {"sha": "6a2ca7c5e9340d132cea73a483a703888ea2ee69", "filename": "src/tools/clippy/tests/ui/match_single_binding.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_single_binding.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -99,4 +99,37 @@ fn main() {\n             unwrapped => unwrapped,\n         })\n         .collect::<Vec<u8>>();\n+    // Ok\n+    let x = 1;\n+    match x {\n+        #[cfg(disabled_feature)]\n+        0 => println!(\"Disabled branch\"),\n+        _ => println!(\"Enabled branch\"),\n+    }\n+    // Lint\n+    let x = 1;\n+    let y = 1;\n+    match match y {\n+        0 => 1,\n+        _ => 2,\n+    } {\n+        _ => println!(\"Single branch\"),\n+    }\n+    // Ok\n+    let x = 1;\n+    let y = 1;\n+    match match y {\n+        0 => 1,\n+        _ => 2,\n+    } {\n+        #[cfg(disabled_feature)]\n+        0 => println!(\"Array index start\"),\n+        _ => println!(\"Not an array index start\"),\n+    }\n+    // False negative\n+    let x = 1;\n+    match x {\n+        // =>\n+        _ => println!(\"Not an array index start\"),\n+    }\n }"}, {"sha": "cbbf5d29c02471a024d0ef8c072768030ed9d026", "filename": "src/tools/clippy/tests/ui/match_single_binding.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_single_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_single_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_single_binding.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -167,5 +167,16 @@ LL |             unwrapped\n LL |         })\n    |\n \n-error: aborting due to 11 previous errors\n+error: this match could be replaced by its body itself\n+  --> $DIR/match_single_binding.rs:112:5\n+   |\n+LL | /     match match y {\n+LL | |         0 => 1,\n+LL | |         _ => 2,\n+LL | |     } {\n+LL | |         _ => println!(\"Single branch\"),\n+LL | |     }\n+   | |_____^ help: consider using the match body instead: `println!(\"Single branch\");`\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "3848bca3207596fd6d16901b5a425e109a88f093", "filename": "src/tools/clippy/tests/ui/min_rust_version_attr.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -2,7 +2,7 @@\n #![feature(custom_inner_attributes)]\n #![clippy::msrv = \"1.0.0\"]\n \n-use std::ops::Deref;\n+use std::ops::{Deref, RangeFrom};\n \n fn option_as_ref_deref() {\n     let mut opt = Some(String::from(\"123\"));\n@@ -42,12 +42,94 @@ pub fn manual_strip_msrv() {\n     }\n }\n \n+pub fn redundant_fieldnames() {\n+    let start = 0;\n+    let _ = RangeFrom { start: start };\n+}\n+\n+pub fn redundant_static_lifetime() {\n+    const VAR_ONE: &'static str = \"Test constant #1\";\n+}\n+\n+pub fn checked_conversion() {\n+    let value: i64 = 42;\n+    let _ = value <= (u32::max_value() as i64) && value >= 0;\n+    let _ = value <= (u32::MAX as i64) && value >= 0;\n+}\n+\n+pub fn filter_map_next() {\n+    let a = [\"1\", \"lol\", \"3\", \"NaN\", \"5\"];\n+\n+    #[rustfmt::skip]\n+    let _: Option<u32> = vec![1, 2, 3, 4, 5, 6]\n+        .into_iter()\n+        .filter_map(|x| {\n+            if x == 2 {\n+                Some(x * 2)\n+            } else {\n+                None\n+            }\n+        })\n+        .next();\n+}\n+\n+#[allow(clippy::no_effect)]\n+#[allow(clippy::short_circuit_statement)]\n+#[allow(clippy::unnecessary_operation)]\n+pub fn manual_range_contains() {\n+    let x = 5;\n+    x >= 8 && x < 12;\n+}\n+\n+pub fn use_self() {\n+    struct Foo {}\n+\n+    impl Foo {\n+        fn new() -> Foo {\n+            Foo {}\n+        }\n+        fn test() -> Foo {\n+            Foo::new()\n+        }\n+    }\n+}\n+\n+fn replace_with_default() {\n+    let mut s = String::from(\"foo\");\n+    let _ = std::mem::replace(&mut s, String::default());\n+}\n+\n+fn map_unwrap_or() {\n+    let opt = Some(1);\n+\n+    // Check for `option.map(_).unwrap_or(_)` use.\n+    // Single line case.\n+    let _ = opt\n+        .map(|x| x + 1)\n+        // Should lint even though this call is on a separate line.\n+        .unwrap_or(0);\n+}\n+\n+// Could be const\n+fn missing_const_for_fn() -> i32 {\n+    1\n+}\n+\n fn main() {\n+    filter_map_next();\n+    checked_conversion();\n+    redundant_fieldnames();\n+    redundant_static_lifetime();\n     option_as_ref_deref();\n     match_like_matches();\n     match_same_arms();\n     match_same_arms2();\n     manual_strip_msrv();\n+    manual_range_contains();\n+    use_self();\n+    replace_with_default();\n+    map_unwrap_or();\n+    missing_const_for_fn();\n }\n \n mod meets_msrv {"}, {"sha": "348052631049b2f8dc9790074c1b0ef5958f34f4", "filename": "src/tools/clippy/tests/ui/min_rust_version_attr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmin_rust_version_attr.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,12 +1,12 @@\n error: stripping a prefix manually\n-  --> $DIR/min_rust_version_attr.rs:60:24\n+  --> $DIR/min_rust_version_attr.rs:142:24\n    |\n LL |             assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n    |                        ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::manual-strip` implied by `-D warnings`\n note: the prefix was tested here\n-  --> $DIR/min_rust_version_attr.rs:59:9\n+  --> $DIR/min_rust_version_attr.rs:141:9\n    |\n LL |         if s.starts_with(\"hello, \") {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -17,13 +17,13 @@ LL |             assert_eq!(<stripped>.to_uppercase(), \"WORLD!\");\n    |\n \n error: stripping a prefix manually\n-  --> $DIR/min_rust_version_attr.rs:72:24\n+  --> $DIR/min_rust_version_attr.rs:154:24\n    |\n LL |             assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n    |                        ^^^^^^^^^^^^^^^^^^^^\n    |\n note: the prefix was tested here\n-  --> $DIR/min_rust_version_attr.rs:71:9\n+  --> $DIR/min_rust_version_attr.rs:153:9\n    |\n LL |         if s.starts_with(\"hello, \") {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "d56c5cc4c3ae25b84514b8742bbfc76844cdc90e", "filename": "src/tools/clippy/tests/ui/missing-doc-crate-missing.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing-doc-crate-missing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing-doc-crate-missing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing-doc-crate-missing.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,4 +1,4 @@\n-error: missing documentation for crate\n+error: missing documentation for the crate\n   --> $DIR/missing-doc-crate-missing.rs:1:1\n    |\n LL | / #![warn(clippy::missing_docs_in_private_items)]"}, {"sha": "7e10404ca005e9fa259b08dc69e114ed4e7c2c3a", "filename": "src/tools/clippy/tests/ui/missing-doc-impl.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing-doc-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing-doc-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmissing-doc-impl.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -51,13 +51,13 @@ LL | |     fn foo_with_impl(&self) {}\n LL | | }\n    | |_^\n \n-error: missing documentation for a trait method\n+error: missing documentation for an associated function\n   --> $DIR/missing-doc-impl.rs:39:5\n    |\n LL |     fn foo(&self);\n    |     ^^^^^^^^^^^^^^\n \n-error: missing documentation for a trait method\n+error: missing documentation for an associated function\n   --> $DIR/missing-doc-impl.rs:40:5\n    |\n LL |     fn foo_with_impl(&self) {}\n@@ -75,25 +75,25 @@ error: missing documentation for an associated type\n LL |     type AssociatedTypeDef = Self;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: missing documentation for a method\n+error: missing documentation for an associated function\n   --> $DIR/missing-doc-impl.rs:62:5\n    |\n LL |     pub fn foo() {}\n    |     ^^^^^^^^^^^^^^^\n \n-error: missing documentation for a method\n+error: missing documentation for an associated function\n   --> $DIR/missing-doc-impl.rs:63:5\n    |\n LL |     fn bar() {}\n    |     ^^^^^^^^^^^\n \n-error: missing documentation for a method\n+error: missing documentation for an associated function\n   --> $DIR/missing-doc-impl.rs:67:5\n    |\n LL |     pub fn foo() {}\n    |     ^^^^^^^^^^^^^^^\n \n-error: missing documentation for a method\n+error: missing documentation for an associated function\n   --> $DIR/missing-doc-impl.rs:70:5\n    |\n LL |     fn foo2() {}"}, {"sha": "bea4b41b803d09b0230619010d4aa390692ef673", "filename": "src/tools/clippy/tests/ui/needless_borrow.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_borrow.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,4 +1,4 @@\n-error: this expression borrows a reference that is immediately dereferenced by the compiler\n+error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:14:15\n    |\n LL |     let c = x(&&a);\n@@ -12,7 +12,7 @@ error: this pattern creates a reference to a reference\n LL |     if let Some(ref cake) = Some(&5) {}\n    |                 ^^^^^^^^ help: change this to: `cake`\n \n-error: this expression borrows a reference that is immediately dereferenced by the compiler\n+error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:28:15\n    |\n LL |         46 => &&a,"}, {"sha": "83e9bbaa3af43dc1bdc1f8c60f77130b42c9bcb5", "filename": "src/tools/clippy/tests/ui/needless_doc_main.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_doc_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_doc_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_doc_main.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -10,7 +10,7 @@\n /// ```\n ///\n /// With an explicit return type it should lint too\n-/// ```\n+/// ```edition2015\n /// fn main() -> () {\n ///     unimplemented!();\n /// }\n@@ -39,7 +39,7 @@ fn bad_doctests() {}\n /// ```\n ///\n /// This shouldn't lint either, because main is async:\n-/// ```\n+/// ```edition2018\n /// async fn main() {\n ///     assert_eq!(42, ANSWER);\n /// }\n@@ -128,6 +128,12 @@ fn bad_doctests() {}\n /// ```\n fn no_false_positives() {}\n \n+/// Yields a parse error when interpreted as rust code:\n+/// ```\n+/// r#\"hi\"\n+/// ```\n+fn issue_6022() {}\n+\n fn main() {\n     bad_doctests();\n     no_false_positives();"}, {"sha": "b93ff048a62f21de1f957e5c1df595552dae851d", "filename": "src/tools/clippy/tests/ui/needless_update.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_update.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -6,9 +6,20 @@ struct S {\n     pub b: i32,\n }\n \n+#[non_exhaustive]\n+struct T {\n+    pub x: i32,\n+    pub y: i32,\n+}\n+\n fn main() {\n     let base = S { a: 0, b: 0 };\n     S { ..base }; // no error\n     S { a: 1, ..base }; // no error\n     S { a: 1, b: 1, ..base };\n+\n+    let base = T { x: 0, y: 0 };\n+    T { ..base }; // no error\n+    T { x: 1, ..base }; // no error\n+    T { x: 1, y: 1, ..base }; // no error\n }"}, {"sha": "b154b3b306ddcc1fab314d1d11ef898865015f7c", "filename": "src/tools/clippy/tests/ui/needless_update.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_update.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_update.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_update.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,5 +1,5 @@\n error: struct update has no effect, all the fields in the struct have already been specified\n-  --> $DIR/needless_update.rs:13:23\n+  --> $DIR/needless_update.rs:19:23\n    |\n LL |     S { a: 1, b: 1, ..base };\n    |                       ^^^^"}, {"sha": "eb744b0c198fabf28dc94e0b387d4d09da513c57", "filename": "src/tools/clippy/tests/ui/panic_in_result_fn.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,4 +1,4 @@\n-error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:7:5\n    |\n LL | /     fn result_with_panic() -> Result<bool, String> // should emit lint\n@@ -8,15 +8,15 @@ LL | |     }\n    | |_____^\n    |\n    = note: `-D clippy::panic-in-result-fn` implied by `-D warnings`\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n note: return Err() instead of panicking\n   --> $DIR/panic_in_result_fn.rs:9:9\n    |\n LL |         panic!(\"error\");\n    |         ^^^^^^^^^^^^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:12:5\n    |\n LL | /     fn result_with_unimplemented() -> Result<bool, String> // should emit lint\n@@ -25,15 +25,15 @@ LL | |         unimplemented!();\n LL | |     }\n    | |_____^\n    |\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n note: return Err() instead of panicking\n   --> $DIR/panic_in_result_fn.rs:14:9\n    |\n LL |         unimplemented!();\n    |         ^^^^^^^^^^^^^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:17:5\n    |\n LL | /     fn result_with_unreachable() -> Result<bool, String> // should emit lint\n@@ -42,15 +42,15 @@ LL | |         unreachable!();\n LL | |     }\n    | |_____^\n    |\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n note: return Err() instead of panicking\n   --> $DIR/panic_in_result_fn.rs:19:9\n    |\n LL |         unreachable!();\n    |         ^^^^^^^^^^^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:22:5\n    |\n LL | /     fn result_with_todo() -> Result<bool, String> // should emit lint\n@@ -59,15 +59,15 @@ LL | |         todo!(\"Finish this\");\n LL | |     }\n    | |_____^\n    |\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n note: return Err() instead of panicking\n   --> $DIR/panic_in_result_fn.rs:24:9\n    |\n LL |         todo!(\"Finish this\");\n    |         ^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:53:1\n    |\n LL | / fn function_result_with_panic() -> Result<bool, String> // should emit lint\n@@ -76,15 +76,15 @@ LL | |     panic!(\"error\");\n LL | | }\n    | |_^\n    |\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n note: return Err() instead of panicking\n   --> $DIR/panic_in_result_fn.rs:55:5\n    |\n LL |     panic!(\"error\");\n    |     ^^^^^^^^^^^^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: used `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` in a function that returns `Result`\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n   --> $DIR/panic_in_result_fn.rs:68:1\n    |\n LL | / fn main() -> Result<(), String> {\n@@ -93,7 +93,7 @@ LL | |     Ok(())\n LL | | }\n    | |_^\n    |\n-   = help: `unimplemented!()`, `unreachable!()`, `todo!()` or `panic!()` should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n note: return Err() instead of panicking\n   --> $DIR/panic_in_result_fn.rs:69:5\n    |"}, {"sha": "ffdf8288adc709d1808072d082e3325b35c3821f", "filename": "src/tools/clippy/tests/ui/panic_in_result_fn_assertions.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_assertions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_assertions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_assertions.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,48 @@\n+#![warn(clippy::panic_in_result_fn)]\n+#![allow(clippy::unnecessary_wraps)]\n+\n+struct A;\n+\n+impl A {\n+    fn result_with_assert_with_message(x: i32) -> Result<bool, String> // should emit lint\n+    {\n+        assert!(x == 5, \"wrong argument\");\n+        Ok(true)\n+    }\n+\n+    fn result_with_assert_eq(x: i32) -> Result<bool, String> // should emit lint\n+    {\n+        assert_eq!(x, 5);\n+        Ok(true)\n+    }\n+\n+    fn result_with_assert_ne(x: i32) -> Result<bool, String> // should emit lint\n+    {\n+        assert_ne!(x, 1);\n+        Ok(true)\n+    }\n+\n+    fn other_with_assert_with_message(x: i32) // should not emit lint\n+    {\n+        assert!(x == 5, \"wrong argument\");\n+    }\n+\n+    fn other_with_assert_eq(x: i32) // should not emit lint\n+    {\n+        assert_eq!(x, 5);\n+    }\n+\n+    fn other_with_assert_ne(x: i32) // should not emit lint\n+    {\n+        assert_ne!(x, 1);\n+    }\n+\n+    fn result_without_banned_functions() -> Result<bool, String> // should not emit lint\n+    {\n+        let assert = \"assert!\";\n+        println!(\"No {}\", assert);\n+        Ok(true)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "86f61ad718a9cbde8b19597bb06fcf39074abad4", "filename": "src/tools/clippy/tests/ui/panic_in_result_fn_assertions.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_assertions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_assertions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_assertions.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,57 @@\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn_assertions.rs:7:5\n+   |\n+LL | /     fn result_with_assert_with_message(x: i32) -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         assert!(x == 5, \"wrong argument\");\n+LL | |         Ok(true)\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::panic-in-result-fn` implied by `-D warnings`\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn_assertions.rs:9:9\n+   |\n+LL |         assert!(x == 5, \"wrong argument\");\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn_assertions.rs:13:5\n+   |\n+LL | /     fn result_with_assert_eq(x: i32) -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         assert_eq!(x, 5);\n+LL | |         Ok(true)\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn_assertions.rs:15:9\n+   |\n+LL |         assert_eq!(x, 5);\n+   |         ^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn_assertions.rs:19:5\n+   |\n+LL | /     fn result_with_assert_ne(x: i32) -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         assert_ne!(x, 1);\n+LL | |         Ok(true)\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn_assertions.rs:21:9\n+   |\n+LL |         assert_ne!(x, 1);\n+   |         ^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "b60c79f97c865935a72e954ad765a6680e5eb4d2", "filename": "src/tools/clippy/tests/ui/panic_in_result_fn_debug_assertions.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_debug_assertions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_debug_assertions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_debug_assertions.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,48 @@\n+#![warn(clippy::panic_in_result_fn)]\n+#![allow(clippy::unnecessary_wraps)]\n+\n+struct A;\n+\n+impl A {\n+    fn result_with_debug_assert_with_message(x: i32) -> Result<bool, String> // should emit lint\n+    {\n+        debug_assert!(x == 5, \"wrong argument\");\n+        Ok(true)\n+    }\n+\n+    fn result_with_debug_assert_eq(x: i32) -> Result<bool, String> // should emit lint\n+    {\n+        debug_assert_eq!(x, 5);\n+        Ok(true)\n+    }\n+\n+    fn result_with_debug_assert_ne(x: i32) -> Result<bool, String> // should emit lint\n+    {\n+        debug_assert_ne!(x, 1);\n+        Ok(true)\n+    }\n+\n+    fn other_with_debug_assert_with_message(x: i32) // should not emit lint\n+    {\n+        debug_assert!(x == 5, \"wrong argument\");\n+    }\n+\n+    fn other_with_debug_assert_eq(x: i32) // should not emit lint\n+    {\n+        debug_assert_eq!(x, 5);\n+    }\n+\n+    fn other_with_debug_assert_ne(x: i32) // should not emit lint\n+    {\n+        debug_assert_ne!(x, 1);\n+    }\n+\n+    fn result_without_banned_functions() -> Result<bool, String> // should not emit lint\n+    {\n+        let debug_assert = \"debug_assert!\";\n+        println!(\"No {}\", debug_assert);\n+        Ok(true)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ec18e89698c56d6d2cc59a158adcdb3a0053e166", "filename": "src/tools/clippy/tests/ui/panic_in_result_fn_debug_assertions.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_debug_assertions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_debug_assertions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpanic_in_result_fn_debug_assertions.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,57 @@\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn_debug_assertions.rs:7:5\n+   |\n+LL | /     fn result_with_debug_assert_with_message(x: i32) -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         debug_assert!(x == 5, \"wrong argument\");\n+LL | |         Ok(true)\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::panic-in-result-fn` implied by `-D warnings`\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn_debug_assertions.rs:9:9\n+   |\n+LL |         debug_assert!(x == 5, \"wrong argument\");\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn_debug_assertions.rs:13:5\n+   |\n+LL | /     fn result_with_debug_assert_eq(x: i32) -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         debug_assert_eq!(x, 5);\n+LL | |         Ok(true)\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn_debug_assertions.rs:15:9\n+   |\n+LL |         debug_assert_eq!(x, 5);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: used `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertion in a function that returns `Result`\n+  --> $DIR/panic_in_result_fn_debug_assertions.rs:19:5\n+   |\n+LL | /     fn result_with_debug_assert_ne(x: i32) -> Result<bool, String> // should emit lint\n+LL | |     {\n+LL | |         debug_assert_ne!(x, 1);\n+LL | |         Ok(true)\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: `unimplemented!()`, `unreachable!()`, `todo!()`, `panic!()` or assertions should not be used in a function that returns `Result` as `Result` is expected to return an error instead of crashing\n+note: return Err() instead of panicking\n+  --> $DIR/panic_in_result_fn_debug_assertions.rs:21:9\n+   |\n+LL |         debug_assert_ne!(x, 1);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "fa07e74a7be47ef865870592b5e5e72d5dca284a", "filename": "src/tools/clippy/tests/ui/print_stderr.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprint_stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprint_stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprint_stderr.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,8 @@\n+#![warn(clippy::print_stderr)]\n+\n+fn main() {\n+    eprintln!(\"Hello\");\n+    println!(\"This should not do anything\");\n+    eprint!(\"World\");\n+    print!(\"Nor should this\");\n+}"}, {"sha": "5af735af65769b9512f336d38dec186afbeffcb2", "filename": "src/tools/clippy/tests/ui/print_stderr.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprint_stderr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprint_stderr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprint_stderr.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,16 @@\n+error: use of `eprintln!`\n+  --> $DIR/print_stderr.rs:4:5\n+   |\n+LL |     eprintln!(\"Hello\");\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::print-stderr` implied by `-D warnings`\n+\n+error: use of `eprint!`\n+  --> $DIR/print_stderr.rs:6:5\n+   |\n+LL |     eprint!(\"World\");\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "9760680927a63d9b9772c929fd3bf700e66ba175", "filename": "src/tools/clippy/tests/ui/println_empty_string.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprintln_empty_string.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprintln_empty_string.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprintln_empty_string.fixed?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -8,4 +8,11 @@ fn main() {\n     match \"a\" {\n         _ => println!(),\n     }\n+\n+    eprintln!();\n+    eprintln!();\n+\n+    match \"a\" {\n+        _ => eprintln!(),\n+    }\n }"}, {"sha": "80fdb3e6e2105412918e757fa7790a8697d193e9", "filename": "src/tools/clippy/tests/ui/println_empty_string.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprintln_empty_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprintln_empty_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprintln_empty_string.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -8,4 +8,11 @@ fn main() {\n     match \"a\" {\n         _ => println!(\"\"),\n     }\n+\n+    eprintln!();\n+    eprintln!(\"\");\n+\n+    match \"a\" {\n+        _ => eprintln!(\"\"),\n+    }\n }"}, {"sha": "17fe4ea74790c4de796cb0bbdf6342f7924fe65b", "filename": "src/tools/clippy/tests/ui/println_empty_string.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprintln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprintln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fprintln_empty_string.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -12,5 +12,17 @@ error: using `println!(\"\")`\n LL |         _ => println!(\"\"),\n    |              ^^^^^^^^^^^^ help: replace it with: `println!()`\n \n-error: aborting due to 2 previous errors\n+error: using `eprintln!(\"\")`\n+  --> $DIR/println_empty_string.rs:13:5\n+   |\n+LL |     eprintln!(\"\");\n+   |     ^^^^^^^^^^^^^ help: replace it with: `eprintln!()`\n+\n+error: using `eprintln!(\"\")`\n+  --> $DIR/println_empty_string.rs:16:14\n+   |\n+LL |         _ => eprintln!(\"\"),\n+   |              ^^^^^^^^^^^^^ help: replace it with: `eprintln!()`\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "47c974e614b91e80bda1fd3b46dfe11a92b240f9", "filename": "src/tools/clippy/tests/ui/range_contains.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.fixed?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -44,3 +44,8 @@ fn main() {\n     (0. ..1.).contains(&y);\n     !(0. ..=1.).contains(&y);\n }\n+\n+// Fix #6373\n+pub const fn in_range(a: i32) -> bool {\n+    3 <= a && a <= 20\n+}"}, {"sha": "835deced5e4cba34a443debfc104ce0ac21b8635", "filename": "src/tools/clippy/tests/ui/range_contains.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_contains.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -44,3 +44,8 @@ fn main() {\n     y >= 0. && y < 1.;\n     y < 0. || y > 1.;\n }\n+\n+// Fix #6373\n+pub const fn in_range(a: i32) -> bool {\n+    3 <= a && a <= 20\n+}"}, {"sha": "737c8a9f8db43783313ab6d6fdfbfe0341709984", "filename": "src/tools/clippy/tests/ui/redundant_else.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_else.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,154 @@\n+#![warn(clippy::redundant_else)]\n+#![allow(clippy::needless_return)]\n+\n+fn main() {\n+    loop {\n+        // break\n+        if foo() {\n+            println!(\"Love your neighbor;\");\n+            break;\n+        } else {\n+            println!(\"yet don't pull down your hedge.\");\n+        }\n+        // continue\n+        if foo() {\n+            println!(\"He that lies down with Dogs,\");\n+            continue;\n+        } else {\n+            println!(\"shall rise up with fleas.\");\n+        }\n+        // match block\n+        if foo() {\n+            match foo() {\n+                1 => break,\n+                _ => return,\n+            }\n+        } else {\n+            println!(\"You may delay, but time will not.\");\n+        }\n+    }\n+    // else if\n+    if foo() {\n+        return;\n+    } else if foo() {\n+        return;\n+    } else {\n+        println!(\"A fat kitchen makes a lean will.\");\n+    }\n+    // let binding outside of block\n+    let _ = {\n+        if foo() {\n+            return;\n+        } else {\n+            1\n+        }\n+    };\n+    // else if with let binding outside of block\n+    let _ = {\n+        if foo() {\n+            return;\n+        } else if foo() {\n+            return;\n+        } else {\n+            2\n+        }\n+    };\n+    // inside if let\n+    let _ = if let Some(1) = foo() {\n+        let _ = 1;\n+        if foo() {\n+            return;\n+        } else {\n+            1\n+        }\n+    } else {\n+        1\n+    };\n+\n+    //\n+    // non-lint cases\n+    //\n+\n+    // sanity check\n+    if foo() {\n+        let _ = 1;\n+    } else {\n+        println!(\"Who is wise? He that learns from every one.\");\n+    }\n+    // else if without else\n+    if foo() {\n+        return;\n+    } else if foo() {\n+        foo()\n+    };\n+    // nested if return\n+    if foo() {\n+        if foo() {\n+            return;\n+        }\n+    } else {\n+        foo()\n+    };\n+    // match with non-breaking branch\n+    if foo() {\n+        match foo() {\n+            1 => foo(),\n+            _ => return,\n+        }\n+    } else {\n+        println!(\"Three may keep a secret, if two of them are dead.\");\n+    }\n+    // let binding\n+    let _ = if foo() {\n+        return;\n+    } else {\n+        1\n+    };\n+    // assign\n+    let a;\n+    a = if foo() {\n+        return;\n+    } else {\n+        1\n+    };\n+    // assign-op\n+    a += if foo() {\n+        return;\n+    } else {\n+        1\n+    };\n+    // if return else if else\n+    if foo() {\n+        return;\n+    } else if foo() {\n+        1\n+    } else {\n+        2\n+    };\n+    // if else if return else\n+    if foo() {\n+        1\n+    } else if foo() {\n+        return;\n+    } else {\n+        2\n+    };\n+    // else if with let binding\n+    let _ = if foo() {\n+        return;\n+    } else if foo() {\n+        return;\n+    } else {\n+        2\n+    };\n+    // inside function call\n+    Box::new(if foo() {\n+        return;\n+    } else {\n+        1\n+    });\n+}\n+\n+fn foo<T>() -> T {\n+    unimplemented!(\"I'm not Santa Claus\")\n+}"}, {"sha": "9000cdc814b1fe7fe27ec966785d9d106851dd2f", "filename": "src/tools/clippy/tests/ui/redundant_else.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_else.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,80 @@\n+error: redundant else block\n+  --> $DIR/redundant_else.rs:10:16\n+   |\n+LL |           } else {\n+   |  ________________^\n+LL | |             println!(\"yet don't pull down your hedge.\");\n+LL | |         }\n+   | |_________^\n+   |\n+   = note: `-D clippy::redundant-else` implied by `-D warnings`\n+   = help: remove the `else` block and move the contents out\n+\n+error: redundant else block\n+  --> $DIR/redundant_else.rs:17:16\n+   |\n+LL |           } else {\n+   |  ________________^\n+LL | |             println!(\"shall rise up with fleas.\");\n+LL | |         }\n+   | |_________^\n+   |\n+   = help: remove the `else` block and move the contents out\n+\n+error: redundant else block\n+  --> $DIR/redundant_else.rs:26:16\n+   |\n+LL |           } else {\n+   |  ________________^\n+LL | |             println!(\"You may delay, but time will not.\");\n+LL | |         }\n+   | |_________^\n+   |\n+   = help: remove the `else` block and move the contents out\n+\n+error: redundant else block\n+  --> $DIR/redundant_else.rs:35:12\n+   |\n+LL |       } else {\n+   |  ____________^\n+LL | |         println!(\"A fat kitchen makes a lean will.\");\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: remove the `else` block and move the contents out\n+\n+error: redundant else block\n+  --> $DIR/redundant_else.rs:42:16\n+   |\n+LL |           } else {\n+   |  ________________^\n+LL | |             1\n+LL | |         }\n+   | |_________^\n+   |\n+   = help: remove the `else` block and move the contents out\n+\n+error: redundant else block\n+  --> $DIR/redundant_else.rs:52:16\n+   |\n+LL |           } else {\n+   |  ________________^\n+LL | |             2\n+LL | |         }\n+   | |_________^\n+   |\n+   = help: remove the `else` block and move the contents out\n+\n+error: redundant else block\n+  --> $DIR/redundant_else.rs:61:16\n+   |\n+LL |           } else {\n+   |  ________________^\n+LL | |             1\n+LL | |         }\n+   | |_________^\n+   |\n+   = help: remove the `else` block and move the contents out\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "226010ec6df3a24c63898f53a81c227b8a3781af", "filename": "src/tools/clippy/tests/ui/suspicious_else_formatting.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_else_formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_else_formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_else_formatting.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,79 @@\n+#![warn(clippy::suspicious_else_formatting)]\n+\n+fn foo() -> bool {\n+    true\n+}\n+\n+#[rustfmt::skip]\n+fn main() {\n+    // weird `else` formatting:\n+    if foo() {\n+    } {\n+    }\n+\n+    if foo() {\n+    } if foo() {\n+    }\n+\n+    let _ = { // if as the last expression\n+        let _ = 0;\n+\n+        if foo() {\n+        } if foo() {\n+        }\n+        else {\n+        }\n+    };\n+\n+    let _ = { // if in the middle of a block\n+        if foo() {\n+        } if foo() {\n+        }\n+        else {\n+        }\n+\n+        let _ = 0;\n+    };\n+\n+    if foo() {\n+    } else\n+    {\n+    }\n+\n+    if foo() {\n+    }\n+    else\n+    {\n+    }\n+\n+    if foo() {\n+    } else\n+    if foo() { // the span of the above error should continue here\n+    }\n+\n+    if foo() {\n+    }\n+    else\n+    if foo() { // the span of the above error should continue here\n+    }\n+\n+    // those are ok:\n+    if foo() {\n+    }\n+    {\n+    }\n+\n+    if foo() {\n+    } else {\n+    }\n+\n+    if foo() {\n+    }\n+    else {\n+    }\n+\n+    if foo() {\n+    }\n+    if foo() {\n+    }\n+}"}, {"sha": "bbc036d376fefc9ead1a8cb034eceb23f3a728c5", "filename": "src/tools/clippy/tests/ui/suspicious_else_formatting.stderr", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_else_formatting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_else_formatting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsuspicious_else_formatting.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,77 @@\n+error: this looks like an `else {..}` but the `else` is missing\n+  --> $DIR/suspicious_else_formatting.rs:11:6\n+   |\n+LL |     } {\n+   |      ^\n+   |\n+   = note: `-D clippy::suspicious-else-formatting` implied by `-D warnings`\n+   = note: to remove this lint, add the missing `else` or add a new line before the next block\n+\n+error: this looks like an `else if` but the `else` is missing\n+  --> $DIR/suspicious_else_formatting.rs:15:6\n+   |\n+LL |     } if foo() {\n+   |      ^\n+   |\n+   = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n+\n+error: this looks like an `else if` but the `else` is missing\n+  --> $DIR/suspicious_else_formatting.rs:22:10\n+   |\n+LL |         } if foo() {\n+   |          ^\n+   |\n+   = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n+\n+error: this looks like an `else if` but the `else` is missing\n+  --> $DIR/suspicious_else_formatting.rs:30:10\n+   |\n+LL |         } if foo() {\n+   |          ^\n+   |\n+   = note: to remove this lint, add the missing `else` or add a new line before the second `if`\n+\n+error: this is an `else {..}` but the formatting might hide it\n+  --> $DIR/suspicious_else_formatting.rs:39:6\n+   |\n+LL |       } else\n+   |  ______^\n+LL | |     {\n+   | |____^\n+   |\n+   = note: to remove this lint, remove the `else` or remove the new line between `else` and `{..}`\n+\n+error: this is an `else {..}` but the formatting might hide it\n+  --> $DIR/suspicious_else_formatting.rs:44:6\n+   |\n+LL |       }\n+   |  ______^\n+LL | |     else\n+LL | |     {\n+   | |____^\n+   |\n+   = note: to remove this lint, remove the `else` or remove the new line between `else` and `{..}`\n+\n+error: this is an `else if` but the formatting might hide it\n+  --> $DIR/suspicious_else_formatting.rs:50:6\n+   |\n+LL |       } else\n+   |  ______^\n+LL | |     if foo() { // the span of the above error should continue here\n+   | |____^\n+   |\n+   = note: to remove this lint, remove the `else` or remove the new line between `else` and `if`\n+\n+error: this is an `else if` but the formatting might hide it\n+  --> $DIR/suspicious_else_formatting.rs:55:6\n+   |\n+LL |       }\n+   |  ______^\n+LL | |     else\n+LL | |     if foo() { // the span of the above error should continue here\n+   | |____^\n+   |\n+   = note: to remove this lint, remove the `else` or remove the new line between `else` and `if`\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "9df1ae568673084298ac3c1acb5672c602616a50", "filename": "src/tools/clippy/tests/ui/unnecessary_clone.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -30,21 +30,21 @@ error: using `.clone()` on a ref-counted pointer\n LL |     let _: Arc<dyn SomeTrait> = x.clone();\n    |                                 ^^^^^^^^^ help: try this: `Arc::<SomeImpl>::clone(&x)`\n \n-error: using `clone` on a `Copy` type\n+error: using `clone` on type `T` which implements the `Copy` trait\n   --> $DIR/unnecessary_clone.rs:40:5\n    |\n LL |     t.clone();\n    |     ^^^^^^^^^ help: try removing the `clone` call: `t`\n    |\n    = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n \n-error: using `clone` on a `Copy` type\n+error: using `clone` on type `std::option::Option<T>` which implements the `Copy` trait\n   --> $DIR/unnecessary_clone.rs:42:5\n    |\n LL |     Some(t).clone();\n    |     ^^^^^^^^^^^^^^^ help: try removing the `clone` call: `Some(t)`\n \n-error: using `clone` on a double-reference; this will copy the reference instead of cloning the inner type\n+error: using `clone` on a double-reference; this will copy the reference of type `&std::vec::Vec<i32>` instead of cloning the inner type\n   --> $DIR/unnecessary_clone.rs:48:22\n    |\n LL |     let z: &Vec<_> = y.clone();\n@@ -60,13 +60,13 @@ help: or try being explicit if you are sure, that you want to clone a reference\n LL |     let z: &Vec<_> = <&std::vec::Vec<i32>>::clone(y);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: using `clone` on a `Copy` type\n+error: using `clone` on type `many_derefs::E` which implements the `Copy` trait\n   --> $DIR/unnecessary_clone.rs:84:20\n    |\n LL |         let _: E = a.clone();\n    |                    ^^^^^^^^^ help: try dereferencing it: `*****a`\n \n-error: using `clone` on a double-reference; this will copy the reference instead of cloning the inner type\n+error: using `clone` on a double-reference; this will copy the reference of type `&[u8]` instead of cloning the inner type\n   --> $DIR/unnecessary_clone.rs:89:22\n    |\n LL |         let _ = &mut encoded.clone();\n@@ -81,7 +81,7 @@ help: or try being explicit if you are sure, that you want to clone a reference\n LL |         let _ = &mut <&[u8]>::clone(encoded);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: using `clone` on a double-reference; this will copy the reference instead of cloning the inner type\n+error: using `clone` on a double-reference; this will copy the reference of type `&[u8]` instead of cloning the inner type\n   --> $DIR/unnecessary_clone.rs:90:18\n    |\n LL |         let _ = &encoded.clone();"}, {"sha": "b05dd143bfd745f6901e2fd34109bdae5fdd611c", "filename": "src/tools/clippy/tests/ui/unnecessary_lazy_eval_unfixable.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval_unfixable.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -15,4 +15,8 @@ fn main() {\n     }\n     let _ = Ok(1).unwrap_or_else(|e::E| 2);\n     let _ = Ok(1).unwrap_or_else(|SomeStruct { .. }| 2);\n+\n+    // Fix #6343\n+    let arr = [(Some(1),)];\n+    Some(&0).and_then(|&i| arr[i].0);\n }"}, {"sha": "4391499a1e1f8e779470f3d1927dcd95c88eadd1", "filename": "src/tools/clippy/tests/ui/update-all-references.sh", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fupdate-all-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fupdate-all-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fupdate-all-references.sh?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,21 +1,3 @@\n #!/bin/bash\n \n-# A script to update the references for all tests. The idea is that\n-# you do a run, which will generate files in the build directory\n-# containing the (normalized) actual output of the compiler. You then\n-# run this script, which will copy those files over. If you find\n-# yourself manually editing a foo.stderr file, you're doing it wrong.\n-#\n-# See all `update-references.sh`, if you just want to update a single test.\n-\n-if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" ]]; then\n-    echo \"usage: $0\"\n-fi\n-\n-CARGO_TARGET_DIR=${CARGO_TARGET_DIR:-$PWD/target}\n-PROFILE=${PROFILE:-debug}\n-BUILD_DIR=${CARGO_TARGET_DIR}/${PROFILE}/test_build_base\n-\n-MY_DIR=$(dirname \"$0\")\n-cd \"$MY_DIR\" || exit\n-find . -name '*.rs' -exec ./update-references.sh \"$BUILD_DIR\" {} +\n+echo \"Please use 'cargo dev bless' instead.\""}, {"sha": "e16ed600ef81406785b05e7dce3ff641cb5c1de1", "filename": "src/tools/clippy/tests/ui/update-references.sh", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c8135455c4a96b1d2570198619f38185c063579d/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c8135455c4a96b1d2570198619f38185c063579d/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fupdate-references.sh?ref=c8135455c4a96b1d2570198619f38185c063579d", "patch": "@@ -1,56 +0,0 @@\n-#!/bin/bash\n-\n-# A script to update the references for particular tests. The idea is\n-# that you do a run, which will generate files in the build directory\n-# containing the (normalized) actual output of the compiler. This\n-# script will then copy that output and replace the \"expected output\"\n-# files. You can then commit the changes.\n-#\n-# If you find yourself manually editing a `foo.stderr` file, you're\n-# doing it wrong.\n-\n-if [[ \"$1\" == \"--help\" || \"$1\" == \"-h\" || \"$1\" == \"\" || \"$2\" == \"\" ]]; then\n-    echo \"usage: $0 <build-directory> <relative-path-to-rs-files>\"\n-    echo \"\"\n-    echo \"For example:\"\n-    echo \"   $0 ../../../build/x86_64-apple-darwin/test/ui *.rs */*.rs\"\n-fi\n-\n-MYDIR=$(dirname \"$0\")\n-\n-BUILD_DIR=\"$1\"\n-shift\n-\n-while [[ \"$1\" != \"\" ]]; do\n-    STDERR_NAME=\"${1/%.rs/.stderr}\"\n-    STDOUT_NAME=\"${1/%.rs/.stdout}\"\n-    FIXED_NAME=\"${1/%.rs/.fixed}\"\n-    shift\n-    if [[ -f \"$BUILD_DIR\"/\"$STDOUT_NAME\" ]] && \\\n-           ! (cmp -s -- \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"); then\n-        echo updating \"$MYDIR\"/\"$STDOUT_NAME\"\n-        cp \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"\n-        if [[ ! -s \"$MYDIR\"/\"$STDOUT_NAME\" ]]; then\n-            echo removing \"$MYDIR\"/\"$STDOUT_NAME\"\n-            rm \"$MYDIR\"/\"$STDOUT_NAME\"\n-        fi\n-    fi\n-    if [[ -f \"$BUILD_DIR\"/\"$STDERR_NAME\" ]] && \\\n-           ! (cmp -s -- \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"); then\n-        echo updating \"$MYDIR\"/\"$STDERR_NAME\"\n-        cp \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"\n-        if [[ ! -s \"$MYDIR\"/\"$STDERR_NAME\" ]]; then\n-            echo removing \"$MYDIR\"/\"$STDERR_NAME\"\n-            rm \"$MYDIR\"/\"$STDERR_NAME\"\n-        fi\n-    fi\n-    if [[ -f \"$BUILD_DIR\"/\"$FIXED_NAME\" ]] && \\\n-           ! (cmp -s -- \"$BUILD_DIR\"/\"$FIXED_NAME\" \"$MYDIR\"/\"$FIXED_NAME\"); then\n-        echo updating \"$MYDIR\"/\"$FIXED_NAME\"\n-        cp \"$BUILD_DIR\"/\"$FIXED_NAME\" \"$MYDIR\"/\"$FIXED_NAME\"\n-        if [[ ! -s \"$MYDIR\"/\"$FIXED_NAME\" ]]; then\n-            echo removing \"$MYDIR\"/\"$FIXED_NAME\"\n-            rm \"$MYDIR\"/\"$FIXED_NAME\"\n-        fi\n-    fi\n-done"}, {"sha": "d6a890014e681f228a59f46550980af25be8e3c1", "filename": "src/tools/clippy/tests/ui/use_self.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.fixed?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -71,6 +71,7 @@ mod lifetimes {\n \n mod issue2894 {\n     trait IntoBytes {\n+        #[allow(clippy::wrong_self_convention)]\n         fn into_bytes(&self) -> Vec<u8>;\n     }\n "}, {"sha": "b04d9ce75b2a57aab483aa427f699d3efe54aa33", "filename": "src/tools/clippy/tests/ui/use_self.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -71,6 +71,7 @@ mod lifetimes {\n \n mod issue2894 {\n     trait IntoBytes {\n+        #[allow(clippy::wrong_self_convention)]\n         fn into_bytes(&self) -> Vec<u8>;\n     }\n "}, {"sha": "80e1bfc75e80a379dac65b82a5b304d802eeefa2", "filename": "src/tools/clippy/tests/ui/use_self.stderr", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fuse_self.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -37,19 +37,19 @@ LL |             Foo::new()\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:89:56\n+  --> $DIR/use_self.rs:90:56\n    |\n LL |         fn bad(foos: &[Self]) -> impl Iterator<Item = &Foo> {\n    |                                                        ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:104:13\n+  --> $DIR/use_self.rs:105:13\n    |\n LL |             TS(0)\n    |             ^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:112:25\n+  --> $DIR/use_self.rs:113:25\n    |\n LL |             fn new() -> Foo {\n    |                         ^^^ help: use the applicable keyword: `Self`\n@@ -60,7 +60,7 @@ LL |         use_self_expand!(); // Should lint in local macros\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:113:17\n+  --> $DIR/use_self.rs:114:17\n    |\n LL |                 Foo {}\n    |                 ^^^ help: use the applicable keyword: `Self`\n@@ -71,91 +71,91 @@ LL |         use_self_expand!(); // Should lint in local macros\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:148:21\n+  --> $DIR/use_self.rs:149:21\n    |\n LL |         fn baz() -> Foo {\n    |                     ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:149:13\n+  --> $DIR/use_self.rs:150:13\n    |\n LL |             Foo {}\n    |             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:136:29\n+  --> $DIR/use_self.rs:137:29\n    |\n LL |                 fn bar() -> Bar {\n    |                             ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:137:21\n+  --> $DIR/use_self.rs:138:21\n    |\n LL |                     Bar { foo: Foo {} }\n    |                     ^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:166:21\n+  --> $DIR/use_self.rs:167:21\n    |\n LL |             let _ = Enum::B(42);\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:167:21\n+  --> $DIR/use_self.rs:168:21\n    |\n LL |             let _ = Enum::C { field: true };\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:168:21\n+  --> $DIR/use_self.rs:169:21\n    |\n LL |             let _ = Enum::A;\n    |                     ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:199:13\n+  --> $DIR/use_self.rs:200:13\n    |\n LL |             nested::A::fun_1();\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:200:13\n+  --> $DIR/use_self.rs:201:13\n    |\n LL |             nested::A::A;\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:202:13\n+  --> $DIR/use_self.rs:203:13\n    |\n LL |             nested::A {};\n    |             ^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:221:13\n+  --> $DIR/use_self.rs:222:13\n    |\n LL |             TestStruct::from_something()\n    |             ^^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:235:25\n+  --> $DIR/use_self.rs:236:25\n    |\n LL |         async fn g() -> S {\n    |                         ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:236:13\n+  --> $DIR/use_self.rs:237:13\n    |\n LL |             S {}\n    |             ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:240:16\n+  --> $DIR/use_self.rs:241:16\n    |\n LL |             &p[S::A..S::B]\n    |                ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/use_self.rs:240:22\n+  --> $DIR/use_self.rs:241:22\n    |\n LL |             &p[S::A..S::B]\n    |                      ^ help: use the applicable keyword: `Self`"}, {"sha": "5282eba74fd1872adc52f3a59086492826a80411", "filename": "src/tools/clippy/tests/ui/wrong_self_convention.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -88,3 +88,52 @@ mod issue4037 {\n         }\n     }\n }\n+\n+// Lint also in trait definition (see #6307)\n+mod issue6307 {\n+    trait T: Sized {\n+        fn as_i32(self) {}\n+        fn as_u32(&self) {}\n+        fn into_i32(&self) {}\n+        fn into_u32(self) {}\n+        fn is_i32(self) {}\n+        fn is_u32(&self) {}\n+        fn to_i32(self) {}\n+        fn to_u32(&self) {}\n+        fn from_i32(self) {}\n+        // check whether the lint can be allowed at the function level\n+        #[allow(clippy::wrong_self_convention)]\n+        fn from_cake(self) {}\n+\n+        // test for false positives\n+        fn as_(self) {}\n+        fn into_(&self) {}\n+        fn is_(self) {}\n+        fn to_(self) {}\n+        fn from_(self) {}\n+        fn to_mut(&mut self) {}\n+    }\n+\n+    trait U {\n+        fn as_i32(self);\n+        fn as_u32(&self);\n+        fn into_i32(&self);\n+        fn into_u32(self);\n+        fn is_i32(self);\n+        fn is_u32(&self);\n+        fn to_i32(self);\n+        fn to_u32(&self);\n+        fn from_i32(self);\n+        // check whether the lint can be allowed at the function level\n+        #[allow(clippy::wrong_self_convention)]\n+        fn from_cake(self);\n+\n+        // test for false positives\n+        fn as_(self);\n+        fn into_(&self);\n+        fn is_(self);\n+        fn to_(self);\n+        fn from_(self);\n+        fn to_mut(&mut self);\n+    }\n+}"}, {"sha": "86467eb0fc7371c96564b42dbaf70af108297833", "filename": "src/tools/clippy/tests/ui/wrong_self_convention.stderr", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwrong_self_convention.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -72,5 +72,65 @@ error: methods called `from_*` usually take no self; consider choosing a less am\n LL |     pub fn from_i64(self) {}\n    |                     ^^^^\n \n-error: aborting due to 12 previous errors\n+error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n+  --> $DIR/wrong_self_convention.rs:95:19\n+   |\n+LL |         fn as_i32(self) {}\n+   |                   ^^^^\n+\n+error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n+  --> $DIR/wrong_self_convention.rs:97:21\n+   |\n+LL |         fn into_i32(&self) {}\n+   |                     ^^^^^\n+\n+error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n+  --> $DIR/wrong_self_convention.rs:99:19\n+   |\n+LL |         fn is_i32(self) {}\n+   |                   ^^^^\n+\n+error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n+  --> $DIR/wrong_self_convention.rs:101:19\n+   |\n+LL |         fn to_i32(self) {}\n+   |                   ^^^^\n+\n+error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n+  --> $DIR/wrong_self_convention.rs:103:21\n+   |\n+LL |         fn from_i32(self) {}\n+   |                     ^^^^\n+\n+error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n+  --> $DIR/wrong_self_convention.rs:118:19\n+   |\n+LL |         fn as_i32(self);\n+   |                   ^^^^\n+\n+error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n+  --> $DIR/wrong_self_convention.rs:120:21\n+   |\n+LL |         fn into_i32(&self);\n+   |                     ^^^^^\n+\n+error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n+  --> $DIR/wrong_self_convention.rs:122:19\n+   |\n+LL |         fn is_i32(self);\n+   |                   ^^^^\n+\n+error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n+  --> $DIR/wrong_self_convention.rs:124:19\n+   |\n+LL |         fn to_i32(self);\n+   |                   ^^^^\n+\n+error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n+  --> $DIR/wrong_self_convention.rs:126:21\n+   |\n+LL |         fn from_i32(self);\n+   |                     ^^^^\n+\n+error: aborting due to 22 previous errors\n "}, {"sha": "5cd254787d834b387c6ea1d1675c2cfa115b43b6", "filename": "src/tools/clippy/tests/ui/zero_sized_btreemap_values.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_sized_btreemap_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_sized_btreemap_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_sized_btreemap_values.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,68 @@\n+#![warn(clippy::zero_sized_map_values)]\n+use std::collections::BTreeMap;\n+\n+const CONST_OK: Option<BTreeMap<String, usize>> = None;\n+const CONST_NOT_OK: Option<BTreeMap<String, ()>> = None;\n+\n+static STATIC_OK: Option<BTreeMap<String, usize>> = None;\n+static STATIC_NOT_OK: Option<BTreeMap<String, ()>> = None;\n+\n+type OkMap = BTreeMap<String, usize>;\n+type NotOkMap = BTreeMap<String, ()>;\n+\n+enum TestEnum {\n+    Ok(BTreeMap<String, usize>),\n+    NotOk(BTreeMap<String, ()>),\n+}\n+\n+struct Test {\n+    ok: BTreeMap<String, usize>,\n+    not_ok: BTreeMap<String, ()>,\n+\n+    also_not_ok: Vec<BTreeMap<usize, ()>>,\n+}\n+\n+trait TestTrait {\n+    type Output;\n+\n+    fn produce_output() -> Self::Output;\n+\n+    fn weird_map(&self, map: BTreeMap<usize, ()>);\n+}\n+\n+impl Test {\n+    fn ok(&self) -> BTreeMap<String, usize> {\n+        todo!()\n+    }\n+\n+    fn not_ok(&self) -> BTreeMap<String, ()> {\n+        todo!()\n+    }\n+}\n+\n+impl TestTrait for Test {\n+    type Output = BTreeMap<String, ()>;\n+\n+    fn produce_output() -> Self::Output {\n+        todo!();\n+    }\n+\n+    fn weird_map(&self, map: BTreeMap<usize, ()>) {\n+        todo!();\n+    }\n+}\n+\n+fn test(map: BTreeMap<String, ()>, key: &str) -> BTreeMap<String, ()> {\n+    todo!();\n+}\n+\n+fn test2(map: BTreeMap<String, usize>, key: &str) -> BTreeMap<String, usize> {\n+    todo!();\n+}\n+\n+fn main() {\n+    let _: BTreeMap<String, ()> = BTreeMap::new();\n+    let _: BTreeMap<String, usize> = BTreeMap::new();\n+\n+    let _: BTreeMap<_, _> = std::iter::empty::<(String, ())>().collect();\n+}"}, {"sha": "334d921a9af3fee977cb2c47d422056b4de385af", "filename": "src/tools/clippy/tests/ui/zero_sized_btreemap_values.stderr", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_sized_btreemap_values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_sized_btreemap_values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_sized_btreemap_values.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,107 @@\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_btreemap_values.rs:5:28\n+   |\n+LL | const CONST_NOT_OK: Option<BTreeMap<String, ()>> = None;\n+   |                            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::zero-sized-map-values` implied by `-D warnings`\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_btreemap_values.rs:8:30\n+   |\n+LL | static STATIC_NOT_OK: Option<BTreeMap<String, ()>> = None;\n+   |                              ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_btreemap_values.rs:11:17\n+   |\n+LL | type NotOkMap = BTreeMap<String, ()>;\n+   |                 ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_btreemap_values.rs:15:11\n+   |\n+LL |     NotOk(BTreeMap<String, ()>),\n+   |           ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_btreemap_values.rs:20:13\n+   |\n+LL |     not_ok: BTreeMap<String, ()>,\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_btreemap_values.rs:22:22\n+   |\n+LL |     also_not_ok: Vec<BTreeMap<usize, ()>>,\n+   |                      ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_btreemap_values.rs:30:30\n+   |\n+LL |     fn weird_map(&self, map: BTreeMap<usize, ()>);\n+   |                              ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_btreemap_values.rs:38:25\n+   |\n+LL |     fn not_ok(&self) -> BTreeMap<String, ()> {\n+   |                         ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_btreemap_values.rs:55:14\n+   |\n+LL | fn test(map: BTreeMap<String, ()>, key: &str) -> BTreeMap<String, ()> {\n+   |              ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_btreemap_values.rs:55:50\n+   |\n+LL | fn test(map: BTreeMap<String, ()>, key: &str) -> BTreeMap<String, ()> {\n+   |                                                  ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_btreemap_values.rs:64:35\n+   |\n+LL |     let _: BTreeMap<String, ()> = BTreeMap::new();\n+   |                                   ^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_btreemap_values.rs:64:12\n+   |\n+LL |     let _: BTreeMap<String, ()> = BTreeMap::new();\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_btreemap_values.rs:67:12\n+   |\n+LL |     let _: BTreeMap<_, _> = std::iter::empty::<(String, ())>().collect();\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: aborting due to 13 previous errors\n+"}, {"sha": "a1608d863fb52cb4c05e336ed40d323387554784", "filename": "src/tools/clippy/tests/ui/zero_sized_hashmap_values.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_sized_hashmap_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_sized_hashmap_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_sized_hashmap_values.rs?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,68 @@\n+#![warn(clippy::zero_sized_map_values)]\n+use std::collections::HashMap;\n+\n+const CONST_OK: Option<HashMap<String, usize>> = None;\n+const CONST_NOT_OK: Option<HashMap<String, ()>> = None;\n+\n+static STATIC_OK: Option<HashMap<String, usize>> = None;\n+static STATIC_NOT_OK: Option<HashMap<String, ()>> = None;\n+\n+type OkMap = HashMap<String, usize>;\n+type NotOkMap = HashMap<String, ()>;\n+\n+enum TestEnum {\n+    Ok(HashMap<String, usize>),\n+    NotOk(HashMap<String, ()>),\n+}\n+\n+struct Test {\n+    ok: HashMap<String, usize>,\n+    not_ok: HashMap<String, ()>,\n+\n+    also_not_ok: Vec<HashMap<usize, ()>>,\n+}\n+\n+trait TestTrait {\n+    type Output;\n+\n+    fn produce_output() -> Self::Output;\n+\n+    fn weird_map(&self, map: HashMap<usize, ()>);\n+}\n+\n+impl Test {\n+    fn ok(&self) -> HashMap<String, usize> {\n+        todo!()\n+    }\n+\n+    fn not_ok(&self) -> HashMap<String, ()> {\n+        todo!()\n+    }\n+}\n+\n+impl TestTrait for Test {\n+    type Output = HashMap<String, ()>;\n+\n+    fn produce_output() -> Self::Output {\n+        todo!();\n+    }\n+\n+    fn weird_map(&self, map: HashMap<usize, ()>) {\n+        todo!();\n+    }\n+}\n+\n+fn test(map: HashMap<String, ()>, key: &str) -> HashMap<String, ()> {\n+    todo!();\n+}\n+\n+fn test2(map: HashMap<String, usize>, key: &str) -> HashMap<String, usize> {\n+    todo!();\n+}\n+\n+fn main() {\n+    let _: HashMap<String, ()> = HashMap::new();\n+    let _: HashMap<String, usize> = HashMap::new();\n+\n+    let _: HashMap<_, _> = std::iter::empty::<(String, ())>().collect();\n+}"}, {"sha": "43987b3d01d16a408cdf19f5a9dd405f75dc276d", "filename": "src/tools/clippy/tests/ui/zero_sized_hashmap_values.stderr", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_sized_hashmap_values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_sized_hashmap_values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fzero_sized_hashmap_values.stderr?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -0,0 +1,107 @@\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_hashmap_values.rs:5:28\n+   |\n+LL | const CONST_NOT_OK: Option<HashMap<String, ()>> = None;\n+   |                            ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::zero-sized-map-values` implied by `-D warnings`\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_hashmap_values.rs:8:30\n+   |\n+LL | static STATIC_NOT_OK: Option<HashMap<String, ()>> = None;\n+   |                              ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_hashmap_values.rs:11:17\n+   |\n+LL | type NotOkMap = HashMap<String, ()>;\n+   |                 ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_hashmap_values.rs:15:11\n+   |\n+LL |     NotOk(HashMap<String, ()>),\n+   |           ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_hashmap_values.rs:20:13\n+   |\n+LL |     not_ok: HashMap<String, ()>,\n+   |             ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_hashmap_values.rs:22:22\n+   |\n+LL |     also_not_ok: Vec<HashMap<usize, ()>>,\n+   |                      ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_hashmap_values.rs:30:30\n+   |\n+LL |     fn weird_map(&self, map: HashMap<usize, ()>);\n+   |                              ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_hashmap_values.rs:38:25\n+   |\n+LL |     fn not_ok(&self) -> HashMap<String, ()> {\n+   |                         ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_hashmap_values.rs:55:14\n+   |\n+LL | fn test(map: HashMap<String, ()>, key: &str) -> HashMap<String, ()> {\n+   |              ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_hashmap_values.rs:55:49\n+   |\n+LL | fn test(map: HashMap<String, ()>, key: &str) -> HashMap<String, ()> {\n+   |                                                 ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_hashmap_values.rs:64:34\n+   |\n+LL |     let _: HashMap<String, ()> = HashMap::new();\n+   |                                  ^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_hashmap_values.rs:64:12\n+   |\n+LL |     let _: HashMap<String, ()> = HashMap::new();\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: map with zero-sized value type\n+  --> $DIR/zero_sized_hashmap_values.rs:67:12\n+   |\n+LL |     let _: HashMap<_, _> = std::iter::empty::<(String, ())>().collect();\n+   |            ^^^^^^^^^^^^^\n+   |\n+   = help: consider using a set instead\n+\n+error: aborting due to 13 previous errors\n+"}, {"sha": "b9549be3a8b632bfe37fec34384ab26e857f1d00", "filename": "src/tools/clippy/triagebot.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftriagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Ftriagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftriagebot.toml?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -1,7 +1,7 @@\n [relabel]\n allow-unauthenticated = [\n     \"A-*\", \"C-*\", \"E-*\", \"L-*\", \"M-*\", \"O-*\", \"P-*\", \"S-*\", \"T-*\",\n-    \"good first issue\"\n+    \"good-first-issue\"\n ]\n \n [assign]"}, {"sha": "428708136cb650df91b01ba72d1553ce68cf6572", "filename": "src/tools/clippy/util/gh-pages/index.html", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Futil%2Fgh-pages%2Findex.html", "raw_url": "https://github.com/rust-lang/rust/raw/15d1f811963649c2f18a88c8e0b39958ec02fd70/src%2Ftools%2Fclippy%2Futil%2Fgh-pages%2Findex.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Futil%2Fgh-pages%2Findex.html?ref=15d1f811963649c2f18a88c8e0b39958ec02fd70", "patch": "@@ -89,7 +89,7 @@ <h1>ALL the Clippy Lints</h1>\n             </div>\n \n             <article class=\"panel panel-default\" id=\"{{lint.id}}\"\n-                ng-repeat=\"lint in data | filter:byLevels | filter:byGroups | filter:search | orderBy:'id' track by lint.id\" on-finish-render=\"ngRepeatFinished\">\n+                ng-repeat=\"lint in data | filter:byLevels | filter:byGroups | filter:bySearch | orderBy:'id' track by lint.id\">\n                 <header class=\"panel-heading\" ng-click=\"open[lint.id] = !open[lint.id]\">\n                     <h2 class=\"panel-title\">\n                         <div class=\"panel-title-name\">\n@@ -215,6 +215,46 @@ <h4 class=\"list-group-item-heading\">\n                 return $scope.groups[lint.group];\n             };\n \n+            $scope.bySearch = function (lint, index, array) {\n+                let search_str = $scope.search;\n+                // It can be `null` I haven't missed this value \n+                if (search_str == null || search_str.length == 0) {\n+                    return true;\n+                }\n+                search_str = search_str.toLowerCase();\n+\n+                // Search by id\n+                let id_search = search_str.trim().replace(/(\\-| )/g, \"_\");\n+                if (lint.id.includes(id_search)) {\n+                    return true;\n+                }\n+\n+                // Search the description\n+                // The use of `for`-loops instead of `foreach` enables us to return early \n+                let search_lint = (lint, therm) => {\n+                    for (const field in lint.docs) {\n+                        // Continue if it's not a property\n+                        if (!lint.docs.hasOwnProperty(field)) {\n+                            continue;\n+                        }\n+\n+                        // Return if not found\n+                        if (lint.docs[field].toLowerCase().includes(therm)) {\n+                            return true;\n+                        }\n+                    }\n+                    return false;\n+                };\n+                let therms = search_str.split(\" \");\n+                for (index = 0; index < therms.length; index++) {\n+                    if (!search_lint(lint, therms[index])) {\n+                        return false;\n+                    }\n+                }\n+\n+                return true;\n+            }\n+\n             // Get data\n             $scope.open = {};\n             $scope.loading = true;"}]}