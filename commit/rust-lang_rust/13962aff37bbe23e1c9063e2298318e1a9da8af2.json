{"sha": "13962aff37bbe23e1c9063e2298318e1a9da8af2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzOTYyYWZmMzdiYmUyM2UxYzkwNjNlMjI5ODMxOGUxYTlkYThhZjI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-04-27T12:52:42Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-04-30T21:43:51Z"}, "message": "Include signed integer types in the lint", "tree": {"sha": "42c3cdeb87b7f2b0dc02506c4a5329a981402689", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42c3cdeb87b7f2b0dc02506c4a5329a981402689"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13962aff37bbe23e1c9063e2298318e1a9da8af2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13962aff37bbe23e1c9063e2298318e1a9da8af2", "html_url": "https://github.com/rust-lang/rust/commit/13962aff37bbe23e1c9063e2298318e1a9da8af2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13962aff37bbe23e1c9063e2298318e1a9da8af2/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0556e4891ef6e73ee886526cd39d4887850b1a1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0556e4891ef6e73ee886526cd39d4887850b1a1a", "html_url": "https://github.com/rust-lang/rust/commit/0556e4891ef6e73ee886526cd39d4887850b1a1a"}], "stats": {"total": 151, "additions": 96, "deletions": 55}, "files": [{"sha": "379b20ab760340b1c61faacc2e96b3e85cab5858", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 88, "deletions": 54, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/13962aff37bbe23e1c9063e2298318e1a9da8af2/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13962aff37bbe23e1c9063e2298318e1a9da8af2/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=13962aff37bbe23e1c9063e2298318e1a9da8af2", "patch": "@@ -58,6 +58,61 @@ impl TypeLimits {\n     }\n }\n \n+/// Attempts to special-case the overflowing literal lint when it occurs as a range endpoint.\n+/// Returns `true` iff the lint was overridden.\n+fn lint_overflowing_range_endpoint<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    lit: &ast::Lit,\n+    lit_val: u128,\n+    max: u128,\n+    expr: &'tcx hir::Expr,\n+    parent_expr: &'tcx hir::Expr,\n+    ty: impl std::fmt::Debug,\n+) -> bool {\n+    // We only want to handle exclusive (`..`) ranges,\n+    // which are represented as `ExprKind::Struct`.\n+    if let ExprKind::Struct(_, eps, _) = &parent_expr.node {\n+        debug_assert_eq!(eps.len(), 2);\n+        // We can suggest using an inclusive range\n+        // (`..=`) instead only if it is the `end` that is\n+        // overflowing and only by 1.\n+        if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max {\n+            let mut err = cx.struct_span_lint(\n+                OVERFLOWING_LITERALS,\n+                parent_expr.span,\n+                &format!(\"range endpoint is out of range for `{:?}`\", ty),\n+            );\n+            if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n+                use ast::{LitKind, LitIntType};\n+                // We need to preserve the literal's suffix,\n+                // as it may determine typing information.\n+                let suffix = match lit.node {\n+                    LitKind::Int(_, LitIntType::Signed(s)) => format!(\"{}\", s),\n+                    LitKind::Int(_, LitIntType::Unsigned(s)) => format!(\"{}\", s),\n+                    LitKind::Int(_, LitIntType::Unsuffixed) => \"\".to_owned(),\n+                    _ => bug!(),\n+                };\n+                let suggestion = format!(\n+                    \"{}..={}{}\",\n+                    start,\n+                    lit_val - 1,\n+                    suffix,\n+                );\n+                err.span_suggestion(\n+                    parent_expr.span,\n+                    &\"use an inclusive range instead\",\n+                    suggestion,\n+                    Applicability::MachineApplicable,\n+                );\n+                err.emit();\n+                return true;\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n         match e.node {\n@@ -103,6 +158,27 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                         );\n                                         return;\n                                     }\n+\n+                                    let par_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n+                                    if let Node::Expr(par_e) = cx.tcx.hir().get_by_hir_id(par_id) {\n+                                        if let hir::ExprKind::Struct(..) = par_e.node {\n+                                            if is_range_literal(cx.sess(), par_e)\n+                                                && lint_overflowing_range_endpoint(\n+                                                    cx,\n+                                                    lit,\n+                                                    v,\n+                                                    max,\n+                                                    e,\n+                                                    par_e,\n+                                                    t,\n+                                                )\n+                                            {\n+                                                    // The overflowing literal lint was overridden.\n+                                                    return;\n+                                            }\n+                                        }\n+                                    }\n+\n                                     cx.span_lint(\n                                         OVERFLOWING_LITERALS,\n                                         e.span,\n@@ -150,61 +226,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                     }\n                                     hir::ExprKind::Struct(..)\n                                         if is_range_literal(cx.sess(), parent_expr) => {\n-                                            // We only want to handle exclusive (`..`) ranges,\n-                                            // which are represented as `ExprKind::Struct`.\n-                                            if let ExprKind::Struct(_, eps, _) = &parent_expr.node {\n-                                                debug_assert_eq!(eps.len(), 2);\n-                                                // We can suggest using an inclusive range\n-                                                // (`..=`) instead only if it is the `end` that is\n-                                                // overflowing and only by 1.\n-                                                if eps[1].expr.hir_id == e.hir_id\n-                                                    && lit_val - 1 == max\n-                                                {\n-                                                    let mut err = cx.struct_span_lint(\n-                                                        OVERFLOWING_LITERALS,\n-                                                        parent_expr.span,\n-                                                        &format!(\n-                                                            \"range endpoint is out of range \\\n-                                                             for `{:?}`\",\n-                                                            t,\n-                                                        ),\n-                                                    );\n-                                                    if let Ok(start) = cx.sess().source_map()\n-                                                        .span_to_snippet(eps[0].span)\n-                                                    {\n-                                                        use ast::{LitKind::*, LitIntType};\n-                                                        // We need to preserve the literal's suffix,\n-                                                        // as it may determine typing information.\n-                                                        let suffix = match lit.node {\n-                                                            Int(_, LitIntType::Signed(s)) => {\n-                                                                format!(\"{}\", s)\n-                                                            }\n-                                                            Int(_, LitIntType::Unsigned(s)) => {\n-                                                                format!(\"{}\", s)\n-                                                            }\n-                                                            Int(_, LitIntType::Unsuffixed) => {\n-                                                                \"\".to_owned()\n-                                                            }\n-                                                            _ => bug!(),\n-                                                        };\n-                                                        let suggestion = format!(\n-                                                            \"{}..={}{}\",\n-                                                            start,\n-                                                            lit_val - 1,\n-                                                            suffix,\n-                                                        );\n-                                                        err.span_suggestion(\n-                                                            parent_expr.span,\n-                                                            &\"use an inclusive range instead\",\n-                                                            suggestion,\n-                                                            Applicability::MachineApplicable,\n-                                                        );\n-                                                        err.emit();\n-                                                        return;\n-                                                    }\n-                                                }\n+                                            if lint_overflowing_range_endpoint(\n+                                                cx,\n+                                                lit,\n+                                                lit_val,\n+                                                max,\n+                                                e,\n+                                                parent_expr,\n+                                                t,\n+                                            ) {\n+                                                // The overflowing literal lint was overridden.\n+                                                return;\n                                             }\n-                                    }\n+                                        }\n                                     _ => {}\n                                 }\n                             }"}, {"sha": "7034d56aa5d8350a1c315f1be1927d95901d0492", "filename": "src/test/ui/lint/lint-range-endpoint-overflow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13962aff37bbe23e1c9063e2298318e1a9da8af2/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13962aff37bbe23e1c9063e2298318e1a9da8af2/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.rs?ref=13962aff37bbe23e1c9063e2298318e1a9da8af2", "patch": "@@ -7,6 +7,7 @@ fn main() {\n     let range_d = 256..5; //~ ERROR literal out of range for `u8`\n     let range_e = 0..257; //~ ERROR literal out of range for `u8`\n     let _range_f = 0..256u8;  //~ ERROR range endpoint is out of range for `u8`\n+    let _range_g = 0..128i8;  //~ ERROR range endpoint is out of range for `i8`\n \n     range_a.collect::<Vec<u8>>();\n     range_b.collect::<Vec<u8>>();"}, {"sha": "939451d6bc022edd6446e76b6e08f73f251e0d5a", "filename": "src/test/ui/lint/lint-range-endpoint-overflow.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13962aff37bbe23e1c9063e2298318e1a9da8af2/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13962aff37bbe23e1c9063e2298318e1a9da8af2/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-range-endpoint-overflow.stderr?ref=13962aff37bbe23e1c9063e2298318e1a9da8af2", "patch": "@@ -34,5 +34,11 @@ error: range endpoint is out of range for `u8`\n LL |     let _range_f = 0..256u8;\n    |                    ^^^^^^^^ help: use an inclusive range instead: `0..=255u8`\n \n-error: aborting due to 5 previous errors\n+error: range endpoint is out of range for `i8`\n+  --> $DIR/lint-range-endpoint-overflow.rs:10:20\n+   |\n+LL |     let _range_g = 0..128i8;\n+   |                    ^^^^^^^^ help: use an inclusive range instead: `0..=127i8`\n+\n+error: aborting due to 6 previous errors\n "}]}