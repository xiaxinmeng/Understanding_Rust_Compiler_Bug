{"sha": "a931e04b757a795e3867ea98c81cee731bd54ac1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MzFlMDRiNzU3YTc5NWUzODY3ZWE5OGM4MWNlZTczMWJkNTRhYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-09T04:41:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-09T04:41:05Z"}, "message": "auto merge of #8350 : dim-an/rust/fix-struct-match, r=pcwalton\n\nCode that collects fields in struct-like patterns used to ignore\r\nwildcard patterns like `Foo{_}`. But `enter_defaults` considered\r\nstruct-like patterns as default in order to overcome this\r\n(accoring to my understanding of situation).\r\n\r\nHowever such behaviour caused code like this:\r\n```\r\nenum E {\r\n    Foo{f: int},\r\n    Bar\r\n}\r\nlet e = Bar;\r\nmatch e {\r\n    Foo{f: _f} => { /* do something (1) */ }\r\n    _ => { /* do something (2) */ }\r\n}\r\n```\r\nconsider pattern `Foo{f: _f}` as default. That caused inproper behaviour\r\nand even segfaults while trying to destruct `Bar` as `Foo{f: _f}`.\r\nIssues: #5625 , #5530.\r\n\r\nThis patch fixes `collect_record_or_struct_fields` to split cases of\r\nsingle wildcard struct-like pattern and no struct-like pattern at all.\r\nFormer case resolved with `enter_rec_or_struct` (and not with\r\n`enter_defaults`).\r\n\r\nCloses #5625.\r\nCloses #5530.", "tree": {"sha": "b771c4bd5b7bb4aa0c70b92a4f8245f446cc4e24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b771c4bd5b7bb4aa0c70b92a4f8245f446cc4e24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a931e04b757a795e3867ea98c81cee731bd54ac1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a931e04b757a795e3867ea98c81cee731bd54ac1", "html_url": "https://github.com/rust-lang/rust/commit/a931e04b757a795e3867ea98c81cee731bd54ac1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a931e04b757a795e3867ea98c81cee731bd54ac1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a1b61d6317c27b735e5471d3d704584bea4c925", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a1b61d6317c27b735e5471d3d704584bea4c925", "html_url": "https://github.com/rust-lang/rust/commit/7a1b61d6317c27b735e5471d3d704584bea4c925"}, {"sha": "0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee", "html_url": "https://github.com/rust-lang/rust/commit/0fadfc5fb7de47f0ffcb55a8bbfe0a75c2a4dbee"}], "stats": {"total": 223, "additions": 158, "deletions": 65}, "files": [{"sha": "28c7df4b33a869e7f999d59db95d931ac637b18a", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a931e04b757a795e3867ea98c81cee731bd54ac1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a931e04b757a795e3867ea98c81cee731bd54ac1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=a931e04b757a795e3867ea98c81cee731bd54ac1", "patch": "@@ -821,7 +821,8 @@ pub fn optgroups() -> ~[getopts::groups::OptGroup] {\n   optmulti(\"\", \"cfg\", \"Configure the compilation\n                           environment\", \"SPEC\"),\n   optflag(\"\",  \"emit-llvm\",\n-                        \"Produce an LLVM bitcode file\"),\n+                        \"Produce an LLVM assembly file if used with -S option;\n+                         produce an LLVM bitcode file otherwise\"),\n   optflag(\"h\", \"help\",\"Display this message\"),\n   optmulti(\"L\", \"\",   \"Add a directory to the library search path\",\n                               \"PATH\"),"}, {"sha": "327d2e698c1e181915f6bcc41a555479ca967694", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 77, "deletions": 62, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/a931e04b757a795e3867ea98c81cee731bd54ac1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a931e04b757a795e3867ea98c81cee731bd54ac1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=a931e04b757a795e3867ea98c81cee731bd54ac1", "patch": "@@ -183,23 +183,23 @@ use syntax::codemap::{span, dummy_sp};\n \n // An option identifying a literal: either a unit-like struct or an\n // expression.\n-pub enum Lit {\n+enum Lit {\n     UnitLikeStructLit(ast::NodeId),    // the node ID of the pattern\n     ExprLit(@ast::expr),\n     ConstLit(ast::def_id),              // the def ID of the constant\n }\n \n // An option identifying a branch (either a literal, a enum variant or a\n // range)\n-pub enum Opt {\n+enum Opt {\n     lit(Lit),\n     var(/* disr val */ uint, @adt::Repr),\n     range(@ast::expr, @ast::expr),\n     vec_len_eq(uint),\n     vec_len_ge(uint, /* slice */uint)\n }\n \n-pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n+fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     match (a, b) {\n         (&lit(a), &lit(b)) => {\n             match (a, b) {\n@@ -258,7 +258,7 @@ pub enum opt_result {\n     lower_bound(Result),\n     range_result(Result, Result),\n }\n-pub fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n+fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n     let _icx = push_ctxt(\"match::trans_opt\");\n     let ccx = bcx.ccx();\n     let bcx = bcx;\n@@ -292,7 +292,7 @@ pub fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n     }\n }\n \n-pub fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n+fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n     -> Opt {\n     let ccx = bcx.ccx();\n     match ccx.tcx.def_map.get_copy(&pat_id) {\n@@ -317,7 +317,7 @@ pub fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n }\n \n #[deriving(Clone)]\n-pub enum TransBindingMode {\n+enum TransBindingMode {\n     TrByValue(/*llbinding:*/ ValueRef),\n     TrByRef,\n }\n@@ -331,24 +331,24 @@ pub enum TransBindingMode {\n  * - `id` is the node id of the binding\n  * - `ty` is the Rust type of the binding */\n  #[deriving(Clone)]\n-pub struct BindingInfo {\n+struct BindingInfo {\n     llmatch: ValueRef,\n     trmode: TransBindingMode,\n     id: ast::NodeId,\n     ty: ty::t,\n }\n \n-pub type BindingsMap = HashMap<ident, BindingInfo>;\n+type BindingsMap = HashMap<ident, BindingInfo>;\n \n #[deriving(Clone)]\n-pub struct ArmData<'self> {\n+struct ArmData<'self> {\n     bodycx: @mut Block,\n     arm: &'self ast::arm,\n     bindings_map: @BindingsMap\n }\n \n #[deriving(Clone)]\n-pub struct Match<'self> {\n+struct Match<'self> {\n     pats: ~[@ast::pat],\n     data: ArmData<'self>\n }\n@@ -364,7 +364,7 @@ impl<'self> Repr for Match<'self> {\n     }\n }\n \n-pub fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n+fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     for br in m.iter() {\n         match br.pats[col].node {\n           ast::pat_ident(_, _, Some(_)) => return true,\n@@ -374,7 +374,7 @@ pub fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     return false;\n }\n \n-pub fn expand_nested_bindings<'r>(bcx: @mut Block,\n+fn expand_nested_bindings<'r>(bcx: @mut Block,\n                                   m: &[Match<'r>],\n                                   col: uint,\n                                   val: ValueRef)\n@@ -409,7 +409,7 @@ pub fn expand_nested_bindings<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::pat) {\n+fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::pat) {\n     if !pat_is_binding_or_wild(bcx.tcx().def_map, p) {\n         bcx.sess().span_bug(\n             p.span,\n@@ -418,9 +418,9 @@ pub fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::pat) {\n     }\n }\n \n-pub type enter_pat<'self> = &'self fn(@ast::pat) -> Option<~[@ast::pat]>;\n+type enter_pat<'self> = &'self fn(@ast::pat) -> Option<~[@ast::pat]>;\n \n-pub fn enter_match<'r>(bcx: @mut Block,\n+fn enter_match<'r>(bcx: @mut Block,\n                        dm: DefMap,\n                        m: &[Match<'r>],\n                        col: uint,\n@@ -470,7 +470,7 @@ pub fn enter_match<'r>(bcx: @mut Block,\n     return result;\n }\n \n-pub fn enter_default<'r>(bcx: @mut Block,\n+fn enter_default<'r>(bcx: @mut Block,\n                          dm: DefMap,\n                          m: &[Match<'r>],\n                          col: uint,\n@@ -485,7 +485,7 @@ pub fn enter_default<'r>(bcx: @mut Block,\n \n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n-          ast::pat_wild | ast::pat_tup(_) | ast::pat_struct(*) => Some(~[]),\n+          ast::pat_wild | ast::pat_tup(_) => Some(~[]),\n           ast::pat_ident(_, _, None) if pat_is_binding(dm, p) => Some(~[]),\n           _ => None\n         }\n@@ -516,7 +516,7 @@ pub fn enter_default<'r>(bcx: @mut Block,\n // <nmatsakis> so all patterns must either be records (resp. tuples) or\n //             wildcards\n \n-pub fn enter_opt<'r>(bcx: @mut Block,\n+fn enter_opt<'r>(bcx: @mut Block,\n                      m: &[Match<'r>],\n                      opt: &Opt,\n                      col: uint,\n@@ -628,7 +628,7 @@ pub fn enter_opt<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_rec_or_struct<'r>(bcx: @mut Block,\n+fn enter_rec_or_struct<'r>(bcx: @mut Block,\n                                dm: DefMap,\n                                m: &[Match<'r>],\n                                col: uint,\n@@ -663,7 +663,7 @@ pub fn enter_rec_or_struct<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_tup<'r>(bcx: @mut Block,\n+fn enter_tup<'r>(bcx: @mut Block,\n                      dm: DefMap,\n                      m: &[Match<'r>],\n                      col: uint,\n@@ -689,7 +689,7 @@ pub fn enter_tup<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_tuple_struct<'r>(bcx: @mut Block,\n+fn enter_tuple_struct<'r>(bcx: @mut Block,\n                               dm: DefMap,\n                               m: &[Match<'r>],\n                               col: uint,\n@@ -715,7 +715,7 @@ pub fn enter_tuple_struct<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_box<'r>(bcx: @mut Block,\n+fn enter_box<'r>(bcx: @mut Block,\n                      dm: DefMap,\n                      m: &[Match<'r>],\n                      col: uint,\n@@ -742,7 +742,7 @@ pub fn enter_box<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_uniq<'r>(bcx: @mut Block,\n+fn enter_uniq<'r>(bcx: @mut Block,\n                       dm: DefMap,\n                       m: &[Match<'r>],\n                       col: uint,\n@@ -769,7 +769,7 @@ pub fn enter_uniq<'r>(bcx: @mut Block,\n     }\n }\n \n-pub fn enter_region<'r>(bcx: @mut Block,\n+fn enter_region<'r>(bcx: @mut Block,\n                         dm: DefMap,\n                         m: &[Match<'r>],\n                         col: uint,\n@@ -799,7 +799,7 @@ pub fn enter_region<'r>(bcx: @mut Block,\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-pub fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n+fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n     fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n@@ -865,12 +865,12 @@ pub fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n     return found;\n }\n \n-pub struct ExtractedBlock {\n+struct ExtractedBlock {\n     vals: ~[ValueRef],\n     bcx: @mut Block\n }\n \n-pub fn extract_variant_args(bcx: @mut Block,\n+fn extract_variant_args(bcx: @mut Block,\n                             repr: &adt::Repr,\n                             disr_val: uint,\n                             val: ValueRef)\n@@ -893,7 +893,7 @@ fn match_datum(bcx: @mut Block, val: ValueRef, pat_id: ast::NodeId) -> Datum {\n }\n \n \n-pub fn extract_vec_elems(bcx: @mut Block,\n+fn extract_vec_elems(bcx: @mut Block,\n                          pat_span: span,\n                          pat_id: ast::NodeId,\n                          elem_count: uint,\n@@ -947,24 +947,37 @@ pub fn extract_vec_elems(bcx: @mut Block,\n     ExtractedBlock { vals: elems, bcx: bcx }\n }\n \n-// NB: This function does not collect fields from struct-like enum variants.\n-pub fn collect_record_or_struct_fields(bcx: @mut Block,\n+/// Checks every pattern in `m` at `col` column.\n+/// If there are a struct pattern among them function\n+/// returns list of all fields that are matched in these patterns.\n+/// Function returns None if there is no struct pattern.\n+/// Function doesn't collect fields from struct-like enum variants.\n+/// Function can return empty list if there is only wildcard struct pattern.\n+fn collect_record_or_struct_fields(bcx: @mut Block,\n                                        m: &[Match],\n                                        col: uint)\n-                                    -> ~[ast::ident] {\n+                                    -> Option<~[ast::ident]> {\n     let mut fields: ~[ast::ident] = ~[];\n+    let mut found = false;\n     for br in m.iter() {\n         match br.pats[col].node {\n           ast::pat_struct(_, ref fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n-              ty::ty_struct(*) => extend(&mut fields, *fs),\n+              ty::ty_struct(*) => {\n+                   extend(&mut fields, *fs);\n+                   found = true;\n+              }\n               _ => ()\n             }\n           }\n           _ => ()\n         }\n     }\n-    return fields;\n+    if found {\n+        return Some(fields);\n+    } else {\n+        return None;\n+    }\n \n     fn extend(idents: &mut ~[ast::ident], field_pats: &[ast::field_pat]) {\n         for field_pat in field_pats.iter() {\n@@ -976,7 +989,7 @@ pub fn collect_record_or_struct_fields(bcx: @mut Block,\n     }\n }\n \n-pub fn pats_require_rooting(bcx: @mut Block,\n+fn pats_require_rooting(bcx: @mut Block,\n                             m: &[Match],\n                             col: uint)\n                          -> bool {\n@@ -987,7 +1000,7 @@ pub fn pats_require_rooting(bcx: @mut Block,\n     }\n }\n \n-pub fn root_pats_as_necessary(mut bcx: @mut Block,\n+fn root_pats_as_necessary(mut bcx: @mut Block,\n                               m: &[Match],\n                               col: uint,\n                               val: ValueRef)\n@@ -1018,23 +1031,23 @@ macro_rules! any_pat (\n     )\n )\n \n-pub fn any_box_pat(m: &[Match], col: uint) -> bool {\n+fn any_box_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_box(_))\n }\n \n-pub fn any_uniq_pat(m: &[Match], col: uint) -> bool {\n+fn any_uniq_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_uniq(_))\n }\n \n-pub fn any_region_pat(m: &[Match], col: uint) -> bool {\n+fn any_region_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_region(_))\n }\n \n-pub fn any_tup_pat(m: &[Match], col: uint) -> bool {\n+fn any_tup_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, ast::pat_tup(_))\n }\n \n-pub fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n+fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n     do m.iter().any |br| {\n         let pat = br.pats[col];\n         match pat.node {\n@@ -1050,9 +1063,9 @@ pub fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n     }\n }\n \n-pub type mk_fail = @fn() -> BasicBlockRef;\n+type mk_fail = @fn() -> BasicBlockRef;\n \n-pub fn pick_col(m: &[Match]) -> uint {\n+fn pick_col(m: &[Match]) -> uint {\n     fn score(p: &ast::pat) -> uint {\n         match p.node {\n           ast::pat_lit(_) | ast::pat_enum(_, _) | ast::pat_range(_, _) => 1u,\n@@ -1088,7 +1101,7 @@ pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n // Compiles a comparison between two things.\n //\n // NB: This must produce an i1, not a Rust bool (i8).\n-pub fn compare_values(cx: @mut Block,\n+fn compare_values(cx: @mut Block,\n                       lhs: ValueRef,\n                       rhs: ValueRef,\n                       rhs_t: ty::t)\n@@ -1204,7 +1217,7 @@ fn insert_lllocals(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn compile_guard(bcx: @mut Block,\n+fn compile_guard(bcx: @mut Block,\n                      guard_expr: @ast::expr,\n                      data: &ArmData,\n                      m: &[Match],\n@@ -1261,7 +1274,7 @@ pub fn compile_guard(bcx: @mut Block,\n     }\n }\n \n-pub fn compile_submatch(bcx: @mut Block,\n+fn compile_submatch(bcx: @mut Block,\n                         m: &[Match],\n                         vals: &[ValueRef],\n                         chk: Option<mk_fail>) {\n@@ -1336,22 +1349,24 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n     // required to root any values.\n     assert!(any_box_pat(m, col) || !pats_require_rooting(bcx, m, col));\n \n-    let rec_fields = collect_record_or_struct_fields(bcx, m, col);\n-    if rec_fields.len() > 0 {\n-        let pat_ty = node_id_type(bcx, pat_id);\n-        let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n-        do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n-            let rec_vals = rec_fields.map(|field_name| {\n-                let ix = ty::field_idx_strict(tcx, *field_name, field_tys);\n-                adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n-            });\n-            compile_submatch(\n-                bcx,\n-                enter_rec_or_struct(bcx, dm, m, col, rec_fields, val),\n-                vec::append(rec_vals, vals_left),\n-                chk);\n+    match collect_record_or_struct_fields(bcx, m, col) {\n+        Some(ref rec_fields) => {\n+            let pat_ty = node_id_type(bcx, pat_id);\n+            let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n+            do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n+                let rec_vals = rec_fields.map(|field_name| {\n+                        let ix = ty::field_idx_strict(tcx, *field_name, field_tys);\n+                        adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n+                        });\n+                compile_submatch(\n+                        bcx,\n+                        enter_rec_or_struct(bcx, dm, m, col, *rec_fields, val),\n+                        vec::append(rec_vals, vals_left),\n+                        chk);\n+            }\n+            return;\n         }\n-        return;\n+        None => {}\n     }\n \n     if any_tup_pat(m, col) {\n@@ -1670,7 +1685,7 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::pat) -> BindingsMap {\n     return bindings_map;\n }\n \n-pub fn trans_match_inner(scope_cx: @mut Block,\n+fn trans_match_inner(scope_cx: @mut Block,\n                          discr_expr: @ast::expr,\n                          arms: &[ast::arm],\n                          dest: Dest) -> @mut Block {\n@@ -1752,7 +1767,7 @@ pub fn trans_match_inner(scope_cx: @mut Block,\n     }\n }\n \n-pub enum IrrefutablePatternBindingMode {\n+enum IrrefutablePatternBindingMode {\n     // Stores the association between node ID and LLVM value in `lllocals`.\n     BindLocal,\n     // Stores the association between node ID and LLVM value in `llargs`."}, {"sha": "8e55ad90c70441bd6091fc36d2b84d50f0cbfe2d", "filename": "src/test/run-pass/issue-5530.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a931e04b757a795e3867ea98c81cee731bd54ac1/src%2Ftest%2Frun-pass%2Fissue-5530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a931e04b757a795e3867ea98c81cee731bd54ac1/src%2Ftest%2Frun-pass%2Fissue-5530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5530.rs?ref=a931e04b757a795e3867ea98c81cee731bd54ac1", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n-\n enum Enum {\n     Foo { foo: uint },\n     Bar { bar: uint }"}, {"sha": "365729ec86054d5f372e80deb7bea4aa655210c9", "filename": "src/test/run-pass/match-enum-struct-0.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a931e04b757a795e3867ea98c81cee731bd54ac1/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a931e04b757a795e3867ea98c81cee731bd54ac1/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-0.rs?ref=a931e04b757a795e3867ea98c81cee731bd54ac1", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// regression test for issue #5625\n+\n+enum E {\n+    Foo{f : int},\n+    Bar\n+}\n+\n+pub fn main() {\n+    let e = Bar;\n+    match e {\n+        Foo{f: _f} => fail!(),\n+        _ => (),\n+    }\n+}"}, {"sha": "15d24c41a3d08953f7c415bcc50aa976bbec9344", "filename": "src/test/run-pass/match-enum-struct-1.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a931e04b757a795e3867ea98c81cee731bd54ac1/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a931e04b757a795e3867ea98c81cee731bd54ac1/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-1.rs?ref=a931e04b757a795e3867ea98c81cee731bd54ac1", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum E {\n+    Foo{f : int},\n+    Bar\n+}\n+\n+pub fn main() {\n+    let e = Foo{f: 1};\n+    match e {\n+        Foo{_} => (),\n+        _ => fail!(),\n+    }\n+    match e {\n+        Foo{f: _f} => (),\n+        _ => fail!(),\n+    }\n+}"}, {"sha": "67e844c519ee8c8740f02ea40e14bbfb2cc357c0", "filename": "src/test/run-pass/match-struct-0.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a931e04b757a795e3867ea98c81cee731bd54ac1/src%2Ftest%2Frun-pass%2Fmatch-struct-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a931e04b757a795e3867ea98c81cee731bd54ac1/src%2Ftest%2Frun-pass%2Fmatch-struct-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-struct-0.rs?ref=a931e04b757a795e3867ea98c81cee731bd54ac1", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo{\n+    f : int,\n+}\n+\n+pub fn main() {\n+    let f = Foo{f: 1};\n+    match f {\n+        Foo{f: 0} => fail!(),\n+        Foo{_} => (),\n+    }\n+    match f {\n+        Foo{f: 0} => fail!(),\n+        Foo{f: _f} => (),\n+    }\n+    match f {\n+        Foo{f: 0} => fail!(),\n+        _ => (),\n+    }\n+}"}]}