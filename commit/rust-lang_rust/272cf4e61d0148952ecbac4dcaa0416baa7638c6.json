{"sha": "272cf4e61d0148952ecbac4dcaa0416baa7638c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MmNmNGU2MWQwMTQ4OTUyZWNiYWM0ZGNhYTA0MTZiYWE3NjM4YzY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-19T05:25:17Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-22T07:45:11Z"}, "message": "Refactor `no_implicit_prelude: Cell<bool>` -> `no_implicit_prelude: bool`.", "tree": {"sha": "7d78770937f12569ef340c98dfd835415ef2cc6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d78770937f12569ef340c98dfd835415ef2cc6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/272cf4e61d0148952ecbac4dcaa0416baa7638c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/272cf4e61d0148952ecbac4dcaa0416baa7638c6", "html_url": "https://github.com/rust-lang/rust/commit/272cf4e61d0148952ecbac4dcaa0416baa7638c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/272cf4e61d0148952ecbac4dcaa0416baa7638c6/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85bfd82be690d00ffafce74b0313fefb976c2e05", "url": "https://api.github.com/repos/rust-lang/rust/commits/85bfd82be690d00ffafce74b0313fefb976c2e05", "html_url": "https://github.com/rust-lang/rust/commit/85bfd82be690d00ffafce74b0313fefb976c2e05"}], "stats": {"total": 81, "additions": 41, "deletions": 40}, "files": [{"sha": "18ce35237afcb8d3dcbf4c5fa04e6a1c2256174e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/272cf4e61d0148952ecbac4dcaa0416baa7638c6/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272cf4e61d0148952ecbac4dcaa0416baa7638c6/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=272cf4e61d0148952ecbac4dcaa0416baa7638c6", "patch": "@@ -643,7 +643,8 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n         macro_import::MacroLoader::new(sess, &cstore, crate_name, krate.config.clone());\n \n     let resolver_arenas = Resolver::arenas();\n-    let mut resolver = Resolver::new(sess, make_glob_map, &mut macro_loader, &resolver_arenas);\n+    let mut resolver =\n+        Resolver::new(sess, &krate, make_glob_map, &mut macro_loader, &resolver_arenas);\n     syntax_ext::register_builtins(&mut resolver, sess.features.borrow().quote);\n \n     krate = time(time_passes, \"expansion\", || {"}, {"sha": "3075e394869a5a35322555563ea5b7171314c12b", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/272cf4e61d0148952ecbac4dcaa0416baa7638c6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272cf4e61d0148952ecbac4dcaa0416baa7638c6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=272cf4e61d0148952ecbac4dcaa0416baa7638c6", "patch": "@@ -14,7 +14,7 @@\n //! any imports resolved.\n \n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n-use {Module, ModuleKind};\n+use {Module, ModuleS, ModuleKind};\n use Namespace::{self, TypeNS, ValueNS};\n use {NameBinding, NameBindingKind, ToNameBinding};\n use Resolver;\n@@ -55,8 +55,6 @@ impl<'a> ToNameBinding<'a> for (Def, Span, ty::Visibility) {\n impl<'b> Resolver<'b> {\n     /// Constructs the reduced graph for the entire crate.\n     pub fn build_reduced_graph(&mut self, krate: &Crate) {\n-        let no_implicit_prelude = attr::contains_name(&krate.attrs, \"no_implicit_prelude\");\n-        self.graph_root.no_implicit_prelude.set(no_implicit_prelude);\n         visit::walk_crate(&mut BuildReducedGraphVisitor { resolver: self }, krate);\n     }\n \n@@ -195,8 +193,11 @@ impl<'b> Resolver<'b> {\n                         krate: crate_id,\n                         index: CRATE_DEF_INDEX,\n                     };\n-                    let def = Def::Mod(def_id);\n-                    let module = self.new_extern_crate_module(parent, name, def, item.id);\n+                    let module = self.arenas.alloc_module(ModuleS {\n+                        extern_crate_id: Some(item.id),\n+                        populated: Cell::new(false),\n+                        ..ModuleS::new(Some(parent), ModuleKind::Def(Def::Mod(def_id), name))\n+                    });\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n \n                     self.populate_module_if_necessary(module);\n@@ -205,10 +206,12 @@ impl<'b> Resolver<'b> {\n \n             ItemKind::Mod(..) => {\n                 let def = Def::Mod(self.definitions.local_def_id(item.id));\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), Some(item.id));\n-                module.no_implicit_prelude.set({\n-                    parent.no_implicit_prelude.get() ||\n+                let module = self.arenas.alloc_module(ModuleS {\n+                    no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n+                    },\n+                    normal_ancestor_id: Some(item.id),\n+                    ..ModuleS::new(Some(parent), ModuleKind::Def(def, name))\n                 });\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n                 self.module_map.insert(item.id, module);\n@@ -241,8 +244,8 @@ impl<'b> Resolver<'b> {\n             }\n \n             ItemKind::Enum(ref enum_definition, _) => {\n-                let kind = ModuleKind::Def(Def::Enum(self.definitions.local_def_id(item.id)), name);\n-                let module = self.new_module(parent, kind, parent.normal_ancestor_id);\n+                let def = Def::Enum(self.definitions.local_def_id(item.id));\n+                let module = self.new_module(parent, ModuleKind::Def(def, name), true);\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n \n                 for variant in &(*enum_definition).variants {\n@@ -293,8 +296,8 @@ impl<'b> Resolver<'b> {\n                 let def_id = self.definitions.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n-                let kind = ModuleKind::Def(Def::Trait(def_id), name);\n-                let module = self.new_module(parent, kind, parent.normal_ancestor_id);\n+                let module =\n+                    self.new_module(parent, ModuleKind::Def(Def::Trait(def_id), name), true);\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n                 self.current_module = module;\n             }\n@@ -348,8 +351,7 @@ impl<'b> Resolver<'b> {\n                     {}\",\n                    block_id);\n \n-            let new_module =\n-                self.new_module(parent, ModuleKind::Block(block_id), parent.normal_ancestor_id);\n+            let new_module = self.new_module(parent, ModuleKind::Block(block_id), true);\n             self.module_map.insert(block_id, new_module);\n             self.current_module = new_module; // Descend into the block.\n         }\n@@ -377,7 +379,7 @@ impl<'b> Resolver<'b> {\n             Def::Mod(_) | Def::Enum(..) => {\n                 debug!(\"(building reduced graph for external crate) building module {} {:?}\",\n                        name, vis);\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), None);\n+                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n                 let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::Variant(variant_id) => {\n@@ -420,7 +422,7 @@ impl<'b> Resolver<'b> {\n                     self.trait_item_map.insert((trait_item_name, def_id), false);\n                 }\n \n-                let module = self.new_module(parent, ModuleKind::Def(def, name), None);\n+                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n                 let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {"}, {"sha": "7a5f255aa9f33bb0b87cd4e174799f5056aed141", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/272cf4e61d0148952ecbac4dcaa0416baa7638c6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272cf4e61d0148952ecbac4dcaa0416baa7638c6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=272cf4e61d0148952ecbac4dcaa0416baa7638c6", "patch": "@@ -60,6 +60,7 @@ use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n+use syntax::attr;\n use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n@@ -771,7 +772,7 @@ pub struct ModuleS<'a> {\n \n     resolutions: RefCell<FnvHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n \n-    no_implicit_prelude: Cell<bool>,\n+    no_implicit_prelude: bool,\n \n     glob_importers: RefCell<Vec<&'a ImportDirective<'a>>>,\n     globs: RefCell<Vec<&'a ImportDirective<'a>>>,\n@@ -788,19 +789,18 @@ pub struct ModuleS<'a> {\n pub type Module<'a> = &'a ModuleS<'a>;\n \n impl<'a> ModuleS<'a> {\n-    fn new(parent: Option<Module<'a>>, kind: ModuleKind, normal_ancestor_id: Option<NodeId>)\n-           -> Self {\n+    fn new(parent: Option<Module<'a>>, kind: ModuleKind) -> Self {\n         ModuleS {\n             parent: parent,\n             kind: kind,\n-            normal_ancestor_id: normal_ancestor_id,\n+            normal_ancestor_id: None,\n             extern_crate_id: None,\n             resolutions: RefCell::new(FnvHashMap()),\n-            no_implicit_prelude: Cell::new(false),\n+            no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n-            populated: Cell::new(normal_ancestor_id.is_some()),\n+            populated: Cell::new(true),\n         }\n     }\n \n@@ -1170,14 +1170,17 @@ impl Named for hir::PathSegment {\n \n impl<'a> Resolver<'a> {\n     pub fn new(session: &'a Session,\n+               krate: &Crate,\n                make_glob_map: MakeGlobMap,\n                macro_loader: &'a mut MacroLoader,\n                arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n-        let graph_root_kind =\n-            ModuleKind::Def(Def::Mod(DefId::local(CRATE_DEF_INDEX)), keywords::Invalid.name());\n-        let graph_root =\n-            arenas.alloc_module(ModuleS::new(None, graph_root_kind, Some(CRATE_NODE_ID)));\n+        let root_def = Def::Mod(DefId::local(CRATE_DEF_INDEX));\n+        let graph_root = arenas.alloc_module(ModuleS {\n+            normal_ancestor_id: Some(CRATE_NODE_ID),\n+            no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n+            ..ModuleS::new(None, ModuleKind::Def(root_def, keywords::Invalid.name()))\n+        });\n         let mut module_map = NodeMap();\n         module_map.insert(CRATE_NODE_ID, graph_root);\n \n@@ -1259,17 +1262,12 @@ impl<'a> Resolver<'a> {\n         self.report_errors();\n     }\n \n-    fn new_module(&self, parent: Module<'a>, kind: ModuleKind, normal_ancestor_id: Option<NodeId>)\n-                  -> Module<'a> {\n-        self.arenas.alloc_module(ModuleS::new(Some(parent), kind, normal_ancestor_id))\n-    }\n-\n-    fn new_extern_crate_module(&self, parent: Module<'a>, name: Name, def: Def, node_id: NodeId)\n-                               -> Module<'a> {\n-        let mut module = ModuleS::new(Some(parent), ModuleKind::Def(def, name), Some(node_id));\n-        module.extern_crate_id = Some(node_id);\n-        module.populated.set(false);\n-        self.arenas.modules.alloc(module)\n+    fn new_module(&self, parent: Module<'a>, kind: ModuleKind, local: bool) -> Module<'a> {\n+        self.arenas.alloc_module(ModuleS {\n+            normal_ancestor_id: if local { self.current_module.normal_ancestor_id } else { None },\n+            populated: Cell::new(local),\n+            ..ModuleS::new(Some(parent), kind)\n+        })\n     }\n \n     fn get_ribs<'b>(&'b mut self, ns: Namespace) -> &'b mut Vec<Rib<'a>> {\n@@ -1509,7 +1507,7 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n-                } else if !module.no_implicit_prelude.get() {\n+                } else if !module.no_implicit_prelude {\n                     return self.prelude.and_then(|prelude| {\n                         self.resolve_name_in_module(prelude, name, ns, false, None).success()\n                     }).map(LexicalScopeBinding::Item)\n@@ -3156,7 +3154,7 @@ impl<'a> Resolver<'a> {\n             if let ModuleKind::Block(..) = search_module.kind {\n                 search_module = search_module.parent.unwrap();\n             } else {\n-                if !search_module.no_implicit_prelude.get() {\n+                if !search_module.no_implicit_prelude {\n                     self.prelude.map(|prelude| search_in_module(self, prelude));\n                 }\n                 break;"}]}