{"sha": "f16993d4acaf90285f6c86268a0ec2e7167c2a58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNjk5M2Q0YWNhZjkwMjg1ZjZjODYyNjhhMGVjMmU3MTY3YzJhNTg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-03T08:44:57Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-10T21:12:08Z"}, "message": "resolve/expand: `resolve_macro_invocation` no longer returns determinate errors\n\nIt either returns the indeterminacy error, or valid (but perhaps dummy) `SyntaxExtension`.\n\nWith this change enum `Determinacy` is no longer used in libsyntax and can be moved to resolve.\n\nThe regressions in diagnosics are fixed in the next commits.", "tree": {"sha": "316cac76a7b4856be9d4958c5e989aabc3767b84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/316cac76a7b4856be9d4958c5e989aabc3767b84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f16993d4acaf90285f6c86268a0ec2e7167c2a58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f16993d4acaf90285f6c86268a0ec2e7167c2a58", "html_url": "https://github.com/rust-lang/rust/commit/f16993d4acaf90285f6c86268a0ec2e7167c2a58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f16993d4acaf90285f6c86268a0ec2e7167c2a58/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd0fd630e8170f8770485cb8248ff3d823521523", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd0fd630e8170f8770485cb8248ff3d823521523", "html_url": "https://github.com/rust-lang/rust/commit/cd0fd630e8170f8770485cb8248ff3d823521523"}], "stats": {"total": 231, "additions": 108, "deletions": 123}, "files": [{"sha": "f74d07a3c5ee6f4ea4c3acf99889791b4197c567", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=f16993d4acaf90285f6c86268a0ec2e7167c2a58", "patch": "@@ -9,7 +9,7 @@ use crate::resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleIm\n use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n use crate::{ModuleOrUniformRoot, PerNS, Resolver, ResolverArenas, ExternPreludeEntry};\n use crate::Namespace::{self, TypeNS, ValueNS, MacroNS};\n-use crate::{resolve_error, resolve_struct_error, ResolutionError};\n+use crate::{resolve_error, resolve_struct_error, ResolutionError, Determinacy};\n \n use rustc::bug;\n use rustc::hir::def::{self, *};\n@@ -30,7 +30,6 @@ use syntax::attr;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind, Variant};\n use syntax::ext::base::SyntaxExtension;\n-use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::is_builtin_attr;\n@@ -231,9 +230,9 @@ impl<'a> Resolver<'a> {\n                     source: source.ident,\n                     target: ident,\n                     source_bindings: PerNS {\n-                        type_ns: Cell::new(Err(Undetermined)),\n-                        value_ns: Cell::new(Err(Undetermined)),\n-                        macro_ns: Cell::new(Err(Undetermined)),\n+                        type_ns: Cell::new(Err(Determinacy::Undetermined)),\n+                        value_ns: Cell::new(Err(Determinacy::Undetermined)),\n+                        macro_ns: Cell::new(Err(Determinacy::Undetermined)),\n                     },\n                     target_bindings: PerNS {\n                         type_ns: Cell::new(None),"}, {"sha": "795ff3faffa333013fb6fbca8229290720305ad3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f16993d4acaf90285f6c86268a0ec2e7167c2a58", "patch": "@@ -15,6 +15,7 @@\n \n pub use rustc::hir::def::{Namespace, PerNS};\n \n+use Determinacy::*;\n use GenericParameters::*;\n use RibKind::*;\n use smallvec::smallvec;\n@@ -41,7 +42,6 @@ use syntax::source_map::SourceMap;\n use syntax::ext::hygiene::{Mark, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n-use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::base::MacroKind;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -93,6 +93,18 @@ enum Weak {\n     No,\n }\n \n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum Determinacy {\n+    Determined,\n+    Undetermined,\n+}\n+\n+impl Determinacy {\n+    fn determined(determined: bool) -> Determinacy {\n+        if determined { Determinacy::Determined } else { Determinacy::Undetermined }\n+    }\n+}\n+\n enum ScopeSet {\n     Import(Namespace),\n     AbsolutePath(Namespace),"}, {"sha": "905b3347a5470a25a9a7738cc4ba2ed55e62c36f", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 27, "deletions": 39, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=f16993d4acaf90285f6c86268a0ec2e7167c2a58", "patch": "@@ -1,4 +1,4 @@\n-use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n+use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc, Determinacy};\n use crate::{CrateLint, Resolver, ResolutionError, ScopeSet, Weak};\n use crate::{Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n use crate::{is_known_tool, resolve_error};\n@@ -14,7 +14,7 @@ use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, Ident, ItemKind};\n use syntax::attr::{self, StabilityLevel};\n use syntax::errors::DiagnosticBuilder;\n-use syntax::ext::base::{self, Determinacy};\n+use syntax::ext::base::{self, Indeterminate};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, Mark};\n@@ -216,7 +216,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n-                                -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n+                                -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n         let (path, kind, derives_in_scope, after_derive) = match invoc.kind {\n             InvocationKind::Attr { attr: None, .. } =>\n                 return Ok(None),\n@@ -229,12 +229,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         };\n \n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n-        let (res, ext) = match self.resolve_macro_to_res(path, kind, &parent_scope, true, force) {\n-            Ok((res, ext)) => (res, ext),\n-            // Return dummy syntax extensions for unresolved macros for better recovery.\n-            Err(Determinacy::Determined) => (Res::Err, self.dummy_ext(kind)),\n-            Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n-        };\n+        let (res, ext) = self.resolve_macro_to_res(path, kind, &parent_scope, true, force)?;\n \n         let span = invoc.span();\n         let descr = fast_print_path(path);\n@@ -287,7 +282,7 @@ impl<'a> Resolver<'a> {\n         parent_scope: &ParentScope<'a>,\n         trace: bool,\n         force: bool,\n-    ) -> Result<(Res, Lrc<SyntaxExtension>), Determinacy> {\n+    ) -> Result<(Res, Lrc<SyntaxExtension>), Indeterminate> {\n         let res = self.resolve_macro_to_res_inner(path, kind, parent_scope, trace, force);\n \n         // Report errors and enforce feature gates for the resolved macro.\n@@ -313,7 +308,14 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let res = res?;\n+        let res = match res {\n+            Err(Determinacy::Undetermined) => return Err(Indeterminate),\n+            Ok(Res::Err) | Err(Determinacy::Determined) => {\n+                // Return dummy syntax extensions for unresolved macros for better recovery.\n+                return Ok((Res::Err, self.dummy_ext(kind)));\n+            }\n+            Ok(res) => res,\n+        };\n \n         match res {\n             Res::Def(DefKind::Macro(_), def_id) => {\n@@ -328,35 +330,23 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             Res::NonMacroAttr(attr_kind) => {\n-                if kind == MacroKind::Attr {\n-                    if attr_kind == NonMacroAttrKind::Custom {\n-                        assert!(path.segments.len() == 1);\n-                        if !features.custom_attribute {\n-                            let msg = format!(\"The attribute `{}` is currently unknown to the \\\n-                                               compiler and may have meaning added to it in the \\\n-                                               future\", path);\n-                            self.report_unknown_attribute(\n-                                path.span,\n-                                &path.segments[0].ident.as_str(),\n-                                &msg,\n-                                sym::custom_attribute,\n-                            );\n-                        }\n+                if attr_kind == NonMacroAttrKind::Custom {\n+                    assert!(path.segments.len() == 1);\n+                    if !features.custom_attribute {\n+                        let msg = format!(\"The attribute `{}` is currently unknown to the \\\n+                                            compiler and may have meaning added to it in the \\\n+                                            future\", path);\n+                        self.report_unknown_attribute(\n+                            path.span,\n+                            &path.segments[0].ident.as_str(),\n+                            &msg,\n+                            sym::custom_attribute,\n+                        );\n                     }\n-                } else {\n-                    // Not only attributes, but anything in macro namespace can result in\n-                    // `Res::NonMacroAttr` definition (e.g., `inline!()`), so we must report\n-                    // an error for those cases.\n-                    let msg = format!(\"expected a macro, found {}\", res.descr());\n-                    self.session.span_err(path.span, &msg);\n-                    return Err(Determinacy::Determined);\n                 }\n             }\n-            Res::Err => {\n-                return Err(Determinacy::Determined);\n-            }\n             _ => panic!(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\"),\n-        }\n+        };\n \n         Ok((res, self.get_macro(res)))\n     }\n@@ -608,9 +598,7 @@ impl<'a> Resolver<'a> {\n                                 result = Ok((binding, Flags::empty()));\n                                 break;\n                             }\n-                            Err(Determinacy::Determined) => {}\n-                            Err(Determinacy::Undetermined) =>\n-                                result = Err(Determinacy::Undetermined),\n+                            Err(Indeterminate) => result = Err(Determinacy::Undetermined),\n                         }\n                     }\n                     result"}, {"sha": "5edfe923e68a2ad2d74d1d0634863cea1ae2357e", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=f16993d4acaf90285f6c86268a0ec2e7167c2a58", "patch": "@@ -2,6 +2,7 @@ use ImportDirectiveSubclass::*;\n \n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, Weak};\n+use crate::Determinacy::{self, *};\n use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use crate::{Resolver, Segment};\n@@ -27,7 +28,6 @@ use rustc::util::nodemap::FxHashSet;\n use rustc::{bug, span_bug};\n \n use syntax::ast::{self, Ident, Name, NodeId, CRATE_NODE_ID};\n-use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::kw;\n use syntax::util::lev_distance::find_best_match_for_name;"}, {"sha": "cb4edee30cdbff73d221a5b5a4c7f9410d1c1226", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f16993d4acaf90285f6c86268a0ec2e7167c2a58", "patch": "@@ -676,6 +676,9 @@ impl SyntaxExtension {\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n+/// Error type that denotes indeterminacy.\n+pub struct Indeterminate;\n+\n pub trait Resolver {\n     fn next_node_id(&mut self) -> ast::NodeId;\n \n@@ -689,23 +692,11 @@ pub trait Resolver {\n     fn resolve_imports(&mut self);\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n-                                -> Result<Option<Lrc<SyntaxExtension>>, Determinacy>;\n+                                -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate>;\n \n     fn check_unused_macros(&self);\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum Determinacy {\n-    Determined,\n-    Undetermined,\n-}\n-\n-impl Determinacy {\n-    pub fn determined(determined: bool) -> Determinacy {\n-        if determined { Determinacy::Determined } else { Determinacy::Undetermined }\n-    }\n-}\n-\n #[derive(Clone)]\n pub struct ModuleData {\n     pub mod_path: Vec<ast::Ident>,"}, {"sha": "2f7fb79a7f53991cc2c6d18eb80edfb8cb1c8fb1", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 53, "deletions": 58, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f16993d4acaf90285f6c86268a0ec2e7167c2a58", "patch": "@@ -313,9 +313,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             let scope =\n                 if self.monotonic { invoc.expansion_data.mark } else { orig_expansion_data.mark };\n             let ext = match self.cx.resolver.resolve_macro_invocation(&invoc, scope, force) {\n-                Ok(ext) => Some(ext),\n-                Err(Determinacy::Determined) => None,\n-                Err(Determinacy::Undetermined) => {\n+                Ok(ext) => ext,\n+                Err(Indeterminate) => {\n                     undetermined_invocations.push(invoc);\n                     continue\n                 }\n@@ -328,65 +327,61 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             self.cx.current_expansion.mark = scope;\n             // FIXME(jseyfried): Refactor out the following logic\n             let (expanded_fragment, new_invocations) = if let Some(ext) = ext {\n-                if let Some(ext) = ext {\n-                    let (invoc_fragment_kind, invoc_span) = (invoc.fragment_kind, invoc.span());\n-                    let fragment = self.expand_invoc(invoc, &*ext).unwrap_or_else(|| {\n-                        invoc_fragment_kind.dummy(invoc_span).unwrap()\n-                    });\n-                    self.collect_invocations(fragment, &[])\n-                } else if let InvocationKind::Attr { attr: None, traits, item, .. } = invoc.kind {\n-                    if !item.derive_allowed() {\n-                        let attr = attr::find_by_name(item.attrs(), sym::derive)\n-                            .expect(\"`derive` attribute should exist\");\n-                        let span = attr.span;\n-                        let mut err = self.cx.mut_span_err(span,\n-                                                           \"`derive` may only be applied to \\\n-                                                            structs, enums and unions\");\n-                        if let ast::AttrStyle::Inner = attr.style {\n-                            let trait_list = traits.iter()\n-                                .map(|t| t.to_string()).collect::<Vec<_>>();\n-                            let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n-                            err.span_suggestion(\n-                                span, \"try an outer attribute\", suggestion,\n-                                // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n-                                Applicability::MaybeIncorrect\n-                            );\n-                        }\n-                        err.emit();\n+                let (invoc_fragment_kind, invoc_span) = (invoc.fragment_kind, invoc.span());\n+                let fragment = self.expand_invoc(invoc, &*ext).unwrap_or_else(|| {\n+                    invoc_fragment_kind.dummy(invoc_span).unwrap()\n+                });\n+                self.collect_invocations(fragment, &[])\n+            } else if let InvocationKind::Attr { attr: None, traits, item, .. } = invoc.kind {\n+                if !item.derive_allowed() {\n+                    let attr = attr::find_by_name(item.attrs(), sym::derive)\n+                        .expect(\"`derive` attribute should exist\");\n+                    let span = attr.span;\n+                    let mut err = self.cx.mut_span_err(span,\n+                                                        \"`derive` may only be applied to \\\n+                                                        structs, enums and unions\");\n+                    if let ast::AttrStyle::Inner = attr.style {\n+                        let trait_list = traits.iter()\n+                            .map(|t| t.to_string()).collect::<Vec<_>>();\n+                        let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n+                        err.span_suggestion(\n+                            span, \"try an outer attribute\", suggestion,\n+                            // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n+                            Applicability::MaybeIncorrect\n+                        );\n                     }\n+                    err.emit();\n+                }\n \n-                    let mut item = self.fully_configure(item);\n-                    item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n-                    let mut item_with_markers = item.clone();\n-                    add_derived_markers(&mut self.cx, item.span(), &traits, &mut item_with_markers);\n-                    let derives = derives.entry(invoc.expansion_data.mark).or_default();\n-\n-                    derives.reserve(traits.len());\n-                    invocations.reserve(traits.len());\n-                    for path in traits {\n-                        let mark = Mark::fresh(self.cx.current_expansion.mark);\n-                        derives.push(mark);\n-                        invocations.push(Invocation {\n-                            kind: InvocationKind::Derive {\n-                                path,\n-                                item: item.clone(),\n-                                item_with_markers: item_with_markers.clone(),\n-                            },\n-                            fragment_kind: invoc.fragment_kind,\n-                            expansion_data: ExpansionData {\n-                                mark,\n-                                ..invoc.expansion_data.clone()\n-                            },\n-                        });\n-                    }\n-                    let fragment = invoc.fragment_kind\n-                        .expect_from_annotatables(::std::iter::once(item_with_markers));\n-                    self.collect_invocations(fragment, derives)\n-                } else {\n-                    unreachable!()\n+                let mut item = self.fully_configure(item);\n+                item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n+                let mut item_with_markers = item.clone();\n+                add_derived_markers(&mut self.cx, item.span(), &traits, &mut item_with_markers);\n+                let derives = derives.entry(invoc.expansion_data.mark).or_default();\n+\n+                derives.reserve(traits.len());\n+                invocations.reserve(traits.len());\n+                for path in traits {\n+                    let mark = Mark::fresh(self.cx.current_expansion.mark);\n+                    derives.push(mark);\n+                    invocations.push(Invocation {\n+                        kind: InvocationKind::Derive {\n+                            path,\n+                            item: item.clone(),\n+                            item_with_markers: item_with_markers.clone(),\n+                        },\n+                        fragment_kind: invoc.fragment_kind,\n+                        expansion_data: ExpansionData {\n+                            mark,\n+                            ..invoc.expansion_data.clone()\n+                        },\n+                    });\n                 }\n+                let fragment = invoc.fragment_kind\n+                    .expect_from_annotatables(::std::iter::once(item_with_markers));\n+                self.collect_invocations(fragment, derives)\n             } else {\n-                self.collect_invocations(invoc.fragment_kind.dummy(invoc.span()).unwrap(), &[])\n+                unreachable!()\n             };\n \n             if expanded_fragments.len() < depth {"}, {"sha": "44f0f2d7ec03c5c7af5ab5c68822e793dcb78c5f", "filename": "src/test/ui/macros/macro-path-prelude-fail-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-4.rs?ref=f16993d4acaf90285f6c86268a0ec2e7167c2a58", "patch": "@@ -1,4 +1,4 @@\n-#[derive(inline)] //~ ERROR expected a macro, found built-in attribute\n+#[derive(inline)] //~ ERROR macro `inline` may not be used for derive attributes\n struct S;\n \n fn main() {}"}, {"sha": "fdd7bf3235c14bfe2e8a4c2edcfce4115316b42d", "filename": "src/test/ui/macros/macro-path-prelude-fail-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-4.stderr?ref=f16993d4acaf90285f6c86268a0ec2e7167c2a58", "patch": "@@ -1,4 +1,4 @@\n-error: expected a macro, found built-in attribute\n+error: macro `inline` may not be used for derive attributes\n   --> $DIR/macro-path-prelude-fail-4.rs:1:10\n    |\n LL | #[derive(inline)]"}, {"sha": "b95791f4e99d8b5bfccc6599c1543f14d364ef0c", "filename": "src/test/ui/tool-attributes/tool-attributes-misplaced-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-2.rs?ref=f16993d4acaf90285f6c86268a0ec2e7167c2a58", "patch": "@@ -1,6 +1,6 @@\n-#[derive(rustfmt::skip)] //~ ERROR expected a macro, found tool attribute\n+#[derive(rustfmt::skip)] //~ ERROR macro `rustfmt::skip` may not be used for derive attributes\n struct S;\n \n fn main() {\n-    rustfmt::skip!(); //~ ERROR expected a macro, found tool attribute\n+    rustfmt::skip!(); //~ ERROR `rustfmt::skip` can only be used in attributes\n }"}, {"sha": "8ef27a07b7f8e5fc8b642804202d95ef95ac3c22", "filename": "src/test/ui/tool-attributes/tool-attributes-misplaced-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f16993d4acaf90285f6c86268a0ec2e7167c2a58/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftool-attributes%2Ftool-attributes-misplaced-2.stderr?ref=f16993d4acaf90285f6c86268a0ec2e7167c2a58", "patch": "@@ -1,10 +1,10 @@\n-error: expected a macro, found tool attribute\n+error: macro `rustfmt::skip` may not be used for derive attributes\n   --> $DIR/tool-attributes-misplaced-2.rs:1:10\n    |\n LL | #[derive(rustfmt::skip)]\n    |          ^^^^^^^^^^^^^\n \n-error: expected a macro, found tool attribute\n+error: `rustfmt::skip` can only be used in attributes\n   --> $DIR/tool-attributes-misplaced-2.rs:5:5\n    |\n LL |     rustfmt::skip!();"}]}