{"sha": "16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2YjVjMmNmZWY4MTFmZWViZTI3OTdiY2I3ZTAxZDJiNmZmMTJkYjE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-10-27T02:17:42Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-28T02:18:10Z"}, "message": "rustc: desugar UFCS as much as possible during HIR lowering.", "tree": {"sha": "e2a17a7e621aff09521fb522bdde1599b1194f18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2a17a7e621aff09521fb522bdde1599b1194f18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "html_url": "https://github.com/rust-lang/rust/commit/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34d1352f0eb7e7511e34b1e7640e854ffaf3f137", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d1352f0eb7e7511e34b1e7640e854ffaf3f137", "html_url": "https://github.com/rust-lang/rust/commit/34d1352f0eb7e7511e34b1e7640e854ffaf3f137"}], "stats": {"total": 1123, "additions": 637, "deletions": 486}, "files": [{"sha": "609d492a93aec5e9930547963e7407ea4f1a5c5e", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n             PatKind::Binding(.., None) |\n-            PatKind::Path(..) |\n+            PatKind::Path(_) |\n             PatKind::Lit(..) |\n             PatKind::Range(..) |\n             PatKind::Wild => {\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             hir::ExprClosure(..) |\n             hir::ExprLit(..) |\n-            hir::ExprPath(..) => {\n+            hir::ExprPath(_) => {\n                 self.straightline(expr, pred, None::<hir::Expr>.iter())\n             }\n         }"}, {"sha": "743eed74d0cea6856babb2bc15c5e4021810f958", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -244,6 +244,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n     }\n+    fn visit_qpath(&mut self, qpath: &'v QPath, id: NodeId, span: Span) {\n+        walk_qpath(self, qpath, id, span)\n+    }\n     fn visit_path(&mut self, path: &'v Path, _id: NodeId) {\n         walk_path(self, path)\n     }\n@@ -481,11 +484,8 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             walk_fn_decl(visitor, &function_declaration.decl);\n             walk_list!(visitor, visit_lifetime_def, &function_declaration.lifetimes);\n         }\n-        TyPath(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n-                visitor.visit_ty(&qself.ty);\n-            }\n-            visitor.visit_path(path, typ.id);\n+        TyPath(ref qpath) => {\n+            visitor.visit_qpath(qpath, typ.id, typ.span);\n         }\n         TyObjectSum(ref ty, ref bounds) => {\n             visitor.visit_ty(ty);\n@@ -508,6 +508,21 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     }\n }\n \n+pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath, id: NodeId, span: Span) {\n+    match *qpath {\n+        QPath::Resolved(ref maybe_qself, ref path) => {\n+            if let Some(ref qself) = *maybe_qself {\n+                visitor.visit_ty(qself);\n+            }\n+            visitor.visit_path(path, id)\n+        }\n+        QPath::TypeRelative(ref qself, ref segment) => {\n+            visitor.visit_ty(qself);\n+            visitor.visit_path_segment(span, segment);\n+        }\n+    }\n+}\n+\n pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n     for segment in &path.segments {\n         visitor.visit_path_segment(path.span, segment);\n@@ -555,18 +570,15 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     visitor.visit_id(pattern.id);\n     match pattern.node {\n-        PatKind::TupleStruct(ref path, ref children, _) => {\n-            visitor.visit_path(path, pattern.id);\n+        PatKind::TupleStruct(ref qpath, ref children, _) => {\n+            visitor.visit_qpath(qpath, pattern.id, pattern.span);\n             walk_list!(visitor, visit_pat, children);\n         }\n-        PatKind::Path(ref opt_qself, ref path) => {\n-            if let Some(ref qself) = *opt_qself {\n-                visitor.visit_ty(&qself.ty);\n-            }\n-            visitor.visit_path(path, pattern.id)\n+        PatKind::Path(ref qpath) => {\n+            visitor.visit_qpath(qpath, pattern.id, pattern.span);\n         }\n-        PatKind::Struct(ref path, ref fields, _) => {\n-            visitor.visit_path(path, pattern.id);\n+        PatKind::Struct(ref qpath, ref fields, _) => {\n+            visitor.visit_qpath(qpath, pattern.id, pattern.span);\n             for field in fields {\n                 visitor.visit_name(field.span, field.node.name);\n                 visitor.visit_pat(&field.node.pat)\n@@ -840,8 +852,8 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(element);\n             visitor.visit_expr(count)\n         }\n-        ExprStruct(ref path, ref fields, ref optional_base) => {\n-            visitor.visit_path(path, expression.id);\n+        ExprStruct(ref qpath, ref fields, ref optional_base) => {\n+            visitor.visit_qpath(qpath, expression.id, expression.span);\n             for field in fields {\n                 visitor.visit_name(field.name.span, field.name.node);\n                 visitor.visit_expr(&field.expr)\n@@ -917,11 +929,8 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)\n         }\n-        ExprPath(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n-                visitor.visit_ty(&qself.ty);\n-            }\n-            visitor.visit_path(path, expression.id)\n+        ExprPath(ref qpath) => {\n+            visitor.visit_qpath(qpath, expression.id, expression.span);\n         }\n         ExprBreak(ref opt_sp_name, ref opt_expr) => {\n             walk_opt_sp_name(visitor, opt_sp_name);"}, {"sha": "056c1b906206a5492f344d258fa65e458d731b1c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 129, "deletions": 60, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -188,13 +188,13 @@ impl<'a> LoweringContext<'a> {\n             node: match view_path.node {\n                 ViewPathSimple(ident, ref path) => {\n                     hir::ViewPathSimple(ident.name,\n-                                        self.lower_path(path, None, ParamMode::Explicit))\n+                                        self.lower_path(path, ParamMode::Explicit))\n                 }\n                 ViewPathGlob(ref path) => {\n-                    hir::ViewPathGlob(self.lower_path(path, None, ParamMode::Explicit))\n+                    hir::ViewPathGlob(self.lower_path(path, ParamMode::Explicit))\n                 }\n                 ViewPathList(ref path, ref path_list_idents) => {\n-                    hir::ViewPathList(self.lower_path(path, None, ParamMode::Explicit),\n+                    hir::ViewPathList(self.lower_path(path, ParamMode::Explicit),\n                                       path_list_idents.iter()\n                                                       .map(|item| self.lower_path_list_item(item))\n                                                       .collect())\n@@ -259,14 +259,7 @@ impl<'a> LoweringContext<'a> {\n                     return self.lower_ty(ty);\n                 }\n                 TyKind::Path(ref qself, ref path) => {\n-                    let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n-                        hir::QSelf {\n-                            ty: self.lower_ty(ty),\n-                            position: position,\n-                        }\n-                    });\n-                    let path = self.lower_path(path, qself.as_ref(), ParamMode::Explicit);\n-                    hir::TyPath(qself, path)\n+                    hir::TyPath(self.lower_qpath(t.id, qself, path, ParamMode::Explicit))\n                 }\n                 TyKind::ObjectSum(ref ty, ref bounds) => {\n                     hir::TyObjectSum(self.lower_ty(ty), self.lower_bounds(bounds))\n@@ -308,44 +301,116 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_path(&mut self,\n-                  p: &Path,\n-                  qself: Option<&hir::QSelf>,\n-                  param_mode: ParamMode)\n-                  -> hir::Path {\n-        hir::Path {\n+    fn lower_qpath(&mut self,\n+                   id: NodeId,\n+                   qself: &Option<QSelf>,\n+                   p: &Path,\n+                   param_mode: ParamMode)\n+                   -> hir::QPath {\n+        let qself_position = qself.as_ref().map(|q| q.position);\n+        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty));\n+\n+        let resolution = self.resolver.get_resolution(id)\n+                                      .unwrap_or(PathResolution::new(Def::Err));\n+\n+        let proj_start = p.segments.len() - resolution.depth;\n+        let path = P(hir::Path {\n             global: p.global,\n-            segments: p.segments.iter().enumerate().map(|(i, segment)| {\n-                let PathSegment { identifier, ref parameters } = *segment;\n-                let param_mode = match (qself, param_mode) {\n-                    (Some(qself), ParamMode::Optional) if i < qself.position => {\n+            segments: p.segments[..proj_start].iter().enumerate().map(|(i, segment)| {\n+                let param_mode = match (qself_position, param_mode) {\n+                    (Some(j), ParamMode::Optional) if i < j => {\n                         // This segment is part of the trait path in a\n                         // qualified path - one of `a`, `b` or `Trait`\n                         // in `<X as a::b::Trait>::T::U::method`.\n                         ParamMode::Explicit\n                     }\n                     _ => param_mode\n                 };\n-                hir::PathSegment {\n-                    name: identifier.name,\n-                    parameters: self.lower_path_parameters(parameters, param_mode),\n-                }\n+                self.lower_path_segment(segment, param_mode)\n             }).collect(),\n             span: p.span,\n+        });\n+\n+        // Simple case, either no projections, or only fully-qualified.\n+        // E.g. `std::mem::size_of` or `<I as Iterator>::Item`.\n+        if resolution.depth == 0 {\n+            return hir::QPath::Resolved(qself, path);\n         }\n+\n+        // Create the innermost type that we're projecting from.\n+        let mut ty = if path.segments.is_empty() {\n+            // If the base path is empty that means there exists a\n+            // syntactical `Self`, e.g. `&i32` in `<&i32>::clone`.\n+            qself.expect(\"missing QSelf for <T>::...\")\n+        } else {\n+            // Otherwise, the base path is an implicit `Self` type path,\n+            // e.g. `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n+            // `<I as Iterator>::Item::default`.\n+            let ty = self.ty(p.span, hir::TyPath(hir::QPath::Resolved(qself, path)));\n+\n+            // Associate that innermost path type with the base Def.\n+            self.resolver.record_resolution(ty.id, resolution.base_def);\n+\n+            ty\n+        };\n+\n+        // Anything after the base path are associated \"extensions\",\n+        // out of which all but the last one are associated types,\n+        // e.g. for `std::vec::Vec::<T>::IntoIter::Item::clone`:\n+        // * base path is `std::vec::Vec<T>`\n+        // * \"extensions\" are `IntoIter`, `Item` and `clone`\n+        // * type nodes are:\n+        //   1. `std::vec::Vec<T>` (created above)\n+        //   2. `<std::vec::Vec<T>>::IntoIter`\n+        //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n+        // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n+        for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n+            let segment = P(self.lower_path_segment(segment, param_mode));\n+            let qpath = hir::QPath::TypeRelative(ty, segment);\n+\n+            // It's finished, return the extension of the right node type.\n+            if i == p.segments.len() - 1 {\n+                return qpath;\n+            }\n+\n+            // Wrap the associated extension in another type node.\n+            ty = self.ty(p.span, hir::TyPath(qpath));\n+        }\n+\n+        // Should've returned in the for loop above.\n+        span_bug!(p.span, \"lower_qpath: no final extension segment in {}..{}\",\n+                  proj_start, p.segments.len())\n     }\n \n-    fn lower_path_parameters(&mut self,\n-                             path_parameters: &PathParameters,\n-                             param_mode: ParamMode)\n-                             -> hir::PathParameters {\n-        match *path_parameters {\n+    fn lower_path(&mut self,\n+                  p: &Path,\n+                  param_mode: ParamMode)\n+                  -> hir::Path {\n+        hir::Path {\n+            global: p.global,\n+            segments: p.segments.iter().map(|segment| {\n+                self.lower_path_segment(segment, param_mode)\n+            }).collect(),\n+            span: p.span,\n+        }\n+    }\n+\n+    fn lower_path_segment(&mut self,\n+                          segment: &PathSegment,\n+                          param_mode: ParamMode)\n+                          -> hir::PathSegment {\n+        let parameters = match segment.parameters {\n             PathParameters::AngleBracketed(ref data) => {\n                 let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n                 hir::AngleBracketedParameters(data)\n             }\n             PathParameters::Parenthesized(ref data) =>\n                 hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data)),\n+        };\n+\n+        hir::PathSegment {\n+            name: segment.identifier.name,\n+            parameters: parameters,\n         }\n     }\n \n@@ -521,7 +586,7 @@ impl<'a> LoweringContext<'a> {\n                                                           span}) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     id: id,\n-                    path: self.lower_path(path, None, ParamMode::Explicit),\n+                    path: self.lower_path(path, ParamMode::Explicit),\n                     ty: self.lower_ty(ty),\n                     span: span,\n                 })\n@@ -551,7 +616,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_trait_ref(&mut self, p: &TraitRef) -> hir::TraitRef {\n         hir::TraitRef {\n-            path: self.lower_path(&p.path, None, ParamMode::Explicit),\n+            path: self.lower_path(&p.path, ParamMode::Explicit),\n             ref_id: p.ref_id,\n         }\n     }\n@@ -908,26 +973,26 @@ impl<'a> LoweringContext<'a> {\n                                                       respan(pth1.span, pth1.node.name),\n                                                       sub.as_ref().map(|x| this.lower_pat(x)))\n                             }\n-                            _ => hir::PatKind::Path(None, hir::Path::from_name(pth1.span,\n-                                                                               pth1.node.name))\n+                            _ => {\n+                                let path = hir::Path::from_name(pth1.span, pth1.node.name);\n+                                hir::PatKind::Path(hir::QPath::Resolved(None, P(path)))\n+                            }\n                         }\n                     })\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n                 PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n-                    hir::PatKind::TupleStruct(self.lower_path(path, None, ParamMode::Optional),\n+                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional);\n+                    hir::PatKind::TupleStruct(qpath,\n                                               pats.iter().map(|x| self.lower_pat(x)).collect(),\n                                               ddpos)\n                 }\n                 PatKind::Path(ref qself, ref path) => {\n-                    let qself = qself.as_ref().map(|qself| {\n-                        hir::QSelf { ty: self.lower_ty(&qself.ty), position: qself.position }\n-                    });\n-                    let path = self.lower_path(path, qself.as_ref(), ParamMode::Optional);\n-                    hir::PatKind::Path(qself, path)\n+                    hir::PatKind::Path(self.lower_qpath(p.id, qself, path, ParamMode::Optional))\n                 }\n-                PatKind::Struct(ref pth, ref fields, etc) => {\n-                    let pth = self.lower_path(pth, None, ParamMode::Optional);\n+                PatKind::Struct(ref path, ref fields, etc) => {\n+                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional);\n+\n                     let fs = fields.iter()\n                                    .map(|f| {\n                                        Spanned {\n@@ -940,7 +1005,7 @@ impl<'a> LoweringContext<'a> {\n                                        }\n                                    })\n                                    .collect();\n-                    hir::PatKind::Struct(pth, fs, etc)\n+                    hir::PatKind::Struct(qpath, fs, etc)\n                 }\n                 PatKind::Tuple(ref elts, ddpos) => {\n                     hir::PatKind::Tuple(elts.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n@@ -1266,14 +1331,7 @@ impl<'a> LoweringContext<'a> {\n                     };\n                 }\n                 ExprKind::Path(ref qself, ref path) => {\n-                    let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n-                        hir::QSelf {\n-                            ty: self.lower_ty(ty),\n-                            position: position,\n-                        }\n-                    });\n-                    let path = self.lower_path(path, qself.as_ref(), ParamMode::Optional);\n-                    hir::ExprPath(qself, path)\n+                    hir::ExprPath(self.lower_qpath(e.id, qself, path, ParamMode::Optional))\n                 }\n                 ExprKind::Break(opt_ident, ref opt_expr) => {\n                     hir::ExprBreak(self.lower_opt_sp_ident(opt_ident),\n@@ -1306,7 +1364,7 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprInlineAsm(P(hir_asm), outputs, inputs)\n                 }\n                 ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n-                    hir::ExprStruct(P(self.lower_path(path, None, ParamMode::Optional)),\n+                    hir::ExprStruct(self.lower_qpath(e.id, &None, path, ParamMode::Optional),\n                                     fields.iter().map(|x| self.lower_field(x)).collect(),\n                                     maybe_expr.as_ref().map(|x| P(self.lower_expr(x))))\n                 }\n@@ -1688,7 +1746,7 @@ impl<'a> LoweringContext<'a> {\n             Visibility::Crate(_) => hir::Visibility::Crate,\n             Visibility::Restricted { ref path, id } => {\n                 hir::Visibility::Restricted {\n-                    path: P(self.lower_path(path, None, ParamMode::Explicit)),\n+                    path: P(self.lower_path(path, ParamMode::Explicit)),\n                     id: id\n                 }\n             }\n@@ -1774,7 +1832,8 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_ident(&mut self, span: Span, id: Name, binding: NodeId) -> hir::Expr {\n-        let expr_path = hir::ExprPath(None, self.path_ident(span, id));\n+        let path = self.path_ident(span, id);\n+        let expr_path = hir::ExprPath(hir::QPath::Resolved(None, P(path)));\n         let expr = self.expr(span, expr_path, ThinVec::new());\n \n         let def = {\n@@ -1792,9 +1851,9 @@ impl<'a> LoweringContext<'a> {\n \n     fn expr_path(&mut self, path: hir::Path, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         let def = self.resolver.resolve_generated_global_path(&path, true);\n-        let expr = P(self.expr(path.span, hir::ExprPath(None, path), attrs));\n+        let expr = self.expr(path.span, hir::ExprPath(hir::QPath::Resolved(None, P(path))), attrs);\n         self.resolver.record_resolution(expr.id, def);\n-        expr\n+        P(expr)\n     }\n \n     fn expr_match(&mut self,\n@@ -1821,9 +1880,10 @@ impl<'a> LoweringContext<'a> {\n                    e: Option<P<hir::Expr>>,\n                    attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n         let def = self.resolver.resolve_generated_global_path(&path, false);\n-        let expr = P(self.expr(sp, hir::ExprStruct(P(path), fields, e), attrs));\n+        let qpath = hir::QPath::Resolved(None, P(path));\n+        let expr = self.expr(sp, hir::ExprStruct(qpath, fields, e), attrs);\n         self.resolver.record_resolution(expr.id, def);\n-        expr\n+        P(expr)\n     }\n \n     fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> hir::Expr {\n@@ -1902,10 +1962,11 @@ impl<'a> LoweringContext<'a> {\n     fn pat_enum(&mut self, span: Span, path: hir::Path, subpats: hir::HirVec<P<hir::Pat>>)\n                 -> P<hir::Pat> {\n         let def = self.resolver.resolve_generated_global_path(&path, true);\n+        let qpath = hir::QPath::Resolved(None, P(path));\n         let pt = if subpats.is_empty() {\n-            hir::PatKind::Path(None, path)\n+            hir::PatKind::Path(qpath)\n         } else {\n-            hir::PatKind::TupleStruct(path, subpats, None)\n+            hir::PatKind::TupleStruct(qpath, subpats, None)\n         };\n         let pat = self.pat(span, pt);\n         self.resolver.record_resolution(pat.id, def);\n@@ -2045,4 +2106,12 @@ impl<'a> LoweringContext<'a> {\n         });\n         self.expr_block(block, attrs)\n     }\n+\n+    fn ty(&mut self, span: Span, node: hir::Ty_) -> P<hir::Ty> {\n+        P(hir::Ty {\n+            id: self.next_id(),\n+            node: node,\n+            span: span,\n+        })\n+    }\n }"}, {"sha": "e9e84eed3e78c02c96381542d7124d073894a01e", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -533,7 +533,7 @@ impl Pat {\n             PatKind::Lit(_) |\n             PatKind::Range(..) |\n             PatKind::Binding(..) |\n-            PatKind::Path(..) => {\n+            PatKind::Path(_) => {\n                 true\n             }\n         }\n@@ -576,16 +576,15 @@ pub enum PatKind {\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(Path, HirVec<Spanned<FieldPat>>, bool),\n+    Struct(QPath, HirVec<Spanned<FieldPat>>, bool),\n \n     /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n     /// 0 <= position <= subpats.len()\n-    TupleStruct(Path, HirVec<P<Pat>>, Option<usize>),\n+    TupleStruct(QPath, HirVec<P<Pat>>, Option<usize>),\n \n-    /// A possibly qualified path pattern.\n-    /// Such pattern can be resolved to a unit struct/variant or a constant.\n-    Path(Option<QSelf>, Path),\n+    /// A path pattern for an unit struct/variant or a (maybe-associated) constant.\n+    Path(QPath),\n \n     /// A tuple pattern `(a, b)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n@@ -940,12 +939,8 @@ pub enum Expr_ {\n     /// An indexing operation (`foo[2]`)\n     ExprIndex(P<Expr>, P<Expr>),\n \n-    /// Variable reference, possibly containing `::` and/or type\n-    /// parameters, e.g. foo::bar::<baz>.\n-    ///\n-    /// Optionally \"qualified\",\n-    /// e.g. `<HirVec<T> as SomeTrait>::SomeType`.\n-    ExprPath(Option<QSelf>, Path),\n+    /// Path to a definition, possibly containing lifetime or type parameters.\n+    ExprPath(QPath),\n \n     /// A referencing operation (`&a` or `&mut a`)\n     ExprAddrOf(Mutability, P<Expr>),\n@@ -963,7 +958,7 @@ pub enum Expr_ {\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n-    ExprStruct(P<Path>, HirVec<Field>, Option<P<Expr>>),\n+    ExprStruct(QPath, HirVec<Field>, Option<P<Expr>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n@@ -972,22 +967,30 @@ pub enum Expr_ {\n     ExprRepeat(P<Expr>, P<Expr>),\n }\n \n-/// The explicit Self type in a \"qualified path\". The actual\n-/// path, including the trait and the associated item, is stored\n-/// separately. `position` represents the index of the associated\n-/// item qualified with this Self type.\n-///\n-///     <HirVec<T> as a::b::Trait>::AssociatedItem\n-///      ^~~~~     ~~~~~~~~~~~~~~^\n-///      ty        position = 3\n-///\n-///     <HirVec<T>>::AssociatedItem\n-///      ^~~~~    ^\n-///      ty       position = 0\n+/// Optionally `Self`-qualified value/type path or associated extension.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct QSelf {\n-    pub ty: P<Ty>,\n-    pub position: usize,\n+pub enum QPath {\n+    /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n+    /// type, if the path points to an associated item in a trait.\n+    ///\n+    /// E.g. an unqualified path like `Clone::clone` has `None` for `Self`,\n+    /// while `<Vec<T> as Clone>::clone` has `Some(Vec<T>)` for `Self`,\n+    /// even though they both have the same two-segment `Clone::clone` `Path`.\n+    Resolved(Option<P<Ty>>, P<Path>),\n+\n+    /// Type-related paths, e.g. `<T>::default` or `<T>::Output`.\n+    /// Will be resolved by type-checking to an associated item.\n+    ///\n+    /// UFCS source paths can desugar into this, with `Vec::new` turning into\n+    /// `<Vec>::new`, and `T::X::Y::method` into `<<<T>::X>::Y>::method`,\n+    /// the `X` and `Y` nodes being each a `TyPath(QPath::TypeRelative(..))`.\n+    TypeRelative(P<Ty>, P<PathSegment>)\n+}\n+\n+impl fmt::Display for QPath {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", print::qpath_to_string(self))\n+    }\n }\n \n /// Hints at the original code for a `match _ { .. }`\n@@ -1161,11 +1164,12 @@ pub enum Ty_ {\n     TyNever,\n     /// A tuple (`(A, B, C, D,...)`)\n     TyTup(HirVec<P<Ty>>),\n-    /// A path (`module::module::...::Type`), optionally\n-    /// \"qualified\", e.g. `<HirVec<T> as SomeTrait>::SomeType`.\n+    /// A path to a type definition (`module::module::...::Type`), or an\n+    /// associated type, e.g. `<Vec<T> as Trait>::Type` or `<T>::Target`.\n     ///\n-    /// Type parameters are stored in the Path itself\n-    TyPath(Option<QSelf>, Path),\n+    /// Type parameters may be stored in each `PathSegment`.\n+    TyPath(QPath),\n+\n     /// Something like `A+B`. Note that `B` must always be a path.\n     TyObjectSum(P<Ty>, TyParamBounds),\n     /// A type like `for<'a> Foo<&'a Bar>`"}, {"sha": "8e39fde367ba7c6518df27eb659fcab0a56d1b7d", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -53,9 +53,13 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n \n pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Lit(_) | PatKind::Range(..) | PatKind::Path(Some(..), _) => true,\n+        PatKind::Lit(_) |\n+        PatKind::Range(..) |\n+        PatKind::Path(hir::QPath::Resolved(Some(..), _)) |\n+        PatKind::Path(hir::QPath::TypeRelative(..)) => true,\n+\n         PatKind::TupleStruct(..) |\n-        PatKind::Path(..) |\n+        PatKind::Path(hir::QPath::Resolved(..)) |\n         PatKind::Struct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Variant(..)) | Some(Def::VariantCtor(..)) => true,\n@@ -69,7 +73,8 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Path(..) => {\n+        PatKind::Path(hir::QPath::TypeRelative(..)) => true,\n+        PatKind::Path(hir::QPath::Resolved(..)) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n                 _ => false\n@@ -171,7 +176,7 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n     pat.walk(|p| {\n         match p.node {\n             PatKind::TupleStruct(..) |\n-            PatKind::Path(..) |\n+            PatKind::Path(hir::QPath::Resolved(..)) |\n             PatKind::Struct(..) => {\n                 match dm.get(&p.id).map(|d| d.full_def()) {\n                     Some(Def::Variant(id)) |"}, {"sha": "448139c37e64662f0cf69c556a598601a86b1db3", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 71, "deletions": 47, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -272,7 +272,11 @@ pub fn fn_block_to_string(p: &hir::FnDecl) -> String {\n }\n \n pub fn path_to_string(p: &hir::Path) -> String {\n-    to_string(|s| s.print_path(p, false, 0))\n+    to_string(|s| s.print_path(p, false))\n+}\n+\n+pub fn qpath_to_string(p: &hir::QPath) -> String {\n+    to_string(|s| s.print_qpath(p, false))\n }\n \n pub fn name_to_string(name: ast::Name) -> String {\n@@ -528,11 +532,8 @@ impl<'a> State<'a> {\n                 };\n                 self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &generics)?;\n             }\n-            hir::TyPath(None, ref path) => {\n-                self.print_path(path, false, 0)?;\n-            }\n-            hir::TyPath(Some(ref qself), ref path) => {\n-                self.print_qpath(path, qself, false)?\n+            hir::TyPath(ref qpath) => {\n+                self.print_qpath(qpath, false)?\n             }\n             hir::TyObjectSum(ref ty, ref bounds) => {\n                 self.print_type(&ty)?;\n@@ -845,7 +846,7 @@ impl<'a> State<'a> {\n     }\n \n     fn print_trait_ref(&mut self, t: &hir::TraitRef) -> io::Result<()> {\n-        self.print_path(&t.path, false, 0)\n+        self.print_path(&t.path, false)\n     }\n \n     fn print_formal_lifetime_list(&mut self, lifetimes: &[hir::LifetimeDef]) -> io::Result<()> {\n@@ -1237,11 +1238,11 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_struct(&mut self,\n-                         path: &hir::Path,\n+                         qpath: &hir::QPath,\n                          fields: &[hir::Field],\n                          wth: &Option<P<hir::Expr>>)\n                          -> io::Result<()> {\n-        self.print_path(path, true, 0)?;\n+        self.print_qpath(qpath, true)?;\n         word(&mut self.s, \"{\")?;\n         self.commasep_cmnt(Consistent,\n                            &fields[..],\n@@ -1345,8 +1346,8 @@ impl<'a> State<'a> {\n             hir::ExprRepeat(ref element, ref count) => {\n                 self.print_expr_repeat(&element, &count)?;\n             }\n-            hir::ExprStruct(ref path, ref fields, ref wth) => {\n-                self.print_expr_struct(path, &fields[..], wth)?;\n+            hir::ExprStruct(ref qpath, ref fields, ref wth) => {\n+                self.print_expr_struct(qpath, &fields[..], wth)?;\n             }\n             hir::ExprTup(ref exprs) => {\n                 self.print_expr_tup(exprs)?;\n@@ -1465,11 +1466,8 @@ impl<'a> State<'a> {\n                 self.print_expr(&index)?;\n                 word(&mut self.s, \"]\")?;\n             }\n-            hir::ExprPath(None, ref path) => {\n-                self.print_path(path, true, 0)?\n-            }\n-            hir::ExprPath(Some(ref qself), ref path) => {\n-                self.print_qpath(path, qself, true)?\n+            hir::ExprPath(ref qpath) => {\n+                self.print_qpath(qpath, true)?\n             }\n             hir::ExprBreak(opt_name, ref opt_expr) => {\n                 word(&mut self.s, \"break\")?;\n@@ -1622,13 +1620,12 @@ impl<'a> State<'a> {\n \n     fn print_path(&mut self,\n                   path: &hir::Path,\n-                  colons_before_params: bool,\n-                  depth: usize)\n+                  colons_before_params: bool)\n                   -> io::Result<()> {\n         self.maybe_print_comment(path.span.lo)?;\n \n         let mut first = !path.global;\n-        for segment in &path.segments[..path.segments.len() - depth] {\n+        for segment in &path.segments {\n             if first {\n                 first = false\n             } else {\n@@ -1644,31 +1641,61 @@ impl<'a> State<'a> {\n     }\n \n     fn print_qpath(&mut self,\n-                   path: &hir::Path,\n-                   qself: &hir::QSelf,\n+                   qpath: &hir::QPath,\n                    colons_before_params: bool)\n                    -> io::Result<()> {\n-        word(&mut self.s, \"<\")?;\n-        self.print_type(&qself.ty)?;\n-        if qself.position > 0 {\n-            space(&mut self.s)?;\n-            self.word_space(\"as\")?;\n-            let depth = path.segments.len() - qself.position;\n-            self.print_path(&path, false, depth)?;\n+        match *qpath {\n+            hir::QPath::Resolved(None, ref path) => {\n+                self.print_path(path, colons_before_params)\n+            }\n+            hir::QPath::Resolved(Some(ref qself), ref path) => {\n+                word(&mut self.s, \"<\")?;\n+                self.print_type(qself)?;\n+                space(&mut self.s)?;\n+                self.word_space(\"as\")?;\n+\n+                let mut first = !path.global;\n+                for segment in &path.segments[..path.segments.len() - 1] {\n+                    if first {\n+                        first = false\n+                    } else {\n+                        word(&mut self.s, \"::\")?\n+                    }\n+                    self.print_name(segment.name)?;\n+                    self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+                }\n+\n+                word(&mut self.s, \">\")?;\n+                word(&mut self.s, \"::\")?;\n+                let item_segment = path.segments.last().unwrap();\n+                self.print_name(item_segment.name)?;\n+                self.print_path_parameters(&item_segment.parameters, colons_before_params)\n+            }\n+            hir::QPath::TypeRelative(ref qself, ref item_segment) => {\n+                word(&mut self.s, \"<\")?;\n+                self.print_type(qself)?;\n+                word(&mut self.s, \">\")?;\n+                word(&mut self.s, \"::\")?;\n+                self.print_name(item_segment.name)?;\n+                self.print_path_parameters(&item_segment.parameters, colons_before_params)\n+            }\n         }\n-        word(&mut self.s, \">\")?;\n-        word(&mut self.s, \"::\")?;\n-        let item_segment = path.segments.last().unwrap();\n-        self.print_name(item_segment.name)?;\n-        self.print_path_parameters(&item_segment.parameters, colons_before_params)\n     }\n \n     fn print_path_parameters(&mut self,\n                              parameters: &hir::PathParameters,\n                              colons_before_params: bool)\n                              -> io::Result<()> {\n         if parameters.is_empty() {\n-            return Ok(());\n+            let infer_types = match *parameters {\n+                hir::AngleBracketedParameters(ref data) => data.infer_types,\n+                hir::ParenthesizedParameters(_) => false\n+            };\n+\n+            // FIXME(eddyb) See the comment below about infer_types.\n+            if !(infer_types && false) {\n+                return Ok(());\n+            }\n         }\n \n         if colons_before_params {\n@@ -1760,8 +1787,8 @@ impl<'a> State<'a> {\n                     self.print_pat(&p)?;\n                 }\n             }\n-            PatKind::TupleStruct(ref path, ref elts, ddpos) => {\n-                self.print_path(path, true, 0)?;\n+            PatKind::TupleStruct(ref qpath, ref elts, ddpos) => {\n+                self.print_qpath(qpath, true)?;\n                 self.popen()?;\n                 if let Some(ddpos) = ddpos {\n                     self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p))?;\n@@ -1778,14 +1805,11 @@ impl<'a> State<'a> {\n                 }\n                 self.pclose()?;\n             }\n-            PatKind::Path(None, ref path) => {\n-                self.print_path(path, true, 0)?;\n-            }\n-            PatKind::Path(Some(ref qself), ref path) => {\n-                self.print_qpath(path, qself, false)?;\n+            PatKind::Path(ref qpath) => {\n+                self.print_qpath(qpath, true)?;\n             }\n-            PatKind::Struct(ref path, ref fields, etc) => {\n-                self.print_path(path, true, 0)?;\n+            PatKind::Struct(ref qpath, ref fields, etc) => {\n+                self.print_qpath(qpath, true)?;\n                 self.nbsp()?;\n                 self.word_space(\"{\")?;\n                 self.commasep_cmnt(Consistent,\n@@ -2118,7 +2142,7 @@ impl<'a> State<'a> {\n                     }\n                 }\n                 &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{ref path, ref ty, ..}) => {\n-                    self.print_path(path, false, 0)?;\n+                    self.print_path(path, false)?;\n                     space(&mut self.s)?;\n                     self.word_space(\"=\")?;\n                     self.print_type(&ty)?;\n@@ -2132,7 +2156,7 @@ impl<'a> State<'a> {\n     pub fn print_view_path(&mut self, vp: &hir::ViewPath) -> io::Result<()> {\n         match vp.node {\n             hir::ViewPathSimple(name, ref path) => {\n-                self.print_path(path, false, 0)?;\n+                self.print_path(path, false)?;\n \n                 if path.segments.last().unwrap().name != name {\n                     space(&mut self.s)?;\n@@ -2144,15 +2168,15 @@ impl<'a> State<'a> {\n             }\n \n             hir::ViewPathGlob(ref path) => {\n-                self.print_path(path, false, 0)?;\n+                self.print_path(path, false)?;\n                 word(&mut self.s, \"::*\")\n             }\n \n             hir::ViewPathList(ref path, ref segments) => {\n                 if path.segments.is_empty() {\n                     word(&mut self.s, \"{\")?;\n                 } else {\n-                    self.print_path(path, false, 0)?;\n+                    self.print_path(path, false)?;\n                     word(&mut self.s, \"::{\")?;\n                 }\n                 self.commasep(Inconsistent, &segments[..], |s, w| s.print_name(w.node.name))?;"}, {"sha": "406d345992a20fa4e0366423f6fc937158010907", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -1440,7 +1440,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                     }\n                     ty_queue.push(&mut_ty.ty);\n                 }\n-                hir::TyPath(ref maybe_qself, ref path) => {\n+                hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                     match self.tcx.expect_def(cur_ty.id) {\n                         Def::Enum(did) | Def::TyAlias(did) |\n                         Def::Struct(did) | Def::Union(did) => {\n@@ -1476,15 +1476,12 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                             };\n                             let new_path = self.rebuild_path(rebuild_info, lifetime);\n                             let qself = maybe_qself.as_ref().map(|qself| {\n-                                hir::QSelf {\n-                                    ty: self.rebuild_arg_ty_or_output(&qself.ty, lifetime,\n-                                                                      anon_nums, region_names),\n-                                    position: qself.position\n-                                }\n+                                self.rebuild_arg_ty_or_output(qself, lifetime,\n+                                                              anon_nums, region_names)\n                             });\n                             let to = hir::Ty {\n                                 id: cur_ty.id,\n-                                node: hir::TyPath(qself, new_path),\n+                                node: hir::TyPath(hir::QPath::Resolved(qself, P(new_path))),\n                                 span: cur_ty.span\n                             };\n                             new_ty = self.rebuild_ty(new_ty, P(to));"}, {"sha": "5b0f241f8a878e606cfe0146f133e5d94433879f", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -14,14 +14,14 @@\n  * Almost certainly this could (and should) be refactored out of existence.\n  */\n \n+use hir;\n use hir::def::Def;\n use ty::{Ty, TyCtxt};\n \n use syntax_pos::Span;\n-use hir as ast;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn prohibit_type_params(self, segments: &[ast::PathSegment]) {\n+    pub fn prohibit_type_params(self, segments: &[hir::PathSegment]) {\n         for segment in segments {\n             for typ in segment.parameters.types() {\n                 struct_span_err!(self.sess, typ.span, E0109,\n@@ -53,24 +53,24 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn prim_ty_to_ty(self,\n-                         segments: &[ast::PathSegment],\n-                         nty: ast::PrimTy)\n+                         segments: &[hir::PathSegment],\n+                         nty: hir::PrimTy)\n                          -> Ty<'tcx> {\n         self.prohibit_type_params(segments);\n         match nty {\n-            ast::TyBool => self.types.bool,\n-            ast::TyChar => self.types.char,\n-            ast::TyInt(it) => self.mk_mach_int(it),\n-            ast::TyUint(uit) => self.mk_mach_uint(uit),\n-            ast::TyFloat(ft) => self.mk_mach_float(ft),\n-            ast::TyStr => self.mk_str()\n+            hir::TyBool => self.types.bool,\n+            hir::TyChar => self.types.char,\n+            hir::TyInt(it) => self.mk_mach_int(it),\n+            hir::TyUint(uit) => self.mk_mach_uint(uit),\n+            hir::TyFloat(ft) => self.mk_mach_float(ft),\n+            hir::TyStr => self.mk_str()\n         }\n     }\n \n     /// If a type in the AST is a primitive type, return the ty::Ty corresponding\n     /// to it.\n-    pub fn ast_ty_to_prim_ty(self, ast_ty: &ast::Ty) -> Option<Ty<'tcx>> {\n-        if let ast::TyPath(None, ref path) = ast_ty.node {\n+    pub fn ast_ty_to_prim_ty(self, ast_ty: &hir::Ty) -> Option<Ty<'tcx>> {\n+        if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n             if let Def::PrimTy(nty) = self.expect_def(ast_ty.id) {\n                 Some(self.prim_ty_to_ty(&path.segments, nty))\n             } else {"}, {"sha": "efbec7bf13b9ea03a75d57dce04b0720a7ec80cf", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -240,6 +240,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n+            hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n+                self.lookup_and_handle_definition(expr.id);\n+            }\n             hir::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(expr.id);\n             }"}, {"sha": "2892f249c5efbd7c0c123edef4005ad2589dfc1d", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             hir::ExprInlineAsm(..) => {\n                 self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n-            hir::ExprPath(..) => {\n+            hir::ExprPath(hir::QPath::Resolved(..)) => {\n                 if let Def::Static(def_id, mutbl) = self.tcx.expect_def(expr.id) {\n                     if mutbl {\n                         self.require_unsafe(expr.span, \"use of mutable static\");"}, {"sha": "6c952825554de1157b5ade69b1aad2cdf1395947", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -374,7 +374,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.walk_adjustment(expr);\n \n         match expr.node {\n-            hir::ExprPath(..) => { }\n+            hir::ExprPath(_) => { }\n \n             hir::ExprType(ref subexpr, _) => {\n                 self.walk_expr(&subexpr)"}, {"sha": "c610c6f75b0caab0b85af0b8097d8d9c54e8edae", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -160,23 +160,27 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n \n impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n-        if let hir::ExprPath(..) = expr.node {\n-            match self.infcx.tcx.expect_def(expr.id) {\n-                Def::Fn(did) if self.def_id_is_transmute(did) => {\n-                    let typ = self.infcx.tcx.tables().node_id_to_type(expr.id);\n-                    match typ.sty {\n-                        ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n-                            let from = bare_fn_ty.sig.0.inputs[0];\n-                            let to = bare_fn_ty.sig.0.output;\n-                            self.check_transmute(expr.span, from, to, expr.id);\n-                        }\n-                        _ => {\n-                            span_bug!(expr.span, \"transmute wasn't a bare fn?!\");\n-                        }\n+        let def = match expr.node {\n+            hir::ExprPath(_) => {\n+                self.infcx.tcx.expect_def(expr.id)\n+            }\n+            _ => Def::Err\n+        };\n+        match def {\n+            Def::Fn(did) if self.def_id_is_transmute(did) => {\n+                let typ = self.infcx.tcx.tables().node_id_to_type(expr.id);\n+                match typ.sty {\n+                    ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n+                        let from = bare_fn_ty.sig.0.inputs[0];\n+                        let to = bare_fn_ty.sig.0.output;\n+                        self.check_transmute(expr.span, from, to, expr.id);\n+                    }\n+                    _ => {\n+                        span_bug!(expr.span, \"transmute wasn't a bare fn?!\");\n                     }\n                 }\n-                _ => {}\n             }\n+            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr);"}, {"sha": "eefed0a5a74ffec6868fd38204f737cfde833b38", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -443,7 +443,7 @@ fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n-      hir::ExprPath(..) => {\n+      hir::ExprPath(_) => {\n         let def = ir.tcx.expect_def(expr.id);\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if let Def::Local(..) = def {\n@@ -922,7 +922,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n-          hir::ExprPath(..) => {\n+          hir::ExprPath(hir::QPath::Resolved(..)) => {\n               self.access_path(expr, succ, ACC_READ | ACC_USE)\n           }\n \n@@ -1171,7 +1171,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(inputs, succ)\n           }\n \n-          hir::ExprLit(..) => {\n+          hir::ExprLit(..) | hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n             succ\n           }\n \n@@ -1235,7 +1235,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // just ignore such cases and treat them as reads.\n \n         match expr.node {\n-            hir::ExprPath(..) => succ,\n+            hir::ExprPath(_) => succ,\n             hir::ExprField(ref e, _) => self.propagate_through_expr(&e, succ),\n             hir::ExprTupField(ref e, _) => self.propagate_through_expr(&e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n@@ -1246,7 +1246,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                     -> LiveNode {\n         match expr.node {\n-          hir::ExprPath(..) => {\n+          hir::ExprPath(hir::QPath::Resolved(..)) => {\n               self.access_path(expr, succ, acc)\n           }\n \n@@ -1431,8 +1431,8 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       hir::ExprBreak(..) | hir::ExprAgain(..) | hir::ExprLit(_) |\n       hir::ExprBlock(..) | hir::ExprAddrOf(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n-      hir::ExprClosure(..) | hir::ExprPath(..) | hir::ExprBox(..) |\n-      hir::ExprType(..) => {\n+      hir::ExprClosure(..) | hir::ExprPath(_) |\n+      hir::ExprBox(..) | hir::ExprType(..) => {\n         intravisit::walk_expr(this, expr);\n       }\n     }\n@@ -1482,7 +1482,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n-            hir::ExprPath(..) => {\n+            hir::ExprPath(hir::QPath::Resolved(..)) => {\n                 if let Def::Local(def_id) = self.ir.tcx.expect_def(expr.id) {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually"}, {"sha": "1ca078dcd2e4976fb7417f9f8c581413976733c9", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -488,7 +488,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          hir::ExprPath(..) => {\n+          hir::ExprPath(_) => {\n             self.cat_def(expr.id, expr.span, expr_ty, self.tcx().expect_def(expr.id))\n           }\n \n@@ -1157,7 +1157,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          PatKind::Path(..) | PatKind::Binding(.., None) |\n+          PatKind::Path(_) | PatKind::Binding(.., None) |\n           PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild => {\n             // always ok\n           }"}, {"sha": "0329b4c4a3019bbb77fa6a65e132dfe9d6809757", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -91,7 +91,7 @@ struct ReachableContext<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n-            hir::ExprPath(..) => {\n+            hir::ExprPath(_) => {\n                 let def = self.tcx.expect_def(expr.id);\n                 let def_id = def.def_id();\n                 if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {"}, {"sha": "c65fd25950deab808fe80638c0d01258a81c6919", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -244,7 +244,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_ty(this, ty);\n                 });\n             }\n-            hir::TyPath(None, ref path) => {\n+            hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n                 // if this path references a trait, then this will resolve to\n                 // a trait ref, which introduces a binding scope.\n                 match self.def_map.get(&ty.id).map(|d| (d.base_def, d.depth)) {\n@@ -944,13 +944,14 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     impl<'v> Visitor<'v> for ConstrainedCollector {\n         fn visit_ty(&mut self, ty: &'v hir::Ty) {\n             match ty.node {\n-                hir::TyPath(Some(_), _) => {\n+                hir::TyPath(hir::QPath::Resolved(Some(_), _)) |\n+                hir::TyPath(hir::QPath::TypeRelative(..)) => {\n                     // ignore lifetimes appearing in associated type\n                     // projections, as they are not *constrained*\n                     // (defined above)\n                 }\n \n-                hir::TyPath(None, ref path) => {\n+                hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n                     // consider only the lifetimes on the final\n                     // segment; I am not sure it's even currently\n                     // valid to have them elsewhere, but even if it"}, {"sha": "a044ffd9a7f85e27b06147f4f7e96e6928f5f131", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -486,6 +486,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         intravisit::walk_pat(self, pat)\n     }\n \n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+        check_ty(self.tcx, ty,\n+                 &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n+        intravisit::walk_ty(self, ty)\n+    }\n+\n     fn visit_block(&mut self, b: &'tcx hir::Block) {\n         let old_skip_count = self.in_skip_block;\n         match b.rules {\n@@ -553,6 +559,10 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n             let method_call = ty::MethodCall::expr(e.id);\n             tcx.tables().method_map[&method_call].def_id\n         }\n+        hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n+            span = e.span;\n+            tcx.expect_def(e.id).def_id()\n+        }\n         hir::ExprField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.tables().expr_ty_adjusted(base_e).sty {\n@@ -633,6 +643,11 @@ pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n+    if let PatKind::Path(hir::QPath::TypeRelative(..)) = pat.node {\n+        let def_id = tcx.expect_def(pat.id).def_id();\n+        maybe_do_stability_check(tcx, def_id, pat.span, cb)\n+    }\n+\n     let v = match tcx.tables().pat_ty_opt(pat).map(|ty| &ty.sty) {\n         Some(&ty::TyAdt(adt, _)) if !adt.is_enum() => adt.struct_variant(),\n         _ => return,\n@@ -656,6 +671,19 @@ pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n     }\n }\n \n+pub fn check_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: &hir::Ty,\n+                          cb: &mut FnMut(DefId, Span,\n+                                         &Option<&Stability>,\n+                                         &Option<DeprecationEntry>)) {\n+    debug!(\"check_ty(ty = {:?})\", ty);\n+    if is_internal(tcx, ty.span) { return; }\n+\n+    if let hir::TyPath(hir::QPath::TypeRelative(..)) = ty.node {\n+        let def_id = tcx.expect_def(ty.id).def_id();\n+        maybe_do_stability_check(tcx, def_id, ty.span, cb);\n+    }\n+}\n+\n fn maybe_do_stability_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       id: DefId, span: Span,\n                                       cb: &mut FnMut(DefId, Span,"}, {"sha": "3d02ff4651f885deb9c7c90fd592cf4583d45fe9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -2059,11 +2059,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn expr_is_lval(self, expr: &hir::Expr) -> bool {\n          match expr.node {\n-            hir::ExprPath(..) => {\n-                // This function can be used during type checking when not all paths are\n-                // fully resolved. Partially resolved paths in expressions can only legally\n-                // refer to associated items which are always rvalues.\n-                match self.expect_resolution(expr.id).base_def {\n+            hir::ExprPath(hir::QPath::Resolved(..)) => {\n+                match self.expect_def(expr.id) {\n                     Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n                     _ => false,\n                 }\n@@ -2080,6 +2077,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 true\n             }\n \n+            // Partially qualified paths in expressions can only legally\n+            // refer to associated items which are always rvalues.\n+            hir::ExprPath(hir::QPath::TypeRelative(..)) |\n+\n             hir::ExprCall(..) |\n             hir::ExprMethodCall(..) |\n             hir::ExprStruct(..) |"}, {"sha": "4731cea02065bf48992623325d8c1c74ea0eb94a", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -324,6 +324,7 @@ impl Witness {\n \n                 ty::TyAdt(adt, _) => {\n                     let v = ctor.variant_for_adt(adt);\n+                    let qpath = hir::QPath::Resolved(None, P(def_to_path(cx.tcx, v.did)));\n                     match v.ctor_kind {\n                         CtorKind::Fictive => {\n                             let field_pats: hir::HirVec<_> = v.fields.iter()\n@@ -338,16 +339,12 @@ impl Witness {\n                                     }\n                                 }).collect();\n                             let has_more_fields = field_pats.len() < arity;\n-                            PatKind::Struct(\n-                                def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n+                            PatKind::Struct(qpath, field_pats, has_more_fields)\n                         }\n                         CtorKind::Fn => {\n-                            PatKind::TupleStruct(\n-                                def_to_path(cx.tcx, v.did), pats.collect(), None)\n-                        }\n-                        CtorKind::Const => {\n-                            PatKind::Path(None, def_to_path(cx.tcx, v.did))\n+                            PatKind::TupleStruct(qpath, pats.collect(), None)\n                         }\n+                        CtorKind::Const => PatKind::Path(qpath)\n                     }\n                 }\n "}, {"sha": "e8c05ec1a35ae11ac3372297758256180dd37319", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -286,9 +286,11 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n                entry.insert(PathResolution::new(def));\n             }\n-            let path = match def {\n+            let qpath = match def {\n                 Def::StructCtor(def_id, CtorKind::Fn) |\n-                Def::VariantCtor(def_id, CtorKind::Fn) => def_to_path(tcx, def_id),\n+                Def::VariantCtor(def_id, CtorKind::Fn) => {\n+                    hir::QPath::Resolved(None, P(def_to_path(tcx, def_id)))\n+                }\n                 Def::Fn(..) | Def::Method(..) => return Ok(P(hir::Pat {\n                     id: expr.id,\n                     node: PatKind::Lit(P(expr.clone())),\n@@ -299,10 +301,10 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let pats = args.iter()\n                            .map(|expr| const_expr_to_pat(tcx, &*expr, pat_id, span))\n                            .collect::<Result<_, _>>()?;\n-            PatKind::TupleStruct(path, pats, None)\n+            PatKind::TupleStruct(qpath, pats, None)\n         }\n \n-        hir::ExprStruct(ref path, ref fields, None) => {\n+        hir::ExprStruct(ref qpath, ref fields, None) => {\n             let field_pats =\n                 fields.iter()\n                       .map(|field| Ok(codemap::Spanned {\n@@ -314,7 +316,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           },\n                       }))\n                       .collect::<Result<_, _>>()?;\n-            PatKind::Struct((**path).clone(), field_pats, false)\n+            PatKind::Struct(qpath.clone(), field_pats, false)\n         }\n \n         hir::ExprArray(ref exprs) => {\n@@ -324,10 +326,17 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             PatKind::Slice(pats, None, hir::HirVec::new())\n         }\n \n-        hir::ExprPath(_, ref path) => {\n+        hir::ExprPath(_) => {\n             match tcx.expect_def(expr.id) {\n                 Def::StructCtor(_, CtorKind::Const) |\n-                Def::VariantCtor(_, CtorKind::Const) => PatKind::Path(None, path.clone()),\n+                Def::VariantCtor(_, CtorKind::Const) => {\n+                    match expr.node {\n+                        hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                            PatKind::Path(hir::QPath::Resolved(None, path.clone()))\n+                        }\n+                        _ => bug!()\n+                    }\n+                }\n                 Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                     let substs = Some(tcx.tables().node_id_item_substs(expr.id)\n                         .unwrap_or_else(|| tcx.intern_substs(&[])));\n@@ -788,14 +797,14 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n         }\n       }\n-      hir::ExprPath(..) => {\n+      hir::ExprPath(_) => {\n           // This function can be used before type checking when not all paths are fully resolved.\n           // FIXME: There's probably a better way to make sure we don't panic here.\n-          let resolution = tcx.expect_resolution(e.id);\n-          if resolution.depth != 0 {\n-              signal!(e, UnresolvedPath);\n-          }\n-          match resolution.base_def {\n+          let def = match tcx.expect_def_or_none(e.id) {\n+              Some(def) => def,\n+              None => signal!(e, UnresolvedPath)\n+          };\n+          match def {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                   let substs = if let ExprTypeChecked = ty_hint {\n@@ -1358,17 +1367,12 @@ pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let mut diag = report_const_eval_err(\n                 tcx, &err, count_expr.span, reason);\n \n-            match count_expr.node {\n-                hir::ExprPath(None, hir::Path {\n-                    global: false,\n-                    ref segments,\n-                    ..\n-                }) if segments.len() == 1 => {\n+            if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = count_expr.node {\n+                if !path.global && path.segments.len() == 1 {\n                     if let Some(Def::Local(..)) = tcx.expect_def_or_none(count_expr.id) {\n-                        diag.note(&format!(\"`{}` is a variable\", segments[0].name));\n+                        diag.note(&format!(\"`{}` is a variable\", path.segments[0].name));\n                     }\n                 }\n-                _ => {}\n             }\n \n             diag.emit();"}, {"sha": "ec405311012592231027300d7cb2f21bffd6e5f6", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -185,6 +185,7 @@ enum SawAbiComponent<'a> {\n     SawImplItem(SawTraitOrImplItemComponent),\n     SawStructField,\n     SawVariant,\n+    SawQPath,\n     SawPath(bool),\n     SawPathSegment,\n     SawPathParameters,\n@@ -259,7 +260,7 @@ enum SawExprComponent<'a> {\n     SawExprAssign,\n     SawExprAssignOp(hir::BinOp_),\n     SawExprIndex,\n-    SawExprPath(Option<usize>),\n+    SawExprPath,\n     SawExprAddrOf(hir::Mutability),\n     SawExprRet,\n     SawExprInlineAsm(&'a hir::InlineAsm),\n@@ -333,7 +334,7 @@ fn saw_expr<'a>(node: &'a Expr_,\n         ExprField(_, name)       => (SawExprField(name.node.as_str()), false),\n         ExprTupField(_, id)      => (SawExprTupField(id.node), false),\n         ExprIndex(..)            => (SawExprIndex, true),\n-        ExprPath(ref qself, _)   => (SawExprPath(qself.as_ref().map(|q| q.position)), false),\n+        ExprPath(_)              => (SawExprPath, false),\n         ExprAddrOf(m, _)         => (SawExprAddrOf(m), false),\n         ExprBreak(id, _)         => (SawExprBreak(id.map(|id| id.node.as_str())), false),\n         ExprAgain(id)            => (SawExprAgain(id.map(|id| id.node.as_str())), false),\n@@ -411,7 +412,7 @@ fn saw_pat(node: &PatKind) -> SawPatComponent {\n         PatKind::Binding(bindingmode, ..) => SawPatBinding(bindingmode),\n         PatKind::Struct(..) => SawPatStruct,\n         PatKind::TupleStruct(..) => SawPatTupleStruct,\n-        PatKind::Path(..) => SawPatPath,\n+        PatKind::Path(_) => SawPatPath,\n         PatKind::Tuple(..) => SawPatTuple,\n         PatKind::Box(..) => SawPatBox,\n         PatKind::Ref(_, mutability) => SawPatRef(mutability),\n@@ -447,7 +448,7 @@ fn saw_ty(node: &Ty_) -> SawTyComponent {\n       TyBareFn(ref barefnty) => SawTyBareFn(barefnty.unsafety, barefnty.abi),\n       TyNever => SawTyNever,\n       TyTup(..) => SawTyTup,\n-      TyPath(..) => SawTyPath,\n+      TyPath(_) => SawTyPath,\n       TyObjectSum(..) => SawTyObjectSum,\n       TyPolyTraitRef(..) => SawTyPolyTraitRef,\n       TyImplTrait(..) => SawTyImplTrait,\n@@ -655,6 +656,13 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         visit::walk_struct_field(self, s)\n     }\n \n+    fn visit_qpath(&mut self, qpath: &'tcx QPath, id: NodeId, span: Span) {\n+        debug!(\"visit_qpath: st={:?}\", self.st);\n+        SawQPath.hash(self.st);\n+        self.hash_discriminant(qpath);\n+        visit::walk_qpath(self, qpath, id, span)\n+    }\n+\n     fn visit_path(&mut self, path: &'tcx Path, _: ast::NodeId) {\n         debug!(\"visit_path: st={:?}\", self.st);\n         SawPath(path.global).hash(self.st);"}, {"sha": "25ea3d65993a49c3d35e18010cbedb3e9899af3a", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -376,7 +376,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n-        if let PatKind::Path(None, ref path) = p.node {\n+        if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.node {\n             if !path.global && path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n                 if let Def::Const(..) = cx.tcx.expect_def(p.id) {\n                     NonUpperCaseGlobals::check_upper_case(cx,"}, {"sha": "7be591293c91bb2583c2577e9e914125d722ced4", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -718,6 +718,12 @@ impl LateLintPass for Deprecated {\n                              &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n     }\n \n+    fn check_ty(&mut self, cx: &LateContext, ty: &hir::Ty) {\n+        stability::check_ty(cx.tcx, ty,\n+                            &mut |id, sp, stab, depr|\n+                               self.lint(cx, id, sp, &stab, &depr));\n+    }\n+\n     fn check_impl_item(&mut self, _: &LateContext, item: &hir::ImplItem) {\n         self.push_item(item.id);\n     }\n@@ -1204,7 +1210,7 @@ impl LateLintPass for MutableTransmutes {\n              expr: &hir::Expr)\n              -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n             match expr.node {\n-                hir::ExprPath(..) => (),\n+                hir::ExprPath(_) => (),\n                 _ => return None,\n             }\n             if let Def::Fn(did) = cx.tcx.expect_def(expr.id) {"}, {"sha": "d0ad682fb58a60a7547a9e918a6eda22b4cf7f0f", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -218,7 +218,7 @@ impl LintPass for PathStatements {\n impl LateLintPass for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         if let hir::StmtSemi(ref expr, _) = s.node {\n-            if let hir::ExprPath(..) = expr.node {\n+            if let hir::ExprPath(_) = expr.node {\n                 cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n             }\n         }"}, {"sha": "0c796ad42bbc2c87bd7ef8d0ad264c6d8c388089", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -265,7 +265,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     args: vec![fun.to_ref(), tupled_args.to_ref()]\n                 }\n             } else {\n-                let adt_data = if let hir::ExprPath(..) = fun.node {\n+                let adt_data = if let hir::ExprPath(hir::QPath::Resolved(..)) = fun.node {\n                     // Tuple-like ADTs are represented as ExprCall. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def|{\n                         match cx.tcx.expect_def(fun.id) {\n@@ -531,7 +531,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprPath(..) => {\n+        hir::ExprPath(_) => {\n             convert_path_expr(cx, expr)\n         }\n "}, {"sha": "ff46273a997c855f9b62cf9e27c799bbf69b6ae2", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -487,7 +487,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                 _ => {}\n             }\n         }\n-        hir::ExprPath(..) => {\n+        hir::ExprPath(_) => {\n             match v.tcx.expect_def(e.id) {\n                 Def::VariantCtor(_, CtorKind::Const) => {\n                     // Size is determined by the whole enum, may be non-zero."}, {"sha": "9028821ef116d760719f7a673c75bf30297c50f5", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -218,6 +218,10 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         self.record(\"LifetimeDef\", Id::None, lifetime);\n         hir_visit::walk_lifetime_def(self, lifetime)\n     }\n+    fn visit_qpath(&mut self, qpath: &'v hir::QPath, id: NodeId, span: Span) {\n+        self.record(\"QPath\", Id::None, qpath);\n+        hir_visit::walk_qpath(self, qpath, id, span)\n+    }\n     fn visit_path(&mut self, path: &'v hir::Path, _id: NodeId) {\n         self.record(\"Path\", Id::None, path);\n         hir_visit::walk_path(self, path)\n@@ -234,7 +238,6 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         self.record(\"PathSegment\", Id::None, path_segment);\n         hir_visit::walk_path_segment(self, path_span, path_segment)\n     }\n-\n     fn visit_assoc_type_binding(&mut self, type_binding: &'v hir::TypeBinding) {\n         self.record(\"TypeBinding\", Id::Node(type_binding.id), type_binding);\n         hir_visit::walk_assoc_type_binding(self, type_binding)"}, {"sha": "b98cf7e602b10198dbe63aa42446029c01ca2768", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -250,7 +250,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n \n     fn visit_expr(&mut self, e: &'ast hir::Expr) {\n         match e.node {\n-            hir::ExprPath(..) => {\n+            hir::ExprPath(_) => {\n                 match self.def_map.get(&e.id).map(|d| d.base_def) {\n                     Some(Def::Static(def_id, _)) |\n                     Some(Def::AssociatedConst(def_id)) |"}, {"sha": "55e11caac6d02e5304ae4d16c582cea6575f62d2", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -67,7 +67,7 @@ struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n \n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn ty_level(&self, ty: &hir::Ty) -> Option<AccessLevel> {\n-        if let hir::TyPath(..) = ty.node {\n+        if let hir::TyPath(_) = ty.node {\n             match self.tcx.expect_def(ty.id) {\n                 Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n                     Some(AccessLevel::Public)\n@@ -306,11 +306,11 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n \n impl<'b, 'a, 'tcx: 'a> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     // Make the type hidden under a type alias reachable\n-    fn reach_aliased_type(&mut self, item: &'tcx hir::Item, path: &'tcx hir::Path) {\n+    fn reach_aliased_type(&mut self, item: &'tcx hir::Item, segment: &'tcx hir::PathSegment) {\n         if let hir::ItemTy(ref ty, ref generics) = item.node {\n             // See `fn is_public_type_alias` for details\n             self.visit_ty(ty);\n-            let provided_params = path.segments.last().unwrap().parameters.types().len();\n+            let provided_params = segment.parameters.types().len();\n             for ty_param in &generics.ty_params[provided_params..] {\n                 if let Some(ref default_ty) = ty_param.default {\n                     self.visit_ty(default_ty);\n@@ -328,7 +328,12 @@ impl<'b, 'a, 'tcx: 'a> Visitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyPath(_, ref path) = ty.node {\n+        let path_segment = match ty.node {\n+            hir::TyPath(hir::QPath::Resolved(_, ref path)) => path.segments.last(),\n+            hir::TyPath(hir::QPath::TypeRelative(_, ref segment)) => Some(&**segment),\n+            _ => None\n+        };\n+        if let Some(segment) = path_segment {\n             let def = self.ev.tcx.expect_def(ty.id);\n             match def {\n                 Def::Struct(def_id) | Def::Union(def_id) | Def::Enum(def_id) |\n@@ -344,7 +349,7 @@ impl<'b, 'a, 'tcx: 'a> Visitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n                             // Type aliases are substituted. Associated type aliases are not\n                             // substituted yet, but ideally they should be.\n                             if self.ev.get(item.id).is_none() {\n-                                self.reach_aliased_type(item, path);\n+                                self.reach_aliased_type(item, segment);\n                             }\n                         } else {\n                             self.ev.update(item.id, Some(AccessLevel::Reachable));\n@@ -461,7 +466,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprPath(..) => {\n+            hir::ExprPath(hir::QPath::Resolved(..)) => {\n                 if let def @ Def::StructCtor(_, CtorKind::Fn) = self.tcx.expect_def(expr.id) {\n                     let adt_def = self.tcx.expect_variant_def(def);\n                     let private_indexes = adt_def.fields.iter().enumerate().filter(|&(_, field)| {\n@@ -606,7 +611,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n-        if let hir::TyPath(..) = ty.node {\n+        if let hir::TyPath(_) = ty.node {\n             if self.inner.path_is_private_type(ty.id) {\n                 self.contains_private = true;\n                 // found what we're looking for so let's stop\n@@ -844,7 +849,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n-        if let hir::TyPath(..) = t.node {\n+        if let hir::TyPath(_) = t.node {\n             if self.path_is_private_type(t.id) {\n                 self.old_error_set.insert(t.id);\n             }\n@@ -906,7 +911,7 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     // Return the visibility of the type alias's least visible component type when substituted\n-    fn substituted_alias_visibility(&self, item: &hir::Item, path: &hir::Path)\n+    fn substituted_alias_visibility(&self, item: &hir::Item, segment: &hir::PathSegment)\n                                     -> Option<ty::Visibility> {\n         // Type alias is considered public if the aliased type is\n         // public, even if the type alias itself is private. So, something\n@@ -921,7 +926,7 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n             // type Alias<T = Private> = T;\n             // pub fn f() -> Alias {...} // `Private` is implicitly used here, so it must be public\n             // ```\n-            let provided_params = path.segments.last().unwrap().parameters.types().len();\n+            let provided_params = segment.parameters.types().len();\n             for ty_param in &generics.ty_params[provided_params..] {\n                 if let Some(ref default_ty) = ty_param.default {\n                     check.visit_ty(default_ty);\n@@ -936,7 +941,12 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n-        if let hir::TyPath(_, ref path) = ty.node {\n+        let path_segment = match ty.node {\n+            hir::TyPath(hir::QPath::Resolved(_, ref path)) => path.segments.last(),\n+            hir::TyPath(hir::QPath::TypeRelative(_, ref segment)) => Some(&**segment),\n+            _ => None\n+        };\n+        if let Some(segment) = path_segment {\n             match self.tcx.expect_def(ty.id) {\n                 Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n                     // Public\n@@ -961,7 +971,7 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n                         }\n \n                         let item = self.tcx.map.expect_item(node_id);\n-                        let vis = match self.substituted_alias_visibility(item, path) {\n+                        let vis = match self.substituted_alias_visibility(item, segment) {\n                             Some(vis) => vis,\n                             None => ty::Visibility::from_hir(&item.vis, node_id, self.tcx),\n                         };"}, {"sha": "7d02678679ac6845606c4c0e21d8eb7e4f71518f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 57, "deletions": 108, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -952,7 +952,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let tcx = self.tcx();\n         match ty.node {\n-            hir::TyPath(None, ref path) => {\n+            hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n                 let resolution = tcx.expect_resolution(ty.id);\n                 match resolution.base_def {\n                     Def::Trait(trait_def_id) if resolution.depth == 0 => {\n@@ -1261,12 +1261,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     // the whole path.\n     // Will fail except for T::A and Self::A; i.e., if ty/ty_path_def are not a type\n     // parameter or Self.\n-    fn associated_path_def_to_ty(&self,\n-                                 span: Span,\n-                                 ty: Ty<'tcx>,\n-                                 ty_path_def: Def,\n-                                 item_segment: &hir::PathSegment)\n-                                 -> (Ty<'tcx>, Def)\n+    pub fn associated_path_def_to_ty(&self,\n+                                     span: Span,\n+                                     ty: Ty<'tcx>,\n+                                     ty_path_def: Def,\n+                                     item_segment: &hir::PathSegment)\n+                                     -> (Ty<'tcx>, Def)\n     {\n         let tcx = self.tcx();\n         let assoc_name = item_segment.name;\n@@ -1412,54 +1412,55 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    // Check the base def in a PathResolution and convert it to a Ty. If there are\n-    // associated types in the PathResolution, these will need to be separately\n-    // resolved.\n-    fn base_def_to_ty(&self,\n-                      rscope: &RegionScope,\n-                      span: Span,\n-                      def: Def,\n-                      opt_self_ty: Option<Ty<'tcx>>,\n-                      base_path_ref_id: ast::NodeId,\n-                      base_segments: &[hir::PathSegment],\n-                      permit_variants: bool)\n-                      -> Ty<'tcx> {\n+    // Check a type Def and convert it to a Ty.\n+    pub fn def_to_ty(&self,\n+                     rscope: &RegionScope,\n+                     span: Span,\n+                     def: Def,\n+                     opt_self_ty: Option<Ty<'tcx>>,\n+                     path_id: ast::NodeId,\n+                     path_segments: &[hir::PathSegment],\n+                     permit_variants: bool)\n+                     -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n-        debug!(\"base_def_to_ty(def={:?}, opt_self_ty={:?}, base_segments={:?})\",\n-               def, opt_self_ty, base_segments);\n+        debug!(\"base_def_to_ty(def={:?}, opt_self_ty={:?}, path_segments={:?})\",\n+               def, opt_self_ty, path_segments);\n \n         match def {\n             Def::Trait(trait_def_id) => {\n                 // N.B. this case overlaps somewhat with\n                 // TyObjectSum, see that fn for details\n \n-                tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n+                assert_eq!(opt_self_ty, None);\n+                tcx.prohibit_type_params(path_segments.split_last().unwrap().1);\n \n                 self.trait_path_to_object_type(rscope,\n                                                span,\n                                                trait_def_id,\n-                                               base_path_ref_id,\n-                                               base_segments.last().unwrap(),\n+                                               path_id,\n+                                               path_segments.last().unwrap(),\n                                                span,\n                                                partition_bounds(tcx, span, &[]))\n             }\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) | Def::Union(did) => {\n-                tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n-                self.ast_path_to_ty(rscope, span, did, base_segments.last().unwrap())\n+                assert_eq!(opt_self_ty, None);\n+                tcx.prohibit_type_params(path_segments.split_last().unwrap().1);\n+                self.ast_path_to_ty(rscope, span, did, path_segments.last().unwrap())\n             }\n             Def::Variant(did) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n-                tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n+                assert_eq!(opt_self_ty, None);\n+                tcx.prohibit_type_params(path_segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(rscope,\n                                     span,\n-                                    param_mode,\n                                     tcx.parent_def_id(did).unwrap(),\n-                                    base_segments.last().unwrap())\n+                                    path_segments.last().unwrap())\n             }\n             Def::TyParam(did) => {\n-                tcx.prohibit_type_params(base_segments);\n+                assert_eq!(opt_self_ty, None);\n+                tcx.prohibit_type_params(path_segments);\n \n                 let node_id = tcx.map.as_local_node_id(did).unwrap();\n                 let param = tcx.ty_param_defs.borrow().get(&node_id)\n@@ -1481,7 +1482,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Def::SelfTy(_, Some(def_id)) => {\n                 // Self in impl (we know the concrete type).\n \n-                tcx.prohibit_type_params(base_segments);\n+                assert_eq!(opt_self_ty, None);\n+                tcx.prohibit_type_params(path_segments);\n                 let ty = tcx.item_type(def_id);\n                 if let Some(free_substs) = self.get_free_substs() {\n                     ty.subst(tcx, free_substs)\n@@ -1491,34 +1493,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             Def::SelfTy(Some(_), None) => {\n                 // Self in trait.\n-                tcx.prohibit_type_params(base_segments);\n+                assert_eq!(opt_self_ty, None);\n+                tcx.prohibit_type_params(path_segments);\n                 tcx.mk_self_type()\n             }\n             Def::AssociatedTy(def_id) => {\n-                tcx.prohibit_type_params(&base_segments[..base_segments.len()-2]);\n+                tcx.prohibit_type_params(&path_segments[..path_segments.len()-2]);\n                 let trait_did = tcx.parent_def_id(def_id).unwrap();\n                 self.qpath_to_ty(rscope,\n                                  span,\n                                  opt_self_ty,\n                                  trait_did,\n-                                 &base_segments[base_segments.len()-2],\n-                                 base_segments.last().unwrap())\n-            }\n-            Def::Mod(..) => {\n-                // Used as sentinel by callers to indicate the `<T>::A::B::C` form.\n-                // FIXME(#22519) This part of the resolution logic should be\n-                // avoided entirely for that form, once we stop needed a Def\n-                // for `associated_path_def_to_ty`.\n-                // Fixing this will also let use resolve <Self>::Foo the same way we\n-                // resolve Self::Foo, at the moment we can't resolve the former because\n-                // we don't have the trait information around, which is just sad.\n-\n-                assert!(base_segments.is_empty());\n-\n-                opt_self_ty.expect(\"missing T in <T>::a::b::c\")\n+                                 &path_segments[path_segments.len()-2],\n+                                 path_segments.last().unwrap())\n             }\n             Def::PrimTy(prim_ty) => {\n-                tcx.prim_ty_to_ty(base_segments, prim_ty)\n+                assert_eq!(opt_self_ty, None);\n+                tcx.prim_ty_to_ty(path_segments, prim_ty)\n             }\n             Def::Err => {\n                 self.set_tainted_by_errors();\n@@ -1535,50 +1526,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    // Resolve possibly associated type path into a type and final definition.\n-    // Note that both base_segments and assoc_segments may be empty, although not at same time.\n-    pub fn finish_resolving_def_to_ty(&self,\n-                                      rscope: &RegionScope,\n-                                      span: Span,\n-                                      base_def: Def,\n-                                      opt_self_ty: Option<Ty<'tcx>>,\n-                                      base_path_ref_id: ast::NodeId,\n-                                      base_segments: &[hir::PathSegment],\n-                                      assoc_segments: &[hir::PathSegment],\n-                                      permit_variants: bool)\n-                                      -> (Ty<'tcx>, Def) {\n-        // Convert the base type.\n-        debug!(\"finish_resolving_def_to_ty(base_def={:?}, \\\n-                base_segments={:?}, \\\n-                assoc_segments={:?})\",\n-               base_def,\n-               base_segments,\n-               assoc_segments);\n-        let base_ty = self.base_def_to_ty(rscope,\n-                                          span,\n-                                          base_def,\n-                                          opt_self_ty,\n-                                          base_path_ref_id,\n-                                          base_segments,\n-                                          permit_variants);\n-        debug!(\"finish_resolving_def_to_ty: base_def_to_ty returned {:?}\", base_ty);\n-\n-        // If any associated type segments remain, attempt to resolve them.\n-        let (mut ty, mut def) = (base_ty, base_def);\n-        for segment in assoc_segments {\n-            debug!(\"finish_resolving_def_to_ty: segment={:?}\", segment);\n-            // This is pretty bad (it will fail except for T::A and Self::A).\n-            let (new_ty, new_def) = self.associated_path_def_to_ty(span, ty, def, segment);\n-            ty = new_ty;\n-            def = new_def;\n-\n-            if def == Def::Err {\n-                break;\n-            }\n-        }\n-        (ty, def)\n-    }\n-\n     /// Parses the programmer's textual representation of a type into our\n     /// internal notion of a type.\n     pub fn ast_ty_to_ty(&self, rscope: &RegionScope, ast_ty: &hir::Ty) -> Ty<'tcx> {\n@@ -1701,26 +1648,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     tcx.types.err\n                 }\n             }\n-            hir::TyPath(ref maybe_qself, ref path) => {\n+            hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n-                let path_res = tcx.expect_resolution(ast_ty.id);\n-                let base_ty_end = path.segments.len() - path_res.depth;\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n-                    self.ast_ty_to_ty(rscope, &qself.ty)\n+                    self.ast_ty_to_ty(rscope, qself)\n                 });\n-                let (ty, def) = self.finish_resolving_def_to_ty(rscope,\n-                                                                ast_ty.span,\n-                                                                path_res.base_def,\n-                                                                opt_self_ty,\n-                                                                ast_ty.id,\n-                                                                &path.segments[..base_ty_end],\n-                                                                &path.segments[base_ty_end..],\n-                                                                false);\n+                self.def_to_ty(rscope,\n+                               ast_ty.span,\n+                               tcx.expect_def(ast_ty.id),\n+                               opt_self_ty,\n+                               ast_ty.id,\n+                               &path.segments,\n+                               false)\n+            }\n+            hir::TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n+                debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n+                let ty = self.ast_ty_to_ty(rscope, qself);\n+\n+                let def = tcx.expect_def_or_none(qself.id).unwrap_or(Def::Err);\n+                let (ty, def) = self.associated_path_def_to_ty(ast_ty.span, ty, def, segment);\n \n                 // Write back the new resolution.\n-                if path_res.depth != 0 {\n-                    tcx.def_map.borrow_mut().insert(ast_ty.id, PathResolution::new(def));\n-                }\n+                tcx.def_map.borrow_mut().insert(ast_ty.id, PathResolution::new(def));\n \n                 ty\n             }"}, {"sha": "3e62b22d36f999546ef64c7caa7c1d5c8958ea89", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -148,15 +148,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 typ\n             }\n-            PatKind::TupleStruct(ref path, ref subpats, ddpos) => {\n-                self.check_pat_tuple_struct(pat, path, &subpats, ddpos, expected)\n+            PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n+                self.check_pat_tuple_struct(pat, qpath, &subpats, ddpos, expected)\n             }\n-            PatKind::Path(ref opt_qself, ref path) => {\n-                let opt_qself_ty = opt_qself.as_ref().map(|qself| self.to_ty(&qself.ty));\n-                self.check_pat_path(pat, opt_qself_ty, path, expected)\n+            PatKind::Path(ref qpath) => {\n+                self.check_pat_path(pat, qpath, expected)\n             }\n-            PatKind::Struct(ref path, ref fields, etc) => {\n-                self.check_pat_struct(pat, path, fields, etc, expected)\n+            PatKind::Struct(ref qpath, ref fields, etc) => {\n+                self.check_pat_struct(pat, qpath, fields, etc, expected)\n             }\n             PatKind::Tuple(ref elements, ddpos) => {\n                 let mut expected_len = elements.len();\n@@ -496,13 +495,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_pat_struct(&self,\n                         pat: &'gcx hir::Pat,\n-                        path: &hir::Path,\n+                        qpath: &hir::QPath,\n                         fields: &'gcx [Spanned<hir::FieldPat>],\n                         etc: bool,\n                         expected: Ty<'tcx>) -> Ty<'tcx>\n     {\n         // Resolve the path and check the definition for errors.\n-        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(path, pat.id) {\n+        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.id) {\n             variant_ty\n         } else {\n             for field in fields {\n@@ -521,20 +520,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_pat_path(&self,\n                       pat: &hir::Pat,\n-                      opt_self_ty: Option<Ty<'tcx>>,\n-                      path: &hir::Path,\n+                      qpath: &hir::QPath,\n                       expected: Ty<'tcx>) -> Ty<'tcx>\n     {\n         let tcx = self.tcx;\n         let report_unexpected_def = |def: Def| {\n             span_err!(tcx.sess, pat.span, E0533,\n                       \"expected unit struct/variant or constant, found {} `{}`\",\n-                      def.kind_name(), path);\n+                      def.kind_name(), qpath);\n         };\n \n         // Resolve the path and check the definition for errors.\n-        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(opt_self_ty, path,\n-                                                                   pat.id, pat.span);\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.id, pat.span);\n         match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n@@ -558,7 +555,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_pat_tuple_struct(&self,\n                               pat: &hir::Pat,\n-                              path: &hir::Path,\n+                              qpath: &hir::QPath,\n                               subpats: &'gcx [P<hir::Pat>],\n                               ddpos: Option<usize>,\n                               expected: Ty<'tcx>) -> Ty<'tcx>\n@@ -571,14 +568,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n         let report_unexpected_def = |def: Def| {\n             let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n-                              def.kind_name(), path);\n+                              def.kind_name(), qpath);\n             struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n                 .span_label(pat.span, &format!(\"not a tuple variant or struct\")).emit();\n             on_error();\n         };\n \n         // Resolve the path and check the definition for errors.\n-        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(None, path, pat.id, pat.span);\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.id, pat.span);\n         let variant = match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();"}, {"sha": "6598790355e8243f977f27bce3ba60631f3ced87", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -28,7 +28,6 @@ use syntax_pos::Span;\n \n use rustc::hir::print as pprust;\n use rustc::hir;\n-use rustc::hir::Expr_;\n \n use std::cell;\n use std::cmp::Ordering;\n@@ -210,7 +209,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(expr) = rcvr_expr {\n                         if let Ok(expr_string) = tcx.sess.codemap().span_to_snippet(expr.span) {\n                             report_function!(expr.span, expr_string);\n-                        } else if let Expr_::ExprPath(_, path) = expr.node.clone() {\n+                        } else if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = expr.node {\n                             if let Some(segment) = path.segments.last() {\n                                 report_function!(expr.span, segment.name);\n                             }"}, {"sha": "33b123d0a6d8f7c993f6ccf25176717c7c63a02c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 78, "deletions": 66, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -3301,10 +3301,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_struct_path(&self,\n-                             path: &hir::Path,\n+                             qpath: &hir::QPath,\n                              node_id: ast::NodeId)\n                              -> Option<(ty::VariantDef<'tcx>,  Ty<'tcx>)> {\n-        let (def, ty) = self.finish_resolving_struct_path(path, node_id);\n+        let path_span = match *qpath {\n+            hir::QPath::Resolved(_, ref path) => path.span,\n+            hir::QPath::TypeRelative(ref qself, _) => qself.span\n+        };\n+        let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, node_id);\n         let variant = match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n@@ -3324,7 +3328,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Def::AssociatedTy(..) | Def::SelfTy(..)\n                             if !self.tcx.sess.features.borrow().more_struct_aliases => {\n                         emit_feature_err(&self.tcx.sess.parse_sess,\n-                                         \"more_struct_aliases\", path.span, GateIssue::Language,\n+                                         \"more_struct_aliases\", path_span, GateIssue::Language,\n                                          \"`Self` and associated types in struct \\\n                                           expressions and patterns are unstable\");\n                     }\n@@ -3342,37 +3346,43 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((variant, did, substs)) = variant {\n             // Check bounds on type arguments used in the path.\n-            let bounds = self.instantiate_bounds(path.span, did, substs);\n-            let cause = traits::ObligationCause::new(path.span, self.body_id,\n+            let bounds = self.instantiate_bounds(path_span, did, substs);\n+            let cause = traits::ObligationCause::new(path_span, self.body_id,\n                                                      traits::ItemObligation(did));\n             self.add_obligations_for_parameters(cause, &bounds);\n \n             Some((variant, ty))\n         } else {\n-            struct_span_err!(self.tcx.sess, path.span, E0071,\n+            struct_span_err!(self.tcx.sess, path_span, E0071,\n                              \"expected struct, variant or union type, found {}\",\n                              ty.sort_string(self.tcx))\n-                .span_label(path.span, &format!(\"not a struct\"))\n+                .span_label(path_span, &format!(\"not a struct\"))\n                 .emit();\n             None\n         }\n     }\n \n     fn check_expr_struct(&self,\n                          expr: &hir::Expr,\n-                         path: &hir::Path,\n+                         qpath: &hir::QPath,\n                          fields: &'gcx [hir::Field],\n                          base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx>\n     {\n         // Find the relevant variant\n-        let (variant, struct_ty) = if let Some(variant_ty) = self.check_struct_path(path, expr.id) {\n+        let (variant, struct_ty) =\n+        if let Some(variant_ty) = self.check_struct_path(qpath, expr.id) {\n             variant_ty\n         } else {\n             self.check_struct_fields_on_error(fields, base_expr);\n             return self.tcx.types.err;\n         };\n \n-        self.check_expr_struct_fields(struct_ty, path.span, variant, fields,\n+        let path_span = match *qpath {\n+            hir::QPath::Resolved(_, ref path) => path.span,\n+            hir::QPath::TypeRelative(ref qself, _) => qself.span\n+        };\n+\n+        self.check_expr_struct_fields(struct_ty, path_span, variant, fields,\n                                       base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {\n             self.check_expr_has_type(base_expr, struct_ty);\n@@ -3590,9 +3600,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tcx.mk_ref(region, tm)\n             }\n           }\n-          hir::ExprPath(ref opt_qself, ref path) => {\n-              let opt_self_ty = opt_qself.as_ref().map(|qself| self.to_ty(&qself.ty));\n-              let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(opt_self_ty, path,\n+          hir::ExprPath(ref qpath) => {\n+              let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath,\n                                                                          expr.id, expr.span);\n               let ty = if def != Def::Err {\n                   self.instantiate_value_path(segments, opt_ty, def, expr.span, id)\n@@ -3930,8 +3939,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 tuple\n             }\n           }\n-          hir::ExprStruct(ref path, ref fields, ref base_expr) => {\n-            self.check_expr_struct(expr, path, fields, base_expr)\n+          hir::ExprStruct(ref qpath, ref fields, ref base_expr) => {\n+            self.check_expr_struct(expr, qpath, fields, base_expr)\n           }\n           hir::ExprField(ref base, ref field) => {\n             self.check_field(expr, lvalue_pref, &base, field)\n@@ -3999,72 +4008,75 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n     // The newly resolved definition is written into `def_map`.\n     fn finish_resolving_struct_path(&self,\n-                                    path: &hir::Path,\n+                                    qpath: &hir::QPath,\n+                                    path_span: Span,\n                                     node_id: ast::NodeId)\n                                     -> (Def, Ty<'tcx>)\n     {\n-        let path_res = self.tcx.expect_resolution(node_id);\n-        let base_ty_end = path.segments.len() - path_res.depth;\n-        let (ty, def) = AstConv::finish_resolving_def_to_ty(self, self, path.span,\n-                                                            path_res.base_def,\n-                                                            None,\n-                                                            node_id,\n-                                                            &path.segments[..base_ty_end],\n-                                                            &path.segments[base_ty_end..],\n-                                                            true);\n-        // Write back the new resolution.\n-        if path_res.depth != 0 {\n-            self.tcx.def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n+        match *qpath {\n+            hir::QPath::Resolved(ref maybe_qself, ref path) => {\n+                let opt_self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n+                let def = self.tcx.expect_def(node_id);\n+                let ty = AstConv::def_to_ty(self, self,\n+                                            path.span,\n+                                            def,\n+                                            opt_self_ty,\n+                                            node_id,\n+                                            &path.segments,\n+                                            true);\n+                (def, ty)\n+            }\n+            hir::QPath::TypeRelative(ref qself, ref segment) => {\n+                let ty = self.to_ty(qself);\n+\n+                let def = self.tcx.expect_def_or_none(qself.id).unwrap_or(Def::Err);\n+                let (ty, def) = AstConv::associated_path_def_to_ty(self, path_span,\n+                                                                   ty, def, segment);\n+\n+                // Write back the new resolution.\n+                self.tcx.def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n+\n+                (def, ty)\n+            }\n         }\n-        (def, ty)\n     }\n \n     // Resolve associated value path into a base type and associated constant or method definition.\n     // The newly resolved definition is written into `def_map`.\n     pub fn resolve_ty_and_def_ufcs<'b>(&self,\n-                                       opt_self_ty: Option<Ty<'tcx>>,\n-                                       path: &'b hir::Path,\n+                                       qpath: &'b hir::QPath,\n                                        node_id: ast::NodeId,\n                                        span: Span)\n                                        -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n-        let path_res = self.tcx.expect_resolution(node_id);\n-        if path_res.depth == 0 {\n-            // If fully resolved already, we don't have to do anything.\n-            (path_res.base_def, opt_self_ty, &path.segments)\n-        } else {\n-            // Try to resolve everything except for the last segment as a type.\n-            let ty_segments = path.segments.split_last().unwrap().1;\n-            let base_ty_end = path.segments.len() - path_res.depth;\n-            let (ty, _def) = AstConv::finish_resolving_def_to_ty(self, self, span,\n-                                                                 path_res.base_def,\n-                                                                 opt_self_ty,\n-                                                                 node_id,\n-                                                                 &ty_segments[..base_ty_end],\n-                                                                 &ty_segments[base_ty_end..],\n-                                                                 false);\n-\n-            // Resolve an associated constant or method on the previously resolved type.\n-            let item_segment = path.segments.last().unwrap();\n-            let item_name = item_segment.name;\n-            let def = match self.resolve_ufcs(span, item_name, ty, node_id) {\n-                Ok(def) => def,\n-                Err(error) => {\n-                    let def = match error {\n-                        method::MethodError::PrivateMatch(def) => def,\n-                        _ => Def::Err,\n-                    };\n-                    if item_name != keywords::Invalid.name() {\n-                        self.report_method_error(span, ty, item_name, None, error);\n-                    }\n-                    def\n+        let (ty, item_segment) = match *qpath {\n+            hir::QPath::Resolved(ref opt_qself, ref path) => {\n+                return (self.tcx.expect_def(node_id),\n+                        opt_qself.as_ref().map(|qself| self.to_ty(qself)),\n+                        &path.segments[..]);\n+            }\n+            hir::QPath::TypeRelative(ref qself, ref segment) => {\n+                (self.to_ty(qself), segment)\n+            }\n+        };\n+        let item_name = item_segment.name;\n+        let def = match self.resolve_ufcs(span, item_name, ty, node_id) {\n+            Ok(def) => def,\n+            Err(error) => {\n+                let def = match error {\n+                    method::MethodError::PrivateMatch(def) => def,\n+                    _ => Def::Err,\n+                };\n+                if item_name != keywords::Invalid.name() {\n+                    self.report_method_error(span, ty, item_name, None, error);\n                 }\n-            };\n+                def\n+            }\n+        };\n \n-            // Write back the new resolution.\n-            self.tcx.def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n-            (def, Some(ty), slice::ref_slice(item_segment))\n-        }\n+        // Write back the new resolution.\n+        self.tcx.def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n+        (def, Some(ty), slice::ref_slice(&**item_segment))\n     }\n \n     pub fn check_decl_initializer(&self,"}, {"sha": "2b1bea89c526035753fa112847df629adc6290b1", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -603,7 +603,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"regionck::visit_expr(e={:?}, repeating_scope={}) - visiting subexprs\",\n                expr, self.repeating_scope);\n         match expr.node {\n-            hir::ExprPath(..) => {\n+            hir::ExprPath(_) => {\n                 self.fcx.opt_node_ty_substs(expr.id, |item_substs| {\n                     let origin = infer::ParameterOrigin::Path;\n                     self.substs_wf_in_scope(origin, &item_substs.substs, expr.span, expr_region);"}, {"sha": "ca5208b7a035aae6dbdcb1f0c62cb6d27f67db70", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -542,7 +542,7 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       param_id: ast::NodeId)\n                       -> bool\n {\n-    if let hir::TyPath(None, _) = ast_ty.node {\n+    if let hir::TyPath(hir::QPath::Resolved(None, _)) = ast_ty.node {\n         let path_res = tcx.expect_resolution(ast_ty.id);\n         match path_res.base_def {\n             Def::SelfTy(Some(def_id), None) |"}, {"sha": "aff384043497e0b5988e8f7411d2eabd4c6f132c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -1727,7 +1727,7 @@ impl Clean<Type> for hir::Ty {\n                 FixedVector(box ty.clean(cx), n)\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n-            TyPath(None, ref path) => {\n+            TyPath(hir::QPath::Resolved(None, ref path)) => {\n                 let def = cx.tcx.expect_def(self.id);\n                 if let Some(new_ty) = cx.ty_substs.borrow().get(&def).cloned() {\n                     return new_ty;\n@@ -1766,7 +1766,7 @@ impl Clean<Type> for hir::Ty {\n                 }\n                 resolve_type(cx, path.clean(cx), self.id)\n             }\n-            TyPath(Some(ref qself), ref p) => {\n+            TyPath(hir::QPath::Resolved(Some(ref qself), ref p)) => {\n                 let mut segments: Vec<_> = p.segments.clone().into();\n                 segments.pop();\n                 let trait_path = hir::Path {\n@@ -1776,7 +1776,19 @@ impl Clean<Type> for hir::Ty {\n                 };\n                 Type::QPath {\n                     name: p.segments.last().unwrap().name.clean(cx),\n-                    self_type: box qself.ty.clean(cx),\n+                    self_type: box qself.clean(cx),\n+                    trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n+                }\n+            }\n+            TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n+                let trait_path = hir::Path {\n+                    span: self.span,\n+                    global: false,\n+                    segments: vec![].into(),\n+                };\n+                Type::QPath {\n+                    name: segment.name.clean(cx),\n+                    self_type: box qself.clean(cx),\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n             }\n@@ -2263,11 +2275,20 @@ impl Clean<PathSegment> for hir::PathSegment {\n     }\n }\n \n-fn path_to_string(p: &hir::Path) -> String {\n+fn qpath_to_string(p: &hir::QPath) -> String {\n+    let (segments, global) = match *p {\n+        hir::QPath::Resolved(_, ref path) => {\n+            (&path.segments, path.global)\n+        }\n+        hir::QPath::TypeRelative(_, ref segment) => {\n+            return segment.name.to_string()\n+        }\n+    };\n+\n     let mut s = String::new();\n     let mut first = true;\n-    for i in p.segments.iter().map(|x| x.name.as_str()) {\n-        if !first || p.global {\n+    for i in segments.iter().map(|x| x.name.as_str()) {\n+        if !first || global {\n             s.push_str(\"::\");\n         } else {\n             first = false;\n@@ -2725,17 +2746,15 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     match p.node {\n         PatKind::Wild => \"_\".to_string(),\n         PatKind::Binding(_, ref p, _) => p.node.to_string(),\n-        PatKind::TupleStruct(ref p, ..) | PatKind::Path(None, ref p) => path_to_string(p),\n-        PatKind::Path(..) => panic!(\"tried to get argument name from qualified PatKind::Path, \\\n-                                     which is not allowed in function arguments\"),\n+        PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),\n         PatKind::Struct(ref name, ref fields, etc) => {\n-            format!(\"{} {{ {}{} }}\", path_to_string(name),\n+            format!(\"{} {{ {}{} }}\", qpath_to_string(name),\n                 fields.iter().map(|&Spanned { node: ref fp, .. }|\n                                   format!(\"{}: {}\", fp.name, name_from_pat(&*fp.pat)))\n                              .collect::<Vec<String>>().join(\", \"),\n                 if etc { \", ...\" } else { \"\" }\n             )\n-        },\n+        }\n         PatKind::Tuple(ref elts, _) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n                                             .collect::<Vec<String>>().join(\", \")),\n         PatKind::Box(ref p) => name_from_pat(&**p),"}, {"sha": "48aabce708eab277d3bcfb944a5fbe15734272f0", "filename": "src/test/compile-fail/issue-28992-empty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28992-empty.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -23,5 +23,5 @@ impl S {\n fn main() {\n     if let C1(..) = 0 {} //~ ERROR expected tuple struct/variant, found constant `C1`\n     if let S::C2(..) = 0 {}\n-    //~^ ERROR expected tuple struct/variant, found associated constant `S::C2`\n+    //~^ ERROR expected tuple struct/variant, found associated constant `<S>::C2`\n }"}, {"sha": "671a518073c376e478eca2bfea872473ac763c9c", "filename": "src/test/compile-fail/method-path-in-pattern.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -22,13 +22,15 @@ impl MyTrait for Foo {}\n \n fn main() {\n     match 0u32 {\n-        Foo::bar => {} //~ ERROR expected unit struct/variant or constant, found method `Foo::bar`\n+        Foo::bar => {}\n+        //~^ ERROR expected unit struct/variant or constant, found method `<Foo>::bar`\n     }\n     match 0u32 {\n-        <Foo>::bar => {} //~ ERROR expected unit struct/variant or constant, found method `bar`\n+        <Foo>::bar => {}\n+        //~^ ERROR expected unit struct/variant or constant, found method `<Foo>::bar`\n     }\n     match 0u32 {\n         <Foo>::trait_bar => {}\n-        //~^ ERROR expected unit struct/variant or constant, found method `trait_bar`\n+        //~^ ERROR expected unit struct/variant or constant, found method `<Foo>::trait_bar`\n     }\n }"}, {"sha": "a7bc27e1749182e0f1de42ab64f52992979e4216", "filename": "src/test/compile-fail/qualified-path-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -28,7 +28,7 @@ impl S {\n fn main() {\n     match 10 {\n         <S as Tr>::A::f::<u8> => {}\n-        //~^ ERROR expected unit struct/variant or constant, found method `Tr::A::f<u8>`\n+        //~^ ERROR expected unit struct/variant or constant, found method `<<S as Tr>::A>::f<u8>`\n         0 ... <S as Tr>::A::f::<u8> => {} //~ ERROR only char and numeric types are allowed in range\n     }\n }"}, {"sha": "84bcca3fc7bd3a3726c6387ea087e21b2d6b926a", "filename": "src/test/compile-fail/unspecified-self-in-trait-ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Ftest%2Fcompile-fail%2Funspecified-self-in-trait-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Ftest%2Fcompile-fail%2Funspecified-self-in-trait-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funspecified-self-in-trait-ref.rs?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n pub trait Foo<A=Self> {\n-    fn foo();\n+    fn foo(&self);\n }\n \n pub trait Bar<X=usize, A=Self> {\n-    fn foo();\n+    fn foo(&self);\n }\n \n fn main() {"}, {"sha": "fdb7f9c68b99db54189764c305f92df4223d482e", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/16b5c2cfef811feebe2797bcb7e01d2b6ff12db1/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=16b5c2cfef811feebe2797bcb7e01d2b6ff12db1", "patch": "@@ -40,7 +40,7 @@\n \n \n                   (($crate::fmt::format as\n-                       fn(std::fmt::Arguments<'_>) -> std::string::String {std::fmt::format})(((::std::fmt::Arguments::new_v1\n+                       fn(std::fmt::Arguments<'_>) -> std::string::String {std::fmt::format})(((<::std::fmt::Arguments>::new_v1\n                                                                                                    as\n                                                                                                    fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})(({\n                                                                                                                                                                                                                static __STATIC_FMTSTR:"}]}