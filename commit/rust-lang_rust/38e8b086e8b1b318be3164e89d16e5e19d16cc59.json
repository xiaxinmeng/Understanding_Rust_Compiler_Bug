{"sha": "38e8b086e8b1b318be3164e89d16e5e19d16cc59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZThiMDg2ZThiMWIzMThiZTMxNjRlODlkMTZlNWUxOWQxNmNjNTk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-09T08:45:30Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T03:43:29Z"}, "message": "chains: refactoring\n\npre-process the expression tree to get a list of chain items.", "tree": {"sha": "8ca4e04dddca59872b7e9cafba926c444ee63bf9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ca4e04dddca59872b7e9cafba926c444ee63bf9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38e8b086e8b1b318be3164e89d16e5e19d16cc59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38e8b086e8b1b318be3164e89d16e5e19d16cc59", "html_url": "https://github.com/rust-lang/rust/commit/38e8b086e8b1b318be3164e89d16e5e19d16cc59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38e8b086e8b1b318be3164e89d16e5e19d16cc59/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c8222474696d3d833cf850a1d50f1c485b63f09", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c8222474696d3d833cf850a1d50f1c485b63f09", "html_url": "https://github.com/rust-lang/rust/commit/9c8222474696d3d833cf850a1d50f1c485b63f09"}], "stats": {"total": 203, "additions": 84, "deletions": 119}, "files": [{"sha": "99fd3d0779b839b0b8f55c15a39e18842ba11354", "filename": "src/chains.rs", "status": "modified", "additions": 84, "deletions": 119, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/38e8b086e8b1b318be3164e89d16e5e19d16cc59/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38e8b086e8b1b318be3164e89d16e5e19d16cc59/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=38e8b086e8b1b318be3164e89d16e5e19d16cc59", "patch": "@@ -85,9 +85,13 @@ use syntax::{ast, ptr};\n pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n     debug!(\"rewrite_chain {:?}\", shape);\n     let chain = Chain::from_ast(expr, context);\n+    // If this is just an expression with some `?`s, then format it trivially and\n+    // return early.\n     if chain.children.is_empty() {\n-        return rewrite_try(&chain.parent.expr, chain.parent.tries, context, shape);\n+        let rewrite = chain.parent.expr.rewrite(context, shape.sub_width(chain.parent.tries)?)?;\n+        return Some(format!(\"{}{}\", rewrite, \"?\".repeat(chain.parent.tries)));\n     }\n+\n     match context.config.indent_style() {\n         IndentStyle::Block => rewrite_chain_block(chain, context, shape),\n         IndentStyle::Visual => rewrite_chain_visual(chain, context, shape),\n@@ -103,70 +107,69 @@ struct ChainItem {\n struct Chain {\n     parent: ChainItem,\n     // TODO do we need to clone the exprs?\n-    children: Vec<ast::Expr>,\n-    span: Span,\n+    children: Vec<ChainItem>,\n }\n \n impl Chain {\n     fn from_ast(expr: &ast::Expr, context: &RewriteContext) -> Chain {\n-        let (parent, mut subexpr_list) = make_subexpr_list(expr, context);\n-        let tries = subexpr_list.iter().rev().take_while(|e| is_try(e)).count();\n-        let new_len = subexpr_list.len() - tries;\n-        subexpr_list.truncate(new_len);\n+        let mut subexpr_list = make_subexpr_list(expr, context);\n+\n+        // Un-parse the expression tree into ChainItems\n+        let mut children = vec![];\n+        let mut sub_tries = 0;\n+        loop {\n+            if subexpr_list.is_empty() {\n+                break;\n+            }\n+\n+            let subexpr = subexpr_list.pop().unwrap();\n+            match subexpr.node {\n+                ast::ExprKind::Try(_) => sub_tries += 1,\n+                _ => {\n+                    children.push(ChainItem {\n+                        expr: subexpr.clone(),\n+                        tries: sub_tries,\n+                    });\n+                    sub_tries = 0;\n+                }\n+            }\n+        }\n+\n         Chain {\n-            parent: ChainItem {\n-                expr: parent,\n-                tries,\n-            },\n-            children: subexpr_list,\n-            span: expr.span,\n+            parent: children.pop().unwrap(),\n+            children: children.into_iter().rev().collect(),\n         }\n     }\n }\n \n-fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    let (parent, subexpr_list) = (&chain.parent.expr, &chain.children);\n-\n-    let suffix_try_num = subexpr_list.iter().take_while(|e| is_try(e)).count();\n+fn rewrite_chain_block(mut chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    let last = chain.children.pop().unwrap();\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n-    let parent_shape = shape;\n-    let parent_rewrite = parent\n-        .rewrite(context, parent_shape)\n+    let parent_rewrite = chain.parent.expr\n+        .rewrite(context, shape)\n         .map(|parent_rw| parent_rw + &\"?\".repeat(chain.parent.tries))?;\n     let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n     let is_small_parent = shape.offset + parent_rewrite.len() <= context.config.tab_spaces();\n-    let parent_is_block = is_block_expr(context, &parent, &parent_rewrite);\n+    let parent_is_block = is_block_expr(context, &chain.parent.expr, &parent_rewrite);\n \n     // Decide how to layout the rest of the chain. `extend` is true if we can\n     // put the first non-parent item on the same line as the parent.\n-    let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n-        let shape = if parent_is_block {\n-            shape\n-        } else {\n-            chain_indent(context, shape.add_offset(parent_rewrite.len()))\n-        };\n-        (shape, is_small_parent)\n-    } else if parent_is_block {\n-        (parent_shape, true)\n+    let other_child_shape = if parent_is_block {\n+        shape\n     } else {\n-        (\n-            chain_indent(context, shape.add_offset(parent_rewrite.len())),\n-            false,\n-        )\n-    };\n+        shape.block_indent(context.config.tab_spaces())\n+    }.with_max_width(context.config);\n \n-    let other_child_shape = nested_shape.with_max_width(context.config);\n+    let extend = if !parent_rewrite_contains_newline && is_continuable(&chain.parent.expr) {\n+        is_small_parent\n+    } else {\n+        parent_is_block\n+    };\n \n     let first_child_shape = if extend {\n         let offset = trimmed_last_line_width(&parent_rewrite) + chain.parent.tries;\n-        if parent_is_block {\n-            parent_shape.offset_left(offset)?\n-        } else {\n-            parent_shape\n-                .block_indent(context.config.tab_spaces())\n-                .offset_left(offset)?\n-        }\n+        other_child_shape.offset_left(offset)?\n     } else {\n         other_child_shape\n     };\n@@ -175,21 +178,18 @@ fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) ->\n         first_child_shape, other_child_shape\n     );\n \n-    let last_subexpr = &subexpr_list[suffix_try_num];\n-    let subexpr_list = &subexpr_list[suffix_try_num..];\n-\n-    let mut rewrites: Vec<String> = Vec::with_capacity(subexpr_list.len());\n-    let mut is_block_like = Vec::with_capacity(subexpr_list.len());\n+    let mut rewrites: Vec<String> = Vec::with_capacity(chain.children.len());\n+    let mut is_block_like = Vec::with_capacity(chain.children.len());\n     is_block_like.push(true);\n-    for (i, expr) in subexpr_list.iter().skip(1).rev().enumerate() {\n+    for (i, item) in chain.children.iter().enumerate() {\n         let shape = if *is_block_like.last().unwrap() && !(extend && i == 0) {\n             first_child_shape\n         } else {\n             other_child_shape\n         };\n-        let rewrite = rewrite_chain_subexpr(expr, chain.span, context, shape)?;\n-        is_block_like.push(is_block_expr(context, expr, &rewrite));\n-        rewrites.push(rewrite);\n+        let rewrite = rewrite_chain_subexpr(&item.expr, context, shape)?;\n+        is_block_like.push(is_block_expr(context, &item.expr, &rewrite));\n+        rewrites.push(format!(\"{}{}\", rewrite, \"?\".repeat(item.tries)));\n     }\n \n     // Total of all items excluding the last.\n@@ -202,7 +202,7 @@ fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) ->\n         last_line_width(&parent_rewrite)\n     } else {\n         rewrites.iter().fold(0, |a, b| a + b.len()) + parent_rewrite.len()\n-    } + suffix_try_num;\n+    } + last.tries;\n     let one_line_budget = if rewrites.is_empty() {\n         shape.width\n     } else {\n@@ -215,7 +215,7 @@ fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) ->\n         first_child_shape\n     } else {\n         other_child_shape\n-    }.sub_width(shape.rhs_overhead(context.config) + suffix_try_num)?;\n+    }.sub_width(shape.rhs_overhead(context.config) + last.tries)?;\n \n     // Rewrite the last child. The last child of a chain requires special treatment. We need to\n     // know whether 'overflowing' the last child make a better formatting:\n@@ -252,12 +252,11 @@ fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) ->\n \n     // `rewrite_last` rewrites the last child on its own line. We use a closure here instead of\n     // directly calling `rewrite_chain_subexpr()` to avoid exponential blowup.\n-    let rewrite_last = || rewrite_chain_subexpr(last_subexpr, chain.span, context, last_shape);\n     let (last_subexpr_str, fits_single_line) = if all_in_one_line || extend_last_subexpr {\n         // First we try to 'overflow' the last child and see if it looks better than using\n         // vertical layout.\n-        parent_shape.offset_left(almost_total).map(|shape| {\n-            if let Some(rw) = rewrite_chain_subexpr(last_subexpr, chain.span, context, shape) {\n+        shape.offset_left(almost_total).map(|shape| {\n+            if let Some(rw) = rewrite_chain_subexpr(&last.expr, context, shape) {\n                 // We allow overflowing here only if both of the following conditions match:\n                 // 1. The entire chain fits in a single line except the last child.\n                 // 2. `last_child_str.lines().count() >= 5`.\n@@ -269,7 +268,7 @@ fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) ->\n                     // We could not know whether overflowing is better than using vertical layout,\n                     // just by looking at the overflowed rewrite. Now we rewrite the last child\n                     // on its own line, and compare two rewrites to choose which is better.\n-                    match rewrite_last() {\n+                    match rewrite_chain_subexpr(&last.expr, context, last_shape) {\n                         Some(ref new_rw) if !fits_single_line => (Some(new_rw.clone()), false),\n                         Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n                             (Some(rw), fits_single_line)\n@@ -279,11 +278,11 @@ fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) ->\n                     }\n                 }\n             } else {\n-                (rewrite_last(), false)\n+                (rewrite_chain_subexpr(&last.expr, context, last_shape), false)\n             }\n         })?\n     } else {\n-        (rewrite_last(), false)\n+        (rewrite_chain_subexpr(&last.expr, context, last_shape), false)\n     };\n     rewrites.push(last_subexpr_str?);\n     // We should never look at this, since we only look at the block-ness of the\n@@ -298,7 +297,7 @@ fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) ->\n         if *context.force_one_line_chain.borrow() {\n             return None;\n         }\n-        nested_shape.indent.to_string_with_newline(context.config)\n+        other_child_shape.indent.to_string_with_newline(context.config)\n     };\n \n     let first_connector = if is_small_parent\n@@ -335,33 +334,30 @@ fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) ->\n             join_rewrites(&rewrites, &is_block_like[1..], &connector),\n         )\n     };\n-    let result = format!(\"{}{}\", result, \"?\".repeat(suffix_try_num));\n+    let result = format!(\"{}{}\", result, \"?\".repeat(last.tries));\n     Some(result)\n }\n \n-fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    let parent = &chain.parent.expr;\n-\n-    let suffix_try_num = chain.children.iter().take_while(|e| is_try(e)).count();\n+fn rewrite_chain_visual(mut chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    let last = chain.children.pop().unwrap();\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n-    let parent_shape = if is_block_expr(context, &parent, \"\\n\") {\n+    let parent_shape = if is_block_expr(context, &chain.parent.expr, \"\\n\") {\n         shape.visual_indent(0)\n     } else {\n         shape\n     };\n-    let parent_rewrite = parent\n+    let parent_rewrite = chain.parent.expr\n         .rewrite(context, parent_shape)\n         .map(|parent_rw| parent_rw + &\"?\".repeat(chain.parent.tries))?;\n     let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n     let is_small_parent = shape.offset + parent_rewrite.len() <= context.config.tab_spaces();\n \n-    let nested_shape = shape.visual_indent(0);\n-    let other_child_shape = nested_shape.with_max_width(context.config);\n+    let other_child_shape = shape.visual_indent(0).with_max_width(context.config);\n \n     // Decide how to layout the rest of the chain. `extend` is true if we can\n     // put the first non-parent item on the same line as the parent.\n-    let extend = !parent_rewrite_contains_newline && is_continuable(&parent);\n+    let extend = !parent_rewrite_contains_newline && is_continuable(&chain.parent.expr);\n \n     let first_child_shape = if extend {\n         let overhead = last_line_width(&parent_rewrite);\n@@ -374,18 +370,15 @@ fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) ->\n         first_child_shape, other_child_shape\n     );\n \n-    let last_subexpr = &chain.children[suffix_try_num];\n-    let subexpr_list = &chain.children[suffix_try_num..];\n-\n-    let mut rewrites: Vec<String> = Vec::with_capacity(subexpr_list.len());\n-    for (i, expr) in subexpr_list.iter().skip(1).rev().enumerate() {\n+    let mut rewrites: Vec<String> = Vec::with_capacity(chain.children.len());\n+    for (i, item) in chain.children.iter().enumerate() {\n         let shape = if i == 0 {\n             first_child_shape\n         } else {\n             other_child_shape\n         };\n-        let rewrite = rewrite_chain_subexpr(expr, chain.span, context, shape)?;\n-        rewrites.push(rewrite);\n+        let rewrite = rewrite_chain_subexpr(&item.expr, context, shape)?;\n+        rewrites.push(format!(\"{}{}\", rewrite, \"?\".repeat(item.tries)));\n     }\n \n     // Total of all items excluding the last.\n@@ -398,7 +391,7 @@ fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) ->\n         last_line_width(&parent_rewrite)\n     } else {\n         rewrites.iter().fold(0, |a, b| a + b.len()) + parent_rewrite.len()\n-    } + suffix_try_num;\n+    } + last.tries;\n     let one_line_budget = if rewrites.is_empty() {\n         shape.width\n     } else {\n@@ -408,7 +401,7 @@ fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) ->\n         && rewrites.iter().all(|s| !s.contains('\\n'))\n         && almost_total < one_line_budget;\n     let last_shape =\n-        other_child_shape.sub_width(shape.rhs_overhead(context.config) + suffix_try_num)?;\n+        other_child_shape.sub_width(shape.rhs_overhead(context.config) + last.tries)?;\n \n     // Rewrite the last child. The last child of a chain requires special treatment. We need to\n     // know whether 'overflowing' the last child make a better formatting:\n@@ -443,14 +436,11 @@ fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) ->\n     // })\n     // ```\n \n-    // `rewrite_last` rewrites the last child on its own line. We use a closure here instead of\n-    // directly calling `rewrite_chain_subexpr()` to avoid exponential blowup.\n-    let rewrite_last = || rewrite_chain_subexpr(last_subexpr, chain.span, context, last_shape);\n     let (last_subexpr_str, fits_single_line) = if all_in_one_line || extend_last_subexpr {\n         // First we try to 'overflow' the last child and see if it looks better than using\n         // vertical layout.\n         parent_shape.offset_left(almost_total).map(|shape| {\n-            if let Some(rw) = rewrite_chain_subexpr(last_subexpr, chain.span, context, shape) {\n+            if let Some(rw) = rewrite_chain_subexpr(&last.expr, context, shape) {\n                 // We allow overflowing here only if both of the following conditions match:\n                 // 1. The entire chain fits in a single line except the last child.\n                 // 2. `last_child_str.lines().count() >= 5`.\n@@ -462,7 +452,7 @@ fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) ->\n                     // We could not know whether overflowing is better than using vertical layout,\n                     // just by looking at the overflowed rewrite. Now we rewrite the last child\n                     // on its own line, and compare two rewrites to choose which is better.\n-                    match rewrite_last() {\n+                    match rewrite_chain_subexpr(&last.expr, context, last_shape) {\n                         Some(ref new_rw) if !fits_single_line => (Some(new_rw.clone()), false),\n                         Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n                             (Some(rw), fits_single_line)\n@@ -472,11 +462,11 @@ fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) ->\n                     }\n                 }\n             } else {\n-                (rewrite_last(), false)\n+                (rewrite_chain_subexpr(&last.expr, context, last_shape), false)\n             }\n         })?\n     } else {\n-        (rewrite_last(), false)\n+        (rewrite_chain_subexpr(&last.expr, context, last_shape), false)\n     };\n     rewrites.push(last_subexpr_str?);\n \n@@ -488,7 +478,7 @@ fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) ->\n         if *context.force_one_line_chain.borrow() {\n             return None;\n         }\n-        nested_shape.indent.to_string_with_newline(context.config)\n+        other_child_shape.indent.to_string_with_newline(context.config)\n     };\n \n     let result = if is_small_parent && rewrites.len() > 1 {\n@@ -505,20 +495,10 @@ fn rewrite_chain_visual(chain: Chain, context: &RewriteContext, shape: Shape) ->\n             join_rewrites_vis(&rewrites, &connector),\n         )\n     };\n-    let result = format!(\"{}{}\", result, \"?\".repeat(suffix_try_num));\n+    let result = format!(\"{}{}\", result, \"?\".repeat(last.tries));\n     wrap_str(result, context.config.max_width(), shape)\n }\n \n-fn rewrite_try(\n-    expr: &ast::Expr,\n-    try_count: usize,\n-    context: &RewriteContext,\n-    shape: Shape,\n-) -> Option<String> {\n-    let sub_expr = expr.rewrite(context, shape.sub_width(try_count)?)?;\n-    Some(format!(\"{}{}\", sub_expr, \"?\".repeat(try_count)))\n-}\n-\n fn join_rewrites(rewrites: &[String], is_block_like: &[bool], connector: &str) -> String {\n     let mut rewrite_iter = rewrites.iter();\n     let mut result = rewrite_iter.next().unwrap().clone();\n@@ -576,23 +556,16 @@ fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool\n     }\n }\n \n-fn chain_indent(context: &RewriteContext, shape: Shape) -> Shape {\n-    shape\n-        .block_indent(context.config.tab_spaces())\n-        .with_max_width(context.config)\n-}\n-\n-// Returns the root of the chain and a Vec of the prefixes of the rest of the chain.\n-// E.g., for input `a.b.c` we return (`a`, [`a.b.c`, `a.b`])\n-fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> (ast::Expr, Vec<ast::Expr>) {\n+// Returns a Vec of the prefixes of the chain.\n+// E.g., for input `a.b.c` we return [`a.b.c`, `a.b`, 'a']\n+fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> Vec<ast::Expr> {\n     let mut subexpr_list = vec![expr.clone()];\n \n     while let Some(subexpr) = pop_expr_chain(subexpr_list.last().unwrap(), context) {\n         subexpr_list.push(subexpr.clone());\n     }\n \n-    let parent = subexpr_list.pop().unwrap();\n-    (parent, subexpr_list)\n+    subexpr_list\n }\n \n // Returns the expression's subexpression, if it exists. When the subexpr\n@@ -626,7 +599,6 @@ fn convert_try(expr: &ast::Expr, context: &RewriteContext) -> ast::Expr {\n // `.c`.\n fn rewrite_chain_subexpr(\n     expr: &ast::Expr,\n-    span: Span,\n     context: &RewriteContext,\n     shape: Shape,\n ) -> Option<String> {\n@@ -647,7 +619,7 @@ fn rewrite_chain_subexpr(\n                 },\n                 _ => &[],\n             };\n-            rewrite_method_call(segment.ident, types, expressions, span, context, shape)\n+            rewrite_method_call(segment.ident, types, expressions, expr.span, context, shape)\n         }\n         ast::ExprKind::Field(ref nested, ref field) => {\n             let space = if is_tup_field_access(expr) && is_tup_field_access(nested) {\n@@ -679,13 +651,6 @@ fn is_continuable(expr: &ast::Expr) -> bool {\n     }\n }\n \n-fn is_try(expr: &ast::Expr) -> bool {\n-    match expr.node {\n-        ast::ExprKind::Try(..) => true,\n-        _ => false,\n-    }\n-}\n-\n fn rewrite_method_call(\n     method_name: ast::Ident,\n     types: &[ast::GenericArg],"}]}