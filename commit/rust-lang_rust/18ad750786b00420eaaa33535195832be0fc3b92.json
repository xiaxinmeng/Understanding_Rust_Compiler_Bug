{"sha": "18ad750786b00420eaaa33535195832be0fc3b92", "node_id": "C_kwDOAAsO6NoAKDE4YWQ3NTA3ODZiMDA0MjBlYWFhMzM1MzUxOTU4MzJiZTBmYzNiOTI", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-03-23T13:30:04Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-03-23T13:34:27Z"}, "message": "fix: properly import all types of macros with #[macro_use] again", "tree": {"sha": "b2f999c010f912bc9c1133163d0e15b7dce69d8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2f999c010f912bc9c1133163d0e15b7dce69d8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18ad750786b00420eaaa33535195832be0fc3b92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18ad750786b00420eaaa33535195832be0fc3b92", "html_url": "https://github.com/rust-lang/rust/commit/18ad750786b00420eaaa33535195832be0fc3b92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18ad750786b00420eaaa33535195832be0fc3b92/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b3daef537b211b7cad5e2d382706979ead22258", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3daef537b211b7cad5e2d382706979ead22258", "html_url": "https://github.com/rust-lang/rust/commit/0b3daef537b211b7cad5e2d382706979ead22258"}], "stats": {"total": 79, "additions": 59, "deletions": 20}, "files": [{"sha": "bdb8c7552d3b34cc60356374e80df99681ac024b", "filename": "crates/hir/src/symbols.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/18ad750786b00420eaaa33535195832be0fc3b92/crates%2Fhir%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ad750786b00420eaaa33535195832be0fc3b92/crates%2Fhir%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsymbols.rs?ref=18ad750786b00420eaaa33535195832be0fc3b92", "patch": "@@ -3,7 +3,7 @@\n use base_db::FileRange;\n use hir_def::{\n     item_tree::ItemTreeNode, src::HasSource, AdtId, AssocItemId, AssocItemLoc, DefWithBodyId,\n-    ImplId, ItemContainerId, Lookup, MacroId, ModuleDefId, ModuleId, TraitId,\n+    HasModule, ImplId, ItemContainerId, Lookup, MacroId, ModuleDefId, ModuleId, TraitId,\n };\n use hir_expand::{HirFileId, InFile};\n use hir_ty::db::HirDatabase;\n@@ -176,9 +176,12 @@ impl<'a> SymbolCollector<'a> {\n         }\n \n         for (_, id) in scope.legacy_macros() {\n-            let loc = id.lookup(self.db.upcast());\n-            if loc.container == module_id {\n-                self.push_decl(id, FileSymbolKind::Macro);\n+            if id.module(self.db.upcast()) == module_id {\n+                match id {\n+                    MacroId::Macro2Id(id) => self.push_decl(id, FileSymbolKind::Macro),\n+                    MacroId::MacroRulesId(id) => self.push_decl(id, FileSymbolKind::Macro),\n+                    MacroId::ProcMacroId(id) => self.push_decl(id, FileSymbolKind::Macro),\n+                }\n             }\n         }\n     }"}, {"sha": "b1337ecc242190ed955da958f3ebd0cb72931e15", "filename": "crates/hir_def/src/child_by_source.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18ad750786b00420eaaa33535195832be0fc3b92/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ad750786b00420eaaa33535195832be0fc3b92/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs?ref=18ad750786b00420eaaa33535195832be0fc3b92", "patch": "@@ -103,9 +103,11 @@ impl ChildBySource for ItemScope {\n             },\n         );\n         self.legacy_macros().for_each(|(_, id)| {\n-            let loc = id.lookup(db);\n-            if loc.id.file_id() == file_id {\n-                res[keys::MACRO_RULES].insert(loc.source(db).value, id);\n+            if let MacroId::MacroRulesId(id) = id {\n+                let loc = id.lookup(db);\n+                if loc.id.file_id() == file_id {\n+                    res[keys::MACRO_RULES].insert(loc.source(db).value, id);\n+                }\n             }\n         });\n         self.derive_macro_invocs().filter(|(id, _)| id.file_id == file_id).for_each("}, {"sha": "ddccbbfef9c5c5e35a3a403322940b73265109c9", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/18ad750786b00420eaaa33535195832be0fc3b92/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ad750786b00420eaaa33535195832be0fc3b92/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=18ad750786b00420eaaa33535195832be0fc3b92", "patch": "@@ -14,8 +14,7 @@ use syntax::ast;\n \n use crate::{\n     attr::AttrId, db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType,\n-    ConstId, HasModule, ImplId, LocalModuleId, MacroId, MacroRulesId, ModuleDefId, ModuleId,\n-    TraitId,\n+    ConstId, HasModule, ImplId, LocalModuleId, MacroId, ModuleDefId, ModuleId, TraitId,\n };\n \n #[derive(Copy, Clone)]\n@@ -62,7 +61,7 @@ pub struct ItemScope {\n     /// Module scoped macros will be inserted into `items` instead of here.\n     // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n     // be all resolved to the last one defined if shadowing happens.\n-    legacy_macros: FxHashMap<Name, MacroRulesId>,\n+    legacy_macros: FxHashMap<Name, MacroId>,\n     /// The derive macro invocations in this scope.\n     attr_macros: FxHashMap<AstId<ast::Item>, MacroCallId>,\n     /// The derive macro invocations in this scope, keyed by the owner item over the actual derive attributes\n@@ -135,7 +134,7 @@ impl ItemScope {\n     }\n \n     /// Iterate over all legacy textual scoped macros visible at the end of the module\n-    pub fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroRulesId)> + 'a {\n+    pub fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroId)> + 'a {\n         self.legacy_macros.iter().map(|(name, def)| (name, *def))\n     }\n \n@@ -181,7 +180,7 @@ impl ItemScope {\n         self.declarations.push(def)\n     }\n \n-    pub(crate) fn get_legacy_macro(&self, name: &Name) -> Option<MacroRulesId> {\n+    pub(crate) fn get_legacy_macro(&self, name: &Name) -> Option<MacroId> {\n         self.legacy_macros.get(name).copied()\n     }\n \n@@ -193,7 +192,7 @@ impl ItemScope {\n         self.unnamed_consts.push(konst);\n     }\n \n-    pub(crate) fn define_legacy_macro(&mut self, name: Name, mac: MacroRulesId) {\n+    pub(crate) fn define_legacy_macro(&mut self, name: Name, mac: MacroId) {\n         self.legacy_macros.insert(name, mac);\n     }\n \n@@ -323,7 +322,7 @@ impl ItemScope {\n         )\n     }\n \n-    pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, MacroRulesId> {\n+    pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, MacroId> {\n         self.legacy_macros.clone()\n     }\n "}, {"sha": "4660ccf50075e3f27df18e8cc97251683e574dcf", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18ad750786b00420eaaa33535195832be0fc3b92/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ad750786b00420eaaa33535195832be0fc3b92/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=18ad750786b00420eaaa33535195832be0fc3b92", "patch": "@@ -610,7 +610,7 @@ impl DefCollector<'_> {\n         export: bool,\n     ) {\n         // Textual scoping\n-        self.define_legacy_macro(module_id, name.clone(), macro_);\n+        self.define_legacy_macro(module_id, name.clone(), macro_.into());\n \n         // Module scoping\n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n@@ -634,7 +634,7 @@ impl DefCollector<'_> {\n     /// the definition of current module.\n     /// And also, `macro_use` on a module will import all legacy macros visible inside to\n     /// current legacy scope, with possible shadowing.\n-    fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, mac: MacroRulesId) {\n+    fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, mac: MacroId) {\n         // Always shadowing\n         self.def_map.modules[module_id].scope.define_legacy_macro(name, mac);\n     }\n@@ -706,10 +706,8 @@ impl DefCollector<'_> {\n     fn import_all_macros_exported(&mut self, current_module_id: LocalModuleId, krate: CrateId) {\n         let def_map = self.db.crate_def_map(krate);\n         for (name, def) in def_map[def_map.root].scope.macros() {\n-            if let MacroId::MacroRulesId(def) = def {\n-                // `macro_use` only bring things into legacy scope.\n-                self.define_legacy_macro(current_module_id, name.clone(), def);\n-            }\n+            // `#[macro_use]` brings macros into legacy scope. Yes, even non-`macro_rules!` macros.\n+            self.define_legacy_macro(current_module_id, name.clone(), def);\n         }\n     }\n "}, {"sha": "411840ccbcc8f8b4f3fa115d19b4f7a44b3e47c7", "filename": "crates/hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/18ad750786b00420eaaa33535195832be0fc3b92/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ad750786b00420eaaa33535195832be0fc3b92/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=18ad750786b00420eaaa33535195832be0fc3b92", "patch": "@@ -1143,3 +1143,40 @@ struct A;\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn macro_use_imports_all_macro_types() {\n+    let def_map = compute_crate_def_map(\n+        r#\"\n+//- /main.rs crate:main deps:lib\n+#[macro_use]\n+extern crate lib;\n+\n+//- /lib.rs crate:lib deps:proc\n+pub use proc::*;\n+\n+#[macro_export]\n+macro_rules! legacy { () => () }\n+\n+pub macro macro20 {}\n+\n+//- /proc.rs crate:proc\n+#![crate_type=\"proc-macro\"]\n+\n+struct TokenStream;\n+\n+#[proc_macro_attribute]\n+fn proc_attr(a: TokenStream, b: TokenStream) -> TokenStream { a }\n+    \"#,\n+    );\n+\n+    let root = &def_map[def_map.root()].scope;\n+    let actual = root.legacy_macros().map(|(name, _)| format!(\"{name}\\n\")).collect::<String>();\n+\n+    expect![[r#\"\n+        macro20\n+        legacy\n+        proc_attr\n+    \"#]]\n+    .assert_eq(&actual);\n+}"}]}