{"sha": "0e014be35971f19001bb58c1e9a904e9f596a052", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMDE0YmUzNTk3MWYxOTAwMWJiNThjMWU5YTkwNGU5ZjU5NmEwNTI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-24T18:49:17Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-26T07:56:54Z"}, "message": "move UnsafeCell-in-const check from interning to validation", "tree": {"sha": "ede5d7df02ec97522dee515802941519ad678a5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ede5d7df02ec97522dee515802941519ad678a5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e014be35971f19001bb58c1e9a904e9f596a052", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e014be35971f19001bb58c1e9a904e9f596a052", "html_url": "https://github.com/rust-lang/rust/commit/0e014be35971f19001bb58c1e9a904e9f596a052", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e014be35971f19001bb58c1e9a904e9f596a052/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0a23e613d7b932ee7e29489afce15580fa5cb66", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0a23e613d7b932ee7e29489afce15580fa5cb66", "html_url": "https://github.com/rust-lang/rust/commit/d0a23e613d7b932ee7e29489afce15580fa5cb66"}], "stats": {"total": 127, "additions": 74, "deletions": 53}, "files": [{"sha": "49cb284be8e62aac5b3cf61814f9669fc03e7feb", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e014be35971f19001bb58c1e9a904e9f596a052/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e014be35971f19001bb58c1e9a904e9f596a052/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=0e014be35971f19001bb58c1e9a904e9f596a052", "patch": "@@ -1,8 +1,8 @@\n use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr, MemoryExtra};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n-    intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, GlobalId, Immediate,\n-    InternKind, InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RefTracking, Scalar,\n+    intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n+    Immediate, InternKind, InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RefTracking, Scalar,\n     ScalarMaybeUninit, StackPopCleanup,\n };\n \n@@ -376,13 +376,14 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                 // https://github.com/rust-lang/rust/issues/67465 is made\n                 if cid.promoted.is_none() {\n                     let mut ref_tracking = RefTracking::new(mplace);\n+                    let mut inner = false;\n                     while let Some((mplace, path)) = ref_tracking.todo.pop() {\n-                        ecx.const_validate_operand(\n-                            mplace.into(),\n-                            path,\n-                            &mut ref_tracking,\n-                            /*may_ref_to_static*/ ecx.memory.extra.can_access_statics,\n-                        )?;\n+                        let mode = match tcx.static_mutability(cid.instance.def_id()) {\n+                            Some(_) => CtfeValidationMode::Regular, // a `static`\n+                            None => CtfeValidationMode::Const { inner },\n+                        };\n+                        ecx.const_validate_operand(mplace.into(), path, &mut ref_tracking, mode)?;\n+                        inner = true;\n                     }\n                 }\n             };"}, {"sha": "53ce4deeff8267cc044db7eceba5355db6eb1549", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e014be35971f19001bb58c1e9a904e9f596a052/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e014be35971f19001bb58c1e9a904e9f596a052/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=0e014be35971f19001bb58c1e9a904e9f596a052", "patch": "@@ -129,9 +129,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n         // See const_eval::machine::MemoryExtra::can_access_statics for why\n         // immutability is so important.\n \n-        // There are no sensible checks we can do here; grep for `mutable_memory_in_const` to\n-        // find the checks we are doing elsewhere to avoid even getting here for memory\n-        // that \"wants\" to be mutable.\n+        // Validation will ensure that there is no `UnsafeCell` on an immutable allocation.\n         alloc.mutability = Mutability::Not;\n     };\n     // link the alloc id to the actual allocation\n@@ -176,7 +174,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                     // they caused.  It also helps us to find cases where const-checking\n                     // failed to prevent an `UnsafeCell` (but as `ignore_interior_mut_in_const`\n                     // shows that part is not airtight).\n-                    mutable_memory_in_const(self.ecx.tcx, \"`UnsafeCell`\");\n+                    //mutable_memory_in_const(self.ecx.tcx, \"`UnsafeCell`\");\n                 }\n                 // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n                 // References we encounter inside here are interned as pointing to mutable"}, {"sha": "072fe21fbcca47f99b3c38395d397e0312cdbf52", "filename": "compiler/rustc_mir/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e014be35971f19001bb58c1e9a904e9f596a052/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e014be35971f19001bb58c1e9a904e9f596a052/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs?ref=0e014be35971f19001bb58c1e9a904e9f596a052", "patch": "@@ -24,7 +24,7 @@ pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackP\n pub use self::memory::{AllocCheck, FnVal, Memory, MemoryKind};\n pub use self::operand::{ImmTy, Immediate, OpTy, Operand};\n pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n-pub use self::validity::RefTracking;\n+pub use self::validity::{RefTracking, CtfeValidationMode};\n pub use self::visitor::{MutValueVisitor, ValueVisitor};\n \n crate use self::intrinsics::eval_nullary_intrinsic;"}, {"sha": "3026b6c6c4931bb9f2a7c9721117bc16fcccb7bf", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 45, "deletions": 29, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0e014be35971f19001bb58c1e9a904e9f596a052/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e014be35971f19001bb58c1e9a904e9f596a052/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=0e014be35971f19001bb58c1e9a904e9f596a052", "patch": "@@ -113,6 +113,15 @@ pub enum PathElem {\n     DynDowncast,\n }\n \n+/// Extra things to check for during validation of CTFE results.\n+pub enum CtfeValidationMode {\n+    /// Regular validation, nothing special happening.\n+    Regular,\n+    /// Validation of a `const`. `inner` says if this is an inner, indirect allocation (as opposed\n+    /// to the top-level const allocation).\n+    Const { inner: bool },\n+}\n+\n /// State for tracking recursive validation of references\n pub struct RefTracking<T, PATH = ()> {\n     pub seen: FxHashSet<T>,\n@@ -202,9 +211,9 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n     /// this stack discipline.\n     path: Vec<PathElem>,\n-    ref_tracking_for_consts:\n-        Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n-    may_ref_to_static: bool,\n+    ref_tracking: Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n+    /// `None` indicates this is not validating for CTFE (but for runtime).\n+    ctfe_mode: Option<CtfeValidationMode>,\n     ecx: &'rt InterpCx<'mir, 'tcx, M>,\n }\n \n@@ -418,27 +427,15 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 { \"a dangling {} (use-after-free)\", kind },\n         );\n         // Recursive checking\n-        if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n+        if let Some(ref mut ref_tracking) = self.ref_tracking {\n             if let Some(ptr) = ptr {\n                 // not a ZST\n                 // Skip validation entirely for some external statics\n                 let alloc_kind = self.ecx.tcx.get_global_alloc(ptr.alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n                     assert!(!self.ecx.tcx.is_thread_local_static(did));\n                     assert!(self.ecx.tcx.is_static(did));\n-                    if self.may_ref_to_static {\n-                        // We skip checking other statics. These statics must be sound by\n-                        // themselves, and the only way to get broken statics here is by using\n-                        // unsafe code.\n-                        // The reasons we don't check other statics is twofold. For one, in all\n-                        // sound cases, the static was already validated on its own, and second, we\n-                        // trigger cycle errors if we try to compute the value of the other static\n-                        // and that static refers back to us.\n-                        // We might miss const-invalid data,\n-                        // but things are still sound otherwise (in particular re: consts\n-                        // referring to statics).\n-                        return Ok(());\n-                    } else {\n+                    if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { .. })) {\n                         // See const_eval::machine::MemoryExtra::can_access_statics for why\n                         // this check is so important.\n                         // This check is reachable when the const just referenced the static,\n@@ -447,6 +444,17 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                             { \"a {} pointing to a static variable\", kind }\n                         );\n                     }\n+                    // We skip checking other statics. These statics must be sound by\n+                    // themselves, and the only way to get broken statics here is by using\n+                    // unsafe code.\n+                    // The reasons we don't check other statics is twofold. For one, in all\n+                    // sound cases, the static was already validated on its own, and second, we\n+                    // trigger cycle errors if we try to compute the value of the other static\n+                    // and that static refers back to us.\n+                    // We might miss const-invalid data,\n+                    // but things are still sound otherwise (in particular re: consts\n+                    // referring to statics).\n+                    return Ok(());\n                 }\n             }\n             // Proceed recursively even for ZST, no reason to skip them!\n@@ -504,7 +512,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let value = self.ecx.read_scalar(value)?;\n                 // NOTE: Keep this in sync with the array optimization for int/float\n                 // types below!\n-                if self.ref_tracking_for_consts.is_some() {\n+                if self.ctfe_mode.is_some() {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n                     let is_bits = value.check_init().map_or(false, |v| v.is_bits());\n                     if !is_bits {\n@@ -723,6 +731,15 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // Sanity check: `builtin_deref` does not know any pointers that are not primitive.\n         assert!(op.layout.ty.builtin_deref(true).is_none());\n \n+        // Special check preventing `UnsafeCell` in constants\n+        if let Some(def) = op.layout.ty.ty_adt_def() {\n+            if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true }))\n+                && Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type()\n+            {\n+                throw_validation_failure!(self.path, { \"`UnsafeCell` in a `const`\" });\n+            }\n+        }\n+\n         // Recursively walk the value at its type.\n         self.walk_value(op)?;\n \n@@ -814,7 +831,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     self.ecx,\n                     ptr,\n                     size,\n-                    /*allow_uninit_and_ptr*/ self.ref_tracking_for_consts.is_none(),\n+                    /*allow_uninit_and_ptr*/ self.ctfe_mode.is_none(),\n                 ) {\n                     // In the happy case, we needn't check anything else.\n                     Ok(()) => {}\n@@ -865,16 +882,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n-        ref_tracking_for_consts: Option<\n-            &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n-        >,\n-        may_ref_to_static: bool,\n+        ref_tracking: Option<&mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n+        ctfe_mode: Option<CtfeValidationMode>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"validate_operand_internal: {:?}, {:?}\", *op, op.layout.ty);\n \n         // Construct a visitor\n-        let mut visitor =\n-            ValidityVisitor { path, ref_tracking_for_consts, may_ref_to_static, ecx: self };\n+        let mut visitor = ValidityVisitor { path, ref_tracking, ctfe_mode, ecx: self };\n \n         // Try to cast to ptr *once* instead of all the time.\n         let op = self.force_op_ptr(op).unwrap_or(op);\n@@ -902,23 +916,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// `ref_tracking` is used to record references that we encounter so that they\n     /// can be checked recursively by an outside driving loop.\n     ///\n-    /// `may_ref_to_static` controls whether references are allowed to point to statics.\n+    /// `constant` controls whether this must satisfy the rules for constants:\n+    /// - no pointers to statics.\n+    /// - no `UnsafeCell` or non-ZST `&mut`.\n     #[inline(always)]\n     pub fn const_validate_operand(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n         ref_tracking: &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n-        may_ref_to_static: bool,\n+        ctfe_mode: CtfeValidationMode,\n     ) -> InterpResult<'tcx> {\n-        self.validate_operand_internal(op, path, Some(ref_tracking), may_ref_to_static)\n+        self.validate_operand_internal(op, path, Some(ref_tracking), Some(ctfe_mode))\n     }\n \n     /// This function checks the data at `op` to be runtime-valid.\n     /// `op` is assumed to cover valid memory if it is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     #[inline(always)]\n     pub fn validate_operand(&self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n-        self.validate_operand_internal(op, vec![], None, false)\n+        self.validate_operand_internal(op, vec![], None, None)\n     }\n }"}, {"sha": "7e5a13a01a7b2b2dcad34d270245659cb0dd728e", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0e014be35971f19001bb58c1e9a904e9f596a052/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e014be35971f19001bb58c1e9a904e9f596a052/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=0e014be35971f19001bb58c1e9a904e9f596a052", "patch": "@@ -9,7 +9,6 @@ use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::mir::interpret::{InterpResult, Scalar};\n use rustc_middle::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n@@ -28,9 +27,10 @@ use rustc_trait_selection::traits;\n \n use crate::const_eval::ConstEvalErr;\n use crate::interpret::{\n-    self, compile_time_machine, truncate, AllocId, Allocation, ConstValue, Frame, ImmTy, Immediate,\n-    InterpCx, LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand,\n-    PlaceTy, Pointer, ScalarMaybeUninit, StackPopCleanup,\n+    self, compile_time_machine, truncate, AllocId, Allocation, ConstValue, CtfeValidationMode,\n+    Frame, ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, Memory,\n+    MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n+    StackPopCleanup,\n };\n use crate::transform::MirPass;\n \n@@ -805,8 +805,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             value,\n             vec![],\n             // FIXME: is ref tracking too expensive?\n+            // FIXME: what is the point of ref tracking if we do not even check the tracked refs?\n             &mut interpret::RefTracking::empty(),\n-            /*may_ref_to_static*/ true,\n+            CtfeValidationMode::Regular,\n         ) {\n             trace!(\"validation error, attempt failed: {:?}\", e);\n             return;"}, {"sha": "e9f6f9140e778af0b7d582514d644846fb8e487c", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e014be35971f19001bb58c1e9a904e9f596a052/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e014be35971f19001bb58c1e9a904e9f596a052/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs?ref=0e014be35971f19001bb58c1e9a904e9f596a052", "patch": "@@ -13,7 +13,7 @@ unsafe impl Sync for Meh {}\n \n // the following will never be ok! no interior mut behind consts, because\n // all allocs interned here will be marked immutable.\n-const MUH: Meh = Meh { //~ ERROR: mutable memory (`UnsafeCell`) is not allowed in constant\n+const MUH: Meh = Meh { //~ ERROR: it is undefined behavior to use this value\n     x: &UnsafeCell::new(42),\n };\n \n@@ -24,7 +24,7 @@ unsafe impl Sync for Synced {}\n \n // Make sure we also catch this behind a type-erased `dyn Trait` reference.\n const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n-//~^ ERROR: mutable memory (`UnsafeCell`) is not allowed in constant\n+//~^ ERROR: it is undefined behavior to use this value\n \n // Make sure we also catch mutable references.\n const BLUNT: &mut i32 = &mut 42;"}, {"sha": "b5b34642ed19674378f965e641f169beccb5530d", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0e014be35971f19001bb58c1e9a904e9f596a052/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e014be35971f19001bb58c1e9a904e9f596a052/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr?ref=0e014be35971f19001bb58c1e9a904e9f596a052", "patch": "@@ -1,16 +1,20 @@\n-error: mutable memory (`UnsafeCell`) is not allowed in constant\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/mutable_references_err.rs:16:1\n    |\n LL | / const MUH: Meh = Meh {\n LL | |     x: &UnsafeCell::new(42),\n LL | | };\n-   | |__^\n+   | |__^ type validation failed: encountered `UnsafeCell` in a `const` at .x.<deref>\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n-error: mutable memory (`UnsafeCell`) is not allowed in constant\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/mutable_references_err.rs:26:1\n    |\n LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered `UnsafeCell` in a `const` at .<deref>.<dyn-downcast>.x\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error: mutable memory (`&mut`) is not allowed in constant\n   --> $DIR/mutable_references_err.rs:30:1\n@@ -38,3 +42,4 @@ LL | const BLUNT: &mut i32 = &mut 42;\n \n error: aborting due to 3 previous errors; 1 warning emitted\n \n+For more information about this error, try `rustc --explain E0080`."}]}