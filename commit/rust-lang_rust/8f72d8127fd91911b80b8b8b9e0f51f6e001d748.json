{"sha": "8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNzJkODEyN2ZkOTE5MTFiODBiOGI4YjllMGY1MWY2ZTAwMWQ3NDg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-29T03:00:23Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:58Z"}, "message": "rustc: Generalize a minimum set of functions over 'tcx != 'gcx.", "tree": {"sha": "df1fa78fdf8cd41a6cc3e6ca8674b4a46fcc3010", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df1fa78fdf8cd41a6cc3e6ca8674b4a46fcc3010"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "html_url": "https://github.com/rust-lang/rust/commit/8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0b2b3c441460a918b9cb9e829b35fdd5b95bdd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0b2b3c441460a918b9cb9e829b35fdd5b95bdd6", "html_url": "https://github.com/rust-lang/rust/commit/f0b2b3c441460a918b9cb9e829b35fdd5b95bdd6"}], "stats": {"total": 2162, "additions": 1144, "deletions": 1018}, "files": [{"sha": "96b14a6c321cd2a5d99fbc309416033f9927c932", "filename": "src/librustc/infer/bivariate.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fbivariate.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -36,24 +36,24 @@ pub struct Bivariate<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fields: CombineFields<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> Bivariate<'a, 'tcx, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'tcx, 'tcx>) -> Bivariate<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Bivariate<'a, 'gcx, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Bivariate<'a, 'gcx, 'tcx> {\n         Bivariate { fields: fields }\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Bivariate<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Bivariate\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n-                                               variance: ty::Variance,\n-                                               a: &T,\n-                                               b: &T)\n-                                               -> RelateResult<'tcx, T>\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             variance: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n     {\n         match variance {\n             // If we have Foo<A> and Foo is invariant w/r/t A,\n@@ -107,7 +107,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx, 'tcx> {\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'a,'tcx>\n+        where T: Relate<'tcx>\n     {\n         let a1 = self.tcx().erase_late_bound_regions(a);\n         let b1 = self.tcx().erase_late_bound_regions(b);"}, {"sha": "3ee034cb09e7b5ef654ff59a6566f8af2babc4c4", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -60,13 +60,13 @@ pub struct CombineFields<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub obligations: PredicateObligations<'tcx>,\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n pub fn super_combine_tys<R>(&self,\n                             relation: &mut R,\n                             a: Ty<'tcx>,\n                             b: Ty<'tcx>)\n                             -> RelateResult<'tcx, Ty<'tcx>>\n-    where R: TypeRelation<'a,'tcx>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>\n {\n     let a_is_expected = relation.a_is_expected();\n \n@@ -150,35 +150,35 @@ fn unify_float_variable(&self,\n }\n }\n \n-impl<'a, 'tcx> CombineFields<'a, 'tcx, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn switch_expected(&self) -> CombineFields<'a, 'tcx, 'tcx> {\n+    pub fn switch_expected(&self) -> CombineFields<'a, 'gcx, 'tcx> {\n         CombineFields {\n             a_is_expected: !self.a_is_expected,\n             ..(*self).clone()\n         }\n     }\n \n-    pub fn equate(&self) -> Equate<'a, 'tcx, 'tcx> {\n+    pub fn equate(&self) -> Equate<'a, 'gcx, 'tcx> {\n         Equate::new(self.clone())\n     }\n \n-    pub fn bivariate(&self) -> Bivariate<'a, 'tcx, 'tcx> {\n+    pub fn bivariate(&self) -> Bivariate<'a, 'gcx, 'tcx> {\n         Bivariate::new(self.clone())\n     }\n \n-    pub fn sub(&self) -> Sub<'a, 'tcx, 'tcx> {\n+    pub fn sub(&self) -> Sub<'a, 'gcx, 'tcx> {\n         Sub::new(self.clone())\n     }\n \n-    pub fn lub(&self) -> Lub<'a, 'tcx, 'tcx> {\n+    pub fn lub(&self) -> Lub<'a, 'gcx, 'tcx> {\n         Lub::new(self.clone())\n     }\n \n-    pub fn glb(&self) -> Glb<'a, 'tcx, 'tcx> {\n+    pub fn glb(&self) -> Glb<'a, 'gcx, 'tcx> {\n         Glb::new(self.clone())\n     }\n \n@@ -299,8 +299,8 @@ struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     cycle_detected: bool,\n }\n \n-impl<'cx, 'tcx> ty::fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "408f22cf15c77dfa46afb74826ca2e16b8672678", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use super::combine::CombineFields;\n-use super::higher_ranked::HigherRankedRelations;\n use super::{Subtype};\n use super::type_variable::{EqTo};\n \n@@ -23,8 +22,8 @@ pub struct Equate<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fields: CombineFields<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> Equate<'a, 'tcx, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'tcx, 'tcx>) -> Equate<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Equate<'a, 'gcx, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Equate<'a, 'gcx, 'tcx> {\n         Equate { fields: fields }\n     }\n \n@@ -33,18 +32,18 @@ impl<'a, 'tcx> Equate<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Equate<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Equate\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n-                                               _: ty::Variance,\n-                                               a: &T,\n-                                               b: &T)\n-                                               -> RelateResult<'tcx, T>\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             _: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n     {\n         self.relate(a, b)\n     }\n@@ -92,7 +91,7 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx, 'tcx> {\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'a, 'tcx>\n+        where T: Relate<'tcx>\n     {\n         self.fields.higher_ranked_sub(a, b)?;\n         self.fields.higher_ranked_sub(b, a)"}, {"sha": "3900fab2d930a3e6e71483fe7e7c391988e10287", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 31, "deletions": 105, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -95,7 +95,7 @@ use syntax::codemap::{self, Pos, Span};\n use syntax::parse::token;\n use syntax::ptr::P;\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n                                    err: &mut DiagnosticBuilder,\n                                    prefix: &str,\n@@ -112,9 +112,9 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             }\n         }\n \n-        fn explain_span<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  heading: &str, span: Span)\n-                                  -> (String, Option<Span>) {\n+        fn explain_span<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                        heading: &str, span: Span)\n+                                        -> (String, Option<Span>) {\n             let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo);\n             (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n              Some(span))\n@@ -228,83 +228,9 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     }\n }\n \n-pub trait ErrorReporting<'tcx> {\n-    fn report_region_errors(&self,\n-                            errors: &Vec<RegionResolutionError<'tcx>>);\n-\n-    fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n-                      -> Option<Vec<RegionResolutionError<'tcx>>>;\n-\n-    fn report_type_error(&self,\n-                         trace: TypeTrace<'tcx>,\n-                         terr: &TypeError<'tcx>)\n-                         -> DiagnosticBuilder<'tcx>;\n-\n-    fn check_and_note_conflicting_crates(&self,\n-                                         err: &mut DiagnosticBuilder,\n-                                         terr: &TypeError<'tcx>,\n-                                         sp: Span);\n-\n-    fn report_and_explain_type_error(&self,\n-                                     trace: TypeTrace<'tcx>,\n-                                     terr: &TypeError<'tcx>)\n-                                     -> DiagnosticBuilder<'tcx>;\n-\n-    fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<(String, String)>;\n-\n-    fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + TypeFoldable<'tcx>>(\n-        &self,\n-        exp_found: &ty::error::ExpectedFound<T>)\n-        -> Option<(String, String)>;\n-\n-    fn report_concrete_failure(&self,\n-                               origin: SubregionOrigin<'tcx>,\n-                               sub: Region,\n-                               sup: Region)\n-                                -> DiagnosticBuilder<'tcx>;\n-\n-    fn report_generic_bound_failure(&self,\n-                                    origin: SubregionOrigin<'tcx>,\n-                                    kind: GenericKind<'tcx>,\n-                                    sub: Region);\n-\n-    fn report_sub_sup_conflict(&self,\n-                               var_origin: RegionVariableOrigin,\n-                               sub_origin: SubregionOrigin<'tcx>,\n-                               sub_region: Region,\n-                               sup_origin: SubregionOrigin<'tcx>,\n-                               sup_region: Region);\n-\n-    fn report_processed_errors(&self,\n-                               origins: &[ProcessedErrorOrigin<'tcx>],\n-                               same_regions: &[SameRegions]);\n-\n-    fn give_suggestion(&self, err: &mut DiagnosticBuilder, same_regions: &[SameRegions]);\n-}\n-\n-trait ErrorReportingHelpers<'tcx> {\n-    fn report_inference_failure(&self,\n-                                var_origin: RegionVariableOrigin)\n-                                -> DiagnosticBuilder<'tcx>;\n-\n-    fn note_region_origin(&self,\n-                          err: &mut DiagnosticBuilder,\n-                          origin: &SubregionOrigin<'tcx>);\n-\n-    fn give_expl_lifetime_param(&self,\n-                                err: &mut DiagnosticBuilder,\n-                                decl: &hir::FnDecl,\n-                                unsafety: hir::Unsafety,\n-                                constness: hir::Constness,\n-                                name: ast::Name,\n-                                opt_explicit_self: Option<&hir::ExplicitSelf_>,\n-                                generics: &hir::Generics,\n-                                span: Span);\n-}\n-\n-impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx, 'tcx> {\n-    fn report_region_errors(&self,\n-                            errors: &Vec<RegionResolutionError<'tcx>>) {\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    pub fn report_region_errors(&self,\n+                                errors: &Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n@@ -475,10 +401,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx, 'tcx> {\n             }\n         }\n \n-        fn free_regions_from_same_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                               sub: Region,\n-                                               sup: Region)\n-                                               -> Option<FreeRegionsFromSameFn> {\n+        fn free_regions_from_same_fn<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                     sub: Region,\n+                                                     sup: Region)\n+                                                     -> Option<FreeRegionsFromSameFn> {\n             debug!(\"free_regions_from_same_fn(sub={:?}, sup={:?})\", sub, sup);\n             let (scope_id, fr1, fr2) = match (sub, sup) {\n                 (ReFree(fr1), ReFree(fr2)) => {\n@@ -620,10 +546,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    fn report_and_explain_type_error(&self,\n-                                     trace: TypeTrace<'tcx>,\n-                                     terr: &TypeError<'tcx>)\n-                                     -> DiagnosticBuilder<'tcx> {\n+    pub fn report_and_explain_type_error(&self,\n+                                         trace: TypeTrace<'tcx>,\n+                                         terr: &TypeError<'tcx>)\n+                                         -> DiagnosticBuilder<'tcx> {\n         let span = trace.origin.span();\n         let mut err = self.report_type_error(trace, terr);\n         self.tcx.note_and_explain_type_err(&mut err, terr, span);\n@@ -1109,8 +1035,8 @@ struct RebuildPathInfo<'a> {\n     region_names: &'a HashSet<ast::Name>\n }\n \n-struct Rebuilder<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct Rebuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     fn_decl: &'a hir::FnDecl,\n     expl_self_opt: Option<&'a hir::ExplicitSelf_>,\n     generics: &'a hir::Generics,\n@@ -1125,14 +1051,14 @@ enum FreshOrKept {\n     Kept\n }\n \n-impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            fn_decl: &'a hir::FnDecl,\n            expl_self_opt: Option<&'a hir::ExplicitSelf_>,\n            generics: &'a hir::Generics,\n            same_regions: &'a [SameRegions],\n            life_giver: &'a LifeGiver)\n-           -> Rebuilder<'a, 'tcx> {\n+           -> Rebuilder<'a, 'gcx, 'tcx> {\n         Rebuilder {\n             tcx: tcx,\n             fn_decl: fn_decl,\n@@ -1642,7 +1568,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn give_expl_lifetime_param(&self,\n                                 err: &mut DiagnosticBuilder,\n                                 decl: &hir::FnDecl,\n@@ -1905,34 +1831,34 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx, 'tcx> {\n }\n \n pub trait Resolvable<'tcx> {\n-    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx, 'tcx>) -> Self;\n+    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Self;\n }\n \n impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n-    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n }\n \n impl<'tcx> Resolvable<'tcx> for ty::TraitRef<'tcx> {\n-    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n-                   -> ty::TraitRef<'tcx> {\n+    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                         -> ty::TraitRef<'tcx> {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n }\n \n impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n-    fn resolve<'a>(&self,\n-                   infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n-                   -> ty::PolyTraitRef<'tcx>\n+    fn resolve<'a, 'gcx>(&self,\n+                         infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                         -> ty::PolyTraitRef<'tcx>\n     {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n }\n \n-fn lifetimes_in_scope<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                scope_id: ast::NodeId)\n-                                -> Vec<hir::LifetimeDef> {\n+fn lifetimes_in_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                      scope_id: ast::NodeId)\n+                                      -> Vec<hir::LifetimeDef> {\n     let mut taken = Vec::new();\n     let parent = tcx.map.get_parent(scope_id);\n     let method_id_opt = match tcx.map.find(parent) {"}, {"sha": "5ded6dc73646ea04f5920446cdfb9385693d8b82", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -43,8 +43,9 @@ pub struct TypeFreshener<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     freshen_map: hash_map::HashMap<ty::InferTy, Ty<'tcx>>,\n }\n \n-impl<'a, 'tcx> TypeFreshener<'a, 'tcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx, 'tcx>) -> TypeFreshener<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n+               -> TypeFreshener<'a, 'gcx, 'tcx> {\n         TypeFreshener {\n             infcx: infcx,\n             freshen_count: 0,\n@@ -77,8 +78,8 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "b7085f0829f8a51239eb35364e5c0e3dce1db454", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use super::combine::CombineFields;\n-use super::higher_ranked::HigherRankedRelations;\n use super::InferCtxt;\n use super::lattice::{self, LatticeDir};\n use super::Subtype;\n@@ -23,8 +22,8 @@ pub struct Glb<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fields: CombineFields<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> Glb<'a, 'tcx, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'tcx, 'tcx>) -> Glb<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Glb<'a, 'gcx, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Glb<'a, 'gcx, 'tcx> {\n         Glb { fields: fields }\n     }\n \n@@ -33,18 +32,18 @@ impl<'a, 'tcx> Glb<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Glb<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Glb\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n-                                               variance: ty::Variance,\n-                                               a: &T,\n-                                               b: &T)\n-                                               -> RelateResult<'tcx, T>\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             variance: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n     {\n         match variance {\n             ty::Invariant => self.fields.equate().relate(a, b),\n@@ -70,14 +69,14 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx, 'tcx> {\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'a, 'tcx>\n+        where T: Relate<'tcx>\n     {\n         self.fields.higher_ranked_glb(a, b)\n     }\n }\n \n-impl<'a, 'tcx> LatticeDir<'a,'tcx> for Glb<'a, 'tcx, 'tcx> {\n-    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> LatticeDir<'a, 'gcx, 'tcx> for Glb<'a, 'gcx, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'gcx, 'tcx> {\n         self.fields.infcx\n     }\n "}, {"sha": "63d462b9f4fb9f0ef0cc3f0de9f9d216031fe742", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -20,21 +20,10 @@ use ty::relate::{Relate, RelateResult, TypeRelation};\n use syntax::codemap::Span;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n-pub trait HigherRankedRelations<'a,'tcx> {\n-    fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'a,'tcx>;\n-\n-    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'a,'tcx>;\n-\n-    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'a,'tcx>;\n-}\n-\n-impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a, 'tcx, 'tcx> {\n-    fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n-                            -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'a,'tcx>\n+impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n+    pub fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n+                                -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'tcx>\n     {\n         debug!(\"higher_ranked_sub(a={:?}, b={:?})\",\n                a, b);\n@@ -79,8 +68,9 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a, 'tcx, 'tcx> {\n         });\n     }\n \n-    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'a,'tcx>\n+    pub fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n+                                -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'tcx>\n     {\n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n@@ -119,14 +109,14 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a, 'tcx, 'tcx> {\n             Ok(ty::Binder(result1))\n         });\n \n-        fn generalize_region<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n-                                       span: Span,\n-                                       snapshot: &CombinedSnapshot,\n-                                       debruijn: ty::DebruijnIndex,\n-                                       new_vars: &[ty::RegionVid],\n-                                       a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                                       r0: ty::Region)\n-                                       -> ty::Region {\n+        fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             span: Span,\n+                                             snapshot: &CombinedSnapshot,\n+                                             debruijn: ty::DebruijnIndex,\n+                                             new_vars: &[ty::RegionVid],\n+                                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n+                                             r0: ty::Region)\n+                                             -> ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n@@ -168,8 +158,9 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'a,'tcx>\n+    pub fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>)\n+                                -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'tcx>\n     {\n         debug!(\"higher_ranked_glb({:?}, {:?})\",\n                a, b);\n@@ -214,15 +205,15 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a, 'tcx, 'tcx> {\n             Ok(ty::Binder(result1))\n         });\n \n-        fn generalize_region<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n-                                       span: Span,\n-                                       snapshot: &CombinedSnapshot,\n-                                       debruijn: ty::DebruijnIndex,\n-                                       new_vars: &[ty::RegionVid],\n-                                       a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                                       a_vars: &[ty::RegionVid],\n-                                       b_vars: &[ty::RegionVid],\n-                                       r0: ty::Region) -> ty::Region {\n+        fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             span: Span,\n+                                             snapshot: &CombinedSnapshot,\n+                                             debruijn: ty::DebruijnIndex,\n+                                             new_vars: &[ty::RegionVid],\n+                                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n+                                             a_vars: &[ty::RegionVid],\n+                                             b_vars: &[ty::RegionVid],\n+                                             r0: ty::Region) -> ty::Region {\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n                 return r0;\n@@ -306,9 +297,9 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a, 'tcx, 'tcx> {\n     }\n }\n \n-fn var_ids<'a, 'tcx>(fields: &CombineFields<'a, 'tcx, 'tcx>,\n-                      map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n-                     -> Vec<ty::RegionVid> {\n+fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n+                           map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n+                           -> Vec<ty::RegionVid> {\n     map.iter()\n        .map(|(_, r)| match *r {\n            ty::ReVar(r) => { r }\n@@ -329,10 +320,10 @@ fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n     }\n }\n \n-fn fold_regions_in<'a, 'tcx, T, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   unbound_value: &T,\n-                                   mut fldr: F)\n-                                   -> T\n+fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                         unbound_value: &T,\n+                                         mut fldr: F)\n+                                         -> T\n     where T: TypeFoldable<'tcx>,\n           F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n@@ -349,7 +340,7 @@ fn fold_regions_in<'a, 'tcx, T, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-impl<'a,'tcx> InferCtxt<'a,'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region> {\n         self.region_vars.tainted(&snapshot.region_vars_snapshot, r)\n     }"}, {"sha": "1a2bc4b5cf2e18b7690e2d942aec2a183260a06d", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -35,19 +35,19 @@ use ty::TyVar;\n use ty::{self, Ty};\n use ty::relate::{RelateResult, TypeRelation};\n \n-pub trait LatticeDir<'f,'tcx> : TypeRelation<'f,'tcx> {\n-    fn infcx(&self) -> &'f InferCtxt<'f, 'tcx, 'tcx>;\n+pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'f, 'gcx, 'tcx> {\n+    fn infcx(&self) -> &'f InferCtxt<'f, 'gcx, 'tcx>;\n \n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n     fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }\n \n-pub fn super_lattice_tys<'a,'tcx,L:LatticeDir<'a,'tcx>>(this: &mut L,\n-                                                        a: Ty<'tcx>,\n-                                                        b: Ty<'tcx>)\n-                                                        -> RelateResult<'tcx, Ty<'tcx>>\n-    where 'tcx: 'a\n+pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n+                                            a: Ty<'tcx>,\n+                                            b: Ty<'tcx>)\n+                                            -> RelateResult<'tcx, Ty<'tcx>>\n+    where L: LatticeDir<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     debug!(\"{}.lattice_tys({:?}, {:?})\",\n            this.tag(),"}, {"sha": "bd46f3a26a2def175852a5026a87d0e2ee8cf6f0", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use super::combine::CombineFields;\n-use super::higher_ranked::HigherRankedRelations;\n use super::InferCtxt;\n use super::lattice::{self, LatticeDir};\n use super::Subtype;\n@@ -23,8 +22,8 @@ pub struct Lub<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fields: CombineFields<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> Lub<'a, 'tcx, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'tcx, 'tcx>) -> Lub<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Lub<'a, 'gcx, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Lub<'a, 'gcx, 'tcx> {\n         Lub { fields: fields }\n     }\n \n@@ -33,18 +32,18 @@ impl<'a, 'tcx> Lub<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Lub<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Lub\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n-                                               variance: ty::Variance,\n-                                               a: &T,\n-                                               b: &T)\n-                                               -> RelateResult<'tcx, T>\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             variance: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n     {\n         match variance {\n             ty::Invariant => self.fields.equate().relate(a, b),\n@@ -70,14 +69,14 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx, 'tcx> {\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'a, 'tcx>\n+        where T: Relate<'tcx>\n     {\n         self.fields.higher_ranked_lub(a, b)\n     }\n }\n \n-impl<'a, 'tcx> LatticeDir<'a,'tcx> for Lub<'a, 'tcx, 'tcx> {\n-    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> LatticeDir<'a, 'gcx, 'tcx> for Lub<'a, 'gcx, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'gcx, 'tcx> {\n         self.fields.infcx\n     }\n "}, {"sha": "28bb99b30f96c2729969544af0b0d3dfa50a0991", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 60, "deletions": 37, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -45,7 +45,6 @@ use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n \n use self::combine::CombineFields;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n-use self::error_reporting::ErrorReporting;\n use self::unify_key::ToType;\n \n pub mod bivariate;\n@@ -94,6 +93,13 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     pub parameter_environment: ty::ParameterEnvironment<'gcx>,\n \n+    /// Caches the results of trait selection. This cache is used\n+    /// for things that have to do with the parameters in scope.\n+    pub selection_cache: traits::SelectionCache<'tcx>,\n+\n+    /// Caches the results of trait evaluation.\n+    pub evaluation_cache: traits::EvaluationCache<'tcx>,\n+\n     // the set of predicates on which errors have been reported, to\n     // avoid reporting the same error twice.\n     pub reported_trait_errors: RefCell<FnvHashSet<traits::TraitErrorKey<'tcx>>>,\n@@ -407,6 +413,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n             float_unification_table: RefCell::new(UnificationTable::new()),\n             region_vars: RegionVarBindings::new(tcx),\n             parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment()),\n+            selection_cache: traits::SelectionCache::new(),\n+            evaluation_cache: traits::EvaluationCache::new(),\n             reported_trait_errors: RefCell::new(FnvHashSet()),\n             normalize: false,\n             projection_mode: projection_mode,\n@@ -465,26 +473,32 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         }\n \n         InferCtxt::enter(self, None, None, ProjectionMode::Any, |infcx| {\n-            let mut selcx = traits::SelectionContext::new(&infcx);\n-            let cause = traits::ObligationCause::dummy();\n-            let traits::Normalized { value: result, obligations } =\n-                traits::normalize(&mut selcx, cause, &value);\n+            infcx.normalize_projections_in(&value)\n+        })\n+    }\n+}\n \n-            debug!(\"normalize_associated_type: result={:?} obligations={:?}\",\n-                   result, obligations);\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    fn normalize_projections_in<T>(&self, value: &T) -> T\n+        where T : TypeFoldable<'tcx>\n+    {\n+        let mut selcx = traits::SelectionContext::new(self);\n+        let cause = traits::ObligationCause::dummy();\n+        let traits::Normalized { value: result, obligations } =\n+            traits::normalize(&mut selcx, cause, value);\n \n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n+        debug!(\"normalize_projections_in: result={:?} obligations={:?}\",\n+                result, obligations);\n \n-            for obligation in obligations {\n-                fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-            }\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n \n-            infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n-        })\n+        for obligation in obligations {\n+            fulfill_cx.register_predicate_obligation(self, obligation);\n+        }\n+\n+        self.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n     }\n-}\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n pub fn drain_fulfillment_cx_or_panic<T>(&self,\n                                         span: Span,\n                                         fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n@@ -543,7 +557,7 @@ pub fn drain_fulfillment_cx<T>(&self,\n         }\n     }\n \n-    pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx, 'tcx> {\n+    pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'gcx, 'tcx> {\n         freshen::TypeFreshener::new(self)\n     }\n \n@@ -614,7 +628,7 @@ pub fn drain_fulfillment_cx<T>(&self,\n     }\n \n     fn combine_fields(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                      -> CombineFields<'a, 'tcx, 'tcx> {\n+                      -> CombineFields<'a, 'gcx, 'tcx> {\n         CombineFields {\n             infcx: self,\n             a_is_expected: a_is_expected,\n@@ -626,7 +640,7 @@ pub fn drain_fulfillment_cx<T>(&self,\n \n     pub fn equate<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n         -> InferResult<'tcx, T>\n-        where T: Relate<'a, 'tcx>\n+        where T: Relate<'tcx>\n     {\n         let mut equate = self.combine_fields(a_is_expected, trace).equate();\n         let result = equate.relate(a, b);\n@@ -635,7 +649,7 @@ pub fn drain_fulfillment_cx<T>(&self,\n \n     pub fn sub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n         -> InferResult<'tcx, T>\n-        where T: Relate<'a, 'tcx>\n+        where T: Relate<'tcx>\n     {\n         let mut sub = self.combine_fields(a_is_expected, trace).sub();\n         let result = sub.relate(a, b);\n@@ -644,7 +658,7 @@ pub fn drain_fulfillment_cx<T>(&self,\n \n     pub fn lub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n         -> InferResult<'tcx, T>\n-        where T: Relate<'a, 'tcx>\n+        where T: Relate<'tcx>\n     {\n         let mut lub = self.combine_fields(a_is_expected, trace).lub();\n         let result = lub.relate(a, b);\n@@ -653,7 +667,7 @@ pub fn drain_fulfillment_cx<T>(&self,\n \n     pub fn glb<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n         -> InferResult<'tcx, T>\n-        where T: Relate<'a, 'tcx>\n+        where T: Relate<'tcx>\n     {\n         let mut glb = self.combine_fields(a_is_expected, trace).glb();\n         let result = glb.relate(a, b);\n@@ -1412,8 +1426,8 @@ pub fn drain_fulfillment_cx<T>(&self,\n         self.region_vars.verify_generic_bound(origin, kind, a, bound);\n     }\n \n-    pub fn can_equate<'b,T>(&'b self, a: &T, b: &T) -> UnitResult<'tcx>\n-        where T: Relate<'b,'tcx> + fmt::Debug\n+    pub fn can_equate<T>(&self, a: &T, b: &T) -> UnitResult<'tcx>\n+        where T: Relate<'tcx> + fmt::Debug\n     {\n         debug!(\"can_equate({:?}, {:?})\", a, b);\n         self.probe(|_| {\n@@ -1438,21 +1452,24 @@ pub fn drain_fulfillment_cx<T>(&self,\n     pub fn tables_are_tcx_tables(&self) -> bool {\n         let tables: &RefCell<ty::Tables> = &self.tables;\n         let tcx_tables: &RefCell<ty::Tables> = &self.tcx.tables;\n-        tables as *const _ == tcx_tables as *const _\n+        tables as *const _ as usize == tcx_tables as *const _ as usize\n     }\n \n     pub fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n-        if ty.needs_infer() ||\n-            (ty.has_closure_types() && !self.tables_are_tcx_tables()) {\n-            // this can get called from typeck (by euv), and moves_by_default\n-            // rightly refuses to work with inference variables, but\n-            // moves_by_default has a cache, which we want to use in other\n-            // cases.\n-            !traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundCopy, span)\n-        } else {\n-            ty.moves_by_default(self.tcx, &self.parameter_environment, span)\n+        if let Some(ty) = self.tcx.lift_to_global(&ty) {\n+            // HACK(eddyb) Temporarily handle infer type in the global tcx.\n+            if !ty.needs_infer() &&\n+               !(ty.has_closure_types() && !self.tables_are_tcx_tables()) {\n+                return ty.moves_by_default(self.tcx.global_tcx(), self.param_env(), span);\n+            }\n         }\n+\n+        // this can get called from typeck (by euv), and moves_by_default\n+        // rightly refuses to work with inference variables, but\n+        // moves_by_default has a cache, which we want to use in other\n+        // cases.\n+        !traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundCopy, span)\n     }\n \n     pub fn node_method_ty(&self, method_call: ty::MethodCall)\n@@ -1495,7 +1512,7 @@ pub fn drain_fulfillment_cx<T>(&self,\n         self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n     }\n \n-    pub fn param_env(&self) -> &ty::ParameterEnvironment<'tcx> {\n+    pub fn param_env(&self) -> &ty::ParameterEnvironment<'gcx> {\n         &self.parameter_environment\n     }\n \n@@ -1526,14 +1543,20 @@ pub fn drain_fulfillment_cx<T>(&self,\n                                      substs);\n \n         if self.normalize {\n-            self.tcx.normalize_associated_type(&closure_ty)\n+            let closure_ty = self.tcx.erase_regions(&closure_ty);\n+\n+            if !closure_ty.has_projection_types() {\n+                return closure_ty;\n+            }\n+\n+            self.normalize_projections_in(&closure_ty)\n         } else {\n             closure_ty\n         }\n     }\n }\n \n-impl<'a, 'tcx> TypeTrace<'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n     pub fn span(&self) -> Span {\n         self.origin.span()\n     }\n@@ -1549,7 +1572,7 @@ impl<'a, 'tcx> TypeTrace<'tcx> {\n         }\n     }\n \n-    pub fn dummy(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> TypeTrace<'tcx> {\n+    pub fn dummy(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n             values: Types(ExpectedFound {"}, {"sha": "5f550b427e21aed275e47d59357bbfdb9de613d8", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -10,6 +10,7 @@\n \n use super::{InferCtxt, FixupError, FixupResult};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::fold::TypeFolder;\n \n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC TYPE RESOLVER\n@@ -23,14 +24,14 @@ pub struct OpportunisticTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> OpportunisticTypeResolver<'a, 'tcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx, 'tcx>) -> OpportunisticTypeResolver<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> OpportunisticTypeResolver<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n         OpportunisticTypeResolver { infcx: infcx }\n     }\n }\n \n-impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeResolver<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -51,14 +52,14 @@ pub struct OpportunisticTypeAndRegionResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> OpportunisticTypeAndRegionResolver<'a, 'tcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx, 'tcx>) -> Self {\n+impl<'a, 'gcx, 'tcx> OpportunisticTypeAndRegionResolver<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n         OpportunisticTypeAndRegionResolver { infcx: infcx }\n     }\n }\n \n-impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeAndRegionResolver<'a, 'tcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolver<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -85,8 +86,8 @@ impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeAndRegionResolver\n /// Full type resolution replaces all type and region variables with\n /// their concrete results. If any variable cannot be replaced (never unified, etc)\n /// then an `Err` result is returned.\n-pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n-                                  value: &T) -> FixupResult<T>\n+pub fn fully_resolve<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                        value: &T) -> FixupResult<T>\n     where T : TypeFoldable<'tcx>\n {\n     let mut full_resolver = FullTypeResolver { infcx: infcx, err: None };\n@@ -104,8 +105,8 @@ struct FullTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     err: Option<FixupError>,\n }\n \n-impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "680dd0d63556b6fe661f51fb2ff0a9d164b6dab1", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use super::combine::CombineFields;\n-use super::higher_ranked::HigherRankedRelations;\n use super::SubregionOrigin;\n use super::type_variable::{SubtypeOf, SupertypeOf};\n \n@@ -24,8 +23,8 @@ pub struct Sub<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fields: CombineFields<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> Sub<'a, 'tcx, 'tcx> {\n-    pub fn new(f: CombineFields<'a, 'tcx, 'tcx>) -> Sub<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Sub<'a, 'gcx, 'tcx> {\n+    pub fn new(f: CombineFields<'a, 'gcx, 'tcx>) -> Sub<'a, 'gcx, 'tcx> {\n         Sub { fields: f }\n     }\n \n@@ -34,9 +33,9 @@ impl<'a, 'tcx> Sub<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Sub<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Sub\" }\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.fields.infcx.tcx }\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.infcx.tcx }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n     fn with_cause<F,R>(&mut self, cause: Cause, f: F) -> R\n@@ -50,11 +49,11 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx, 'tcx> {\n         r\n     }\n \n-    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n-                                               variance: ty::Variance,\n-                                               a: &T,\n-                                               b: &T)\n-                                               -> RelateResult<'tcx, T>\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             variance: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n     {\n         match variance {\n             ty::Invariant => self.fields.equate().relate(a, b),\n@@ -115,7 +114,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx, 'tcx> {\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'a,'tcx>\n+        where T: Relate<'tcx>\n     {\n         self.fields.higher_ranked_sub(a, b)\n     }"}, {"sha": "d7e3a53ff25c92dca5f4129e81480fbfb3873287", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -12,8 +12,8 @@ use syntax::ast;\n use ty::{self, IntVarValue, Ty, TyCtxt};\n use rustc_data_structures::unify::{Combine, UnifyKey};\n \n-pub trait ToType<'tcx> {\n-    fn to_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx>;\n+pub trait ToType {\n+    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n }\n \n impl UnifyKey for ty::IntVid {\n@@ -50,8 +50,8 @@ impl UnifyKey for ty::RegionVid {\n     fn tag(_: Option<ty::RegionVid>) -> &'static str { \"RegionVid\" }\n }\n \n-impl<'tcx> ToType<'tcx> for IntVarValue {\n-    fn to_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+impl ToType for IntVarValue {\n+    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             ty::IntType(i) => tcx.mk_mach_int(i),\n             ty::UintType(i) => tcx.mk_mach_uint(i),\n@@ -68,8 +68,8 @@ impl UnifyKey for ty::FloatVid {\n     fn tag(_: Option<ty::FloatVid>) -> &'static str { \"FloatVid\" }\n }\n \n-impl<'tcx> ToType<'tcx> for ast::FloatTy {\n-    fn to_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+impl ToType for ast::FloatTy {\n+    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         tcx.mk_mach_float(*self)\n     }\n }"}, {"sha": "6d2adef6f8067ab4a5a534d327a67dd5f93cec61", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'tcx> LvalueTy<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for LvalueTy<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             LvalueTy::Ty { ty } => LvalueTy::Ty { ty: ty.fold_with(folder) },\n             LvalueTy::Downcast { adt_def, substs, variant_index } => {"}, {"sha": "74e6a97daf84cbe8f7a8970a16a9683d587e79a5", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -86,8 +86,8 @@ fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx, 'tcx>,\n     Some(selcx.infcx().resolve_type_vars_if_possible(&a_impl_header))\n }\n \n-pub fn trait_ref_is_knowable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       trait_ref: &ty::TraitRef<'tcx>) -> bool\n+pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                             trait_ref: &ty::TraitRef<'tcx>) -> bool\n {\n     debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n \n@@ -129,9 +129,9 @@ pub enum OrphanCheckErr<'tcx> {\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n /// 2. Some local type must appear in `Self`.\n-pub fn orphan_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              impl_def_id: DefId)\n-                              -> Result<(), OrphanCheckErr<'tcx>>\n+pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                    impl_def_id: DefId)\n+                                    -> Result<(), OrphanCheckErr<'tcx>>\n {\n     debug!(\"orphan_check({:?})\", impl_def_id);\n \n@@ -150,10 +150,10 @@ pub fn orphan_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     orphan_check_trait_ref(tcx, &trait_ref, InferIsLocal(false))\n }\n \n-fn orphan_check_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    trait_ref: &ty::TraitRef<'tcx>,\n-                                    infer_is_local: InferIsLocal)\n-                                    -> Result<(), OrphanCheckErr<'tcx>>\n+fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n+                                trait_ref: &ty::TraitRef<'tcx>,\n+                                infer_is_local: InferIsLocal)\n+                                -> Result<(), OrphanCheckErr<'tcx>>\n {\n     debug!(\"orphan_check_trait_ref(trait_ref={:?}, infer_is_local={})\",\n            trait_ref, infer_is_local.0);\n@@ -198,11 +198,8 @@ fn orphan_check_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     return Err(OrphanCheckErr::NoLocalInputType);\n }\n \n-fn uncovered_tys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           ty: Ty<'tcx>,\n-                           infer_is_local: InferIsLocal)\n-                           -> Vec<Ty<'tcx>>\n-{\n+fn uncovered_tys<'tcx>(tcx: TyCtxt, ty: Ty<'tcx>, infer_is_local: InferIsLocal)\n+                       -> Vec<Ty<'tcx>> {\n     if ty_is_local_constructor(tcx, ty, infer_is_local) {\n         vec![]\n     } else if fundamental_ty(tcx, ty) {\n@@ -214,24 +211,20 @@ fn uncovered_tys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn is_type_parameter<'tcx>(ty: Ty<'tcx>) -> bool {\n+fn is_type_parameter(ty: Ty) -> bool {\n     match ty.sty {\n         // FIXME(#20590) straighten story about projection types\n         ty::TyProjection(..) | ty::TyParam(..) => true,\n         _ => false,\n     }\n }\n \n-fn ty_is_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         ty: Ty<'tcx>,\n-                         infer_is_local: InferIsLocal) -> bool\n-{\n+fn ty_is_local(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal) -> bool {\n     ty_is_local_constructor(tcx, ty, infer_is_local) ||\n         fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, infer_is_local))\n }\n \n-fn fundamental_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool\n-{\n+fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     match ty.sty {\n         ty::TyBox(..) | ty::TyRef(..) =>\n             true,\n@@ -244,11 +237,7 @@ fn fundamental_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool\n     }\n }\n \n-fn ty_is_local_constructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     ty: Ty<'tcx>,\n-                                     infer_is_local: InferIsLocal)\n-                                     -> bool\n-{\n+fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)-> bool {\n     debug!(\"ty_is_local_constructor({:?})\", ty);\n \n     match ty.sty {"}, {"sha": "bc573d956a7e1ac71a395b67e57ff5992f78bc30", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -46,10 +46,10 @@ pub struct TraitErrorKey<'tcx> {\n     predicate: ty::Predicate<'tcx>\n }\n \n-impl<'tcx> TraitErrorKey<'tcx> {\n-    fn from_error<'a>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n-                      e: &FulfillmentError<'tcx>,\n-                      warning_node_id: Option<ast::NodeId>) -> Self {\n+impl<'a, 'gcx, 'tcx> TraitErrorKey<'tcx> {\n+    fn from_error(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                  e: &FulfillmentError<'tcx>,\n+                  warning_node_id: Option<ast::NodeId>) -> Self {\n         let predicate =\n             infcx.resolve_type_vars_if_possible(&e.obligation.predicate);\n         TraitErrorKey {\n@@ -60,7 +60,7 @@ impl<'tcx> TraitErrorKey<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n pub fn report_fulfillment_errors(&self, errors: &Vec<FulfillmentError<'tcx>>) {\n     for error in errors {\n         self.report_fulfillment_error(error, None);\n@@ -558,7 +558,7 @@ pub fn report_selection_error(&self,\n }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n pub fn recursive_type_with_infinite_size_error(self,\n                                                type_def_id: DefId)\n                                                -> DiagnosticBuilder<'tcx>\n@@ -646,7 +646,7 @@ pub fn report_object_safety_error(self,\n }\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n fn maybe_report_ambiguity(&self, obligation: &PredicateObligation<'tcx>) {\n     // Unable to successfully determine, probably means\n     // insufficient type information, but could mean\n@@ -737,14 +737,13 @@ fn maybe_report_ambiguity(&self, obligation: &PredicateObligation<'tcx>) {\n /// Returns whether the trait predicate may apply for *some* assignment\n /// to the type parameters.\n fn predicate_can_apply(&self, pred: ty::PolyTraitRef<'tcx>) -> bool {\n-    struct ParamToVarFolder<'a, 'tcx: 'a> {\n-        infcx: &'a InferCtxt<'a, 'tcx, 'tcx>,\n+    struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n         var_map: FnvHashMap<Ty<'tcx>, Ty<'tcx>>\n     }\n \n-    impl<'a, 'tcx> TypeFolder<'tcx> for ParamToVarFolder<'a, 'tcx>\n-    {\n-        fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.infcx.tcx }\n+    impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ParamToVarFolder<'a, 'gcx, 'tcx> {\n+        fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.infcx.tcx }\n \n         fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n             if let ty::TyParam(..) = ty.sty {"}, {"sha": "756318f8d9252a43e96ab5765116b52183c165d9", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 47, "deletions": 42, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -111,7 +111,7 @@ pub struct PendingPredicateObligation<'tcx> {\n     pub stalled_on: Vec<Ty<'tcx>>,\n }\n \n-impl<'a, 'tcx> FulfillmentContext<'tcx> {\n+impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     /// something concrete. If this fails, we'll unify `$0` with\n     /// `projection_ty` again.\n     pub fn normalize_projection_type(&mut self,\n-                                     infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n+                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                      projection_ty: ty::ProjectionTy<'tcx>,\n                                      cause: ObligationCause<'tcx>)\n                                      -> Ty<'tcx>\n@@ -155,7 +155,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn register_builtin_bound(&mut self,\n-                                  infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n+                                  infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                   ty: Ty<'tcx>,\n                                   builtin_bound: ty::BuiltinBound,\n                                   cause: ObligationCause<'tcx>)\n@@ -177,7 +177,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn register_predicate_obligation(&mut self,\n-                                         infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n+                                         infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                          obligation: PredicateObligation<'tcx>)\n     {\n         // this helps to reduce duplicate errors, as well as making\n@@ -200,7 +200,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn register_rfc1592_obligation(&mut self,\n-                                       _infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n+                                       _infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        obligation: PredicateObligation<'tcx>)\n     {\n         self.rfc1592_obligations.push(obligation);\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn select_rfc1592_obligations(&mut self,\n-                                      infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n+                                      infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n                                       -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         while !self.rfc1592_obligations.is_empty() {\n@@ -232,7 +232,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn select_all_or_error(&mut self,\n-                               infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n+                               infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n                                -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         self.select_where_possible(infcx)?;\n@@ -250,7 +250,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn select_where_possible(&mut self,\n-                                 infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n+                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n                                  -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx);\n@@ -261,7 +261,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n         self.predicates.pending_obligations()\n     }\n \n-    fn is_duplicate_or_add(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn is_duplicate_or_add(&mut self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                            predicate: &ty::Predicate<'tcx>)\n                            -> bool {\n         // For \"global\" predicates -- that is, predicates that don't\n@@ -289,7 +289,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n \n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n-    fn select(&mut self, selcx: &mut SelectionContext<'a, 'tcx, 'tcx>)\n+    fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n               -> Result<(),Vec<FulfillmentError<'tcx>>> {\n         debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n \n@@ -316,7 +316,8 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n             // these are obligations that were proven to be true.\n             for pending_obligation in outcome.completed {\n                 let predicate = &pending_obligation.obligation.predicate;\n-                selcx.tcx().fulfilled_predicates.borrow_mut().add_if_global(predicate);\n+                selcx.tcx().fulfilled_predicates.borrow_mut()\n+                           .add_if_global(selcx.tcx(), predicate);\n             }\n \n             errors.extend(\n@@ -341,14 +342,15 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n }\n \n /// Like `process_predicate1`, but wrap result into a pending predicate.\n-fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx, 'tcx>,\n-                              tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n-                              pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-                              backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n-                              region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-                              rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n-                              -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n-                                        FulfillmentErrorCode<'tcx>>\n+fn process_predicate<'a, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+    tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n+    pending_obligation: &mut PendingPredicateObligation<'tcx>,\n+    backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n+    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n+    rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n+    -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n+              FulfillmentErrorCode<'tcx>>\n {\n     match process_predicate1(selcx, pending_obligation, region_obligations,\n                              rfc1592_obligations) {\n@@ -362,8 +364,8 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx, 'tcx>,\n     }\n }\n \n-fn process_child_obligations<'a, 'tcx>(\n-    selcx: &mut SelectionContext<'a, 'tcx, 'tcx>,\n+fn process_child_obligations<'a, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n     tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n     pending_obligation: &PredicateObligation<'tcx>,\n     backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n@@ -464,7 +466,7 @@ struct AncestorSet<'b, 'tcx: 'b> {\n     backtrace: Backtrace<'b, PendingPredicateObligation<'tcx>>,\n }\n \n-impl<'a, 'b, 'tcx> AncestorSet<'b, 'tcx> {\n+impl<'a, 'b, 'gcx, 'tcx> AncestorSet<'b, 'tcx> {\n     fn new(backtrace: &Backtrace<'b, PendingPredicateObligation<'tcx>>) -> Self {\n         AncestorSet {\n             populated: false,\n@@ -478,7 +480,7 @@ impl<'a, 'b, 'tcx> AncestorSet<'b, 'tcx> {\n     /// type-resolved).  Returns `None` if not; otherwise, returns\n     /// `Some` with the index within the backtrace.\n     fn has(&mut self,\n-           infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n+           infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n            predicate: &ty::Predicate<'tcx>)\n            -> Option<usize> {\n         // the first time, we have to populate the cache\n@@ -514,8 +516,8 @@ impl<'a, 'b, 'tcx> AncestorSet<'b, 'tcx> {\n }\n \n /// Return the set of type variables contained in a trait ref\n-fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx, 'tcx>,\n-                                 t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n+fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+                                       t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n {\n     t.skip_binder() // ok b/c this check doesn't care about regions\n      .input_types()\n@@ -531,12 +533,13 @@ fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx, 'tcx>,\n /// - `Ok(Some(v))` if the predicate is true, presuming that `v` are also true\n /// - `Ok(None)` if we don't have enough info to be sure\n /// - `Err` if the predicate does not hold\n-fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx, 'tcx>,\n-                               pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-                               rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n-                               -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n-                                         FulfillmentErrorCode<'tcx>>\n+fn process_predicate1<'a, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+    pending_obligation: &mut PendingPredicateObligation<'tcx>,\n+    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n+    rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n+    -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n+              FulfillmentErrorCode<'tcx>>\n {\n     // if we were stalled on some unresolved variables, first check\n     // whether any of them have been resolved; if not, don't bother\n@@ -722,9 +725,9 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx, 'tcx>,\n /// - it also appears in the backtrace at some position `X`; and,\n /// - all the predicates at positions `X..` between `X` an the top are\n ///   also defaulted traits.\n-fn coinductive_match<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx, 'tcx>,\n-                               cycle: &[PredicateObligation<'tcx>])\n-                               -> bool\n+fn coinductive_match<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+                                     cycle: &[PredicateObligation<'tcx>])\n+                                     -> bool\n {\n     let len = cycle.len();\n \n@@ -740,9 +743,9 @@ fn coinductive_match<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx, 'tcx>,\n         })\n }\n \n-fn coinductive_obligation<'a, 'tcx>(selcx: &SelectionContext<'a, 'tcx, 'tcx>,\n-                                    obligation: &PredicateObligation<'tcx>)\n-                                    -> bool {\n+fn coinductive_obligation<'a, 'gcx, 'tcx>(selcx: &SelectionContext<'a, 'gcx, 'tcx>,\n+                                          obligation: &PredicateObligation<'tcx>)\n+                                          -> bool {\n     match obligation.predicate {\n         ty::Predicate::Trait(ref data) => {\n             selcx.tcx().trait_has_default_impl(data.def_id())\n@@ -790,8 +793,8 @@ impl<'tcx> LocalFulfilledPredicates<'tcx> {\n     }\n }\n \n-impl<'tcx> GlobalFulfilledPredicates<'tcx> {\n-    pub fn new(dep_graph: DepGraph) -> GlobalFulfilledPredicates<'tcx> {\n+impl<'a, 'gcx, 'tcx> GlobalFulfilledPredicates<'gcx> {\n+    pub fn new(dep_graph: DepGraph) -> GlobalFulfilledPredicates<'gcx> {\n         GlobalFulfilledPredicates {\n             set: FnvHashSet(),\n             dep_graph: dep_graph,\n@@ -822,15 +825,17 @@ impl<'tcx> GlobalFulfilledPredicates<'tcx> {\n         }\n     }\n \n-    fn add_if_global(&mut self, key: &ty::Predicate<'tcx>) {\n+    fn add_if_global(&mut self, tcx: TyCtxt<'a, 'gcx, 'tcx>, key: &ty::Predicate<'tcx>) {\n         if let ty::Predicate::Trait(ref data) = *key {\n             // We only add things to the global predicate registry\n             // after the current task has proved them, and hence\n             // already has the required read edges, so we don't need\n             // to add any more edges here.\n             if data.is_global() {\n-                if self.set.insert(data.clone()) {\n-                    debug!(\"add_if_global: global predicate `{:?}` added\", data);\n+                if let Some(data) = tcx.lift_to_global(data) {\n+                    if self.set.insert(data.clone()) {\n+                        debug!(\"add_if_global: global predicate `{:?}` added\", data);\n+                    }\n                 }\n             }\n         }"}, {"sha": "f9b5c0b139c2b443b13c3b216e1d83ff715295af", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -316,11 +316,11 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n /// `bound` or is not known to meet bound (note that this is\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n-pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx, 'tcx>,\n-                                                 ty: Ty<'tcx>,\n-                                                 bound: ty::BuiltinBound,\n-                                                 span: Span)\n-                                                 -> bool\n+pub fn type_known_to_meet_builtin_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                                        ty: Ty<'tcx>,\n+                                                        bound: ty::BuiltinBound,\n+                                                        span: Span)\n+                                                        -> bool\n {\n     debug!(\"type_known_to_meet_builtin_bound(ty={:?}, bound={:?})\",\n            ty,"}, {"sha": "8fffe3fa666724f2625acf24afa24b81fac81a21", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -53,7 +53,7 @@ pub enum MethodViolationCode {\n     Generic,\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n pub fn is_object_safe(self, trait_def_id: DefId) -> bool {\n     // Because we query yes/no results frequently, we keep a cache:\n     let def = self.lookup_trait_def(trait_def_id);\n@@ -173,8 +173,8 @@ fn trait_has_sized_self(self, trait_def_id: DefId) -> bool {\n }\n \n fn generics_require_sized_self(self,\n-                               generics: &ty::Generics<'tcx>,\n-                               predicates: &ty::GenericPredicates<'tcx>)\n+                               generics: &ty::Generics<'gcx>,\n+                               predicates: &ty::GenericPredicates<'gcx>)\n                                -> bool\n {\n     let sized_def_id = match self.lang_items.sized_trait() {\n@@ -210,7 +210,7 @@ fn generics_require_sized_self(self,\n /// Returns `Some(_)` if this method makes the containing trait not object safe.\n fn object_safety_violation_for_method(self,\n                                       trait_def_id: DefId,\n-                                      method: &ty::Method<'tcx>)\n+                                      method: &ty::Method<'gcx>)\n                                       -> Option<MethodViolationCode>\n {\n     // Any method that has a `Self : Sized` requisite is otherwise"}, {"sha": "d057b2da52a6bdbe493a9b66c11cc036bfa98b26", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 64, "deletions": 59, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -171,8 +171,8 @@ struct ProjectionTyCandidateSet<'tcx> {\n ///     for<...> <T as Trait>::U == V\n ///\n /// If successful, this may result in additional obligations.\n-pub fn poly_project_and_unify_type<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n+pub fn poly_project_and_unify_type<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &PolyProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n@@ -204,8 +204,8 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n ///     <T as Trait>::U == V\n ///\n /// If successful, this may result in additional obligations.\n-fn project_and_unify_type<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n+fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n@@ -240,8 +240,10 @@ fn project_and_unify_type<'cx,'tcx>(\n     }\n }\n \n-fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n-                                                    obligation: &ProjectionObligation<'tcx>) {\n+fn consider_unification_despite_ambiguity<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+    obligation: &ProjectionObligation<'tcx>)\n+{\n     debug!(\"consider_unification_despite_ambiguity(obligation={:?})\",\n            obligation);\n \n@@ -295,21 +297,23 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n /// them with a fully resolved type where possible. The return value\n /// combines the normalized result and any additional obligations that\n /// were incurred as result.\n-pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx, 'tcx>,\n-                               cause: ObligationCause<'tcx>,\n-                               value: &T)\n-                               -> Normalized<'tcx, T>\n+pub fn normalize<'a, 'b, 'gcx, 'tcx, T>(selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+                                        cause: ObligationCause<'tcx>,\n+                                        value: &T)\n+                                        -> Normalized<'tcx, T>\n     where T : TypeFoldable<'tcx>\n {\n     normalize_with_depth(selcx, cause, 0, value)\n }\n \n /// As `normalize`, but with a custom depth.\n-pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx, 'tcx>,\n-                                          cause: ObligationCause<'tcx>,\n-                                          depth: usize,\n-                                          value: &T)\n-                                          -> Normalized<'tcx, T>\n+pub fn normalize_with_depth<'a, 'b, 'gcx, 'tcx, T>(\n+    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    value: &T)\n+    -> Normalized<'tcx, T>\n+\n     where T : TypeFoldable<'tcx>\n {\n     let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n@@ -321,18 +325,18 @@ pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tc\n     }\n }\n \n-struct AssociatedTypeNormalizer<'a,'b:'a,'tcx:'b> {\n-    selcx: &'a mut SelectionContext<'b,'tcx, 'tcx>,\n+struct AssociatedTypeNormalizer<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n+    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n     cause: ObligationCause<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n     depth: usize,\n }\n \n-impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n-    fn new(selcx: &'a mut SelectionContext<'b,'tcx, 'tcx>,\n+impl<'a, 'b, 'gcx, 'tcx> AssociatedTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n+    fn new(selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n            cause: ObligationCause<'tcx>,\n            depth: usize)\n-           -> AssociatedTypeNormalizer<'a,'b,'tcx>\n+           -> AssociatedTypeNormalizer<'a, 'b, 'gcx, 'tcx>\n     {\n         AssociatedTypeNormalizer {\n             selcx: selcx,\n@@ -353,8 +357,8 @@ impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n     }\n }\n \n-impl<'a,'b,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'b,'tcx> {\n-    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'tcx, 'tcx> {\n+impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'tcx> {\n         self.selcx.tcx()\n     }\n \n@@ -422,8 +426,8 @@ impl<'tcx,T> Normalized<'tcx,T> {\n /// there are unresolved type variables in the projection, we will\n /// substitute a fresh type variable `$X` and generate a new\n /// obligation `<T as Trait>::Item == $X` for later.\n-pub fn normalize_projection_type<'a,'b,'tcx>(\n-    selcx: &'a mut SelectionContext<'b,'tcx, 'tcx>,\n+pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize)\n@@ -453,8 +457,8 @@ pub fn normalize_projection_type<'a,'b,'tcx>(\n /// as Trait>::Item`. The result is always a type (and possibly\n /// additional obligations). Returns `None` in the case of ambiguity,\n /// which indicates that there are unbound type variables.\n-fn opt_normalize_projection_type<'a,'b,'tcx>(\n-    selcx: &'a mut SelectionContext<'b,'tcx, 'tcx>,\n+fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize)\n@@ -542,11 +546,11 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n /// an error for this obligation, but we legitimately should not,\n /// because it contains `[type error]`. Yuck! (See issue #29857 for\n /// one case where this arose.)\n-fn normalize_to_error<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx, 'tcx>,\n-                               projection_ty: ty::ProjectionTy<'tcx>,\n-                               cause: ObligationCause<'tcx>,\n-                               depth: usize)\n-                               -> NormalizedTy<'tcx>\n+fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+                                      projection_ty: ty::ProjectionTy<'tcx>,\n+                                      cause: ObligationCause<'tcx>,\n+                                      depth: usize)\n+                                      -> NormalizedTy<'tcx>\n {\n     let trait_ref = projection_ty.trait_ref.to_poly_trait_ref();\n     let trait_obligation = Obligation { cause: cause,\n@@ -565,8 +569,8 @@ enum ProjectedTy<'tcx> {\n }\n \n /// Compute the result of a projection type (if we can).\n-fn project_type<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n+fn project_type<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>)\n     -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>>\n {\n@@ -748,8 +752,8 @@ fn project_type<'cx,'tcx>(\n /// The first thing we have to do is scan through the parameter\n /// environment to see whether there are any projection predicates\n /// there that can answer this question.\n-fn assemble_candidates_from_param_env<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n+fn assemble_candidates_from_param_env<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n@@ -774,8 +778,8 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n /// ```\n ///\n /// Here, for example, we could conclude that the result is `i32`.\n-fn assemble_candidates_from_trait_def<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n+fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n@@ -806,8 +810,8 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n                                         bounds)\n }\n \n-fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n-    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n+fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n@@ -853,8 +857,8 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n     }\n }\n \n-fn assemble_candidates_from_object_type<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n+fn assemble_candidates_from_object_type<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation:  &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n@@ -885,8 +889,8 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n                                         env_predicates)\n }\n \n-fn assemble_candidates_from_impls<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n+fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n@@ -969,8 +973,8 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n     Ok(())\n }\n \n-fn confirm_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n+fn confirm_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     candidate: ProjectionTyCandidate<'tcx>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n@@ -999,8 +1003,8 @@ fn confirm_candidate<'cx,'tcx>(\n     }\n }\n \n-fn confirm_fn_pointer_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n+fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_type: Ty<'tcx>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n@@ -1010,8 +1014,8 @@ fn confirm_fn_pointer_candidate<'cx,'tcx>(\n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n }\n \n-fn confirm_closure_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n+fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n@@ -1033,8 +1037,8 @@ fn confirm_closure_candidate<'cx,'tcx>(\n     (ty, obligations)\n }\n \n-fn confirm_callable_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n+fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_sig: &ty::PolyFnSig<'tcx>,\n     flag: util::TupleArgumentsFlag)\n@@ -1067,8 +1071,8 @@ fn confirm_callable_candidate<'cx,'tcx>(\n     confirm_param_env_candidate(selcx, obligation, predicate)\n }\n \n-fn confirm_param_env_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n+fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     poly_projection: ty::PolyProjectionPredicate<'tcx>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n@@ -1106,8 +1110,8 @@ fn confirm_param_env_candidate<'cx,'tcx>(\n     (projection.ty, vec!())\n }\n \n-fn confirm_impl_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n+fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n@@ -1146,10 +1150,11 @@ fn confirm_impl_candidate<'cx,'tcx>(\n ///\n /// Based on the \"projection mode\", this lookup may in fact only examine the\n /// topmost impl. See the comments for `ProjectionMode` for more details.\n-fn assoc_ty_def<'cx, 'tcx>(selcx: &SelectionContext<'cx, 'tcx, 'tcx>,\n-                           impl_def_id: DefId,\n-                           assoc_ty_name: ast::Name)\n-                           -> Option<specialization_graph::NodeItem<Rc<ty::AssociatedType<'tcx>>>>\n+fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n+    selcx: &SelectionContext<'cx, 'gcx, 'tcx>,\n+    impl_def_id: DefId,\n+    assoc_ty_name: ast::Name)\n+    -> Option<specialization_graph::NodeItem<Rc<ty::AssociatedType<'tcx>>>>\n {\n     let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n "}, {"sha": "0d8f2f7cabfe38f9aeeca24428758516e38e5ccd", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 84, "deletions": 34, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -57,7 +57,7 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     /// at one time will have the same set of skolemized entries,\n     /// which is important for checking for trait bounds that\n     /// recursively require themselves.\n-    freshener: TypeFreshener<'cx, 'tcx, 'tcx>,\n+    freshener: TypeFreshener<'cx, 'gcx, 'tcx>,\n \n     /// If true, indicates that the evaluation should be conservative\n     /// and consider the possibility of types outside this crate.\n@@ -210,6 +210,38 @@ enum SelectionCandidate<'tcx> {\n     BuiltinUnsizeCandidate,\n }\n \n+impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n+    type Lifted = SelectionCandidate<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        Some(match *self {\n+            BuiltinCandidate { has_nested } => {\n+                BuiltinCandidate {\n+                    has_nested: has_nested\n+                }\n+            }\n+            ImplCandidate(def_id) => ImplCandidate(def_id),\n+            DefaultImplCandidate(def_id) => DefaultImplCandidate(def_id),\n+            DefaultImplObjectCandidate(def_id) => {\n+                DefaultImplObjectCandidate(def_id)\n+            }\n+            ProjectionCandidate => ProjectionCandidate,\n+            FnPointerCandidate => FnPointerCandidate,\n+            ObjectCandidate => ObjectCandidate,\n+            BuiltinObjectCandidate => BuiltinObjectCandidate,\n+            BuiltinUnsizeCandidate => BuiltinUnsizeCandidate,\n+\n+            ParamCandidate(ref trait_ref) => {\n+                return tcx.lift(trait_ref).map(ParamCandidate);\n+            }\n+            ClosureCandidate(def_id, ref substs, kind) => {\n+                return tcx.lift(substs).map(|substs| {\n+                    ClosureCandidate(def_id, substs, kind)\n+                });\n+            }\n+        })\n+    }\n+}\n+\n struct SelectionCandidateSet<'tcx> {\n     // a list of candidates that definitely apply to the current\n     // obligation (meaning: types unify).\n@@ -262,36 +294,36 @@ pub struct EvaluationCache<'tcx> {\n     hashmap: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n }\n \n-impl<'cx, 'tcx> SelectionContext<'cx, 'tcx, 'tcx> {\n-    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx, 'tcx>) -> SelectionContext<'cx, 'tcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>) -> SelectionContext<'cx, 'gcx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n             freshener: infcx.freshener(),\n             intercrate: false,\n         }\n     }\n \n-    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx, 'tcx>) -> SelectionContext<'cx, 'tcx, 'tcx> {\n+    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>) -> SelectionContext<'cx, 'gcx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n             freshener: infcx.freshener(),\n             intercrate: true,\n         }\n     }\n \n-    pub fn infcx(&self) -> &'cx InferCtxt<'cx, 'tcx, 'tcx> {\n+    pub fn infcx(&self) -> &'cx InferCtxt<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'cx, 'tcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n     pub fn param_env(&self) -> &'cx ty::ParameterEnvironment<'tcx> {\n         self.infcx.param_env()\n     }\n \n-    pub fn closure_typer(&self) -> &'cx InferCtxt<'cx, 'tcx, 'tcx> {\n+    pub fn closure_typer(&self) -> &'cx InferCtxt<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n \n@@ -627,23 +659,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx, 'tcx> {\n         result\n     }\n \n-    fn pick_evaluation_cache(&self) -> &EvaluationCache<'tcx> {\n-        // see comment in `pick_candidate_cache`\n-        if self.intercrate ||\n-            !self.param_env().caller_bounds.is_empty()\n-        {\n-            &self.param_env().evaluation_cache\n-        } else\n-        {\n-            &self.tcx().evaluation_cache\n-        }\n-    }\n-\n     fn check_evaluation_cache(&self, trait_ref: ty::PolyTraitRef<'tcx>)\n                               -> Option<EvaluationResult>\n     {\n-        let cache = self.pick_evaluation_cache();\n-        cache.hashmap.borrow().get(&trait_ref).cloned()\n+        if self.can_use_global_caches() {\n+            let cache = self.tcx().evaluation_cache.hashmap.borrow();\n+            if let Some(cached) = cache.get(&trait_ref) {\n+                return Some(cached.clone());\n+            }\n+        }\n+        self.infcx.evaluation_cache.hashmap.borrow().get(&trait_ref).cloned()\n     }\n \n     fn insert_evaluation_cache(&mut self,\n@@ -661,8 +686,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx, 'tcx> {\n             return;\n         }\n \n-        let cache = self.pick_evaluation_cache();\n-        cache.hashmap.borrow_mut().insert(trait_ref, result);\n+        if self.can_use_global_caches() {\n+            let mut cache = self.tcx().evaluation_cache.hashmap.borrow_mut();\n+            if let Some(trait_ref) = self.tcx().lift_to_global(&trait_ref) {\n+                cache.insert(trait_ref, result);\n+                return;\n+            }\n+        }\n+\n+        self.infcx.evaluation_cache.hashmap.borrow_mut().insert(trait_ref, result);\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -871,7 +903,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx, 'tcx> {\n         coherence::trait_ref_is_knowable(self.tcx(), trait_ref)\n     }\n \n-    fn pick_candidate_cache(&self) -> &SelectionCache<'tcx> {\n+    /// Returns true if the global caches can be used.\n+    /// Do note that if the type itself is not in the\n+    /// global tcx, the local caches will be used.\n+    fn can_use_global_caches(&self) -> bool {\n         // If there are any where-clauses in scope, then we always use\n         // a cache local to this particular scope. Otherwise, we\n         // switch to a global cache. We used to try and draw\n@@ -880,7 +915,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx, 'tcx> {\n         // rule seems to be pretty clearly safe and also still retains\n         // a very high hit rate (~95% when compiling rustc).\n         if !self.param_env().caller_bounds.is_empty() {\n-            return &self.param_env().selection_cache;\n+            return false;\n         }\n \n         // Avoid using the master cache during coherence and just rely\n@@ -891,29 +926,43 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx, 'tcx> {\n         // it's not worth going to more trouble to increase the\n         // hit-rate I don't think.\n         if self.intercrate {\n-            return &self.param_env().selection_cache;\n+            return false;\n         }\n \n         // Otherwise, we can use the global cache.\n-        &self.tcx().selection_cache\n+        true\n     }\n \n     fn check_candidate_cache(&mut self,\n                              cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>)\n                              -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>>\n     {\n-        let cache = self.pick_candidate_cache();\n-        let hashmap = cache.hashmap.borrow();\n-        hashmap.get(&cache_fresh_trait_pred.0.trait_ref).cloned()\n+        let trait_ref = &cache_fresh_trait_pred.0.trait_ref;\n+        if self.can_use_global_caches() {\n+            let cache = self.tcx().selection_cache.hashmap.borrow();\n+            if let Some(cached) = cache.get(&trait_ref) {\n+                return Some(cached.clone());\n+            }\n+        }\n+        self.infcx.selection_cache.hashmap.borrow().get(trait_ref).cloned()\n     }\n \n     fn insert_candidate_cache(&mut self,\n                               cache_fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n                               candidate: SelectionResult<'tcx, SelectionCandidate<'tcx>>)\n     {\n-        let cache = self.pick_candidate_cache();\n-        let mut hashmap = cache.hashmap.borrow_mut();\n-        hashmap.insert(cache_fresh_trait_pred.0.trait_ref.clone(), candidate);\n+        let trait_ref = cache_fresh_trait_pred.0.trait_ref;\n+        if self.can_use_global_caches() {\n+            let mut cache = self.tcx().selection_cache.hashmap.borrow_mut();\n+            if let Some(trait_ref) = self.tcx().lift_to_global(&trait_ref) {\n+                if let Some(candidate) = self.tcx().lift_to_global(&candidate) {\n+                    cache.insert(trait_ref, candidate);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        self.infcx.selection_cache.hashmap.borrow_mut().insert(trait_ref, candidate);\n     }\n \n     fn should_update_candidate_cache(&mut self,\n@@ -1592,7 +1641,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx, 'tcx> {\n                 // i.e. EvaluatedToOk:\n                 if other.evaluation == EvaluatedToOk {\n                     if let ImplCandidate(victim_def) = victim.candidate {\n-                        return traits::specializes(self.tcx(), other_def, victim_def);\n+                        let tcx = self.tcx().global_tcx();\n+                        return traits::specializes(tcx, other_def, victim_def);\n                     }\n                 }\n "}, {"sha": "a4c75e4307a38ec13d6e4663ebace10a94117fde", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -72,11 +72,11 @@ pub struct OverlapError {\n /// through associated type projection. We deal with such cases by using\n /// *fulfillment* to relate the two impls, requiring that all projections are\n /// resolved.\n-pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n-                                  source_impl: DefId,\n-                                  source_substs: &'tcx Substs<'tcx>,\n-                                  target_node: specialization_graph::Node)\n-                                  -> &'tcx Substs<'tcx> {\n+pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                        source_impl: DefId,\n+                                        source_substs: &'tcx Substs<'tcx>,\n+                                        target_node: specialization_graph::Node)\n+                                        -> &'tcx Substs<'tcx> {\n     let source_trait_ref = infcx.tcx\n                                 .impl_trait_ref(source_impl)\n                                 .unwrap()\n@@ -168,10 +168,10 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// generics of `target_impl`, including both those needed to unify with\n /// `source_trait_ref` and those whose identity is determined via a where\n /// clause in the impl.\n-fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n-                                 source_trait_ref: ty::TraitRef<'tcx>,\n-                                 target_impl: DefId)\n-                                 -> Result<Substs<'tcx>, ()> {\n+fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                       source_trait_ref: ty::TraitRef<'tcx>,\n+                                       target_impl: DefId)\n+                                       -> Result<Substs<'tcx>, ()> {\n     infcx.commit_if_ok(|_| {\n         let selcx = &mut SelectionContext::new(&infcx);\n         let target_substs = fresh_type_vars_for_impl(&infcx, DUMMY_SP, target_impl);"}, {"sha": "8c359c0c7a2ce78fb4c77c505874aaeed77b7471", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -77,7 +77,7 @@ enum Inserted {\n     ShouldRecurseOn(DefId),\n }\n \n-impl<'a, 'tcx> Children {\n+impl<'a, 'gcx, 'tcx> Children {\n     fn new() -> Children {\n         Children {\n             nonblanket_impls: FnvHashMap(),\n@@ -87,7 +87,7 @@ impl<'a, 'tcx> Children {\n \n     /// Insert an impl into this set of children without comparing to any existing impls\n     fn insert_blindly(&mut self,\n-                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                      tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                       impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n@@ -100,7 +100,7 @@ impl<'a, 'tcx> Children {\n     /// Attempt to insert an impl into this set of children, while comparing for\n     /// specialiation relationships.\n     fn insert(&mut self,\n-              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n               impl_def_id: DefId,\n               simplified_self: Option<SimplifiedType>)\n               -> Result<Inserted, OverlapError>\n@@ -111,6 +111,7 @@ impl<'a, 'tcx> Children {\n         } {\n             let possible_sibling = *slot;\n \n+            let tcx = tcx.global_tcx();\n             let (le, ge) = InferCtxt::enter(tcx, None, None,\n                                             ProjectionMode::Topmost, |infcx| {\n                 let overlap = traits::overlapping_impls(&infcx,\n@@ -181,7 +182,7 @@ impl<'a, 'tcx> Children {\n     }\n }\n \n-impl<'a, 'tcx> Graph {\n+impl<'a, 'gcx, 'tcx> Graph {\n     pub fn new() -> Graph {\n         Graph {\n             parent: Default::default(),\n@@ -193,7 +194,7 @@ impl<'a, 'tcx> Graph {\n     /// conflicts with it (has overlap, but neither specializes the other),\n     /// information about the area of overlap is returned in the `Err`.\n     pub fn insert(&mut self,\n-                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                   impl_def_id: DefId)\n                   -> Result<(), OverlapError> {\n         assert!(impl_def_id.is_local());\n@@ -252,7 +253,7 @@ impl<'a, 'tcx> Graph {\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n     pub fn record_impl_from_cstore(&mut self,\n-                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                    parent: DefId,\n                                    child: DefId) {\n         if self.parent.insert(child, parent).is_some() {\n@@ -279,7 +280,7 @@ pub enum Node {\n     Trait(DefId),\n }\n \n-impl<'a, 'tcx> Node {\n+impl<'a, 'gcx, 'tcx> Node {\n     pub fn is_from_trait(&self) -> bool {\n         match *self {\n             Node::Trait(..) => true,\n@@ -288,11 +289,11 @@ impl<'a, 'tcx> Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> NodeItems<'a, 'tcx> {\n+    pub fn items(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> NodeItems<'a, 'gcx> {\n         match *self {\n             Node::Impl(impl_def_id) => {\n                 NodeItems::Impl {\n-                    tcx: tcx,\n+                    tcx: tcx.global_tcx(),\n                     items: cell::Ref::map(tcx.impl_items.borrow(),\n                                           |impl_items| &impl_items[&impl_def_id]),\n                     idx: 0,\n@@ -427,10 +428,10 @@ impl<'a, 'tcx> Iterator for ConstDefs<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Ancestors<'a, 'tcx> {\n     /// Search the items from the given ancestors, returning each type definition\n     /// with the given name.\n-    pub fn type_defs(self, tcx: TyCtxt<'a, 'tcx, 'tcx>, name: Name) -> TypeDefs<'a, 'tcx> {\n+    pub fn type_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> TypeDefs<'a, 'gcx> {\n         let iter = self.flat_map(move |node| {\n             node.items(tcx)\n                 .filter_map(move |item| {\n@@ -451,7 +452,7 @@ impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n \n     /// Search the items from the given ancestors, returning each fn definition\n     /// with the given name.\n-    pub fn fn_defs(self, tcx: TyCtxt<'a, 'tcx, 'tcx>, name: Name) -> FnDefs<'a, 'tcx> {\n+    pub fn fn_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> FnDefs<'a, 'gcx> {\n         let iter = self.flat_map(move |node| {\n             node.items(tcx)\n                 .filter_map(move |item| {\n@@ -472,7 +473,7 @@ impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n \n     /// Search the items from the given ancestors, returning each const\n     /// definition with the given name.\n-    pub fn const_defs(self, tcx: TyCtxt<'a, 'tcx, 'tcx>, name: Name) -> ConstDefs<'a, 'tcx> {\n+    pub fn const_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> ConstDefs<'a, 'gcx> {\n         let iter = self.flat_map(move |node| {\n             node.items(tcx)\n                 .filter_map(move |item| {"}, {"sha": "a8ba9655abbbee51744666ea9ebe37bc95da01f7", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -10,6 +10,7 @@\n \n use traits;\n use traits::project::Normalized;\n+use ty::{Lift, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::fmt;\n@@ -130,9 +131,34 @@ impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Lift implementations\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n+    type Lifted = traits::SelectionError<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            super::Unimplemented => Some(super::Unimplemented),\n+            super::OutputTypeParameterMismatch(a, b, ref err) => {\n+                tcx.lift(&(a, b)).and_then(|(a, b)| {\n+                    tcx.lift(err).map(|err| {\n+                        super::OutputTypeParameterMismatch(a, b, err)\n+                    })\n+                })\n+            }\n+            super::TraitNotObjectSafe(def_id) => {\n+                Some(super::TraitNotObjectSafe(def_id))\n+            }\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// TypeFoldable implementations.\n+\n impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O>\n {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::Obligation {\n             cause: self.cause.clone(),\n             recursion_depth: self.recursion_depth,\n@@ -146,7 +172,7 @@ impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let substs = self.substs.fold_with(folder);\n         traits::VtableImplData {\n             impl_def_id: self.impl_def_id,\n@@ -161,7 +187,7 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::VtableClosureData {\n             closure_def_id: self.closure_def_id,\n             substs: self.substs.fold_with(folder),\n@@ -175,7 +201,7 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureDa\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableDefaultImplData<N> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::VtableDefaultImplData {\n             trait_def_id: self.trait_def_id,\n             nested: self.nested.fold_with(folder),\n@@ -188,7 +214,7 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableDefaultIm\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::VtableBuiltinData {\n             nested: self.nested.fold_with(folder),\n         }\n@@ -200,7 +226,7 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinDa\n }\n \n impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::VtableObjectData {\n             upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n             vtable_base: self.vtable_base\n@@ -213,7 +239,7 @@ impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n             traits::VtableDefaultImpl(ref t) => traits::VtableDefaultImpl(t.fold_with(folder)),\n@@ -243,7 +269,7 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         Normalized {\n             value: self.value.fold_with(folder),\n             obligations: self.obligations.fold_with(folder),"}, {"sha": "3b90586810e326c7780dd40140ad1ff6bc5d9524", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -18,8 +18,9 @@ use util::nodemap::FnvHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n-fn anonymize_predicate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pred: &ty::Predicate<'tcx>)\n-                                 -> ty::Predicate<'tcx> {\n+fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                       pred: &ty::Predicate<'tcx>)\n+                                       -> ty::Predicate<'tcx> {\n     match *pred {\n         ty::Predicate::Trait(ref data) =>\n             ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data)),\n@@ -51,13 +52,13 @@ fn anonymize_predicate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pred: &ty::Predica\n }\n \n \n-struct PredicateSet<'a,'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct PredicateSet<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     set: FnvHashSet<ty::Predicate<'tcx>>,\n }\n \n-impl<'a,'tcx> PredicateSet<'a,'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> PredicateSet<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> PredicateSet<'a, 'gcx, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PredicateSet<'a, 'gcx, 'tcx> {\n         PredicateSet { tcx: tcx, set: FnvHashSet() }\n     }\n \n@@ -87,56 +88,56 @@ impl<'a,'tcx> PredicateSet<'a,'tcx> {\n /// that `T : PartialOrd` holds as well. Similarly, if we have `trait\n /// Foo : 'static`, and we know that `T : Foo`, then we know that `T :\n /// 'static`.\n-pub struct Elaborator<'cx, 'tcx:'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+pub struct Elaborator<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     stack: Vec<ty::Predicate<'tcx>>,\n-    visited: PredicateSet<'cx,'tcx>,\n+    visited: PredicateSet<'a, 'gcx, 'tcx>,\n }\n \n-pub fn elaborate_trait_ref<'cx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+pub fn elaborate_trait_ref<'cx, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>)\n-    -> Elaborator<'cx, 'tcx>\n+    -> Elaborator<'cx, 'gcx, 'tcx>\n {\n     elaborate_predicates(tcx, vec![trait_ref.to_predicate()])\n }\n \n-pub fn elaborate_trait_refs<'cx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+pub fn elaborate_trait_refs<'cx, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     trait_refs: &[ty::PolyTraitRef<'tcx>])\n-    -> Elaborator<'cx, 'tcx>\n+    -> Elaborator<'cx, 'gcx, 'tcx>\n {\n     let predicates = trait_refs.iter()\n                                .map(|trait_ref| trait_ref.to_predicate())\n                                .collect();\n     elaborate_predicates(tcx, predicates)\n }\n \n-pub fn elaborate_predicates<'cx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+pub fn elaborate_predicates<'cx, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     mut predicates: Vec<ty::Predicate<'tcx>>)\n-    -> Elaborator<'cx, 'tcx>\n+    -> Elaborator<'cx, 'gcx, 'tcx>\n {\n     let mut visited = PredicateSet::new(tcx);\n     predicates.retain(|pred| visited.insert(pred));\n-    Elaborator { tcx: tcx, stack: predicates, visited: visited }\n+    Elaborator { stack: predicates, visited: visited }\n }\n \n-impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n-    pub fn filter_to_traits(self) -> FilterToTraits<Elaborator<'cx, 'tcx>> {\n+impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n+    pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n         FilterToTraits::new(self)\n     }\n \n     fn push(&mut self, predicate: &ty::Predicate<'tcx>) {\n+        let tcx = self.visited.tcx;\n         match *predicate {\n             ty::Predicate::Trait(ref data) => {\n                 // Predicates declared on the trait.\n-                let predicates = self.tcx.lookup_super_predicates(data.def_id());\n+                let predicates = tcx.lookup_super_predicates(data.def_id());\n \n                 let mut predicates: Vec<_> =\n                     predicates.predicates\n                               .iter()\n-                              .map(|p| p.subst_supertrait(self.tcx, &data.to_poly_trait_ref()))\n+                              .map(|p| p.subst_supertrait(tcx, &data.to_poly_trait_ref()))\n                               .collect();\n \n                 debug!(\"super_predicates: data={:?} predicates={:?}\",\n@@ -199,7 +200,7 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx> Iterator for Elaborator<'cx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> Iterator for Elaborator<'cx, 'gcx, 'tcx> {\n     type Item = ty::Predicate<'tcx>;\n \n     fn next(&mut self) -> Option<ty::Predicate<'tcx>> {\n@@ -220,34 +221,34 @@ impl<'cx, 'tcx> Iterator for Elaborator<'cx, 'tcx> {\n // Supertrait iterator\n ///////////////////////////////////////////////////////////////////////////\n \n-pub type Supertraits<'cx, 'tcx> = FilterToTraits<Elaborator<'cx, 'tcx>>;\n+pub type Supertraits<'cx, 'gcx, 'tcx> = FilterToTraits<Elaborator<'cx, 'gcx, 'tcx>>;\n \n-pub fn supertraits<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n-                              trait_ref: ty::PolyTraitRef<'tcx>)\n-                              -> Supertraits<'cx, 'tcx>\n+pub fn supertraits<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+                                    trait_ref: ty::PolyTraitRef<'tcx>)\n+                                    -> Supertraits<'cx, 'gcx, 'tcx>\n {\n     elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n }\n \n-pub fn transitive_bounds<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n-                                    bounds: &[ty::PolyTraitRef<'tcx>])\n-                                    -> Supertraits<'cx, 'tcx>\n+pub fn transitive_bounds<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+                                          bounds: &[ty::PolyTraitRef<'tcx>])\n+                                          -> Supertraits<'cx, 'gcx, 'tcx>\n {\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // Iterator over def-ids of supertraits\n \n-pub struct SupertraitDefIds<'cx, 'tcx:'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+pub struct SupertraitDefIds<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     stack: Vec<DefId>,\n     visited: FnvHashSet<DefId>,\n }\n \n-pub fn supertrait_def_ids<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n-                                     trait_def_id: DefId)\n-                                     -> SupertraitDefIds<'cx, 'tcx>\n+pub fn supertrait_def_ids<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+                                           trait_def_id: DefId)\n+                                           -> SupertraitDefIds<'cx, 'gcx, 'tcx>\n {\n     SupertraitDefIds {\n         tcx: tcx,\n@@ -256,7 +257,7 @@ pub fn supertrait_def_ids<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n     }\n }\n \n-impl<'cx, 'tcx> Iterator for SupertraitDefIds<'cx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> Iterator for SupertraitDefIds<'cx, 'gcx, 'tcx> {\n     type Item = DefId;\n \n     fn next(&mut self) -> Option<DefId> {\n@@ -319,11 +320,11 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n /// Instantiate all bound parameters of the impl with the given substs,\n /// returning the resulting trait ref and all obligations that arise.\n /// The obligations are closed under normalization.\n-pub fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx, 'tcx>,\n-                                         impl_def_id: DefId,\n-                                         impl_substs: &Substs<'tcx>)\n-                                         -> (ty::TraitRef<'tcx>,\n-                                             Vec<PredicateObligation<'tcx>>)\n+pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+                                                impl_def_id: DefId,\n+                                                impl_substs: &Substs<'tcx>)\n+                                                -> (ty::TraitRef<'tcx>,\n+                                                    Vec<PredicateObligation<'tcx>>)\n {\n     let impl_trait_ref =\n         selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n@@ -352,10 +353,10 @@ pub fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx, '\n // declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-pub fn fresh_type_vars_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n-                                          span: Span,\n-                                          impl_def_id: DefId)\n-                                          -> Substs<'tcx>\n+pub fn fresh_type_vars_for_impl<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                                span: Span,\n+                                                impl_def_id: DefId)\n+                                                -> Substs<'tcx>\n {\n     let tcx = infcx.tcx;\n     let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n@@ -391,7 +392,7 @@ pub fn predicate_for_trait_ref<'tcx>(\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n pub fn trait_ref_for_builtin_bound(self,\n     builtin_bound: ty::BuiltinBound,\n     param_ty: Ty<'tcx>)"}, {"sha": "39dba57c47b7c855fe1bf6cad60dc778dad0aa6c", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -28,26 +28,26 @@ use ty::relate::{self, Relate, TypeRelation, RelateResult};\n /// Like subtyping, matching is really a binary relation, so the only\n /// important thing about the result is Ok/Err. Also, matching never\n /// affects any type variables or unification state.\n-pub struct Match<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+pub struct Match<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> Match<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Match<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Match<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Match<'a, 'gcx, 'tcx> {\n         Match { tcx: tcx }\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Match\" }\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.tcx }\n     fn a_is_expected(&self) -> bool { true } // irrelevant\n \n-    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n-                                               _: ty::Variance,\n-                                               a: &T,\n-                                               b: &T)\n-                                               -> RelateResult<'tcx, T>\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             _: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n     {\n         self.relate(a, b)\n     }\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'a,'tcx>\n+        where T: Relate<'tcx>\n     {\n         Ok(ty::Binder(self.relate(a.skip_binder(), b.skip_binder())?))\n     }"}, {"sha": "58f24a5c6cbf27aedad6e9d668f32729366ad52e", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -136,10 +136,10 @@ pub enum CustomCoerceUnsized {\n     Struct(usize)\n }\n \n-impl<'a, 'tcx> ty::TyS<'tcx> {\n+impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n     /// See `expr_ty_adjusted`\n     pub fn adjust<F>(&'tcx self,\n-                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                      span: Span,\n                      expr_id: ast::NodeId,\n                      adjustment: Option<&AutoAdjustment<'tcx>>,\n@@ -216,7 +216,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     }\n \n     pub fn adjust_for_autoderef<F>(&'tcx self,\n-                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                    expr_id: ast::NodeId,\n                                    expr_span: Span,\n                                    autoderef: u32, // how many autoderefs so far?\n@@ -244,7 +244,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         }\n     }\n \n-    pub fn adjust_for_autoref(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn adjust_for_autoref(&'tcx self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                               autoref: Option<AutoRef<'tcx>>)\n                               -> Ty<'tcx> {\n         match autoref {"}, {"sha": "c493942aa096b47b00dff4756bd5ead6d8f7f588", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -194,7 +194,7 @@ pub struct Tables<'tcx> {\n     pub fru_field_types: NodeMap<Vec<Ty<'tcx>>>\n }\n \n-impl<'a, 'tcx> Tables<'tcx> {\n+impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n     pub fn empty() -> Tables<'tcx> {\n         Tables {\n             node_types: FnvHashMap(),\n@@ -210,7 +210,7 @@ impl<'a, 'tcx> Tables<'tcx> {\n     }\n \n     pub fn closure_kind(this: &RefCell<Self>,\n-                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                         def_id: DefId)\n                         -> ty::ClosureKind {\n         // If this is a local def-id, it should be inserted into the\n@@ -226,7 +226,7 @@ impl<'a, 'tcx> Tables<'tcx> {\n     }\n \n     pub fn closure_type(this: &RefCell<Self>,\n-                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                         def_id: DefId,\n                         substs: &ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n@@ -238,7 +238,7 @@ impl<'a, 'tcx> Tables<'tcx> {\n             return ty.subst(tcx, &substs.func_substs);\n         }\n \n-        let ty = tcx.sess.cstore.closure_ty(tcx, def_id);\n+        let ty = tcx.sess.cstore.closure_ty(tcx.global_tcx(), def_id);\n         this.borrow_mut().closure_tys.insert(def_id, ty.clone());\n         ty.subst(tcx, &substs.func_substs)\n     }\n@@ -494,7 +494,7 @@ impl<'tcx> GlobalCtxt<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn crate_name(self, cnum: ast::CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n             self.crate_name.clone()\n@@ -526,12 +526,12 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         Ref::map(self.tables.borrow(), projection)\n     }\n \n-    pub fn node_type_insert(self, id: NodeId, ty: Ty<'tcx>) {\n+    pub fn node_type_insert(self, id: NodeId, ty: Ty<'gcx>) {\n         self.tables.borrow_mut().node_types.insert(id, ty);\n     }\n \n-    pub fn intern_trait_def(self, def: ty::TraitDef<'tcx>)\n-                            -> &'tcx ty::TraitDef<'tcx> {\n+    pub fn intern_trait_def(self, def: ty::TraitDef<'gcx>)\n+                            -> &'gcx ty::TraitDef<'gcx> {\n         let did = def.trait_ref.def_id;\n         let interned = self.global_interners.arenas.trait_defs.alloc(def);\n         if let Some(prev) = self.trait_defs.borrow_mut().insert(did, interned) {\n@@ -540,16 +540,16 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         interned\n     }\n \n-    pub fn alloc_trait_def(self, def: ty::TraitDef<'tcx>)\n-                           -> &'tcx ty::TraitDef<'tcx> {\n+    pub fn alloc_trait_def(self, def: ty::TraitDef<'gcx>)\n+                           -> &'gcx ty::TraitDef<'gcx> {\n         self.global_interners.arenas.trait_defs.alloc(def)\n     }\n \n     pub fn intern_adt_def(self,\n                           did: DefId,\n                           kind: ty::AdtKind,\n-                          variants: Vec<ty::VariantDefData<'tcx, 'tcx>>)\n-                          -> ty::AdtDefMaster<'tcx> {\n+                          variants: Vec<ty::VariantDefData<'gcx, 'gcx>>)\n+                          -> ty::AdtDefMaster<'gcx> {\n         let def = ty::AdtDefData::new(self, did, kind, variants);\n         let interned = self.global_interners.arenas.adt_defs.alloc(def);\n         // this will need a transmute when reverse-variance is removed\n@@ -601,6 +601,18 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         value.lift_to_tcx(self)\n     }\n \n+    /// Like lift, but only tries in the global tcx.\n+    pub fn lift_to_global<T: ?Sized + Lift<'gcx>>(self, value: &T) -> Option<T::Lifted> {\n+        value.lift_to_tcx(self.global_tcx())\n+    }\n+\n+    /// Returns true if self is the same as self.global_tcx().\n+    fn is_global(self) -> bool {\n+        let local = self.interners as *const _;\n+        let global = &self.global_interners as *const _;\n+        local as usize == global as usize\n+    }\n+\n     /// Create a type context and call the closure with a `TyCtxt` reference\n     /// to the context. The closure enforces that the type context and any interned\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n@@ -693,30 +705,40 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n /// e.g. `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx> {\n     type Lifted;\n-    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Self::Lifted>;\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted>;\n }\n \n impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n     type Lifted = Ty<'tcx>;\n-    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> Option<Ty<'tcx>> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n         if let Some(&InternedTy { ty }) = tcx.interners.type_.borrow().get(&self.sty) {\n             if *self as *const _ == ty as *const _ {\n                 return Some(ty);\n             }\n         }\n-        None\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     type Lifted = &'tcx Substs<'tcx>;\n-    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n         if let Some(&InternedSubsts { substs }) = tcx.interners.substs.borrow().get(*self) {\n             if *self as *const _ == substs as *const _ {\n                 return Some(substs);\n             }\n         }\n-        None\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -910,7 +932,7 @@ fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n             |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // Type constructors\n     pub fn mk_substs(self, substs: Substs<'tcx>) -> &'tcx Substs<'tcx> {\n         if let Some(interned) = self.interners.substs.borrow().get(&substs) {\n@@ -1139,7 +1161,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         self.mk_param(def.space, def.index, def.name)\n     }\n \n-    pub fn trait_items(self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> {\n+    pub fn trait_items(self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'gcx>>> {\n         self.trait_items_cache.memoize(trait_did, || {\n             let def_ids = self.trait_item_def_ids(trait_did);\n             Rc::new(def_ids.iter()"}, {"sha": "b5190f313309fe18a4a9f79358adfb38e6fe3486", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -210,8 +210,8 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'lcx> ty::TyS<'tcx> {\n-    fn sort_string(&self, tcx: TyCtxt<'a, 'lcx, 'lcx>) -> String {\n+impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n+    fn sort_string(&self, tcx: TyCtxt<'a, 'gcx, 'lcx>) -> String {\n         match self.sty {\n             ty::TyBool | ty::TyChar | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr => self.to_string(),\n@@ -252,7 +252,7 @@ impl<'a, 'tcx, 'lcx> ty::TyS<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_type_err(self,\n                                      db: &mut DiagnosticBuilder,\n                                      err: &TypeError<'tcx>,"}, {"sha": "25f3552b565e720cccd1a0ec86b9bda1b759d1b2", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -43,10 +43,10 @@ pub enum SimplifiedType {\n /// then we can't say much about whether two types would unify. Put another way,\n /// `can_simplify_params` should be true if type parameters appear free in `ty` and `false` if they\n /// are to be considered bound.\n-pub fn simplify_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               ty: Ty,\n-                               can_simplify_params: bool)\n-                               -> Option<SimplifiedType>\n+pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                     ty: Ty,\n+                                     can_simplify_params: bool)\n+                                     -> Option<SimplifiedType>\n {\n     match ty.sty {\n         ty::TyBool => Some(BoolSimplifiedType),"}, {"sha": "463b0e17f613f3bb737f7ef38a620b69ba5d4221", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -50,8 +50,8 @@ use util::nodemap::{FnvHashMap, FnvHashSet};\n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self;\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         self.super_fold_with(folder)\n     }\n \n@@ -113,8 +113,8 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n /// default implementation that does an \"identity\" fold. Within each\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n /// sub-item.\n-pub trait TypeFolder<'tcx> : Sized {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n     fn fold_binder<T>(&mut self, t: &Binder<T>) -> Binder<T>\n         where T : TypeFoldable<'tcx>\n@@ -201,15 +201,17 @@ pub trait TypeVisitor<'tcx> : Sized {\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n-pub struct BottomUpFolder<'a, 'tcx: 'a, F> where F: FnMut(Ty<'tcx>) -> Ty<'tcx> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct BottomUpFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a, F>\n+    where F: FnMut(Ty<'tcx>) -> Ty<'tcx>\n+{\n+    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub fldop: F,\n }\n \n-impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n-    F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n+impl<'a, 'gcx, 'tcx, F> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'a, 'gcx, 'tcx, F>\n+    where F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let t1 = ty.super_fold_with(self);\n@@ -220,7 +222,7 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n ///////////////////////////////////////////////////////////////////////////\n // Region folder\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Collects the free and escaping regions in `value` into `region_set`. Returns\n     /// whether any late-bound regions were skipped\n     pub fn collect_regions<T>(self,\n@@ -259,17 +261,17 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n /// visited by this folder; only regions that occur free will be\n /// visited by `fld_r`.\n \n-pub struct RegionFolder<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     skipped_regions: &'a mut bool,\n     current_depth: u32,\n     fld_r: &'a mut (FnMut(ty::Region, u32) -> ty::Region + 'a),\n }\n \n-impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n-    pub fn new<F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n+    pub fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                   skipped_regions: &'a mut bool,\n-                  fld_r: &'a mut F) -> RegionFolder<'a, 'tcx>\n+                  fld_r: &'a mut F) -> RegionFolder<'a, 'gcx, 'tcx>\n         where F : FnMut(ty::Region, u32) -> ty::Region\n     {\n         RegionFolder {\n@@ -281,9 +283,8 @@ impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n-{\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.tcx }\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_depth += 1;\n@@ -314,14 +315,14 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n \n // Replaces the escaping regions in a type.\n \n-struct RegionReplacer<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     current_depth: u32,\n     fld_r: &'a mut (FnMut(ty::BoundRegion) -> ty::Region + 'a),\n     map: FnvHashMap<ty::BoundRegion, ty::Region>\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n@@ -408,8 +409,9 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> RegionReplacer<'a, 'tcx> {\n-    fn new<F>(tcx: TyCtxt<'a, 'tcx, 'tcx>, fld_r: &'a mut F) -> RegionReplacer<'a, 'tcx>\n+impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n+    fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>, fld_r: &'a mut F)\n+              -> RegionReplacer<'a, 'gcx, 'tcx>\n         where F : FnMut(ty::BoundRegion) -> ty::Region\n     {\n         RegionReplacer {\n@@ -421,9 +423,8 @@ impl<'a, 'tcx> RegionReplacer<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n-{\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.tcx }\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_depth += 1;\n@@ -463,7 +464,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n ///////////////////////////////////////////////////////////////////////////\n // Region eraser\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns an equivalent value with all free regions removed (note\n     /// that late-bound regions remain, because they are important for\n     /// subtyping, but they are anonymized and normalized as well)..\n@@ -475,20 +476,26 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n                value, value1);\n         return value1;\n \n-        struct RegionEraser<'a, 'tcx: 'a>(TyCtxt<'a, 'tcx, 'tcx>);\n+        struct RegionEraser<'a, 'gcx: 'a+'tcx, 'tcx: 'a>(TyCtxt<'a, 'gcx, 'tcx>);\n \n-        impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n-            fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.0 }\n+        impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionEraser<'a, 'gcx, 'tcx> {\n+            fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.0 }\n \n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n                     None => {}\n                     Some(u) => return u\n                 }\n \n-                let t_norm = ty.super_fold_with(self);\n-                self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n-                return t_norm;\n+                // FIXME(eddyb) should local contexts have a cache too?\n+                if let Some(ty_lifted) = self.tcx().lift_to_global(&ty) {\n+                    let tcx = self.tcx().global_tcx();\n+                    let t_norm = ty_lifted.super_fold_with(&mut RegionEraser(tcx));\n+                    tcx.normalized_cache.borrow_mut().insert(ty_lifted, t_norm);\n+                    t_norm\n+                } else {\n+                    ty.super_fold_with(self)\n+                }\n             }\n \n             fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n@@ -543,8 +550,10 @@ pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n     }\n }\n \n-pub fn shift_regions<'a, 'tcx, T:TypeFoldable<'tcx>>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                     amount: u32, value: &T) -> T {\n+pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                        amount: u32, value: &T) -> T\n+    where T: TypeFoldable<'tcx>\n+{\n     debug!(\"shift_regions(value={:?}, amount={})\",\n            value, amount);\n "}, {"sha": "5246c6739d9609ed9918f038eca0175dc3a29798", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -14,7 +14,7 @@ use hir::def_id::{DefId, CRATE_DEF_INDEX};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It is relative to the current crate\n     /// root."}, {"sha": "4b79b3809a5788fc7ebd8a15f259d7714053d36e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 94, "deletions": 97, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -773,26 +773,28 @@ pub struct GenericPredicates<'tcx> {\n     pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n }\n \n-impl<'a, 'tcx> GenericPredicates<'tcx> {\n+impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     pub fn empty() -> GenericPredicates<'tcx> {\n         GenericPredicates {\n             predicates: VecPerParamSpace::empty(),\n         }\n     }\n \n-    pub fn instantiate(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, substs: &Substs<'tcx>)\n+    pub fn instantiate(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n                        -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n             predicates: self.predicates.subst(tcx, substs),\n         }\n     }\n \n-    pub fn instantiate_supertrait(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn instantiate_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   poly_trait_ref: &ty::PolyTraitRef<'tcx>)\n                                   -> InstantiatedPredicates<'tcx>\n     {\n         InstantiatedPredicates {\n-            predicates: self.predicates.map(|pred| pred.subst_supertrait(tcx, poly_trait_ref))\n+            predicates: self.predicates.map(|pred| {\n+                pred.subst_supertrait(tcx, poly_trait_ref)\n+            })\n         }\n     }\n }\n@@ -832,13 +834,13 @@ pub enum Predicate<'tcx> {\n     ClosureKind(DefId, ClosureKind),\n }\n \n-impl<'a, 'tcx> Predicate<'tcx> {\n+impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n     /// Performs a substitution suitable for going from a\n     /// poly-trait-ref to supertraits that must hold if that\n     /// poly-trait-ref holds. This is slightly different from a normal\n     /// substitution in terms of what happens with bound regions.  See\n     /// lengthy comment below for details.\n-    pub fn subst_supertrait(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn subst_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                             trait_ref: &ty::PolyTraitRef<'tcx>)\n                             -> ty::Predicate<'tcx>\n     {\n@@ -1224,13 +1226,6 @@ pub struct ParameterEnvironment<'tcx> {\n     /// into Obligations, and elaborated and normalized.\n     pub caller_bounds: Vec<ty::Predicate<'tcx>>,\n \n-    /// Caches the results of trait selection. This cache is used\n-    /// for things that have to do with the parameters in scope.\n-    pub selection_cache: traits::SelectionCache<'tcx>,\n-\n-    /// Caches the results of trait evaluation.\n-    pub evaluation_cache: traits::EvaluationCache<'tcx>,\n-\n     /// Scope that is attached to free regions for this scope. This\n     /// is usually the id of the fn body, but for more abstract scopes\n     /// like structs we often use the node-id of the struct.\n@@ -1250,8 +1245,6 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             free_substs: self.free_substs.clone(),\n             implicit_region_bound: self.implicit_region_bound,\n             caller_bounds: caller_bounds,\n-            selection_cache: traits::SelectionCache::new(),\n-            evaluation_cache: traits::EvaluationCache::new(),\n             free_id_outlive: self.free_id_outlive,\n         }\n     }\n@@ -1566,11 +1559,11 @@ impl VariantKind {\n     }\n }\n \n-impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n+    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            did: DefId,\n            kind: AdtKind,\n-           variants: Vec<VariantDefData<'tcx, 'container>>) -> Self {\n+           variants: Vec<VariantDefData<'gcx, 'container>>) -> Self {\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n         let attrs = tcx.get_attrs(did);\n         if attr::contains_name(&attrs, \"fundamental\") {\n@@ -1597,7 +1590,7 @@ impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n         }\n     }\n \n-    fn calculate_dtorck(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    fn calculate_dtorck(&'gcx self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n         if tcx.is_adt_dtorck(self) {\n             self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK);\n         }\n@@ -1618,7 +1611,7 @@ impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// true, this type being safe for destruction requires it to be\n     /// alive; Otherwise, only the contents are required to be.\n     #[inline]\n-    pub fn is_dtorck(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+    pub fn is_dtorck(&'gcx self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         if !self.flags.get().intersects(AdtFlags::IS_DTORCK_VALID) {\n             self.calculate_dtorck(tcx)\n         }\n@@ -1653,18 +1646,18 @@ impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n \n     /// Asserts this is a struct and returns the struct's unique\n     /// variant.\n-    pub fn struct_variant(&self) -> &VariantDefData<'tcx, 'container> {\n+    pub fn struct_variant(&self) -> &VariantDefData<'gcx, 'container> {\n         assert_eq!(self.adt_kind(), AdtKind::Struct);\n         &self.variants[0]\n     }\n \n     #[inline]\n-    pub fn type_scheme(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> TypeScheme<'tcx> {\n+    pub fn type_scheme(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> TypeScheme<'gcx> {\n         tcx.lookup_item_type(self.did)\n     }\n \n     #[inline]\n-    pub fn predicates(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> GenericPredicates<'tcx> {\n+    pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> GenericPredicates<'gcx> {\n         tcx.lookup_predicates(self.did)\n     }\n \n@@ -1673,10 +1666,10 @@ impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     #[inline]\n     pub fn all_fields(&self) ->\n             iter::FlatMap<\n-                slice::Iter<VariantDefData<'tcx, 'container>>,\n-                slice::Iter<FieldDefData<'tcx, 'container>>,\n-                for<'s> fn(&'s VariantDefData<'tcx, 'container>)\n-                    -> slice::Iter<'s, FieldDefData<'tcx, 'container>>\n+                slice::Iter<VariantDefData<'gcx, 'container>>,\n+                slice::Iter<FieldDefData<'gcx, 'container>>,\n+                for<'s> fn(&'s VariantDefData<'gcx, 'container>)\n+                    -> slice::Iter<'s, FieldDefData<'gcx, 'container>>\n             > {\n         self.variants.iter().flat_map(VariantDefData::fields_iter)\n     }\n@@ -1696,7 +1689,7 @@ impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n             self.variants.iter().all(|v| v.fields.is_empty())\n     }\n \n-    pub fn variant_with_id(&self, vid: DefId) -> &VariantDefData<'tcx, 'container> {\n+    pub fn variant_with_id(&self, vid: DefId) -> &VariantDefData<'gcx, 'container> {\n         self.variants\n             .iter()\n             .find(|v| v.did == vid)\n@@ -1710,7 +1703,7 @@ impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n             .expect(\"variant_index_with_id: unknown variant\")\n     }\n \n-    pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'tcx, 'container> {\n+    pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'gcx, 'container> {\n         match def {\n             Def::Variant(_, vid) => self.variant_with_id(vid),\n             Def::Struct(..) | Def::TyAlias(..) => self.struct_variant(),\n@@ -1734,7 +1727,9 @@ impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n             None => NoDtor,\n         }\n     }\n+}\n \n+impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// Returns a simpler type such that `Self: Sized` if and only\n     /// if that type is Sized, or `TyErr` if this type is recursive.\n     ///\n@@ -1752,12 +1747,13 @@ impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     ///\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer, e.g. issue #31299.\n-    pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         let dep_node = DepNode::SizedConstraint(self.did);\n         match self.sized_constraint.get(dep_node) {\n             None => {\n-                let this = tcx.lookup_adt_def_master(self.did);\n-                this.calculate_sized_constraint_inner(tcx, &mut Vec::new());\n+                let global_tcx = tcx.global_tcx();\n+                let this = global_tcx.lookup_adt_def_master(self.did);\n+                this.calculate_sized_constraint_inner(global_tcx, &mut Vec::new());\n                 self.sized_constraint(tcx)\n             }\n             Some(ty) => ty\n@@ -1949,7 +1945,7 @@ impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n     }\n }\n \n-impl<'a, 'tcx, 'container> FieldDefData<'tcx, 'container> {\n+impl<'a, 'gcx, 'tcx, 'container> FieldDefData<'tcx, 'container> {\n     pub fn new(did: DefId,\n                name: Name,\n                vis: Visibility) -> Self {\n@@ -1961,7 +1957,7 @@ impl<'a, 'tcx, 'container> FieldDefData<'tcx, 'container> {\n         }\n     }\n \n-    pub fn ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n         self.unsubst_ty().subst(tcx, subst)\n     }\n \n@@ -2142,20 +2138,20 @@ impl BorrowKind {\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n-    pub fn node_id_to_type(self, id: NodeId) -> Ty<'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn node_id_to_type(self, id: NodeId) -> Ty<'gcx> {\n         match self.node_id_to_type_opt(id) {\n            Some(ty) => ty,\n            None => bug!(\"node_id_to_type: no type for node `{}`\",\n                         self.map.node_to_string(id))\n         }\n     }\n \n-    pub fn node_id_to_type_opt(self, id: NodeId) -> Option<Ty<'tcx>> {\n+    pub fn node_id_to_type_opt(self, id: NodeId) -> Option<Ty<'gcx>> {\n         self.tables.borrow().node_types.get(&id).cloned()\n     }\n \n-    pub fn node_id_item_substs(self, id: NodeId) -> ItemSubsts<'tcx> {\n+    pub fn node_id_item_substs(self, id: NodeId) -> ItemSubsts<'gcx> {\n         match self.tables.borrow().item_substs.get(&id) {\n             None => ItemSubsts::empty(),\n             Some(ts) => ts.clone(),\n@@ -2164,10 +2160,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n     // doesn't provide type parameter substitutions.\n-    pub fn pat_ty(self, pat: &hir::Pat) -> Ty<'tcx> {\n+    pub fn pat_ty(self, pat: &hir::Pat) -> Ty<'gcx> {\n         self.node_id_to_type(pat.id)\n     }\n-    pub fn pat_ty_opt(self, pat: &hir::Pat) -> Option<Ty<'tcx>> {\n+    pub fn pat_ty_opt(self, pat: &hir::Pat) -> Option<Ty<'gcx>> {\n         self.node_id_to_type_opt(pat.id)\n     }\n \n@@ -2181,11 +2177,11 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n     // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n     // instead of \"fn(ty) -> T with T = isize\".\n-    pub fn expr_ty(self, expr: &hir::Expr) -> Ty<'tcx> {\n+    pub fn expr_ty(self, expr: &hir::Expr) -> Ty<'gcx> {\n         self.node_id_to_type(expr.id)\n     }\n \n-    pub fn expr_ty_opt(self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+    pub fn expr_ty_opt(self, expr: &hir::Expr) -> Option<Ty<'gcx>> {\n         self.node_id_to_type_opt(expr.id)\n     }\n \n@@ -2198,17 +2194,17 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// hard to do, I just hate that code so much I didn't want to touch it\n     /// unless it was to fix it properly, which seemed a distraction from the\n     /// thread at hand! -nmatsakis\n-    pub fn expr_ty_adjusted(self, expr: &hir::Expr) -> Ty<'tcx> {\n+    pub fn expr_ty_adjusted(self, expr: &hir::Expr) -> Ty<'gcx> {\n         self.expr_ty(expr)\n-            .adjust(self, expr.span, expr.id,\n+            .adjust(self.global_tcx(), expr.span, expr.id,\n                     self.tables.borrow().adjustments.get(&expr.id),\n                     |method_call| {\n             self.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n         })\n     }\n \n-    pub fn expr_ty_adjusted_opt(self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n-        self.expr_ty_opt(expr).map(|t| t.adjust(self,\n+    pub fn expr_ty_adjusted_opt(self, expr: &hir::Expr) -> Option<Ty<'gcx>> {\n+        self.expr_ty_opt(expr).map(|t| t.adjust(self.global_tcx(),\n                                                 expr.span,\n                                                 expr.id,\n                                                 self.tables.borrow().adjustments.get(&expr.id),\n@@ -2316,7 +2312,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    pub fn provided_trait_methods(self, id: DefId) -> Vec<Rc<Method<'tcx>>> {\n+    pub fn provided_trait_methods(self, id: DefId) -> Vec<Rc<Method<'gcx>>> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             if let ItemTrait(_, _, _, ref ms) = self.map.expect_item(id).node {\n                 ms.iter().filter_map(|ti| {\n@@ -2337,11 +2333,11 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n                 bug!(\"provided_trait_methods: `{:?}` is not a trait\", id)\n             }\n         } else {\n-            self.sess.cstore.provided_trait_methods(self, id)\n+            self.sess.cstore.provided_trait_methods(self.global_tcx(), id)\n         }\n     }\n \n-    pub fn associated_consts(self, id: DefId) -> Vec<Rc<AssociatedConst<'tcx>>> {\n+    pub fn associated_consts(self, id: DefId) -> Vec<Rc<AssociatedConst<'gcx>>> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             match self.map.expect_item(id).node {\n                 ItemTrait(_, _, _, ref tis) => {\n@@ -2381,7 +2377,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n                 }\n             }\n         } else {\n-            self.sess.cstore.associated_consts(self, id)\n+            self.sess.cstore.associated_consts(self.global_tcx(), id)\n         }\n     }\n \n@@ -2420,10 +2416,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         })\n     }\n \n-    pub fn impl_or_trait_item(self, id: DefId) -> ImplOrTraitItem<'tcx> {\n+    pub fn impl_or_trait_item(self, id: DefId) -> ImplOrTraitItem<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"impl_or_trait_items\", id, &self.impl_or_trait_items,\n-            || self.sess.cstore.impl_or_trait_item(self, id)\n+            || self.sess.cstore.impl_or_trait_item(self.global_tcx(), id)\n                    .expect(\"missing ImplOrTraitItem in metadata\"))\n     }\n \n@@ -2435,10 +2431,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n     /// an inherent impl.\n-    pub fn impl_trait_ref(self, id: DefId) -> Option<TraitRef<'tcx>> {\n+    pub fn impl_trait_ref(self, id: DefId) -> Option<TraitRef<'gcx>> {\n         lookup_locally_or_in_crate_store(\n             \"impl_trait_refs\", id, &self.impl_trait_refs,\n-            || self.sess.cstore.impl_trait_ref(self, id))\n+            || self.sess.cstore.impl_trait_ref(self.global_tcx(), id))\n     }\n \n     /// Returns whether this DefId refers to an impl\n@@ -2487,55 +2483,55 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     }\n \n     // Register a given item type\n-    pub fn register_item_type(self, did: DefId, ty: TypeScheme<'tcx>) {\n+    pub fn register_item_type(self, did: DefId, ty: TypeScheme<'gcx>) {\n         self.tcache.borrow_mut().insert(did, ty);\n     }\n \n     // If the given item is in an external crate, looks up its type and adds it to\n     // the type cache. Returns the type parameters and type.\n-    pub fn lookup_item_type(self, did: DefId) -> TypeScheme<'tcx> {\n+    pub fn lookup_item_type(self, did: DefId) -> TypeScheme<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"tcache\", did, &self.tcache,\n-            || self.sess.cstore.item_type(self, did))\n+            || self.sess.cstore.item_type(self.global_tcx(), did))\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n-    pub fn lookup_trait_def(self, did: DefId) -> &'tcx TraitDef<'tcx> {\n+    pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"trait_defs\", did, &self.trait_defs,\n-            || self.alloc_trait_def(self.sess.cstore.trait_def(self, did))\n+            || self.alloc_trait_def(self.sess.cstore.trait_def(self.global_tcx(), did))\n         )\n     }\n \n     /// Given the did of an ADT, return a master reference to its\n     /// definition. Unless you are planning on fulfilling the ADT's fields,\n     /// use lookup_adt_def instead.\n-    pub fn lookup_adt_def_master(self, did: DefId) -> AdtDefMaster<'tcx> {\n+    pub fn lookup_adt_def_master(self, did: DefId) -> AdtDefMaster<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"adt_defs\", did, &self.adt_defs,\n-            || self.sess.cstore.adt_def(self, did)\n+            || self.sess.cstore.adt_def(self.global_tcx(), did)\n         )\n     }\n \n     /// Given the did of an ADT, return a reference to its definition.\n-    pub fn lookup_adt_def(self, did: DefId) -> AdtDef<'tcx> {\n+    pub fn lookup_adt_def(self, did: DefId) -> AdtDef<'gcx> {\n         // when reverse-variance goes away, a transmute::<AdtDefMaster,AdtDef>\n         // would be needed here.\n         self.lookup_adt_def_master(did)\n     }\n \n     /// Given the did of an item, returns its full set of predicates.\n-    pub fn lookup_predicates(self, did: DefId) -> GenericPredicates<'tcx> {\n+    pub fn lookup_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"predicates\", did, &self.predicates,\n-            || self.sess.cstore.item_predicates(self, did))\n+            || self.sess.cstore.item_predicates(self.global_tcx(), did))\n     }\n \n     /// Given the did of a trait, returns its superpredicates.\n-    pub fn lookup_super_predicates(self, did: DefId) -> GenericPredicates<'tcx> {\n+    pub fn lookup_super_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"super_predicates\", did, &self.super_predicates,\n-            || self.sess.cstore.item_super_predicates(self, did))\n+            || self.sess.cstore.item_super_predicates(self.global_tcx(), did))\n     }\n \n     /// If `type_needs_drop` returns true, then `ty` is definitely\n@@ -2545,13 +2541,14 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// (Note that this implies that if `ty` has a destructor attached,\n     /// then `type_needs_drop` will definitely return `true` for `ty`.)\n     pub fn type_needs_drop_given_env(self,\n-                                     ty: Ty<'tcx>,\n-                                     param_env: &ty::ParameterEnvironment<'tcx>) -> bool {\n+                                     ty: Ty<'gcx>,\n+                                     param_env: &ty::ParameterEnvironment<'gcx>) -> bool {\n         // Issue #22536: We first query type_moves_by_default.  It sees a\n         // normalized version of the type, and therefore will definitely\n         // know whether the type implements Copy (and thus needs no\n         // cleanup/drop/zeroing) ...\n-        let implements_copy = !ty.moves_by_default(self, param_env, DUMMY_SP);\n+        let tcx = self.global_tcx();\n+        let implements_copy = !ty.moves_by_default(tcx, param_env, DUMMY_SP);\n \n         if implements_copy { return false; }\n \n@@ -2566,13 +2563,13 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         // bound attached (see above), it is sound to treat it as having a\n         // destructor (e.g. zero its memory on move).\n \n-        let contents = ty.type_contents(self);\n+        let contents = ty.type_contents(tcx);\n         debug!(\"type_needs_drop ty={:?} contents={:?}\", ty, contents);\n-        contents.needs_drop(self)\n+        contents.needs_drop(tcx)\n     }\n \n     /// Get the attributes of a definition.\n-    pub fn get_attrs(self, did: DefId) -> Cow<'tcx, [ast::Attribute]> {\n+    pub fn get_attrs(self, did: DefId) -> Cow<'gcx, [ast::Attribute]> {\n         if let Some(id) = self.map.as_local_node_id(did) {\n             Cow::Borrowed(self.map.attrs(id))\n         } else {\n@@ -2720,15 +2717,15 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     }\n \n     pub fn closure_kind(self, def_id: DefId) -> ty::ClosureKind {\n-        Tables::closure_kind(&self.tables, self, def_id)\n+        Tables::closure_kind(&self.tables, self.global_tcx(), def_id)\n     }\n \n     pub fn closure_type(self,\n                         def_id: DefId,\n-                        substs: &ClosureSubsts<'tcx>)\n-                        -> ty::ClosureTy<'tcx>\n+                        substs: &ClosureSubsts<'gcx>)\n+                        -> ty::ClosureTy<'gcx>\n     {\n-        Tables::closure_type(&self.tables, self, def_id, substs)\n+        Tables::closure_type(&self.tables, self.global_tcx(), def_id, substs)\n     }\n \n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n@@ -2741,7 +2738,8 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return self.sess.cstore.impl_or_trait_item(self, def_id).and_then(|item| {\n+            return self.sess.cstore.impl_or_trait_item(self.global_tcx(), def_id)\n+                       .and_then(|item| {\n                 match item.container() {\n                     TraitContainer(_) => None,\n                     ImplContainer(def_id) => Some(def_id),\n@@ -2764,7 +2762,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// the trait that the method belongs to. Otherwise, return `None`.\n     pub fn trait_of_item(self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return self.sess.cstore.trait_of_item(self, def_id);\n+            return self.sess.cstore.trait_of_item(self.global_tcx(), def_id);\n         }\n         match self.impl_or_trait_items.borrow().get(&def_id).cloned() {\n             Some(impl_or_trait_item) => {\n@@ -2806,27 +2804,27 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         // for an empty parameter environment, there ARE no free\n         // regions, so it shouldn't matter what we use for the free id\n         let free_id_outlive = self.region_maps.node_extent(ast::DUMMY_NODE_ID);\n-        ty::ParameterEnvironment { free_substs: Substs::empty(),\n-                                   caller_bounds: Vec::new(),\n-                                   implicit_region_bound: ty::ReEmpty,\n-                                   selection_cache: traits::SelectionCache::new(),\n-                                   evaluation_cache: traits::EvaluationCache::new(),\n-                                   free_id_outlive: free_id_outlive }\n+        ty::ParameterEnvironment {\n+            free_substs: Substs::empty(),\n+            caller_bounds: Vec::new(),\n+            implicit_region_bound: ty::ReEmpty,\n+            free_id_outlive: free_id_outlive\n+        }\n     }\n \n     /// Constructs and returns a substitution that can be applied to move from\n     /// the \"outer\" view of a type or method to the \"inner\" view.\n     /// In general, this means converting from bound parameters to\n     /// free parameters. Since we currently represent bound/free type\n     /// parameters in the same way, this only has an effect on regions.\n-    pub fn construct_free_substs(self, generics: &Generics<'tcx>,\n-                                 free_id_outlive: CodeExtent) -> Substs<'tcx> {\n+    pub fn construct_free_substs(self, generics: &Generics<'gcx>,\n+                                 free_id_outlive: CodeExtent) -> Substs<'gcx> {\n         // map T => T\n         let mut types = VecPerParamSpace::empty();\n         for def in generics.types.as_slice() {\n             debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n                     def);\n-            types.push(def.space, self.mk_param_from_def(def));\n+            types.push(def.space, self.global_tcx().mk_param_from_def(def));\n         }\n \n         // map bound 'a => free 'a\n@@ -2850,10 +2848,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// for the `free_id_outlive` parameter. (But note that that is not always quite right.)\n     pub fn construct_parameter_environment(self,\n                                            span: Span,\n-                                           generics: &ty::Generics<'tcx>,\n-                                           generic_predicates: &ty::GenericPredicates<'tcx>,\n+                                           generics: &ty::Generics<'gcx>,\n+                                           generic_predicates: &ty::GenericPredicates<'gcx>,\n                                            free_id_outlive: CodeExtent)\n-                                           -> ParameterEnvironment<'tcx>\n+                                           -> ParameterEnvironment<'gcx>\n     {\n         //\n         // Construct the free substs.\n@@ -2865,8 +2863,9 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         // Compute the bounds on Self and the type parameters.\n         //\n \n-        let bounds = generic_predicates.instantiate(self, &free_substs);\n-        let bounds = self.liberate_late_bound_regions(free_id_outlive, &ty::Binder(bounds));\n+        let tcx = self.global_tcx();\n+        let bounds = generic_predicates.instantiate(tcx, &free_substs);\n+        let bounds = tcx.liberate_late_bound_regions(free_id_outlive, &ty::Binder(bounds));\n         let predicates = bounds.predicates.into_vec();\n \n         // Finally, we have to normalize the bounds in the environment, in\n@@ -2886,13 +2885,11 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             free_substs: free_substs,\n             implicit_region_bound: ty::ReScope(free_id_outlive),\n             caller_bounds: predicates,\n-            selection_cache: traits::SelectionCache::new(),\n-            evaluation_cache: traits::EvaluationCache::new(),\n             free_id_outlive: free_id_outlive,\n         };\n \n         let cause = traits::ObligationCause::misc(span, free_id_outlive.node_id(&self.region_maps));\n-        traits::normalize_param_env_or_error(self, unnormalized_env, cause)\n+        traits::normalize_param_env_or_error(tcx, unnormalized_env, cause)\n     }\n \n     pub fn is_method_call(self, expr_id: NodeId) -> bool {\n@@ -2911,9 +2908,9 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn visit_all_items_in_krate<V,F>(self,\n                                          dep_node_fn: F,\n                                          visitor: &mut V)\n-        where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n+        where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'gcx>\n     {\n-        dep_graph::visit_all_items_in_krate(self, dep_node_fn, visitor);\n+        dep_graph::visit_all_items_in_krate(self.global_tcx(), dep_node_fn, visitor);\n     }\n \n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`"}, {"sha": "0fba7ed2a929a15970eb78109f33eec6f3ec84d1", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -55,7 +55,7 @@ pub enum Component<'tcx> {\n     EscapingProjection(Vec<Component<'tcx>>),\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n /// Returns all the things that must outlive `'a` for the condition\n /// `ty0: 'a` to hold.\n pub fn outlives_components(&self, ty0: Ty<'tcx>)"}, {"sha": "d1bbe5a173f430b60ecc2c2e3b62049cb5f7c692", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 161, "deletions": 168, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -28,8 +28,8 @@ pub enum Cause {\n     ExistentialRegionBound, // relating an existential region bound\n }\n \n-pub trait TypeRelation<'a,'tcx> : Sized {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n     /// Returns a static string we can use for printouts.\n     fn tag(&self) -> &'static str;\n@@ -45,22 +45,22 @@ pub trait TypeRelation<'a,'tcx> : Sized {\n     }\n \n     /// Generic relation routine suitable for most anything.\n-    fn relate<T:Relate<'a,'tcx>>(&mut self, a: &T, b: &T) -> RelateResult<'tcx, T> {\n+    fn relate<T: Relate<'tcx>>(&mut self, a: &T, b: &T) -> RelateResult<'tcx, T> {\n         Relate::relate(self, a, b)\n     }\n \n     /// Relete elements of two slices pairwise.\n-    fn relate_zip<T:Relate<'a,'tcx>>(&mut self, a: &[T], b: &[T]) -> RelateResult<'tcx, Vec<T>> {\n+    fn relate_zip<T: Relate<'tcx>>(&mut self, a: &[T], b: &[T]) -> RelateResult<'tcx, Vec<T>> {\n         assert_eq!(a.len(), b.len());\n         a.iter().zip(b).map(|(a, b)| self.relate(a, b)).collect()\n     }\n \n     /// Switch variance for the purpose of relating `a` and `b`.\n-    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n-                                               variance: ty::Variance,\n-                                               a: &T,\n-                                               b: &T)\n-                                               -> RelateResult<'tcx, T>;\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             variance: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>;\n \n     // Overrideable relations. You shouldn't typically call these\n     // directly, instead call `relate()`, which in turn calls\n@@ -76,25 +76,24 @@ pub trait TypeRelation<'a,'tcx> : Sized {\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'a,'tcx>;\n+        where T: Relate<'tcx>;\n }\n \n-pub trait Relate<'a,'tcx>: TypeFoldable<'tcx> {\n-    fn relate<R:TypeRelation<'a,'tcx>>(relation: &mut R,\n-                                       a: &Self,\n-                                       b: &Self)\n-                                       -> RelateResult<'tcx, Self>;\n+pub trait Relate<'tcx>: TypeFoldable<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Self, b: &Self)\n+                           -> RelateResult<'tcx, Self>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a;\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // Relate impls\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TypeAndMut<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::TypeAndMut<'tcx>,\n-                 b: &ty::TypeAndMut<'tcx>)\n-                 -> RelateResult<'tcx, ty::TypeAndMut<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::TypeAndMut<'tcx>,\n+                           b: &ty::TypeAndMut<'tcx>)\n+                           -> RelateResult<'tcx, ty::TypeAndMut<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         debug!(\"{}.mts({:?}, {:?})\",\n                relation.tag(),\n@@ -117,12 +116,12 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TypeAndMut<'tcx> {\n // substitutions are not themselves relatable without more context,\n // but they is an important subroutine for things that ARE relatable,\n // like traits etc.\n-fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n-                                    item_def_id: DefId,\n-                                    a_subst: &Substs<'tcx>,\n-                                    b_subst: &Substs<'tcx>)\n-                                    -> RelateResult<'tcx, Substs<'tcx>>\n-    where R: TypeRelation<'a,'tcx>\n+fn relate_item_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n+                                         item_def_id: DefId,\n+                                         a_subst: &Substs<'tcx>,\n+                                         b_subst: &Substs<'tcx>)\n+                                         -> RelateResult<'tcx, Substs<'tcx>>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     debug!(\"substs: item_def_id={:?} a_subst={:?} b_subst={:?}\",\n            item_def_id,\n@@ -139,12 +138,12 @@ fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n     relate_substs(relation, opt_variances, a_subst, b_subst)\n }\n \n-pub fn relate_substs<'a,'tcx:'a,R>(relation: &mut R,\n-                                   variances: Option<&ty::ItemVariances>,\n-                                   a_subst: &Substs<'tcx>,\n-                                   b_subst: &Substs<'tcx>)\n-                                   -> RelateResult<'tcx, Substs<'tcx>>\n-    where R: TypeRelation<'a,'tcx>\n+pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n+                                        variances: Option<&ty::ItemVariances>,\n+                                        a_subst: &Substs<'tcx>,\n+                                        b_subst: &Substs<'tcx>)\n+                                        -> RelateResult<'tcx, Substs<'tcx>>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let mut substs = Substs::empty();\n \n@@ -170,12 +169,12 @@ pub fn relate_substs<'a,'tcx:'a,R>(relation: &mut R,\n     Ok(substs)\n }\n \n-fn relate_type_params<'a,'tcx:'a,R>(relation: &mut R,\n-                                    variances: Option<&[ty::Variance]>,\n-                                    a_tys: &[Ty<'tcx>],\n-                                    b_tys: &[Ty<'tcx>])\n-                                    -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n-    where R: TypeRelation<'a,'tcx>\n+fn relate_type_params<'a, 'gcx, 'tcx, R>(relation: &mut R,\n+                                         variances: Option<&[ty::Variance]>,\n+                                         a_tys: &[Ty<'tcx>],\n+                                         b_tys: &[Ty<'tcx>])\n+                                         -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     if a_tys.len() != b_tys.len() {\n         return Err(TypeError::TyParamSize(expected_found(relation,\n@@ -193,12 +192,12 @@ fn relate_type_params<'a,'tcx:'a,R>(relation: &mut R,\n         .collect()\n }\n \n-fn relate_region_params<'a,'tcx:'a,R>(relation: &mut R,\n-                                      variances: Option<&[ty::Variance]>,\n-                                      a_rs: &[ty::Region],\n-                                      b_rs: &[ty::Region])\n-                                      -> RelateResult<'tcx, Vec<ty::Region>>\n-    where R: TypeRelation<'a,'tcx>\n+fn relate_region_params<'a, 'gcx, 'tcx, R>(relation: &mut R,\n+                                           variances: Option<&[ty::Variance]>,\n+                                           a_rs: &[ty::Region],\n+                                           b_rs: &[ty::Region])\n+                                           -> RelateResult<'tcx, Vec<ty::Region>>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let num_region_params = a_rs.len();\n \n@@ -224,12 +223,12 @@ fn relate_region_params<'a,'tcx:'a,R>(relation: &mut R,\n         .collect()\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BareFnTy<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::BareFnTy<'tcx>,\n-                 b: &ty::BareFnTy<'tcx>)\n-                 -> RelateResult<'tcx, ty::BareFnTy<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::BareFnTy<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::BareFnTy<'tcx>,\n+                           b: &ty::BareFnTy<'tcx>)\n+                           -> RelateResult<'tcx, ty::BareFnTy<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let unsafety = relation.relate(&a.unsafety, &b.unsafety)?;\n         let abi = relation.relate(&a.abi, &b.abi)?;\n@@ -240,12 +239,12 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BareFnTy<'tcx> {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::FnSig<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::FnSig<'tcx>,\n-                 b: &ty::FnSig<'tcx>)\n-                 -> RelateResult<'tcx, ty::FnSig<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::FnSig<'tcx>,\n+                           b: &ty::FnSig<'tcx>)\n+                           -> RelateResult<'tcx, ty::FnSig<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         if a.variadic != b.variadic {\n             return Err(TypeError::VariadicMismatch(\n@@ -272,11 +271,11 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::FnSig<'tcx> {\n     }\n }\n \n-fn relate_arg_vecs<'a,'tcx:'a,R>(relation: &mut R,\n-                                 a_args: &[Ty<'tcx>],\n-                                 b_args: &[Ty<'tcx>])\n-                                 -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n-    where R: TypeRelation<'a,'tcx>\n+fn relate_arg_vecs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n+                                      a_args: &[Ty<'tcx>],\n+                                      b_args: &[Ty<'tcx>])\n+                                      -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     if a_args.len() != b_args.len() {\n         return Err(TypeError::ArgCount);\n@@ -287,12 +286,12 @@ fn relate_arg_vecs<'a,'tcx:'a,R>(relation: &mut R,\n           .collect()\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ast::Unsafety {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ast::Unsafety,\n-                 b: &ast::Unsafety)\n-                 -> RelateResult<'tcx, ast::Unsafety>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ast::Unsafety {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ast::Unsafety,\n+                           b: &ast::Unsafety)\n+                           -> RelateResult<'tcx, ast::Unsafety>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         if a != b {\n             Err(TypeError::UnsafetyMismatch(expected_found(relation, a, b)))\n@@ -302,12 +301,12 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ast::Unsafety {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for abi::Abi {\n-    fn relate<R>(relation: &mut R,\n-                 a: &abi::Abi,\n-                 b: &abi::Abi)\n-                 -> RelateResult<'tcx, abi::Abi>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for abi::Abi {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &abi::Abi,\n+                           b: &abi::Abi)\n+                           -> RelateResult<'tcx, abi::Abi>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         if a == b {\n             Ok(*a)\n@@ -317,12 +316,12 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for abi::Abi {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionTy<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::ProjectionTy<'tcx>,\n-                 b: &ty::ProjectionTy<'tcx>)\n-                 -> RelateResult<'tcx, ty::ProjectionTy<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::ProjectionTy<'tcx>,\n+                           b: &ty::ProjectionTy<'tcx>)\n+                           -> RelateResult<'tcx, ty::ProjectionTy<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         if a.item_name != b.item_name {\n             Err(TypeError::ProjectionNameMismatched(\n@@ -334,25 +333,25 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::ProjectionPredicate<'tcx>,\n-                 b: &ty::ProjectionPredicate<'tcx>)\n-                 -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::ProjectionPredicate<'tcx>,\n+                           b: &ty::ProjectionPredicate<'tcx>)\n+                           -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let projection_ty = relation.relate(&a.projection_ty, &b.projection_ty)?;\n         let ty = relation.relate(&a.ty, &b.ty)?;\n         Ok(ty::ProjectionPredicate { projection_ty: projection_ty, ty: ty })\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &Vec<ty::PolyProjectionPredicate<'tcx>>,\n-                 b: &Vec<ty::PolyProjectionPredicate<'tcx>>)\n-                 -> RelateResult<'tcx, Vec<ty::PolyProjectionPredicate<'tcx>>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &Vec<ty::PolyProjectionPredicate<'tcx>>,\n+                           b: &Vec<ty::PolyProjectionPredicate<'tcx>>)\n+                           -> RelateResult<'tcx, Vec<ty::PolyProjectionPredicate<'tcx>>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         // To be compatible, `a` and `b` must be for precisely the\n         // same set of traits and item names. We always require that\n@@ -369,12 +368,12 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::ExistentialBounds<'tcx>,\n-                 b: &ty::ExistentialBounds<'tcx>)\n-                 -> RelateResult<'tcx, ty::ExistentialBounds<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::ExistentialBounds<'tcx>,\n+                           b: &ty::ExistentialBounds<'tcx>)\n+                           -> RelateResult<'tcx, ty::ExistentialBounds<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let r =\n             relation.with_cause(\n@@ -390,12 +389,12 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ExistentialBounds<'tcx> {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BuiltinBounds {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::BuiltinBounds,\n-                 b: &ty::BuiltinBounds)\n-                 -> RelateResult<'tcx, ty::BuiltinBounds>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::BuiltinBounds {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::BuiltinBounds,\n+                           b: &ty::BuiltinBounds)\n+                           -> RelateResult<'tcx, ty::BuiltinBounds>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         // Two sets of builtin bounds are only relatable if they are\n         // precisely the same (but see the coercion code).\n@@ -407,12 +406,12 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TraitRef<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::TraitRef<'tcx>,\n-                 b: &ty::TraitRef<'tcx>)\n-                 -> RelateResult<'tcx, ty::TraitRef<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::TraitRef<'tcx>,\n+                           b: &ty::TraitRef<'tcx>)\n+                           -> RelateResult<'tcx, ty::TraitRef<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         // Different traits cannot be related\n         if a.def_id != b.def_id {\n@@ -424,12 +423,12 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TraitRef<'tcx> {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for Ty<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &Ty<'tcx>,\n-                 b: &Ty<'tcx>)\n-                 -> RelateResult<'tcx, Ty<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &Ty<'tcx>,\n+                           b: &Ty<'tcx>)\n+                           -> RelateResult<'tcx, Ty<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.tys(a, b)\n     }\n@@ -438,11 +437,11 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for Ty<'tcx> {\n /// The main \"type relation\" routine. Note that this does not handle\n /// inference artifacts, so you should filter those out before calling\n /// it.\n-pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n-                                      a: Ty<'tcx>,\n-                                      b: Ty<'tcx>)\n-                                      -> RelateResult<'tcx, Ty<'tcx>>\n-    where R: TypeRelation<'a,'tcx>\n+pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n+                                           a: Ty<'tcx>,\n+                                           b: Ty<'tcx>)\n+                                           -> RelateResult<'tcx, Ty<'tcx>>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let tcx = relation.tcx();\n     let a_sty = &a.sty;\n@@ -588,12 +587,12 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ClosureSubsts<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::ClosureSubsts<'tcx>,\n-                 b: &ty::ClosureSubsts<'tcx>)\n-                 -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::ClosureSubsts<'tcx>,\n+                           b: &ty::ClosureSubsts<'tcx>)\n+                           -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let func_substs = relate_substs(relation, None, a.func_substs, b.func_substs)?;\n         let upvar_tys = relation.relate_zip(&a.upvar_tys, &b.upvar_tys)?;\n@@ -602,64 +601,58 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ClosureSubsts<'tcx> {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for Substs<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &Substs<'tcx>,\n-                 b: &Substs<'tcx>)\n-                 -> RelateResult<'tcx, Substs<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for Substs<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &Substs<'tcx>,\n+                           b: &Substs<'tcx>)\n+                           -> RelateResult<'tcx, Substs<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relate_substs(relation, None, a, b)\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::Region {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::Region,\n-                 b: &ty::Region)\n-                 -> RelateResult<'tcx, ty::Region>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::Region {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::Region,\n+                           b: &ty::Region)\n+                           -> RelateResult<'tcx, ty::Region>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.regions(*a, *b)\n     }\n }\n \n-impl<'a,'tcx:'a,T> Relate<'a,'tcx> for ty::Binder<T>\n-    where T: Relate<'a,'tcx>\n-{\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::Binder<T>,\n-                 b: &ty::Binder<T>)\n-                 -> RelateResult<'tcx, ty::Binder<T>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<T> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::Binder<T>,\n+                           b: &ty::Binder<T>)\n+                           -> RelateResult<'tcx, ty::Binder<T>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.binders(a, b)\n     }\n }\n \n-impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Rc<T>\n-    where T: Relate<'a,'tcx>\n-{\n-    fn relate<R>(relation: &mut R,\n-                 a: &Rc<T>,\n-                 b: &Rc<T>)\n-                 -> RelateResult<'tcx, Rc<T>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Rc<T> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &Rc<T>,\n+                           b: &Rc<T>)\n+                           -> RelateResult<'tcx, Rc<T>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let a: &T = a;\n         let b: &T = b;\n         Ok(Rc::new(relation.relate(a, b)?))\n     }\n }\n \n-impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Box<T>\n-    where T: Relate<'a,'tcx>\n-{\n-    fn relate<R>(relation: &mut R,\n-                 a: &Box<T>,\n-                 b: &Box<T>)\n-                 -> RelateResult<'tcx, Box<T>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Box<T> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &Box<T>,\n+                           b: &Box<T>)\n+                           -> RelateResult<'tcx, Box<T>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let a: &T = a;\n         let b: &T = b;\n@@ -670,11 +663,11 @@ impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Box<T>\n ///////////////////////////////////////////////////////////////////////////\n // Error handling\n \n-pub fn expected_found<'a,'tcx:'a,R,T>(relation: &mut R,\n-                                      a: &T,\n-                                      b: &T)\n-                                      -> ExpectedFound<T>\n-    where R: TypeRelation<'a,'tcx>, T: Clone\n+pub fn expected_found<'a, 'gcx, 'tcx, R, T>(relation: &mut R,\n+                                            a: &T,\n+                                            b: &T)\n+                                            -> ExpectedFound<T>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>, T: Clone, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     expected_found_bool(relation.a_is_expected(), a, b)\n }"}, {"sha": "4f8e172d49fea117ec55f987c33cdefbe353036a", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 153, "deletions": 65, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use infer::type_variable;\n use ty::subst::{self, VecPerParamSpace};\n-use traits;\n use ty::{self, Lift, TraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n@@ -24,14 +24,31 @@ use hir;\n \n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     type Lifted = (A::Lifted, B::Lifted);\n-    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.0).and_then(|a| tcx.lift(&self.1).map(|b| (a, b)))\n     }\n }\n \n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n+    type Lifted = Option<T::Lifted>;\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        self.as_ref().map(|x| tcx.lift(x))\n+    }\n+}\n+\n+impl<'tcx, T: Lift<'tcx>, E: Lift<'tcx>> Lift<'tcx> for Result<T, E> {\n+    type Lifted = Result<T::Lifted, E::Lifted>;\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            Ok(ref x) => tcx.lift(x).map(Ok),\n+            Err(ref e) => tcx.lift(e).map(Err)\n+        }\n+    }\n+}\n+\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     type Lifted = Vec<T::Lifted>;\n-    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         // type annotation needed to inform `projection_must_outlive`\n         let mut result : Vec<<T as Lift<'tcx>>::Lifted>\n             = Vec::with_capacity(self.len());\n@@ -55,7 +72,7 @@ impl<'tcx> Lift<'tcx> for ty::Region {\n \n impl<'a, 'tcx> Lift<'tcx> for TraitRef<'a> {\n     type Lifted = TraitRef<'tcx>;\n-    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> Option<TraitRef<'tcx>> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<TraitRef<'tcx>> {\n         tcx.lift(&self.substs).map(|substs| TraitRef {\n             def_id: self.def_id,\n             substs: substs\n@@ -65,7 +82,8 @@ impl<'a, 'tcx> Lift<'tcx> for TraitRef<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n-    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+                             -> Option<ty::TraitPredicate<'tcx>> {\n         tcx.lift(&self.trait_ref).map(|trait_ref| ty::TraitPredicate {\n             trait_ref: trait_ref\n         })\n@@ -74,22 +92,23 @@ impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::EquatePredicate<'a> {\n     type Lifted = ty::EquatePredicate<'tcx>;\n-    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> Option<ty::EquatePredicate<'tcx>> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+                             -> Option<ty::EquatePredicate<'tcx>> {\n         tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::EquatePredicate(a, b))\n     }\n }\n \n impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n     type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n-    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     type Lifted = ty::ProjectionPredicate<'tcx>;\n-    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx, 'tcx>)\n-                       -> Option<ty::ProjectionPredicate<'tcx>> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+                             -> Option<ty::ProjectionPredicate<'tcx>> {\n         tcx.lift(&(self.projection_ty.trait_ref, self.ty)).map(|(trait_ref, ty)| {\n             ty::ProjectionPredicate {\n                 projection_ty: ty::ProjectionTy {\n@@ -104,11 +123,82 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n-    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.0).map(|x| ty::Binder(x))\n     }\n }\n \n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n+    type Lifted = ty::error::ExpectedFound<T::Lifted>;\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.expected).and_then(|expected| {\n+            tcx.lift(&self.found).map(|found| {\n+                ty::error::ExpectedFound {\n+                    expected: expected,\n+                    found: found\n+                }\n+            })\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for type_variable::Default<'a> {\n+    type Lifted = type_variable::Default<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.ty).map(|ty| {\n+            type_variable::Default {\n+                ty: ty,\n+                origin_span: self.origin_span,\n+                def_id: self.def_id\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n+    type Lifted = ty::error::TypeError<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        use ty::error::TypeError::*;\n+\n+        Some(match *self {\n+            Mismatch => Mismatch,\n+            UnsafetyMismatch(x) => UnsafetyMismatch(x),\n+            AbiMismatch(x) => AbiMismatch(x),\n+            Mutability => Mutability,\n+            BoxMutability => BoxMutability,\n+            PtrMutability => PtrMutability,\n+            RefMutability => RefMutability,\n+            VecMutability => VecMutability,\n+            TupleSize(x) => TupleSize(x),\n+            FixedArraySize(x) => FixedArraySize(x),\n+            TyParamSize(x) => TyParamSize(x),\n+            ArgCount => ArgCount,\n+            RegionsDoesNotOutlive(a, b) => RegionsDoesNotOutlive(a, b),\n+            RegionsNotSame(a, b) => RegionsNotSame(a, b),\n+            RegionsNoOverlap(a, b) => RegionsNoOverlap(a, b),\n+            RegionsInsufficientlyPolymorphic(a, b) => {\n+                RegionsInsufficientlyPolymorphic(a, b)\n+            }\n+            RegionsOverlyPolymorphic(a, b) => RegionsOverlyPolymorphic(a, b),\n+            IntegerAsChar => IntegerAsChar,\n+            IntMismatch(x) => IntMismatch(x),\n+            FloatMismatch(x) => FloatMismatch(x),\n+            Traits(x) => Traits(x),\n+            BuiltinBoundsMismatch(x) => BuiltinBoundsMismatch(x),\n+            VariadicMismatch(x) => VariadicMismatch(x),\n+            CyclicTy => CyclicTy,\n+            ConvergenceMismatch(x) => ConvergenceMismatch(x),\n+            ProjectionNameMismatched(x) => ProjectionNameMismatched(x),\n+            ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n+\n+            Sorts(ref x) => return tcx.lift(x).map(Sorts),\n+            TyParamDefaultMismatch(ref x) => {\n+                return tcx.lift(x).map(TyParamDefaultMismatch)\n+            }\n+        })\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n //\n@@ -124,7 +214,7 @@ macro_rules! CopyImpls {\n     ($($ty:ty),+) => {\n         $(\n             impl<'tcx> TypeFoldable<'tcx> for $ty {\n-                fn super_fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> $ty {\n+                fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> $ty {\n                     *self\n                 }\n \n@@ -139,7 +229,7 @@ macro_rules! CopyImpls {\n CopyImpls! { (), hir::Unsafety, abi::Abi }\n \n impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> (T, U) {\n         (self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n \n@@ -149,7 +239,7 @@ impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Option<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         self.as_ref().map(|t| t.fold_with(folder))\n     }\n \n@@ -159,7 +249,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Option<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         Rc::new((**self).fold_with(folder))\n     }\n \n@@ -169,7 +259,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let content: T = (**self).fold_with(folder);\n         box content\n     }\n@@ -180,7 +270,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n \n@@ -190,11 +280,11 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n }\n \n impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::Binder(self.0.fold_with(folder))\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_binder(self)\n     }\n \n@@ -208,7 +298,7 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for P<[T]> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n \n@@ -218,7 +308,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for P<[T]> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         self.map(|elem| elem.fold_with(folder))\n     }\n \n@@ -228,7 +318,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TraitTy<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TraitTy {\n             principal: self.principal.fold_with(folder),\n             bounds: self.bounds.fold_with(folder),\n@@ -241,7 +331,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitTy<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let sty = match self.sty {\n             ty::TyBox(typ) => ty::TyBox(typ.fold_with(folder)),\n             ty::TyRawPtr(ref tm) => ty::TyRawPtr(tm.fold_with(folder)),\n@@ -283,7 +373,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n         folder.tcx().mk_ty(sty)\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_ty(*self)\n     }\n \n@@ -316,13 +406,13 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::BareFnTy<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::BareFnTy { sig: self.sig.fold_with(folder),\n                        abi: self.abi,\n                        unsafety: self.unsafety }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_bare_fn_ty(self)\n     }\n \n@@ -332,15 +422,15 @@ impl<'tcx> TypeFoldable<'tcx> for ty::BareFnTy<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureTy<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n        ty::ClosureTy {\n             sig: self.sig.fold_with(folder),\n             unsafety: self.unsafety,\n             abi: self.abi,\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_closure_ty(self)\n     }\n \n@@ -350,11 +440,11 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureTy<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TypeAndMut { ty: self.ty.fold_with(folder), mutbl: self.mutbl }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_mt(self)\n     }\n \n@@ -364,14 +454,14 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::FnOutput<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             ty::FnConverging(ref ty) => ty::FnConverging(ty.fold_with(folder)),\n             ty::FnDiverging => ty::FnDiverging\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_output(self)\n     }\n \n@@ -384,13 +474,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::FnOutput<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::FnSig { inputs: self.inputs.fold_with(folder),\n                     output: self.output.fold_with(folder),\n                     variadic: self.variadic }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_fn_sig(self)\n     }\n \n@@ -400,15 +490,15 @@ impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let substs = self.substs.fold_with(folder);\n         ty::TraitRef {\n             def_id: self.def_id,\n             substs: folder.tcx().mk_substs(substs),\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_trait_ref(self)\n     }\n \n@@ -418,7 +508,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ImplHeader {\n             impl_def_id: self.impl_def_id,\n             self_ty: self.self_ty.fold_with(folder),\n@@ -427,7 +517,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_impl_header(self)\n     }\n \n@@ -439,11 +529,11 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n         *self\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_region(*self)\n     }\n \n@@ -457,12 +547,12 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         subst::Substs { regions: self.regions.fold_with(folder),\n                         types: self.types.fold_with(folder) }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_substs(self)\n     }\n \n@@ -472,7 +562,7 @@ impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let func_substs = self.func_substs.fold_with(folder);\n         ty::ClosureSubsts {\n             func_substs: folder.tcx().mk_substs(func_substs),\n@@ -486,7 +576,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ItemSubsts {\n             substs: self.substs.fold_with(folder),\n         }\n@@ -498,7 +588,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             ty::adjustment::AutoPtr(r, m) => {\n                 let r = r.fold_with(folder);\n@@ -508,7 +598,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_autoref(self)\n     }\n \n@@ -521,7 +611,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n         *self\n     }\n \n@@ -531,15 +621,15 @@ impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ExistentialBounds {\n             region_bound: self.region_bound.fold_with(folder),\n             builtin_bounds: self.builtin_bounds,\n             projection_bounds: self.projection_bounds.fold_with(folder),\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_existential_bounds(self)\n     }\n \n@@ -549,7 +639,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TypeParameterDef {\n             name: self.name,\n             def_id: self.def_id,\n@@ -568,7 +658,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             ty::ObjectLifetimeDefault::Ambiguous =>\n                 ty::ObjectLifetimeDefault::Ambiguous,\n@@ -590,7 +680,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::RegionParameterDef {\n             name: self.name,\n             def_id: self.def_id,\n@@ -606,7 +696,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::Generics {\n             types: self.types.fold_with(folder),\n             regions: self.regions.fold_with(folder),\n@@ -619,7 +709,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::GenericPredicates {\n             predicates: self.predicates.fold_with(folder),\n         }\n@@ -631,7 +721,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             ty::Predicate::Trait(ref a) =>\n                 ty::Predicate::Trait(a.fold_with(folder)),\n@@ -670,7 +760,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ProjectionPredicate {\n             projection_ty: self.projection_ty.fold_with(folder),\n             ty: self.ty.fold_with(folder),\n@@ -683,7 +773,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ProjectionTy {\n             trait_ref: self.trait_ref.fold_with(folder),\n             item_name: self.item_name,\n@@ -696,7 +786,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::InstantiatedPredicates {\n             predicates: self.predicates.fold_with(folder),\n         }\n@@ -708,7 +798,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::EquatePredicate(self.0.fold_with(folder),\n                             self.1.fold_with(folder))\n     }\n@@ -719,7 +809,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TraitPredicate {\n             trait_ref: self.trait_ref.fold_with(folder)\n         }\n@@ -734,7 +824,7 @@ impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n     where T : TypeFoldable<'tcx>,\n           U : TypeFoldable<'tcx>,\n {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::OutlivesPredicate(self.0.fold_with(folder),\n                               self.1.fold_with(folder))\n     }\n@@ -745,7 +835,7 @@ impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ClosureUpvar {\n             def: self.def,\n             span: self.span,\n@@ -759,13 +849,11 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'tcx> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ParameterEnvironment {\n             free_substs: self.free_substs.fold_with(folder),\n             implicit_region_bound: self.implicit_region_bound.fold_with(folder),\n             caller_bounds: self.caller_bounds.fold_with(folder),\n-            selection_cache: traits::SelectionCache::new(),\n-            evaluation_cache: traits::EvaluationCache::new(),\n             free_id_outlive: self.free_id_outlive,\n         }\n     }\n@@ -778,7 +866,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TypeScheme<'tcx>  {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TypeScheme {\n             generics: self.generics.fold_with(folder),\n             ty: self.ty.fold_with(folder),"}, {"sha": "da1eedb66348ad01cf329449cb0969cce6e24c40", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -270,7 +270,7 @@ pub struct TraitTy<'tcx> {\n     pub bounds: ExistentialBounds<'tcx>,\n }\n \n-impl<'a, 'tcx> TraitTy<'tcx> {\n+impl<'a, 'gcx, 'tcx> TraitTy<'tcx> {\n     pub fn principal_def_id(&self) -> DefId {\n         self.principal.0.def_id\n     }\n@@ -279,7 +279,7 @@ impl<'a, 'tcx> TraitTy<'tcx> {\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self-type. A common choice is `mk_err()`\n     /// or some skolemized type.\n-    pub fn principal_trait_ref_with_self_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn principal_trait_ref_with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                             self_ty: Ty<'tcx>)\n                                             -> ty::PolyTraitRef<'tcx>\n     {\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> TraitTy<'tcx> {\n         })\n     }\n \n-    pub fn projection_bounds_with_self_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn projection_bounds_with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                           self_ty: Ty<'tcx>)\n                                           -> Vec<ty::PolyProjectionPredicate<'tcx>>\n     {\n@@ -521,7 +521,7 @@ pub struct ParamTy {\n     pub name: Name,\n }\n \n-impl<'a, 'tcx> ParamTy {\n+impl<'a, 'gcx, 'tcx> ParamTy {\n     pub fn new(space: subst::ParamSpace,\n                index: u32,\n                name: Name)\n@@ -537,7 +537,7 @@ impl<'a, 'tcx> ParamTy {\n         ParamTy::new(def.space, def.index, def.name)\n     }\n \n-    pub fn to_ty(self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         tcx.mk_param(self.space, self.idx, self.name)\n     }\n \n@@ -762,7 +762,7 @@ impl<'tcx> ExistentialBounds<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct BuiltinBounds(EnumSet<BuiltinBound>);\n \n-impl<'a, 'tcx> BuiltinBounds {\n+impl<'a, 'gcx, 'tcx> BuiltinBounds {\n     pub fn empty() -> BuiltinBounds {\n         BuiltinBounds(EnumSet::new())\n     }\n@@ -771,7 +771,7 @@ impl<'a, 'tcx> BuiltinBounds {\n         self.into_iter()\n     }\n \n-    pub fn to_predicates(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn to_predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                          self_ty: Ty<'tcx>)\n                          -> Vec<ty::Predicate<'tcx>> {\n         self.iter().filter_map(|builtin_bound|\n@@ -819,7 +819,7 @@ impl CLike for BuiltinBound {\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn try_add_builtin_trait(self,\n                                  trait_def_id: DefId,\n                                  builtin_bounds: &mut EnumSet<BuiltinBound>)\n@@ -884,7 +884,7 @@ impl Region {\n }\n \n // Type utilities\n-impl<'a, 'tcx> TyS<'tcx> {\n+impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     pub fn as_opt_param_ty(&self) -> Option<ty::ParamTy> {\n         match self.sty {\n             ty::TyParam(ref d) => Some(d.clone()),\n@@ -971,15 +971,15 @@ impl<'a, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn sequence_element_type(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn sequence_element_type(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyArray(ty, _) | TySlice(ty) => ty,\n             TyStr => tcx.mk_mach_uint(ast::UintTy::U8),\n             _ => bug!(\"sequence_element_type called on non-sequence value: {}\", self),\n         }\n     }\n \n-    pub fn simd_type(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn simd_type(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyStruct(def, substs) => {\n                 def.struct_variant().fields[0].ty(tcx, substs)"}, {"sha": "462e809be2a38b467acb7223b3965b78591ca2de", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -36,7 +36,7 @@ pub struct Substs<'tcx> {\n     pub regions: VecPerParamSpace<ty::Region>,\n }\n \n-impl<'a, 'tcx> Substs<'tcx> {\n+impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     pub fn new(t: VecPerParamSpace<Ty<'tcx>>,\n                r: VecPerParamSpace<ty::Region>)\n                -> Substs<'tcx>\n@@ -122,7 +122,7 @@ impl<'a, 'tcx> Substs<'tcx> {\n     }\n \n     /// Creates a trait-ref out of this substs, ignoring the FnSpace substs\n-    pub fn to_trait_ref(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_id: DefId)\n+    pub fn to_trait_ref(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, trait_id: DefId)\n                         -> ty::TraitRef<'tcx> {\n         let Substs { mut types, mut regions } = self.clone();\n         types.truncate(FnSpace, 0);\n@@ -532,21 +532,22 @@ impl<'a,T> IntoIterator for &'a VecPerParamSpace<T> {\n // there is more information available (for better errors).\n \n pub trait Subst<'tcx> : Sized {\n-    fn subst<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, substs: &Substs<'tcx>) -> Self {\n+    fn subst<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                      substs: &Substs<'tcx>) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n-    fn subst_spanned<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         substs: &Substs<'tcx>,\n-                         span: Option<Span>)\n-                         -> Self;\n+    fn subst_spanned<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                               substs: &Substs<'tcx>,\n+                               span: Option<Span>)\n+                               -> Self;\n }\n \n impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n-    fn subst_spanned<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         substs: &Substs<'tcx>,\n-                         span: Option<Span>)\n-                         -> T\n+    fn subst_spanned<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                               substs: &Substs<'tcx>,\n+                               span: Option<Span>)\n+                               -> T\n     {\n         let mut folder = SubstFolder { tcx: tcx,\n                                        substs: substs,\n@@ -561,8 +562,8 @@ impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n ///////////////////////////////////////////////////////////////////////////\n // The actual substitution engine itself is a type folder.\n \n-struct SubstFolder<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct SubstFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     substs: &'a Substs<'tcx>,\n \n     // The location for which the substitution is performed, if available.\n@@ -578,8 +579,8 @@ struct SubstFolder<'a, 'tcx: 'a> {\n     region_binders_passed: u32,\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.tcx }\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.region_binders_passed += 1;\n@@ -649,7 +650,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n     }\n }\n \n-impl<'a,'tcx> SubstFolder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n         let opt_ty = self.substs.types.opt_get(p.space, p.idx as usize);"}, {"sha": "a76dfc35dc1d3897ed10589c949d19ea20a57fa5", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -73,7 +73,7 @@ pub struct TraitDef<'tcx> {\n     pub flags: Cell<TraitFlags>\n }\n \n-impl<'a, 'tcx> TraitDef<'tcx> {\n+impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n     pub fn new(unsafety: hir::Unsafety,\n                paren_sugar: bool,\n                generics: ty::Generics<'tcx>,\n@@ -117,18 +117,18 @@ impl<'a, 'tcx> TraitDef<'tcx> {\n         );\n     }\n \n-    fn write_trait_impls(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    fn write_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n         tcx.dep_graph.write(DepNode::TraitImpls(self.trait_ref.def_id));\n     }\n \n-    fn read_trait_impls(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    fn read_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n         tcx.dep_graph.read(DepNode::TraitImpls(self.trait_ref.def_id));\n     }\n \n     /// Records a basic trait-to-implementation mapping.\n     ///\n     /// Returns `true` iff the impl has not previously been recorded.\n-    fn record_impl(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn record_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                    impl_def_id: DefId,\n                    impl_trait_ref: TraitRef<'tcx>)\n                    -> bool {\n@@ -163,7 +163,7 @@ impl<'a, 'tcx> TraitDef<'tcx> {\n     }\n \n     /// Records a trait-to-implementation mapping for a crate-local impl.\n-    pub fn record_local_impl(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn record_local_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                              impl_def_id: DefId,\n                              impl_trait_ref: TraitRef<'tcx>) {\n         assert!(impl_def_id.is_local());\n@@ -176,7 +176,7 @@ impl<'a, 'tcx> TraitDef<'tcx> {\n     /// The `parent_impl` is the immediately-less-specialized impl, or the\n     /// trait's def ID if the impl is not a specialization -- information that\n     /// should be pulled from the metadata.\n-    pub fn record_remote_impl(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn record_remote_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                               impl_def_id: DefId,\n                               impl_trait_ref: TraitRef<'tcx>,\n                               parent_impl: DefId) {\n@@ -195,7 +195,7 @@ impl<'a, 'tcx> TraitDef<'tcx> {\n     /// overlap information if the impl overlaps but does not specialize an\n     /// existing impl.\n     pub fn add_impl_for_specialization(&self,\n-                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                        impl_def_id: DefId)\n                                        -> Result<(), traits::OverlapError> {\n         assert!(impl_def_id.is_local());\n@@ -208,7 +208,7 @@ impl<'a, 'tcx> TraitDef<'tcx> {\n         specialization_graph::ancestors(self, of_impl)\n     }\n \n-    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, mut f: F) {\n+    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, mut f: F) {\n         self.read_trait_impls(tcx);\n         tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n \n@@ -226,7 +226,7 @@ impl<'a, 'tcx> TraitDef<'tcx> {\n     /// Iterate over every impl that could possibly match the\n     /// self-type `self_ty`.\n     pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n-                                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                    self_ty: Ty<'tcx>,\n                                                    mut f: F)\n     {"}, {"sha": "88ebb332354b5c055f69e49f9da7c568556da0b6", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -171,7 +171,7 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn pat_contains_ref_binding(self, pat: &hir::Pat) -> Option<hir::Mutability> {\n         pat_util::pat_contains_ref_binding(&self.def_map, pat)\n     }\n@@ -338,8 +338,9 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         helper(self, ty, svh, &mut state);\n         return state.finish();\n \n-        fn helper<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>, svh: &Svh,\n-                        state: &mut SipHasher) {\n+        fn helper<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                  ty: Ty<'tcx>, svh: &Svh,\n+                                  state: &mut SipHasher) {\n             macro_rules! byte { ($b:expr) => { ($b as u8).hash(state) } }\n             macro_rules! hash { ($e:expr) => { $e.hash(state) }  }\n "}, {"sha": "a25994ea69981f23dc7f9eb1cc0bd764c48b2c2b", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -25,11 +25,11 @@ use util::common::ErrorReported;\n /// inference variable, returns `None`, because we are not able to\n /// make any progress at all. This is to prevent \"livelock\" where we\n /// say \"$0 is WF if $0 is WF\".\n-pub fn obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n-                            body_id: ast::NodeId,\n-                            ty: Ty<'tcx>,\n-                            span: Span)\n-                            -> Option<Vec<traits::PredicateObligation<'tcx>>>\n+pub fn obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                   body_id: ast::NodeId,\n+                                   ty: Ty<'tcx>,\n+                                   span: Span)\n+                                   -> Option<Vec<traits::PredicateObligation<'tcx>>>\n {\n     let mut wf = WfPredicates { infcx: infcx,\n                                 body_id: body_id,\n@@ -49,22 +49,22 @@ pub fn obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n /// well-formed.  For example, if there is a trait `Set` defined like\n /// `trait Set<K:Eq>`, then the trait reference `Foo: Set<Bar>` is WF\n /// if `Bar: Eq`.\n-pub fn trait_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n-                                  body_id: ast::NodeId,\n-                                  trait_ref: &ty::TraitRef<'tcx>,\n-                                  span: Span)\n-                                  -> Vec<traits::PredicateObligation<'tcx>>\n+pub fn trait_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                         body_id: ast::NodeId,\n+                                         trait_ref: &ty::TraitRef<'tcx>,\n+                                         span: Span)\n+                                         -> Vec<traits::PredicateObligation<'tcx>>\n {\n     let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span, out: vec![] };\n     wf.compute_trait_ref(trait_ref);\n     wf.normalize()\n }\n \n-pub fn predicate_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n-                                      body_id: ast::NodeId,\n-                                      predicate: &ty::Predicate<'tcx>,\n-                                      span: Span)\n-                                      -> Vec<traits::PredicateObligation<'tcx>>\n+pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             body_id: ast::NodeId,\n+                                             predicate: &ty::Predicate<'tcx>,\n+                                             span: Span)\n+                                             -> Vec<traits::PredicateObligation<'tcx>>\n {\n     let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span, out: vec![] };\n \n@@ -123,8 +123,8 @@ pub enum ImpliedBound<'tcx> {\n /// Compute the implied bounds that a callee/impl can assume based on\n /// the fact that caller/projector has ensured that `ty` is WF.  See\n /// the `ImpliedBound` type for more details.\n-pub fn implied_bounds<'a, 'tcx>(\n-    infcx: &'a InferCtxt<'a, 'tcx, 'tcx>,\n+pub fn implied_bounds<'a, 'gcx, 'tcx>(\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     body_id: ast::NodeId,\n     ty: Ty<'tcx>,\n     span: Span)\n@@ -227,14 +227,14 @@ fn implied_bounds_from_components<'tcx>(sub_region: ty::Region,\n         .collect()\n }\n \n-struct WfPredicates<'a,'tcx:'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx, 'tcx>,\n+struct WfPredicates<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     body_id: ast::NodeId,\n     span: Span,\n     out: Vec<traits::PredicateObligation<'tcx>>,\n }\n \n-impl<'a,'tcx> WfPredicates<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n     }\n@@ -525,8 +525,8 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n /// they declare `trait SomeTrait : 'static`, for example, then\n /// `'static` would appear in the list. The hard work is done by\n /// `ty::required_region_bounds`, see that for more information.\n-pub fn object_region_bounds<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     principal: &ty::PolyTraitRef<'tcx>,\n     others: ty::BuiltinBounds)\n     -> Vec<ty::Region>"}, {"sha": "7464713c66d04998bfffc3acb6c03031c75251ad", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -18,6 +18,7 @@ use ty::{TyParam, TyRawPtr, TyRef, TyTuple};\n use ty::TyClosure;\n use ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::fold::{TypeFolder, TypeVisitor};\n \n use std::cell::Cell;\n use std::fmt;\n@@ -293,11 +294,11 @@ fn in_binder<'a, 'tcx, T, U>(f: &mut fmt::Formatter,\n struct TraitAndProjections<'tcx>(ty::TraitRef<'tcx>, Vec<ty::ProjectionPredicate<'tcx>>);\n \n impl<'tcx> TypeFoldable<'tcx> for TraitAndProjections<'tcx> {\n-    fn super_fold_with<F:ty::fold::TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         TraitAndProjections(self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n \n-    fn super_visit_with<V: ty::fold::TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.0.visit_with(visitor) || self.1.visit_with(visitor)\n     }\n }"}, {"sha": "432cf89606573e9199d441b7ea08b30693d89758", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f72d8127fd91911b80b8b8b9e0f51f6e001d748/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=8f72d8127fd91911b80b8b8b9e0f51f6e001d748", "patch": "@@ -480,7 +480,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx, 'tcx> {\n+impl<'cx, 'tcx> TypeFolder<'tcx, 'tcx> for Resolver<'cx, 'tcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n     }"}]}