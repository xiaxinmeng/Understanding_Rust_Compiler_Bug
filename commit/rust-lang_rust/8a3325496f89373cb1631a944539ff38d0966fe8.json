{"sha": "8a3325496f89373cb1631a944539ff38d0966fe8", "node_id": "C_kwDOAAsO6NoAKDhhMzMyNTQ5NmY4OTM3M2NiMTYzMWE5NDQ1MzlmZjM4ZDA5NjZmZTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-11T20:32:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-11T20:32:06Z"}, "message": "Auto merge of #96978 - lqd:win_pgo2, r=Mark-Simulacrum\n\nUtilize PGO for windows x64 rustc dist builds\n\nThis PR adds PGO support for the CI x64 windows dist builds.\n\nThese are the results from running the rustc-perf benchmarks:\n![image](https://user-images.githubusercontent.com/247183/177662869-683a8034-7c95-42bf-9900-9ffd66677fcf.png)\n\nThanks to `@Kobzol,` `@michaelwoerister,` `@wesleywiser,` `@Mark-Simulacrum` for their precious help.", "tree": {"sha": "f9497dad9882cf4d9edce7b8514caa74a4da04e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9497dad9882cf4d9edce7b8514caa74a4da04e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a3325496f89373cb1631a944539ff38d0966fe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a3325496f89373cb1631a944539ff38d0966fe8", "html_url": "https://github.com/rust-lang/rust/commit/8a3325496f89373cb1631a944539ff38d0966fe8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a3325496f89373cb1631a944539ff38d0966fe8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38b72154ded23847cd08a796d0c6708b5efac265", "url": "https://api.github.com/repos/rust-lang/rust/commits/38b72154ded23847cd08a796d0c6708b5efac265", "html_url": "https://github.com/rust-lang/rust/commit/38b72154ded23847cd08a796d0c6708b5efac265"}, {"sha": "9027f825360a83a5f632d8317e96c5440a83ebc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9027f825360a83a5f632d8317e96c5440a83ebc0", "html_url": "https://github.com/rust-lang/rust/commit/9027f825360a83a5f632d8317e96c5440a83ebc0"}], "stats": {"total": 245, "additions": 190, "deletions": 55}, "files": [{"sha": "6d9e249ee44ef14442a862a58ae787feb77a5bbd", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3325496f89373cb1631a944539ff38d0966fe8/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8a3325496f89373cb1631a944539ff38d0966fe8/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=8a3325496f89373cb1631a944539ff38d0966fe8", "patch": "@@ -410,7 +410,7 @@ jobs:\n           - name: dist-x86_64-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n-              SCRIPT: python x.py dist\n+              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc src/ci/pgo.sh python x.py dist\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl\n           - name: dist-i686-msvc"}, {"sha": "3d678b2290d1c7dd3f8983394e0dbb524bb195c7", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8a3325496f89373cb1631a944539ff38d0966fe8/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3325496f89373cb1631a944539ff38d0966fe8/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=8a3325496f89373cb1631a944539ff38d0966fe8", "patch": "@@ -25,6 +25,7 @@ use crate::config::{LlvmLibunwind, TargetSelection};\n use crate::dist;\n use crate::native;\n use crate::tool::SourceType;\n+use crate::util::get_clang_cl_resource_dir;\n use crate::util::{exe, is_debug_info, is_dylib, output, symlink_dir, t, up_to_date};\n use crate::LLVM_TOOLS;\n use crate::{CLang, Compiler, DependencyType, GitRepo, Mode};\n@@ -772,10 +773,38 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetS\n         if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n             cargo.env(\"CFG_LLVM_ROOT\", s);\n         }\n-        // Some LLVM linker flags (-L and -l) may be needed to link rustc_llvm.\n+\n+        // Some LLVM linker flags (-L and -l) may be needed to link `rustc_llvm`. Its build script\n+        // expects these to be passed via the `LLVM_LINKER_FLAGS` env variable, separated by\n+        // whitespace.\n+        //\n+        // For example:\n+        // - on windows, when `clang-cl` is used with instrumentation, we need to manually add\n+        // clang's runtime library resource directory so that the profiler runtime library can be\n+        // found. This is to avoid the linker errors about undefined references to\n+        // `__llvm_profile_instrument_memop` when linking `rustc_driver`.\n+        let mut llvm_linker_flags = String::new();\n+        if builder.config.llvm_profile_generate && target.contains(\"msvc\") {\n+            if let Some(ref clang_cl_path) = builder.config.llvm_clang_cl {\n+                // Add clang's runtime library directory to the search path\n+                let clang_rt_dir = get_clang_cl_resource_dir(clang_cl_path);\n+                llvm_linker_flags.push_str(&format!(\"-L{}\", clang_rt_dir.display()));\n+            }\n+        }\n+\n+        // The config can also specify its own llvm linker flags.\n         if let Some(ref s) = builder.config.llvm_ldflags {\n-            cargo.env(\"LLVM_LINKER_FLAGS\", s);\n+            if !llvm_linker_flags.is_empty() {\n+                llvm_linker_flags.push_str(\" \");\n+            }\n+            llvm_linker_flags.push_str(s);\n+        }\n+\n+        // Set the linker flags via the env var that `rustc_llvm`'s build script will read.\n+        if !llvm_linker_flags.is_empty() {\n+            cargo.env(\"LLVM_LINKER_FLAGS\", llvm_linker_flags);\n         }\n+\n         // Building with a static libstdc++ is only supported on linux right now,\n         // not for MSVC or macOS\n         if builder.config.llvm_static_stdcpp"}, {"sha": "01e70b3fb2dd787194f5e1a8ce2bb73c2e479277", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a3325496f89373cb1631a944539ff38d0966fe8/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3325496f89373cb1631a944539ff38d0966fe8/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=8a3325496f89373cb1631a944539ff38d0966fe8", "patch": "@@ -18,6 +18,7 @@ use std::process::Command;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::config::TargetSelection;\n+use crate::util::get_clang_cl_resource_dir;\n use crate::util::{self, exe, output, program_out_of_date, t, up_to_date};\n use crate::{CLang, GitRepo};\n \n@@ -776,7 +777,22 @@ impl Step for Lld {\n         t!(fs::create_dir_all(&out_dir));\n \n         let mut cfg = cmake::Config::new(builder.src.join(\"src/llvm-project/lld\"));\n-        configure_cmake(builder, target, &mut cfg, true, LdFlags::default());\n+        let mut ldflags = LdFlags::default();\n+\n+        // When building LLD as part of a build with instrumentation on windows, for example\n+        // when doing PGO on CI, cmake or clang-cl don't automatically link clang's\n+        // profiler runtime in. In that case, we need to manually ask cmake to do it, to avoid\n+        // linking errors, much like LLVM's cmake setup does in that situation.\n+        if builder.config.llvm_profile_generate && target.contains(\"msvc\") {\n+            if let Some(clang_cl_path) = builder.config.llvm_clang_cl.as_ref() {\n+                // Find clang's runtime library directory and push that as a search path to the\n+                // cmake linker flags.\n+                let clang_rt_dir = get_clang_cl_resource_dir(clang_cl_path);\n+                ldflags.push_all(&format!(\"/libpath:{}\", clang_rt_dir.display()));\n+            }\n+        }\n+\n+        configure_cmake(builder, target, &mut cfg, true, ldflags);\n \n         // This is an awful, awful hack. Discovered when we migrated to using\n         // clang-cl to compile LLVM/LLD it turns out that LLD, when built out of"}, {"sha": "c5d62a8810a8b4079a95da4328cbde9c42e8699d", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8a3325496f89373cb1631a944539ff38d0966fe8/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3325496f89373cb1631a944539ff38d0966fe8/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=8a3325496f89373cb1631a944539ff38d0966fe8", "patch": "@@ -576,3 +576,27 @@ fn absolute_windows(path: &std::path::Path) -> std::io::Result<std::path::PathBu\n         }\n     }\n }\n+\n+/// Adapted from https://github.com/llvm/llvm-project/blob/782e91224601e461c019e0a4573bbccc6094fbcd/llvm/cmake/modules/HandleLLVMOptions.cmake#L1058-L1079\n+///\n+/// When `clang-cl` is used with instrumentation, we need to add clang's runtime library resource\n+/// directory to the linker flags, otherwise there will be linker errors about the profiler runtime\n+/// missing. This function returns the path to that directory.\n+pub fn get_clang_cl_resource_dir(clang_cl_path: &str) -> PathBuf {\n+    // Similar to how LLVM does it, to find clang's library runtime directory:\n+    // - we ask `clang-cl` to locate the `clang_rt.builtins` lib.\n+    let mut builtins_locator = Command::new(clang_cl_path);\n+    builtins_locator.args(&[\"/clang:-print-libgcc-file-name\", \"/clang:--rtlib=compiler-rt\"]);\n+\n+    let clang_rt_builtins = output(&mut builtins_locator);\n+    let clang_rt_builtins = Path::new(clang_rt_builtins.trim());\n+    assert!(\n+        clang_rt_builtins.exists(),\n+        \"`clang-cl` must correctly locate the library runtime directory\"\n+    );\n+\n+    // - the profiler runtime will be located in the same directory as the builtins lib, like\n+    // `$LLVM_DISTRO_ROOT/lib/clang/$LLVM_VERSION/lib/windows`.\n+    let clang_rt_dir = clang_rt_builtins.parent().expect(\"The clang lib folder should exist\");\n+    clang_rt_dir.to_path_buf()\n+}"}, {"sha": "1025f5bce802cd5bd815696fbc9594522c741a61", "filename": "src/ci/docker/host-x86_64/dist-x86_64-linux/build-clang.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3325496f89373cb1631a944539ff38d0966fe8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8a3325496f89373cb1631a944539ff38d0966fe8/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-linux%2Fbuild-clang.sh?ref=8a3325496f89373cb1631a944539ff38d0966fe8", "patch": "@@ -4,7 +4,7 @@ set -ex\n \n source shared.sh\n \n-LLVM=llvmorg-14.0.2\n+LLVM=llvmorg-14.0.5\n \n mkdir llvm-project\n cd llvm-project"}, {"sha": "f92e46b0a97f657918b029490359da5f948a0961", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3325496f89373cb1631a944539ff38d0966fe8/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8a3325496f89373cb1631a944539ff38d0966fe8/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=8a3325496f89373cb1631a944539ff38d0966fe8", "patch": "@@ -625,7 +625,7 @@ jobs:\n                 --target=x86_64-pc-windows-msvc\n                 --enable-full-tools\n                 --enable-profiler\n-              SCRIPT: python x.py dist\n+              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc src/ci/pgo.sh python x.py dist\n               DIST_REQUIRE_ALL_TOOLS: 1\n             <<: *job-windows-xl\n "}, {"sha": "28bed1fa0353b3cc1778bee81dcaee1d44fbd0a6", "filename": "src/ci/pgo.sh", "status": "modified", "additions": 113, "deletions": 48, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/8a3325496f89373cb1631a944539ff38d0966fe8/src%2Fci%2Fpgo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8a3325496f89373cb1631a944539ff38d0966fe8/src%2Fci%2Fpgo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fpgo.sh?ref=8a3325496f89373cb1631a944539ff38d0966fe8", "patch": "@@ -3,44 +3,82 @@\n \n set -euxo pipefail\n \n+ci_dir=`cd $(dirname $0) && pwd`\n+source \"$ci_dir/shared.sh\"\n+\n+# The root checkout, where the source is located\n+CHECKOUT=/checkout\n+\n+DOWNLOADED_LLVM=/rustroot\n+\n+# The main directory where the build occurs, which can be different between linux and windows\n+BUILD_ROOT=$CHECKOUT/obj\n+\n+if isWindows; then\n+    CHECKOUT=$(pwd)\n+    DOWNLOADED_LLVM=$CHECKOUT/citools/clang-rust\n+    BUILD_ROOT=$CHECKOUT\n+fi\n+\n+# The various build artifacts used in other commands: to launch rustc builds, build the perf\n+# collector, and run benchmarks to gather profiling data\n+BUILD_ARTIFACTS=$BUILD_ROOT/build/$PGO_HOST\n+RUSTC_STAGE_0=$BUILD_ARTIFACTS/stage0/bin/rustc\n+CARGO_STAGE_0=$BUILD_ARTIFACTS/stage0/bin/cargo\n+RUSTC_STAGE_2=$BUILD_ARTIFACTS/stage2/bin/rustc\n+\n+# Windows needs these to have the .exe extension\n+if isWindows; then\n+    RUSTC_STAGE_0=\"${RUSTC_STAGE_0}.exe\"\n+    CARGO_STAGE_0=\"${CARGO_STAGE_0}.exe\"\n+    RUSTC_STAGE_2=\"${RUSTC_STAGE_2}.exe\"\n+fi\n+\n+# Make sure we have a temporary PGO work folder\n+PGO_TMP=/tmp/tmp-pgo\n+mkdir -p $PGO_TMP\n+rm -rf $PGO_TMP/*\n+\n+RUSTC_PERF=$PGO_TMP/rustc-perf\n+\n # Compile several crates to gather execution PGO profiles.\n # Arg0 => profiles (Debug, Opt)\n # Arg1 => scenarios (Full, IncrFull, All)\n # Arg2 => crates (syn, cargo, ...)\n gather_profiles () {\n-  cd /checkout/obj\n+  cd $BUILD_ROOT\n \n   # Compile libcore, both in opt-level=0 and opt-level=3\n-  RUSTC_BOOTSTRAP=1 ./build/$PGO_HOST/stage2/bin/rustc \\\n-      --edition=2021 --crate-type=lib ../library/core/src/lib.rs\n-  RUSTC_BOOTSTRAP=1 ./build/$PGO_HOST/stage2/bin/rustc \\\n-      --edition=2021 --crate-type=lib -Copt-level=3 ../library/core/src/lib.rs\n+  RUSTC_BOOTSTRAP=1 $RUSTC_STAGE_2 \\\n+      --edition=2021 --crate-type=lib $CHECKOUT/library/core/src/lib.rs \\\n+      --out-dir $PGO_TMP\n+  RUSTC_BOOTSTRAP=1 $RUSTC_STAGE_2 \\\n+      --edition=2021 --crate-type=lib -Copt-level=3 $CHECKOUT/library/core/src/lib.rs \\\n+      --out-dir $PGO_TMP\n \n-  cd rustc-perf\n+  cd $RUSTC_PERF\n \n   # Run rustc-perf benchmarks\n   # Benchmark using profile_local with eprintln, which essentially just means\n   # don't actually benchmark -- just make sure we run rustc a bunch of times.\n   RUST_LOG=collector=debug \\\n-  RUSTC=/checkout/obj/build/$PGO_HOST/stage0/bin/rustc \\\n+  RUSTC=$RUSTC_STAGE_0 \\\n   RUSTC_BOOTSTRAP=1 \\\n-  /checkout/obj/build/$PGO_HOST/stage0/bin/cargo run -p collector --bin collector -- \\\n-          profile_local \\\n-          eprintln \\\n-          /checkout/obj/build/$PGO_HOST/stage2/bin/rustc \\\n-          --id Test \\\n-          --profiles $1 \\\n-          --cargo /checkout/obj/build/$PGO_HOST/stage0/bin/cargo \\\n-          --scenarios $2 \\\n-          --include $3\n-\n-  cd /checkout/obj\n+  $CARGO_STAGE_0 run -p collector --bin collector -- \\\n+      profile_local \\\n+      eprintln \\\n+      $RUSTC_STAGE_2 \\\n+      --id Test \\\n+      --profiles $1 \\\n+      --cargo $CARGO_STAGE_0 \\\n+      --scenarios $2 \\\n+      --include $3\n+\n+  cd $BUILD_ROOT\n }\n \n-rm -rf /tmp/rustc-pgo\n-\n # This path has to be absolute\n-LLVM_PROFILE_DIRECTORY_ROOT=/tmp/llvm-pgo\n+LLVM_PROFILE_DIRECTORY_ROOT=$PGO_TMP/llvm-pgo\n \n # We collect LLVM profiling information and rustc profiling information in\n # separate phases. This increases build time -- though not by a huge amount --\n@@ -49,69 +87,93 @@ LLVM_PROFILE_DIRECTORY_ROOT=/tmp/llvm-pgo\n # LLVM IR PGO does not respect LLVM_PROFILE_FILE, so we have to set the profiling file\n # path through our custom environment variable. We include the PID in the directory path\n # to avoid updates to profile files being lost because of race conditions.\n-LLVM_PROFILE_DIR=${LLVM_PROFILE_DIRECTORY_ROOT}/prof-%p python3 ../x.py build \\\n+LLVM_PROFILE_DIR=${LLVM_PROFILE_DIRECTORY_ROOT}/prof-%p python3 $CHECKOUT/x.py build \\\n     --target=$PGO_HOST \\\n     --host=$PGO_HOST \\\n     --stage 2 library/std \\\n     --llvm-profile-generate\n \n-# Compile rustc perf\n-cp -r /tmp/rustc-perf ./\n-chown -R $(whoami): ./rustc-perf\n-cd rustc-perf\n-\n-# Build the collector ahead of time, which is needed to make sure the rustc-fake\n-# binary used by the collector is present.\n-RUSTC=/checkout/obj/build/$PGO_HOST/stage0/bin/rustc \\\n+# Compile rustc-perf:\n+# - get the expected commit source code: on linux, the Dockerfile downloads a source archive before\n+# running this script. On Windows, we do that here.\n+if isLinux; then\n+    cp -r /tmp/rustc-perf $RUSTC_PERF\n+    chown -R $(whoami): $RUSTC_PERF\n+else\n+    # rustc-perf version from 2022-05-18\n+    PERF_COMMIT=f66cc8f3e04392b0e2fd811f21fd1ece6ebaded3\n+    retry curl -LS -o $PGO_TMP/perf.zip \\\n+        https://github.com/rust-lang/rustc-perf/archive/$PERF_COMMIT.zip && \\\n+        cd $PGO_TMP && unzip -q perf.zip && \\\n+        mv rustc-perf-$PERF_COMMIT $RUSTC_PERF && \\\n+        rm perf.zip\n+fi\n+\n+# - build rustc-perf's collector ahead of time, which is needed to make sure the rustc-fake binary\n+# used by the collector is present.\n+cd $RUSTC_PERF\n+\n+RUSTC=$RUSTC_STAGE_0 \\\n RUSTC_BOOTSTRAP=1 \\\n-/checkout/obj/build/$PGO_HOST/stage0/bin/cargo build -p collector\n+$CARGO_STAGE_0 build -p collector\n \n # Here we're profiling LLVM, so we only care about `Debug` and `Opt`, because we want to stress\n # codegen. We also profile some of the most prolific crates.\n gather_profiles \"Debug,Opt\" \"Full\" \\\n-\"syn-1.0.89,cargo-0.60.0,serde-1.0.136,ripgrep-13.0.0,regex-1.5.5,clap-3.1.6,hyper-0.14.18\"\n+    \"syn-1.0.89,cargo-0.60.0,serde-1.0.136,ripgrep-13.0.0,regex-1.5.5,clap-3.1.6,hyper-0.14.18\"\n \n-LLVM_PROFILE_MERGED_FILE=/tmp/llvm-pgo.profdata\n+LLVM_PROFILE_MERGED_FILE=$PGO_TMP/llvm-pgo.profdata\n \n # Merge the profile data we gathered for LLVM\n # Note that this uses the profdata from the clang we used to build LLVM,\n # which likely has a different version than our in-tree clang.\n-/rustroot/bin/llvm-profdata merge -o ${LLVM_PROFILE_MERGED_FILE} ${LLVM_PROFILE_DIRECTORY_ROOT}\n+$DOWNLOADED_LLVM/bin/llvm-profdata merge -o ${LLVM_PROFILE_MERGED_FILE} ${LLVM_PROFILE_DIRECTORY_ROOT}\n \n echo \"LLVM PGO statistics\"\n du -sh ${LLVM_PROFILE_MERGED_FILE}\n du -sh ${LLVM_PROFILE_DIRECTORY_ROOT}\n echo \"Profile file count\"\n find ${LLVM_PROFILE_DIRECTORY_ROOT} -type f | wc -l\n \n+# We don't need the individual .profraw files now that they have been merged into a final .profdata\n+rm -r $LLVM_PROFILE_DIRECTORY_ROOT\n+\n # Rustbuild currently doesn't support rebuilding LLVM when PGO options\n # change (or any other llvm-related options); so just clear out the relevant\n # directories ourselves.\n-rm -r ./build/$PGO_HOST/llvm ./build/$PGO_HOST/lld\n+rm -r $BUILD_ARTIFACTS/llvm $BUILD_ARTIFACTS/lld\n \n # Okay, LLVM profiling is done, switch to rustc PGO.\n \n # The path has to be absolute\n-RUSTC_PROFILE_DIRECTORY_ROOT=/tmp/rustc-pgo\n+RUSTC_PROFILE_DIRECTORY_ROOT=$PGO_TMP/rustc-pgo\n \n-python3 ../x.py build --target=$PGO_HOST --host=$PGO_HOST \\\n+python3 $CHECKOUT/x.py build --target=$PGO_HOST --host=$PGO_HOST \\\n     --stage 2 library/std \\\n     --rust-profile-generate=${RUSTC_PROFILE_DIRECTORY_ROOT}\n \n # Here we're profiling the `rustc` frontend, so we also include `Check`.\n # The benchmark set includes various stress tests that put the frontend under pressure.\n-# The profile data is written into a single filepath that is being repeatedly merged when each\n-# rustc invocation ends. Empirically, this can result in some profiling data being lost.\n-# That's why we override the profile path to include the PID. This will produce many more profiling\n-# files, but the resulting profile will produce a slightly faster rustc binary.\n-LLVM_PROFILE_FILE=${RUSTC_PROFILE_DIRECTORY_ROOT}/default_%m_%p.profraw gather_profiles \\\n-  \"Check,Debug,Opt\" \"All\" \\\n-  \"externs,ctfe-stress-5,cargo-0.60.0,token-stream-stress,match-stress,tuple-stress,diesel-1.4.8,bitmaps-3.1.0\"\n-\n-RUSTC_PROFILE_MERGED_FILE=/tmp/rustc-pgo.profdata\n+if isLinux; then\n+    # The profile data is written into a single filepath that is being repeatedly merged when each\n+    # rustc invocation ends. Empirically, this can result in some profiling data being lost. That's\n+    # why we override the profile path to include the PID. This will produce many more profiling\n+    # files, but the resulting profile will produce a slightly faster rustc binary.\n+    LLVM_PROFILE_FILE=${RUSTC_PROFILE_DIRECTORY_ROOT}/default_%m_%p.profraw gather_profiles \\\n+        \"Check,Debug,Opt\" \"All\" \\\n+        \"externs,ctfe-stress-5,cargo-0.60.0,token-stream-stress,match-stress,tuple-stress,diesel-1.4.8,bitmaps-3.1.0\"\n+else\n+    # On windows, we don't do that yet (because it generates a lot of data, hitting disk space\n+    # limits on the builder), and use the default profraw merging behavior.\n+    gather_profiles \\\n+        \"Check,Debug,Opt\" \"All\" \\\n+        \"externs,ctfe-stress-5,cargo-0.60.0,token-stream-stress,match-stress,tuple-stress,diesel-1.4.8,bitmaps-3.1.0\"\n+fi\n+\n+RUSTC_PROFILE_MERGED_FILE=$PGO_TMP/rustc-pgo.profdata\n \n # Merge the profile data we gathered\n-./build/$PGO_HOST/llvm/bin/llvm-profdata \\\n+$BUILD_ARTIFACTS/llvm/bin/llvm-profdata \\\n     merge -o ${RUSTC_PROFILE_MERGED_FILE} ${RUSTC_PROFILE_DIRECTORY_ROOT}\n \n echo \"Rustc PGO statistics\"\n@@ -120,10 +182,13 @@ du -sh ${RUSTC_PROFILE_DIRECTORY_ROOT}\n echo \"Profile file count\"\n find ${RUSTC_PROFILE_DIRECTORY_ROOT} -type f | wc -l\n \n+# We don't need the individual .profraw files now that they have been merged into a final .profdata\n+rm -r $RUSTC_PROFILE_DIRECTORY_ROOT\n+\n # Rustbuild currently doesn't support rebuilding LLVM when PGO options\n # change (or any other llvm-related options); so just clear out the relevant\n # directories ourselves.\n-rm -r ./build/$PGO_HOST/llvm ./build/$PGO_HOST/lld\n+rm -r $BUILD_ARTIFACTS/llvm $BUILD_ARTIFACTS/lld\n \n # This produces the actual final set of artifacts, using both the LLVM and rustc\n # collected profiling data."}, {"sha": "0bc8a0389a8d4c0e6fc153fdbd26423d2b5f759c", "filename": "src/ci/scripts/install-clang.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a3325496f89373cb1631a944539ff38d0966fe8/src%2Fci%2Fscripts%2Finstall-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8a3325496f89373cb1631a944539ff38d0966fe8/src%2Fci%2Fscripts%2Finstall-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-clang.sh?ref=8a3325496f89373cb1631a944539ff38d0966fe8", "patch": "@@ -1,4 +1,5 @@\n #!/bin/bash\n+# ignore-tidy-linelength\n # This script installs clang on the local machine. Note that we don't install\n # clang on Linux since its compiler story is just so different. Each container\n # has its own toolchain configured appropriately already.\n@@ -9,7 +10,7 @@ IFS=$'\\n\\t'\n source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n \n # Update both macOS's and Windows's tarballs when bumping the version here.\n-LLVM_VERSION=\"14.0.2\"\n+LLVM_VERSION=\"14.0.5\"\n \n if isMacOS; then\n     # If the job selects a specific Xcode version, use that instead of"}]}