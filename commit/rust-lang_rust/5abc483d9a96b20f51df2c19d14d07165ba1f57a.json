{"sha": "5abc483d9a96b20f51df2c19d14d07165ba1f57a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYmM0ODNkOWE5NmIyMGY1MWRmMmMxOWQxNGQwNzE2NWJhMWY1N2E=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-29T01:53:16Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-29T01:53:43Z"}, "message": "Move more of the GC logic into the runtime.", "tree": {"sha": "c2ee4c6d4be802c0f1959d2c68828cc5a4654392", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2ee4c6d4be802c0f1959d2c68828cc5a4654392"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5abc483d9a96b20f51df2c19d14d07165ba1f57a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5abc483d9a96b20f51df2c19d14d07165ba1f57a", "html_url": "https://github.com/rust-lang/rust/commit/5abc483d9a96b20f51df2c19d14d07165ba1f57a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5abc483d9a96b20f51df2c19d14d07165ba1f57a/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a27cbd4ee8d1ea1061d726dcd8939f54edd257e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a27cbd4ee8d1ea1061d726dcd8939f54edd257e4", "html_url": "https://github.com/rust-lang/rust/commit/a27cbd4ee8d1ea1061d726dcd8939f54edd257e4"}], "stats": {"total": 408, "additions": 213, "deletions": 195}, "files": [{"sha": "7a62bb7397ba19fcb7398994a6233779c477ab58", "filename": "src/boot/llvm/lltrans.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5abc483d9a96b20f51df2c19d14d07165ba1f57a/src%2Fboot%2Fllvm%2Flltrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/5abc483d9a96b20f51df2c19d14d07165ba1f57a/src%2Fboot%2Fllvm%2Flltrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Flltrans.ml?ref=5abc483d9a96b20f51df2c19d14d07165ba1f57a", "patch": "@@ -196,7 +196,7 @@ let trans_crate\n       (lltask:Llvm.llvalue)\n       (src:Llvm.llvalue)\n       : unit =\n-    upcall llbuilder lltask \"upcall_free\" None [| src |]\n+    upcall llbuilder lltask \"upcall_free\" None [| src; const_i32 0 |]\n   in\n \n   (*"}, {"sha": "8ecc743e56ca307481da301808ec334e2cca79d3", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 81, "deletions": 183, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/5abc483d9a96b20f51df2c19d14d07165ba1f57a/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/5abc483d9a96b20f51df2c19d14d07165ba1f57a/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=5abc483d9a96b20f51df2c19d14d07165ba1f57a", "patch": "@@ -1082,7 +1082,7 @@ let trans_visitor\n                      [|\n                        get_copy_glue t None;\n                        get_drop_glue t None;\n-                       get_free_glue t (slot_mem_ctrl (interior_slot t)) None;\n+                       get_free_glue t (type_has_state t) None;\n                        get_sever_glue t None;\n                        get_mark_glue t None;\n                      |];\n@@ -1580,7 +1580,7 @@ let trans_visitor\n \n   and get_free_glue\n       (ty:Ast.ty)\n-      (mctrl:mem_ctrl)\n+      (is_gc:bool)\n       (curr_iso:Ast.ty_iso option)\n       : fixup =\n     let g = GLUE_free ty in\n@@ -1604,49 +1604,7 @@ let trans_visitor\n         trans_call_simple_static_glue\n           (get_drop_glue ty curr_iso) ty_params vr;\n         note_drop_step ty \"back in free-glue, calling free\";\n-        if type_has_state ty\n-        then\n-          note_drop_step ty \"type has state\"\n-        else\n-          note_drop_step ty \"type has no state\";\n-        if mctrl = MEM_gc\n-        then\n-          begin\n-            note_drop_step ty \"MEM_gc, unlinking from GC chain\";\n-            let pcast c =\n-              rty_ptr_at (fst (need_mem_cell c)) (Il.ScalarTy wordptr_ty)\n-            in\n-            let next = pcast (exterior_gc_next_cell cell) in\n-            let prev = pcast (exterior_gc_prev_cell cell) in\n-\n-              note_drop_step ty \"MEM_gc, next->prev = prev\";\n-              let skip_null_next_jmp = null_check next in\n-                mov (exterior_gc_prev_cell next) (Il.Cell prev);\n-                patch skip_null_next_jmp;\n-\n-                let skip_null_prev_jmp = null_check prev in\n-                  note_drop_step ty \"MEM_gc, prev->next = next\";\n-                  mov (exterior_gc_next_cell prev) (Il.Cell next);\n-                  let skip_set_task_chain_jmp = mark () in\n-                    emit (Il.jmp Il.JMP Il.CodeNone);\n-                    patch skip_null_prev_jmp;\n-                    note_drop_step ty \"MEM_gc, task->chain = next\";\n-                    let chain =\n-                      tp_imm (word_n Abi.task_field_gc_alloc_chain)\n-                    in\n-                      mov chain (Il.Cell next);\n-                      patch skip_set_task_chain_jmp;\n-\n-                      note_drop_step ty \"MEM_gc, freeing\";\n-                      lea vr (fst (need_mem_cell\n-                                     (exterior_gc_alloc_base cell)));\n-                      trans_free vr;\n-          end\n-        else\n-          begin\n-            note_drop_step ty \"not MEM_gc\";\n-            trans_free cell;\n-          end;\n+        trans_free cell is_gc;\n         trace_str cx.ctxt_sess.Session.sess_trace_drop\n           \"free-glue complete\";\n     in\n@@ -2091,11 +2049,16 @@ let trans_visitor\n             trans_cond_fail (Fmt.fmt_to_str Ast.fmt_expr e) fwd_jmps\n       | _ -> bugi cx id \"check expr on non-bool\"\n \n-  and trans_malloc (dst:Il.cell) (nbytes:Il.operand) : unit =\n-    trans_upcall \"upcall_malloc\" dst [| nbytes |]\n+  and trans_malloc\n+      (dst:Il.cell)\n+      (nbytes:Il.operand)\n+      (gc_ctrl_word:Il.operand)\n+      : unit =\n+    trans_upcall \"upcall_malloc\" dst [| nbytes; gc_ctrl_word |]\n \n-  and trans_free (src:Il.cell) : unit =\n-    trans_void_upcall \"upcall_free\" [| Il.Cell src |]\n+  and trans_free (src:Il.cell) (is_gc:bool) : unit =\n+    let is_gc = if is_gc then 1L else 0L in\n+      trans_void_upcall \"upcall_free\" [| Il.Cell src; imm is_gc |]\n \n   and trans_yield () : unit =\n     trans_void_upcall \"upcall_yield\" [| |];\n@@ -2172,14 +2135,20 @@ let trans_visitor\n \n   and trans_init_vec (dst:Ast.lval) (atoms:Ast.atom array) : unit =\n     let (dst_cell, dst_slot) = trans_lval_init dst in\n-    let unit_slot = match slot_ty dst_slot with\n+    let dst_ty = slot_ty dst_slot in\n+    let gc_ctrl =\n+      if (slot_mem_ctrl dst_slot) = MEM_gc\n+      then Il.Cell (get_tydesc None (slot_ty dst_slot))\n+      else zero\n+    in\n+    let unit_slot = match dst_ty with\n         Ast.TY_vec s -> s\n       | _ -> bug () \"init dst of vec-init has non-vec type\"\n     in\n     let fill = next_vreg_cell word_ty in\n     let unit_sz = slot_sz_in_current_frame unit_slot in\n       umul fill unit_sz (imm (Int64.of_int (Array.length atoms)));\n-      trans_upcall \"upcall_new_vec\" dst_cell [| Il.Cell fill |];\n+      trans_upcall \"upcall_new_vec\" dst_cell [| Il.Cell fill; gc_ctrl |];\n       let vec = deref dst_cell in\n         let body_mem =\n           fst (need_mem_cell\n@@ -2251,24 +2220,12 @@ let trans_visitor\n   and exterior_rc_cell (cell:Il.cell) : Il.cell =\n     exterior_ctrl_cell cell Abi.exterior_rc_slot_field_refcnt\n \n-  and exterior_gc_ctrl_cell (cell:Il.cell) : Il.cell =\n-    exterior_ctrl_cell cell Abi.exterior_gc_slot_field_ctrl\n-\n-  and exterior_gc_next_cell (cell:Il.cell) : Il.cell =\n-    exterior_ctrl_cell cell Abi.exterior_gc_slot_field_next\n-\n-  and exterior_gc_prev_cell (cell:Il.cell) : Il.cell =\n-    exterior_ctrl_cell cell Abi.exterior_gc_slot_field_prev\n-\n-  and exterior_gc_alloc_base (cell:Il.cell) : Il.cell =\n-    exterior_ctrl_cell cell Abi.exterior_gc_slot_alloc_base\n-\n   and exterior_allocation_size\n       (slot:Ast.slot)\n       : Il.operand =\n     let header_sz =\n       match slot_mem_ctrl slot with\n-          MEM_gc -> word_n Abi.exterior_gc_header_size\n+          MEM_gc\n         | MEM_rc_opaque\n         | MEM_rc_struct -> word_n Abi.exterior_rc_header_size\n         | MEM_interior -> bug () \"exterior_allocation_size of MEM_interior\"\n@@ -2494,7 +2451,10 @@ let trans_visitor\n               (* Drop the body. *)\n               trans_call_dynamic_glue tydesc\n                 Abi.tydesc_field_drop_glue None [| ty_params; alias body |];\n-              trans_free binding;\n+              (* FIXME: this will fail if the user has lied about the\n+               * state-ness of their obj. We need to store state-ness in the\n+               * captured tydesc, and use that.  *)\n+              trans_free binding (type_has_state ty);\n               mov binding zero;\n               patch rc_jmp;\n               patch null_jmp\n@@ -2620,6 +2580,7 @@ let trans_visitor\n             curr_iso\n \n   and free_ty\n+      (is_gc:bool)\n       (ty_params:Il.cell)\n       (ty:Ast.ty)\n       (cell:Il.cell)\n@@ -2632,9 +2593,9 @@ let trans_visitor\n       | Ast.TY_vec s ->\n           iter_seq_slots ty_params cell cell s\n             (fun _ src slot iso -> drop_slot ty_params src slot iso) curr_iso;\n-          trans_free cell\n+          trans_free cell is_gc\n \n-      | _ -> trans_free cell\n+      | _ -> trans_free cell is_gc\n \n   and maybe_iso\n       (curr_iso:Ast.ty_iso option)\n@@ -2700,38 +2661,24 @@ let trans_visitor\n     let ty = slot_ty slot in\n       match slot_mem_ctrl slot with\n           MEM_gc ->\n-            note_gc_step slot \"mark GC slot: check for null:\";\n-            emit (Il.cmp (Il.Cell cell) zero);\n-            let null_cell_jump = mark () in\n-              emit (Il.jmp Il.JE Il.CodeNone);\n-              let gc_word = exterior_gc_ctrl_cell cell in\n-              let tmp = next_vreg_cell Il.voidptr_t in\n-                (* if this has been marked already, jump to exit.*)\n-                note_gc_step slot \"mark GC slot: check for mark:\";\n-                emit (Il.binary Il.AND tmp (Il.Cell gc_word) one);\n-                trace_word cx.ctxt_sess.Session.sess_trace_gc tmp;\n-\n-                let already_marked_jump =\n-                  trans_compare Il.JNE (Il.Cell tmp) zero;\n-                in\n-                  (* Set mark bit in allocation header. *)\n-                  emit (Il.binary Il.OR gc_word (Il.Cell gc_word) one);\n-                  note_gc_step slot \"mark GC slot: set mark\";\n-                  (* Iterate over exterior slots marking outgoing links. *)\n-                  let (body_mem, _) =\n-                    need_mem_cell\n-                      (get_element_ptr (deref cell)\n-                         Abi.exterior_gc_slot_field_body)\n-                  in\n-                  let ty = maybe_iso curr_iso ty in\n-                  let curr_iso = maybe_enter_iso ty curr_iso in\n-                    lea tmp body_mem;\n-                    trans_call_simple_static_glue\n-                      (get_mark_glue ty curr_iso)\n-                      ty_params tmp;\n-                    patch null_cell_jump;\n-                    List.iter patch already_marked_jump;\n-                    note_gc_step slot \"mark GC slot: done marking:\";\n+            let tmp = next_vreg_cell Il.voidptr_t in\n+            trans_upcall \"upcall_mark\" tmp [| Il.Cell cell |];\n+              let marked_jump =\n+                trans_compare Il.JE (Il.Cell tmp) zero;\n+              in\n+                (* Iterate over exterior slots marking outgoing links. *)\n+              let (body_mem, _) =\n+                need_mem_cell\n+                  (get_element_ptr (deref cell)\n+                     Abi.exterior_gc_slot_field_body)\n+              in\n+              let ty = maybe_iso curr_iso ty in\n+              let curr_iso = maybe_enter_iso ty curr_iso in\n+                lea tmp body_mem;\n+                trans_call_simple_static_glue\n+                  (get_mark_glue ty curr_iso)\n+                  ty_params tmp;\n+                List.iter patch marked_jump;\n \n         | MEM_interior when type_is_structured ty ->\n             (iflog (fun _ ->\n@@ -2814,42 +2761,26 @@ let trans_visitor\n     let slot = {slot with Ast.slot_ty = Some ty} in\n     let mctrl = slot_mem_ctrl slot in\n       match mctrl with\n-          MEM_rc_opaque ->\n-            (* Refcounted opaque objects we handle without glue functions. *)\n-            let _ = check_exterior_rty cell in\n-            let null_jmp = null_check cell in\n-            let j = drop_refcount_and_cmp (exterior_rc_cell cell) in\n-              free_ty ty_params ty cell curr_iso;\n-              (* Null the slot out to prevent double-free if the frame\n-               * unwinds.\n-               *)\n-              mov cell zero;\n-              patch j;\n-              patch null_jmp\n-\n+          MEM_rc_opaque\n         | MEM_gc\n         | MEM_rc_struct ->\n-            (* Refcounted \"structured exterior\" objects we handle via\n-             * glue functions.\n-             *)\n-\n-            (* \n-             * 'GC memory' is treated similarly, just happens to have\n-             * an extra couple cells on the front.\n-             *)\n-\n-            (* FIXME (issue #25): check to see that the exterior has\n-             * further exterior members; if it doesn't we can elide the\n-             * call to the glue function.  *)\n             let _ = check_exterior_rty cell in\n             let null_jmp = null_check cell in\n             let rc = exterior_rc_cell cell in\n-            let _ = note_gc_step slot \"dropping refcount on \" in\n-            let _ = trace_word cx.ctxt_sess.Session.sess_trace_gc rc in\n             let j = drop_refcount_and_cmp rc in\n-              trans_call_simple_static_glue\n-                (get_free_glue ty mctrl curr_iso)\n-                ty_params cell;\n+\n+              (* FIXME (issue #25): check to see that the exterior has\n+               * further exterior members; if it doesn't we can elide the\n+               * call to the glue function.  *)\n+\n+              if mctrl = MEM_rc_opaque\n+              then\n+                free_ty false ty_params ty cell curr_iso\n+              else\n+                trans_call_simple_static_glue\n+                  (get_free_glue ty (mctrl = MEM_gc) curr_iso)\n+                  ty_params cell;\n+\n               (* Null the slot out to prevent double-free if the frame\n                * unwinds.\n                *)\n@@ -2904,57 +2835,22 @@ let trans_visitor\n \n   (* Returns the offset of the slot-body in the initialized allocation. *)\n   and init_exterior_slot (cell:Il.cell) (slot:Ast.slot) : unit =\n-    match slot_mem_ctrl slot with\n-        MEM_gc ->\n-          iflog (fun _ -> annotate \"init GC exterior: malloc\");\n-          let sz = exterior_allocation_size slot in\n-            (* \n-             * Malloc and then immediately shift down to point to\n-             * the pseudo-rc cell.\n-             *)\n-            note_gc_step slot \"init GC exterior: malloc slot:\";\n-            trans_malloc cell sz;\n-            add_to cell\n-              (imm (word_n Abi.exterior_gc_malloc_return_adjustment));\n-            note_gc_step slot \"init GC exterior: load control word\";\n-            let ctrl = exterior_gc_ctrl_cell cell in\n-            let tydesc = get_tydesc None (slot_ty slot) in\n-            let rc = exterior_rc_cell cell in\n-              note_gc_step slot \"init GC exterior: set refcount\";\n-              mov rc one;\n-              trace_word cx.ctxt_sess.Session.sess_trace_gc rc;\n-              mov ctrl (Il.Cell tydesc);\n-              note_gc_step slot \"init GC exterior: load chain next-ptr\";\n-              let next = exterior_gc_next_cell cell in\n-              let prev = exterior_gc_prev_cell cell in\n-              let chain = tp_imm (word_n Abi.task_field_gc_alloc_chain) in\n-\n-                note_gc_step slot \"init GC exterior: new->prev = 0\";\n-                mov prev zero;\n-\n-                note_gc_step slot \"init GC exterior: new->next = curr\";\n-                mov next (Il.Cell chain);\n-\n-                let null_jmp = null_check chain in\n-                let prev = rty_ptr_at (fst (need_mem_cell chain)) word_rty in\n-                let chain_prev = exterior_gc_prev_cell prev in\n-                  note_gc_step slot \"init GC exterior: curr->prev = new\";\n-                  mov chain_prev (Il.Cell cell);\n-                  patch null_jmp;\n-\n-                  note_gc_step slot \"init GC exterior: chain = new\";\n-                  mov chain (Il.Cell cell);\n-\n-                  note_gc_step slot \"init GC exterior: done initializing\"\n-\n-      | MEM_rc_opaque\n-      | MEM_rc_struct ->\n-          iflog (fun _ -> annotate \"init RC exterior: malloc\");\n-          let sz = exterior_allocation_size slot in\n-            trans_malloc cell sz;\n-            iflog (fun _ -> annotate \"init RC exterior: load refcount\");\n-            let rc = exterior_rc_cell cell in\n-              mov rc one\n+    let mctrl = slot_mem_ctrl slot in\n+      match mctrl with\n+          MEM_gc\n+        | MEM_rc_opaque\n+        | MEM_rc_struct ->\n+            let ctrl =\n+              if mctrl = MEM_gc\n+              then Il.Cell (get_tydesc None (slot_ty slot))\n+              else zero\n+            in\n+              iflog (fun _ -> annotate \"init exterior: malloc\");\n+              let sz = exterior_allocation_size slot in\n+                trans_malloc cell sz ctrl;\n+                iflog (fun _ -> annotate \"init exterior: load refcount\");\n+                let rc = exterior_rc_cell cell in\n+                  mov rc one\n \n       | MEM_interior -> bug () \"init_exterior_slot of MEM_interior\"\n \n@@ -3452,7 +3348,7 @@ let trans_visitor\n       mov fn_cell (crate_rel_imm glue_fixup);\n       iflog (fun _ ->\n                annotate \"heap-allocate closure to binding slot of pair\");\n-      trans_malloc closure_cell (imm closure_sz);\n+      trans_malloc closure_cell (imm closure_sz) zero;\n       trans_init_closure\n         (deref closure_cell)\n         target_fn_ptr target_binding_ptr\n@@ -4092,6 +3988,7 @@ let trans_visitor\n       match src_ty with\n           Ast.TY_str\n         | Ast.TY_vec _ ->\n+            let is_gc = if type_has_state src_ty then 1L else 0L in\n             let src_cell = need_cell src_oper in\n             let src_vec = deref src_cell in\n             let src_fill = get_element_ptr src_vec Abi.vec_elt_fill in\n@@ -4108,7 +4005,8 @@ let trans_visitor\n               trans_upcall \"upcall_vec_grow\"\n                 dst_cell\n                 [| Il.Cell dst_cell;\n-                   Il.Cell src_fill |];\n+                   Il.Cell src_fill;\n+                   imm is_gc |];\n \n               (* \n                * By now, dst_cell points to a vec/str with room for us\n@@ -4583,7 +4481,7 @@ let trans_visitor\n \n       (* Load second cell of pair with pointer to fresh state tuple.*)\n       iflog (fun _ -> annotate \"malloc state-tuple to obj.state cell\");\n-      trans_malloc dst_pair_state_cell state_malloc_sz;\n+      trans_malloc dst_pair_state_cell state_malloc_sz zero;\n \n       (* Copy args into the state tuple. *)\n       let state_ptr = next_vreg_cell (need_scalar_ty state_ptr_rty) in"}, {"sha": "fafc1924a55fa3989950edac12cb417604e6b31b", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5abc483d9a96b20f51df2c19d14d07165ba1f57a/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/5abc483d9a96b20f51df2c19d14d07165ba1f57a/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=5abc483d9a96b20f51df2c19d14d07165ba1f57a", "patch": "@@ -595,6 +595,19 @@ struct frame_glue_fns {\n     uintptr_t reloc_glue_off;\n };\n \n+struct gc_alloc {\n+    gc_alloc *prev;\n+    gc_alloc *next;\n+    uintptr_t ctrl_word;\n+    uint8_t data[];\n+    bool mark() {\n+        if (ctrl_word & 1)\n+            return false;\n+        ctrl_word |= 1;\n+        return true;\n+    }\n+};\n+\n struct\n rust_task : public rc_base<rust_task>,\n             public dom_owned<rust_task>,\n@@ -604,7 +617,7 @@ rust_task : public rc_base<rust_task>,\n     stk_seg *stk;\n     uintptr_t runtime_sp;      // Runtime sp while task running.\n     uintptr_t rust_sp;         // Saved sp when not running.\n-    uintptr_t gc_alloc_chain;  // Linked list of GC allocations.\n+    gc_alloc *gc_alloc_chain;  // Linked list of GC allocations.\n     rust_dom *dom;\n     rust_crate_cache *cache;\n \n@@ -614,6 +627,8 @@ rust_task : public rc_base<rust_task>,\n     uintptr_t* dptr;           // Rendezvous pointer for send/recv.\n     rust_task *spawner;        // Parent-link.\n     size_t idx;\n+    size_t gc_alloc_thresh;\n+    size_t gc_alloc_accum;\n \n     // Wait queue for tasks waiting for this task.\n     rust_wait_queue waiting_tasks;\n@@ -633,6 +648,12 @@ rust_task : public rc_base<rust_task>,\n     bool blocked_on(rust_cond *cond);\n     bool dead();\n \n+    void link_gc(gc_alloc *gcm);\n+    void unlink_gc(gc_alloc *gcm);\n+    void *malloc(size_t sz, type_desc *td=0);\n+    void *realloc(void *data, size_t sz, bool gc_mem=false);\n+    void free(void *p, bool gc_mem=false);\n+\n     const char *state_str();\n     void transition(ptr_vec<rust_task> *svec, ptr_vec<rust_task> *dvec);\n "}, {"sha": "5cdf315c7c6ec267ed2093093f7f83d321058341", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5abc483d9a96b20f51df2c19d14d07165ba1f57a/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5abc483d9a96b20f51df2c19d14d07165ba1f57a/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=5abc483d9a96b20f51df2c19d14d07165ba1f57a", "patch": "@@ -21,6 +21,7 @@ static uint32_t read_type_bit_mask() {\n         bits |= strstr(env_str, \"dwarf\") ? rust_log::DWARF : 0;\n         bits |= strstr(env_str, \"cache\") ? rust_log::CACHE : 0;\n         bits |= strstr(env_str, \"timer\") ? rust_log::TIMER : 0;\n+        bits |= strstr(env_str, \"gc\") ? rust_log::GC : 0;\n         bits |= strstr(env_str, \"all\") ? rust_log::ALL : 0;\n     }\n     return bits;"}, {"sha": "bd32c1550e4efedd7c254431f64597904109e90b", "filename": "src/rt/rust_log.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5abc483d9a96b20f51df2c19d14d07165ba1f57a/src%2Frt%2Frust_log.h", "raw_url": "https://github.com/rust-lang/rust/raw/5abc483d9a96b20f51df2c19d14d07165ba1f57a/src%2Frt%2Frust_log.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.h?ref=5abc483d9a96b20f51df2c19d14d07165ba1f57a", "patch": "@@ -44,6 +44,7 @@ class rust_log {\n         CACHE = 0x100,\n         UPCALL = 0x200,\n         TIMER = 0x400,\n+        GC = 0x800,\n         ALL = 0xffffffff\n     };\n "}, {"sha": "bf92ba90ec468a7e7dfa027d51a0998e5e1a625d", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/5abc483d9a96b20f51df2c19d14d07165ba1f57a/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5abc483d9a96b20f51df2c19d14d07165ba1f57a/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=5abc483d9a96b20f51df2c19d14d07165ba1f57a", "patch": "@@ -407,6 +407,84 @@ rust_task::dead()\n     return state == &dom->dead_tasks;\n }\n \n+void\n+rust_task::link_gc(gc_alloc *gcm) {\n+    I(dom, gcm->prev == NULL);\n+    I(dom, gcm->next == NULL);\n+    gcm->prev = NULL;\n+    gcm->next = gc_alloc_chain;\n+}\n+\n+void\n+rust_task::unlink_gc(gc_alloc *gcm) {\n+    if (gcm->prev)\n+        gcm->prev->next = gcm->next;\n+    if (gcm->next)\n+        gcm->next->prev = gcm->prev;\n+    gcm->prev = NULL;\n+    gcm->next = NULL;\n+}\n+\n+void *\n+rust_task::malloc(size_t sz, type_desc *td)\n+{\n+    if (td) {\n+        sz += sizeof(gc_alloc);\n+    }\n+    void *mem = dom->malloc(sz);\n+    if (!mem)\n+        return mem;\n+    if (td) {\n+        gc_alloc *gcm = (gc_alloc*) mem;\n+        dom->log(rust_log::TASK|rust_log::MEM|rust_log::GC,\n+                 \"task 0x%\" PRIxPTR \" allocated %d GC bytes = 0x%\" PRIxPTR,\n+                 (uintptr_t)this, sz, gcm);\n+        memset((void*) gcm, 0, sizeof(gc_alloc));\n+        link_gc(gcm);\n+        gcm->ctrl_word = (uintptr_t)td;\n+        gc_alloc_accum += sz;\n+        mem = (void*) &(gcm->data);\n+    }\n+    return mem;;\n+}\n+\n+void *\n+rust_task::realloc(void *data, size_t sz, bool is_gc)\n+{\n+    if (is_gc) {\n+        gc_alloc *gcm = (gc_alloc*)(((char *)data) - sizeof(gc_alloc));\n+        unlink_gc(gcm);\n+        sz += sizeof(gc_alloc);\n+        gcm = (gc_alloc*) dom->realloc((void*)gcm, sz);\n+        dom->log(rust_log::TASK|rust_log::MEM|rust_log::GC,\n+                 \"task 0x%\" PRIxPTR \" reallocated %d GC bytes = 0x%\" PRIxPTR,\n+                 (uintptr_t)this, sz, gcm);\n+        if (!gcm)\n+            return gcm;\n+        link_gc(gcm);\n+        data = (void*) &(gcm->data);\n+    } else {\n+        data = dom->realloc(data, sz);\n+    }\n+    return data;\n+}\n+\n+void\n+rust_task::free(void *p, bool is_gc)\n+{\n+    if (is_gc) {\n+        gc_alloc *gcm = (gc_alloc*)(((char *)p) - sizeof(gc_alloc));\n+        unlink_gc(gcm);\n+        dom->log(rust_log::TASK|rust_log::MEM|rust_log::GC,\n+                 \"task 0x%\" PRIxPTR \" freeing GC memory = 0x%\" PRIxPTR,\n+                 (uintptr_t)this, gcm);\n+        dom->free(gcm);\n+    } else {\n+        dom->free(p);\n+    }\n+}\n+\n+\n void\n rust_task::transition(ptr_vec<rust_task> *src, ptr_vec<rust_task> *dst)\n {"}, {"sha": "ffe775325fcbb188ebd9ed75d16ce16776096827", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5abc483d9a96b20f51df2c19d14d07165ba1f57a/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5abc483d9a96b20f51df2c19d14d07165ba1f57a/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=5abc483d9a96b20f51df2c19d14d07165ba1f57a", "patch": "@@ -324,27 +324,45 @@ upcall_exit(rust_task *task)\n }\n \n extern \"C\" CDECL uintptr_t\n-upcall_malloc(rust_task *task, size_t nbytes)\n+upcall_malloc(rust_task *task, size_t nbytes, type_desc *td)\n {\n     LOG_UPCALL_ENTRY(task);\n \n-    void *p = task->dom->malloc(nbytes);\n+    void *p = task->malloc(nbytes, td);\n     task->dom->log(rust_log::UPCALL|rust_log::MEM,\n-                   \"upcall malloc(%u) = 0x%\" PRIxPTR,\n-                   nbytes, (uintptr_t)p);\n+                   \"upcall malloc(%u) = 0x%\" PRIxPTR\n+                   \" with gc-chain head = 0x%\" PRIxPTR,\n+                   nbytes, (uintptr_t)p, task->gc_alloc_chain);\n     return (uintptr_t) p;\n }\n \n extern \"C\" CDECL void\n-upcall_free(rust_task *task, void* ptr)\n+upcall_free(rust_task *task, void* ptr, uintptr_t is_gc)\n {\n     LOG_UPCALL_ENTRY(task);\n \n     rust_dom *dom = task->dom;\n     dom->log(rust_log::UPCALL|rust_log::MEM,\n              \"upcall free(0x%\" PRIxPTR \")\",\n              (uintptr_t)ptr);\n-    dom->free(ptr);\n+    task->free(ptr, (bool) is_gc);\n+}\n+\n+extern \"C\" CDECL uintptr_t\n+upcall_mark(rust_task *task, void* ptr)\n+{\n+    LOG_UPCALL_ENTRY(task);\n+\n+    rust_dom *dom = task->dom;\n+    if (ptr) {\n+        gc_alloc *gcm = (gc_alloc*) (((char*)ptr) - sizeof(gc_alloc));\n+        uintptr_t marked = (uintptr_t) gcm->mark();\n+        dom->log(rust_log::UPCALL|rust_log::MEM|rust_log::GC,\n+                 \"upcall mark(0x%\" PRIxPTR \") = %\" PRIdPTR,\n+                 (uintptr_t)gcm, marked);\n+        return marked;\n+    }\n+    return 0;\n }\n \n extern \"C\" CDECL rust_str *\n@@ -368,14 +386,15 @@ upcall_new_str(rust_task *task, char const *s, size_t fill)\n }\n \n extern \"C\" CDECL rust_vec *\n-upcall_new_vec(rust_task *task, size_t fill)\n+upcall_new_vec(rust_task *task, size_t fill, type_desc *td)\n {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;\n     dom->log(rust_log::UPCALL|rust_log::MEM,\n-             \"upcall new_vec(%\" PRIdPTR \")\", fill);\n+             \"upcall new_vec(%\" PRIdPTR \")\",\n+             fill);\n     size_t alloc = next_power_of_two(sizeof(rust_vec) + fill);\n-    void *mem = dom->malloc(alloc);\n+    void *mem = task->malloc(alloc, td);\n     if (!mem) {\n         task->fail(3);\n         return NULL;\n@@ -389,7 +408,7 @@ upcall_new_vec(rust_task *task, size_t fill)\n \n \n extern \"C\" CDECL rust_str *\n-upcall_vec_grow(rust_task *task, rust_vec *v, size_t n_bytes)\n+upcall_vec_grow(rust_task *task, rust_vec *v, size_t n_bytes, uintptr_t is_gc)\n {\n     LOG_UPCALL_ENTRY(task);\n     rust_dom *dom = task->dom;"}]}