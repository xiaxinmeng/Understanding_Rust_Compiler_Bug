{"sha": "6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMzdiNWJhYjc0YTg3YzRmMDUyNzRlNmE0OWQ5ZTI4YTRjMGY0ZTE=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-07-14T02:44:36Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-07-14T02:44:36Z"}, "message": "Split mutable methods out of Set and Map\n\nFixes most of #4989. I didn't add Persistent{Set,Map} since the only\npersistent data structure is fun_treemap and its functionality is\ncurrently too limited to build a trait out of.", "tree": {"sha": "1a92b4e674126ff3bf2a9e6204a25a2ae30071b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a92b4e674126ff3bf2a9e6204a25a2ae30071b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "html_url": "https://github.com/rust-lang/rust/commit/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839", "html_url": "https://github.com/rust-lang/rust/commit/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839"}], "stats": {"total": 195, "additions": 109, "deletions": 86}, "files": [{"sha": "49cedac399e0ce0b81367b72102259f846047ca4", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "patch": "@@ -718,38 +718,6 @@ impl Set<uint> for BitvSet {\n         *value < self.bitv.storage.len() * uint::bits && self.bitv.get(*value)\n     }\n \n-    fn insert(&mut self, value: uint) -> bool {\n-        if self.contains(&value) {\n-            return false;\n-        }\n-        let nbits = self.capacity();\n-        if value >= nbits {\n-            let newsize = num::max(value, nbits * 2) / uint::bits + 1;\n-            assert!(newsize > self.bitv.storage.len());\n-            self.bitv.storage.grow(newsize, &0);\n-        }\n-        self.size += 1;\n-        self.bitv.set(value, true);\n-        return true;\n-    }\n-\n-    fn remove(&mut self, value: &uint) -> bool {\n-        if !self.contains(value) {\n-            return false;\n-        }\n-        self.size -= 1;\n-        self.bitv.set(*value, false);\n-\n-        // Attempt to truncate our storage\n-        let mut i = self.bitv.storage.len();\n-        while i > 1 && self.bitv.storage[i - 1] == 0 {\n-            i -= 1;\n-        }\n-        self.bitv.storage.truncate(i);\n-\n-        return true;\n-    }\n-\n     fn is_disjoint(&self, other: &BitvSet) -> bool {\n         for self.intersection(other) |_| {\n             return false;\n@@ -816,6 +784,40 @@ impl Set<uint> for BitvSet {\n     }\n }\n \n+impl MutableSet<uint> for BitvSet {\n+    fn insert(&mut self, value: uint) -> bool {\n+        if self.contains(&value) {\n+            return false;\n+        }\n+        let nbits = self.capacity();\n+        if value >= nbits {\n+            let newsize = num::max(value, nbits * 2) / uint::bits + 1;\n+            assert!(newsize > self.bitv.storage.len());\n+            self.bitv.storage.grow(newsize, &0);\n+        }\n+        self.size += 1;\n+        self.bitv.set(value, true);\n+        return true;\n+    }\n+\n+    fn remove(&mut self, value: &uint) -> bool {\n+        if !self.contains(value) {\n+            return false;\n+        }\n+        self.size -= 1;\n+        self.bitv.set(*value, false);\n+\n+        // Attempt to truncate our storage\n+        let mut i = self.bitv.storage.len();\n+        while i > 1 && self.bitv.storage[i - 1] == 0 {\n+            i -= 1;\n+        }\n+        self.bitv.storage.truncate(i);\n+\n+        return true;\n+    }\n+}\n+\n impl BitvSet {\n     /// Visits each of the words that the two bit vectors (self and other)\n     /// both have in common. The three yielded arguments are (bit location,"}, {"sha": "27e9f8cd60f3307ed480a23d81fc4001c064e525", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "patch": "@@ -17,8 +17,7 @@\n \n \n use std::cmp;\n-use std::container::{Container, Mutable, Map, Set};\n-use std::iterator::*;\n+use std::iterator::{Iterator,IteratorUtil,ZipIterator,Counter,EnumerateIterator,FilterMapIterator};\n use std::uint;\n use std::util::replace;\n use std::vec::{VecIterator,VecMutIterator,VecRevIterator,VecMutRevIterator};\n@@ -68,7 +67,9 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n             None\n         }\n     }\n+}\n \n+impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n     /// Return a mutable reference to the value corresponding to the key\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> {\n         if *key < self.v.len() {\n@@ -349,14 +350,6 @@ impl Set<uint> for SmallIntSet {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &uint) -> bool { self.map.contains_key(value) }\n \n-    /// Add a value to the set. Return true if the value was not already\n-    /// present in the set.\n-    fn insert(&mut self, value: uint) -> bool { self.map.insert(value, ()) }\n-\n-    /// Remove a value from the set. Return true if the value was\n-    /// present in the set.\n-    fn remove(&mut self, value: &uint) -> bool { self.map.remove(value) }\n-\n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty uintersection.\n     fn is_disjoint(&self, other: &SmallIntSet) -> bool {\n@@ -412,6 +405,16 @@ impl Set<uint> for SmallIntSet {\n     }\n }\n \n+impl MutableSet<uint> for SmallIntSet {\n+    /// Add a value to the set. Return true if the value was not already\n+    /// present in the set.\n+    fn insert(&mut self, value: uint) -> bool { self.map.insert(value, ()) }\n+\n+    /// Remove a value from the set. Return true if the value was\n+    /// present in the set.\n+    fn remove(&mut self, value: &uint) -> bool { self.map.remove(value) }\n+}\n+\n impl SmallIntSet {\n     /// Create an empty SmallIntSet\n     pub fn new() -> SmallIntSet { SmallIntSet{map: SmallIntMap::new()} }"}, {"sha": "05a941b4925d006a92d7612d860f730e5e9b673a", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "patch": "@@ -124,7 +124,9 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n             }\n         }\n     }\n+}\n \n+impl<K: TotalOrd, V> MutableMap<K, V> for TreeMap<K, V> {\n     /// Return a mutable reference to the value corresponding to the key\n     #[inline]\n     fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n@@ -293,16 +295,6 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n         self.map.contains_key(value)\n     }\n \n-    /// Add a value to the set. Return true if the value was not already\n-    /// present in the set.\n-    #[inline]\n-    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n-\n-    /// Remove a value from the set. Return true if the value was\n-    /// present in the set.\n-    #[inline]\n-    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n-\n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n@@ -475,6 +467,18 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n }\n \n+impl<T: TotalOrd> MutableSet<T> for TreeSet<T> {\n+    /// Add a value to the set. Return true if the value was not already\n+    /// present in the set.\n+    #[inline]\n+    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+\n+    /// Remove a value from the set. Return true if the value was\n+    /// present in the set.\n+    #[inline]\n+    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+}\n+\n impl<T: TotalOrd> TreeSet<T> {\n     /// Create an empty TreeSet\n     #[inline]"}, {"sha": "4bad28ca3383081bf04f3f140168074268a138f6", "filename": "src/libstd/container.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibstd%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibstd%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcontainer.rs?ref=6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "patch": "@@ -30,16 +30,16 @@ pub trait Mutable: Container {\n \n /// A map is a key-value store where values may be looked up by their keys. This\n /// trait provides basic operations to operate on these stores.\n-pub trait Map<K, V>: Mutable {\n+pub trait Map<K, V>: Container {\n     /// Return true if the map contains a value for the specified key\n     fn contains_key(&self, key: &K) -> bool;\n \n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V>;\n+}\n \n-    /// Return a mutable reference to the value corresponding to the key\n-    fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V>;\n-\n+/// This trait provides basic operations to modify the contents of a map.\n+pub trait MutableMap<K, V>: Map<K, V> + Mutable {\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -56,23 +56,18 @@ pub trait Map<K, V>: Mutable {\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     fn pop(&mut self, k: &K) -> Option<V>;\n+\n+    /// Return a mutable reference to the value corresponding to the key\n+    fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V>;\n }\n \n /// A set is a group of objects which are each distinct from one another. This\n-/// trait represents actions which can be performed on sets to manipulate and\n-/// iterate over them.\n-pub trait Set<T>: Mutable {\n+/// trait represents actions which can be performed on sets to iterate over\n+/// them.\n+pub trait Set<T>: Container {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &T) -> bool;\n \n-    /// Add a value to the set. Return true if the value was not already\n-    /// present in the set.\n-    fn insert(&mut self, value: T) -> bool;\n-\n-    /// Remove a value from the set. Return true if the value was\n-    /// present in the set.\n-    fn remove(&mut self, value: &T) -> bool;\n-\n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     fn is_disjoint(&self, other: &Self) -> bool;\n@@ -95,3 +90,15 @@ pub trait Set<T>: Mutable {\n     /// Visit the values representing the union\n     fn union(&self, other: &Self, f: &fn(&T) -> bool) -> bool;\n }\n+\n+/// This trait represents actions which can be performed on sets to mutate\n+/// them.\n+pub trait MutableSet<T>: Set<T> + Mutable {\n+    /// Add a value to the set. Return true if the value was not already\n+    /// present in the set.\n+    fn insert(&mut self, value: T) -> bool;\n+\n+    /// Remove a value from the set. Return true if the value was\n+    /// present in the set.\n+    fn remove(&mut self, value: &T) -> bool;\n+}"}, {"sha": "9d0588fdcc1b0f4434a5e686704af053659dbbee", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "patch": "@@ -39,7 +39,7 @@ with destructors.\n */\n \n use cast;\n-use container::{Map, Set};\n+use container::{Set, MutableSet};\n use io;\n use libc::{uintptr_t};\n use option::{None, Option, Some};"}, {"sha": "e95c63e891201c825656cfcb97da7e33cd13d777", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "patch": "@@ -15,7 +15,7 @@\n \n #[mutable_doc];\n \n-use container::{Container, Mutable, Map, Set};\n+use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use cmp::{Eq, Equiv};\n use hash::Hash;\n use iterator::{Iterator, IteratorUtil};\n@@ -316,7 +316,9 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n             TableFull | FoundHole(_) => None,\n         }\n     }\n+}\n \n+impl<K:Hash + Eq,V> MutableMap<K, V> for HashMap<K, V> {\n     /// Return a mutable reference to the value corresponding to the key\n     fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n         let idx = match self.bucket_for_key(k) {\n@@ -640,14 +642,6 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n \n-    /// Add a value to the set. Return true if the value was not already\n-    /// present in the set.\n-    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n-\n-    /// Remove a value from the set. Return true if the value was\n-    /// present in the set.\n-    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n-\n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     fn is_disjoint(&self, other: &HashSet<T>) -> bool {\n@@ -688,6 +682,16 @@ impl<T:Hash + Eq> Set<T> for HashSet<T> {\n     }\n }\n \n+impl<T:Hash + Eq> MutableSet<T> for HashSet<T> {\n+    /// Add a value to the set. Return true if the value was not already\n+    /// present in the set.\n+    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+\n+    /// Remove a value from the set. Return true if the value was\n+    /// present in the set.\n+    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+}\n+\n impl<T:Hash + Eq> HashSet<T> {\n     /// Create an empty HashSet\n     pub fn new() -> HashSet<T> {"}, {"sha": "8be34896bef6d4f797fc8b677cceb66806b51f5e", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "patch": "@@ -45,7 +45,7 @@ pub use io::{print, println};\n pub use clone::{Clone, DeepClone};\n pub use cmp::{Eq, ApproxEq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater, Equiv};\n pub use char::Char;\n-pub use container::{Container, Mutable, Map, Set};\n+pub use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n pub use hash::Hash;\n pub use iter::Times;\n pub use iterator::{Iterator, IteratorUtil, DoubleEndedIterator, DoubleEndedIteratorUtil};"}, {"sha": "27cb1c2c1000a328959194383291f3886211a518", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "patch": "@@ -77,7 +77,7 @@ use prelude::*;\n use cast::transmute;\n use cast;\n use cell::Cell;\n-use container::Map;\n+use container::MutableMap;\n use comm::{Chan, GenericChan};\n use hashmap::HashSet;\n use task::local_data_priv::{local_get, local_set, OldHandle};"}, {"sha": "0c82df7e43a5ed023026052c630f6fbd4b8d36a2", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "patch": "@@ -182,7 +182,7 @@ impl<A:ToStr> ToStr for @[A] {\n mod tests {\n     use hashmap::HashMap;\n     use hashmap::HashSet;\n-    use container::{Set, Map};\n+    use container::{Set, Map, MutableSet, MutableMap};\n     #[test]\n     fn test_simple_types() {\n         assert_eq!(1i.to_str(), ~\"1\");"}, {"sha": "c4bfda7e2bef0fa13fd4ec1dc1e9537de5f56908", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "patch": "@@ -78,7 +78,9 @@ impl<T> Map<uint, T> for TrieMap<T> {\n             idx += 1;\n         }\n     }\n+}\n \n+impl<T> MutableMap<uint, T> for TrieMap<T> {\n     /// Return a mutable reference to the value corresponding to the key\n     #[inline]\n     fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {"}, {"sha": "a1ea1d6e3e2af9807a00b3c864ab8d97c8b0af9d", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=6b37b5bab74a87c4f05274e6a49d9e28a4c0f4e1", "patch": "@@ -11,7 +11,6 @@\n // xfail-fast\n \n use std::cmp;\n-use std::container::{Container, Mutable, Map};\n use std::int;\n use std::uint;\n \n@@ -63,18 +62,20 @@ impl<T> Mutable for cat<T> {\n impl<T> Map<int, T> for cat<T> {\n     fn contains_key(&self, k: &int) -> bool { *k <= self.meows }\n \n-    fn insert(&mut self, k: int, _: T) -> bool {\n-        self.meows += k;\n-        true\n-    }\n-\n     fn find<'a>(&'a self, k: &int) -> Option<&'a T> {\n         if *k <= self.meows {\n             Some(&self.name)\n         } else {\n             None\n         }\n     }\n+}\n+\n+impl<T> MutableMap<int, T> for cat<T> {\n+    fn insert(&mut self, k: int, _: T) -> bool {\n+        self.meows += k;\n+        true\n+    }\n \n     fn find_mut<'a>(&'a mut self, _k: &int) -> Option<&'a mut T> { fail!() }\n "}]}