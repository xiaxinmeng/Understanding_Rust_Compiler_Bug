{"sha": "f399d308028fb491427a34b2ac70db797536280b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzOTlkMzA4MDI4ZmI0OTE0MjdhMzRiMmFjNzBkYjc5NzUzNjI4MGI=", "commit": {"author": {"name": "Piotr Jawniak", "email": "sawyer47@gmail.com", "date": "2014-07-28T19:24:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-29T22:43:59Z"}, "message": "Improve documentation of rounding functions", "tree": {"sha": "07a8fe3c6557300c0aa0db8d2851657757cb51a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07a8fe3c6557300c0aa0db8d2851657757cb51a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f399d308028fb491427a34b2ac70db797536280b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f399d308028fb491427a34b2ac70db797536280b", "html_url": "https://github.com/rust-lang/rust/commit/f399d308028fb491427a34b2ac70db797536280b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f399d308028fb491427a34b2ac70db797536280b/comments", "author": {"login": "Sawyer47", "id": 1534302, "node_id": "MDQ6VXNlcjE1MzQzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/1534302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Sawyer47", "html_url": "https://github.com/Sawyer47", "followers_url": "https://api.github.com/users/Sawyer47/followers", "following_url": "https://api.github.com/users/Sawyer47/following{/other_user}", "gists_url": "https://api.github.com/users/Sawyer47/gists{/gist_id}", "starred_url": "https://api.github.com/users/Sawyer47/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Sawyer47/subscriptions", "organizations_url": "https://api.github.com/users/Sawyer47/orgs", "repos_url": "https://api.github.com/users/Sawyer47/repos", "events_url": "https://api.github.com/users/Sawyer47/events{/privacy}", "received_events_url": "https://api.github.com/users/Sawyer47/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a3c0d91cfc3852837f857aff0c23c0055bc94fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a3c0d91cfc3852837f857aff0c23c0055bc94fc", "html_url": "https://github.com/rust-lang/rust/commit/2a3c0d91cfc3852837f857aff0c23c0055bc94fc"}], "stats": {"total": 96, "additions": 53, "deletions": 43}, "files": [{"sha": "d4cf10b384f39aba8abeb08c6864cfeb4c76c4be", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f399d308028fb491427a34b2ac70db797536280b/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f399d308028fb491427a34b2ac70db797536280b/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=f399d308028fb491427a34b2ac70db797536280b", "patch": "@@ -117,23 +117,23 @@ impl Float for f32 {\n     #[inline]\n     fn neg_zero() -> f32 { -0.0 }\n \n-    /// Returns `true` if the number is NaN\n+    /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool { self != self }\n \n-    /// Returns `true` if the number is infinite\n+    /// Returns `true` if the number is infinite.\n     #[inline]\n     fn is_infinite(self) -> bool {\n         self == Float::infinity() || self == Float::neg_infinity()\n     }\n \n-    /// Returns `true` if the number is neither infinite or NaN\n+    /// Returns `true` if the number is neither infinite or NaN.\n     #[inline]\n     fn is_finite(self) -> bool {\n         !(self.is_nan() || self.is_infinite())\n     }\n \n-    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n+    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN.\n     #[inline]\n     fn is_normal(self) -> bool {\n         self.classify() == FPNormal\n@@ -195,25 +195,25 @@ impl Float for f32 {\n         (mantissa as u64, exponent, sign)\n     }\n \n-    /// Round half-way cases toward `NEG_INFINITY`\n+    /// Rounds towards minus infinity.\n     #[inline]\n     fn floor(self) -> f32 {\n         unsafe { intrinsics::floorf32(self) }\n     }\n \n-    /// Round half-way cases toward `INFINITY`\n+    /// Rounds towards plus infinity.\n     #[inline]\n     fn ceil(self) -> f32 {\n         unsafe { intrinsics::ceilf32(self) }\n     }\n \n-    /// Round half-way cases away from `0.0`\n+    /// Rounds to nearest integer. Rounds half-way cases away from zero.\n     #[inline]\n     fn round(self) -> f32 {\n         unsafe { intrinsics::roundf32(self) }\n     }\n \n-    /// The integer part of the number (rounds towards `0.0`)\n+    /// Returns the integer part of the number (rounds towards zero).\n     #[inline]\n     fn trunc(self) -> f32 {\n         unsafe { intrinsics::truncf32(self) }\n@@ -236,7 +236,7 @@ impl Float for f32 {\n         unsafe { intrinsics::fmaf32(self, a, b) }\n     }\n \n-    /// The reciprocal (multiplicative inverse) of the number\n+    /// Returns the reciprocal (multiplicative inverse) of the number.\n     #[inline]\n     fn recip(self) -> f32 { 1.0 / self }\n \n@@ -325,45 +325,45 @@ impl Float for f32 {\n     #[inline]\n     fn ln_10() -> f32 { consts::LN_10 }\n \n-    /// Returns the exponential of the number\n+    /// Returns the exponential of the number.\n     #[inline]\n     fn exp(self) -> f32 {\n         unsafe { intrinsics::expf32(self) }\n     }\n \n-    /// Returns 2 raised to the power of the number\n+    /// Returns 2 raised to the power of the number.\n     #[inline]\n     fn exp2(self) -> f32 {\n         unsafe { intrinsics::exp2f32(self) }\n     }\n \n-    /// Returns the natural logarithm of the number\n+    /// Returns the natural logarithm of the number.\n     #[inline]\n     fn ln(self) -> f32 {\n         unsafe { intrinsics::logf32(self) }\n     }\n \n-    /// Returns the logarithm of the number with respect to an arbitrary base\n+    /// Returns the logarithm of the number with respect to an arbitrary base.\n     #[inline]\n     fn log(self, base: f32) -> f32 { self.ln() / base.ln() }\n \n-    /// Returns the base 2 logarithm of the number\n+    /// Returns the base 2 logarithm of the number.\n     #[inline]\n     fn log2(self) -> f32 {\n         unsafe { intrinsics::log2f32(self) }\n     }\n \n-    /// Returns the base 10 logarithm of the number\n+    /// Returns the base 10 logarithm of the number.\n     #[inline]\n     fn log10(self) -> f32 {\n         unsafe { intrinsics::log10f32(self) }\n     }\n \n-    /// Converts to degrees, assuming the number is in radians\n+    /// Converts to degrees, assuming the number is in radians.\n     #[inline]\n     fn to_degrees(self) -> f32 { self * (180.0f32 / Float::pi()) }\n \n-    /// Converts to radians, assuming the number is in degrees\n+    /// Converts to radians, assuming the number is in degrees.\n     #[inline]\n     fn to_radians(self) -> f32 {\n         let value: f32 = Float::pi();"}, {"sha": "a3ae8e7c79ea355309dc9189cf13c822966b3b21", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f399d308028fb491427a34b2ac70db797536280b/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f399d308028fb491427a34b2ac70db797536280b/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=f399d308028fb491427a34b2ac70db797536280b", "patch": "@@ -123,23 +123,23 @@ impl Float for f64 {\n     #[inline]\n     fn neg_zero() -> f64 { -0.0 }\n \n-    /// Returns `true` if the number is NaN\n+    /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool { self != self }\n \n-    /// Returns `true` if the number is infinite\n+    /// Returns `true` if the number is infinite.\n     #[inline]\n     fn is_infinite(self) -> bool {\n         self == Float::infinity() || self == Float::neg_infinity()\n     }\n \n-    /// Returns `true` if the number is neither infinite or NaN\n+    /// Returns `true` if the number is neither infinite or NaN.\n     #[inline]\n     fn is_finite(self) -> bool {\n         !(self.is_nan() || self.is_infinite())\n     }\n \n-    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n+    /// Returns `true` if the number is neither zero, infinite, subnormal or NaN.\n     #[inline]\n     fn is_normal(self) -> bool {\n         self.classify() == FPNormal\n@@ -201,25 +201,25 @@ impl Float for f64 {\n         (mantissa, exponent, sign)\n     }\n \n-    /// Round half-way cases toward `NEG_INFINITY`\n+    /// Rounds towards minus infinity.\n     #[inline]\n     fn floor(self) -> f64 {\n         unsafe { intrinsics::floorf64(self) }\n     }\n \n-    /// Round half-way cases toward `INFINITY`\n+    /// Rounds towards plus infinity.\n     #[inline]\n     fn ceil(self) -> f64 {\n         unsafe { intrinsics::ceilf64(self) }\n     }\n \n-    /// Round half-way cases away from `0.0`\n+    /// Rounds to nearest integer. Rounds half-way cases away from zero.\n     #[inline]\n     fn round(self) -> f64 {\n         unsafe { intrinsics::roundf64(self) }\n     }\n \n-    /// The integer part of the number (rounds towards `0.0`)\n+    /// Returns the integer part of the number (rounds towards zero).\n     #[inline]\n     fn trunc(self) -> f64 {\n         unsafe { intrinsics::truncf64(self) }\n@@ -242,7 +242,7 @@ impl Float for f64 {\n         unsafe { intrinsics::fmaf64(self, a, b) }\n     }\n \n-    /// The reciprocal (multiplicative inverse) of the number\n+    /// Returns the reciprocal (multiplicative inverse) of the number.\n     #[inline]\n     fn recip(self) -> f64 { 1.0 / self }\n \n@@ -332,46 +332,45 @@ impl Float for f64 {\n     #[inline]\n     fn ln_10() -> f64 { consts::LN_10 }\n \n-    /// Returns the exponential of the number\n+    /// Returns the exponential of the number.\n     #[inline]\n     fn exp(self) -> f64 {\n         unsafe { intrinsics::expf64(self) }\n     }\n \n-    /// Returns 2 raised to the power of the number\n+    /// Returns 2 raised to the power of the number.\n     #[inline]\n     fn exp2(self) -> f64 {\n         unsafe { intrinsics::exp2f64(self) }\n     }\n \n-    /// Returns the natural logarithm of the number\n+    /// Returns the natural logarithm of the number.\n     #[inline]\n     fn ln(self) -> f64 {\n         unsafe { intrinsics::logf64(self) }\n     }\n \n-    /// Returns the logarithm of the number with respect to an arbitrary base\n+    /// Returns the logarithm of the number with respect to an arbitrary base.\n     #[inline]\n     fn log(self, base: f64) -> f64 { self.ln() / base.ln() }\n \n-    /// Returns the base 2 logarithm of the number\n+    /// Returns the base 2 logarithm of the number.\n     #[inline]\n     fn log2(self) -> f64 {\n         unsafe { intrinsics::log2f64(self) }\n     }\n \n-    /// Returns the base 10 logarithm of the number\n+    /// Returns the base 10 logarithm of the number.\n     #[inline]\n     fn log10(self) -> f64 {\n         unsafe { intrinsics::log10f64(self) }\n     }\n \n-\n-    /// Converts to degrees, assuming the number is in radians\n+    /// Converts to degrees, assuming the number is in radians.\n     #[inline]\n     fn to_degrees(self) -> f64 { self * (180.0f64 / Float::pi()) }\n \n-    /// Converts to radians, assuming the number is in degrees\n+    /// Converts to radians, assuming the number is in degrees.\n     #[inline]\n     fn to_radians(self) -> f64 {\n         let value: f64 = Float::pi();"}, {"sha": "e0f6b4fb9af66a12ccb06e6f4282d12f6ed65890", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f399d308028fb491427a34b2ac70db797536280b/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f399d308028fb491427a34b2ac70db797536280b/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=f399d308028fb491427a34b2ac70db797536280b", "patch": "@@ -38,13 +38,13 @@ pub type BigRational = Ratio<BigInt>;\n \n impl<T: Clone + Integer + PartialOrd>\n     Ratio<T> {\n-    /// Create a ratio representing the integer `t`.\n+    /// Creates a ratio representing the integer `t`.\n     #[inline]\n     pub fn from_integer(t: T) -> Ratio<T> {\n         Ratio::new_raw(t, One::one())\n     }\n \n-    /// Create a ratio without checking for `denom == 0` or reducing.\n+    /// Creates a ratio without checking for `denom == 0` or reducing.\n     #[inline]\n     pub fn new_raw(numer: T, denom: T) -> Ratio<T> {\n         Ratio { numer: numer, denom: denom }\n@@ -61,7 +61,7 @@ impl<T: Clone + Integer + PartialOrd>\n         ret\n     }\n \n-    /// Convert to an integer.\n+    /// Converts to an integer.\n     #[inline]\n     pub fn to_integer(&self) -> T {\n         self.trunc().numer\n@@ -79,7 +79,7 @@ impl<T: Clone + Integer + PartialOrd>\n         &self.denom\n     }\n \n-    /// Return true if the rational number is an integer (denominator is 1).\n+    /// Returns true if the rational number is an integer (denominator is 1).\n     #[inline]\n     pub fn is_integer(&self) -> bool {\n         self.denom == One::one()\n@@ -103,19 +103,21 @@ impl<T: Clone + Integer + PartialOrd>\n         }\n     }\n \n-    /// Return a `reduce`d copy of self.\n+    /// Returns a `reduce`d copy of self.\n     pub fn reduced(&self) -> Ratio<T> {\n         let mut ret = self.clone();\n         ret.reduce();\n         ret\n     }\n \n-    /// Return the reciprocal\n+    /// Returns the reciprocal.\n     #[inline]\n     pub fn recip(&self) -> Ratio<T> {\n         Ratio::new_raw(self.denom.clone(), self.numer.clone())\n     }\n \n+    /// Rounds towards minus infinity.\n+    #[inline]\n     pub fn floor(&self) -> Ratio<T> {\n         if *self < Zero::zero() {\n             Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n@@ -124,6 +126,8 @@ impl<T: Clone + Integer + PartialOrd>\n         }\n     }\n \n+    /// Rounds towards plus infinity.\n+    #[inline]\n     pub fn ceil(&self) -> Ratio<T> {\n         if *self < Zero::zero() {\n             Ratio::from_integer(self.numer / self.denom)\n@@ -132,27 +136,34 @@ impl<T: Clone + Integer + PartialOrd>\n         }\n     }\n \n+    /// Rounds to the nearest integer. Rounds half-way cases away from zero.\n+    ///\n+    /// Note: This function is currently broken and always rounds away from zero.\n     #[inline]\n     pub fn round(&self) -> Ratio<T> {\n+        // FIXME(#15826)\n         if *self < Zero::zero() {\n             Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n         } else {\n             Ratio::from_integer((self.numer + self.denom - One::one()) / self.denom)\n         }\n     }\n \n+    /// Rounds towards zero.\n     #[inline]\n     pub fn trunc(&self) -> Ratio<T> {\n         Ratio::from_integer(self.numer / self.denom)\n     }\n \n+    ///Returns the fractional part of a number.\n+    #[inline]\n     pub fn fract(&self) -> Ratio<T> {\n         Ratio::new_raw(self.numer % self.denom, self.denom.clone())\n     }\n }\n \n impl Ratio<BigInt> {\n-    /// Converts a float into a rational number\n+    /// Converts a float into a rational number.\n     pub fn from_float<T: Float>(f: T) -> Option<BigRational> {\n         if !f.is_finite() {\n             return None;\n@@ -328,7 +339,7 @@ impl<T: ToStrRadix> ToStrRadix for Ratio<T> {\n \n impl<T: FromStr + Clone + Integer + PartialOrd>\n     FromStr for Ratio<T> {\n-    /// Parses `numer/denom` or just `numer`\n+    /// Parses `numer/denom` or just `numer`.\n     fn from_str(s: &str) -> Option<Ratio<T>> {\n         let mut split = s.splitn('/', 1);\n "}]}