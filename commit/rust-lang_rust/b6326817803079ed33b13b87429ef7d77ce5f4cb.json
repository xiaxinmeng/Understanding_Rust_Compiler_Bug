{"sha": "b6326817803079ed33b13b87429ef7d77ce5f4cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MzI2ODE3ODAzMDc5ZWQzM2IxM2I4NzQyOWVmN2Q3N2NlNWY0Y2I=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-06-21T00:25:49Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-28T15:02:12Z"}, "message": "Add AST fold.", "tree": {"sha": "7fb8904daa262e2d4ae9d876f8f9f92a4697c3ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fb8904daa262e2d4ae9d876f8f9f92a4697c3ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6326817803079ed33b13b87429ef7d77ce5f4cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6326817803079ed33b13b87429ef7d77ce5f4cb", "html_url": "https://github.com/rust-lang/rust/commit/b6326817803079ed33b13b87429ef7d77ce5f4cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6326817803079ed33b13b87429ef7d77ce5f4cb/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be748fc21586f32ca797dcda95ddc122ae8ab334", "url": "https://api.github.com/repos/rust-lang/rust/commits/be748fc21586f32ca797dcda95ddc122ae8ab334", "html_url": "https://github.com/rust-lang/rust/commit/be748fc21586f32ca797dcda95ddc122ae8ab334"}], "stats": {"total": 690, "additions": 690, "deletions": 0}, "files": [{"sha": "fe0def71af140b7619281309d3bb1367a183b344", "filename": "src/comp/front/fold.rs", "status": "added", "additions": 689, "deletions": 0, "changes": 689, "blob_url": "https://github.com/rust-lang/rust/blob/b6326817803079ed33b13b87429ef7d77ce5f4cb/src%2Fcomp%2Ffront%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6326817803079ed33b13b87429ef7d77ce5f4cb/src%2Fcomp%2Ffront%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ffold.rs?ref=b6326817803079ed33b13b87429ef7d77ce5f4cb", "patch": "@@ -0,0 +1,689 @@\n+import util::common::span;\n+import ast::*;\n+\n+import std::vec;\n+import std::option;\n+import vec::map;\n+\n+export ast_fold_precursor;\n+export ast_fold;\n+export default_ast_fold;\n+export make_fold;\n+export dummy_out;\n+\n+type ast_fold = @mutable a_f;\n+\n+// We may eventually want to be able to fold over type parameters, too\n+\n+type ast_fold_precursor = \n+    rec(fn (&crate_ c, ast_fold) -> crate_                fold_crate,\n+        fn (&crate_directive_ cd, ast_fold) -> crate_directive_ \n+                                                 fold_crate_directive,\n+        fn (&view_item_ i, ast_fold) -> view_item_        fold_view_item,\n+        fn (&@native_item i, ast_fold) -> @native_item    fold_native_item,\n+        fn (&@item i, ast_fold) -> @item                  fold_item,\n+        //unlike the others, item_ is non-trivial\n+        fn (&item_ i, ast_fold) -> item_        fold_item_underscore,\n+        fn (&method_ m, ast_fold) -> method_              fold_method,\n+        fn (&block_ b, ast_fold) -> block_                fold_block,\n+        fn (&stmt_ s, ast_fold) -> stmt_                  fold_stmt,\n+        fn (&arm a, ast_fold) -> arm                      fold_arm,\n+        fn (&pat_ p, ast_fold) -> pat_                    fold_pat,\n+        fn (&decl_ d, ast_fold) -> decl_                  fold_decl,\n+        fn (&expr_ e, ast_fold) -> expr_                  fold_expr,\n+        fn (&ty_ t, ast_fold) -> ty_                      fold_ty,\n+        fn (&constr_ c, ast_fold) -> constr_              fold_constr,\n+        fn (&_fn f, ast_fold) -> _fn                      fold_fn,\n+        fn (&_mod m, ast_fold) -> _mod                    fold_mod,\n+        fn (&native_mod, ast_fold) -> native_mod          fold_native_mod,\n+        fn (&variant_, ast_fold) -> variant_              fold_variant,\n+        fn (&ident, ast_fold) -> ident                    fold_ident,\n+        fn (&path_, ast_fold) -> path_                    fold_path,\n+        fn (&local_, ast_fold) -> local_                  fold_local\n+        );\n+\n+type a_f =\n+    rec(fn (&crate c) -> crate                        fold_crate,\n+        fn (&@crate_directive cd) -> @crate_directive fold_crate_directive,\n+        fn (&@view_item i) -> @view_item              fold_view_item,\n+        fn (&@native_item i) -> @native_item          fold_native_item,\n+        fn (&@item i) -> @item                        fold_item,\n+        fn (&item_ i) -> item_                        fold_item_underscore,\n+        fn (&@method m) -> @method                    fold_method,\n+        fn (&block b) -> block                        fold_block,\n+        fn (&@stmt s) -> @stmt                        fold_stmt,\n+        fn (&arm a) -> arm                            fold_arm,\n+        fn (&@pat p) -> @pat                          fold_pat,\n+        fn (&@decl d) -> @decl                        fold_decl,\n+        fn (&@expr e) -> @expr                        fold_expr,\n+        fn (&@ty t) -> @ty                            fold_ty,\n+        fn (&@constr c) -> @constr                    fold_constr,\n+        fn (&_fn f) -> _fn                            fold_fn,\n+        fn (&_mod m) -> _mod                          fold_mod,\n+        fn (&native_mod) -> native_mod                fold_native_mod,\n+        fn (&variant) -> variant                      fold_variant,\n+        fn (&ident) -> ident                          fold_ident,\n+        fn (&path) -> path                            fold_path,\n+        fn (&@local) -> @local                        fold_local\n+        );\n+\n+//fn nf_dummy[T](&T node) -> T { fail; }\n+fn nf_crate_dummy(&crate c) -> crate { fail; }\n+fn nf_crate_directive_dummy(&@crate_directive c) \n+    -> @crate_directive { fail; }\n+fn nf_view_item_dummy(&@view_item v) -> @view_item { fail; } \n+fn nf_native_item_dummy(&@native_item n) -> @native_item { fail; } \n+fn nf_item_dummy(&@item i) -> @item { fail; } \n+fn nf_item_underscore_dummy(&item_ i) -> item_ { fail; } \n+fn nf_method_dummy(&@method m) -> @method { fail; } \n+fn nf_block_dummy(&block b) -> block { fail; } \n+fn nf_stmt_dummy(&@stmt s) -> @stmt { fail; } \n+fn nf_arm_dummy(&arm a) -> arm { fail; } \n+fn nf_pat_dummy(&@pat p) -> @pat { fail; } \n+fn nf_decl_dummy(&@decl d) -> @decl { fail; } \n+fn nf_expr_dummy(&@expr e) -> @expr { fail; } \n+fn nf_ty_dummy(&@ty t) -> @ty { fail; } \n+fn nf_constr_dummy(&@constr c) -> @constr { fail; } \n+fn nf_fn_dummy(&_fn f) -> _fn { fail; } \n+fn nf_mod_dummy(&_mod m) -> _mod { fail; } \n+fn nf_native_mod_dummy(&native_mod n) -> native_mod { fail; } \n+fn nf_variant_dummy(&variant v) -> variant { fail; } \n+fn nf_ident_dummy(&ident i) -> ident { fail; } \n+fn nf_path_dummy(&path p) -> path { fail; } \n+fn nf_obj_field_dummy(&obj_field o) -> obj_field { fail; }\n+fn nf_local_dummy(&@local o) -> @local { fail; }\n+\n+/* some little folds that probably aren't useful to have in ast_fold itself*/\n+\n+//used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n+fn fold_meta_item_(&@meta_item mi, ast_fold fld) -> @meta_item {\n+    ret @rec(node=\n+             alt (mi.node) {\n+                 case (meta_word(?id)) { meta_word(fld.fold_ident(id)) }\n+                 case (meta_list(?id, ?mis)) {\n+                     auto fold_meta_item = bind fold_meta_item_(_,fld);\n+                     meta_list(id, map(fold_meta_item, mis))\n+                 }\n+                 case (meta_key_value(?id,?s)) {\n+                     meta_key_value(fld.fold_ident(id),s)\n+                 }\n+             },\n+             span=mi.span);\n+}\n+//used in noop_fold_item and noop_fold_crate\n+fn fold_attribute_(&attribute at, fn(&@meta_item) -> @meta_item fmi) \n+    -> attribute {\n+    ret rec(node=rec(style=at.node.style,\n+                     value=*fmi(@at.node.value)),\n+            span=at.span);\n+}\n+//used in noop_fold_native_item and noop_fold_fn\n+fn fold_arg_(&arg a, ast_fold fld) -> arg {\n+    ret rec(mode=a.mode, ty=fld.fold_ty(a.ty), \n+            ident=fld.fold_ident(a.ident), id=a.id);\n+}\n+\n+\n+\n+\n+fn noop_fold_crate(&crate_ c, ast_fold fld) -> crate_ {\n+    auto fold_meta_item = bind fold_meta_item_(_,fld);\n+    auto fold_attribute = bind fold_attribute_(_,fold_meta_item);\n+\n+    ret rec(directives=map(fld.fold_crate_directive, c.directives),\n+            module=c.module, attrs=map(fold_attribute, c.attrs));\n+}\n+\n+fn noop_fold_crate_directive(&crate_directive_ cd, ast_fold fld) \n+    -> crate_directive_ {\n+    auto fold_meta_item = bind fold_meta_item_(_,fld);\n+    ret alt(cd) {\n+        case(cdir_expr(?e)) { cdir_expr(fld.fold_expr(e)) }\n+        case(cdir_let(?id, ?e, ?cds)) {\n+            cdir_let(fld.fold_ident(id), fld.fold_expr(e),\n+                     map(fld.fold_crate_directive, cds))\n+                }\n+        case(cdir_src_mod(?id,?fname)) { \n+            cdir_src_mod(fld.fold_ident(id), fname)\n+                }\n+        case(cdir_dir_mod(?id,?fname,?cds)) {\n+            cdir_dir_mod(fld.fold_ident(id),fname,\n+                         map(fld.fold_crate_directive, cds))\n+                }\n+        case(cdir_view_item(?vi)) { \n+            cdir_view_item(fld.fold_view_item(vi))\n+                }\n+        case(cdir_syntax(_)) { cd }\n+        case(cdir_auth(_,_)) { cd }\n+    }\n+}\n+\n+fn noop_fold_view_item(&view_item_ vi, ast_fold fld) -> view_item_ {\n+    ret vi;\n+}\n+\n+\n+fn noop_fold_native_item(&@native_item ni, ast_fold fld) -> @native_item {\n+    auto fold_arg = bind fold_arg_(_, fld);\n+\n+    ret @rec(ident=fld.fold_ident(ni.ident),\n+             node=alt (ni.node) {\n+                 case (native_item_ty) { native_item_ty }\n+                 case (native_item_fn(?st, ?fdec, ?typms)) {\n+                     native_item_fn(st, \n+                                    rec(inputs=map(fold_arg, fdec.inputs),\n+                                        output=fld.fold_ty(fdec.output),\n+                                        purity=fdec.purity, cf=fdec.cf,\n+                                        constraints=map(fld.fold_constr,\n+                                                        fdec.constraints)),\n+                                    typms)\n+                 }\n+             },\n+             id=ni.id,\n+             span=ni.span);\n+}\n+\n+fn noop_fold_item(&@item i, ast_fold fld) -> @item {\n+    auto fold_meta_item = bind fold_meta_item_(_,fld);\n+    auto fold_attribute = bind fold_attribute_(_,fold_meta_item);\n+\n+    ret @rec(ident=fld.fold_ident(i.ident),\n+             attrs=map(fold_attribute,i.attrs),\n+             id=i.id, node=fld.fold_item_underscore(i.node),\n+             span=i.span);\n+}\n+\n+fn noop_fold_item_underscore(&item_ i, ast_fold fld) -> item_ {\n+    fn fold_obj_field_(&obj_field of, ast_fold fld) -> obj_field {\n+        ret rec(mut=of.mut, ty=fld.fold_ty(of.ty), \n+                ident=fld.fold_ident(of.ident), id=of.id);\n+    }\n+    auto fold_obj_field = bind fold_obj_field_(_,fld);\n+\n+    ret alt(i) {\n+        case (item_const(?t, ?e)) {\n+            item_const(fld.fold_ty(t), fld.fold_expr(e))\n+        }\n+        case (item_fn(?f, ?typms)) {\n+            item_fn(fld.fold_fn(f), typms)\n+        }\n+        case (item_mod(?m)) { item_mod(fld.fold_mod(m)) }\n+        case (item_native_mod(?nm)) {\n+            item_native_mod(fld.fold_native_mod(nm))\n+                }\n+        case (item_ty(?t, ?typms)) {\n+            item_ty(fld.fold_ty(t), typms)\n+                }\n+        case (item_tag(?variants, ?typms)) {\n+            item_tag(map(fld.fold_variant, variants), typms)\n+                }\n+        case (item_obj(?o, ?typms, ?d)) {\n+            item_obj(rec(fields=map(fold_obj_field,o.fields),\n+                         methods=map(fld.fold_method,o.methods),\n+                         dtor=option::map(fld.fold_method,o.dtor)),\n+                     typms, d)\n+                }\n+    };\n+}\n+\n+fn noop_fold_method(&method_ m, ast_fold fld) -> method_ {\n+    ret rec(ident=fld.fold_ident(m.ident),\n+            meth=fld.fold_fn(m.meth), id=m.id); \n+}\n+\n+\n+fn noop_fold_block(&block_ b, ast_fold fld) -> block_ {\n+    ret rec(stmts=map(fld.fold_stmt, b.stmts),\n+            expr=option::map(fld.fold_expr, b.expr), id=b.id);\n+}\n+\n+fn noop_fold_stmt(&stmt_ s, ast_fold fld) -> stmt_ {\n+    ret alt(s) {\n+        case (stmt_decl(?d, ?nid)) { stmt_decl(fld.fold_decl(d), nid) }\n+        case (stmt_expr(?e, ?nid)) { stmt_expr(fld.fold_expr(e), nid) }\n+        case (stmt_crate_directive(?cd)) {\n+                stmt_crate_directive(fld.fold_crate_directive(cd))\n+                    }\n+    };\n+}\n+\n+fn noop_fold_arm(&arm a, ast_fold fld) -> arm {\n+    ret rec(pat=fld.fold_pat(a.pat), block=fld.fold_block(a.block));\n+}\n+\n+fn noop_fold_pat(&pat_ p, ast_fold fld) -> pat_ {\n+    ret alt (p) {\n+        case (pat_wild(_)) { p }\n+        case (pat_bind(?id, ?d)) { pat_bind(fld.fold_ident(id), d)}\n+        case (pat_lit(_, _)) { p }\n+        case (pat_tag(?pth, ?pats, ?nid)) {\n+            pat_tag(fld.fold_path(pth), map(fld.fold_pat, pats), nid)\n+                }\n+    };\n+}\n+\n+fn noop_fold_decl(&decl_ d, ast_fold fld) -> decl_ {\n+    ret alt (d) {\n+        // local really doesn't need its own fold...\n+        case (decl_local(?l)) {\n+            decl_local(fld.fold_local(l))\n+        }\n+        case (decl_item(?it)) { decl_item(fld.fold_item(it)) }\n+    }\n+}\n+\n+fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n+    fn fold_elt_(&elt elt, ast_fold fld) -> elt {\n+        ret rec(mut=elt.mut, expr=fld.fold_expr(elt.expr));\n+    }\n+    auto fold_elt = bind fold_elt_(_,fld);\n+    fn fold_field_(&field field, ast_fold fld) -> field {\n+        ret rec(node=rec(mut=field.node.mut,\n+                         ident=fld.fold_ident(field.node.ident),\n+                         expr=fld.fold_expr(field.node.expr)),\n+                span=field.span);\n+    }\n+    auto fold_field = bind fold_field_(_,fld);\n+    fn fold_anon_obj_(&anon_obj ao, ast_fold fld) -> anon_obj {\n+        fn fold_anon_obj_field_(&anon_obj_field aof, ast_fold fld) \n+            -> anon_obj_field {\n+            ret rec(mut=aof.mut, ty=fld.fold_ty(aof.ty), \n+                    expr=fld.fold_expr(aof.expr),\n+                    ident=fld.fold_ident(aof.ident), id=aof.id);\n+        }\n+        auto fold_anon_obj_field = bind fold_anon_obj_field_(_,fld);\n+\n+        ret rec(fields=alt(ao.fields) {\n+                    case (option::none[vec[anon_obj_field]]) { ao.fields }\n+                    case (option::some[vec[anon_obj_field]](?v)) {\n+                        option::some[vec[anon_obj_field]]\n+                            (map(fold_anon_obj_field, v))\n+                    }},\n+                methods=map(fld.fold_method, ao.methods),\n+                with_obj=option::map(fld.fold_expr, ao.with_obj))\n+    }\n+    auto fold_anon_obj = bind fold_anon_obj_(_,fld);\n+    \n+\n+    ret alt (e) {\n+        case (expr_vec(?exprs, ?mut, ?seq_kind)) {\n+            expr_vec(map(fld.fold_expr, exprs), mut, seq_kind)\n+                }\n+        case (expr_tup(?elts)) {\n+            expr_tup(map(fold_elt, elts))\n+                }\n+        case (expr_rec(?fields, ?maybe_expr)) {\n+            expr_rec(map(fold_field, fields),\n+                     option::map(fld.fold_expr, maybe_expr))\n+                }\n+        case (expr_call(?f, ?args)) {\n+            expr_call(fld.fold_expr(f), map(fld.fold_expr, args))\n+                }\n+        case (expr_self_method(?id)) {\n+            expr_self_method(fld.fold_ident(id))\n+                }\n+        case (expr_bind(?f, ?args)) {\n+            auto opt_map_se = bind option::map(fld.fold_expr,_);\n+            expr_bind(fld.fold_expr(f), map(opt_map_se, args))\n+                }\n+        case (expr_spawn(?spawn_dom, ?name, ?f, ?args)) {\n+            expr_spawn(spawn_dom, name, fld.fold_expr(f), \n+                       map(fld.fold_expr, args))\n+                }\n+        case (expr_binary(?binop, ?lhs, ?rhs)) {\n+            expr_binary(binop, fld.fold_expr(lhs), fld.fold_expr(rhs))\n+                }\n+        case (expr_unary(?binop, ?ohs)) {\n+            expr_unary(binop, fld.fold_expr(ohs))\n+                }\n+        case (expr_lit(_)) { e }\n+        case (expr_cast(?expr, ?ty)) {\n+            expr_cast(fld.fold_expr(expr), ty)\n+        }\n+        case (expr_if(?cond, ?tr, ?fl)) {\n+            expr_if(fld.fold_expr(cond), fld.fold_block(tr), \n+                    option::map(fld.fold_expr, fl))\n+                }\n+        case (expr_while(?cond, ?body)) {\n+            expr_while(fld.fold_expr(cond), fld.fold_block(body))\n+                }\n+        case (expr_for(?decl, ?expr, ?block)) {\n+            expr_for(fld.fold_local(decl), fld.fold_expr(expr), \n+                     fld.fold_block(block))\n+                }\n+        case (expr_for_each(?decl, ?expr, ?block)) {\n+            expr_for_each(fld.fold_local(decl), fld.fold_expr(expr), \n+                          fld.fold_block(block))\n+                }\n+        case (expr_do_while(?block, ?expr)) {\n+            expr_do_while(fld.fold_block(block), fld.fold_expr(expr))\n+                }\n+        case (expr_alt(?expr, ?arms)) {\n+            expr_alt(fld.fold_expr(expr), map(fld.fold_arm, arms))\n+                }\n+        case (expr_block(?block)) {\n+            expr_block(fld.fold_block(block))\n+                }\n+        case (expr_move(?el, ?er)) {\n+            expr_move(fld.fold_expr(el), fld.fold_expr(er))\n+                }\n+        case (expr_assign(?el, ?er)) {\n+            expr_assign(fld.fold_expr(el), fld.fold_expr(er))\n+                }\n+        case (expr_assign_op(?op, ?el, ?er)) {\n+            expr_assign_op(op, fld.fold_expr(el), fld.fold_expr(er))\n+                }\n+        case (expr_send(?el, ?er)) {\n+            expr_send(fld.fold_expr(el), fld.fold_expr(er))\n+                }\n+        case (expr_recv(?el, ?er)) {\n+            expr_recv(fld.fold_expr(el), fld.fold_expr(er))\n+                }\n+        case (expr_field(?el, ?id)) {\n+            expr_field(fld.fold_expr(el), fld.fold_ident(id))\n+                }\n+        case (expr_index(?el, ?er)) {\n+            expr_index(fld.fold_expr(el), fld.fold_expr(er))\n+                }\n+        case (expr_path(?pth)) {\n+            expr_path(fld.fold_path(pth))\n+                }\n+        case (expr_ext(?pth, ?args, ?body, ?expanded)) {\n+            expr_ext(fld.fold_path(pth), map(fld.fold_expr, args),\n+                     body, fld.fold_expr(expanded))\n+                }\n+        case (expr_fail(_)) { e }\n+        case (expr_break()) { e }\n+        case (expr_cont()) { e }\n+        case (expr_ret(?e)) { \n+            expr_ret(option::map(fld.fold_expr, e))\n+                }\n+        case (expr_put(?e)) { \n+            expr_put(option::map(fld.fold_expr, e))\n+                }\n+        case (expr_be(?e)) { expr_be(fld.fold_expr(e)) }\n+        case (expr_log(?lv, ?e)) { expr_log(lv, fld.fold_expr(e)) }\n+        case (expr_assert(?e)) { expr_assert(fld.fold_expr(e)) }\n+        case (expr_check(?e)) { expr_check(fld.fold_expr(e)) }\n+        case (expr_port()) { e }\n+        case (expr_chan(?e)) { expr_chan(fld.fold_expr(e)) }\n+        case (expr_anon_obj(?ao, ?typms, ?odis)) {\n+            expr_anon_obj(fold_anon_obj(ao), typms, odis)\n+                }\n+    }\n+}\n+\n+fn noop_fold_ty(&ty_ t, ast_fold fld) -> ty_ {\n+    //drop in ty::fold_ty here if necessary\n+    ret t;\n+}\n+\n+fn noop_fold_constr(&constr_ c, ast_fold fld) -> constr_ {\n+    ret rec(path=fld.fold_path(c.path), args=c.args, id=c.id);\n+}\n+\n+// functions just don't get spans, for some reason\n+fn noop_fold_fn(&_fn f, ast_fold fld) -> _fn {\n+    auto fold_arg = bind fold_arg_(_, fld);\n+\n+    ret rec(decl= rec(inputs=map(fold_arg, f.decl.inputs),\n+                      output=fld.fold_ty(f.decl.output),\n+                      purity=f.decl.purity,\n+                      cf=f.decl.cf,\n+                      constraints=map(fld.fold_constr, f.decl.constraints)),\n+            proto = f.proto,\n+            body = fld.fold_block(f.body));\n+}\n+\n+// ...nor do modules\n+fn noop_fold_mod(&_mod m, ast_fold fld) -> _mod {\n+    ret rec(view_items=map(fld.fold_view_item, m.view_items),\n+            items=map(fld.fold_item, m.items));\n+}\n+\n+fn noop_fold_native_mod(&native_mod nm, ast_fold fld) -> native_mod {\n+    ret rec(native_name=nm.native_name,\n+            abi=nm.abi,\n+            view_items=map(fld.fold_view_item, nm.view_items),\n+            items=map(fld.fold_native_item, nm.items))\n+}\n+\n+fn noop_fold_variant(&variant_ v, ast_fold fld) -> variant_ {\n+    fn fold_variant_arg_(&variant_arg va, ast_fold fld) -> variant_arg {\n+        ret rec(ty=fld.fold_ty(va.ty), id=va.id);\n+    }\n+    auto fold_variant_arg = bind fold_variant_arg_(_,fld);\n+    ret rec(name=v.name,\n+            args=map(fold_variant_arg, v.args),\n+            id=v.id);\n+}\n+\n+fn noop_fold_ident(&ident i, ast_fold fld) -> ident {\n+    ret i;\n+}\n+\n+fn noop_fold_path(&path_ p, ast_fold fld) -> path_ {\n+    ret rec(idents=map(fld.fold_ident, p.idents),\n+            types=map(fld.fold_ty, p.types));\n+}\n+\n+fn noop_fold_local(&local_ l, ast_fold fld) -> local_ {\n+    ret rec(ty=option::map(fld.fold_ty,l.ty),\n+            infer=l.infer,\n+            ident=fld.fold_ident(l.ident),\n+            init=alt (l.init) {\n+                case (option::none[initializer]) { l.init }\n+                case (option::some[initializer](?init)) {\n+                    option::some[initializer]\n+                    (rec(op=init.op, \n+                         expr=fld.fold_expr(init.expr)))\n+                }\n+            },\n+            id=l.id);\n+}\n+\n+\n+fn default_ast_fold() -> @ast_fold_precursor {\n+    ret @rec(fold_crate = noop_fold_crate,\n+             fold_crate_directive = noop_fold_crate_directive,\n+             fold_view_item = noop_fold_view_item,\n+             fold_native_item = noop_fold_native_item,\n+             fold_item = noop_fold_item,\n+             fold_item_underscore = noop_fold_item_underscore,\n+             fold_method = noop_fold_method,\n+             fold_block = noop_fold_block,\n+             fold_stmt = noop_fold_stmt,\n+             fold_arm = noop_fold_arm,\n+             fold_pat = noop_fold_pat,\n+             fold_decl = noop_fold_decl,\n+             fold_expr = noop_fold_expr,\n+             fold_ty = noop_fold_ty,\n+             fold_constr = noop_fold_constr,\n+             fold_fn = noop_fold_fn,\n+             fold_mod = noop_fold_mod,\n+             fold_native_mod = noop_fold_native_mod,\n+             fold_variant = noop_fold_variant,\n+             fold_ident = noop_fold_ident,\n+             fold_path = noop_fold_path,\n+             fold_local = noop_fold_local);\n+}\n+\n+fn dummy_out(ast_fold a) {\n+    *a = rec(fold_crate = nf_crate_dummy,\n+                     fold_crate_directive = nf_crate_directive_dummy,\n+                     fold_view_item = nf_view_item_dummy,\n+                     fold_native_item = nf_native_item_dummy,\n+                     fold_item = nf_item_dummy,\n+                     fold_item_underscore = nf_item_underscore_dummy,\n+                     fold_method = nf_method_dummy,\n+                     fold_block = nf_block_dummy,\n+                     fold_stmt = nf_stmt_dummy,\n+                     fold_arm = nf_arm_dummy,\n+                     fold_pat = nf_pat_dummy,\n+                     fold_decl = nf_decl_dummy,\n+                     fold_expr = nf_expr_dummy,\n+                     fold_ty = nf_ty_dummy,\n+                     fold_constr = nf_constr_dummy,\n+                     fold_fn = nf_fn_dummy,\n+                     fold_mod = nf_mod_dummy,\n+                     fold_native_mod = nf_native_mod_dummy,\n+                     fold_variant = nf_variant_dummy,\n+                     fold_ident = nf_ident_dummy,\n+                     fold_path = nf_path_dummy,\n+                     fold_local = nf_local_dummy);\n+}\n+\n+\n+fn make_fold(&ast_fold_precursor afp) -> ast_fold {\n+    let ast_fold result = \n+        @mutable rec(fold_crate = nf_crate_dummy,\n+                     fold_crate_directive = nf_crate_directive_dummy,\n+                     fold_view_item = nf_view_item_dummy,\n+                     fold_native_item = nf_native_item_dummy,\n+                     fold_item = nf_item_dummy,\n+                     fold_item_underscore = nf_item_underscore_dummy,\n+                     fold_method = nf_method_dummy,\n+                     fold_block = nf_block_dummy,\n+                     fold_stmt = nf_stmt_dummy,\n+                     fold_arm = nf_arm_dummy,\n+                     fold_pat = nf_pat_dummy,\n+                     fold_decl = nf_decl_dummy,\n+                     fold_expr = nf_expr_dummy,\n+                     fold_ty = nf_ty_dummy,\n+                     fold_constr = nf_constr_dummy,\n+                     fold_fn = nf_fn_dummy,\n+                     fold_mod = nf_mod_dummy,\n+                     fold_native_mod = nf_native_mod_dummy,\n+                     fold_variant = nf_variant_dummy,\n+                     fold_ident = nf_ident_dummy,\n+                     fold_path = nf_path_dummy,\n+                     fold_local = nf_local_dummy);\n+\n+    /* naturally, a macro to write these would be nice */\n+    fn f_crate(&ast_fold_precursor afp, ast_fold f, &crate c) -> crate {\n+        ret rec(node=afp.fold_crate(c.node, f),\n+                span=c.span);\n+    }\n+    fn f_crate_directive(&ast_fold_precursor afp, ast_fold f, \n+                         &@crate_directive c) -> @crate_directive {\n+        ret @rec(node=afp.fold_crate_directive(c.node, f),\n+                 span=c.span);\n+    }\n+    fn f_view_item(&ast_fold_precursor afp, ast_fold f, &@view_item x)\n+        -> @view_item {\n+        ret @rec(node=afp.fold_view_item(x.node, f), span=x.span);\n+    }\n+    fn f_native_item(&ast_fold_precursor afp, ast_fold f, &@native_item x)\n+        -> @native_item {\n+        ret afp.fold_native_item(x, f);\n+    }\n+    fn f_item(&ast_fold_precursor afp, ast_fold f, &@item i) -> @item {\n+        ret afp.fold_item(i, f);\n+    }\n+    fn f_item_underscore(&ast_fold_precursor afp, ast_fold f, &item_ i) ->\n+        item_ {\n+        ret afp.fold_item_underscore(i, f);\n+    }\n+    fn f_method(&ast_fold_precursor afp, ast_fold f, &@method x) -> @method {\n+        ret @rec(node=afp.fold_method(x.node, f), span=x.span);\n+    }\n+    fn f_block(&ast_fold_precursor afp, ast_fold f, &block x) -> block {\n+        ret rec(node=afp.fold_block(x.node, f), span=x.span);\n+    }\n+    fn f_stmt(&ast_fold_precursor afp, ast_fold f, &@stmt x) -> @stmt {\n+        ret @rec(node=afp.fold_stmt(x.node, f), span=x.span);\n+    }\n+    fn f_arm(&ast_fold_precursor afp, ast_fold f, &arm x) -> arm {\n+        ret afp.fold_arm(x, f);\n+    }\n+    fn f_pat(&ast_fold_precursor afp, ast_fold f, &@pat x) -> @pat {\n+        ret @rec(node=afp.fold_pat(x.node, f), span=x.span);\n+    }\n+    fn f_decl(&ast_fold_precursor afp, ast_fold f, &@decl x) -> @decl {\n+        ret @rec(node=afp.fold_decl(x.node, f), span=x.span);\n+    }\n+    fn f_expr(&ast_fold_precursor afp, ast_fold f, &@expr x) -> @expr {\n+        ret @rec(id=x.id, node=afp.fold_expr(x.node, f), span=x.span);\n+    }\n+    fn f_ty(&ast_fold_precursor afp, ast_fold f, &@ty x) -> @ty {\n+        ret @rec(node=afp.fold_ty(x.node, f), span=x.span);\n+    }\n+    fn f_constr(&ast_fold_precursor afp, ast_fold f, &@constr x) -> @constr {\n+        ret @rec(node=afp.fold_constr(x.node, f), span=x.span);\n+    }\n+    fn f_fn(&ast_fold_precursor afp, ast_fold f, &_fn x) -> _fn {\n+        ret afp.fold_fn(x, f);\n+    }    \n+    fn f_mod(&ast_fold_precursor afp, ast_fold f, &_mod x) -> _mod {\n+        ret afp.fold_mod(x, f);\n+    }\n+    fn f_native_mod(&ast_fold_precursor afp, ast_fold f, &native_mod x) -> \n+        native_mod {\n+        ret afp.fold_native_mod(x, f);\n+    }    \n+    fn f_variant(&ast_fold_precursor afp, ast_fold f, &variant x)\n+        -> variant {\n+        ret rec(node=afp.fold_variant(x.node, f), span=x.span);\n+    }\n+    fn f_ident(&ast_fold_precursor afp, ast_fold f, &ident x) -> ident {\n+        ret afp.fold_ident(x, f);\n+    }\n+    fn f_path(&ast_fold_precursor afp, ast_fold f, &path x) -> path {\n+        ret rec(node=afp.fold_path(x.node, f), span=x.span);\n+    }\n+    fn f_local(&ast_fold_precursor afp, ast_fold f, &@local x) -> @local {\n+        ret @rec(node=afp.fold_local(x.node, f), span=x.span);\n+    }\n+\n+    *result = rec(fold_crate = bind f_crate(afp,result,_),\n+                  fold_crate_directive = bind f_crate_directive(afp,result,_),\n+                  fold_view_item = bind f_view_item(afp,result,_),\n+                  fold_native_item = bind f_native_item(afp,result,_),\n+                  fold_item = bind f_item(afp,result,_),\n+                  fold_item_underscore = bind f_item_underscore(afp,result,_),\n+                  fold_method = bind f_method(afp,result,_),\n+                  fold_block = bind f_block(afp,result,_),\n+                  fold_stmt = bind f_stmt(afp,result,_),\n+                  fold_arm = bind f_arm(afp, result, _),\n+                  fold_pat = bind f_pat(afp,result,_),\n+                  fold_decl = bind f_decl(afp,result,_),\n+                  fold_expr = bind f_expr(afp,result,_),\n+                  fold_ty = bind f_ty(afp,result,_),\n+                  fold_constr = bind f_constr(afp,result,_),\n+                  fold_fn = bind f_fn(afp,result,_),\n+                  fold_mod = bind f_mod(afp,result,_),\n+                  fold_native_mod = bind f_native_mod(afp,result,_),\n+                  fold_variant = bind f_variant(afp,result,_),\n+                  fold_ident = bind f_ident(afp,result,_),\n+                  fold_path = bind f_path(afp,result,_),\n+                  fold_local = bind f_local(afp,result,_));\n+    ret result;\n+    /*\n+    ret rec(fold_crate = noop_fold_crate,\n+          fold_crate_directive = noop_fold_crate_drective,\n+          fold_view_item = noop_fold_view_item,\n+          fold_native_item = noop_fold_native_item,\n+          fold_item = noop_fold_item,\n+          fold_method = noop_fold_method,\n+          fold_block = noop_fold_block,\n+          fold_stmt = noop_fold_stmt,\n+          fold_arm = noop_fold_arm,\n+          fold_pat = noop_fold_pat,\n+          fold_decl = noop_fold_decl,\n+          fold_expr = noop_fold_expr,\n+          fold_ty = noop_fold_ty,\n+          fold_constr = noop_fold_constr,\n+          fold_fn = noop_fold_fn);*/\n+}\n+\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "2adecfa13bb11875f1171045da0da15a64b4c058", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6326817803079ed33b13b87429ef7d77ce5f4cb/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b6326817803079ed33b13b87429ef7d77ce5f4cb/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=b6326817803079ed33b13b87429ef7d77ce5f4cb", "patch": "@@ -48,6 +48,7 @@ mod front {\n     mod ext;\n     mod extfmt;\n     mod extenv;\n+    mod fold;\n     mod codemap;\n     mod lexer;\n     mod parser;"}]}