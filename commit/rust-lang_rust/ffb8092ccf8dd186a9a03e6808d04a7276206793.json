{"sha": "ffb8092ccf8dd186a9a03e6808d04a7276206793", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmYjgwOTJjY2Y4ZGQxODZhOWEwM2U2ODA4ZDA0YTcyNzYyMDY3OTM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-31T19:20:24Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-24T12:14:16Z"}, "message": "syntax: use a single Path for Trait::Item in QPath.", "tree": {"sha": "f9fab075f87149cc4ebbac0fed1e4ac90657c60c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9fab075f87149cc4ebbac0fed1e4ac90657c60c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffb8092ccf8dd186a9a03e6808d04a7276206793", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffb8092ccf8dd186a9a03e6808d04a7276206793", "html_url": "https://github.com/rust-lang/rust/commit/ffb8092ccf8dd186a9a03e6808d04a7276206793", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffb8092ccf8dd186a9a03e6808d04a7276206793/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "326711e9bdee2e8f467ad716109b5a270b61478d", "url": "https://api.github.com/repos/rust-lang/rust/commits/326711e9bdee2e8f467ad716109b5a270b61478d", "html_url": "https://github.com/rust-lang/rust/commit/326711e9bdee2e8f467ad716109b5a270b61478d"}], "stats": {"total": 428, "additions": 177, "deletions": 251}, "files": [{"sha": "d344ee8c881c5ab4fa796f64f80f9ae2264ffcb2", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -717,11 +717,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n         visit::walk_path(self, p);\n     }\n \n-    fn visit_qpath(&mut self, p: &ast::QPath, id: ast::NodeId) {\n-        run_lints!(self, check_qpath, p, id);\n-        visit::walk_qpath(self, p);\n-    }\n-\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         run_lints!(self, check_attribute, attr);\n     }"}, {"sha": "021827b0101c81f7dee8caf04ab20ca6bcc9cac5", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -157,7 +157,6 @@ pub trait LintPass {\n     fn check_explicit_self(&mut self, _: &Context, _: &ast::ExplicitSelf) { }\n     fn check_mac(&mut self, _: &Context, _: &ast::Mac) { }\n     fn check_path(&mut self, _: &Context, _: &ast::Path, _: ast::NodeId) { }\n-    fn check_qpath(&mut self, _: &Context, _: &ast::QPath, _: ast::NodeId) { }\n     fn check_attribute(&mut self, _: &Context, _: &ast::Attribute) { }\n \n     /// Called when entering a syntax node that can have lint attributes such"}, {"sha": "ff78deb8d12ea6ba945531b6c34f0762b38a2ee6", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -306,11 +306,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         visit::walk_path(self, path);\n     }\n \n-    fn visit_qpath(&mut self, qpath: &ast::QPath, id: ast::NodeId) {\n-        self.lookup_and_handle_definition(&id);\n-        visit::walk_qpath(self, qpath);\n-    }\n-\n     fn visit_item(&mut self, _: &ast::Item) {\n         // Do not recurse into items. These items will be added to the\n         // worklist and recursed into manually if necessary."}, {"sha": "2fc43ab26b58ef328699c5a295df5386f79f982f", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -194,7 +194,6 @@ mod svh_visitor {\n         SawVariant,\n         SawExplicitSelf,\n         SawPath,\n-        SawQPath,\n         SawOptLifetimeRef,\n         SawBlock,\n         SawPat,\n@@ -486,10 +485,6 @@ mod svh_visitor {\n             SawPath.hash(self.st); visit::walk_path(self, path)\n         }\n \n-        fn visit_qpath(&mut self, qpath: &QPath, _: ast::NodeId) {\n-            SawQPath.hash(self.st); visit::walk_qpath(self, qpath)\n-        }\n-\n         fn visit_block(&mut self, b: &Block) {\n             SawBlock.hash(self.st); visit::walk_block(self, b)\n         }"}, {"sha": "838ba9c658cf1661fda1b7e3b4ac3c9949d8d848", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -1021,11 +1021,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         self.check_path(path.span, id, path.segments.last().unwrap().identifier);\n         visit::walk_path(self, path);\n     }\n-\n-    fn visit_qpath(&mut self, qpath: &ast::QPath, id: ast::NodeId) {\n-        self.check_path(qpath.trait_path.span, id, qpath.item_path.identifier);\n-        visit::walk_qpath(self, qpath);\n-    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "6584e3cc19d4c9a7897a7902a3e17c72460a30e3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 74, "deletions": 84, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -1096,8 +1096,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         result\n     }\n \n-    fn path_names_to_string(&self, path: &Path) -> String {\n-        let names: Vec<ast::Name> = path.segments\n+    fn path_names_to_string(&self, path: &Path, depth: usize) -> String {\n+        let names: Vec<ast::Name> = path.segments[..path.segments.len()-depth]\n                                         .iter()\n                                         .map(|seg| seg.identifier.name)\n                                         .collect();\n@@ -3162,7 +3162,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match *type_parameter_bound {\n             TraitTyParamBound(ref tref, _) => {\n                 self.resolve_trait_reference(tref.trait_ref.ref_id,\n-                                             &tref.trait_ref.path,\n+                                             &tref.trait_ref.path, 0,\n                                              reference_type)\n             }\n             RegionTyParamBound(..) => {}\n@@ -3172,10 +3172,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn resolve_trait_reference(&mut self,\n                                id: NodeId,\n                                trait_path: &Path,\n+                               path_depth: usize,\n                                reference_type: TraitReferenceType) {\n-        match self.resolve_path(id, trait_path, TypeNS, true) {\n+        match self.resolve_path(id, trait_path, path_depth, TypeNS, true) {\n             None => {\n-                let path_str = self.path_names_to_string(trait_path);\n+                let path_str = self.path_names_to_string(trait_path, path_depth);\n                 let usage_str = match reference_type {\n                     TraitBoundingTypeParameter => \"bound type parameter with\",\n                     TraitImplementation        => \"implement\",\n@@ -3196,7 +3197,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     (def, _) => {\n                         self.resolve_error(trait_path.span,\n                             &format!(\"`{}` is not a trait\",\n-                                     self.path_names_to_string(trait_path)));\n+                                     self.path_names_to_string(trait_path, path_depth)));\n \n                         // If it's a typedef, give a note\n                         if let DefTy(..) = def {\n@@ -3221,7 +3222,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n                 &ast::WherePredicate::RegionPredicate(_) => {}\n                 &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n-                    match self.resolve_path(eq_pred.id, &eq_pred.path, TypeNS, true) {\n+                    match self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS, true) {\n                         Some((def @ DefTyParam(..), last_private)) => {\n                             self.record_def(eq_pred.id, (def, last_private));\n                         }\n@@ -3297,7 +3298,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let new_val = match *opt_trait_ref {\n             Some(ref trait_ref) => {\n                 self.resolve_trait_reference(trait_ref.ref_id,\n-                                             &trait_ref.path,\n+                                             &trait_ref.path, 0,\n                                              TraitImplementation);\n \n                 match self.def_map.borrow().get(&trait_ref.ref_id) {\n@@ -3395,7 +3396,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n         if let Some((did, ref trait_ref)) = self.current_trait_ref {\n             if self.trait_item_map.get(&(name, did)).is_none() {\n-                let path_str = self.path_names_to_string(&trait_ref.path);\n+                let path_str = self.path_names_to_string(&trait_ref.path, 0);\n                 self.resolve_error(span,\n                                     &format!(\"method `{}` is not a member of trait `{}`\",\n                                             token::get_name(name),\n@@ -3563,23 +3564,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match ty.node {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n-            TyPath(_) | TyQPath(_) => {\n-                let mut path_from_qpath;\n-                let path = match ty.node {\n-                    TyPath(ref path) => path,\n-                    TyQPath(ref qpath) => {\n-                        self.resolve_type(&*qpath.self_type);\n-\n-                        // Just make sure the trait is valid, don't record a def.\n-                        self.resolve_trait_reference(ty.id, &qpath.trait_path, TraitQPath);\n-                        self.def_map.borrow_mut().remove(&ty.id);\n-\n-                        path_from_qpath = qpath.trait_path.clone();\n-                        path_from_qpath.segments.push(qpath.item_path.clone());\n-                        &path_from_qpath\n-                    }\n-                    _ => unreachable!()\n-                };\n+\n+            TyPath(ref path) | TyQPath(ast::QPath { ref path, .. }) => {\n+                if let TyQPath(ref qpath) = ty.node {\n+                    self.resolve_type(&*qpath.self_type);\n+\n+                    // Just make sure the trait is valid, don't record a def.\n+                    self.resolve_trait_reference(ty.id, path, 1, TraitQPath);\n+                    self.def_map.borrow_mut().remove(&ty.id);\n+                }\n \n                 // This is a path in the type namespace. Walk through scopes\n                 // looking for it.\n@@ -3612,15 +3605,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n \n                 if let None = result_def {\n-                    result_def = self.resolve_path(ty.id, path, TypeNS, true);\n+                    result_def = self.resolve_path(ty.id, path, 0, TypeNS, true);\n                 }\n \n                 match result_def {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `{}` \\\n                                 (id {}) = {:?}\",\n-                               self.path_names_to_string(path),\n+                               self.path_names_to_string(path, 0),\n                                ty.id, def);\n                         self.record_def(ty.id, def);\n                     }\n@@ -3630,7 +3623,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             _ => \"type name\"\n                         };\n                         let msg = format!(\"use of undeclared {} `{}`\", kind,\n-                                          self.path_names_to_string(path));\n+                                          self.path_names_to_string(path, 0));\n                         self.resolve_error(ty.span, &msg[..]);\n                     }\n                 }\n@@ -3765,7 +3758,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 PatEnum(ref path, _) => {\n                     // This must be an enum variant, struct or const.\n-                    match self.resolve_path(pat_id, path, ValueNS, false) {\n+                    match self.resolve_path(pat_id, path, 0, ValueNS, false) {\n                         Some(def @ (DefVariant(..), _)) |\n                         Some(def @ (DefStruct(..), _))  |\n                         Some(def @ (DefConst(..), _)) => {\n@@ -3808,15 +3801,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n \n                 PatStruct(ref path, _, _) => {\n-                    match self.resolve_path(pat_id, path, TypeNS, false) {\n+                    match self.resolve_path(pat_id, path, 0, TypeNS, false) {\n                         Some(definition) => {\n                             self.record_def(pattern.id, definition);\n                         }\n                         result => {\n                             debug!(\"(resolving pattern) didn't find struct \\\n                                     def: {:?}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n-                                              self.path_names_to_string(path));\n+                                              self.path_names_to_string(path, 0));\n                             self.resolve_error(path.span, &msg[..]);\n                         }\n                     }\n@@ -3896,34 +3889,38 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn resolve_path(&mut self,\n                     id: NodeId,\n                     path: &Path,\n+                    path_depth: usize,\n                     namespace: Namespace,\n                     check_ribs: bool) -> Option<(Def, LastPrivate)> {\n+        let span = path.span;\n+        let segments = &path.segments[..path.segments.len()-path_depth];\n+\n         // First, resolve the types and associated type bindings.\n-        for ty in path.segments.iter().flat_map(|s| s.parameters.types().into_iter()) {\n+        for ty in segments.iter().flat_map(|s| s.parameters.types().into_iter()) {\n             self.resolve_type(&**ty);\n         }\n-        for binding in path.segments.iter().flat_map(|s| s.parameters.bindings().into_iter()) {\n+        for binding in segments.iter().flat_map(|s| s.parameters.bindings().into_iter()) {\n             self.resolve_type(&*binding.ty);\n         }\n \n         // A special case for sugared associated type paths `T::A` where `T` is\n         // a type parameter and `A` is an associated type on some bound of `T`.\n-        if namespace == TypeNS && path.segments.len() == 2 {\n-            match self.resolve_identifier(path.segments[0].identifier,\n+        if namespace == TypeNS && segments.len() == 2 {\n+            match self.resolve_identifier(segments[0].identifier,\n                                           TypeNS,\n                                           true,\n-                                          path.span) {\n+                                          span) {\n                 Some((def, last_private)) => {\n                     match def {\n                         DefTyParam(_, _, did, _) => {\n                             let def = DefAssociatedPath(TyParamProvenance::FromParam(did),\n-                                                        path.segments.last()\n+                                                        segments.last()\n                                                             .unwrap().identifier);\n                             return Some((def, last_private));\n                         }\n                         DefSelfTy(nid) => {\n                             let def = DefAssociatedPath(TyParamProvenance::FromSelf(local_def(nid)),\n-                                                        path.segments.last()\n+                                                        segments.last()\n                                                             .unwrap().identifier);\n                             return Some((def, last_private));\n                         }\n@@ -3935,24 +3932,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         if path.global {\n-            return self.resolve_crate_relative_path(path, namespace);\n+            return self.resolve_crate_relative_path(span, segments, namespace);\n         }\n \n         // Try to find a path to an item in a module.\n         let unqualified_def =\n-                self.resolve_identifier(path.segments.last().unwrap().identifier,\n+                self.resolve_identifier(segments.last().unwrap().identifier,\n                                         namespace,\n                                         check_ribs,\n-                                        path.span);\n+                                        span);\n \n-        if path.segments.len() > 1 {\n-            let def = self.resolve_module_relative_path(path, namespace);\n+        if segments.len() > 1 {\n+            let def = self.resolve_module_relative_path(span, segments, namespace);\n             match (def, unqualified_def) {\n                 (Some((ref d, _)), Some((ref ud, _))) if *d == *ud => {\n                     self.session\n                         .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n-                                  id,\n-                                  path.span,\n+                                  id, span,\n                                   \"unnecessary qualification\".to_string());\n                 }\n                 _ => ()\n@@ -4063,28 +4059,29 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     // resolve a \"module-relative\" path, e.g. a::b::c\n     fn resolve_module_relative_path(&mut self,\n-                                    path: &Path,\n+                                    span: Span,\n+                                    segments: &[ast::PathSegment],\n                                     namespace: Namespace)\n                                     -> Option<(Def, LastPrivate)> {\n-        let module_path = path.segments.init().iter()\n-                                              .map(|ps| ps.identifier.name)\n-                                              .collect::<Vec<_>>();\n+        let module_path = segments.init().iter()\n+                                         .map(|ps| ps.identifier.name)\n+                                         .collect::<Vec<_>>();\n \n         let containing_module;\n         let last_private;\n         let module = self.current_module.clone();\n         match self.resolve_module_path(module,\n                                        &module_path[..],\n                                        UseLexicalScope,\n-                                       path.span,\n+                                       span,\n                                        PathSearch) {\n             Failed(err) => {\n                 let (span, msg) = match err {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared type or module `{}`\",\n                                           self.names_to_string(&module_path));\n-                        (path.span, msg)\n+                        (span, msg)\n                     }\n                 };\n \n@@ -4099,7 +4096,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        let name = path.segments.last().unwrap().identifier.name;\n+        let name = segments.last().unwrap().identifier.name;\n         let def = match self.resolve_definition_of_name_in_module(containing_module.clone(),\n                                                                   name,\n                                                                   namespace) {\n@@ -4120,12 +4117,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Invariant: This must be called only during main resolution, not during\n     /// import resolution.\n     fn resolve_crate_relative_path(&mut self,\n-                                   path: &Path,\n+                                   span: Span,\n+                                   segments: &[ast::PathSegment],\n                                    namespace: Namespace)\n                                        -> Option<(Def, LastPrivate)> {\n-        let module_path = path.segments.init().iter()\n-                                              .map(|ps| ps.identifier.name)\n-                                              .collect::<Vec<_>>();\n+        let module_path = segments.init().iter()\n+                                         .map(|ps| ps.identifier.name)\n+                                         .collect::<Vec<_>>();\n \n         let root_module = self.graph_root.get_module();\n \n@@ -4134,7 +4132,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match self.resolve_module_path_from_root(root_module,\n                                                  &module_path[..],\n                                                  0,\n-                                                 path.span,\n+                                                 span,\n                                                  PathSearch,\n                                                  LastMod(AllPublic)) {\n             Failed(err) => {\n@@ -4143,7 +4141,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         let msg = format!(\"Use of undeclared module `::{}`\",\n                                           self.names_to_string(&module_path[..]));\n-                        (path.span, msg)\n+                        (span, msg)\n                     }\n                 };\n \n@@ -4162,7 +4160,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        let name = path.segments.last().unwrap().identifier.name;\n+        let name = segments.last().unwrap().identifier.name;\n         match self.resolve_definition_of_name_in_module(containing_module,\n                                                         name,\n                                                         namespace) {\n@@ -4342,7 +4340,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match get_module(self, path.span, &name_path[..]) {\n             Some(module) => match module.children.borrow().get(&name) {\n                 Some(binding) => {\n-                    let p_str = self.path_names_to_string(&path);\n+                    let p_str = self.path_names_to_string(&path, 0);\n                     match binding.def_for_namespace(ValueNS) {\n                         Some(DefStaticMethod(_, provenance)) => {\n                             match provenance {\n@@ -4363,7 +4361,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Look for a method in the current trait.\n         match self.current_trait_ref {\n             Some((did, ref trait_ref)) => {\n-                let path_str = self.path_names_to_string(&trait_ref.path);\n+                let path_str = self.path_names_to_string(&trait_ref.path, 0);\n \n                 match self.trait_item_map.get(&(name, did)) {\n                     Some(&StaticMethodTraitItemKind) => {\n@@ -4426,29 +4424,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // The interpretation of paths depends on whether the path has\n             // multiple elements in it or not.\n \n-            ExprPath(_) | ExprQPath(_) => {\n-                let mut path_from_qpath;\n-                let path = match expr.node {\n-                    ExprPath(ref path) => path,\n-                    ExprQPath(ref qpath) => {\n-                        self.resolve_type(&*qpath.self_type);\n+            ExprPath(ref path) | ExprQPath(ast::QPath { ref path, .. }) => {\n+                if let ExprQPath(ref qpath) = expr.node {\n+                    self.resolve_type(&*qpath.self_type);\n \n-                        // Just make sure the trait is valid, don't record a def.\n-                        self.resolve_trait_reference(expr.id, &qpath.trait_path, TraitQPath);\n-                        self.def_map.borrow_mut().remove(&expr.id);\n+                    // Just make sure the trait is valid, don't record a def.\n+                    self.resolve_trait_reference(expr.id, path, 1, TraitQPath);\n+                    self.def_map.borrow_mut().remove(&expr.id);\n+                }\n \n-                        path_from_qpath = qpath.trait_path.clone();\n-                        path_from_qpath.segments.push(qpath.item_path.clone());\n-                        &path_from_qpath\n-                    }\n-                    _ => unreachable!()\n-                };\n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n-                match self.resolve_path(expr.id, path, ValueNS, true) {\n+                match self.resolve_path(expr.id, path, 0, ValueNS, true) {\n                     // Check if struct variant\n                     Some((DefVariant(_, _, true), _)) => {\n-                        let path_name = self.path_names_to_string(path);\n+                        let path_name = self.path_names_to_string(path, 0);\n                         self.resolve_error(expr.span,\n                                 &format!(\"`{}` is a struct variant name, but \\\n                                           this expression \\\n@@ -4463,7 +4453,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `{}`\",\n-                               self.path_names_to_string(path));\n+                               self.path_names_to_string(path, 0));\n \n                         self.record_def(expr.id, def);\n                     }\n@@ -4472,9 +4462,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // (The pattern matching def_tys where the id is in self.structs\n                         // matches on regular structs while excluding tuple- and enum-like\n                         // structs, which wouldn't result in this error.)\n-                        let path_name = self.path_names_to_string(path);\n+                        let path_name = self.path_names_to_string(path, 0);\n                         match self.with_no_errors(|this|\n-                            this.resolve_path(expr.id, path, TypeNS, false)) {\n+                            this.resolve_path(expr.id, path, 0, TypeNS, false)) {\n                             Some((DefTy(struct_id, _), _))\n                               if self.structs.contains_key(&struct_id) => {\n                                 self.resolve_error(expr.span,\n@@ -4557,13 +4547,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // Resolve the path to the structure it goes to. We don't\n                 // check to ensure that the path is actually a structure; that\n                 // is checked later during typeck.\n-                match self.resolve_path(expr.id, path, TypeNS, false) {\n+                match self.resolve_path(expr.id, path, 0, TypeNS, false) {\n                     Some(definition) => self.record_def(expr.id, definition),\n                     result => {\n                         debug!(\"(resolving expression) didn't find struct \\\n                                 def: {:?}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n-                                          self.path_names_to_string(path));\n+                                          self.path_names_to_string(path, 0));\n                         self.resolve_error(path.span, &msg[..]);\n                     }\n                 }"}, {"sha": "6a20938da2e47d09945d4ea4b1e5b4ffb60cf9d4", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -1334,16 +1334,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 // Don't need to do anything for function calls,\n                 // because just walking the callee path does what we want.\n                 visit::walk_expr(self, ex);\n-            },\n-            ast::ExprPath(ref path) => {\n-                self.process_path(ex.id, path.span, path, None);\n-                visit::walk_path(self, path);\n             }\n-            ast::ExprQPath(ref qpath) => {\n-                let mut path = qpath.trait_path.clone();\n-                path.segments.push(qpath.item_path.clone());\n-                self.process_path(ex.id, ex.span, &path, None);\n-                visit::walk_qpath(self, &**qpath);\n+            ast::ExprPath(ref path) | ast::ExprQPath(ast::QPath { ref path, .. }) => {\n+                self.process_path(ex.id, path.span, path, None);\n+                visit::walk_expr(self, ex);\n             }\n             ast::ExprStruct(ref path, ref fields, ref base) =>\n                 self.process_struct_lit(ex, path, fields, base),"}, {"sha": "8eb75ece4a14587f3241dee3e12f80b6239b3811", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -575,8 +575,7 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n     let shifted_rscope = ShiftedRscope::new(rscope);\n \n     let trait_ref = instantiate_trait_ref(this, &shifted_rscope,\n-                                          &ast_trait_ref.trait_ref.path,\n-                                          ast_trait_ref.trait_ref.ref_id,\n+                                          &ast_trait_ref.trait_ref,\n                                           None, self_ty, Some(&mut projections));\n \n     for projection in projections {\n@@ -595,14 +594,14 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n pub fn instantiate_trait_ref<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n-    path: &ast::Path,\n-    path_id: ast::NodeId,\n+    trait_ref: &ast::TraitRef,\n     impl_id: Option<ast::NodeId>,\n     self_ty: Option<Ty<'tcx>>,\n     projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n     -> Rc<ty::TraitRef<'tcx>>\n {\n-    match ::lookup_def_tcx(this.tcx(), path.span, path_id) {\n+    let path = &trait_ref.path;\n+    match ::lookup_def_tcx(this.tcx(), path.span, trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => {\n             let trait_ref = ast_path_to_trait_ref(this,\n                                                   rscope,\n@@ -1201,11 +1200,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             ast::TyPolyTraitRef(ref bounds) => {\n                 conv_ty_poly_trait_ref(this, rscope, ast_ty.span, &bounds[..])\n             }\n-            ast::TyPath(_) | ast::TyQPath(_) => {\n-                let simple_path = |&:| match ast_ty.node {\n-                    ast::TyPath(ref path) => path,\n-                    _ => tcx.sess.span_bug(ast_ty.span, \"expected non-qualified path\")\n-                };\n+            ast::TyPath(ref path) | ast::TyQPath(ast::QPath { ref path, .. }) => {\n                 let a_def = match tcx.def_map.borrow().get(&ast_ty.id) {\n                     None => {\n                         tcx.sess\n@@ -1224,24 +1219,24 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                         let trait_ref = object_path_to_poly_trait_ref(this,\n                                                                       rscope,\n                                                                       trait_def_id,\n-                                                                      simple_path(),\n+                                                                      path,\n                                                                       &mut projection_bounds);\n \n                         trait_ref_to_object_type(this, rscope, ast_ty.span,\n                                                  trait_ref, projection_bounds, &[])\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n-                        ast_path_to_ty(this, rscope, did, simple_path()).ty\n+                        ast_path_to_ty(this, rscope, did, path).ty\n                     }\n                     def::DefTyParam(space, index, _, name) => {\n-                        check_path_args(tcx, simple_path(), NO_TPS | NO_REGIONS);\n+                        check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         ty::mk_param(tcx, space, index, name)\n                     }\n                     def::DefSelfTy(_) => {\n                         // n.b.: resolve guarantees that the this type only appears in a\n                         // trait, which we rely upon in various places when creating\n                         // substs\n-                        check_path_args(tcx, simple_path(), NO_TPS | NO_REGIONS);\n+                        check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         ty::mk_self_type(tcx)\n                     }\n                     def::DefMod(id) => {\n@@ -1253,19 +1248,14 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                         panic!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n                     }\n                     def::DefAssociatedTy(trait_did, _) => {\n-                        let (opt_self_ty, trait_segment, item_segment) = match ast_ty.node {\n-                            ast::TyQPath(ref qpath) => {\n-                                (Some(&*qpath.self_type), qpath.trait_path.segments.last().unwrap(),\n-                                 &qpath.item_path)\n-                            }\n-                            ast::TyPath(ref path) => {\n-                                (None, &path.segments[path.segments.len()-2],\n-                                 path.segments.last().unwrap())\n-                            }\n-                            _ => unreachable!()\n+                        let opt_self_ty = if let ast::TyQPath(ref qpath) = ast_ty.node {\n+                            Some(&*qpath.self_type)\n+                        } else {\n+                            None\n                         };\n-                        qpath_to_ty(this, rscope, ast_ty.span, opt_self_ty,\n-                                    trait_did, trait_segment, item_segment)\n+                        qpath_to_ty(this, rscope, ast_ty.span, opt_self_ty, trait_did,\n+                                    &path.segments[path.segments.len()-2],\n+                                    path.segments.last().unwrap())\n                     }\n                     def::DefAssociatedPath(provenance, assoc_ident) => {\n                         associated_path_def_to_ty(this, ast_ty, provenance, assoc_ident.name)"}, {"sha": "5b3090be59372f93a1bbf63e2b1fff78e8fef10c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -3614,9 +3614,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           let self_ty = fcx.to_ty(&*qpath.self_type);\n           let defn = lookup_def(fcx, expr.span, id);\n           let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx, expr.span, defn);\n-          let mut path = qpath.trait_path.clone();\n-          path.segments.push(qpath.item_path.clone());\n-          instantiate_path(fcx, &path, scheme, &predicates, Some(self_ty),\n+          instantiate_path(fcx, &qpath.path, scheme, &predicates, Some(self_ty),\n                            defn, expr.span, expr.id);\n \n           // We always require that the type provided as the value for"}, {"sha": "46e1f6f076a7bbd028aabeb3f29c80dbb2e24e2d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -740,8 +740,7 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n             if let Some(ref trait_ref) = *opt_trait_ref {\n                 astconv::instantiate_trait_ref(ccx,\n                                                &ExplicitRscope,\n-                                               &trait_ref.path,\n-                                               trait_ref.ref_id,\n+                                               trait_ref,\n                                                Some(it.id),\n                                                Some(selfty),\n                                                None);"}, {"sha": "2af8107622301fdecdf66873165d6e3623c6ac1e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -1500,10 +1500,12 @@ impl Clean<Type> for ast::Ty {\n                 resolve_type(cx, p.clean(cx), self.id)\n             }\n             TyQPath(ref qp) => {\n+                let mut trait_path = qp.path.clone();\n+                trait_path.segments.pop();\n                 Type::QPath {\n-                    name: qp.item_path.identifier.clean(cx),\n+                    name: qp.path.segments.last().unwrap().identifier.clean(cx),\n                     self_type: box qp.self_type.clean(cx),\n-                    trait_: box resolve_type(cx, qp.trait_path.clean(cx), self.id)\n+                    trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n             }\n             TyObjectSum(ref lhs, ref bounds) => {"}, {"sha": "80a5527cb948d35714bade381d3c9e71fe6102b9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -757,7 +757,7 @@ pub enum Expr_ {\n     /// type parameters, e.g. foo::bar::<baz>\n     ExprPath(Path),\n     /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`\n-    ExprQPath(P<QPath>),\n+    ExprQPath(QPath),\n \n     ExprAddrOf(Mutability, P<Expr>),\n     ExprBreak(Option<Ident>),\n@@ -781,13 +781,12 @@ pub enum Expr_ {\n /// A \"qualified path\":\n ///\n ///     <Vec<T> as SomeTrait>::SomeAssociatedItem\n-///      ^~~~~     ^~~~~~~~~   ^~~~~~~~~~~~~~~~~~\n-///      self_type  trait_path  item_path\n+///      ^~~~~     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+///      self_type  path\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct QPath {\n     pub self_type: P<Ty>,\n-    pub trait_path: Path,\n-    pub item_path: PathSegment,\n+    pub path: Path,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -1259,7 +1258,7 @@ pub enum Ty_ {\n     /// Type parameters are stored in the Path itself\n     TyPath(Path),\n     /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`\n-    TyQPath(P<QPath>),\n+    TyQPath(QPath),\n     /// Something like `A+B`. Note that `B` must always be a path.\n     TyObjectSum(P<Ty>, TyParamBounds),\n     /// A type like `for<'a> Foo<&'a Bar>`"}, {"sha": "90842bbab47d217f76564e4a19a12ad11da8e082", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -41,16 +41,16 @@ pub trait AstBuilder {\n         -> ast::Path;\n \n     fn qpath(&self, self_type: P<ast::Ty>,\n-             trait_ref: P<ast::TraitRef>,\n-             ident: ast::Ident )\n-        -> P<ast::QPath>;\n+             trait_path: ast::Path,\n+             ident: ast::Ident)\n+             -> ast::QPath;\n     fn qpath_all(&self, self_type: P<ast::Ty>,\n-                trait_ref: P<ast::TraitRef>,\n+                trait_path: ast::Path,\n                 ident: ast::Ident,\n                 lifetimes: Vec<ast::Lifetime>,\n                 types: Vec<P<ast::Ty>>,\n-                bindings: Vec<P<ast::TypeBinding>> )\n-        -> P<ast::QPath>;\n+                bindings: Vec<P<ast::TypeBinding>>)\n+                -> ast::QPath;\n \n     // types\n     fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy;\n@@ -114,7 +114,7 @@ pub trait AstBuilder {\n     // expressions\n     fn expr(&self, span: Span, node: ast::Expr_) -> P<ast::Expr>;\n     fn expr_path(&self, path: ast::Path) -> P<ast::Expr>;\n-    fn expr_qpath(&self, span: Span, qpath: P<ast::QPath>) -> P<ast::Expr>;\n+    fn expr_qpath(&self, span: Span, qpath: ast::QPath) -> P<ast::Expr>;\n     fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr>;\n \n     fn expr_self(&self, span: Span) -> P<ast::Expr>;\n@@ -346,40 +346,40 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     /// Constructs a qualified path.\n     ///\n-    /// Constructs a path like `<self_type as trait_ref>::ident`.\n+    /// Constructs a path like `<self_type as trait_path>::ident`.\n     fn qpath(&self,\n              self_type: P<ast::Ty>,\n-             trait_ref: P<ast::TraitRef>,\n+             trait_path: ast::Path,\n              ident: ast::Ident)\n-             -> P<ast::QPath> {\n-        self.qpath_all(self_type, trait_ref, ident, Vec::new(), Vec::new(), Vec::new())\n+             -> ast::QPath {\n+        self.qpath_all(self_type, trait_path, ident, vec![], vec![], vec![])\n     }\n \n     /// Constructs a qualified path.\n     ///\n-    /// Constructs a path like `<self_type as trait_ref>::ident<a, T, A=Bar>`.\n+    /// Constructs a path like `<self_type as trait_path>::ident<'a, T, A=Bar>`.\n     fn qpath_all(&self,\n                  self_type: P<ast::Ty>,\n-                 trait_ref: P<ast::TraitRef>,\n+                 trait_path: ast::Path,\n                  ident: ast::Ident,\n                  lifetimes: Vec<ast::Lifetime>,\n                  types: Vec<P<ast::Ty>>,\n-                 bindings: Vec<P<ast::TypeBinding>> )\n-                 -> P<ast::QPath> {\n-        let segment = ast::PathSegment {\n+                 bindings: Vec<P<ast::TypeBinding>>)\n+                 -> ast::QPath {\n+        let mut path = trait_path;\n+        path.segments.push(ast::PathSegment {\n             identifier: ident,\n             parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                 lifetimes: lifetimes,\n                 types: OwnedSlice::from_vec(types),\n                 bindings: OwnedSlice::from_vec(bindings),\n             })\n-        };\n+        });\n \n-        P(ast::QPath {\n+        ast::QPath {\n             self_type: self_type,\n-            trait_ref: trait_ref,\n-            item_path: segment,\n-        })\n+            path: path\n+        }\n     }\n \n     fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy {\n@@ -607,7 +607,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     /// Constructs a QPath expression.\n-    fn expr_qpath(&self, span: Span, qpath: P<ast::QPath>) -> P<ast::Expr> {\n+    fn expr_qpath(&self, span: Span, qpath: ast::QPath) -> P<ast::Expr> {\n         self.expr(span, ast::ExprQPath(qpath))\n     }\n "}, {"sha": "c706ce9065dd5f9768db6465546c1cbde971a1b4", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -146,10 +146,6 @@ pub trait Folder : Sized {\n         noop_fold_ty(t, self)\n     }\n \n-    fn fold_qpath(&mut self, t: P<QPath>) -> P<QPath> {\n-        noop_fold_qpath(t, self)\n-    }\n-\n     fn fold_ty_binding(&mut self, t: P<TypeBinding>) -> P<TypeBinding> {\n         noop_fold_ty_binding(t, self)\n     }\n@@ -430,7 +426,10 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n             TyParen(ty) => TyParen(fld.fold_ty(ty)),\n             TyPath(path) => TyPath(fld.fold_path(path)),\n             TyQPath(qpath) => {\n-                TyQPath(fld.fold_qpath(qpath))\n+                TyQPath(QPath {\n+                    self_type: fld.fold_ty(qpath.self_type),\n+                    path: fld.fold_path(qpath.path)\n+                })\n             }\n             TyObjectSum(ty, bounds) => {\n                 TyObjectSum(fld.fold_ty(ty),\n@@ -450,19 +449,6 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n     })\n }\n \n-pub fn noop_fold_qpath<T: Folder>(qpath: P<QPath>, fld: &mut T) -> P<QPath> {\n-    qpath.map(|qpath| {\n-        QPath {\n-            self_type: fld.fold_ty(qpath.self_type),\n-            trait_path: fld.fold_path(qpath.trait_path),\n-            item_path: PathSegment {\n-                identifier: fld.fold_ident(qpath.item_path.identifier),\n-                parameters: fld.fold_path_parameters(qpath.item_path.parameters),\n-            }\n-        }\n-    })\n-}\n-\n pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, items}: ForeignMod,\n                                         fld: &mut T) -> ForeignMod {\n     ForeignMod {\n@@ -1362,7 +1348,10 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                           e2.map(|x| folder.fold_expr(x)))\n             }\n             ExprPath(pth) => ExprPath(folder.fold_path(pth)),\n-            ExprQPath(qpath) => ExprQPath(folder.fold_qpath(qpath)),\n+            ExprQPath(qpath) => ExprQPath(QPath {\n+                self_type: folder.fold_ty(qpath.self_type),\n+                path: folder.fold_path(qpath.path)\n+            }),\n             ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|x| folder.fold_ident(x))),\n             ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|x| folder.fold_ident(x))),\n             ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),"}, {"sha": "ad290da7d0a6209bc5b2ae8cb1ad06886f495752", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -1525,18 +1525,14 @@ impl<'a> Parser<'a> {\n             // QUALIFIED PATH `<TYPE as TRAIT_REF>::item`\n             let self_type = self.parse_ty_sum();\n             self.expect_keyword(keywords::As);\n-            let trait_path = self.parse_path(LifetimeAndTypesWithoutColons);\n+            let mut path = self.parse_path(LifetimeAndTypesWithoutColons);\n             self.expect(&token::Gt);\n             self.expect(&token::ModSep);\n-            let item_name = self.parse_ident();\n-            TyQPath(P(QPath {\n-                self_type: self_type,\n-                trait_path: trait_path,\n-                item_path: ast::PathSegment {\n-                    identifier: item_name,\n-                    parameters: ast::PathParameters::none()\n-                }\n-            }))\n+            path.segments.push(ast::PathSegment {\n+                identifier: self.parse_ident(),\n+                parameters: ast::PathParameters::none()\n+            });\n+            TyQPath(QPath { self_type: self_type, path: path })\n         } else if self.check(&token::ModSep) ||\n                   self.token.is_ident() ||\n                   self.token.is_path() {\n@@ -2220,7 +2216,7 @@ impl<'a> Parser<'a> {\n                     // QUALIFIED PATH `<TYPE as TRAIT_REF>::item::<'a, T>`\n                     let self_type = self.parse_ty_sum();\n                     self.expect_keyword(keywords::As);\n-                    let trait_path = self.parse_path(LifetimeAndTypesWithoutColons);\n+                    let mut path = self.parse_path(LifetimeAndTypesWithoutColons);\n                     self.expect(&token::Gt);\n                     self.expect(&token::ModSep);\n                     let item_name = self.parse_ident();\n@@ -2237,15 +2233,13 @@ impl<'a> Parser<'a> {\n                     } else {\n                         ast::PathParameters::none()\n                     };\n+                    path.segments.push(ast::PathSegment {\n+                        identifier: item_name,\n+                        parameters: parameters\n+                    });\n                     let hi = self.span.hi;\n-                    return self.mk_expr(lo, hi, ExprQPath(P(QPath {\n-                        self_type: self_type,\n-                        trait_path: trait_path,\n-                        item_path: ast::PathSegment {\n-                            identifier: item_name,\n-                            parameters: parameters\n-                        }\n-                    })));\n+                    return self.mk_expr(lo, hi,\n+                        ExprQPath(QPath { self_type: self_type, path: path }));\n                 }\n                 if self.eat_keyword(keywords::Move) {\n                     return self.parse_lambda_expr(CaptureByValue);"}, {"sha": "11502c29ebb159551dbebbf8190e2d01211c149d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -373,7 +373,7 @@ pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n }\n \n pub fn path_to_string(p: &ast::Path) -> String {\n-    $to_string(|s| s.print_path(p, false))\n+    $to_string(|s| s.print_path(p, false, 0))\n }\n \n pub fn ident_to_string(id: &ast::Ident) -> String {\n@@ -730,7 +730,10 @@ impl<'a> State<'a> {\n                                       None));\n             }\n             ast::TyPath(ref path) => {\n-                try!(self.print_path(path, false));\n+                try!(self.print_path(path, false, 0));\n+            }\n+            ast::TyQPath(ref qpath) => {\n+                try!(self.print_qpath(qpath, false))\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n                 try!(self.print_type(&**ty));\n@@ -739,9 +742,6 @@ impl<'a> State<'a> {\n             ast::TyPolyTraitRef(ref bounds) => {\n                 try!(self.print_bounds(\"\", &bounds[..]));\n             }\n-            ast::TyQPath(ref qpath) => {\n-                try!(self.print_qpath(&**qpath, false))\n-            }\n             ast::TyFixedLengthVec(ref ty, ref v) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.print_type(&**ty));\n@@ -1018,7 +1018,7 @@ impl<'a> State<'a> {\n             ast::ItemMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n                                             ..}) => {\n                 try!(self.print_visibility(item.vis));\n-                try!(self.print_path(pth, false));\n+                try!(self.print_path(pth, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.print_ident(item.ident));\n                 try!(self.cbox(indent_unit));\n@@ -1033,7 +1033,7 @@ impl<'a> State<'a> {\n     }\n \n     fn print_trait_ref(&mut self, t: &ast::TraitRef) -> IoResult<()> {\n-        self.print_path(&t.path, false)\n+        self.print_path(&t.path, false, 0)\n     }\n \n     fn print_formal_lifetime_list(&mut self, lifetimes: &[ast::LifetimeDef]) -> IoResult<()> {\n@@ -1297,7 +1297,7 @@ impl<'a> State<'a> {\n             ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n                                             ..}) => {\n                 // code copied from ItemMac:\n-                try!(self.print_path(pth, false));\n+                try!(self.print_path(pth, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.cbox(indent_unit));\n                 try!(self.popen());\n@@ -1514,7 +1514,7 @@ impl<'a> State<'a> {\n         match m.node {\n             // I think it's reasonable to hide the ctxt here:\n             ast::MacInvocTT(ref pth, ref tts, _) => {\n-                try!(self.print_path(pth, false));\n+                try!(self.print_path(pth, false, 0));\n                 try!(word(&mut self.s, \"!\"));\n                 match delim {\n                     token::Paren => try!(self.popen()),\n@@ -1584,7 +1584,7 @@ impl<'a> State<'a> {\n                          path: &ast::Path,\n                          fields: &[ast::Field],\n                          wth: &Option<P<ast::Expr>>) -> IoResult<()> {\n-        try!(self.print_path(path, true));\n+        try!(self.print_path(path, true, 0));\n         if !(fields.is_empty() && wth.is_none()) {\n             try!(word(&mut self.s, \"{\"));\n             try!(self.commasep_cmnt(\n@@ -1852,8 +1852,8 @@ impl<'a> State<'a> {\n                     try!(self.print_expr(&**e));\n                 }\n             }\n-            ast::ExprPath(ref path) => try!(self.print_path(path, true)),\n-            ast::ExprQPath(ref qpath) => try!(self.print_qpath(&**qpath, true)),\n+            ast::ExprPath(ref path) => try!(self.print_path(path, true, 0)),\n+            ast::ExprQPath(ref qpath) => try!(self.print_qpath(qpath, true)),\n             ast::ExprBreak(opt_ident) => {\n                 try!(word(&mut self.s, \"break\"));\n                 try!(space(&mut self.s));\n@@ -2014,16 +2014,14 @@ impl<'a> State<'a> {\n \n     fn print_path(&mut self,\n                   path: &ast::Path,\n-                  colons_before_params: bool)\n+                  colons_before_params: bool,\n+                  depth: usize)\n                   -> IoResult<()>\n     {\n         try!(self.maybe_print_comment(path.span.lo));\n-        if path.global {\n-            try!(word(&mut self.s, \"::\"));\n-        }\n \n-        let mut first = true;\n-        for segment in &path.segments {\n+        let mut first = !path.global;\n+        for segment in &path.segments[..path.segments.len()-depth] {\n             if first {\n                 first = false\n             } else {\n@@ -2047,11 +2045,12 @@ impl<'a> State<'a> {\n         try!(self.print_type(&*qpath.self_type));\n         try!(space(&mut self.s));\n         try!(self.word_space(\"as\"));\n-        try!(self.print_path(&qpath.trait_path, false));\n+        try!(self.print_path(&qpath.path, false, 1));\n         try!(word(&mut self.s, \">\"));\n         try!(word(&mut self.s, \"::\"));\n-        try!(self.print_ident(qpath.item_path.identifier));\n-        self.print_path_parameters(&qpath.item_path.parameters, colons_before_params)\n+        let item_segment = qpath.path.segments.last().unwrap();\n+        try!(self.print_ident(item_segment.identifier));\n+        self.print_path_parameters(&item_segment.parameters, colons_before_params)\n     }\n \n     fn print_path_parameters(&mut self,\n@@ -2156,7 +2155,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::PatEnum(ref path, ref args_) => {\n-                try!(self.print_path(path, true));\n+                try!(self.print_path(path, true, 0));\n                 match *args_ {\n                     None => try!(word(&mut self.s, \"(..)\")),\n                     Some(ref args) => {\n@@ -2170,7 +2169,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::PatStruct(ref path, ref fields, etc) => {\n-                try!(self.print_path(path, true));\n+                try!(self.print_path(path, true, 0));\n                 try!(self.nbsp());\n                 try!(self.word_space(\"{\"));\n                 try!(self.commasep_cmnt(\n@@ -2555,7 +2554,7 @@ impl<'a> State<'a> {\n                     }\n                 }\n                 &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n-                    try!(self.print_path(path, false));\n+                    try!(self.print_path(path, false, 0));\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"=\"));\n                     try!(self.print_type(&**ty));\n@@ -2592,7 +2591,7 @@ impl<'a> State<'a> {\n     pub fn print_view_path(&mut self, vp: &ast::ViewPath) -> IoResult<()> {\n         match vp.node {\n             ast::ViewPathSimple(ident, ref path) => {\n-                try!(self.print_path(path, false));\n+                try!(self.print_path(path, false, 0));\n \n                 // FIXME(#6993) can't compare identifiers directly here\n                 if path.segments.last().unwrap().identifier.name !=\n@@ -2606,15 +2605,15 @@ impl<'a> State<'a> {\n             }\n \n             ast::ViewPathGlob(ref path) => {\n-                try!(self.print_path(path, false));\n+                try!(self.print_path(path, false, 0));\n                 word(&mut self.s, \"::*\")\n             }\n \n             ast::ViewPathList(ref path, ref idents) => {\n                 if path.segments.is_empty() {\n                     try!(word(&mut self.s, \"{\"));\n                 } else {\n-                    try!(self.print_path(path, false));\n+                    try!(self.print_path(path, false, 0));\n                     try!(word(&mut self.s, \"::{\"));\n                 }\n                 try!(self.commasep(Inconsistent, &idents[..], |s, w| {"}, {"sha": "55372585062d8b44ff23145d1d91ba593d9a224a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb8092ccf8dd186a9a03e6808d04a7276206793/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=ffb8092ccf8dd186a9a03e6808d04a7276206793", "patch": "@@ -125,9 +125,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_path(&mut self, path: &'v Path, _id: ast::NodeId) {\n         walk_path(self, path)\n     }\n-    fn visit_qpath(&mut self, qpath: &'v QPath, _id: ast::NodeId) {\n-        walk_qpath(self, qpath)\n-    }\n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment) {\n         walk_path_segment(self, path_span, path_segment)\n     }\n@@ -403,7 +400,8 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_path(path, typ.id);\n         }\n         TyQPath(ref qpath) => {\n-            visitor.visit_qpath(&**qpath, typ.id);\n+            visitor.visit_ty(&*qpath.self_type);\n+            visitor.visit_path(&qpath.path, typ.id);\n         }\n         TyObjectSum(ref ty, ref bounds) => {\n             visitor.visit_ty(&**ty);\n@@ -436,12 +434,6 @@ pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n     }\n }\n \n-pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath) {\n-    visitor.visit_ty(&*qpath.self_type);\n-    walk_path(visitor, &qpath.trait_path);\n-    visitor.visit_path_segment(qpath.trait_path.span, &qpath.item_path);\n-}\n-\n pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'v PathSegment) {\n@@ -871,7 +863,8 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_path(path, expression.id)\n         }\n         ExprQPath(ref qpath) => {\n-            visitor.visit_qpath(&**qpath, expression.id)\n+            visitor.visit_ty(&*qpath.self_type);\n+            visitor.visit_path(&qpath.path, expression.id);\n         }\n         ExprBreak(_) | ExprAgain(_) => {}\n         ExprRet(ref optional_expression) => {"}]}