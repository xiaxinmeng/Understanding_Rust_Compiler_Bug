{"sha": "edf82452730162a64ae87a8bb0865e037309a3d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZjgyNDUyNzMwMTYyYTY0YWU4N2E4YmIwODY1ZTAzNzMwOWEzZDc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-08T01:30:35Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-08T01:39:05Z"}, "message": "rustc: Make trans use interior vectors", "tree": {"sha": "9d8c08a5142cdde93924d92d5e544e6783a86b57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d8c08a5142cdde93924d92d5e544e6783a86b57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edf82452730162a64ae87a8bb0865e037309a3d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edf82452730162a64ae87a8bb0865e037309a3d7", "html_url": "https://github.com/rust-lang/rust/commit/edf82452730162a64ae87a8bb0865e037309a3d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edf82452730162a64ae87a8bb0865e037309a3d7/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97", "html_url": "https://github.com/rust-lang/rust/commit/e1b107d74ef5c27ec4c000f1fe4a9f55a7c67b97"}], "stats": {"total": 1513, "additions": 732, "deletions": 781}, "files": [{"sha": "8b6e1a5d82d6eb24e76324be5de1332480698144", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/edf82452730162a64ae87a8bb0865e037309a3d7/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf82452730162a64ae87a8bb0865e037309a3d7/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=edf82452730162a64ae87a8bb0865e037309a3d7", "patch": "@@ -429,7 +429,7 @@ fn get_symbol_hash(&@crate_ctxt ccx, &ty::t t) -> str {\n     ret hash;\n }\n \n-fn mangle(&vec[str] ss) -> str {\n+fn mangle(&str[] ss) -> str {\n     // Follow C++ namespace-mangling style\n \n     auto n = \"_ZN\"; // Begin name-sequence.\n@@ -440,14 +440,14 @@ fn mangle(&vec[str] ss) -> str {\n     ret n;\n }\n \n-fn exported_name(&vec[str] path, &str hash, &str vers) -> str {\n+fn exported_name(&str[] path, &str hash, &str vers) -> str {\n     // FIXME: versioning isn't working yet\n \n-    ret mangle(path + [hash]); //  + \"@\" + vers;\n+    ret mangle(path + ~[hash]); //  + \"@\" + vers;\n \n }\n \n-fn mangle_exported_name(&@crate_ctxt ccx, &vec[str] path, &ty::t t) -> str {\n+fn mangle_exported_name(&@crate_ctxt ccx, &str[] path, &ty::t t) -> str {\n     auto hash = get_symbol_hash(ccx, t);\n     ret exported_name(path, hash, ccx.link_meta.vers);\n }\n@@ -456,15 +456,15 @@ fn mangle_internal_name_by_type_only(&@crate_ctxt ccx, &ty::t t, &str name) ->\n    str {\n     auto s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n     auto hash = get_symbol_hash(ccx, t);\n-    ret mangle([name, s, hash]);\n+    ret mangle(~[name, s, hash]);\n }\n \n-fn mangle_internal_name_by_path_and_seq(&@crate_ctxt ccx, &vec[str] path,\n+fn mangle_internal_name_by_path_and_seq(&@crate_ctxt ccx, &str[] path,\n                                         &str flav) -> str {\n-    ret mangle(path + [ccx.names.next(flav)]);\n+    ret mangle(path + ~[ccx.names.next(flav)]);\n }\n \n-fn mangle_internal_name_by_path(&@crate_ctxt ccx, &vec[str] path) -> str {\n+fn mangle_internal_name_by_path(&@crate_ctxt ccx, &str[] path) -> str {\n     ret mangle(path);\n }\n "}, {"sha": "c1205281f309184a9a23ee9b509113e2777dca11", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/edf82452730162a64ae87a8bb0865e037309a3d7/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf82452730162a64ae87a8bb0865e037309a3d7/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=edf82452730162a64ae87a8bb0865e037309a3d7", "patch": "@@ -65,8 +65,8 @@ type upcalls =\n fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n     fn decl(type_names tn, ModuleRef llmod, str name, vec[TypeRef] tys,\n             TypeRef rv) -> ValueRef {\n-        let vec[TypeRef] arg_tys = [T_taskptr(tn)];\n-        for (TypeRef t in tys) { arg_tys += [t]; }\n+        let TypeRef[] arg_tys = ~[T_taskptr(tn)];\n+        for (TypeRef t in tys) { arg_tys += ~[t]; }\n         auto fn_ty = T_fn(arg_tys, rv);\n         ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n     }"}, {"sha": "b9e27442ba9b2a33e6c98f6206c2df933e56edb8", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 71, "deletions": 92, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/edf82452730162a64ae87a8bb0865e037309a3d7/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf82452730162a64ae87a8bb0865e037309a3d7/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=edf82452730162a64ae87a8bb0865e037309a3d7", "patch": "@@ -1,7 +1,6 @@\n-import std::vec;\n+import std::ivec;\n import std::str;\n import std::str::rustrt::sbuf;\n-import std::vec::rustrt::vbuf;\n \n import llvm::ModuleRef;\n import llvm::ContextRef;\n@@ -222,20 +221,20 @@ native mod llvm = \"rustllvm\" {\n     fn LLVMPPCFP128Type() -> TypeRef;\n \n     /* Operations on function types */\n-    fn LLVMFunctionType(TypeRef ReturnType, vbuf ParamTypes,\n+    fn LLVMFunctionType(TypeRef ReturnType, *TypeRef ParamTypes,\n                         uint ParamCount, Bool IsVarArg) -> TypeRef;\n     fn LLVMIsFunctionVarArg(TypeRef FunctionTy) -> Bool;\n     fn LLVMGetReturnType(TypeRef FunctionTy) -> TypeRef;\n     fn LLVMCountParamTypes(TypeRef FunctionTy) -> uint;\n-    fn LLVMGetParamTypes(TypeRef FunctionTy, vbuf Dest);\n+    fn LLVMGetParamTypes(TypeRef FunctionTy, *TypeRef Dest);\n \n     /* Operations on struct types */\n-    fn LLVMStructTypeInContext(ContextRef C, vbuf ElementTypes,\n+    fn LLVMStructTypeInContext(ContextRef C, *TypeRef ElementTypes,\n                                uint ElementCount, Bool Packed) -> TypeRef;\n-    fn LLVMStructType(vbuf ElementTypes, uint ElementCount,\n+    fn LLVMStructType(*TypeRef ElementTypes, uint ElementCount,\n                       Bool Packed) -> TypeRef;\n     fn LLVMCountStructElementTypes(TypeRef StructTy) -> uint;\n-    fn LLVMGetStructElementTypes(TypeRef StructTy, vbuf Dest);\n+    fn LLVMGetStructElementTypes(TypeRef StructTy, *TypeRef Dest);\n     fn LLVMIsPackedStruct(TypeRef StructTy) -> Bool;\n \n     /* Operations on array, pointer, and vector types (sequence types) */\n@@ -294,8 +293,9 @@ native mod llvm = \"rustllvm\" {\n     /* Operations on metadata */\n     fn LLVMMDStringInContext(ContextRef C, sbuf Str, uint SLen) -> ValueRef;\n     fn LLVMMDString(sbuf Str, uint SLen) -> ValueRef;\n-    fn LLVMMDNodeInContext(ContextRef C, vbuf Vals, uint Count) -> ValueRef;\n-    fn LLVMMDNode(vbuf Vals, uint Count) -> ValueRef;\n+    fn LLVMMDNodeInContext(ContextRef C, *ValueRef Vals, uint Count)\n+        -> ValueRef;\n+    fn LLVMMDNode(*ValueRef Vals, uint Count) -> ValueRef;\n \n     /* Operations on scalar constants */\n     fn LLVMConstInt(TypeRef IntTy, ULongLong N, Bool SignExtend) -> ValueRef;\n@@ -315,16 +315,16 @@ native mod llvm = \"rustllvm\" {\n     /* Operations on composite constants */\n     fn LLVMConstStringInContext(ContextRef C, sbuf Str, uint Length,\n                                 Bool DontNullTerminate) -> ValueRef;\n-    fn LLVMConstStructInContext(ContextRef C, vbuf ConstantVals,\n+    fn LLVMConstStructInContext(ContextRef C, *ValueRef ConstantVals,\n                                 uint Count, Bool Packed) -> ValueRef;\n \n     fn LLVMConstString(sbuf Str, uint Length,\n                        Bool DontNullTerminate) -> ValueRef;\n     fn LLVMConstArray(TypeRef ElementTy,\n-                      vbuf ConstantVals, uint Length) -> ValueRef;\n-    fn LLVMConstStruct(vbuf ConstantVals, uint Count,\n+                      *ValueRef ConstantVals, uint Length) -> ValueRef;\n+    fn LLVMConstStruct(*ValueRef ConstantVals, uint Count,\n                        Bool Packed) -> ValueRef;\n-    fn LLVMConstVector(vbuf ScalarConstantVals, uint Size) -> ValueRef;\n+    fn LLVMConstVector(*ValueRef ScalarConstantVals, uint Size) -> ValueRef;\n \n     /* Constant expressions */\n     fn LLVMAlignOf(TypeRef Ty) -> ValueRef;\n@@ -367,9 +367,9 @@ native mod llvm = \"rustllvm\" {\n     fn LLVMConstLShr(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n     fn LLVMConstAShr(ValueRef LHSConstant, ValueRef RHSConstant) -> ValueRef;\n     fn LLVMConstGEP(ValueRef ConstantVal,\n-                    vbuf ConstantIndices, uint NumIndices) -> ValueRef;\n+                    *uint ConstantIndices, uint NumIndices) -> ValueRef;\n     fn LLVMConstInBoundsGEP(ValueRef ConstantVal,\n-                            vbuf ConstantIndices,\n+                            *uint ConstantIndices,\n                             uint NumIndices) -> ValueRef;\n     fn LLVMConstTrunc(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n     fn LLVMConstSExt(ValueRef ConstantVal, TypeRef ToType) -> ValueRef;\n@@ -405,11 +405,11 @@ native mod llvm = \"rustllvm\" {\n     fn LLVMConstShuffleVector(ValueRef VectorAConstant,\n                               ValueRef VectorBConstant,\n                               ValueRef MaskConstant) -> ValueRef;\n-    fn LLVMConstExtractValue(ValueRef AggConstant, vbuf IdxList,\n+    fn LLVMConstExtractValue(ValueRef AggConstant, *uint IdxList,\n                              uint NumIdx) -> ValueRef;\n     fn LLVMConstInsertValue(ValueRef AggConstant,\n                             ValueRef ElementValueConstant,\n-                            vbuf IdxList, uint NumIdx) -> ValueRef;\n+                            *uint IdxList, uint NumIdx) -> ValueRef;\n     fn LLVMConstInlineAsm(TypeRef Ty,\n                           sbuf AsmString, sbuf Constraints,\n                           Bool HasSideEffects, Bool IsAlignStack) -> ValueRef;\n@@ -472,7 +472,7 @@ native mod llvm = \"rustllvm\" {\n \n     /* Operations on parameters */\n     fn LLVMCountParams(ValueRef Fn) -> uint;\n-    fn LLVMGetParams(ValueRef Fn, vbuf Params);\n+    fn LLVMGetParams(ValueRef Fn, *ValueRef Params);\n     fn LLVMGetParam(ValueRef Fn, uint Index) -> ValueRef;\n     fn LLVMGetParamParent(ValueRef Inst) -> ValueRef;\n     fn LLVMGetFirstParam(ValueRef Fn) -> ValueRef;\n@@ -490,7 +490,7 @@ native mod llvm = \"rustllvm\" {\n     fn LLVMValueAsBasicBlock(ValueRef Val) -> BasicBlockRef;\n     fn LLVMGetBasicBlockParent(BasicBlockRef BB) -> ValueRef;\n     fn LLVMCountBasicBlocks(ValueRef Fn) -> uint;\n-    fn LLVMGetBasicBlocks(ValueRef Fn, vbuf BasicBlocks);\n+    fn LLVMGetBasicBlocks(ValueRef Fn, *ValueRef BasicBlocks);\n     fn LLVMGetFirstBasicBlock(ValueRef Fn) -> BasicBlockRef;\n     fn LLVMGetLastBasicBlock(ValueRef Fn) -> BasicBlockRef;\n     fn LLVMGetNextBasicBlock(BasicBlockRef BB) -> BasicBlockRef;\n@@ -526,8 +526,8 @@ native mod llvm = \"rustllvm\" {\n     fn LLVMSetTailCall(ValueRef CallInst, Bool IsTailCall);\n \n     /* Operations on phi nodes */\n-    fn LLVMAddIncoming(ValueRef PhiNode, vbuf IncomingValues,\n-                       vbuf IncomingBlocks, uint Count);\n+    fn LLVMAddIncoming(ValueRef PhiNode, *ValueRef IncomingValues,\n+                       *BasicBlockRef IncomingBlocks, uint Count);\n     fn LLVMCountIncoming(ValueRef PhiNode) -> uint;\n     fn LLVMGetIncomingValue(ValueRef PhiNode, uint Index) -> ValueRef;\n     fn LLVMGetIncomingBlock(ValueRef PhiNode, uint Index) -> BasicBlockRef;\n@@ -554,7 +554,7 @@ native mod llvm = \"rustllvm\" {\n     /* Terminators */\n     fn LLVMBuildRetVoid(BuilderRef B) -> ValueRef;\n     fn LLVMBuildRet(BuilderRef B, ValueRef V) -> ValueRef;\n-    fn LLVMBuildAggregateRet(BuilderRef B, vbuf RetVals,\n+    fn LLVMBuildAggregateRet(BuilderRef B, *ValueRef RetVals,\n                              uint N) -> ValueRef;\n     fn LLVMBuildBr(BuilderRef B, BasicBlockRef Dest) -> ValueRef;\n     fn LLVMBuildCondBr(BuilderRef B, ValueRef If,\n@@ -564,7 +564,7 @@ native mod llvm = \"rustllvm\" {\n     fn LLVMBuildIndirectBr(BuilderRef B, ValueRef Addr,\n                            uint NumDests) -> ValueRef;\n     fn LLVMBuildInvoke(BuilderRef B, ValueRef Fn,\n-                       vbuf Args, uint NumArgs,\n+                       *ValueRef Args, uint NumArgs,\n                        BasicBlockRef Then, BasicBlockRef Catch,\n                        sbuf Name) -> ValueRef;\n     fn LLVMBuildUnwind(BuilderRef B) -> ValueRef;\n@@ -651,10 +651,10 @@ native mod llvm = \"rustllvm\" {\n                      sbuf Name) -> ValueRef;\n     fn LLVMBuildStore(BuilderRef B, ValueRef Val, ValueRef Ptr) -> ValueRef;\n     fn LLVMBuildGEP(BuilderRef B, ValueRef Pointer,\n-                    vbuf Indices, uint NumIndices,\n+                    *ValueRef Indices, uint NumIndices,\n                     sbuf Name) -> ValueRef;\n     fn LLVMBuildInBoundsGEP(BuilderRef B, ValueRef Pointer,\n-                            vbuf Indices, uint NumIndices,\n+                            *ValueRef Indices, uint NumIndices,\n                             sbuf Name) -> ValueRef;\n     fn LLVMBuildStructGEP(BuilderRef B, ValueRef Pointer,\n                           uint Idx, sbuf Name) -> ValueRef;\n@@ -714,7 +714,7 @@ native mod llvm = \"rustllvm\" {\n     /* Miscellaneous instructions */\n     fn LLVMBuildPhi(BuilderRef B, TypeRef Ty, sbuf Name) -> ValueRef;\n     fn LLVMBuildCall(BuilderRef B, ValueRef Fn,\n-                     vbuf Args, uint NumArgs,\n+                     *ValueRef Args, uint NumArgs,\n                      sbuf Name) -> ValueRef;\n     fn LLVMBuildSelect(BuilderRef B, ValueRef If,\n                        ValueRef Then, ValueRef Else,\n@@ -908,12 +908,11 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n         ret llvm::LLVMBuildRet(B, V);\n     }\n \n-    fn AggregateRet(vec[ValueRef] RetVals) -> ValueRef {\n+    fn AggregateRet(&ValueRef[] RetVals) -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n-        ret llvm::LLVMBuildAggregateRet(B,\n-                                       vec::buf[ValueRef](RetVals),\n-                                       vec::len[ValueRef](RetVals));\n+        ret llvm::LLVMBuildAggregateRet(B, ivec::to_ptr(RetVals),\n+                                        ivec::len(RetVals));\n     }\n \n     fn Br(BasicBlockRef Dest) -> ValueRef {\n@@ -942,16 +941,13 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n     }\n \n     fn Invoke(ValueRef Fn,\n-              vec[ValueRef] Args,\n+              &ValueRef[] Args,\n               BasicBlockRef Then,\n               BasicBlockRef Catch) -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n-        ret llvm::LLVMBuildInvoke(B, Fn,\n-                                 vec::buf[ValueRef](Args),\n-                                 vec::len[ValueRef](Args),\n-                                 Then, Catch,\n-                                 str::buf(\"\"));\n+        ret llvm::LLVMBuildInvoke(B, Fn, ivec::to_ptr(Args), ivec::len(Args),\n+                                  Then, Catch, str::buf(\"\"));\n     }\n \n     fn Unwind() -> ValueRef {\n@@ -1156,20 +1152,16 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n         ret llvm::LLVMBuildStore(B, Val, Ptr);\n     }\n \n-    fn GEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n+    fn GEP(ValueRef Pointer, &ValueRef[] Indices) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildGEP(B, Pointer,\n-                              vec::buf[ValueRef](Indices),\n-                              vec::len[ValueRef](Indices),\n-                              str::buf(\"\"));\n+        ret llvm::LLVMBuildGEP(B, Pointer, ivec::to_ptr(Indices),\n+                               ivec::len(Indices), str::buf(\"\"));\n     }\n \n-    fn InBoundsGEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n+    fn InBoundsGEP(ValueRef Pointer, &ValueRef[] Indices) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildInBoundsGEP(B, Pointer,\n-                                      vec::buf[ValueRef](Indices),\n-                                      vec::len[ValueRef](Indices),\n-                                      str::buf(\"\"));\n+        ret llvm::LLVMBuildInBoundsGEP(B, Pointer, ivec::to_ptr(Indices),\n+                                       ivec::len(Indices), str::buf(\"\"));\n     }\n \n     fn StructGEP(ValueRef Pointer, uint Idx) -> ValueRef {\n@@ -1297,42 +1289,33 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n \n \n     /* Miscellaneous instructions */\n-    fn Phi(TypeRef Ty, vec[ValueRef] vals,\n-           vec[BasicBlockRef] bbs) -> ValueRef {\n+    fn Phi(TypeRef Ty, &ValueRef[] vals, &BasicBlockRef[] bbs) -> ValueRef {\n         assert (!*terminated);\n         auto phi = llvm::LLVMBuildPhi(B, Ty, str::buf(\"\"));\n-        assert (vec::len[ValueRef](vals) == vec::len[BasicBlockRef](bbs));\n-        llvm::LLVMAddIncoming(phi,\n-                             vec::buf[ValueRef](vals),\n-                             vec::buf[BasicBlockRef](bbs),\n-                             vec::len[ValueRef](vals));\n+        assert (ivec::len[ValueRef](vals) == ivec::len[BasicBlockRef](bbs));\n+        llvm::LLVMAddIncoming(phi, ivec::to_ptr(vals), ivec::to_ptr(bbs),\n+                              ivec::len(vals));\n         ret phi;\n     }\n \n     fn AddIncomingToPhi(ValueRef phi,\n-                        vec[ValueRef] vals,\n-                        vec[BasicBlockRef] bbs) {\n-        assert (vec::len[ValueRef](vals) == vec::len[BasicBlockRef](bbs));\n-        llvm::LLVMAddIncoming(phi,\n-                             vec::buf[ValueRef](vals),\n-                             vec::buf[BasicBlockRef](bbs),\n-                             vec::len[ValueRef](vals));\n+                        &ValueRef[] vals,\n+                        &BasicBlockRef[] bbs) {\n+        assert (ivec::len[ValueRef](vals) == ivec::len[BasicBlockRef](bbs));\n+        llvm::LLVMAddIncoming(phi, ivec::to_ptr(vals), ivec::to_ptr(bbs),\n+                              ivec::len(vals));\n     }\n \n-    fn Call(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n+    fn Call(ValueRef Fn, &ValueRef[] Args) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildCall(B, Fn,\n-                               vec::buf[ValueRef](Args),\n-                               vec::len[ValueRef](Args),\n-                               str::buf(\"\"));\n+        ret llvm::LLVMBuildCall(B, Fn, ivec::to_ptr(Args), ivec::len(Args),\n+                                str::buf(\"\"));\n     }\n \n-    fn FastCall(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n+    fn FastCall(ValueRef Fn, &ValueRef[] Args) -> ValueRef {\n         assert (!*terminated);\n-        auto v = llvm::LLVMBuildCall(B, Fn,\n-                                    vec::buf[ValueRef](Args),\n-                                    vec::len[ValueRef](Args),\n-                                    str::buf(\"\"));\n+        auto v = llvm::LLVMBuildCall(B, Fn, ivec::to_ptr(Args),\n+                                     ivec::len(Args), str::buf(\"\"));\n         llvm::LLVMSetInstructionCallConv(v, LLVMFastCallConv);\n         ret v;\n     }\n@@ -1399,11 +1382,9 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n         let ValueRef T = llvm::LLVMGetNamedFunction(M,\n                                                     str::buf(\"llvm.trap\"));\n         assert (T as int != 0);\n-        let vec[ValueRef] Args = [];\n-        ret llvm::LLVMBuildCall(B, T,\n-                               vec::buf[ValueRef](Args),\n-                               vec::len[ValueRef](Args),\n-                               str::buf(\"\"));\n+        let ValueRef[] Args = ~[];\n+        ret llvm::LLVMBuildCall(B, T, ivec::to_ptr(Args), ivec::len(Args),\n+                                str::buf(\"\"));\n     }\n \n     fn is_terminated() -> bool {\n@@ -1475,23 +1456,20 @@ fn mk_type_names() -> type_names {\n }\n \n fn type_to_str(type_names names, TypeRef ty) -> str {\n-    let vec[TypeRef] v = [];\n-    ret type_to_str_inner(names, v, ty);\n+    ret type_to_str_inner(names, ~[], ty);\n }\n \n-fn type_to_str_inner(type_names names,\n-                     vec[TypeRef] outer0, TypeRef ty) -> str {\n+fn type_to_str_inner(type_names names, &TypeRef[] outer0, TypeRef ty) -> str {\n \n     if (names.type_has_name(ty)) {\n         ret names.get_name(ty);\n     }\n \n-    auto outer = outer0 + [ty];\n+    auto outer = outer0 + ~[ty];\n \n     let int kind = llvm::LLVMGetTypeKind(ty);\n \n-    fn tys_str(type_names names,\n-               vec[TypeRef] outer, vec[TypeRef] tys) -> str {\n+    fn tys_str(type_names names, &TypeRef[] outer, &TypeRef[] tys) -> str {\n         let str s = \"\";\n         let bool first = true;\n         for (TypeRef t in tys) {\n@@ -1526,9 +1504,9 @@ fn type_to_str_inner(type_names names,\n             auto s = \"fn(\";\n             let TypeRef out_ty = llvm::LLVMGetReturnType(ty);\n             let uint n_args = llvm::LLVMCountParamTypes(ty);\n-            let vec[TypeRef] args =\n-                vec::init_elt[TypeRef](0 as TypeRef, n_args);\n-            llvm::LLVMGetParamTypes(ty, vec::buf[TypeRef](args));\n+            let TypeRef[] args =\n+                ivec::init_elt[TypeRef](0 as TypeRef, n_args);\n+            llvm::LLVMGetParamTypes(ty, ivec::to_ptr(args));\n             s += tys_str(names, outer, args);\n             s += \") -> \";\n             s += type_to_str_inner(names, outer, out_ty);\n@@ -1538,9 +1516,9 @@ fn type_to_str_inner(type_names names,\n         case (9) {\n             let str s = \"{\";\n             let uint n_elts = llvm::LLVMCountStructElementTypes(ty);\n-            let vec[TypeRef] elts =\n-                vec::init_elt[TypeRef](0 as TypeRef, n_elts);\n-            llvm::LLVMGetStructElementTypes(ty, vec::buf[TypeRef](elts));\n+            let TypeRef[] elts =\n+                ivec::init_elt[TypeRef](0 as TypeRef, n_elts);\n+            llvm::LLVMGetStructElementTypes(ty, ivec::to_ptr(elts));\n             s += tys_str(names, outer, elts);\n             s += \"}\";\n             ret s;\n@@ -1556,7 +1534,7 @@ fn type_to_str_inner(type_names names,\n             for (TypeRef tout in outer0) {\n                 i += 1u;\n                 if (tout as int == ty as int) {\n-                    let uint n = vec::len[TypeRef](outer0) - i;\n+                    let uint n = ivec::len[TypeRef](outer0) - i;\n                     ret \"*\\\\\" + std::int::str(n as int);\n                 }\n             }\n@@ -1574,9 +1552,10 @@ fn type_to_str_inner(type_names names,\n     }\n }\n \n-fn fn_ty_param_tys(TypeRef fn_ty) -> vec[TypeRef] {\n-    auto args = vec::init_elt(0 as TypeRef, llvm::LLVMCountParamTypes(fn_ty));\n-    llvm::LLVMGetParamTypes(fn_ty, vec::buf(args));\n+fn fn_ty_param_tys(TypeRef fn_ty) -> TypeRef[] {\n+    auto args = ivec::init_elt(0 as TypeRef,\n+                               llvm::LLVMCountParamTypes(fn_ty));\n+    llvm::LLVMGetParamTypes(fn_ty, ivec::to_ptr(args));\n     ret args;\n }\n "}, {"sha": "431f75482d759aee0913b58ebcb9a239884a897b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 651, "deletions": 679, "changes": 1330, "blob_url": "https://github.com/rust-lang/rust/blob/edf82452730162a64ae87a8bb0865e037309a3d7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf82452730162a64ae87a8bb0865e037309a3d7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=edf82452730162a64ae87a8bb0865e037309a3d7"}]}