{"sha": "410385dfd0532f3e8867afaaa4b89c315b0e84b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMDM4NWRmZDA1MzJmM2U4ODY3YWZhYWE0Yjg5YzMxNWIwZTg0YjE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-23T09:58:43Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-23T10:02:18Z"}, "message": "add macro to reduce boilerplate and keep readable messages", "tree": {"sha": "cc840208cdfb6ae47c78ed94914a0eb673df3f08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc840208cdfb6ae47c78ed94914a0eb673df3f08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/410385dfd0532f3e8867afaaa4b89c315b0e84b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/410385dfd0532f3e8867afaaa4b89c315b0e84b1", "html_url": "https://github.com/rust-lang/rust/commit/410385dfd0532f3e8867afaaa4b89c315b0e84b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/410385dfd0532f3e8867afaaa4b89c315b0e84b1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cda81da6ea4c037ef036067d9cb98e80208ee525", "url": "https://api.github.com/repos/rust-lang/rust/commits/cda81da6ea4c037ef036067d9cb98e80208ee525", "html_url": "https://github.com/rust-lang/rust/commit/cda81da6ea4c037ef036067d9cb98e80208ee525"}], "stats": {"total": 47, "additions": 25, "deletions": 22}, "files": [{"sha": "010b73db9ac20df8a4c25ef2d90a88a1a50ef9d7", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/410385dfd0532f3e8867afaaa4b89c315b0e84b1/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/410385dfd0532f3e8867afaaa4b89c315b0e84b1/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=410385dfd0532f3e8867afaaa4b89c315b0e84b1", "patch": "@@ -577,7 +577,7 @@ impl InterpError<'_> {\n     /// waste of resources.\n     pub fn allocates(&self) -> bool {\n         match self {\n-            // Zero-sized boxes to not allocate.\n+            // Zero-sized boxes do not allocate.\n             InterpError::MachineStop(b) => mem::size_of_val(&**b) > 0,\n             InterpError::Unsupported(UnsupportedOpInfo::Unsupported(_))\n             | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::ValidationFailure(_))"}, {"sha": "74140a1fc6daf8b33a321452f45e287e0f70aca7", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/410385dfd0532f3e8867afaaa4b89c315b0e84b1/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/410385dfd0532f3e8867afaaa4b89c315b0e84b1/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=410385dfd0532f3e8867afaaa4b89c315b0e84b1", "patch": "@@ -4,7 +4,7 @@\n use std::borrow::Cow;\n use std::cell::Cell;\n \n-use rustc::mir::interpret::{InterpResult, MachineStopType, Scalar};\n+use rustc::mir::interpret::{InterpResult, Scalar};\n use rustc::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n@@ -39,6 +39,24 @@ use crate::transform::{MirPass, MirSource};\n /// The maximum number of bytes that we'll allocate space for a return value.\n const MAX_ALLOC_LIMIT: u64 = 1024;\n \n+/// Macro for machine-specific `InterpError` without allocation.\n+/// (These will never be shown to the user, but they help diagnose ICEs.)\n+macro_rules! throw_machine_stop_str {\n+    ($($tt:tt)*) => {{\n+        // We make a new local type for it. The type itself does not carry any information,\n+        // but its vtable (for the `MachineStopType` trait) does.\n+        struct Zst;\n+        // Debug-printing this type shows the desired string.\n+        impl std::fmt::Debug for Zst {\n+            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+                write!(f, $($tt)*)\n+            }\n+        }\n+        impl rustc::mir::interpret::MachineStopType for Zst {}\n+        throw_machine_stop!(Zst)\n+    }};\n+}\n+\n pub struct ConstProp;\n \n impl<'tcx> MirPass<'tcx> for ConstProp {\n@@ -192,10 +210,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: Option<BasicBlock>,\n     ) -> InterpResult<'tcx> {\n-        #[derive(Debug)]\n-        struct ConstPropIntrinsic;\n-        impl MachineStopType for ConstPropIntrinsic {}\n-        throw_machine_stop!(ConstPropIntrinsic)\n+        throw_machine_stop_str!(\"calling intrinsics isn't supported in ConstProp\")\n     }\n \n     fn assert_panic(\n@@ -216,11 +231,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n-        #[derive(Debug)]\n-        struct ConstPropPtrOp;\n-        impl MachineStopType for ConstPropPtrOp {}\n         // We can't do this because aliasing of memory can differ between const eval and llvm\n-        throw_machine_stop!(ConstPropPtrOp)\n+        throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n     }\n \n     #[inline(always)]\n@@ -243,10 +255,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n-        #[derive(Debug)]\n-        struct ConstPropBox;\n-        impl MachineStopType for ConstPropBox {}\n-        throw_machine_stop!(ConstPropBox)\n+        throw_machine_stop_str!(\"can't const prop heap allocations\")\n     }\n \n     fn access_local(\n@@ -257,10 +266,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         let l = &frame.locals[local];\n \n         if l.value == LocalValue::Uninitialized {\n-            #[derive(Debug)]\n-            struct ConstPropUninitLocal;\n-            impl MachineStopType for ConstPropUninitLocal {}\n-            throw_machine_stop!(ConstPropUninitLocal)\n+            throw_machine_stop_str!(\"tried to access an uninitialized local\")\n         }\n \n         l.access()\n@@ -270,13 +276,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _memory_extra: &(),\n         allocation: &Allocation<Self::PointerTag, Self::AllocExtra>,\n     ) -> InterpResult<'tcx> {\n-        #[derive(Debug)]\n-        struct ConstPropGlobalMem;\n-        impl MachineStopType for ConstPropGlobalMem {}\n         // if the static allocation is mutable or if it has relocations (it may be legal to mutate\n         // the memory behind that in the future), then we can't const prop it\n         if allocation.mutability == Mutability::Mut || allocation.relocations().len() > 0 {\n-            throw_machine_stop!(ConstPropGlobalMem)\n+            throw_machine_stop_str!(\"can't eval mutable statics in ConstProp\")\n         }\n \n         Ok(())"}]}