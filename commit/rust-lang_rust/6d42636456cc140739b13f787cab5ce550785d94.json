{"sha": "6d42636456cc140739b13f787cab5ce550785d94", "node_id": "C_kwDOAAsO6NoAKDZkNDI2MzY0NTZjYzE0MDczOWIxM2Y3ODdjYWI1Y2U1NTA3ODVkOTQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-25T20:52:34Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-12-25T16:41:33Z"}, "message": "Encode span parent in the inlined representation.", "tree": {"sha": "d8606ee3520acc43124100b22f0078aafabb6cd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8606ee3520acc43124100b22f0078aafabb6cd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d42636456cc140739b13f787cab5ce550785d94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d42636456cc140739b13f787cab5ce550785d94", "html_url": "https://github.com/rust-lang/rust/commit/6d42636456cc140739b13f787cab5ce550785d94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d42636456cc140739b13f787cab5ce550785d94/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9ee0f468f8d07e92da94fe991db91e95822d721", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9ee0f468f8d07e92da94fe991db91e95822d721", "html_url": "https://github.com/rust-lang/rust/commit/d9ee0f468f8d07e92da94fe991db91e95822d721"}], "stats": {"total": 86, "additions": 64, "deletions": 22}, "files": [{"sha": "d48c4f7e5a8119f1c84f2a9b32d043dcab05e898", "filename": "compiler/rustc_span/src/span_encoding.rs", "status": "modified", "additions": 64, "deletions": 22, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6d42636456cc140739b13f787cab5ce550785d94/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d42636456cc140739b13f787cab5ce550785d94/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs?ref=6d42636456cc140739b13f787cab5ce550785d94", "patch": "@@ -4,7 +4,7 @@\n // The encoding format for inline spans were obtained by optimizing over crates in rustc/libstd.\n // See https://internals.rust-lang.org/t/rfc-compiler-refactoring-spans/1357/28\n \n-use crate::def_id::LocalDefId;\n+use crate::def_id::{DefIndex, LocalDefId};\n use crate::hygiene::SyntaxContext;\n use crate::SPAN_TRACK;\n use crate::{BytePos, SpanData};\n@@ -13,8 +13,8 @@ use rustc_data_structures::fx::FxIndexSet;\n \n /// A compressed span.\n ///\n-/// Whereas [`SpanData`] is 12 bytes, which is a bit too big to stick everywhere, `Span`\n-/// is a form that only takes up 8 bytes, with less space for the length and\n+/// Whereas [`SpanData`] is 16 bytes, which is a bit too big to stick everywhere, `Span`\n+/// is a form that only takes up 8 bytes, with less space for the length, parent and\n /// context. The vast majority (99.9%+) of `SpanData` instances will fit within\n /// those 8 bytes; any `SpanData` whose fields don't fit into a `Span` are\n /// stored in a separate interner table, and the `Span` will index into that\n@@ -25,7 +25,7 @@ use rustc_data_structures::fx::FxIndexSet;\n /// slower because only 80--90% of spans could be stored inline (even less in\n /// very large crates) and so the interner was used a lot more.\n ///\n-/// Inline (compressed) format:\n+/// Inline (compressed) format with no parent:\n /// - `span.base_or_index == span_data.lo`\n /// - `span.len_or_tag == len == span_data.hi - span_data.lo` (must be `<= MAX_LEN`)\n /// - `span.ctxt_or_tag == span_data.ctxt` (must be `<= MAX_CTXT`)\n@@ -35,6 +35,12 @@ use rustc_data_structures::fx::FxIndexSet;\n /// - `span.len_or_tag == LEN_TAG` (high bit set, all other bits are zero)\n /// - `span.ctxt_or_tag == span_data.ctxt` (must be `<= MAX_CTXT`)\n ///\n+/// Inline (compressed) format with root context:\n+/// - `span.base_or_index == span_data.lo`\n+/// - `span.len_or_tag == len == span_data.hi - span_data.lo` (must be `<= MAX_LEN`)\n+/// - `span.len_or_tag` has top bit (`PARENT_MASK`) set\n+/// - `span.ctxt == span_data.parent` (must be `<= MAX_CTXT`)\n+///\n /// Interned format:\n /// - `span.base_or_index == index` (indexes into the interner table)\n /// - `span.len_or_tag == LEN_TAG` (high bit set, all other bits are zero)\n@@ -73,7 +79,8 @@ pub struct Span {\n     ctxt_or_tag: u16,\n }\n \n-const LEN_TAG: u16 = 0b1000_0000_0000_0000;\n+const LEN_TAG: u16 = 0b1111_1111_1111_1111;\n+const PARENT_MASK: u16 = 0b1000_0000_0000_0000;\n const MAX_LEN: u32 = 0b0111_1111_1111_1111;\n const CTXT_TAG: u32 = 0b1111_1111_1111_1111;\n const MAX_CTXT: u32 = CTXT_TAG - 1;\n@@ -95,16 +102,32 @@ impl Span {\n \n         let (base, len, ctxt2) = (lo.0, hi.0 - lo.0, ctxt.as_u32());\n \n-        if len <= MAX_LEN && ctxt2 <= MAX_CTXT && parent.is_none() {\n-            // Inline format.\n-            Span { base_or_index: base, len_or_tag: len as u16, ctxt_or_tag: ctxt2 as u16 }\n-        } else {\n-            // Interned format.\n-            let index =\n-                with_span_interner(|interner| interner.intern(&SpanData { lo, hi, ctxt, parent }));\n-            let ctxt_or_tag = if ctxt2 <= MAX_CTXT { ctxt2 } else { CTXT_TAG } as u16;\n-            Span { base_or_index: index, len_or_tag: LEN_TAG, ctxt_or_tag }\n+        if len <= MAX_LEN && ctxt2 <= MAX_CTXT {\n+            let len_or_tag = len as u16;\n+            debug_assert_eq!(len_or_tag & PARENT_MASK, 0);\n+\n+            if let Some(parent) = parent {\n+                // Inline format with parent.\n+                let len_or_tag = len_or_tag | PARENT_MASK;\n+                let parent2 = parent.local_def_index.as_u32();\n+                if ctxt2 == SyntaxContext::root().as_u32() && parent2 <= MAX_CTXT {\n+                    return Span { base_or_index: base, len_or_tag, ctxt_or_tag: parent2 as u16 };\n+                }\n+            } else {\n+                // Inline format with ctxt.\n+                return Span {\n+                    base_or_index: base,\n+                    len_or_tag: len as u16,\n+                    ctxt_or_tag: ctxt2 as u16,\n+                };\n+            }\n         }\n+\n+        // Interned format.\n+        let index =\n+            with_span_interner(|interner| interner.intern(&SpanData { lo, hi, ctxt, parent }));\n+        let ctxt_or_tag = if ctxt2 <= MAX_CTXT { ctxt2 } else { CTXT_TAG } as u16;\n+        Span { base_or_index: index, len_or_tag: LEN_TAG, ctxt_or_tag }\n     }\n \n     #[inline]\n@@ -122,12 +145,25 @@ impl Span {\n     pub fn data_untracked(self) -> SpanData {\n         if self.len_or_tag != LEN_TAG {\n             // Inline format.\n-            debug_assert!(self.len_or_tag as u32 <= MAX_LEN);\n-            SpanData {\n-                lo: BytePos(self.base_or_index),\n-                hi: BytePos(self.base_or_index + self.len_or_tag as u32),\n-                ctxt: SyntaxContext::from_u32(self.ctxt_or_tag as u32),\n-                parent: None,\n+            if self.len_or_tag & PARENT_MASK == 0 {\n+                debug_assert!(self.len_or_tag as u32 <= MAX_LEN);\n+                SpanData {\n+                    lo: BytePos(self.base_or_index),\n+                    hi: BytePos(self.base_or_index + self.len_or_tag as u32),\n+                    ctxt: SyntaxContext::from_u32(self.ctxt_or_tag as u32),\n+                    parent: None,\n+                }\n+            } else {\n+                let len = self.len_or_tag & !PARENT_MASK;\n+                debug_assert!(len as u32 <= MAX_LEN);\n+                let parent =\n+                    LocalDefId { local_def_index: DefIndex::from_u32(self.ctxt_or_tag as u32) };\n+                SpanData {\n+                    lo: BytePos(self.base_or_index),\n+                    hi: BytePos(self.base_or_index + len as u32),\n+                    ctxt: SyntaxContext::root(),\n+                    parent: Some(parent),\n+                }\n             }\n         } else {\n             // Interned format.\n@@ -141,8 +177,14 @@ impl Span {\n     pub fn ctxt(self) -> SyntaxContext {\n         let ctxt_or_tag = self.ctxt_or_tag as u32;\n         if ctxt_or_tag <= MAX_CTXT {\n-            // Inline format or interned format with inline ctxt.\n-            SyntaxContext::from_u32(ctxt_or_tag)\n+            if self.len_or_tag == LEN_TAG || self.len_or_tag & PARENT_MASK == 0 {\n+                // Inline format or interned format with inline ctxt.\n+                SyntaxContext::from_u32(ctxt_or_tag)\n+            } else {\n+                // Inline format or interned format with inline parent.\n+                // We know that the SyntaxContext is root.\n+                SyntaxContext::root()\n+            }\n         } else {\n             // Interned format.\n             let index = self.base_or_index;"}]}