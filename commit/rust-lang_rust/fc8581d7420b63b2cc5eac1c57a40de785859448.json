{"sha": "fc8581d7420b63b2cc5eac1c57a40de785859448", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjODU4MWQ3NDIwYjYzYjJjYzVlYWMxYzU3YTQwZGU3ODU4NTk0NDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-30T14:12:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-30T14:12:12Z"}, "message": "Auto merge of #59561 - Centril:rollup, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #59343 (rustc(codegen): uncache `def_symbol_name` prefix from `symbol_name`.)\n - #59380 (Fix invalid DWARF for enums when using ThinLTO)\n - #59463 (skip dyn keyword lint under macros)\n - #59539 (Fix infinite recursion)\n - #59544 (manifest: only include miri on the nightly channel)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "cb9a00e632f44a35f9d2320df2f4d63fb785fc34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb9a00e632f44a35f9d2320df2f4d63fb785fc34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc8581d7420b63b2cc5eac1c57a40de785859448", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc8581d7420b63b2cc5eac1c57a40de785859448", "html_url": "https://github.com/rust-lang/rust/commit/fc8581d7420b63b2cc5eac1c57a40de785859448", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc8581d7420b63b2cc5eac1c57a40de785859448/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c49da45441d29aadd5935dabbaa8dc09ebad33a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c49da45441d29aadd5935dabbaa8dc09ebad33a", "html_url": "https://github.com/rust-lang/rust/commit/6c49da45441d29aadd5935dabbaa8dc09ebad33a"}, {"sha": "04ffaca71a16905d58161e51c1046daebe8dee0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/04ffaca71a16905d58161e51c1046daebe8dee0b", "html_url": "https://github.com/rust-lang/rust/commit/04ffaca71a16905d58161e51c1046daebe8dee0b"}], "stats": {"total": 656, "additions": 590, "deletions": 66}, "files": [{"sha": "03fa5c04ec721284e874d2ce9dba9fa07fa75489", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -500,8 +500,7 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     [] ConstEval { param_env: ParamEnvAnd<'tcx, GlobalId<'tcx>> },\n     [] ConstEvalRaw { param_env: ParamEnvAnd<'tcx, GlobalId<'tcx>> },\n     [] CheckMatch(DefId),\n-    [] SymbolName(DefId),\n-    [] InstanceSymbolName { instance: Instance<'tcx> },\n+    [] SymbolName { instance: Instance<'tcx> },\n     [] SpecializationGraph(DefId),\n     [] ObjectSafety(DefId),\n     [] FulfillObligation { param_env: ParamEnv<'tcx>, trait_ref: PolyTraitRef<'tcx> },"}, {"sha": "bc5caffb934643ee3a400bee77f92d6e957c6786", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -941,7 +941,6 @@ impl_disk_cacheable_query!(mir_borrowck, |tcx, def_id| {\n impl_disk_cacheable_query!(unsafety_check_result, |_, def_id| def_id.is_local());\n impl_disk_cacheable_query!(borrowck, |_, def_id| def_id.is_local());\n impl_disk_cacheable_query!(check_match, |_, def_id| def_id.is_local());\n-impl_disk_cacheable_query!(def_symbol_name, |_, _| true);\n impl_disk_cacheable_query!(predicates_of, |_, def_id| def_id.is_local());\n impl_disk_cacheable_query!(used_trait_imports, |_, def_id| def_id.is_local());\n impl_disk_cacheable_query!(codegen_fn_attrs, |_, _| true);"}, {"sha": "f64156beeaa2d41aa6c4629f1d49b80f258996ba", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -315,7 +315,6 @@ rustc_query_append! { [define_queries!][ <'tcx>\n \n         [] fn mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n \n-        [] fn def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n         [] fn symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n \n         [] fn describe_def: DescribeDef(DefId) -> Option<Def>,\n@@ -727,7 +726,7 @@ fn mir_shim_dep_node<'tcx>(instance_def: ty::InstanceDef<'tcx>) -> DepConstructo\n }\n \n fn symbol_name_dep_node<'tcx>(instance: ty::Instance<'tcx>) -> DepConstructor<'tcx> {\n-    DepConstructor::InstanceSymbolName { instance }\n+    DepConstructor::SymbolName { instance }\n }\n \n fn typeck_item_bodies_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {"}, {"sha": "1b4c36b8b06c32eb0728947b802dc5e0078f2556", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -218,7 +218,6 @@ impl<'sess> OnDiskCache<'sess> {\n                 encode_query_results::<borrowck<'_>, _>(tcx, enc, qri)?;\n                 encode_query_results::<mir_borrowck<'_>, _>(tcx, enc, qri)?;\n                 encode_query_results::<mir_const_qualif<'_>, _>(tcx, enc, qri)?;\n-                encode_query_results::<def_symbol_name<'_>, _>(tcx, enc, qri)?;\n                 encode_query_results::<const_is_rvalue_promotable_to_static<'_>, _>(tcx, enc, qri)?;\n                 encode_query_results::<symbol_name<'_>, _>(tcx, enc, qri)?;\n                 encode_query_results::<check_match<'_>, _>(tcx, enc, qri)?;"}, {"sha": "973291d94acdd14092880a8b531e72b00e24e9d5", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -1217,7 +1217,7 @@ pub fn force_from_dep_node<'tcx>(\n         DepKind::Layout |\n         DepKind::ConstEval |\n         DepKind::ConstEvalRaw |\n-        DepKind::InstanceSymbolName |\n+        DepKind::SymbolName |\n         DepKind::MirShim |\n         DepKind::BorrowCheckKrate |\n         DepKind::Specializes |\n@@ -1304,7 +1304,6 @@ pub fn force_from_dep_node<'tcx>(\n         DepKind::TypeckTables => { force!(typeck_tables_of, def_id!()); }\n         DepKind::UsedTraitImports => { force!(used_trait_imports, def_id!()); }\n         DepKind::HasTypeckTables => { force!(has_typeck_tables, def_id!()); }\n-        DepKind::SymbolName => { force!(def_symbol_name, def_id!()); }\n         DepKind::SpecializationGraph => { force!(specialization_graph_of, def_id!()); }\n         DepKind::ObjectSafety => { force!(is_object_safe, def_id!()); }\n         DepKind::TraitImpls => { force!(trait_impls_of, def_id!()); }\n@@ -1486,7 +1485,6 @@ impl_load_from_cache!(\n     BorrowCheck => borrowck,\n     MirBorrowCheck => mir_borrowck,\n     mir_const_qualif => mir_const_qualif,\n-    SymbolName => def_symbol_name,\n     ConstIsRvaluePromotableToStatic => const_is_rvalue_promotable_to_static,\n     CheckMatch => check_match,\n     type_of => type_of,"}, {"sha": "e50839cd5983c74853ff02e8f82b7d1deec5b58a", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -189,6 +189,17 @@ impl TypeMap<'ll, 'tcx> {\n         let interner_key = self.unique_id_interner.intern(&enum_variant_type_id);\n         UniqueTypeId(interner_key)\n     }\n+\n+    // Get the unique type id string for an enum variant part.\n+    // Variant parts are not types and shouldn't really have their own id,\n+    // but it makes set_members_of_composite_type() simpler.\n+    fn get_unique_type_id_str_of_enum_variant_part<'a>(&mut self,\n+                                                       enum_type_id: UniqueTypeId) -> &str {\n+        let variant_part_type_id = format!(\"{}_variant_part\",\n+                                           self.get_unique_type_id_as_string(enum_type_id));\n+        let interner_key = self.unique_id_interner.intern(&variant_part_type_id);\n+        self.unique_id_interner.get(interner_key)\n+    }\n }\n \n // A description of some recursive type. It can either be already finished (as\n@@ -1689,6 +1700,11 @@ fn prepare_enum_metadata(\n         },\n     };\n \n+    let variant_part_unique_type_id_str = SmallCStr::new(\n+        debug_context(cx).type_map\n+            .borrow_mut()\n+            .get_unique_type_id_str_of_enum_variant_part(unique_type_id)\n+    );\n     let empty_array = create_DIArray(DIB(cx), &[]);\n     let variant_part = unsafe {\n         llvm::LLVMRustDIBuilderCreateVariantPart(\n@@ -1702,7 +1718,7 @@ fn prepare_enum_metadata(\n             DIFlags::FlagZero,\n             discriminator_metadata,\n             empty_array,\n-            unique_type_id_str.as_ptr())\n+            variant_part_unique_type_id_str.as_ptr())\n     };\n \n     // The variant part must be wrapped in a struct according to DWARF."}, {"sha": "d50a9a1607b240da1f7c3b2fceb125c3e2148162", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 15, "deletions": 38, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -101,7 +101,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_mir::monomorphize::item::{InstantiationMode, MonoItem, MonoItemExt};\n use rustc_mir::monomorphize::Instance;\n \n-use syntax_pos::symbol::Symbol;\n+use syntax_pos::symbol::{Symbol, InternedString};\n \n use log::debug;\n \n@@ -110,7 +110,6 @@ use std::mem::{self, discriminant};\n \n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n-        def_symbol_name,\n         symbol_name,\n \n         ..*providers\n@@ -222,21 +221,13 @@ fn get_symbol_hash<'a, 'tcx>(\n     hasher.finish()\n }\n \n-fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n-    SymbolPrinter {\n-        tcx,\n-        path: SymbolPath::new(),\n-        keep_within_component: false,\n-    }.print_def_path(def_id, &[]).unwrap().path.into_interned()\n-}\n-\n-fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n+fn symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n     ty::SymbolName {\n-        name: Symbol::intern(&compute_symbol_name(tcx, instance)).as_interned_str(),\n+        name: compute_symbol_name(tcx, instance),\n     }\n }\n \n-fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> String {\n+fn compute_symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) -> InternedString {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n@@ -247,11 +238,13 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     if def_id.is_local() {\n         if tcx.plugin_registrar_fn(LOCAL_CRATE) == Some(def_id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n-            return tcx.sess.generate_plugin_registrar_symbol(disambiguator);\n+            return Symbol::intern(&tcx.sess.generate_plugin_registrar_symbol(disambiguator))\n+                .as_interned_str();\n         }\n         if tcx.proc_macro_decls_static(LOCAL_CRATE) == Some(def_id) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n-            return tcx.sess.generate_proc_macro_decls_symbol(disambiguator);\n+            return Symbol::intern(&tcx.sess.generate_proc_macro_decls_symbol(disambiguator))\n+                .as_interned_str();\n         }\n     }\n \n@@ -268,20 +261,20 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     let attrs = tcx.codegen_fn_attrs(def_id);\n     if is_foreign {\n         if let Some(name) = attrs.link_name {\n-            return name.to_string();\n+            return name.as_interned_str();\n         }\n         // Don't mangle foreign items.\n-        return tcx.item_name(def_id).to_string();\n+        return tcx.item_name(def_id);\n     }\n \n     if let Some(name) = &attrs.export_name {\n         // Use provided name\n-        return name.to_string();\n+        return name.as_interned_str();\n     }\n \n     if attrs.flags.contains(CodegenFnAttrFlags::NO_MANGLE) {\n         // Don't mangle\n-        return tcx.item_name(def_id).to_string();\n+        return tcx.item_name(def_id);\n     }\n \n     // We want to compute the \"type\" of this item. Unfortunately, some\n@@ -321,15 +314,15 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n \n     let mut printer = SymbolPrinter {\n         tcx,\n-        path: SymbolPath::from_interned(tcx.def_symbol_name(def_id)),\n+        path: SymbolPath::new(),\n         keep_within_component: false,\n-    };\n+    }.print_def_path(def_id, &[]).unwrap();\n \n     if instance.is_vtable_shim() {\n         let _ = printer.write_str(\"{{vtable-shim}}\");\n     }\n \n-    printer.path.finish(hash)\n+    Symbol::intern(&printer.path.finish(hash)).as_interned_str()\n }\n \n // Follow C++ namespace-mangling style, see\n@@ -361,22 +354,6 @@ impl SymbolPath {\n         result\n     }\n \n-    fn from_interned(symbol: ty::SymbolName) -> Self {\n-        let mut result = SymbolPath {\n-            result: String::with_capacity(64),\n-            temp_buf: String::with_capacity(16),\n-        };\n-        result.result.push_str(&symbol.as_str());\n-        result\n-    }\n-\n-    fn into_interned(mut self) -> ty::SymbolName {\n-        self.finalize_pending_component();\n-        ty::SymbolName {\n-            name: Symbol::intern(&self.result).as_interned_str(),\n-        }\n-    }\n-\n     fn finalize_pending_component(&mut self) {\n         if !self.temp_buf.is_empty() {\n             let _ = write!(self.result, \"{}{}\", self.temp_buf.len(), self.temp_buf);"}, {"sha": "1fae931e9f1fd531d35fa949820aac1df32001ac", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -1619,14 +1619,16 @@ impl LintPass for KeywordIdents {\n     }\n }\n \n+struct UnderMacro(bool);\n+\n impl KeywordIdents {\n     fn check_tokens(&mut self, cx: &EarlyContext<'_>, tokens: TokenStream) {\n         for tt in tokens.into_trees() {\n             match tt {\n                 TokenTree::Token(span, tok) => match tok.ident() {\n                     // only report non-raw idents\n                     Some((ident, false)) => {\n-                        self.check_ident(cx, ast::Ident {\n+                        self.check_ident_token(cx, UnderMacro(true), ast::Ident {\n                             span: span.substitute_dummy(ident.span),\n                             ..ident\n                         });\n@@ -1639,16 +1641,12 @@ impl KeywordIdents {\n             }\n         }\n     }\n-}\n \n-impl EarlyLintPass for KeywordIdents {\n-    fn check_mac_def(&mut self, cx: &EarlyContext<'_>, mac_def: &ast::MacroDef, _id: ast::NodeId) {\n-        self.check_tokens(cx, mac_def.stream());\n-    }\n-    fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::Mac) {\n-        self.check_tokens(cx, mac.node.tts.clone().into());\n-    }\n-    fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: ast::Ident) {\n+    fn check_ident_token(&mut self,\n+                         cx: &EarlyContext<'_>,\n+                         UnderMacro(under_macro): UnderMacro,\n+                         ident: ast::Ident)\n+    {\n         let ident_str = &ident.as_str()[..];\n         let cur_edition = cx.sess.edition();\n         let is_raw_ident = |ident: ast::Ident| {\n@@ -1657,7 +1655,22 @@ impl EarlyLintPass for KeywordIdents {\n         let next_edition = match cur_edition {\n             Edition::Edition2015 => {\n                 match ident_str {\n-                    \"async\" | \"try\" | \"dyn\" => Edition::Edition2018,\n+                    \"async\" | \"try\" => Edition::Edition2018,\n+\n+                    // rust-lang/rust#56327: Conservatively do not\n+                    // attempt to report occurrences of `dyn` within\n+                    // macro definitions or invocations, because `dyn`\n+                    // can legitimately occur as a contextual keyword\n+                    // in 2015 code denoting its 2018 meaning, and we\n+                    // do not want rustfix to inject bugs into working\n+                    // code by rewriting such occurrences.\n+                    //\n+                    // But if we see `dyn` outside of a macro, we know\n+                    // its precise role in the parsed AST and thus are\n+                    // assured this is truly an attempt to use it as\n+                    // an identifier.\n+                    \"dyn\" if !under_macro => Edition::Edition2018,\n+\n                     // Only issue warnings for `await` if the `async_await`\n                     // feature isn't being used. Otherwise, users need\n                     // to keep using `await` for the macro exposed by std.\n@@ -1715,6 +1728,18 @@ impl EarlyLintPass for KeywordIdents {\n     }\n }\n \n+impl EarlyLintPass for KeywordIdents {\n+    fn check_mac_def(&mut self, cx: &EarlyContext<'_>, mac_def: &ast::MacroDef, _id: ast::NodeId) {\n+        self.check_tokens(cx, mac_def.stream());\n+    }\n+    fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::Mac) {\n+        self.check_tokens(cx, mac.node.tts.clone().into());\n+    }\n+    fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: ast::Ident) {\n+        self.check_ident_token(cx, UnderMacro(false), ident);\n+    }\n+}\n+\n \n pub struct ExplicitOutlivesRequirements;\n "}, {"sha": "54fc63f30571ead77b8079a46b8fae9a3efd046a", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -138,7 +138,7 @@ fn check_lang_item_type<'a, 'tcx, D>(\n     let place_ty = place.ty(local_decls, tcx).to_ty(tcx);\n     let expected = [lhs_ty, rhs_ty, place_ty];\n     assert_eq!(sig.inputs_and_output[..], expected,\n-        \"lang item {}\", tcx.def_symbol_name(did));\n+        \"lang item `{}`\", tcx.def_path_str(did));\n     did\n }\n "}, {"sha": "27ffe4583df252ef27ecd3f178a98bd860701206", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -1769,9 +1769,13 @@ fn get_real_types(\n     generics: &Generics,\n     arg: &Type,\n     cx: &DocContext<'_>,\n+    recurse: i32,\n ) -> FxHashSet<Type> {\n     let arg_s = arg.to_string();\n     let mut res = FxHashSet::default();\n+    if recurse >= 10 { // FIXME: remove this whole recurse thing when the recursion bug is fixed\n+        return res;\n+    }\n     if arg.is_full_generic() {\n         if let Some(where_pred) = generics.where_predicates.iter().find(|g| {\n             match g {\n@@ -1788,7 +1792,7 @@ fn get_real_types(\n                                 continue\n                             }\n                             if let Some(ty) = x.get_type(cx) {\n-                                let adds = get_real_types(generics, &ty, cx);\n+                                let adds = get_real_types(generics, &ty, cx, recurse + 1);\n                                 if !adds.is_empty() {\n                                     res.extend(adds);\n                                 } else if !ty.is_full_generic() {\n@@ -1806,7 +1810,7 @@ fn get_real_types(\n         }) {\n             for bound in bound.get_bounds().unwrap_or_else(|| &[]) {\n                 if let Some(ty) = bound.get_trait_type() {\n-                    let adds = get_real_types(generics, &ty, cx);\n+                    let adds = get_real_types(generics, &ty, cx, recurse + 1);\n                     if !adds.is_empty() {\n                         res.extend(adds);\n                     } else if !ty.is_full_generic() {\n@@ -1820,7 +1824,7 @@ fn get_real_types(\n         if let Some(gens) = arg.generics() {\n             for gen in gens.iter() {\n                 if gen.is_full_generic() {\n-                    let adds = get_real_types(generics, gen, cx);\n+                    let adds = get_real_types(generics, gen, cx, recurse + 1);\n                     if !adds.is_empty() {\n                         res.extend(adds);\n                     }\n@@ -1847,7 +1851,7 @@ pub fn get_all_types(\n         if arg.type_.is_self_type() {\n             continue;\n         }\n-        let args = get_real_types(generics, &arg.type_, cx);\n+        let args = get_real_types(generics, &arg.type_, cx, 0);\n         if !args.is_empty() {\n             all_types.extend(args);\n         } else {\n@@ -1857,7 +1861,7 @@ pub fn get_all_types(\n \n     let ret_types = match decl.output {\n         FunctionRetTy::Return(ref return_type) => {\n-            let mut ret = get_real_types(generics, &return_type, cx);\n+            let mut ret = get_real_types(generics, &return_type, cx, 0);\n             if ret.is_empty() {\n                 ret.insert(return_type.clone());\n             }"}, {"sha": "7f15ed90e67b37b64d752353dd7e6802a58b3d73", "filename": "src/test/debuginfo/enum-thinlto.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fdebuginfo%2Fenum-thinlto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fdebuginfo%2Fenum-thinlto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fenum-thinlto.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -0,0 +1,48 @@\n+// ignore-tidy-linelength\n+\n+// Require LLVM with DW_TAG_variant_part and a gdb that can read it.\n+// min-system-llvm-version: 8.0\n+// min-gdb-version: 8.2\n+\n+// compile-flags:-g -Z thinlto\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+\n+// gdb-command:print *abc\n+// gdbr-check:$1 = enum_thinlto::ABC::TheA{x: 0, y: 8970181431921507452}\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+\n+// lldb-command:print *abc\n+// lldbg-check:(enum_thinlto::ABC) $0 = ABC { }\n+\n+#![allow(unused_variables)]\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+#[derive(Debug)]\n+enum ABC {\n+    TheA { x: i64, y: i64 },\n+    TheB (i64, i32, i32),\n+}\n+\n+fn main() {\n+    let abc = ABC::TheA { x: 0, y: 0x7c7c_7c7c_7c7c_7c7c };\n+\n+    f(&abc);\n+}\n+\n+fn f(abc: &ABC) {\n+    zzz(); // #break\n+\n+    println!(\"{:?}\", abc);\n+}\n+\n+fn zzz() {()}"}, {"sha": "003736208ed38e818974558a932cd1732e19d4df", "filename": "src/test/ui/dyn-keyword/dyn-2015-edition-keyword-ident-lint.fixed", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-edition-keyword-ident-lint.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-edition-keyword-ident-lint.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-edition-keyword-ident-lint.fixed?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -0,0 +1,81 @@\n+// Under the 2015 edition with the keyword_idents lint, `dyn` is not\n+// entirely acceptable as an identifier. We currently do not attempt\n+// to detect or fix uses of `dyn` under a macro. Since we are testing\n+// this file via `rustfix`, we want the rustfix output to be\n+// compilable; so the macros here carefully use `dyn` \"correctly.\"\n+\n+// run-rustfix\n+\n+#![allow(non_camel_case_types)]\n+#![deny(keyword_idents)]\n+\n+mod outer_mod {\n+    pub mod r#dyn {\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+        pub struct r#dyn;\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+    }\n+}\n+use outer_mod::r#dyn::r#dyn;\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+//~| ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+\n+fn main() {\n+    match r#dyn { r#dyn => {} }\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+//~| ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+    macro_defn::r#dyn();\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+\n+    macro_defn::boxed();\n+}\n+\n+mod macro_defn {\n+    use super::Trait;\n+\n+    macro_rules! r#dyn {\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+\n+        // Note that we do not lint nor fix occurrences under macros\n+        ($dyn:tt) => { (Box<dyn Trait>, Box<$dyn Trait>) }\n+    }\n+\n+    pub fn r#dyn() -> ::outer_mod::r#dyn::r#dyn {\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+//~| ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+//~| ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+        ::outer_mod::r#dyn::r#dyn\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+//~| ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+    }\n+\n+\n+\n+    pub fn boxed() -> r#dyn!(\n+        //~^ ERROR `dyn` is a keyword\n+        //~| WARN was previously accepted\n+\n+            // Note that we do not lint nor fix occurrences under macros\n+            dyn\n+    )\n+    {\n+        (Box::new(1), Box::new(2))\n+    }\n+}\n+\n+pub trait Trait { }\n+\n+impl Trait for u32 { }"}, {"sha": "0e5c39fc501beecc166f4d5b9c1dfcad6f147919", "filename": "src/test/ui/dyn-keyword/dyn-2015-edition-keyword-ident-lint.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-edition-keyword-ident-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-edition-keyword-ident-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-edition-keyword-ident-lint.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -0,0 +1,81 @@\n+// Under the 2015 edition with the keyword_idents lint, `dyn` is not\n+// entirely acceptable as an identifier. We currently do not attempt\n+// to detect or fix uses of `dyn` under a macro. Since we are testing\n+// this file via `rustfix`, we want the rustfix output to be\n+// compilable; so the macros here carefully use `dyn` \"correctly.\"\n+\n+// run-rustfix\n+\n+#![allow(non_camel_case_types)]\n+#![deny(keyword_idents)]\n+\n+mod outer_mod {\n+    pub mod dyn {\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+        pub struct dyn;\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+    }\n+}\n+use outer_mod::dyn::dyn;\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+//~| ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+\n+fn main() {\n+    match dyn { dyn => {} }\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+//~| ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+    macro_defn::dyn();\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+\n+    macro_defn::boxed();\n+}\n+\n+mod macro_defn {\n+    use super::Trait;\n+\n+    macro_rules! dyn {\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+\n+        // Note that we do not lint nor fix occurrences under macros\n+        ($dyn:tt) => { (Box<dyn Trait>, Box<$dyn Trait>) }\n+    }\n+\n+    pub fn dyn() -> ::outer_mod::dyn::dyn {\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+//~| ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+//~| ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+        ::outer_mod::dyn::dyn\n+//~^ ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+//~| ERROR `dyn` is a keyword\n+//~| WARN was previously accepted\n+    }\n+\n+\n+\n+    pub fn boxed() -> dyn!(\n+        //~^ ERROR `dyn` is a keyword\n+        //~| WARN was previously accepted\n+\n+            // Note that we do not lint nor fix occurrences under macros\n+            dyn\n+    )\n+    {\n+        (Box::new(1), Box::new(2))\n+    }\n+}\n+\n+pub trait Trait { }\n+\n+impl Trait for u32 { }"}, {"sha": "361727733bc57243be5ff7b2b3c73747d6fb0490", "filename": "src/test/ui/dyn-keyword/dyn-2015-edition-keyword-ident-lint.stderr", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-edition-keyword-ident-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-edition-keyword-ident-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-edition-keyword-ident-lint.stderr?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -0,0 +1,133 @@\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:13:13\n+   |\n+LL |     pub mod dyn {\n+   |             ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+note: lint level defined here\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:10:9\n+   |\n+LL | #![deny(keyword_idents)]\n+   |         ^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:16:20\n+   |\n+LL |         pub struct dyn;\n+   |                    ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:21:16\n+   |\n+LL | use outer_mod::dyn::dyn;\n+   |                ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:21:21\n+   |\n+LL | use outer_mod::dyn::dyn;\n+   |                     ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:28:11\n+   |\n+LL |     match dyn { dyn => {} }\n+   |           ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:28:17\n+   |\n+LL |     match dyn { dyn => {} }\n+   |                 ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:33:17\n+   |\n+LL |     macro_defn::dyn();\n+   |                 ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:43:18\n+   |\n+LL |     macro_rules! dyn {\n+   |                  ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:51:12\n+   |\n+LL |     pub fn dyn() -> ::outer_mod::dyn::dyn {\n+   |            ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:51:34\n+   |\n+LL |     pub fn dyn() -> ::outer_mod::dyn::dyn {\n+   |                                  ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:51:39\n+   |\n+LL |     pub fn dyn() -> ::outer_mod::dyn::dyn {\n+   |                                       ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:58:22\n+   |\n+LL |         ::outer_mod::dyn::dyn\n+   |                      ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:58:27\n+   |\n+LL |         ::outer_mod::dyn::dyn\n+   |                           ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `dyn` is a keyword in the 2018 edition\n+  --> $DIR/dyn-2015-edition-keyword-ident-lint.rs:67:23\n+   |\n+LL |     pub fn boxed() -> dyn!(\n+   |                       ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: aborting due to 14 previous errors\n+"}, {"sha": "f535791d7fbe498ea1c8f18c8ce5019b5b0d9983", "filename": "src/test/ui/dyn-keyword/dyn-2015-idents-in-decl-macros-unlinted.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-idents-in-decl-macros-unlinted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-idents-in-decl-macros-unlinted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-idents-in-decl-macros-unlinted.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -0,0 +1,51 @@\n+// compile-pass\n+\n+// Under the 2015 edition with the keyword_idents lint, `dyn` is\n+// not entirely acceptable as an identifier.\n+//\n+// We currently do not attempt to detect or fix uses of `dyn` as an\n+// identifier under a macro, including under the declarative `macro`\n+// forms from macros 1.2 and macros 2.0.\n+\n+#![feature(decl_macro)]\n+#![allow(non_camel_case_types)]\n+#![deny(keyword_idents)]\n+\n+mod outer_mod {\n+    pub mod r#dyn {\n+        pub struct r#dyn;\n+    }\n+}\n+\n+// Here we are illustrating that the current lint does not flag the\n+// occurrences of `dyn` in this macro definition; however, it\n+// certainly *could* (and it would be nice if it did), since these\n+// occurrences are not compatible with the 2018 edition's\n+// interpretation of `dyn` as a keyword.\n+macro defn_has_dyn_idents() { ::outer_mod::dyn::dyn }\n+\n+struct X;\n+trait Trait { fn hello(&self) { }}\n+impl Trait for X { }\n+\n+macro tt_trait($arg:tt) { & $arg Trait }\n+macro id_trait($id:ident) { & $id Trait }\n+\n+fn main() {\n+    defn_has_dyn_idents!();\n+\n+    // Here we are illustrating that the current lint does not flag\n+    // the occurrences of `dyn` in these macro invocations. It\n+    // definitely should *not* flag the one in `tt_trait`, since that\n+    // is expanding in a valid fashion to `&dyn Trait`.\n+    //\n+    // It is arguable whether it would be valid to flag the occurrence\n+    // in `id_trait`, since that macro specifies that it takes an\n+    // `ident` as its input.\n+    fn f_tt(x: &X) -> tt_trait!(dyn) { x }\n+    fn f_id(x: &X) -> id_trait!(dyn) { x }\n+\n+    let x = X;\n+    f_tt(&x).hello();\n+    f_id(&x).hello();\n+}"}, {"sha": "27e490558689fe7fdc3ef18ff3063e7d4e5e1d9d", "filename": "src/test/ui/dyn-keyword/dyn-2015-idents-in-macros-unlinted.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-idents-in-macros-unlinted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-idents-in-macros-unlinted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-idents-in-macros-unlinted.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -0,0 +1,56 @@\n+// compile-pass\n+\n+// Under the 2015 edition with the keyword_idents lint, `dyn` is\n+// not entirely acceptable as an identifier.\n+//\n+// We currently do not attempt to detect or fix uses of `dyn` as an\n+// identifier under a macro.\n+\n+#![allow(non_camel_case_types)]\n+#![deny(keyword_idents)]\n+\n+mod outer_mod {\n+    pub mod r#dyn {\n+        pub struct r#dyn;\n+    }\n+}\n+\n+// Here we are illustrating that the current lint does not flag the\n+// occurrences of `dyn` in this macro definition; however, it\n+// certainly *could* (and it would be nice if it did), since these\n+// occurrences are not compatible with the 2018 edition's\n+// interpretation of `dyn` as a keyword.\n+macro_rules! defn_has_dyn_idents {\n+    () => { ::outer_mod::dyn::dyn }\n+}\n+\n+struct X;\n+trait Trait { fn hello(&self) { }}\n+impl Trait for X { }\n+\n+macro_rules! tt_trait {\n+    ($arg:tt) => { & $arg Trait }\n+}\n+\n+macro_rules! id_trait {\n+    ($id:ident) => { & $id Trait }\n+}\n+\n+fn main() {\n+    defn_has_dyn_idents!();\n+\n+    // Here we are illustrating that the current lint does not flag\n+    // the occurrences of `dyn` in these macro invocations. It\n+    // definitely should *not* flag the one in `tt_trait`, since that\n+    // is expanding in a valid fashion to `&dyn Trait`.\n+    //\n+    // It is arguable whether it would be valid to flag the occurrence\n+    // in `id_trait`, since that macro specifies that it takes an\n+    // `ident` as its input.\n+    fn f_tt(x: &X) -> tt_trait!(dyn) { x }\n+    fn f_id(x: &X) -> id_trait!(dyn) { x }\n+\n+    let x = X;\n+    f_tt(&x).hello();\n+    f_id(&x).hello();\n+}"}, {"sha": "8cef5c2b349471d9a72247666ad5e8d002678575", "filename": "src/test/ui/dyn-keyword/dyn-2015-no-warnings-without-lints.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-no-warnings-without-lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-no-warnings-without-lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-keyword%2Fdyn-2015-no-warnings-without-lints.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -0,0 +1,27 @@\n+// Under the 2015 edition without the keyword_idents lint, `dyn` is\n+// entirely acceptable as an identifier.\n+\n+// compile-pass\n+\n+#![allow(non_camel_case_types)]\n+\n+mod outer_mod {\n+    pub mod dyn {\n+        pub struct dyn;\n+    }\n+}\n+use outer_mod::dyn::dyn;\n+\n+fn main() {\n+    match dyn { dyn => {} }\n+    macro_defn::dyn();\n+}\n+mod macro_defn {\n+    macro_rules! dyn {\n+        () => { ::outer_mod::dyn::dyn }\n+    }\n+\n+    pub fn dyn() -> ::outer_mod::dyn::dyn {\n+        dyn!()\n+    }\n+}"}, {"sha": "ff3830d61755adb964085d27cb868fb4d0cc150a", "filename": "src/test/ui/dyn-keyword/issue-56327-dyn-trait-in-macro-is-okay.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fui%2Fdyn-keyword%2Fissue-56327-dyn-trait-in-macro-is-okay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftest%2Fui%2Fdyn-keyword%2Fissue-56327-dyn-trait-in-macro-is-okay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-keyword%2Fissue-56327-dyn-trait-in-macro-is-okay.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -0,0 +1,25 @@\n+// compile-pass\n+\n+// rust-lang/rust#56327: Some occurrences of `dyn` within a macro are\n+// not instances of identifiers, and thus should *not* be caught by the\n+// keyword_ident lint.\n+//\n+// Otherwise, rustfix replaces the type `Box<dyn Drop>` with\n+// `Box<r#dyn Drop>`, which is injecting a bug rather than fixing\n+// anything.\n+\n+#![deny(rust_2018_compatibility)]\n+\n+macro_rules! foo {\n+    () => {\n+        fn generated_foo() {\n+            let _x: Box<dyn Drop>;\n+        }\n+    }\n+}\n+\n+foo!();\n+\n+fn main() {\n+    generated_foo();\n+}"}, {"sha": "0611e53d0927c95a637df0b6cf5be6b5c29b494b", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8581d7420b63b2cc5eac1c57a40de785859448/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=fc8581d7420b63b2cc5eac1c57a40de785859448", "patch": "@@ -523,12 +523,18 @@ impl Builder {\n                pkgname: &str,\n                dst: &mut BTreeMap<String, Package>,\n                targets: &[&str]) {\n-        let (version, is_present) = self.cached_version(pkgname)\n+        let (version, mut is_present) = self.cached_version(pkgname)\n             .as_ref()\n             .cloned()\n             .map(|version| (version, true))\n             .unwrap_or_default();\n \n+        // miri needs to build std with xargo, which doesn't allow stable/beta:\n+        // <https://github.com/japaric/xargo/pull/204#issuecomment-374888868>\n+        if pkgname == \"miri-preview\" && self.rust_release != \"nightly\" {\n+            is_present = false; // ignore it\n+        }\n+\n         let targets = targets.iter().map(|name| {\n             if is_present {\n                 let filename = self.filename(pkgname, name);"}]}