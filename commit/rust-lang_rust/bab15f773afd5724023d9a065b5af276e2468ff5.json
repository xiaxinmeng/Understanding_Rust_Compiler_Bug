{"sha": "bab15f773afd5724023d9a065b5af276e2468ff5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYjE1Zjc3M2FmZDU3MjQwMjNkOWEwNjViNWFmMjc2ZTI0NjhmZjU=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-24T15:45:50Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-24T16:18:48Z"}, "message": "Remove std::io::lazy::Lazy in favour of SyncOnceCell\n\nThe (internal) std::io::lazy::Lazy was used to lazily initialize the\nstdout and stdin buffers (and mutexes). It uses atexit() to register a\ndestructor to flush the streams on exit, and mark the streams as\n'closed'. Using the stream afterwards would result in a panic.\n\nStdout uses a LineWriter which contains a BufWriter that will flush the\nbuffer on drop. This one is important to be executed during shutdown,\nto make sure no buffered output is lost. It also forbids access to\nstdout afterwards, since the buffer is already flushed and gone.\n\nStdin uses a BufReader, which does not implement Drop. It simply forgets\nany previously read data that was not read from the buffer yet. This\nmeans that in the case of stdin, the atexit() function's only effect is\nmaking stdin inaccessible to the program, such that later accesses\nresult in a panic. This is uncessary, as it'd have been safe to access\nstdin during shutdown of the program.\n\n---\n\nThis change removes the entire io::lazy module in favour of\nSyncOnceCell. SyncOnceCell's fast path is much faster (a single atomic\noperation) than locking a sys_common::Mutex on every access like Lazy\ndid.\n\nHowever, SyncOnceCell does not use atexit() to drop the contained object\nduring shutdown.\n\nAs noted above, this is not a problem for stdin. It simply means stdin\nis now usable during shutdown.\n\nThe atexit() call for stdout is moved to the stdio module. Unlike the\nnow-removed Lazy struct, SyncOnceCell does not have a 'gone and\nunusable' state that panics. Instead of adding this again, this simply\nreplaces the buffer with one with zero capacity. This effectively\nflushes the old buffer *and* makes any writes afterwards pass through\ndirectly without touching a buffer, making print!() available during\nshutdown without panicking.", "tree": {"sha": "16a5dc00cdd0272d64358e850d0857ebf2c9f2ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16a5dc00cdd0272d64358e850d0857ebf2c9f2ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bab15f773afd5724023d9a065b5af276e2468ff5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bab15f773afd5724023d9a065b5af276e2468ff5", "html_url": "https://github.com/rust-lang/rust/commit/bab15f773afd5724023d9a065b5af276e2468ff5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bab15f773afd5724023d9a065b5af276e2468ff5/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4eff9b0b29a8898c839d46f3c66526710afed68a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eff9b0b29a8898c839d46f3c66526710afed68a", "html_url": "https://github.com/rust-lang/rust/commit/4eff9b0b29a8898c839d46f3c66526710afed68a"}], "stats": {"total": 138, "additions": 40, "deletions": 98}, "files": [{"sha": "1968d498bbed4c588bd7e6dd2ad3acf83177920e", "filename": "library/std/src/io/lazy.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Fstd%2Fsrc%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eff9b0b29a8898c839d46f3c66526710afed68a/library%2Fstd%2Fsrc%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Flazy.rs?ref=4eff9b0b29a8898c839d46f3c66526710afed68a", "patch": "@@ -1,63 +0,0 @@\n-use crate::cell::Cell;\n-use crate::ptr;\n-use crate::sync::Arc;\n-use crate::sys_common;\n-use crate::sys_common::mutex::Mutex;\n-\n-pub struct Lazy<T> {\n-    // We never call `lock.init()`, so it is UB to attempt to acquire this mutex reentrantly!\n-    lock: Mutex,\n-    ptr: Cell<*mut Arc<T>>,\n-}\n-\n-#[inline]\n-const fn done<T>() -> *mut Arc<T> {\n-    1_usize as *mut _\n-}\n-\n-unsafe impl<T> Sync for Lazy<T> {}\n-\n-impl<T> Lazy<T> {\n-    pub const fn new() -> Lazy<T> {\n-        Lazy { lock: Mutex::new(), ptr: Cell::new(ptr::null_mut()) }\n-    }\n-}\n-\n-impl<T: Send + Sync + 'static> Lazy<T> {\n-    /// Safety: `init` must not call `get` on the variable that is being\n-    /// initialized.\n-    pub unsafe fn get(&'static self, init: fn() -> Arc<T>) -> Option<Arc<T>> {\n-        let _guard = self.lock.lock();\n-        let ptr = self.ptr.get();\n-        if ptr.is_null() {\n-            Some(self.init(init))\n-        } else if ptr == done() {\n-            None\n-        } else {\n-            Some((*ptr).clone())\n-        }\n-    }\n-\n-    // Must only be called with `lock` held\n-    unsafe fn init(&'static self, init: fn() -> Arc<T>) -> Arc<T> {\n-        // If we successfully register an at exit handler, then we cache the\n-        // `Arc` allocation in our own internal box (it will get deallocated by\n-        // the at exit handler). Otherwise we just return the freshly allocated\n-        // `Arc`.\n-        let registered = sys_common::at_exit(move || {\n-            let ptr = {\n-                let _guard = self.lock.lock();\n-                self.ptr.replace(done())\n-            };\n-            drop(Box::from_raw(ptr))\n-        });\n-        // This could reentrantly call `init` again, which is a problem\n-        // because our `lock` allows reentrancy!\n-        // That's why `get` is unsafe and requires the caller to ensure no reentrancy happens.\n-        let ret = init();\n-        if registered.is_ok() {\n-            self.ptr.set(Box::into_raw(Box::new(ret.clone())));\n-        }\n-        ret\n-    }\n-}"}, {"sha": "d9d0380781925a85b4ed954e98bda58348009242", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bab15f773afd5724023d9a065b5af276e2468ff5/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15f773afd5724023d9a065b5af276e2468ff5/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=bab15f773afd5724023d9a065b5af276e2468ff5", "patch": "@@ -285,7 +285,6 @@ mod buffered;\n mod cursor;\n mod error;\n mod impls;\n-mod lazy;\n pub mod prelude;\n mod stdio;\n mod util;"}, {"sha": "e0e5ccd062533df6e59082a4982e644318ef8e08", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/bab15f773afd5724023d9a065b5af276e2468ff5/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab15f773afd5724023d9a065b5af276e2468ff5/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=bab15f773afd5724023d9a065b5af276e2468ff5", "patch": "@@ -7,10 +7,11 @@ use crate::io::prelude::*;\n \n use crate::cell::RefCell;\n use crate::fmt;\n-use crate::io::lazy::Lazy;\n use crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter};\n-use crate::sync::{Arc, Mutex, MutexGuard, Once};\n+use crate::lazy::SyncOnceCell;\n+use crate::sync::{Arc, Mutex, MutexGuard};\n use crate::sys::stdio;\n+use crate::sys_common;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use crate::thread::LocalKey;\n \n@@ -292,15 +293,13 @@ pub struct StdinLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdin() -> Stdin {\n-    static INSTANCE: Lazy<Mutex<BufReader<StdinRaw>>> = Lazy::new();\n-    return Stdin {\n-        inner: unsafe { INSTANCE.get(stdin_init).expect(\"cannot access stdin during shutdown\") },\n-    };\n-\n-    fn stdin_init() -> Arc<Mutex<BufReader<StdinRaw>>> {\n-        // This must not reentrantly access `INSTANCE`\n-        let stdin = stdin_raw();\n-        Arc::new(Mutex::new(BufReader::with_capacity(stdio::STDIN_BUF_SIZE, stdin)))\n+    static INSTANCE: SyncOnceCell<Arc<Mutex<BufReader<StdinRaw>>>> = SyncOnceCell::new();\n+    Stdin {\n+        inner: INSTANCE\n+            .get_or_init(|| {\n+                Arc::new(Mutex::new(BufReader::with_capacity(stdio::STDIN_BUF_SIZE, stdin_raw())))\n+            })\n+            .clone(),\n     }\n }\n \n@@ -534,19 +533,27 @@ pub struct StdoutLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdout() -> Stdout {\n-    static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = Lazy::new();\n-    return Stdout {\n-        inner: unsafe { INSTANCE.get(stdout_init).expect(\"cannot access stdout during shutdown\") },\n-    };\n-\n-    fn stdout_init() -> Arc<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> {\n-        // This must not reentrantly access `INSTANCE`\n-        let stdout = stdout_raw();\n-        unsafe {\n-            let ret = Arc::new(ReentrantMutex::new(RefCell::new(LineWriter::new(stdout))));\n-            ret.init();\n-            ret\n-        }\n+    static INSTANCE: SyncOnceCell<Arc<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>>> =\n+        SyncOnceCell::new();\n+    Stdout {\n+        inner: INSTANCE\n+            .get_or_init(|| unsafe {\n+                let _ = sys_common::at_exit(|| {\n+                    if let Some(instance) = INSTANCE.get() {\n+                        // Flush the data and disable buffering during shutdown\n+                        // by replacing the line writer by one with zero\n+                        // buffering capacity.\n+                        // We use try_lock() instead of lock(), because someone\n+                        // might have leaked a StdoutLock, which would\n+                        // otherwise cause a deadlock here.\n+                        if let Some(lock) = instance.try_lock() {\n+                            *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n+                        }\n+                    }\n+                });\n+                Arc::new(ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw()))))\n+            })\n+            .clone(),\n     }\n }\n \n@@ -714,16 +721,15 @@ pub fn stderr() -> Stderr {\n     //\n     // This has the added benefit of allowing `stderr` to be usable during\n     // process shutdown as well!\n-    static INSTANCE: ReentrantMutex<RefCell<StderrRaw>> =\n-        unsafe { ReentrantMutex::new(RefCell::new(stderr_raw())) };\n-\n-    // When accessing stderr we need one-time initialization of the reentrant\n-    // mutex. Afterwards we can just always use the now-filled-in `INSTANCE` value.\n-    static INIT: Once = Once::new();\n-    INIT.call_once(|| unsafe {\n-        INSTANCE.init();\n-    });\n-    Stderr { inner: &INSTANCE }\n+    static INSTANCE: SyncOnceCell<ReentrantMutex<RefCell<StderrRaw>>> = SyncOnceCell::new();\n+\n+    Stderr {\n+        inner: INSTANCE.get_or_init(|| unsafe {\n+            let r = ReentrantMutex::new(RefCell::new(stderr_raw()));\n+            r.init();\n+            r\n+        }),\n+    }\n }\n \n impl Stderr {"}]}