{"sha": "b2d021aa2b7c701406c10a3110dd31f990368c97", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZDAyMWFhMmI3YzcwMTQwNmMxMGEzMTEwZGQzMWY5OTAzNjhjOTc=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-10-22T21:30:31Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-10-26T03:56:56Z"}, "message": "Make `check_consts::Item` work on non-const fns\n\nThis was originally only needed for validation, which is never run on\nnon-const `fn`s. The new promotion pass wants to use it, however.", "tree": {"sha": "81b4bb0a966b00743d73b2260c80879ff9b7699f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81b4bb0a966b00743d73b2260c80879ff9b7699f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2d021aa2b7c701406c10a3110dd31f990368c97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2d021aa2b7c701406c10a3110dd31f990368c97", "html_url": "https://github.com/rust-lang/rust/commit/b2d021aa2b7c701406c10a3110dd31f990368c97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2d021aa2b7c701406c10a3110dd31f990368c97/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "084edc426f2e7e4bbedb5c6afa7fc422a52ee379", "url": "https://api.github.com/repos/rust-lang/rust/commits/084edc426f2e7e4bbedb5c6afa7fc422a52ee379", "html_url": "https://github.com/rust-lang/rust/commit/084edc426f2e7e4bbedb5c6afa7fc422a52ee379"}], "stats": {"total": 225, "additions": 105, "deletions": 120}, "files": [{"sha": "61496ebb4425f32efb6d595aa27fee279c2978ad", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 73, "deletions": 25, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b2d021aa2b7c701406c10a3110dd31f990368c97/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d021aa2b7c701406c10a3110dd31f990368c97/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=b2d021aa2b7c701406c10a3110dd31f990368c97", "patch": "@@ -4,26 +4,27 @@\n //! has interior mutability or needs to be dropped, as well as the visitor that emits errors when\n //! it finds operations that are invalid in a certain context.\n \n-use rustc::hir::def_id::DefId;\n+use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt};\n \n+use std::fmt;\n+\n pub use self::qualifs::Qualif;\n \n pub mod ops;\n pub mod qualifs;\n mod resolver;\n pub mod validation;\n \n-/// Information about the item currently being validated, as well as a reference to the global\n+/// Information about the item currently being const-checked, as well as a reference to the global\n /// context.\n pub struct Item<'mir, 'tcx> {\n     body: &'mir mir::Body<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    mode: validation::Mode,\n-    for_promotion: bool,\n+    const_kind: Option<ConstKind>,\n }\n \n impl Item<'mir, 'tcx> {\n@@ -33,41 +34,88 @@ impl Item<'mir, 'tcx> {\n         body: &'mir mir::Body<'tcx>,\n     ) -> Self {\n         let param_env = tcx.param_env(def_id);\n-        let mode = validation::Mode::for_item(tcx, def_id)\n-            .expect(\"const validation must only be run inside a const context\");\n+        let const_kind = ConstKind::for_item(tcx, def_id);\n \n         Item {\n             body,\n             tcx,\n             def_id,\n             param_env,\n-            mode,\n-            for_promotion: false,\n+            const_kind,\n         }\n     }\n \n-    // HACK(eddyb) this is to get around the panic for a runtime fn from `Item::new`.\n-    // Also, it allows promoting `&mut []`.\n-    pub fn for_promotion(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        body: &'mir mir::Body<'tcx>,\n-    ) -> Self {\n-        let param_env = tcx.param_env(def_id);\n-        let mode = validation::Mode::for_item(tcx, def_id)\n-            .unwrap_or(validation::Mode::ConstFn);\n+    /// Returns the kind of const context this `Item` represents (`const`, `static`, etc.).\n+    ///\n+    /// Panics if this `Item` is not const.\n+    pub fn const_kind(&self) -> ConstKind {\n+        self.const_kind.expect(\"`const_kind` must not be called on a non-const fn\")\n+    }\n+}\n \n-        Item {\n-            body,\n-            tcx,\n-            def_id,\n-            param_env,\n-            mode,\n-            for_promotion: true,\n+/// The kinds of items which require compile-time evaluation.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum ConstKind {\n+    /// A `static` item.\n+    Static,\n+    /// A `static mut` item.\n+    StaticMut,\n+    /// A `const fn` item.\n+    ConstFn,\n+    /// A `const` item or an anonymous constant (e.g. in array lengths).\n+    Const,\n+}\n+\n+impl ConstKind {\n+    /// Returns the validation mode for the item with the given `DefId`, or `None` if this item\n+    /// does not require validation (e.g. a non-const `fn`).\n+    pub fn for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<Self> {\n+        use hir::BodyOwnerKind as HirKind;\n+\n+        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+\n+        let mode = match tcx.hir().body_owner_kind(hir_id) {\n+            HirKind::Closure => return None,\n+\n+            HirKind::Fn if tcx.is_const_fn(def_id) => ConstKind::ConstFn,\n+            HirKind::Fn => return None,\n+\n+            HirKind::Const => ConstKind::Const,\n+\n+            HirKind::Static(hir::MutImmutable) => ConstKind::Static,\n+            HirKind::Static(hir::MutMutable) => ConstKind::StaticMut,\n+        };\n+\n+        Some(mode)\n+    }\n+\n+    pub fn is_static(self) -> bool {\n+        match self {\n+            ConstKind::Static | ConstKind::StaticMut => true,\n+            ConstKind::ConstFn | ConstKind::Const => false,\n+        }\n+    }\n+\n+    /// Returns `true` if the value returned by this item must be `Sync`.\n+    ///\n+    /// This returns false for `StaticMut` since all accesses to one are `unsafe` anyway.\n+    pub fn requires_sync(self) -> bool {\n+        match self {\n+            ConstKind::Static => true,\n+            ConstKind::ConstFn | ConstKind::Const |  ConstKind::StaticMut => false,\n         }\n     }\n }\n \n+impl fmt::Display for ConstKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ConstKind::Const => write!(f, \"constant\"),\n+            ConstKind::Static | ConstKind::StaticMut => write!(f, \"static\"),\n+            ConstKind::ConstFn => write!(f, \"constant function\"),\n+        }\n+    }\n+}\n \n fn is_lang_panic_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     Some(def_id) == tcx.lang_items().panic_fn() ||"}, {"sha": "4b374cff8093067807e131f1cfa392ad0d5360a7", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b2d021aa2b7c701406c10a3110dd31f990368c97/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d021aa2b7c701406c10a3110dd31f990368c97/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=b2d021aa2b7c701406c10a3110dd31f990368c97", "patch": "@@ -8,8 +8,7 @@ use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::symbol::sym;\n use syntax_pos::{Span, Symbol};\n \n-use super::Item;\n-use super::validation::Mode;\n+use super::{ConstKind, Item};\n \n /// An operation that is not *always* allowed in a const context.\n pub trait NonConstOp: std::fmt::Debug {\n@@ -36,7 +35,7 @@ pub trait NonConstOp: std::fmt::Debug {\n             span,\n             E0019,\n             \"{} contains unimplemented expression type\",\n-            item.mode\n+            item.const_kind()\n         );\n         if item.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\"A function call isn't allowed in the const's initialization expression \\\n@@ -76,7 +75,7 @@ impl NonConstOp for FnCallNonConst {\n             E0015,\n             \"calls in {}s are limited to constant functions, \\\n              tuple structs and tuple variants\",\n-            item.mode,\n+            item.const_kind(),\n         );\n         err.emit();\n     }\n@@ -121,8 +120,8 @@ impl NonConstOp for HeapAllocation {\n \n     fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(item.tcx.sess, span, E0010,\n-                                       \"allocations are not allowed in {}s\", item.mode);\n-        err.span_label(span, format!(\"allocation not allowed in {}s\", item.mode));\n+                                       \"allocations are not allowed in {}s\", item.const_kind());\n+        err.span_label(span, format!(\"allocation not allowed in {}s\", item.const_kind()));\n         if item.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"The value of statics and constants must be known at compile time, \\\n@@ -146,7 +145,7 @@ impl NonConstOp for LiveDrop {\n         struct_span_err!(item.tcx.sess, span, E0493,\n                          \"destructors cannot be evaluated at compile-time\")\n             .span_label(span, format!(\"{}s cannot evaluate destructors\",\n-                                      item.mode))\n+                                      item.const_kind()))\n             .emit();\n     }\n }\n@@ -163,9 +162,9 @@ impl NonConstOp for MutBorrow {\n         if let BorrowKind::Mut { .. } = kind {\n             let mut err = struct_span_err!(item.tcx.sess, span, E0017,\n                                            \"references in {}s may only refer \\\n-                                            to immutable values\", item.mode);\n+                                            to immutable values\", item.const_kind());\n             err.span_label(span, format!(\"{}s require immutable values\",\n-                                                item.mode));\n+                                                item.const_kind()));\n             if item.tcx.sess.teach(&err.get_code().unwrap()) {\n                 err.note(\"References in statics and constants may only refer \\\n                           to immutable values.\\n\\n\\\n@@ -202,7 +201,7 @@ impl NonConstOp for Panic {\n             sym::const_panic,\n             span,\n             GateIssue::Language,\n-            &format!(\"panicking in {}s is unstable\", item.mode),\n+            &format!(\"panicking in {}s is unstable\", item.const_kind()),\n         );\n     }\n }\n@@ -220,7 +219,7 @@ impl NonConstOp for RawPtrComparison {\n             sym::const_compare_raw_pointers,\n             span,\n             GateIssue::Language,\n-            &format!(\"comparing raw pointers inside {}\", item.mode),\n+            &format!(\"comparing raw pointers inside {}\", item.const_kind()),\n         );\n     }\n }\n@@ -238,7 +237,7 @@ impl NonConstOp for RawPtrDeref {\n             span, GateIssue::Language,\n             &format!(\n                 \"dereferencing raw pointers in {}s is unstable\",\n-                item.mode,\n+                item.const_kind(),\n             ),\n         );\n     }\n@@ -257,7 +256,7 @@ impl NonConstOp for RawPtrToIntCast {\n             span, GateIssue::Language,\n             &format!(\n                 \"casting pointers to integers in {}s is unstable\",\n-                item.mode,\n+                item.const_kind(),\n             ),\n         );\n     }\n@@ -268,13 +267,13 @@ impl NonConstOp for RawPtrToIntCast {\n pub struct StaticAccess;\n impl NonConstOp for StaticAccess {\n     fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n-        item.mode.is_static()\n+        item.const_kind().is_static()\n     }\n \n     fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(item.tcx.sess, span, E0013,\n                                         \"{}s cannot refer to statics, use \\\n-                                        a constant instead\", item.mode);\n+                                        a constant instead\", item.const_kind());\n         if item.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"Static and const variables can refer to other const variables. \\\n@@ -313,7 +312,7 @@ impl NonConstOp for Transmute {\n             &item.tcx.sess.parse_sess, sym::const_transmute,\n             span, GateIssue::Language,\n             &format!(\"The use of std::mem::transmute() \\\n-            is gated in {}s\", item.mode));\n+            is gated in {}s\", item.const_kind()));\n     }\n }\n \n@@ -322,7 +321,7 @@ pub struct UnionAccess;\n impl NonConstOp for UnionAccess {\n     fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n         // Union accesses are stable in all contexts except `const fn`.\n-        item.mode != Mode::ConstFn || Self::feature_gate(item.tcx).unwrap()\n+        item.const_kind() != ConstKind::ConstFn || Self::feature_gate(item.tcx).unwrap()\n     }\n \n     fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {"}, {"sha": "840ad303016074239ea2b81202ae91a1c5f29b07", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2d021aa2b7c701406c10a3110dd31f990368c97/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d021aa2b7c701406c10a3110dd31f990368c97/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=b2d021aa2b7c701406c10a3110dd31f990368c97", "patch": "@@ -5,8 +5,7 @@ use rustc::mir::interpret::ConstValue;\n use rustc::ty::{self, Ty};\n use syntax_pos::DUMMY_SP;\n \n-use super::Item as ConstCx;\n-use super::validation::Mode;\n+use super::{ConstKind, Item as ConstCx};\n \n #[derive(Clone, Copy)]\n pub struct QualifSet(u8);\n@@ -236,13 +235,17 @@ impl Qualif for HasMutInterior {\n                     // mutably without consequences.\n                     match ty.kind {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n-                        ty::Array(..) | ty::Slice(_) if cx.mode == Mode::StaticMut => {},\n-\n-                        // FIXME(eddyb) the `cx.for_promotion` condition\n-                        // seems unnecessary, given that this is merely a ZST.\n-                        ty::Array(_, len)\n-                            if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n-                                && cx.for_promotion => {},\n+                        | ty::Array(..)\n+                        | ty::Slice(_)\n+                        if cx.const_kind == Some(ConstKind::StaticMut)\n+                        => {},\n+\n+                        // FIXME(eddyb): We only return false for `&mut []` outside a const\n+                        // context which seems unnecessary given that this is merely a ZST.\n+                        | ty::Array(_, len)\n+                        if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n+                            && cx.const_kind == None\n+                        => {},\n \n                         _ => return true,\n                     }"}, {"sha": "c145fb41c9695e7eef9dc644a3c35261625bde99", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 3, "deletions": 68, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b2d021aa2b7c701406c10a3110dd31f990368c97/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d021aa2b7c701406c10a3110dd31f990368c97/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=b2d021aa2b7c701406c10a3110dd31f990368c97", "patch": "@@ -1,10 +1,9 @@\n //! The `Visitor` responsible for actually checking a `mir::Body` for invalid operations.\n \n-use rustc::hir::{self, def_id::DefId};\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::*;\n use rustc::ty::cast::CastTy;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty;\n use rustc_index::bit_set::BitSet;\n use rustc_target::spec::abi::Abi;\n use syntax::symbol::sym;\n@@ -15,7 +14,7 @@ use std::fmt;\n use std::ops::Deref;\n \n use crate::dataflow as old_dataflow;\n-use super::{Item, Qualif, is_lang_panic_fn};\n+use super::{ConstKind, Item, Qualif, is_lang_panic_fn};\n use super::resolver::{FlowSensitiveResolver, IndirectlyMutableResults, QualifResolver};\n use super::qualifs::{HasMutInterior, NeedsDrop};\n use super::ops::{self, NonConstOp};\n@@ -27,70 +26,6 @@ pub enum CheckOpResult {\n     Allowed,\n }\n \n-/// What kind of item we are in.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Mode {\n-    /// A `static` item.\n-    Static,\n-    /// A `static mut` item.\n-    StaticMut,\n-    /// A `const fn` item.\n-    ConstFn,\n-    /// A `const` item or an anonymous constant (e.g. in array lengths).\n-    Const,\n-}\n-\n-impl Mode {\n-    /// Returns the validation mode for the item with the given `DefId`, or `None` if this item\n-    /// does not require validation (e.g. a non-const `fn`).\n-    pub fn for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<Self> {\n-        use hir::BodyOwnerKind as HirKind;\n-\n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-\n-        let mode = match tcx.hir().body_owner_kind(hir_id) {\n-            HirKind::Closure => return None,\n-\n-            HirKind::Fn if tcx.is_const_fn(def_id) => Mode::ConstFn,\n-            HirKind::Fn => return None,\n-\n-            HirKind::Const => Mode::Const,\n-\n-            HirKind::Static(hir::MutImmutable) => Mode::Static,\n-            HirKind::Static(hir::MutMutable) => Mode::StaticMut,\n-        };\n-\n-        Some(mode)\n-    }\n-\n-    pub fn is_static(self) -> bool {\n-        match self {\n-            Mode::Static | Mode::StaticMut => true,\n-            Mode::ConstFn | Mode::Const => false,\n-        }\n-    }\n-\n-    /// Returns `true` if the value returned by this item must be `Sync`.\n-    ///\n-    /// This returns false for `StaticMut` since all accesses to one are `unsafe` anyway.\n-    pub fn requires_sync(self) -> bool {\n-        match self {\n-            Mode::Static => true,\n-            Mode::ConstFn | Mode::Const |  Mode::StaticMut => false,\n-        }\n-    }\n-}\n-\n-impl fmt::Display for Mode {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            Mode::Const => write!(f, \"constant\"),\n-            Mode::Static | Mode::StaticMut => write!(f, \"static\"),\n-            Mode::ConstFn => write!(f, \"constant function\"),\n-        }\n-    }\n-}\n-\n pub struct Qualifs<'a, 'mir, 'tcx> {\n     has_mut_interior: FlowSensitiveResolver<'a, 'mir, 'tcx, HasMutInterior>,\n     needs_drop: FlowSensitiveResolver<'a, 'mir, 'tcx, NeedsDrop>,\n@@ -343,7 +278,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 let is_thread_local = self.tcx.has_attr(*def_id, sym::thread_local);\n                 if is_thread_local {\n                     self.check_op(ops::ThreadLocalAccess);\n-                } else if self.mode == Mode::Static && context.is_mutating_use() {\n+                } else if self.const_kind() == ConstKind::Static && context.is_mutating_use() {\n                     // this is not strictly necessary as miri will also bail out\n                     // For interior mutability we can't really catch this statically as that\n                     // goes through raw pointers and intermediate temporaries, so miri has"}, {"sha": "4bf1fc60fe7b5e10eaf15afe09d8e76338df6bfa", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d021aa2b7c701406c10a3110dd31f990368c97/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d021aa2b7c701406c10a3110dd31f990368c97/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=b2d021aa2b7c701406c10a3110dd31f990368c97", "patch": "@@ -730,7 +730,7 @@ pub fn validate_candidates(\n         is_non_const_fn: false,\n         temps,\n \n-        const_cx: ConstCx::for_promotion(tcx, def_id, body),\n+        const_cx: ConstCx::new(tcx, def_id, body),\n \n         explicit: false,\n     };"}]}