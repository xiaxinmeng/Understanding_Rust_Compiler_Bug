{"sha": "e7281d08de338fc091ce12f90b48d7b4de50a138", "node_id": "C_kwDOAAsO6NoAKGU3MjgxZDA4ZGUzMzhmYzA5MWNlMTJmOTBiNDhkN2I0ZGU1MGExMzg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-03-10T11:20:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-10T11:20:53Z"}, "message": "Rollup merge of #94746 - notriddle:notriddle/method-rustc-on-unimplemented, r=davidtwco\n\ndiagnostics: use rustc_on_unimplemented to recommend `[].iter()`\n\nTo make this work, the `#[rustc_on_unimplemented]` data needs to be used to\nreport method resolution errors, which is most of what this commit does.\n\nFixes #94581", "tree": {"sha": "427236d504552c056fe8da6445f17ed7c50de96c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/427236d504552c056fe8da6445f17ed7c50de96c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7281d08de338fc091ce12f90b48d7b4de50a138", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiKd8VCRBK7hj4Ov3rIwAAvOUIAHGl2C4aPBYxYJTGjNQaTzeg\nRMue6FC+5kpZXI+7IgdEftq22hDe7VssBqvrgIafAZt26zAivtVEvIOyuN3t8ScB\nQfJUR99qgEWQNA/hhYQJ9Kwwv5zWVsQi6NPk/mRmGmSdW4XW28KM3bN4NlSj/KmJ\n7/WOZ6l/RNIGWddJ66wYE6TX0s7henjVb4qFM51DFCDDRzbrJ3u1zdkh1fFVXHfP\nEv6Wmx0R7c60LJ3czAebbxgliVA61VyyhrrNJeAu4AORDvWv7M5TruA9oaWdFtRg\nSvo9JhBywQ6qVjyEIV9XaZT0OTOeq7ftuvVuKqiEKrES1Pb6WQwNdna/3nCChUg=\n=RiiY\n-----END PGP SIGNATURE-----\n", "payload": "tree 427236d504552c056fe8da6445f17ed7c50de96c\nparent fe034cb43baf6fe415ca0f530cd72614df447b70\nparent 32d7f8145a33d7b3061cf29dd997fd8c5d2117b6\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1646911253 +0100\ncommitter GitHub <noreply@github.com> 1646911253 +0100\n\nRollup merge of #94746 - notriddle:notriddle/method-rustc-on-unimplemented, r=davidtwco\n\ndiagnostics: use rustc_on_unimplemented to recommend `[].iter()`\n\nTo make this work, the `#[rustc_on_unimplemented]` data needs to be used to\nreport method resolution errors, which is most of what this commit does.\n\nFixes #94581\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7281d08de338fc091ce12f90b48d7b4de50a138", "html_url": "https://github.com/rust-lang/rust/commit/e7281d08de338fc091ce12f90b48d7b4de50a138", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7281d08de338fc091ce12f90b48d7b4de50a138/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe034cb43baf6fe415ca0f530cd72614df447b70", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe034cb43baf6fe415ca0f530cd72614df447b70", "html_url": "https://github.com/rust-lang/rust/commit/fe034cb43baf6fe415ca0f530cd72614df447b70"}, {"sha": "32d7f8145a33d7b3061cf29dd997fd8c5d2117b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/32d7f8145a33d7b3061cf29dd997fd8c5d2117b6", "html_url": "https://github.com/rust-lang/rust/commit/32d7f8145a33d7b3061cf29dd997fd8c5d2117b6"}], "stats": {"total": 420, "additions": 258, "deletions": 162}, "files": [{"sha": "da54ad06e048b0cdc455fdc6e9e68ec98d104c40", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7281d08de338fc091ce12f90b48d7b4de50a138/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7281d08de338fc091ce12f90b48d7b4de50a138/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=e7281d08de338fc091ce12f90b48d7b4de50a138", "patch": "@@ -1886,6 +1886,15 @@ impl<'tcx> Ty<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    pub fn is_array_slice(self) -> bool {\n+        match self.kind() {\n+            Slice(_) => true,\n+            RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => matches!(ty.kind(), Slice(_)),\n+            _ => false,\n+        }\n+    }\n+\n     #[inline]\n     pub fn is_array(self) -> bool {\n         matches!(self.kind(), Array(..))"}, {"sha": "59c88b6603c228aa1f8f7fde58ad0ad65d9d7bc1", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7281d08de338fc091ce12f90b48d7b4de50a138/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7281d08de338fc091ce12f90b48d7b4de50a138/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=e7281d08de338fc091ce12f90b48d7b4de50a138", "patch": "@@ -11,7 +11,7 @@ use std::iter;\n \n use super::InferCtxtPrivExt;\n \n-crate trait InferCtxtExt<'tcx> {\n+pub trait InferCtxtExt<'tcx> {\n     /*private*/\n     fn impl_similar_to(\n         &self,\n@@ -204,6 +204,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n             }\n \n+            if self_ty.is_array_slice() {\n+                flags.push((sym::_Self, Some(\"&[]\".to_owned())));\n+            }\n+\n             if let ty::Array(aty, len) = self_ty.kind() {\n                 flags.push((sym::_Self, Some(\"[]\".to_owned())));\n                 flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));"}, {"sha": "504e1ce8c9f51c84de1a494d5db9e613adef0a1d", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 209, "deletions": 153, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/e7281d08de338fc091ce12f90b48d7b4de50a138/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7281d08de338fc091ce12f90b48d7b4de50a138/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e7281d08de338fc091ce12f90b48d7b4de50a138", "patch": "@@ -19,9 +19,10 @@ use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_span::lev_distance;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{source_map, FileName, MultiSpan, Span};\n-use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::on_unimplemented::InferCtxtExt as _;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n-    FulfillmentError, Obligation, ObligationCause, ObligationCauseCode,\n+    FulfillmentError, Obligation, ObligationCause, ObligationCauseCode, OnUnimplementedNote,\n };\n \n use std::cmp::Ordering;\n@@ -483,150 +484,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                let mut label_span_not_found = || {\n-                    if unsatisfied_predicates.is_empty() {\n-                        err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n-                        let is_string_or_ref_str = match actual.kind() {\n-                            ty::Ref(_, ty, _) => {\n-                                ty.is_str()\n-                                    || matches!(\n-                                        ty.kind(),\n-                                        ty::Adt(adt, _) if self.tcx.is_diagnostic_item(sym::String, adt.did)\n-                                    )\n-                            }\n-                            ty::Adt(adt, _) => self.tcx.is_diagnostic_item(sym::String, adt.did),\n-                            _ => false,\n-                        };\n-                        if is_string_or_ref_str && item_name.name == sym::iter {\n-                            err.span_suggestion_verbose(\n-                                item_name.span,\n-                                \"because of the in-memory representation of `&str`, to obtain \\\n-                                 an `Iterator` over each of its codepoint use method `chars`\",\n-                                String::from(\"chars\"),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                        if let ty::Adt(adt, _) = rcvr_ty.kind() {\n-                            let mut inherent_impls_candidate = self\n-                                .tcx\n-                                .inherent_impls(adt.did)\n-                                .iter()\n-                                .copied()\n-                                .filter(|def_id| {\n-                                    if let Some(assoc) = self.associated_value(*def_id, item_name) {\n-                                        // Check for both mode is the same so we avoid suggesting\n-                                        // incorrect associated item.\n-                                        match (mode, assoc.fn_has_self_parameter, source) {\n-                                            (Mode::MethodCall, true, SelfSource::MethodCall(_)) => {\n-                                                // We check that the suggest type is actually\n-                                                // different from the received one\n-                                                // So we avoid suggestion method with Box<Self>\n-                                                // for instance\n-                                                self.tcx.at(span).type_of(*def_id) != actual\n-                                                    && self.tcx.at(span).type_of(*def_id) != rcvr_ty\n-                                            }\n-                                            (Mode::Path, false, _) => true,\n-                                            _ => false,\n-                                        }\n-                                    } else {\n-                                        false\n-                                    }\n-                                })\n-                                .collect::<Vec<_>>();\n-                            if !inherent_impls_candidate.is_empty() {\n-                                inherent_impls_candidate.sort();\n-                                inherent_impls_candidate.dedup();\n-\n-                                // number of type to shows at most.\n-                                let limit = if inherent_impls_candidate.len() == 5 { 5 } else { 4 };\n-                                let type_candidates = inherent_impls_candidate\n-                                    .iter()\n-                                    .take(limit)\n-                                    .map(|impl_item| {\n-                                        format!(\"- `{}`\", self.tcx.at(span).type_of(*impl_item))\n-                                    })\n-                                    .collect::<Vec<_>>()\n-                                    .join(\"\\n\");\n-                                let additional_types = if inherent_impls_candidate.len() > limit {\n-                                    format!(\n-                                        \"\\nand {} more types\",\n-                                        inherent_impls_candidate.len() - limit\n-                                    )\n-                                } else {\n-                                    \"\".to_string()\n-                                };\n-                                err.note(&format!(\n-                                    \"the {item_kind} was found for\\n{}{}\",\n-                                    type_candidates, additional_types\n-                                ));\n-                            }\n-                        }\n-                    } else {\n-                        err.span_label(span, format!(\"{item_kind} cannot be called on `{ty_str}` due to unsatisfied trait bounds\"));\n-                    }\n-                };\n-\n-                // If the method name is the name of a field with a function or closure type,\n-                // give a helping note that it has to be called as `(x.f)(...)`.\n-                if let SelfSource::MethodCall(expr) = source {\n-                    let field_receiver =\n-                        self.autoderef(span, rcvr_ty).find_map(|(ty, _)| match ty.kind() {\n-                            ty::Adt(def, substs) if !def.is_enum() => {\n-                                let variant = &def.non_enum_variant();\n-                                self.tcx.find_field_index(item_name, variant).map(|index| {\n-                                    let field = &variant.fields[index];\n-                                    let field_ty = field.ty(tcx, substs);\n-                                    (field, field_ty)\n-                                })\n-                            }\n-                            _ => None,\n-                        });\n-\n-                    if let Some((field, field_ty)) = field_receiver {\n-                        let scope = self.tcx.parent_module(self.body_id).to_def_id();\n-                        let is_accessible = field.vis.is_accessible_from(scope, self.tcx);\n-\n-                        if is_accessible {\n-                            if self.is_fn_ty(field_ty, span) {\n-                                let expr_span = expr.span.to(item_name.span);\n-                                err.multipart_suggestion(\n-                                    &format!(\n-                                        \"to call the function stored in `{}`, \\\n-                                         surround the field access with parentheses\",\n-                                        item_name,\n-                                    ),\n-                                    vec![\n-                                        (expr_span.shrink_to_lo(), '('.to_string()),\n-                                        (expr_span.shrink_to_hi(), ')'.to_string()),\n-                                    ],\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            } else {\n-                                let call_expr = self\n-                                    .tcx\n-                                    .hir()\n-                                    .expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n-\n-                                if let Some(span) = call_expr.span.trim_start(item_name.span) {\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"remove the arguments\",\n-                                        String::new(),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                            }\n-                        }\n-\n-                        let field_kind = if is_accessible { \"field\" } else { \"private field\" };\n-                        err.span_label(item_name.span, format!(\"{}, not a method\", field_kind));\n-                    } else if lev_candidate.is_none() && static_sources.is_empty() {\n-                        label_span_not_found();\n-                    }\n-                } else {\n-                    label_span_not_found();\n-                }\n-\n                 if self.is_fn_ty(rcvr_ty, span) {\n                     fn report_function<T: std::fmt::Display>(err: &mut Diagnostic, name: T) {\n                         err.note(\n@@ -645,12 +502,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n+                let mut custom_span_label = false;\n+\n                 if !static_sources.is_empty() {\n                     err.note(\n                         \"found the following associated functions; to be used as methods, \\\n                          functions must have a `self` parameter\",\n                     );\n                     err.span_label(span, \"this is an associated function, not a method\");\n+                    custom_span_label = true;\n                 }\n                 if static_sources.len() == 1 {\n                     let ty_str = if let Some(CandidateSource::ImplSource(impl_did)) =\n@@ -686,6 +546,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     report_candidates(span, &mut err, static_sources, sugg_span);\n                 }\n \n+                let mut bound_spans = vec![];\n                 let mut restrict_type_params = false;\n                 let mut unsatisfied_bounds = false;\n                 if item_name.name == sym::count && self.is_slice_ty(actual, span) {\n@@ -709,7 +570,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         self.tcx.sess.source_map().guess_head_span(self.tcx.def_span(def_id))\n                     };\n                     let mut type_params = FxHashMap::default();\n-                    let mut bound_spans = vec![];\n+\n+                    // Pick out the list of unimplemented traits on the receiver.\n+                    // This is used for custom error messages with the `#[rustc_on_unimplemented]` attribute.\n+                    let mut unimplemented_traits = FxHashMap::default();\n+                    for (predicate, _parent_pred, cause) in &unsatisfied_predicates {\n+                        if let (ty::PredicateKind::Trait(p), Some(cause)) =\n+                            (predicate.kind().skip_binder(), cause.as_ref())\n+                        {\n+                            if p.trait_ref.self_ty() != rcvr_ty {\n+                                // This is necessary, not just to keep the errors clean, but also\n+                                // because our derived obligations can wind up with a trait ref that\n+                                // requires a different param_env to be correctly compared.\n+                                continue;\n+                            }\n+                            unimplemented_traits.entry(p.trait_ref.def_id).or_insert((\n+                                predicate.kind().rebind(p.trait_ref),\n+                                Obligation {\n+                                    cause: cause.clone(),\n+                                    param_env: self.param_env,\n+                                    predicate: predicate.clone(),\n+                                    recursion_depth: 0,\n+                                },\n+                            ));\n+                        }\n+                    }\n \n                     let mut collect_type_param_suggestions =\n                         |self_ty: Ty<'tcx>, parent_pred: ty::Predicate<'tcx>, obligation: &str| {\n@@ -945,21 +830,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     bound_list.sort_by(|(_, a), (_, b)| a.cmp(b)); // Sort alphabetically.\n                     bound_list.dedup_by(|(_, a), (_, b)| a == b); // #35677\n                     bound_list.sort_by_key(|(pos, _)| *pos); // Keep the original predicate order.\n-                    bound_spans.sort();\n-                    bound_spans.dedup();\n-                    for (span, msg) in bound_spans.into_iter() {\n-                        err.span_label(span, &msg);\n-                    }\n+\n                     if !bound_list.is_empty() || !skip_list.is_empty() {\n                         let bound_list = bound_list\n                             .into_iter()\n                             .map(|(_, path)| path)\n                             .collect::<Vec<_>>()\n                             .join(\"\\n\");\n                         let actual_prefix = actual.prefix_string(self.tcx);\n-                        err.set_primary_message(&format!(\n+                        info!(\"unimplemented_traits.len() == {}\", unimplemented_traits.len());\n+                        let (primary_message, label) = if unimplemented_traits.len() == 1 {\n+                            unimplemented_traits\n+                                .into_iter()\n+                                .next()\n+                                .map(|(_, (trait_ref, obligation))| {\n+                                    if trait_ref.self_ty().references_error()\n+                                        || actual.references_error()\n+                                    {\n+                                        // Avoid crashing.\n+                                        return (None, None);\n+                                    }\n+                                    let OnUnimplementedNote { message, label, .. } =\n+                                        self.infcx.on_unimplemented_note(trait_ref, &obligation);\n+                                    (message, label)\n+                                })\n+                                .unwrap_or((None, None))\n+                        } else {\n+                            (None, None)\n+                        };\n+                        let primary_message = primary_message.unwrap_or_else(|| format!(\n                             \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, but its trait bounds were not satisfied\"\n                         ));\n+                        err.set_primary_message(&primary_message);\n+                        if let Some(label) = label {\n+                            custom_span_label = true;\n+                            err.span_label(span, label);\n+                        }\n                         if !bound_list.is_empty() {\n                             err.note(&format!(\n                                 \"the following trait bounds were not satisfied:\\n{bound_list}\"\n@@ -971,6 +877,156 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n+                let mut label_span_not_found = || {\n+                    if unsatisfied_predicates.is_empty() {\n+                        err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n+                        let is_string_or_ref_str = match actual.kind() {\n+                            ty::Ref(_, ty, _) => {\n+                                ty.is_str()\n+                                    || matches!(\n+                                        ty.kind(),\n+                                        ty::Adt(adt, _) if self.tcx.is_diagnostic_item(sym::String, adt.did)\n+                                    )\n+                            }\n+                            ty::Adt(adt, _) => self.tcx.is_diagnostic_item(sym::String, adt.did),\n+                            _ => false,\n+                        };\n+                        if is_string_or_ref_str && item_name.name == sym::iter {\n+                            err.span_suggestion_verbose(\n+                                item_name.span,\n+                                \"because of the in-memory representation of `&str`, to obtain \\\n+                                 an `Iterator` over each of its codepoint use method `chars`\",\n+                                String::from(\"chars\"),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                        if let ty::Adt(adt, _) = rcvr_ty.kind() {\n+                            let mut inherent_impls_candidate = self\n+                                .tcx\n+                                .inherent_impls(adt.did)\n+                                .iter()\n+                                .copied()\n+                                .filter(|def_id| {\n+                                    if let Some(assoc) = self.associated_value(*def_id, item_name) {\n+                                        // Check for both mode is the same so we avoid suggesting\n+                                        // incorrect associated item.\n+                                        match (mode, assoc.fn_has_self_parameter, source) {\n+                                            (Mode::MethodCall, true, SelfSource::MethodCall(_)) => {\n+                                                // We check that the suggest type is actually\n+                                                // different from the received one\n+                                                // So we avoid suggestion method with Box<Self>\n+                                                // for instance\n+                                                self.tcx.at(span).type_of(*def_id) != actual\n+                                                    && self.tcx.at(span).type_of(*def_id) != rcvr_ty\n+                                            }\n+                                            (Mode::Path, false, _) => true,\n+                                            _ => false,\n+                                        }\n+                                    } else {\n+                                        false\n+                                    }\n+                                })\n+                                .collect::<Vec<_>>();\n+                            if !inherent_impls_candidate.is_empty() {\n+                                inherent_impls_candidate.sort();\n+                                inherent_impls_candidate.dedup();\n+\n+                                // number of type to shows at most.\n+                                let limit = if inherent_impls_candidate.len() == 5 { 5 } else { 4 };\n+                                let type_candidates = inherent_impls_candidate\n+                                    .iter()\n+                                    .take(limit)\n+                                    .map(|impl_item| {\n+                                        format!(\"- `{}`\", self.tcx.at(span).type_of(*impl_item))\n+                                    })\n+                                    .collect::<Vec<_>>()\n+                                    .join(\"\\n\");\n+                                let additional_types = if inherent_impls_candidate.len() > limit {\n+                                    format!(\n+                                        \"\\nand {} more types\",\n+                                        inherent_impls_candidate.len() - limit\n+                                    )\n+                                } else {\n+                                    \"\".to_string()\n+                                };\n+                                err.note(&format!(\n+                                    \"the {item_kind} was found for\\n{}{}\",\n+                                    type_candidates, additional_types\n+                                ));\n+                            }\n+                        }\n+                    } else {\n+                        err.span_label(span, format!(\"{item_kind} cannot be called on `{ty_str}` due to unsatisfied trait bounds\"));\n+                    }\n+                };\n+\n+                // If the method name is the name of a field with a function or closure type,\n+                // give a helping note that it has to be called as `(x.f)(...)`.\n+                if let SelfSource::MethodCall(expr) = source {\n+                    let field_receiver =\n+                        self.autoderef(span, rcvr_ty).find_map(|(ty, _)| match ty.kind() {\n+                            ty::Adt(def, substs) if !def.is_enum() => {\n+                                let variant = &def.non_enum_variant();\n+                                self.tcx.find_field_index(item_name, variant).map(|index| {\n+                                    let field = &variant.fields[index];\n+                                    let field_ty = field.ty(tcx, substs);\n+                                    (field, field_ty)\n+                                })\n+                            }\n+                            _ => None,\n+                        });\n+\n+                    if let Some((field, field_ty)) = field_receiver {\n+                        let scope = self.tcx.parent_module(self.body_id).to_def_id();\n+                        let is_accessible = field.vis.is_accessible_from(scope, self.tcx);\n+\n+                        if is_accessible {\n+                            if self.is_fn_ty(field_ty, span) {\n+                                let expr_span = expr.span.to(item_name.span);\n+                                err.multipart_suggestion(\n+                                    &format!(\n+                                        \"to call the function stored in `{}`, \\\n+                                         surround the field access with parentheses\",\n+                                        item_name,\n+                                    ),\n+                                    vec![\n+                                        (expr_span.shrink_to_lo(), '('.to_string()),\n+                                        (expr_span.shrink_to_hi(), ')'.to_string()),\n+                                    ],\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            } else {\n+                                let call_expr = self\n+                                    .tcx\n+                                    .hir()\n+                                    .expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n+\n+                                if let Some(span) = call_expr.span.trim_start(item_name.span) {\n+                                    err.span_suggestion(\n+                                        span,\n+                                        \"remove the arguments\",\n+                                        String::new(),\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                }\n+                            }\n+                        }\n+\n+                        let field_kind = if is_accessible { \"field\" } else { \"private field\" };\n+                        err.span_label(item_name.span, format!(\"{}, not a method\", field_kind));\n+                    } else if lev_candidate.is_none() && !custom_span_label {\n+                        label_span_not_found();\n+                    }\n+                } else if !custom_span_label {\n+                    label_span_not_found();\n+                }\n+\n+                bound_spans.sort();\n+                bound_spans.dedup();\n+                for (span, msg) in bound_spans.into_iter() {\n+                    err.span_label(span, &msg);\n+                }\n+\n                 if actual.is_numeric() && actual.is_fresh() || restrict_type_params {\n                 } else {\n                     self.suggest_traits_to_import("}, {"sha": "c35d0784dd5a46e0de6ce1be950110c3297ca3a6", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7281d08de338fc091ce12f90b48d7b4de50a138/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7281d08de338fc091ce12f90b48d7b4de50a138/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=e7281d08de338fc091ce12f90b48d7b4de50a138", "patch": "@@ -34,6 +34,11 @@ fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n         note = \"`..=end` is a `RangeToInclusive`, which cannot be iterated on; you might have meant \\\n               to have a bounded `RangeInclusive`: `0..=end`\"\n     ),\n+    on(\n+        _Self = \"[]\",\n+        label = \"`{Self}` is not an iterator; try calling `.into_iter()` or `.iter()`\"\n+    ),\n+    on(_Self = \"&[]\", label = \"`{Self}` is not an iterator; try calling `.iter()`\"),\n     on(\n         _Self = \"&str\",\n         label = \"`{Self}` is not an iterator; try calling `.chars()` or `.bytes()`\""}, {"sha": "a336d1b0ed55d7e5707a1131dde331581ecaefce", "filename": "src/test/ui/issues/issue-21596.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7281d08de338fc091ce12f90b48d7b4de50a138/src%2Ftest%2Fui%2Fissues%2Fissue-21596.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7281d08de338fc091ce12f90b48d7b4de50a138/src%2Ftest%2Fui%2Fissues%2Fissue-21596.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21596.stderr?ref=e7281d08de338fc091ce12f90b48d7b4de50a138", "patch": "@@ -1,8 +1,8 @@\n-error[E0599]: the method `to_string` exists for raw pointer `*const u8`, but its trait bounds were not satisfied\n+error[E0599]: `*const u8` doesn't implement `std::fmt::Display`\n   --> $DIR/issue-21596.rs:4:22\n    |\n LL |     println!(\"{}\", z.to_string());\n-   |                      ^^^^^^^^^ method cannot be called on `*const u8` due to unsatisfied trait bounds\n+   |                      ^^^^^^^^^ `*const u8` cannot be formatted with the default formatter\n    |\n    = note: try using `<*const T>::as_ref()` to get a reference to the type behind the pointer: https://doc.rust-lang.org/std/primitive.pointer.html#method.as_ref\n    = note: using `<*const T>::as_ref()` on a pointer which is unaligned or points to invalid or uninitialized memory is undefined behavior"}, {"sha": "df393e91db0842d65f12e78111a42dc926083772", "filename": "src/test/ui/methods/issues/issue-94581.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7281d08de338fc091ce12f90b48d7b4de50a138/src%2Ftest%2Fui%2Fmethods%2Fissues%2Fissue-94581.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7281d08de338fc091ce12f90b48d7b4de50a138/src%2Ftest%2Fui%2Fmethods%2Fissues%2Fissue-94581.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fissues%2Fissue-94581.rs?ref=e7281d08de338fc091ce12f90b48d7b4de50a138", "patch": "@@ -0,0 +1,7 @@\n+fn get_slice() -> &'static [i32] {\n+    &[1, 2, 3, 4]\n+}\n+\n+fn main() {\n+    let sqsum = get_slice().map(|i| i * i).sum(); //~ ERROR [E0599]\n+}"}, {"sha": "d6be29cf582c37deef9e4b75a9280a4dfcc15779", "filename": "src/test/ui/methods/issues/issue-94581.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e7281d08de338fc091ce12f90b48d7b4de50a138/src%2Ftest%2Fui%2Fmethods%2Fissues%2Fissue-94581.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7281d08de338fc091ce12f90b48d7b4de50a138/src%2Ftest%2Fui%2Fmethods%2Fissues%2Fissue-94581.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fissues%2Fissue-94581.stderr?ref=e7281d08de338fc091ce12f90b48d7b4de50a138", "patch": "@@ -0,0 +1,15 @@\n+error[E0599]: `&'static [i32]` is not an iterator\n+  --> $DIR/issue-94581.rs:6:29\n+   |\n+LL |     let sqsum = get_slice().map(|i| i * i).sum();\n+   |                             ^^^ `&'static [i32]` is not an iterator; try calling `.iter()`\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `&'static [i32]: Iterator`\n+           which is required by `&mut &'static [i32]: Iterator`\n+           `[i32]: Iterator`\n+           which is required by `&mut [i32]: Iterator`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "d53ef445afc1bcf06174bf700cb2098ae2a7ac31", "filename": "src/test/ui/methods/method-call-err-msg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7281d08de338fc091ce12f90b48d7b4de50a138/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7281d08de338fc091ce12f90b48d7b4de50a138/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.rs?ref=e7281d08de338fc091ce12f90b48d7b4de50a138", "patch": "@@ -16,7 +16,7 @@ fn main() {\n \n     let y = Foo;\n     y.zero()\n-     .take()    //~ ERROR the method\n+     .take()    //~ ERROR not an iterator\n      .one(0);\n     y.three::<usize>(); //~ ERROR this function takes 3 arguments but 0 arguments were supplied\n }"}, {"sha": "c410e076dde2655babda04452050473b7cdc44d2", "filename": "src/test/ui/methods/method-call-err-msg.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7281d08de338fc091ce12f90b48d7b4de50a138/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7281d08de338fc091ce12f90b48d7b4de50a138/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr?ref=e7281d08de338fc091ce12f90b48d7b4de50a138", "patch": "@@ -40,7 +40,7 @@ note: associated function defined here\n LL |     fn two(self, _: isize, _: isize) -> Foo { self }\n    |        ^^^ ----  --------  --------\n \n-error[E0599]: the method `take` exists for struct `Foo`, but its trait bounds were not satisfied\n+error[E0599]: `Foo` is not an iterator\n   --> $DIR/method-call-err-msg.rs:19:7\n    |\n LL | pub struct Foo;\n@@ -50,7 +50,7 @@ LL | pub struct Foo;\n    | doesn't satisfy `Foo: Iterator`\n ...\n LL |      .take()\n-   |       ^^^^ method cannot be called on `Foo` due to unsatisfied trait bounds\n+   |       ^^^^ `Foo` is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n            `Foo: Iterator`"}, {"sha": "0252ba2eb04606e860492fec1757de88a3015de4", "filename": "src/test/ui/mismatched_types/issue-36053-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7281d08de338fc091ce12f90b48d7b4de50a138/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7281d08de338fc091ce12f90b48d7b4de50a138/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.rs?ref=e7281d08de338fc091ce12f90b48d7b4de50a138", "patch": "@@ -5,6 +5,6 @@\n use std::iter::once;\n fn main() {\n     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n-    //~^ ERROR the method\n+    //~^ ERROR not an iterator\n     //~| ERROR type mismatch in closure arguments\n }"}, {"sha": "b1010171eb23560fee29e2c705c15b8a6b55f736", "filename": "src/test/ui/mismatched_types/issue-36053-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7281d08de338fc091ce12f90b48d7b4de50a138/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7281d08de338fc091ce12f90b48d7b4de50a138/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr?ref=e7281d08de338fc091ce12f90b48d7b4de50a138", "patch": "@@ -12,11 +12,11 @@ note: required by a bound in `filter`\n LL |         P: FnMut(&Self::Item) -> bool,\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `filter`\n \n-error[E0599]: the method `count` exists for struct `Filter<Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:7:39: 7:53]>`, but its trait bounds were not satisfied\n+error[E0599]: `Filter<Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:7:39: 7:53]>` is not an iterator\n   --> $DIR/issue-36053-2.rs:7:55\n    |\n LL |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n-   |                                       --------------  ^^^^^ method cannot be called on `Filter<Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:7:39: 7:53]>` due to unsatisfied trait bounds\n+   |                                       --------------  ^^^^^ `Filter<Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:7:39: 7:53]>` is not an iterator\n    |                                       |\n    |                                       doesn't satisfy `<_ as FnOnce<(&&str,)>>::Output = bool`\n    |                                       doesn't satisfy `_: FnMut<(&&str,)>`"}]}