{"sha": "8619edede1496a8d9c4131f9cb2079e71dccd5fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MTllZGVkZTE0OTZhOGQ5YzQxMzFmOWNiMjA3OWU3MWRjY2Q1ZmI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-29T05:21:11Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: slice substs in ty::print instead of passing the full ones.", "tree": {"sha": "912e6fb69b376cb1132947a95ccf9ea0cf52580f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/912e6fb69b376cb1132947a95ccf9ea0cf52580f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8619edede1496a8d9c4131f9cb2079e71dccd5fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8619edede1496a8d9c4131f9cb2079e71dccd5fb", "html_url": "https://github.com/rust-lang/rust/commit/8619edede1496a8d9c4131f9cb2079e71dccd5fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8619edede1496a8d9c4131f9cb2079e71dccd5fb/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9df7c3f48fd4bb20da04624d19c8c1465d1117dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9df7c3f48fd4bb20da04624d19c8c1465d1117dc", "html_url": "https://github.com/rust-lang/rust/commit/9df7c3f48fd4bb20da04624d19c8c1465d1117dc"}], "stats": {"total": 167, "additions": 79, "deletions": 88}, "files": [{"sha": "5026074f5e82084f81529bb8a168a9e856304359", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8619edede1496a8d9c4131f9cb2079e71dccd5fb", "patch": "@@ -533,7 +533,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n                 let abs_path = |def_id| {\n                     AbsolutePathPrinter { tcx: self.tcx }\n-                        .print_def_path(def_id, None)\n+                        .print_def_path(def_id, &[])\n                 };\n \n                 // We compare strings because DefPath can be different"}, {"sha": "718b506d051135e188b6cc68e2febf9a307dde62", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=8619edede1496a8d9c4131f9cb2079e71dccd5fb", "patch": "@@ -2410,7 +2410,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         ty::tls::with(|tcx| {\n                             let substs = tcx.lift(&substs).expect(\"could not lift for printing\");\n                             FmtPrinter::new(tcx, f, Namespace::ValueNS)\n-                                .print_def_path(variant_def.did, Some(substs))?;\n+                                .print_def_path(variant_def.did, substs)?;\n                             Ok(())\n                         })?;\n "}, {"sha": "995e85fc5f4db557cf54dd8d0729986985a12bc5", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=8619edede1496a8d9c4131f9cb2079e71dccd5fb", "patch": "@@ -179,7 +179,7 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n         ty::tls::with(|tcx| {\n             let substs = tcx.lift(&self.substs).expect(\"could not lift for printing\");\n             FmtPrinter::new(tcx, &mut *f, Namespace::ValueNS)\n-                .print_def_path(self.def_id(), Some(substs))?;\n+                .print_def_path(self.def_id(), substs)?;\n             Ok(())\n         })?;\n "}, {"sha": "c3f4a26a57ee83326a2c3a7b52d4f6fb9e11a483", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=8619edede1496a8d9c4131f9cb2079e71dccd5fb", "patch": "@@ -1,7 +1,7 @@\n use crate::hir::map::DefPathData;\n use crate::hir::def_id::{CrateNum, DefId};\n use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n-use crate::ty::subst::{Kind, Subst, SubstsRef};\n+use crate::ty::subst::{Kind, Subst};\n \n use rustc_data_structures::fx::FxHashSet;\n \n@@ -29,14 +29,14 @@ pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n     fn print_def_path(\n         self,\n         def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n+        substs: &'tcx [Kind<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         self.default_print_def_path(def_id, substs)\n     }\n     fn print_impl_path(\n         self,\n         impl_def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n+        substs: &'tcx [Kind<'tcx>],\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n@@ -90,7 +90,7 @@ pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n     fn default_print_def_path(\n         self,\n         def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n+        substs: &'tcx [Kind<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         debug!(\"default_print_def_path: def_id={:?}, substs={:?}\", def_id, substs);\n         let key = self.tcx().def_key(def_id);\n@@ -103,69 +103,69 @@ pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n             }\n \n             DefPathData::Impl => {\n+                let generics = self.tcx().generics_of(def_id);\n                 let mut self_ty = self.tcx().type_of(def_id);\n-                if let Some(substs) = substs {\n-                    self_ty = self_ty.subst(self.tcx(), substs);\n-                }\n-\n                 let mut impl_trait_ref = self.tcx().impl_trait_ref(def_id);\n-                if let Some(substs) = substs {\n+                if substs.len() >= generics.count() {\n+                    self_ty = self_ty.subst(self.tcx(), substs);\n                     impl_trait_ref = impl_trait_ref.subst(self.tcx(), substs);\n                 }\n                 self.print_impl_path(def_id, substs, self_ty, impl_trait_ref)\n             }\n \n             _ => {\n-                let generics = substs.map(|_| self.tcx().generics_of(def_id));\n-                let generics_parent = generics.as_ref().and_then(|g| g.parent);\n                 let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n-                let print_parent_path = |cx: Self| {\n-                    if let Some(generics_parent_def_id) = generics_parent {\n-                        assert_eq!(parent_def_id, generics_parent_def_id);\n-\n-                        // FIXME(eddyb) try to move this into the parent's printing\n-                        // logic, instead of doing it when printing the child.\n-                        let parent_generics = cx.tcx().generics_of(parent_def_id);\n-                        let parent_has_own_self =\n-                            parent_generics.has_self && parent_generics.parent_count == 0;\n-                        if let (Some(substs), true) = (substs, parent_has_own_self) {\n-                            let trait_ref = ty::TraitRef::new(parent_def_id, substs);\n-                            cx.path_qualified(trait_ref.self_ty(), Some(trait_ref))\n-                        } else {\n-                            cx.print_def_path(parent_def_id, substs)\n-                        }\n-                    } else {\n-                        cx.print_def_path(parent_def_id, None)\n-                    }\n-                };\n-                let print_path = |cx: Self| {\n+\n+                let mut parent_substs = substs;\n+                let mut trait_qualify_parent = false;\n+                if !substs.is_empty() {\n+                    let generics = self.tcx().generics_of(def_id);\n+                    parent_substs = &substs[..generics.parent_count.min(substs.len())];\n+\n                     match key.disambiguated_data.data {\n-                        // Skip `::{{constructor}}` on tuple/unit structs.\n-                        DefPathData::StructCtor => print_parent_path(cx),\n-\n-                        _ => {\n-                            cx.path_append(\n-                                print_parent_path,\n-                                &key.disambiguated_data.data.as_interned_str().as_str(),\n-                            )\n+                        // Closures' own generics are only captures, don't print them.\n+                        DefPathData::ClosureExpr => {}\n+\n+                        // If we have any generic arguments to print, we do that\n+                        // on top of the same path, but without its own generics.\n+                        _ => if !generics.params.is_empty() && substs.len() >= generics.count() {\n+                            let args = self.generic_args_to_print(generics, substs);\n+                            return self.path_generic_args(\n+                                |cx| cx.print_def_path(def_id, parent_substs),\n+                                args,\n+                            );\n                         }\n                     }\n-                };\n \n-                if let (Some(generics), Some(substs)) = (generics, substs) {\n-                    let args = self.generic_args_to_print(generics, substs);\n-                    self.path_generic_args(print_path, args)\n-                } else {\n-                    print_path(self)\n+                    // FIXME(eddyb) try to move this into the parent's printing\n+                    // logic, instead of doing it when printing the child.\n+                    trait_qualify_parent =\n+                        generics.has_self &&\n+                        generics.parent == Some(parent_def_id) &&\n+                        parent_substs.len() == generics.parent_count &&\n+                        self.tcx().generics_of(parent_def_id).parent_count == 0;\n                 }\n+\n+                self.path_append(\n+                    |cx: Self| if trait_qualify_parent {\n+                        let trait_ref = ty::TraitRef::new(\n+                            parent_def_id,\n+                            cx.tcx().intern_substs(parent_substs),\n+                        );\n+                        cx.path_qualified(trait_ref.self_ty(), Some(trait_ref))\n+                    } else {\n+                        cx.print_def_path(parent_def_id, parent_substs)\n+                    },\n+                    &key.disambiguated_data.data.as_interned_str().as_str(),\n+                )\n             }\n         }\n     }\n \n     fn generic_args_to_print(\n         &self,\n         generics: &'tcx ty::Generics,\n-        substs: SubstsRef<'tcx>,\n+        substs: &'tcx [Kind<'tcx>],\n     ) -> &'tcx [Kind<'tcx>] {\n         let mut own_params = generics.parent_count..generics.count();\n \n@@ -193,7 +193,7 @@ pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n     fn default_print_impl_path(\n         self,\n         impl_def_id: DefId,\n-        _substs: Option<SubstsRef<'tcx>>,\n+        _substs: &'tcx [Kind<'tcx>],\n         self_ty: Ty<'tcx>,\n         impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n@@ -220,7 +220,7 @@ pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n             // trait-type, then fallback to a format that identifies\n             // the module more clearly.\n             self.path_append_impl(\n-                |cx| cx.print_def_path(parent_def_id, None),\n+                |cx| cx.print_def_path(parent_def_id, &[]),\n                 self_ty,\n                 impl_trait_ref,\n             )"}, {"sha": "54ca63b457af7211bc933fdd0054b75575c9e4f5", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=8619edede1496a8d9c4131f9cb2079e71dccd5fb", "patch": "@@ -5,7 +5,7 @@ use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n use crate::middle::region;\n use crate::ty::{self, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n-use crate::ty::subst::{Kind, Subst, SubstsRef, UnpackedKind};\n+use crate::ty::subst::{Kind, Subst, UnpackedKind};\n use crate::mir::interpret::ConstValue;\n use syntax::symbol::{keywords, Symbol};\n \n@@ -178,7 +178,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n     fn print_value_path(\n         self,\n         def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n+        substs: &'tcx [Kind<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         self.print_def_path(def_id, substs)\n     }\n@@ -264,7 +264,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n                 }) => {\n                     debug!(\"try_print_visible_def_path: def_id={:?}\", def_id);\n                     return Ok((if !span.is_dummy() {\n-                        self.print_def_path(def_id, None)?\n+                        self.print_def_path(def_id, &[])?\n                     } else {\n                         self.path_crate(cnum)?\n                     }, true));\n@@ -469,8 +469,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n             }\n             ty::FnDef(def_id, substs) => {\n                 let sig = self.tcx().fn_sig(def_id).subst(self.tcx(), substs);\n-                p!(print(sig),\n-                   write(\" {{\"), print_value_path(def_id, Some(substs)), write(\"}}\"));\n+                p!(print(sig), write(\" {{\"), print_value_path(def_id, substs), write(\"}}\"));\n             }\n             ty::FnPtr(ref bare_fn) => {\n                 p!(print(bare_fn))\n@@ -492,7 +491,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n                 }\n             }\n             ty::Adt(def, substs) => {\n-                p!(print_def_path(def.did, Some(substs)));\n+                p!(print_def_path(def.did, substs));\n             }\n             ty::Dynamic(data, r) => {\n                 let print_r = self.region_should_not_be_omitted(r);\n@@ -505,7 +504,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n                 }\n             }\n             ty::Foreign(def_id) => {\n-                p!(print_def_path(def_id, None));\n+                p!(print_def_path(def_id, &[]));\n             }\n             ty::Projection(ref data) => p!(print(data)),\n             ty::UnnormalizedProjection(ref data) => {\n@@ -691,7 +690,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n         let mut first = true;\n \n         if let Some(principal) = predicates.principal() {\n-            p!(print_def_path(principal.def_id, None));\n+            p!(print_def_path(principal.def_id, &[]));\n \n             let mut resugared = false;\n \n@@ -774,7 +773,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n             }\n             first = false;\n \n-            p!(print_def_path(def_id, None));\n+            p!(print_def_path(def_id, &[]));\n         }\n \n         Ok(self)\n@@ -879,7 +878,7 @@ impl TyCtxt<'_, '_, '_> {\n         debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n         let mut s = String::new();\n         let _ = FmtPrinter::new(self, &mut s, ns)\n-            .print_def_path(def_id, None);\n+            .print_def_path(def_id, &[]);\n         s\n     }\n }\n@@ -905,21 +904,13 @@ impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n     fn print_def_path(\n         mut self,\n         def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n+        substs: &'tcx [Kind<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         define_scoped_cx!(self);\n \n-        // FIXME(eddyb) avoid querying `tcx.generics_of` and `tcx.def_key`\n-        // both here and in `default_print_def_path`.\n-        let generics = substs.map(|_| self.tcx.generics_of(def_id));\n-        if generics.as_ref().and_then(|g| g.parent).is_none() {\n+        if substs.is_empty() {\n             match self.try_print_visible_def_path(def_id)? {\n-                (cx, true) => return if let (Some(generics), Some(substs)) = (generics, substs) {\n-                    let args = cx.generic_args_to_print(generics, substs);\n-                    cx.path_generic_args(Ok, args)\n-                } else {\n-                    Ok(cx)\n-                },\n+                (cx, true) => return Ok(cx),\n                 (cx, false) => self = cx,\n             }\n         }\n@@ -942,7 +933,7 @@ impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n                 let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n                 let span = self.tcx.def_span(def_id);\n                 return self.path_append(\n-                    |cx| cx.print_def_path(parent_def_id, None),\n+                    |cx| cx.print_def_path(parent_def_id, &[]),\n                     &format!(\"<impl at {:?}>\", span),\n                 );\n             }\n@@ -1073,7 +1064,7 @@ impl<F: fmt::Write> PrettyPrinter<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F>\n     fn print_value_path(\n         mut self,\n         def_id: DefId,\n-        substs: Option<SubstsRef<'tcx>>,\n+        substs: &'tcx [Kind<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         let was_in_value = std::mem::replace(&mut self.in_value, true);\n         self = self.print_def_path(def_id, substs)?;\n@@ -1476,7 +1467,7 @@ define_print_and_forward_display! {\n             ty::ExistentialPredicate::Trait(x) => p!(print(x)),\n             ty::ExistentialPredicate::Projection(x) => p!(print(x)),\n             ty::ExistentialPredicate::AutoTrait(def_id) => {\n-                p!(print_def_path(def_id, None));\n+                p!(print_def_path(def_id, &[]));\n             }\n         }\n     }\n@@ -1509,7 +1500,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::TraitRef<'tcx> {\n-        p!(print_def_path(self.def_id, Some(self.substs)));\n+        p!(print_def_path(self.def_id, self.substs));\n     }\n \n     ConstValue<'tcx> {\n@@ -1553,7 +1544,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::ProjectionTy<'tcx> {\n-        p!(print_def_path(self.item_def_id, Some(self.substs)));\n+        p!(print_def_path(self.item_def_id, self.substs));\n     }\n \n     ty::ClosureKind {\n@@ -1574,17 +1565,17 @@ define_print_and_forward_display! {\n             ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n             ty::Predicate::ObjectSafe(trait_def_id) => {\n                 p!(write(\"the trait `\"),\n-                   print_def_path(trait_def_id, None),\n+                   print_def_path(trait_def_id, &[]),\n                    write(\"` is object-safe\"))\n             }\n             ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n                 p!(write(\"the closure `\"),\n-                   print_value_path(closure_def_id, None),\n+                   print_value_path(closure_def_id, &[]),\n                    write(\"` implements the trait `{}`\", kind))\n             }\n             ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                 p!(write(\"the constant `\"),\n-                   print_value_path(def_id, Some(substs)),\n+                   print_value_path(def_id, substs),\n                    write(\"` can be evaluated\"))\n             }\n         }"}, {"sha": "6aabdf1e5661fc2b7b906725dd13fbe8f3a70243", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=8619edede1496a8d9c4131f9cb2079e71dccd5fb", "patch": "@@ -36,7 +36,7 @@ impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         ty::tls::with(|tcx| {\n             FmtPrinter::new(tcx, f, Namespace::TypeNS)\n-                .print_def_path(self.def_id, None)?;\n+                .print_def_path(self.def_id, &[])?;\n             Ok(())\n         })\n     }\n@@ -46,7 +46,7 @@ impl fmt::Debug for ty::AdtDef {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         ty::tls::with(|tcx| {\n             FmtPrinter::new(tcx, f, Namespace::TypeNS)\n-                .print_def_path(self.did, None)?;\n+                .print_def_path(self.did, &[])?;\n             Ok(())\n         })\n     }"}, {"sha": "262ba8a1c747f284e7f5347b812874302399269f", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=8619edede1496a8d9c4131f9cb2079e71dccd5fb", "patch": "@@ -227,7 +227,7 @@ fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::\n         tcx,\n         path: SymbolPath::new(),\n         keep_within_component: false,\n-    }.print_def_path(def_id, None).unwrap().path.into_interned()\n+    }.print_def_path(def_id, &[]).unwrap().path.into_interned()\n }\n \n fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n@@ -438,7 +438,7 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n             ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n             ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n             ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n-                self.print_def_path(def_id, Some(substs))\n+                self.print_def_path(def_id, substs)\n             }\n             _ => self.pretty_print_type(ty),\n         }"}, {"sha": "c4e371d5afedb58e45d0b5864c71f5b656cb4447", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=8619edede1496a8d9c4131f9cb2079e71dccd5fb", "patch": "@@ -12,7 +12,7 @@ use rustc::mir::{ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Pla\n use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n-use rustc::ty::{self, DefIdTree, TyCtxt};\n+use rustc::ty::{self, TyCtxt};\n \n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, Level};\n use rustc_data_structures::bit_set::BitSet;"}, {"sha": "da73eb0cda5db8bcff8ed57c77c14842bd08b544", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8619edede1496a8d9c4131f9cb2079e71dccd5fb", "patch": "@@ -4322,7 +4322,7 @@ pub fn get_path_for_type(\n     }\n \n     let names = AbsolutePathPrinter { tcx: tcx.global_tcx() }\n-        .print_def_path(def_id, None)\n+        .print_def_path(def_id, &[])\n         .unwrap();\n \n     hir::Path {"}, {"sha": "99fa3b96794827ee5c0922fd16498cf271607788", "filename": "src/test/ui/namespace/namespace-mix.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Ftest%2Fui%2Fnamespace%2Fnamespace-mix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8619edede1496a8d9c4131f9cb2079e71dccd5fb/src%2Ftest%2Fui%2Fnamespace%2Fnamespace-mix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnamespace%2Fnamespace-mix.stderr?ref=8619edede1496a8d9c4131f9cb2079e71dccd5fb", "patch": "@@ -462,11 +462,11 @@ note: required by `check`\n LL | fn check<T: Impossible>(_: T) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0277]: the trait bound `fn() -> namespace_mix::c::E {namespace_mix::c::E::TV}: Impossible` is not satisfied\n+error[E0277]: the trait bound `fn() -> namespace_mix::c::E {namespace_mix::xm7::TV}: Impossible` is not satisfied\n   --> $DIR/namespace-mix.rs:128:5\n    |\n LL |     check(xm9::TV);\n-   |     ^^^^^ the trait `Impossible` is not implemented for `fn() -> namespace_mix::c::E {namespace_mix::c::E::TV}`\n+   |     ^^^^^ the trait `Impossible` is not implemented for `fn() -> namespace_mix::c::E {namespace_mix::xm7::TV}`\n    |\n note: required by `check`\n   --> $DIR/namespace-mix.rs:21:1"}]}