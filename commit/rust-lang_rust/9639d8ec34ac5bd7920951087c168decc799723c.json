{"sha": "9639d8ec34ac5bd7920951087c168decc799723c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MzlkOGVjMzRhYzViZDc5MjA5NTEwODdjMTY4ZGVjYzc5OTcyM2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-11T23:05:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-12T17:56:29Z"}, "message": "add the \"provisional cache\"", "tree": {"sha": "2a6fa5df4d7db4d7094e06fc94f7e51e993da8ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a6fa5df4d7db4d7094e06fc94f7e51e993da8ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9639d8ec34ac5bd7920951087c168decc799723c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9639d8ec34ac5bd7920951087c168decc799723c", "html_url": "https://github.com/rust-lang/rust/commit/9639d8ec34ac5bd7920951087c168decc799723c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9639d8ec34ac5bd7920951087c168decc799723c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1a8a7b9869b4b2627b88f293ad92160ed826688", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1a8a7b9869b4b2627b88f293ad92160ed826688", "html_url": "https://github.com/rust-lang/rust/commit/a1a8a7b9869b4b2627b88f293ad92160ed826688"}], "stats": {"total": 196, "additions": 192, "deletions": 4}, "files": [{"sha": "4411aa6cb9401f20dedcf2bd11a735fcc162c25c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 192, "deletions": 4, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/9639d8ec34ac5bd7920951087c168decc799723c/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9639d8ec34ac5bd7920951087c168decc799723c/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=9639d8ec34ac5bd7920951087c168decc799723c", "patch": "@@ -43,7 +43,7 @@ use crate::hir;\n use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::Lock;\n use rustc_target::spec::abi::Abi;\n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt::{self, Display};\n use std::iter;\n@@ -191,7 +191,6 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n \n     /// Depth-first number of this node in the search graph -- a\n     /// pre-order index.  Basically a freshly incremented counter.\n-    #[allow(dead_code)] // TODO\n     dfn: usize,\n }\n \n@@ -880,6 +879,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(result);\n         }\n \n+        if let Some(result) = stack.cache().get_provisional(fresh_trait_ref) {\n+            debug!(\"PROVISIONAL CACHE HIT: EVAL({:?})={:?}\", fresh_trait_ref, result);\n+            stack.update_reached_depth(stack.cache().current_reached_depth());\n+            return Ok(result);\n+        }\n+\n         // Check if this is a match for something already on the\n         // stack. If so, we don't want to insert the result into the\n         // main cache (it is cycle dependent) nor the provisional\n@@ -892,20 +897,42 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let (result, dep_node) = self.in_task(|this| this.evaluate_stack(&stack));\n         let result = result?;\n \n+        if !result.must_apply_modulo_regions() {\n+            stack.cache().on_failure(stack.dfn);\n+        }\n+\n         let reached_depth = stack.reached_depth.get();\n         if reached_depth >= stack.depth {\n             debug!(\"CACHE MISS: EVAL({:?})={:?}\", fresh_trait_ref, result);\n             self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n+\n+            stack.cache().on_completion(stack.depth, |fresh_trait_ref, provisional_result| {\n+                self.insert_evaluation_cache(\n+                    obligation.param_env,\n+                    fresh_trait_ref,\n+                    dep_node,\n+                    provisional_result.max(result),\n+                );\n+            });\n         } else {\n+            debug!(\"PROVISIONAL: {:?}={:?}\", fresh_trait_ref, result);\n             debug!(\n-                \"evaluate_trait_predicate_recursively: skipping cache because {:?} \\\n+                \"evaluate_trait_predicate_recursively: caching provisionally because {:?} \\\n                  is a cycle participant (at depth {}, reached depth {})\",\n                 fresh_trait_ref,\n                 stack.depth,\n                 reached_depth,\n             );\n+\n+            stack.cache().insert_provisional(\n+                stack.dfn,\n+                reached_depth,\n+                fresh_trait_ref,\n+                result,\n+            );\n         }\n \n+\n         Ok(result)\n     }\n \n@@ -4004,18 +4031,179 @@ impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n     }\n }\n \n+/// The \"provisional evaluation cache\" is used to store intermediate cache results\n+/// when solving auto traits. Auto traits are unusual in that they can support\n+/// cycles. So, for example, a \"proof tree\" like this would be ok:\n+///\n+/// - `Foo<T>: Send` :-\n+///   - `Bar<T>: Send` :-\n+///     - `Foo<T>: Send` -- cycle, but ok\n+///   - `Baz<T>: Send`\n+///\n+/// Here, to prove `Foo<T>: Send`, we have to prove `Bar<T>: Send` and\n+/// `Baz<T>: Send`. Proving `Bar<T>: Send` in turn required `Foo<T>: Send`.\n+/// For non-auto traits, this cycle would be an error, but for auto traits (because\n+/// they are coinductive) it is considered ok.\n+///\n+/// However, there is a complication: at the point where we have\n+/// \"proven\" `Bar<T>: Send`, we have in fact only proven it\n+/// *provisionally*. In particular, we proved that `Bar<T>: Send`\n+/// *under the assumption* that `Foo<T>: Send`. But what if we later\n+/// find out this assumption is wrong?  Specifically, we could\n+/// encounter some kind of error proving `Baz<T>: Send`. In that case,\n+/// `Bar<T>: Send` didn't turn out to be true.\n+///\n+/// In Issue #60010, we found a bug in rustc where it would cache\n+/// these intermediate results. This was fixed in #60444 by disabling\n+/// *all* caching for things involved in a cycle -- in our example,\n+/// that would mean we don't cache that `Bar<T>: Send`.  But this led\n+/// to large slowdowns.\n+///\n+/// Specifically, imagine this scenario, where proving `Baz<T>: Send`\n+/// first requires proving `Bar<T>: Send` (which is true:\n+///\n+/// - `Foo<T>: Send` :-\n+///   - `Bar<T>: Send` :-\n+///     - `Foo<T>: Send` -- cycle, but ok\n+///   - `Baz<T>: Send`\n+///     - `Bar<T>: Send` -- would be nice for this to be a cache hit!\n+///     - `*const T: Send` -- but what if we later encounter an error?\n+///\n+/// The *provisional evaluation cache* resolves this issue. It stores\n+/// cache results that we've proven but which were involved in a cycle\n+/// in some way. We track the minimal stack depth (i.e., the\n+/// farthest from the top of the stack) that we are dependent on.\n+/// The idea is that the cache results within are all valid -- so long as\n+/// none of the nodes in between the current node and the node at that minimum\n+/// depth result in an error (in which case the cached results are just thrown away).\n+///\n+/// During evaluation, we consult this provisional cache and rely on\n+/// it. Accessing a cached value is considered equivalent to accessing\n+/// a result at `reached_depth`, so it marks the *current* solution as\n+/// provisional as well. If an error is encountered, we toss out any\n+/// provisional results added from the subtree that encountered the\n+/// error.  When we pop the node at `reached_depth` from the stack, we\n+/// can commit all the things that remain in the provisional cache.\n #[derive(Default)]\n struct ProvisionalEvaluationCache<'tcx> {\n+    /// next \"depth first number\" to issue -- just a counter\n     dfn: Cell<usize>,\n-    _dummy: Vec<&'tcx ()>,\n+\n+    /// Stores the \"coldest\" depth (bottom of stack) reached by any of\n+    /// the evaluation entries. The idea here is that all things in the provisional\n+    /// cache are always dependent on *something* that is colder in the stack:\n+    /// therefore, if we add a new entry that is dependent on something *colder still*,\n+    /// we have to modify the depth for all entries at once.\n+    ///\n+    /// Example:\n+    ///\n+    /// Imagine we have a stack `A B C D E` (with `E` being the top of\n+    /// the stack).  We cache something with depth 2, which means that\n+    /// it was dependent on C.  Then we pop E but go on and process a\n+    /// new node F: A B C D F.  Now F adds something to the cache with\n+    /// depth 1, meaning it is dependent on B.  Our original cache\n+    /// entry is also dependent on B, because there is a path from E\n+    /// to C and then from C to F and from F to B.\n+    reached_depth: Cell<usize>,\n+\n+    /// Map from cache key to the provisionally evaluated thing.\n+    /// The cache entries contain the result but also the DFN in which they\n+    /// were added. The DFN is used to clear out values on failure.\n+    ///\n+    /// Imagine we have a stack like:\n+    ///\n+    /// - `A B C` and we add a cache for the result of C (DFN 2)\n+    /// - Then we have a stack `A B D` where `D` has DFN 3\n+    /// - We try to solve D by evaluating E: `A B D E` (DFN 4)\n+    /// - `E` generates various cache entries which have cyclic dependices on `B`\n+    ///   - `A B D E F` and so forth\n+    ///   - the DFN of `F` for example would be 5\n+    /// - then we determine that `E` is in error -- we will then clear\n+    ///   all cache values whose DFN is >= 4 -- in this case, that\n+    ///   means the cached value for `F`.\n+    map: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, ProvisionalEvaluation>>,\n+}\n+\n+/// A cache value for the provisional cache: contains the depth-first\n+/// number (DFN) and result.\n+#[derive(Copy, Clone)]\n+struct ProvisionalEvaluation {\n+    from_dfn: usize,\n+    result: EvaluationResult,\n }\n \n impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n+    /// Get the next DFN in sequence (basically a counter).\n     fn next_dfn(&self) -> usize {\n         let result = self.dfn.get();\n         self.dfn.set(result + 1);\n         result\n     }\n+\n+    /// Check the provisional cache for any result for\n+    /// `fresh_trait_ref`. If there is a hit, then you must consider\n+    /// it an access to the stack slots at depth\n+    /// `self.current_reached_depth()` and above.\n+    fn get_provisional(&self, fresh_trait_ref: ty::PolyTraitRef<'tcx>) -> Option<EvaluationResult> {\n+        Some(self.map.borrow().get(&fresh_trait_ref)?.result)\n+    }\n+\n+    /// Current value of the `reached_depth` counter -- all the\n+    /// provisional cache entries are dependent on the item at this\n+    /// depth.\n+    fn current_reached_depth(&self) -> usize {\n+        self.reached_depth.get()\n+    }\n+\n+    /// Insert a provisional result into the cache. The result came\n+    /// from the node with the given DFN. It accessed a minimum depth\n+    /// of `reached_depth` to compute. It evaluated `fresh_trait_ref`\n+    /// and resulted in `result`.\n+    fn insert_provisional(\n+        &self,\n+        from_dfn: usize,\n+        reached_depth: usize,\n+        fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n+        result: EvaluationResult,\n+    ) {\n+        let r_d = self.reached_depth.get();\n+        self.reached_depth.set(r_d.min(reached_depth));\n+\n+        self.map.borrow_mut().insert(fresh_trait_ref, ProvisionalEvaluation { from_dfn, result });\n+    }\n+\n+    /// Invoked when the node with dfn `dfn` does not get a successful\n+    /// result.  This will clear out any provisional cache entries\n+    /// that were added since `dfn` was created. This is because the\n+    /// provisional entries are things which must assume that the\n+    /// things on the stack at the time of their creation succeeded --\n+    /// since the failing node is presently at the top of the stack,\n+    /// these provisional entries must either depend on it or some\n+    /// ancestor of it.\n+    fn on_failure(&self, dfn: usize) {\n+        self.map.borrow_mut().retain(|_key, eval| eval.from_dfn >= dfn)\n+    }\n+\n+    /// Invoked when the node at depth `depth` completed without\n+    /// depending on anything higher in the stack (if that completion\n+    /// was a failure, then `on_failure` should have been invoked\n+    /// already). The callback `op` will be invoked for each\n+    /// provisional entry that we can now confirm.\n+    fn on_completion(\n+        &self,\n+        depth: usize,\n+        mut op: impl FnMut(ty::PolyTraitRef<'tcx>, EvaluationResult),\n+    ) {\n+        if self.reached_depth.get() < depth {\n+            return;\n+        }\n+\n+        for (fresh_trait_ref, eval) in self.map.borrow_mut().drain() {\n+            op(fresh_trait_ref, eval.result);\n+        }\n+\n+        self.reached_depth.set(depth);\n+    }\n }\n \n #[derive(Copy, Clone)]"}]}