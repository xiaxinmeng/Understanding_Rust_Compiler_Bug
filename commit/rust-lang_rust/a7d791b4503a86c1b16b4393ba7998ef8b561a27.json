{"sha": "a7d791b4503a86c1b16b4393ba7998ef8b561a27", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZDc5MWI0NTAzYTg2YzFiMTZiNDM5M2JhNzk5OGVmOGI1NjFhMjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-26T20:38:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-26T20:38:47Z"}, "message": "Auto merge of #66646 - RalfJung:unwind_to_block, r=oli-obk\n\nrefactor goto_block and also add unwind_to_block\n\nr? @oli-obk", "tree": {"sha": "b9d873e9b6250bbd6e33bcfb57aafd25c2c34cbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9d873e9b6250bbd6e33bcfb57aafd25c2c34cbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7d791b4503a86c1b16b4393ba7998ef8b561a27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7d791b4503a86c1b16b4393ba7998ef8b561a27", "html_url": "https://github.com/rust-lang/rust/commit/a7d791b4503a86c1b16b4393ba7998ef8b561a27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7d791b4503a86c1b16b4393ba7998ef8b561a27/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "797fd92628842c1f5face9fb93b0fe4f1f9d297f", "url": "https://api.github.com/repos/rust-lang/rust/commits/797fd92628842c1f5face9fb93b0fe4f1f9d297f", "html_url": "https://github.com/rust-lang/rust/commit/797fd92628842c1f5face9fb93b0fe4f1f9d297f"}, {"sha": "6797d52ee02b19675621718dca823794ffb921b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6797d52ee02b19675621718dca823794ffb921b5", "html_url": "https://github.com/rust-lang/rust/commit/6797d52ee02b19675621718dca823794ffb921b5"}], "stats": {"total": 271, "additions": 136, "deletions": 135}, "files": [{"sha": "640b5fbdff31e983d25722218a353c377c023dea", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a7d791b4503a86c1b16b4393ba7998ef8b561a27/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d791b4503a86c1b16b4393ba7998ef8b561a27/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=a7d791b4503a86c1b16b4393ba7998ef8b561a27", "patch": "@@ -323,8 +323,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n-        ret: Option<mir::BasicBlock>,\n+        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock> // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         debug!(\"eval_fn_call: {:?}\", instance);\n@@ -337,8 +336,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 // Some functions we support even if they are non-const -- but avoid testing\n                 // that for const fn!  We certainly do *not* want to actually call the fn\n                 // though, so be sure we return here.\n-                return if ecx.hook_panic_fn(instance, args, dest)? {\n-                    ecx.goto_block(ret)?; // fully evaluated and done\n+                return if ecx.hook_panic_fn(instance, args, ret)? {\n                     Ok(None)\n                 } else {\n                     throw_unsup_format!(\"calling non-const function `{}`\", instance)\n@@ -364,8 +362,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         fn_val: !,\n         _args: &[OpTy<'tcx>],\n-        _dest: Option<PlaceTy<'tcx>>,\n-        _ret: Option<mir::BasicBlock>,\n+        _ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        _unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx> {\n         match fn_val {}\n     }\n@@ -375,11 +373,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n-        dest: Option<PlaceTy<'tcx>>,\n-        _ret: Option<mir::BasicBlock>,\n+        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx> {\n-        if ecx.emulate_intrinsic(span, instance, args, dest)? {\n+        if ecx.emulate_intrinsic(span, instance, args, ret)? {\n             return Ok(());\n         }\n         // An intrinsic that we do not support"}, {"sha": "2be27e41090a65151c4e34096b81edaae5ad5aab", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a7d791b4503a86c1b16b4393ba7998ef8b561a27/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d791b4503a86c1b16b4393ba7998ef8b561a27/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=a7d791b4503a86c1b16b4393ba7998ef8b561a27", "patch": "@@ -555,6 +555,37 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n+    /// Jump to the given block.\n+    #[inline]\n+    pub fn go_to_block(&mut self, target: mir::BasicBlock) {\n+        let frame = self.frame_mut();\n+        frame.block = Some(target);\n+        frame.stmt = 0;\n+    }\n+\n+    /// *Return* to the given `target` basic block.\n+    /// Do *not* use for unwinding! Use `unwind_to_block` instead.\n+    ///\n+    /// If `target` is `None`, that indicates the function cannot return, so we raise UB.\n+    pub fn return_to_block(&mut self, target: Option<mir::BasicBlock>) -> InterpResult<'tcx> {\n+        if let Some(target) = target {\n+            Ok(self.go_to_block(target))\n+        } else {\n+            throw_ub!(Unreachable)\n+        }\n+    }\n+\n+    /// *Unwind* to the given `target` basic block.\n+    /// Do *not* use for returning! Use `return_to_block` instead.\n+    ///\n+    /// If `target` is `None`, that indicates the function does not need cleanup during\n+    /// unwinding, and we will just keep propagating that upwards.\n+    pub fn unwind_to_block(&mut self, target: Option<mir::BasicBlock>) {\n+        let frame = self.frame_mut();\n+        frame.block = target;\n+        frame.stmt = 0;\n+    }\n+\n     /// Pops the current frame from the stack, deallocating the\n     /// memory for allocated locals.\n     ///\n@@ -630,10 +661,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         if cur_unwinding {\n             // Follow the unwind edge.\n             let unwind = next_block.expect(\"Encounted StackPopCleanup::None when unwinding!\");\n-            let next_frame = self.frame_mut();\n-            // If `unwind` is `None`, we'll leave that function immediately again.\n-            next_frame.block = unwind;\n-            next_frame.stmt = 0;\n+            self.unwind_to_block(unwind);\n         } else {\n             // Follow the normal return edge.\n             // Validate the return value. Do this after deallocating so that we catch dangling\n@@ -660,7 +688,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             // Jump to new block -- *after* validation so that the spans make more sense.\n             if let Some(ret) = next_block {\n-                self.goto_block(ret)?;\n+                self.return_to_block(ret)?;\n             }\n         }\n "}, {"sha": "7bcf84a7b2dd609befc9b91d225ab90997be45c5", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 44, "deletions": 31, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a7d791b4503a86c1b16b4393ba7998ef8b561a27/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d791b4503a86c1b16b4393ba7998ef8b561a27/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=a7d791b4503a86c1b16b4393ba7998ef8b561a27", "patch": "@@ -9,8 +9,10 @@ use rustc::ty::layout::{LayoutOf, Primitive, Size};\n use rustc::ty::subst::SubstsRef;\n use rustc::hir::def_id::DefId;\n use rustc::ty::TyCtxt;\n-use rustc::mir::BinOp;\n-use rustc::mir::interpret::{InterpResult, Scalar, GlobalId, ConstValue};\n+use rustc::mir::{\n+    self, BinOp,\n+    interpret::{InterpResult, Scalar, GlobalId, ConstValue}\n+};\n \n use super::{\n     Machine, PlaceTy, OpTy, InterpCx, ImmTy,\n@@ -91,16 +93,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n+        ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx, bool> {\n         let substs = instance.substs;\n+        let intrinsic_name = &*self.tcx.item_name(instance.def_id()).as_str();\n \n-        // We currently do not handle any diverging intrinsics.\n-        let dest = match dest {\n-            Some(dest) => dest,\n-            None => return Ok(false)\n+        // We currently do not handle any intrinsics that are *allowed* to diverge,\n+        // but `transmute` could lack a return place in case of UB.\n+        let (dest, ret) = match ret {\n+            Some(p) => p,\n+            None => match intrinsic_name {\n+                \"transmute\" => throw_ub!(Unreachable),\n+                _ => return Ok(false),\n+            }\n         };\n-        let intrinsic_name = &*self.tcx.item_name(instance.def_id()).as_str();\n \n         match intrinsic_name {\n             \"caller_location\" => {\n@@ -268,34 +274,39 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // exception from the exception.)\n                 // This is the dual to the special exception for offset-by-0\n                 // in the inbounds pointer offset operation (see the Miri code, `src/operator.rs`).\n-                if a.is_bits() && b.is_bits() {\n+                //\n+                // Control flow is weird because we cannot early-return (to reach the\n+                // `go_to_block` at the end).\n+                let done = if a.is_bits() && b.is_bits() {\n                     let a = a.to_machine_usize(self)?;\n                     let b = b.to_machine_usize(self)?;\n                     if a == b && a != 0 {\n                         self.write_scalar(Scalar::from_int(0, isize_layout.size), dest)?;\n-                        return Ok(true);\n-                    }\n-                }\n+                        true\n+                    } else { false }\n+                } else { false };\n \n-                // General case: we need two pointers.\n-                let a = self.force_ptr(a)?;\n-                let b = self.force_ptr(b)?;\n-                if a.alloc_id != b.alloc_id {\n-                    throw_ub_format!(\n-                        \"ptr_offset_from cannot compute offset of pointers into different \\\n-                        allocations.\",\n-                    );\n+                if !done {\n+                    // General case: we need two pointers.\n+                    let a = self.force_ptr(a)?;\n+                    let b = self.force_ptr(b)?;\n+                    if a.alloc_id != b.alloc_id {\n+                        throw_ub_format!(\n+                            \"ptr_offset_from cannot compute offset of pointers into different \\\n+                            allocations.\",\n+                        );\n+                    }\n+                    let usize_layout = self.layout_of(self.tcx.types.usize)?;\n+                    let a_offset = ImmTy::from_uint(a.offset.bytes(), usize_layout);\n+                    let b_offset = ImmTy::from_uint(b.offset.bytes(), usize_layout);\n+                    let (val, _overflowed, _ty) = self.overflowing_binary_op(\n+                        BinOp::Sub, a_offset, b_offset,\n+                    )?;\n+                    let pointee_layout = self.layout_of(substs.type_at(0))?;\n+                    let val = ImmTy::from_scalar(val, isize_layout);\n+                    let size = ImmTy::from_int(pointee_layout.size.bytes(), isize_layout);\n+                    self.exact_div(val, size, dest)?;\n                 }\n-                let usize_layout = self.layout_of(self.tcx.types.usize)?;\n-                let a_offset = ImmTy::from_uint(a.offset.bytes(), usize_layout);\n-                let b_offset = ImmTy::from_uint(b.offset.bytes(), usize_layout);\n-                let (val, _overflowed, _ty) = self.overflowing_binary_op(\n-                    BinOp::Sub, a_offset, b_offset,\n-                )?;\n-                let pointee_layout = self.layout_of(substs.type_at(0))?;\n-                let val = ImmTy::from_scalar(val, isize_layout);\n-                let size = ImmTy::from_int(pointee_layout.size.bytes(), isize_layout);\n-                self.exact_div(val, size, dest)?;\n             }\n \n             \"transmute\" => {\n@@ -350,6 +361,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => return Ok(false),\n         }\n \n+        self.dump_place(*dest);\n+        self.go_to_block(ret);\n         Ok(true)\n     }\n \n@@ -360,7 +373,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        _dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n+        _ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx, bool> {\n         let def_id = instance.def_id();\n         if Some(def_id) == self.tcx.lang_items().panic_fn() {"}, {"sha": "d2ea55a5d3c8875a94474fbe0b13b4814c557075", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a7d791b4503a86c1b16b4393ba7998ef8b561a27/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d791b4503a86c1b16b4393ba7998ef8b561a27/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=a7d791b4503a86c1b16b4393ba7998ef8b561a27", "patch": "@@ -141,7 +141,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Returns either the mir to use for the call, or `None` if execution should\n     /// just proceed (which usually means this hook did all the work that the\n     /// called function should usually have done). In the latter case, it is\n-    /// this hook's responsibility to call `goto_block(ret)` to advance the instruction pointer!\n+    /// this hook's responsibility to advance the instruction pointer!\n     /// (This is to support functions like `__rust_maybe_catch_panic` that neither find a MIR\n     /// nor just jump to `ret`, but instead push their own stack frame.)\n     /// Passing `dest`and `ret` in the same `Option` proved very annoying when only one of them\n@@ -150,30 +150,28 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n-        dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n-        ret: Option<mir::BasicBlock>,\n-        unwind: Option<mir::BasicBlock>\n+        ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n+        unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>>;\n \n-    /// Execute `fn_val`.  it is the hook's responsibility to advance the instruction\n+    /// Execute `fn_val`.  It is the hook's responsibility to advance the instruction\n     /// pointer as appropriate.\n     fn call_extra_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         fn_val: Self::ExtraFnVal,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n-        dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n-        ret: Option<mir::BasicBlock>,\n+        ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n+        unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx>;\n \n-    /// Directly process an intrinsic without pushing a stack frame.\n-    /// If this returns successfully, the engine will take care of jumping to the next block.\n+    /// Directly process an intrinsic without pushing a stack frame. It is the hook's\n+    /// responsibility to advance the instruction pointer as appropriate.\n     fn call_intrinsic(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n-        dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n-        ret: Option<mir::BasicBlock>,\n+        ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx>;\n "}, {"sha": "daa0a5e1bc4dd13729574e9d691723fb06dec523", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 40, "deletions": 73, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a7d791b4503a86c1b16b4393ba7998ef8b561a27/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d791b4503a86c1b16b4393ba7998ef8b561a27/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=a7d791b4503a86c1b16b4393ba7998ef8b561a27", "patch": "@@ -12,17 +12,6 @@ use super::{\n };\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    #[inline]\n-    pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> InterpResult<'tcx> {\n-        if let Some(target) = target {\n-            self.frame_mut().block = Some(target);\n-            self.frame_mut().stmt = 0;\n-            Ok(())\n-        } else {\n-            throw_ub!(Unreachable)\n-        }\n-    }\n-\n     pub(super) fn eval_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n@@ -34,7 +23,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.pop_stack_frame(/* unwinding */ false)?\n             }\n \n-            Goto { target } => self.goto_block(Some(target))?,\n+            Goto { target } => self.go_to_block(target),\n \n             SwitchInt {\n                 ref discr,\n@@ -60,7 +49,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 }\n \n-                self.goto_block(Some(target_block))?;\n+                self.go_to_block(target_block);\n             }\n \n             Call {\n@@ -70,11 +59,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 ref cleanup,\n                 ..\n             } => {\n-                let (dest, ret) = match *destination {\n-                    Some((ref lv, target)) => (Some(self.eval_place(lv)?), Some(target)),\n-                    None => (None, None),\n-                };\n-\n                 let func = self.eval_operand(func, None)?;\n                 let (fn_val, abi) = match func.layout.ty.kind {\n                     ty::FnPtr(sig) => {\n@@ -92,12 +76,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 };\n                 let args = self.eval_operands(args)?;\n+                let ret = match destination {\n+                    Some((dest, ret)) => Some((self.eval_place(dest)?, *ret)),\n+                    None => None,\n+                };\n                 self.eval_fn_call(\n                     fn_val,\n                     terminator.source_info.span,\n                     abi,\n                     &args[..],\n-                    dest,\n                     ret,\n                     *cleanup\n                 )?;\n@@ -133,7 +120,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let cond_val = self.read_immediate(self.eval_operand(cond, None)?)?\n                     .to_scalar()?.to_bool()?;\n                 if expected == cond_val {\n-                    self.goto_block(Some(target))?;\n+                    self.go_to_block(target);\n                 } else {\n                     // Compute error message\n                     use rustc::mir::interpret::PanicInfo::*;\n@@ -249,41 +236,46 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         span: Span,\n         caller_abi: Abi,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n-        ret: Option<mir::BasicBlock>,\n+        ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", fn_val);\n \n         let instance = match fn_val {\n             FnVal::Instance(instance) => instance,\n             FnVal::Other(extra) => {\n-                return M::call_extra_fn(self, extra, args, dest, ret);\n+                return M::call_extra_fn(self, extra, args, ret, unwind);\n             }\n         };\n \n+        // ABI check\n+        {\n+            let callee_abi = {\n+                let instance_ty = instance.ty(*self.tcx);\n+                match instance_ty.kind {\n+                    ty::FnDef(..) =>\n+                        instance_ty.fn_sig(*self.tcx).abi(),\n+                    ty::Closure(..) => Abi::RustCall,\n+                    ty::Generator(..) => Abi::Rust,\n+                    _ => bug!(\"unexpected callee ty: {:?}\", instance_ty),\n+                }\n+            };\n+            let normalize_abi = |abi| match abi {\n+                Abi::Rust | Abi::RustCall | Abi::RustIntrinsic | Abi::PlatformIntrinsic =>\n+                    // These are all the same ABI, really.\n+                    Abi::Rust,\n+                abi =>\n+                    abi,\n+            };\n+            if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n+                throw_unsup!(FunctionAbiMismatch(caller_abi, callee_abi))\n+            }\n+        }\n+\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n                 assert!(caller_abi == Abi::RustIntrinsic || caller_abi == Abi::PlatformIntrinsic);\n-\n-                let old_stack = self.cur_frame();\n-                let old_bb = self.frame().block;\n-                M::call_intrinsic(self, span, instance, args, dest, ret, unwind)?;\n-                // No stack frame gets pushed, the main loop will just act as if the\n-                // call completed.\n-                if ret.is_some() {\n-                    self.goto_block(ret)?;\n-                } else {\n-                    // If this intrinsic call doesn't have a ret block,\n-                    // then the intrinsic implementation should have\n-                    // changed the stack frame (otherwise, we'll end\n-                    // up trying to execute this intrinsic call again)\n-                    debug_assert!(self.cur_frame() != old_stack || self.frame().block != old_bb);\n-                }\n-                if let Some(dest) = dest {\n-                    self.dump_place(*dest)\n-                }\n-                Ok(())\n+                return M::call_intrinsic(self, span, instance, args, ret, unwind);\n             }\n             ty::InstanceDef::VtableShim(..) |\n             ty::InstanceDef::ReifyShim(..) |\n@@ -292,32 +284,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::InstanceDef::DropGlue(..) |\n             ty::InstanceDef::CloneShim(..) |\n             ty::InstanceDef::Item(_) => {\n-                // ABI check\n-                {\n-                    let callee_abi = {\n-                        let instance_ty = instance.ty(*self.tcx);\n-                        match instance_ty.kind {\n-                            ty::FnDef(..) =>\n-                                instance_ty.fn_sig(*self.tcx).abi(),\n-                            ty::Closure(..) => Abi::RustCall,\n-                            ty::Generator(..) => Abi::Rust,\n-                            _ => bug!(\"unexpected callee ty: {:?}\", instance_ty),\n-                        }\n-                    };\n-                    let normalize_abi = |abi| match abi {\n-                        Abi::Rust | Abi::RustCall | Abi::RustIntrinsic | Abi::PlatformIntrinsic =>\n-                            // These are all the same ABI, really.\n-                            Abi::Rust,\n-                        abi =>\n-                            abi,\n-                    };\n-                    if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n-                        throw_unsup!(FunctionAbiMismatch(caller_abi, callee_abi))\n-                    }\n-                }\n-\n                 // We need MIR for this fn\n-                let body = match M::find_fn(self, instance, args, dest, ret, unwind)? {\n+                let body = match M::find_fn(self, instance, args, ret, unwind)? {\n                     Some(body) => body,\n                     None => return Ok(()),\n                 };\n@@ -326,8 +294,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     instance,\n                     span,\n                     body,\n-                    dest,\n-                    StackPopCleanup::Goto { ret, unwind }\n+                    ret.map(|p| p.0),\n+                    StackPopCleanup::Goto { ret: ret.map(|p| p.1), unwind }\n                 )?;\n \n                 // We want to pop this frame again in case there was an error, to put\n@@ -410,7 +378,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         throw_unsup!(FunctionArgCountMismatch)\n                     }\n                     // Don't forget to check the return type!\n-                    if let Some(caller_ret) = dest {\n+                    if let Some((caller_ret, _)) = ret {\n                         let callee_ret = self.eval_place(\n                             &mir::Place::return_place()\n                         )?;\n@@ -476,7 +444,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 });\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(drop_fn, span, caller_abi, &args, dest, ret, unwind)\n+                self.eval_fn_call(drop_fn, span, caller_abi, &args, ret, unwind)\n             }\n         }\n     }\n@@ -516,8 +484,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             span,\n             Abi::Rust,\n             &[arg.into()],\n-            Some(dest.into()),\n-            Some(target),\n+            Some((dest.into(), target)),\n             unwind\n         )\n     }"}, {"sha": "1114694d2e335aebcc5bef3e231bd8724bbeaa3d", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7d791b4503a86c1b16b4393ba7998ef8b561a27/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d791b4503a86c1b16b4393ba7998ef8b561a27/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=a7d791b4503a86c1b16b4393ba7998ef8b561a27", "patch": "@@ -144,8 +144,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _instance: ty::Instance<'tcx>,\n         _args: &[OpTy<'tcx>],\n-        _dest: Option<PlaceTy<'tcx>>,\n-        _ret: Option<BasicBlock>,\n+        _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: Option<BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir Body<'tcx>>> {\n         Ok(None)\n@@ -155,8 +154,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         fn_val: !,\n         _args: &[OpTy<'tcx>],\n-        _dest: Option<PlaceTy<'tcx>>,\n-        _ret: Option<BasicBlock>,\n+        _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n+        _unwind: Option<BasicBlock>\n     ) -> InterpResult<'tcx> {\n         match fn_val {}\n     }\n@@ -166,8 +165,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _span: Span,\n         _instance: ty::Instance<'tcx>,\n         _args: &[OpTy<'tcx>],\n-        _dest: Option<PlaceTy<'tcx>>,\n-        _ret: Option<BasicBlock>,\n+        _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: Option<BasicBlock>\n     ) -> InterpResult<'tcx> {\n         throw_unsup_format!(\"calling intrinsics isn't supported in ConstProp\");"}]}