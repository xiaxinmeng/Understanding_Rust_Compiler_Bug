{"sha": "07a47e0708fd8d37dd6f15eec1a4202c7da810e2", "node_id": "C_kwDOAAsO6NoAKDA3YTQ3ZTA3MDhmZDhkMzdkZDZmMTVlZWMxYTQyMDJjN2RhODEwZTI", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-09T20:19:31Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-09T20:28:07Z"}, "message": "Emit error in `collecting_trait_impl_trait_tys` on mismatched signatures\n\nPreviously, a `delay_span_bug` was isssued, failing normalization. This\ncreate a `TyKind::Error` in the signature, which caused\n`compare_predicate_entailment` to swallow its signature mismatch error,\ncausing ICEs because no error was emitted.", "tree": {"sha": "2c54fcada76d0f85db3ac83e285eedf01b5cff76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c54fcada76d0f85db3ac83e285eedf01b5cff76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07a47e0708fd8d37dd6f15eec1a4202c7da810e2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAgbSfWKRQb2tiqhuHtakDJeupmrF\nChDbM0msU+PXaBOk8AAAADZ2l0AAAAAAAAAAZzaGE1MTIAAABTAAAAC3NzaC1lZDI1NTE5\nAAAAQDAsS3//PVojY2wabrqx8V+XvYpmEeLC/7S787zgWeon7V5NaFSJMVY7lsKSM1Ddcr\nCBmKp8uzPElVv/YFi31gA=\n-----END SSH SIGNATURE-----", "payload": "tree 2c54fcada76d0f85db3ac83e285eedf01b5cff76\nparent cc9b259b5e94e4543b96dca236e3a1af5ec496c9\nauthor Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1668025171 +0100\ncommitter Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1668025687 +0100\n\nEmit error in `collecting_trait_impl_trait_tys` on mismatched signatures\n\nPreviously, a `delay_span_bug` was isssued, failing normalization. This\ncreate a `TyKind::Error` in the signature, which caused\n`compare_predicate_entailment` to swallow its signature mismatch error,\ncausing ICEs because no error was emitted.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07a47e0708fd8d37dd6f15eec1a4202c7da810e2", "html_url": "https://github.com/rust-lang/rust/commit/07a47e0708fd8d37dd6f15eec1a4202c7da810e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07a47e0708fd8d37dd6f15eec1a4202c7da810e2/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc9b259b5e94e4543b96dca236e3a1af5ec496c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc9b259b5e94e4543b96dca236e3a1af5ec496c9", "html_url": "https://github.com/rust-lang/rust/commit/cc9b259b5e94e4543b96dca236e3a1af5ec496c9"}], "stats": {"total": 382, "additions": 277, "deletions": 105}, "files": [{"sha": "7c99896b4571427d08543e8031e4ab20b99e30b8", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 142, "deletions": 105, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/07a47e0708fd8d37dd6f15eec1a4202c7da810e2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a47e0708fd8d37dd6f15eec1a4202c7da810e2/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=07a47e0708fd8d37dd6f15eec1a4202c7da810e2", "patch": "@@ -9,14 +9,15 @@ use rustc_hir::intravisit;\n use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{self, TyCtxtInferExt};\n+use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::util::ExplicitSelf;\n-use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{\n-    self, AssocItem, DefIdTree, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+    self, AssocItem, DefIdTree, TraitRef, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable,\n+    TypeVisitable,\n };\n+use rustc_middle::ty::{FnSig, InternalSubsts};\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n@@ -303,102 +304,19 @@ fn compare_predicate_entailment<'tcx>(\n     }\n \n     if let Err(terr) = result {\n-        debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n+        debug!(?terr, \"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n \n-        let (impl_err_span, trait_err_span) =\n-            extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n-\n-        cause.span = impl_err_span;\n-\n-        let mut diag = struct_span_err!(\n-            tcx.sess,\n-            cause.span(),\n-            E0053,\n-            \"method `{}` has an incompatible type for trait\",\n-            trait_m.name\n-        );\n-        match &terr {\n-            TypeError::ArgumentMutability(0) | TypeError::ArgumentSorts(_, 0)\n-                if trait_m.fn_has_self_parameter =>\n-            {\n-                let ty = trait_sig.inputs()[0];\n-                let sugg = match ExplicitSelf::determine(ty, |_| ty == impl_trait_ref.self_ty()) {\n-                    ExplicitSelf::ByValue => \"self\".to_owned(),\n-                    ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n-                    ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n-                    _ => format!(\"self: {ty}\"),\n-                };\n-\n-                // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n-                // span points only at the type `Box<Self`>, but we want to cover the whole\n-                // argument pattern and type.\n-                let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                    ImplItemKind::Fn(ref sig, body) => tcx\n-                        .hir()\n-                        .body_param_names(body)\n-                        .zip(sig.decl.inputs.iter())\n-                        .map(|(param, ty)| param.span.to(ty.span))\n-                        .next()\n-                        .unwrap_or(impl_err_span),\n-                    _ => bug!(\"{:?} is not a method\", impl_m),\n-                };\n-\n-                diag.span_suggestion(\n-                    span,\n-                    \"change the self-receiver type to match the trait\",\n-                    sugg,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(_, i) => {\n-                if trait_sig.inputs().len() == *i {\n-                    // Suggestion to change output type. We do not suggest in `async` functions\n-                    // to avoid complex logic or incorrect output.\n-                    match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                        ImplItemKind::Fn(ref sig, _)\n-                            if sig.header.asyncness == hir::IsAsync::NotAsync =>\n-                        {\n-                            let msg = \"change the output type to match the trait\";\n-                            let ap = Applicability::MachineApplicable;\n-                            match sig.decl.output {\n-                                hir::FnRetTy::DefaultReturn(sp) => {\n-                                    let sugg = format!(\"-> {} \", trait_sig.output());\n-                                    diag.span_suggestion_verbose(sp, msg, sugg, ap);\n-                                }\n-                                hir::FnRetTy::Return(hir_ty) => {\n-                                    let sugg = trait_sig.output();\n-                                    diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n-                                }\n-                            };\n-                        }\n-                        _ => {}\n-                    };\n-                } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n-                    diag.span_suggestion(\n-                        impl_err_span,\n-                        \"change the parameter type to match the trait\",\n-                        trait_ty,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        infcx.err_ctxt().note_type_err(\n-            &mut diag,\n-            &cause,\n-            trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n-            Some(infer::ValuePairs::Terms(ExpectedFound {\n-                expected: trait_fty.into(),\n-                found: impl_fty.into(),\n-            })),\n+        let emitted = report_trait_method_mismatch(\n+            tcx,\n+            &mut cause,\n+            &infcx,\n             terr,\n-            false,\n-            false,\n+            (trait_m, trait_fty),\n+            (impl_m, impl_fty),\n+            &trait_sig,\n+            &impl_trait_ref,\n         );\n-\n-        return Err(diag.emit());\n+        return Err(emitted);\n     }\n \n     // Check that all obligations are satisfied by the implementation's\n@@ -424,6 +342,7 @@ fn compare_predicate_entailment<'tcx>(\n     Ok(())\n }\n \n+#[instrument(skip(tcx), level = \"debug\", ret)]\n pub fn collect_trait_impl_trait_tys<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n@@ -437,7 +356,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n \n     let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n     let return_span = tcx.hir().fn_decl_by_hir_id(impl_m_hir_id).unwrap().output.span();\n-    let cause = ObligationCause::new(\n+    let mut cause = ObligationCause::new(\n         return_span,\n         impl_m_hir_id,\n         ObligationCauseCode::CompareImplItemObligation {\n@@ -514,23 +433,35 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n         }\n     }\n \n+    debug!(?trait_sig, ?impl_sig, \"equating function signatures\");\n+\n+    let trait_fty = tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig));\n+    let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n+\n     // Unify the whole function signature. We need to do this to fully infer\n     // the lifetimes of the return type, but do this after unifying just the\n     // return types, since we want to avoid duplicating errors from\n     // `compare_predicate_entailment`.\n-    match infcx\n-        .at(&cause, param_env)\n-        .eq(tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig)), tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig)))\n-    {\n+    match infcx.at(&cause, param_env).eq(trait_fty, impl_fty) {\n         Ok(infer::InferOk { value: (), obligations }) => {\n             ocx.register_obligations(obligations);\n         }\n         Err(terr) => {\n-            let guar = tcx.sess.delay_span_bug(\n-                return_span,\n-                format!(\"could not unify `{trait_sig}` and `{impl_sig}`: {terr:?}\"),\n+            // This function gets called during `compare_predicate_entailment` when normalizing a\n+            // signature that contains RPITIT. When the method signatures don't match, we have to\n+            // emit an error now because `compare_predicate_entailment` will not report the error\n+            // when normalization fails.\n+            let emitted = report_trait_method_mismatch(\n+                tcx,\n+                &mut cause,\n+                infcx,\n+                terr,\n+                (trait_m, trait_fty),\n+                (impl_m, impl_fty),\n+                &trait_sig,\n+                &impl_trait_ref,\n             );\n-            return Err(guar);\n+            return Err(emitted);\n         }\n     }\n \n@@ -690,6 +621,112 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n     }\n }\n \n+fn report_trait_method_mismatch<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cause: &mut ObligationCause<'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n+    terr: TypeError<'tcx>,\n+    (trait_m, trait_fty): (&AssocItem, Ty<'tcx>),\n+    (impl_m, impl_fty): (&AssocItem, Ty<'tcx>),\n+    trait_sig: &FnSig<'tcx>,\n+    impl_trait_ref: &TraitRef<'tcx>,\n+) -> ErrorGuaranteed {\n+    let (impl_err_span, trait_err_span) =\n+        extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n+\n+    cause.span = impl_err_span;\n+\n+    let mut diag = struct_span_err!(\n+        tcx.sess,\n+        cause.span(),\n+        E0053,\n+        \"method `{}` has an incompatible type for trait\",\n+        trait_m.name\n+    );\n+    match &terr {\n+        TypeError::ArgumentMutability(0) | TypeError::ArgumentSorts(_, 0)\n+            if trait_m.fn_has_self_parameter =>\n+        {\n+            let ty = trait_sig.inputs()[0];\n+            let sugg = match ExplicitSelf::determine(ty, |_| ty == impl_trait_ref.self_ty()) {\n+                ExplicitSelf::ByValue => \"self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n+                _ => format!(\"self: {ty}\"),\n+            };\n+\n+            // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n+            // span points only at the type `Box<Self`>, but we want to cover the whole\n+            // argument pattern and type.\n+            let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n+                ImplItemKind::Fn(ref sig, body) => tcx\n+                    .hir()\n+                    .body_param_names(body)\n+                    .zip(sig.decl.inputs.iter())\n+                    .map(|(param, ty)| param.span.to(ty.span))\n+                    .next()\n+                    .unwrap_or(impl_err_span),\n+                _ => bug!(\"{:?} is not a method\", impl_m),\n+            };\n+\n+            diag.span_suggestion(\n+                span,\n+                \"change the self-receiver type to match the trait\",\n+                sugg,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(_, i) => {\n+            if trait_sig.inputs().len() == *i {\n+                // Suggestion to change output type. We do not suggest in `async` functions\n+                // to avoid complex logic or incorrect output.\n+                match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n+                    ImplItemKind::Fn(ref sig, _)\n+                        if sig.header.asyncness == hir::IsAsync::NotAsync =>\n+                    {\n+                        let msg = \"change the output type to match the trait\";\n+                        let ap = Applicability::MachineApplicable;\n+                        match sig.decl.output {\n+                            hir::FnRetTy::DefaultReturn(sp) => {\n+                                let sugg = format!(\"-> {} \", trait_sig.output());\n+                                diag.span_suggestion_verbose(sp, msg, sugg, ap);\n+                            }\n+                            hir::FnRetTy::Return(hir_ty) => {\n+                                let sugg = trait_sig.output();\n+                                diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n+                            }\n+                        };\n+                    }\n+                    _ => {}\n+                };\n+            } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n+                diag.span_suggestion(\n+                    impl_err_span,\n+                    \"change the parameter type to match the trait\",\n+                    trait_ty,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    infcx.err_ctxt().note_type_err(\n+        &mut diag,\n+        &cause,\n+        trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n+        Some(infer::ValuePairs::Terms(ExpectedFound {\n+            expected: trait_fty.into(),\n+            found: impl_fty.into(),\n+        })),\n+        terr,\n+        false,\n+        false,\n+    );\n+\n+    return diag.emit();\n+}\n+\n fn check_region_bounds_on_impl_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,"}, {"sha": "c848ee3f643deb1d7459999e540fc10cf23b4e8d", "filename": "src/test/ui/impl-trait/in-trait/method-signature-matches.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/07a47e0708fd8d37dd6f15eec1a4202c7da810e2/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07a47e0708fd8d37dd6f15eec1a4202c7da810e2/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.rs?ref=07a47e0708fd8d37dd6f15eec1a4202c7da810e2", "patch": "@@ -0,0 +1,51 @@\n+// edition: 2021\n+\n+#![feature(return_position_impl_trait_in_trait, async_fn_in_trait)]\n+#![allow(incomplete_features)]\n+\n+trait Uwu {\n+    fn owo(x: ()) -> impl Sized;\n+}\n+\n+impl Uwu for () {\n+    fn owo(_: u8) {}\n+    //~^ ERROR method `owo` has an incompatible type for trait\n+}\n+\n+trait AsyncUwu {\n+    async fn owo(x: ()) {}\n+}\n+\n+impl AsyncUwu for () {\n+    async fn owo(_: u8) {}\n+    //~^ ERROR method `owo` has an incompatible type for trait\n+}\n+\n+trait TooMuch {\n+    fn calm_down_please() -> impl Sized;\n+}\n+\n+impl TooMuch for () {\n+    fn calm_down_please(_: (), _: (), _: ()) {}\n+    //~^ ERROR method `calm_down_please` has 3 parameters but the declaration in trait `TooMuch::calm_down_please` has 0\n+}\n+\n+trait TooLittle {\n+    fn come_on_a_little_more_effort(_: (), _: (), _: ()) -> impl Sized;\n+}\n+\n+impl TooLittle for () {\n+    fn come_on_a_little_more_effort() {}\n+    //~^ ERROR method `come_on_a_little_more_effort` has 0 parameters but the declaration in trait `TooLittle::come_on_a_little_more_effort` has 3\n+}\n+\n+trait Lifetimes {\n+    fn early<'early, T>(x: &'early T) -> impl Sized;\n+}\n+\n+impl Lifetimes for () {\n+    fn early<'late, T>(_: &'late ()) {}\n+    //~^ ERROR method `early` has an incompatible type for trait\n+}\n+\n+fn main() {}"}, {"sha": "2b32c52c829ec4075449fb3d2ee77f86e0b304af", "filename": "src/test/ui/impl-trait/in-trait/method-signature-matches.stderr", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/07a47e0708fd8d37dd6f15eec1a4202c7da810e2/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/07a47e0708fd8d37dd6f15eec1a4202c7da810e2/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Fmethod-signature-matches.stderr?ref=07a47e0708fd8d37dd6f15eec1a4202c7da810e2", "patch": "@@ -0,0 +1,84 @@\n+error[E0053]: method `owo` has an incompatible type for trait\n+  --> $DIR/method-signature-matches.rs:11:15\n+   |\n+LL |     fn owo(_: u8) {}\n+   |               ^^\n+   |               |\n+   |               expected `()`, found `u8`\n+   |               help: change the parameter type to match the trait: `()`\n+   |\n+note: type in trait\n+  --> $DIR/method-signature-matches.rs:7:15\n+   |\n+LL |     fn owo(x: ()) -> impl Sized;\n+   |               ^^\n+   = note: expected fn pointer `fn(())`\n+              found fn pointer `fn(u8)`\n+\n+error[E0053]: method `owo` has an incompatible type for trait\n+  --> $DIR/method-signature-matches.rs:20:21\n+   |\n+LL |     async fn owo(_: u8) {}\n+   |                     ^^\n+   |                     |\n+   |                     expected `()`, found `u8`\n+   |                     help: change the parameter type to match the trait: `()`\n+   |\n+note: while checking the return type of the `async fn`\n+  --> $DIR/method-signature-matches.rs:20:25\n+   |\n+LL |     async fn owo(_: u8) {}\n+   |                         ^ checked the `Output` of this `async fn`, expected opaque type\n+note: while checking the return type of the `async fn`\n+  --> $DIR/method-signature-matches.rs:20:25\n+   |\n+LL |     async fn owo(_: u8) {}\n+   |                         ^ checked the `Output` of this `async fn`, found opaque type\n+note: type in trait\n+  --> $DIR/method-signature-matches.rs:16:21\n+   |\n+LL |     async fn owo(x: ()) {}\n+   |                     ^^\n+   = note: expected fn pointer `fn(()) -> _`\n+              found fn pointer `fn(u8) -> _`\n+\n+error[E0050]: method `calm_down_please` has 3 parameters but the declaration in trait `TooMuch::calm_down_please` has 0\n+  --> $DIR/method-signature-matches.rs:29:28\n+   |\n+LL |     fn calm_down_please() -> impl Sized;\n+   |     ------------------------------------ trait requires 0 parameters\n+...\n+LL |     fn calm_down_please(_: (), _: (), _: ()) {}\n+   |                            ^^^^^^^^^^^^^^^^ expected 0 parameters, found 3\n+\n+error[E0050]: method `come_on_a_little_more_effort` has 0 parameters but the declaration in trait `TooLittle::come_on_a_little_more_effort` has 3\n+  --> $DIR/method-signature-matches.rs:38:5\n+   |\n+LL |     fn come_on_a_little_more_effort(_: (), _: (), _: ()) -> impl Sized;\n+   |                                        ---------------- trait requires 3 parameters\n+...\n+LL |     fn come_on_a_little_more_effort() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 3 parameters, found 0\n+\n+error[E0053]: method `early` has an incompatible type for trait\n+  --> $DIR/method-signature-matches.rs:47:27\n+   |\n+LL |     fn early<'late, T>(_: &'late ()) {}\n+   |                     -     ^^^^^^^^^\n+   |                     |     |\n+   |                     |     expected type parameter `T`, found `()`\n+   |                     |     help: change the parameter type to match the trait: `&'early T`\n+   |                     this type parameter\n+   |\n+note: type in trait\n+  --> $DIR/method-signature-matches.rs:43:28\n+   |\n+LL |     fn early<'early, T>(x: &'early T) -> impl Sized;\n+   |                            ^^^^^^^^^\n+   = note: expected fn pointer `fn(&'early T)`\n+              found fn pointer `fn(&())`\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0050, E0053.\n+For more information about an error, try `rustc --explain E0050`."}]}