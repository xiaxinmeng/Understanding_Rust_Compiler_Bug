{"sha": "14c331053ea9d2661cfd9c81351f4b3815cf5e3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0YzMzMTA1M2VhOWQyNjYxY2ZkOWM4MTM1MWY0YjM4MTVjZjVlM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-02T04:31:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-02T04:31:36Z"}, "message": "auto merge of #6815 : kballard/rust/hashmap-insert_or_modify_with, r=erickt\n\n`std::hashmap::HashMap.insert_or_update_with()` is basically the opposite\r\nof `find_or_insert_with()`. It inserts a given key-value pair if the key\r\ndoes not already exist, or replaces the existing value with the output\r\nof the passed function if it does.\r\n\r\nThis is useful because replicating this with existing functionality is awkward, especially with the current borrow-checker. In my own project I have code that looks like\r\n\r\n\tif match map.find_mut(&key) {\r\n\t\tNone => { true }\r\n\t\tSome(x) => { *x += 1; false }\r\n\t} {\r\n\t\tmap.insert(key, 0);\r\n\t}\r\n\r\nand it took several iterations to make it look this good. The new function turns this into\r\n\r\n    map.insert_or_update_with(key, 0, |_,x| *x += 1);", "tree": {"sha": "339ec3e8a10db3a80f908a2299b1161a3a146a9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/339ec3e8a10db3a80f908a2299b1161a3a146a9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14c331053ea9d2661cfd9c81351f4b3815cf5e3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14c331053ea9d2661cfd9c81351f4b3815cf5e3d", "html_url": "https://github.com/rust-lang/rust/commit/14c331053ea9d2661cfd9c81351f4b3815cf5e3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14c331053ea9d2661cfd9c81351f4b3815cf5e3d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96f6f29477cbe8ce0f779f493b243fc657b6e22e", "url": "https://api.github.com/repos/rust-lang/rust/commits/96f6f29477cbe8ce0f779f493b243fc657b6e22e", "html_url": "https://github.com/rust-lang/rust/commit/96f6f29477cbe8ce0f779f493b243fc657b6e22e"}, {"sha": "75f1b7f96fa4e91244a96ba92f615f3213d97519", "url": "https://api.github.com/repos/rust-lang/rust/commits/75f1b7f96fa4e91244a96ba92f615f3213d97519", "html_url": "https://github.com/rust-lang/rust/commit/75f1b7f96fa4e91244a96ba92f615f3213d97519"}], "stats": {"total": 71, "additions": 35, "deletions": 36}, "files": [{"sha": "fb4cab721262a66792265f30fa8ec2a2eca1454b", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/14c331053ea9d2661cfd9c81351f4b3815cf5e3d/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c331053ea9d2661cfd9c81351f4b3815cf5e3d/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=14c331053ea9d2661cfd9c81351f4b3815cf5e3d", "patch": "@@ -425,9 +425,10 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n         }\n     }\n \n-    /// Return the value corresponding to the key in the map, or insert\n-    /// and return the value if it doesn't exist.\n-    pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {\n+    /// Modify and return the value corresponding to the key in the map, or\n+    /// insert and return a new value if it doesn't exist.\n+    pub fn mangle<'a,A>(&'a mut self, k: K, a: A, not_found: &fn(&K, A) -> V,\n+                        found: &fn(&K, &mut V, A)) -> &'a mut V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n             // that we do not resize if this call to insert is\n@@ -441,46 +442,37 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n         let hash = k.hash_keyed(self.k0, self.k1) as uint;\n         let idx = match self.bucket_for_key_with_hash(hash, &k) {\n             TableFull => fail!(\"Internal logic error\"),\n-            FoundEntry(idx) => idx,\n+            FoundEntry(idx) => { found(&k, self.mut_value_for_bucket(idx), a); idx }\n             FoundHole(idx) => {\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                     value: v});\n+                let v = not_found(&k, a);\n+                self.buckets[idx] = Some(Bucket{hash: hash, key: k, value: v});\n                 self.size += 1;\n                 idx\n-            },\n+            }\n         };\n \n-        self.value_for_bucket(idx)\n+        self.mut_value_for_bucket(idx)\n+    }\n+\n+    /// Return the value corresponding to the key in the map, or insert\n+    /// and return the value if it doesn't exist.\n+    pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V {\n+        self.mangle(k, v, |_k, a| a, |_k,_v,_a| ())\n     }\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n     pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V)\n-                                   -> &'a V {\n-        if self.size >= self.resize_at {\n-            // n.b.: We could also do this after searching, so\n-            // that we do not resize if this call to insert is\n-            // simply going to update a key in place.  My sense\n-            // though is that it's worse to have to search through\n-            // buckets to find the right spot twice than to just\n-            // resize in this corner case.\n-            self.expand();\n-        }\n-\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n-            TableFull => fail!(\"Internal logic error\"),\n-            FoundEntry(idx) => idx,\n-            FoundHole(idx) => {\n-                let v = f(&k);\n-                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n-                                     value: v});\n-                self.size += 1;\n-                idx\n-            },\n-        };\n+                               -> &'a mut V {\n+        self.mangle(k, (), |k,_a| f(k), |_k,_v,_a| ())\n+    }\n \n-        self.value_for_bucket(idx)\n+    /// Insert a key-value pair into the map if the key is not already present.\n+    /// Otherwise, modify the existing value for the key.\n+    /// Returns the new or modified value for the key.\n+    pub fn insert_or_update_with<'a>(&'a mut self, k: K, v: V,\n+                                     f: &fn(&K, &mut V)) -> &'a mut V {\n+        self.mangle(k, v, |_k,a| a, |k,v,_a| f(k,v))\n     }\n \n     /// Calls a function on each element of a hash map, destroying the hash\n@@ -763,15 +755,22 @@ mod test_map {\n     #[test]\n     fn test_find_or_insert() {\n         let mut m = HashMap::new::<int, int>();\n-        assert_eq!(m.find_or_insert(1, 2), &2);\n-        assert_eq!(m.find_or_insert(1, 3), &2);\n+        assert_eq!(*m.find_or_insert(1, 2), 2);\n+        assert_eq!(*m.find_or_insert(1, 3), 2);\n     }\n \n     #[test]\n     fn test_find_or_insert_with() {\n         let mut m = HashMap::new::<int, int>();\n-        assert_eq!(m.find_or_insert_with(1, |_| 2), &2);\n-        assert_eq!(m.find_or_insert_with(1, |_| 3), &2);\n+        assert_eq!(*m.find_or_insert_with(1, |_| 2), 2);\n+        assert_eq!(*m.find_or_insert_with(1, |_| 3), 2);\n+    }\n+\n+    #[test]\n+    fn test_insert_or_update_with() {\n+        let mut m = HashMap::new::<int, int>();\n+        assert_eq!(*m.insert_or_update_with(1, 2, |_,x| *x+=1), 2);\n+        assert_eq!(*m.insert_or_update_with(1, 2, |_,x| *x+=1), 3);\n     }\n \n     #[test]"}]}