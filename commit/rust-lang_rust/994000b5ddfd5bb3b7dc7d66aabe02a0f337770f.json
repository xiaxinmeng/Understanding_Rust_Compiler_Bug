{"sha": "994000b5ddfd5bb3b7dc7d66aabe02a0f337770f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NDAwMGI1ZGRmZDViYjNiN2RjN2Q2NmFhYmUwMmEwZjMzNzc3MGY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-04T11:17:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-04T11:22:47Z"}, "message": "Use method instead of a free function", "tree": {"sha": "cb9256acc0a53c17a809b50b211d9655ff4a3da5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb9256acc0a53c17a809b50b211d9655ff4a3da5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/994000b5ddfd5bb3b7dc7d66aabe02a0f337770f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/994000b5ddfd5bb3b7dc7d66aabe02a0f337770f", "html_url": "https://github.com/rust-lang/rust/commit/994000b5ddfd5bb3b7dc7d66aabe02a0f337770f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/994000b5ddfd5bb3b7dc7d66aabe02a0f337770f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e839d793ae4afd2a9ca2df1f6b4b3c56dce12ab8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e839d793ae4afd2a9ca2df1f6b4b3c56dce12ab8", "html_url": "https://github.com/rust-lang/rust/commit/e839d793ae4afd2a9ca2df1f6b4b3c56dce12ab8"}], "stats": {"total": 132, "additions": 67, "deletions": 65}, "files": [{"sha": "6440707d73df5dc3e1e3627b134752532c143c99", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/994000b5ddfd5bb3b7dc7d66aabe02a0f337770f/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994000b5ddfd5bb3b7dc7d66aabe02a0f337770f/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=994000b5ddfd5bb3b7dc7d66aabe02a0f337770f", "patch": "@@ -28,9 +28,7 @@ use crate::{display::TryToNav, FilePosition, FileRange, NavigationTarget, RangeI\n \n pub(crate) use self::rename::rename;\n \n-pub use ra_ide_db::search::{\n-    find_refs_to_def, Reference, ReferenceAccess, ReferenceKind, SearchScope,\n-};\n+pub use ra_ide_db::search::{Reference, ReferenceAccess, ReferenceKind, SearchScope};\n \n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {\n@@ -105,7 +103,8 @@ pub(crate) fn find_all_refs(\n \n     let RangeInfo { range, info: def } = find_name(&sema, &syntax, position, opt_name)?;\n \n-    let references = find_refs_to_def(db, &def, search_scope)\n+    let references = def\n+        .find_usages(db, search_scope)\n         .into_iter()\n         .filter(|r| search_kind == ReferenceKind::Other || search_kind == r.kind)\n         .collect();"}, {"sha": "23dd278b515672740595ee7ec4a9ca5f2cbb3dc9", "filename": "crates/ra_ide_db/src/search.rs", "status": "modified", "additions": 64, "deletions": 61, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/994000b5ddfd5bb3b7dc7d66aabe02a0f337770f/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994000b5ddfd5bb3b7dc7d66aabe02a0f337770f/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsearch.rs?ref=994000b5ddfd5bb3b7dc7d66aabe02a0f337770f", "patch": "@@ -171,85 +171,88 @@ impl IntoIterator for SearchScope {\n     }\n }\n \n-pub fn find_refs_to_def(\n-    db: &RootDatabase,\n-    def: &Definition,\n-    search_scope: Option<SearchScope>,\n-) -> Vec<Reference> {\n-    let _p = profile(\"find_refs_to_def\");\n-\n-    let search_scope = {\n-        let base = SearchScope::for_def(&def, db);\n-        match search_scope {\n-            None => base,\n-            Some(scope) => base.intersection(&scope),\n-        }\n-    };\n+impl Definition {\n+    pub fn find_usages(\n+        &self,\n+        db: &RootDatabase,\n+        search_scope: Option<SearchScope>,\n+    ) -> Vec<Reference> {\n+        let _p = profile(\"Definition::find_usages\");\n+\n+        let search_scope = {\n+            let base = SearchScope::for_def(self, db);\n+            match search_scope {\n+                None => base,\n+                Some(scope) => base.intersection(&scope),\n+            }\n+        };\n \n-    let name = match def.name(db) {\n-        None => return Vec::new(),\n-        Some(it) => it.to_string(),\n-    };\n+        let name = match self.name(db) {\n+            None => return Vec::new(),\n+            Some(it) => it.to_string(),\n+        };\n \n-    let pat = name.as_str();\n-    let mut refs = vec![];\n+        let pat = name.as_str();\n+        let mut refs = vec![];\n \n-    for (file_id, search_range) in search_scope {\n-        let text = db.file_text(file_id);\n-        let search_range =\n-            search_range.unwrap_or(TextRange::offset_len(0.into(), TextUnit::of_str(&text)));\n+        for (file_id, search_range) in search_scope {\n+            let text = db.file_text(file_id);\n+            let search_range =\n+                search_range.unwrap_or(TextRange::offset_len(0.into(), TextUnit::of_str(&text)));\n \n-        let sema = Semantics::new(db);\n-        let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n+            let sema = Semantics::new(db);\n+            let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n \n-        for (idx, _) in text.match_indices(pat) {\n-            let offset = TextUnit::from_usize(idx);\n-            if !search_range.contains_inclusive(offset) {\n-                // tested_by!(search_filters_by_range);\n-                continue;\n-            }\n+            for (idx, _) in text.match_indices(pat) {\n+                let offset = TextUnit::from_usize(idx);\n+                if !search_range.contains_inclusive(offset) {\n+                    // tested_by!(search_filters_by_range);\n+                    continue;\n+                }\n \n-            let name_ref =\n-                if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&tree, offset) {\n-                    name_ref\n-                } else {\n-                    // Handle macro token cases\n-                    let token = match tree.token_at_offset(offset) {\n-                        TokenAtOffset::None => continue,\n-                        TokenAtOffset::Single(t) => t,\n-                        TokenAtOffset::Between(_, t) => t,\n+                let name_ref =\n+                    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(&tree, offset) {\n+                        name_ref\n+                    } else {\n+                        // Handle macro token cases\n+                        let token = match tree.token_at_offset(offset) {\n+                            TokenAtOffset::None => continue,\n+                            TokenAtOffset::Single(t) => t,\n+                            TokenAtOffset::Between(_, t) => t,\n+                        };\n+                        let expanded = sema.descend_into_macros(token);\n+                        match ast::NameRef::cast(expanded.parent()) {\n+                            Some(name_ref) => name_ref,\n+                            _ => continue,\n+                        }\n                     };\n-                    let expanded = sema.descend_into_macros(token);\n-                    match ast::NameRef::cast(expanded.parent()) {\n-                        Some(name_ref) => name_ref,\n-                        _ => continue,\n-                    }\n-                };\n \n-            // FIXME: reuse sb\n-            // See https://github.com/rust-lang/rust/pull/68198#issuecomment-574269098\n+                // FIXME: reuse sb\n+                // See https://github.com/rust-lang/rust/pull/68198#issuecomment-574269098\n \n-            if let Some(d) = classify_name_ref(&sema, &name_ref) {\n-                let d = d.definition();\n-                if &d == def {\n-                    let kind =\n-                        if is_record_lit_name_ref(&name_ref) || is_call_expr_name_ref(&name_ref) {\n+                if let Some(d) = classify_name_ref(&sema, &name_ref) {\n+                    let d = d.definition();\n+                    if &d == self {\n+                        let kind = if is_record_lit_name_ref(&name_ref)\n+                            || is_call_expr_name_ref(&name_ref)\n+                        {\n                             ReferenceKind::StructLiteral\n                         } else {\n                             ReferenceKind::Other\n                         };\n \n-                    let file_range = sema.original_range(name_ref.syntax());\n-                    refs.push(Reference {\n-                        file_range,\n-                        kind,\n-                        access: reference_access(&d, &name_ref),\n-                    });\n+                        let file_range = sema.original_range(name_ref.syntax());\n+                        refs.push(Reference {\n+                            file_range,\n+                            kind,\n+                            access: reference_access(&d, &name_ref),\n+                        });\n+                    }\n                 }\n             }\n         }\n+        refs\n     }\n-    refs\n }\n \n fn reference_access(def: &Definition, name_ref: &ast::NameRef) -> Option<ReferenceAccess> {"}]}