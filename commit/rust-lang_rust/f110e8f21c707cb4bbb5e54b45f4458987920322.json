{"sha": "f110e8f21c707cb4bbb5e54b45f4458987920322", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMTBlOGYyMWM3MDdjYjRiYmI1ZTU0YjQ1ZjQ0NTg5ODc5MjAzMjI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-08T21:17:52Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-08T21:19:21Z"}, "message": "rustc: Do some plumbing work on nested enums", "tree": {"sha": "d4999199d287f0e3e53569ba8bdc82a593654a6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4999199d287f0e3e53569ba8bdc82a593654a6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f110e8f21c707cb4bbb5e54b45f4458987920322", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f110e8f21c707cb4bbb5e54b45f4458987920322", "html_url": "https://github.com/rust-lang/rust/commit/f110e8f21c707cb4bbb5e54b45f4458987920322", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f110e8f21c707cb4bbb5e54b45f4458987920322/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "166cb1b28bc23303d15e8c1c4a71d0cdff0556a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2", "html_url": "https://github.com/rust-lang/rust/commit/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2"}], "stats": {"total": 407, "additions": 250, "deletions": 157}, "files": [{"sha": "d2a6aa1f7b0e2cc854d9461965c7ae82523336cc", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f110e8f21c707cb4bbb5e54b45f4458987920322", "patch": "@@ -636,7 +636,8 @@ type variant_arg = {ty: @ty, id: node_id};\n #[auto_serialize]\n enum variant_kind {\n     tuple_variant_kind(~[variant_arg]),\n-    struct_variant_kind(@struct_def)\n+    struct_variant_kind(@struct_def),\n+    enum_variant_kind(~[variant])\n }\n \n #[auto_serialize]"}, {"sha": "d0a55b6d95c2c96b2635c9ba4404c668d4645f61", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=f110e8f21c707cb4bbb5e54b45f4458987920322", "patch": "@@ -913,7 +913,9 @@ fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: ast::ident,\n                 };\n             }\n             ast::struct_variant_kind(*) =>\n-                fail ~\"struct variants unimplemented\"\n+                fail ~\"struct variants unimplemented\",\n+            ast::enum_variant_kind(*) =>\n+                fail ~\"enum variants unimplemented\"\n         }\n \n         {pats: ~[@{id: cx.next_id(),"}, {"sha": "d84c981504fa21364120b24d6d903d1e72b0aa02", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f110e8f21c707cb4bbb5e54b45f4458987920322", "patch": "@@ -564,6 +564,11 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n                 dtor: dtor\n             })\n         }\n+\n+        enum_variant_kind(variants) => {\n+            let variants = vec::map(variants, |x| fld.fold_variant(x));\n+            kind = enum_variant_kind(variants);\n+        }\n     }\n \n     let fold_attribute = |x| fold_attribute_(x, fld);"}, {"sha": "1cc3f19772124fc859951e0fc33c64478c7a4afe", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 50, "deletions": 45, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f110e8f21c707cb4bbb5e54b45f4458987920322", "patch": "@@ -17,28 +17,27 @@ import dvec::{dvec, extensions};\n import vec::{push};\n import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              bind_by_ref, bind_by_implicit_ref, bind_by_value,\n-             bitand, bitor, bitxor, blk,\n-             blk_check_mode, bound_const, bound_copy, bound_send, bound_trait,\n-             bound_owned, box, by_copy, by_move, by_mutbl_ref, by_ref, by_val,\n-             capture_clause, capture_item, cdir_dir_mod, cdir_src_mod,\n-             cdir_view_item, class_immutable, class_member, class_method,\n-             class_mutable, crate, crate_cfg, crate_directive, decl,\n-             decl_item, decl_local, default_blk, deref, div, expl, expr,\n-             expr_, expr_addr_of, expr_match, expr_again, expr_assert,\n-             expr_assign, expr_assign_op, expr_binary, expr_block, expr_break,\n-             expr_call, expr_cast, expr_copy, expr_do_body,\n-             expr_fail, expr_field, expr_fn, expr_fn_block, expr_if,\n-             expr_index, expr_lit, expr_log, expr_loop,\n-             expr_loop_body, expr_mac, expr_move, expr_path, expr_rec,\n-             expr_repeat, expr_ret, expr_swap, expr_struct, expr_tup,\n-             expr_unary, expr_unary_move, expr_vec, expr_vstore, expr_while,\n-             extern_fn, field, fn_decl, foreign_item, foreign_item_fn,\n-             foreign_mod, ident, impure_fn, infer, inherited, init_assign,\n-             init_move, initializer, instance_var, item, item_, item_class,\n-             item_const, item_enum, item_fn, item_foreign_mod, item_impl,\n-             item_mac, item_mod, item_trait, item_ty, lit, lit_, lit_bool,\n-             lit_float, lit_int, lit_int_unsuffixed, lit_nil, lit_str,\n-             lit_uint, local, m_const, m_imm, m_mutbl, mac_, mac_aq,\n+             bitand, bitor, bitxor, blk, blk_check_mode, bound_const,\n+             bound_copy, bound_send, bound_trait, bound_owned, box, by_copy,\n+             by_move, by_mutbl_ref, by_ref, by_val, capture_clause,\n+             capture_item, cdir_dir_mod, cdir_src_mod, cdir_view_item,\n+             class_immutable, class_member, class_method, class_mutable,\n+             crate, crate_cfg, crate_directive, decl, decl_item, decl_local,\n+             default_blk, deref, div, enum_variant_kind, expl, expr, expr_,\n+             expr_addr_of, expr_match, expr_again, expr_assert, expr_assign,\n+             expr_assign_op, expr_binary, expr_block, expr_break, expr_call,\n+             expr_cast, expr_copy, expr_do_body, expr_fail, expr_field,\n+             expr_fn, expr_fn_block, expr_if, expr_index, expr_lit, expr_log,\n+             expr_loop, expr_loop_body, expr_mac, expr_move, expr_path,\n+             expr_rec, expr_repeat, expr_ret, expr_swap, expr_struct,\n+             expr_tup, expr_unary, expr_unary_move, expr_vec, expr_vstore,\n+             expr_while, extern_fn, field, fn_decl, foreign_item,\n+             foreign_item_fn, foreign_mod, ident, impure_fn, infer, inherited,\n+             init_assign, init_move, initializer, instance_var, item, item_,\n+             item_class, item_const, item_enum, item_fn, item_foreign_mod,\n+             item_impl, item_mac, item_mod, item_trait, item_ty, lit, lit_,\n+             lit_bool, lit_float, lit_int, lit_int_unsuffixed, lit_nil,\n+             lit_str, lit_uint, local, m_const, m_imm, m_mutbl, mac_, mac_aq,\n              mac_ellipsis, mac_invoc, mac_invoc_tt, mac_var, matcher,\n              match_nonterminal, match_seq, match_tok, method, mode, mt, mul,\n              mutability, neg, noreturn, not, pat, pat_box, pat_enum,\n@@ -2842,30 +2841,8 @@ class parser {\n         }\n     }\n \n-    fn parse_item_enum() -> item_info {\n-        let id = self.parse_ident();\n-        self.parse_region_param();\n-        let ty_params = self.parse_ty_params();\n+    fn parse_enum_body(ty_params: ~[ast::ty_param]) -> ~[ast::variant] {\n         let mut variants: ~[variant] = ~[];\n-        // Newtype syntax\n-        if self.token == token::EQ {\n-            self.check_restricted_keywords_(*id);\n-            self.bump();\n-            let ty = self.parse_ty(false);\n-            self.expect(token::SEMI);\n-            let variant =\n-                spanned(ty.span.lo, ty.span.hi,\n-                        {name: id,\n-                         attrs: ~[],\n-                         kind: tuple_variant_kind\n-                            (~[{ty: ty, id: self.get_id()}]),\n-                         id: self.get_id(),\n-                         disr_expr: none,\n-                         vis: public});\n-            return (id, item_enum(~[variant], ty_params), none);\n-        }\n-        self.expect(token::LBRACE);\n-\n         let mut all_nullary = true, have_disr = false;\n \n         while self.token != token::RBRACE {\n@@ -2954,6 +2931,34 @@ class parser {\n             self.fatal(~\"discriminator values can only be used with a c-like \\\n                         enum\");\n         }\n+\n+        return variants;\n+    }\n+\n+    fn parse_item_enum() -> item_info {\n+        let id = self.parse_ident();\n+        self.parse_region_param();\n+        let ty_params = self.parse_ty_params();\n+        // Newtype syntax\n+        if self.token == token::EQ {\n+            self.check_restricted_keywords_(*id);\n+            self.bump();\n+            let ty = self.parse_ty(false);\n+            self.expect(token::SEMI);\n+            let variant =\n+                spanned(ty.span.lo, ty.span.hi,\n+                        {name: id,\n+                         attrs: ~[],\n+                         kind: tuple_variant_kind\n+                            (~[{ty: ty, id: self.get_id()}]),\n+                         id: self.get_id(),\n+                         disr_expr: none,\n+                         vis: public});\n+            return (id, item_enum(~[variant], ty_params), none);\n+        }\n+        self.expect(token::LBRACE);\n+\n+        let variants = self.parse_enum_body(ty_params);\n         (id, item_enum(variants, ty_params), none)\n     }\n "}, {"sha": "56b3197c336cafbc02f88ab08d1b548ecb1fbe66", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f110e8f21c707cb4bbb5e54b45f4458987920322", "patch": "@@ -516,18 +516,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n             word(s.s, ~\";\");\n             end(s);\n         } else {\n-            bopen(s);\n-            for variants.each |v| {\n-                space_if_not_bol(s);\n-                maybe_print_comment(s, v.span.lo);\n-                print_outer_attributes(s, v.node.attrs);\n-                ibox(s, indent_unit);\n-                print_variant(s, v);\n-                word(s.s, ~\",\");\n-                end(s);\n-                maybe_print_trailing_comment(s, v.span, none::<uint>);\n-            }\n-            bclose(s, item.span);\n+            print_variants(s, variants, item.span);\n         }\n       }\n       ast::item_class(struct_def, tps) => {\n@@ -582,6 +571,21 @@ fn print_item(s: ps, &&item: @ast::item) {\n     s.ann.post(ann_node);\n }\n \n+fn print_variants(s: ps, variants: ~[ast::variant], span: ast::span) {\n+    bopen(s);\n+    for variants.each |v| {\n+        space_if_not_bol(s);\n+        maybe_print_comment(s, v.span.lo);\n+        print_outer_attributes(s, v.node.attrs);\n+        ibox(s, indent_unit);\n+        print_variant(s, v);\n+        word(s.s, ~\",\");\n+        end(s);\n+        maybe_print_trailing_comment(s, v.span, none::<uint>);\n+    }\n+    bclose(s, span);\n+}\n+\n fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n                 ident: ast::ident, span: ast::span) {\n     word_nbsp(s, *ident);\n@@ -710,6 +714,9 @@ fn print_variant(s: ps, v: ast::variant) {\n             head(s, ~\"\");\n             print_struct(s, struct_def, ~[], v.node.name, v.span);\n         }\n+        ast::enum_variant_kind(variants) => {\n+            print_variants(s, variants, v.span);\n+        }\n     }\n     match v.node.disr_expr {\n       some(d) => {"}, {"sha": "f526f8c73e1a86c298feb7bbaf9c2612ba5a9d47", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=f110e8f21c707cb4bbb5e54b45f4458987920322", "patch": "@@ -138,17 +138,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       }\n       item_enum(variants, tps) => {\n         v.visit_ty_params(tps, e, v);\n-        for variants.each |vr| {\n-            match vr.node.kind {\n-                tuple_variant_kind(variant_args) => {\n-                    for variant_args.each |va| { v.visit_ty(va.ty, e, v); }\n-                }\n-                struct_variant_kind(struct_def) => {\n-                    v.visit_struct_def(struct_def, vr.node.name, tps,\n-                                       vr.node.id, e, v);\n-                }\n-            }\n-        }\n+        visit_variants(variants, tps, e, v);\n       }\n       item_impl(tps, traits, ty, methods) => {\n         v.visit_ty_params(tps, e, v);\n@@ -175,6 +165,24 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     }\n }\n \n+fn visit_variants<E>(variants: ~[ast::variant], tps: ~[ast::ty_param], e: E,\n+                     v: vt<E>) {\n+    for variants.each |vr| {\n+        match vr.node.kind {\n+            tuple_variant_kind(variant_args) => {\n+                for variant_args.each |va| { v.visit_ty(va.ty, e, v); }\n+            }\n+            struct_variant_kind(struct_def) => {\n+                v.visit_struct_def(struct_def, vr.node.name, tps,\n+                                   vr.node.id, e, v);\n+            }\n+            enum_variant_kind(variants) => {\n+                visit_variants(variants, tps, e, v);\n+            }\n+        }\n+    }\n+}\n+\n fn visit_class_item<E>(cm: @class_member, e:E, v:vt<E>) {\n     match cm.node {\n       instance_var(_, t, _, _, _) => v.visit_ty(t, e, v),"}, {"sha": "de0dca66f9c64f25d43c0b3c6a282218e94ee4e5", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=f110e8f21c707cb4bbb5e54b45f4458987920322", "patch": "@@ -398,7 +398,8 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                     if args.len() > 0 && ty_params.len() == 0 => {\n                 encode_symbol(ecx, ebml_w, variant.node.id);\n             }\n-            ast::tuple_variant_kind(_) | ast::struct_variant_kind(_) => {}\n+            ast::tuple_variant_kind(_) | ast::struct_variant_kind(_) |\n+            ast::enum_variant_kind(_) => {}\n         }\n         encode_discriminant(ecx, ebml_w, variant.node.id);\n         if vi[i].disr_val != disr_val {"}, {"sha": "d17542b797af27365d6742cb54ef8b69479bdffa", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=f110e8f21c707cb4bbb5e54b45f4458987920322", "patch": "@@ -21,19 +21,19 @@ import syntax::ast::{def_upvar, def_use, def_variant, expr, expr_assign_op};\n import syntax::ast::{expr_binary, expr_cast, expr_field, expr_fn};\n import syntax::ast::{expr_fn_block, expr_index, expr_path};\n import syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n-import syntax::ast::{def_upvar, def_use, def_variant, div, eq, expr};\n-import syntax::ast::{expr_assign_op, expr_binary, expr_cast, expr_field};\n-import syntax::ast::{expr_fn, expr_fn_block, expr_index, expr_path};\n-import syntax::ast::{expr_struct, expr_unary, fn_decl, foreign_item};\n-import syntax::ast::{foreign_item_fn, ge, gt, ident, trait_ref, impure_fn};\n-import syntax::ast::{instance_var, item, item_class, item_const, item_enum};\n-import syntax::ast::{item_fn, item_mac, item_foreign_mod, item_impl};\n-import syntax::ast::{item_mod, item_trait, item_ty, le, local, local_crate};\n-import syntax::ast::{lt, method, mul, ne, neg, node_id, pat, pat_enum};\n-import syntax::ast::{pat_ident, path, prim_ty, pat_box, pat_uniq, pat_lit};\n-import syntax::ast::{pat_range, pat_rec, pat_struct, pat_tup, pat_wild};\n-import syntax::ast::{provided, required, rem, self_ty_, shl, stmt_decl};\n-import syntax::ast::{struct_variant_kind, sty_static, subtract};\n+import syntax::ast::{def_upvar, def_use, def_variant, div, eq};\n+import syntax::ast::{enum_variant_kind, expr, expr_assign_op, expr_binary};\n+import syntax::ast::{expr_cast, expr_field, expr_fn, expr_fn_block};\n+import syntax::ast::{expr_index, expr_path, expr_struct, expr_unary, fn_decl};\n+import syntax::ast::{foreign_item, foreign_item_fn, ge, gt, ident, trait_ref};\n+import syntax::ast::{impure_fn, instance_var, item, item_class, item_const};\n+import syntax::ast::{item_enum, item_fn, item_mac, item_foreign_mod};\n+import syntax::ast::{item_impl, item_mod, item_trait, item_ty, le, local};\n+import syntax::ast::{local_crate, lt, method, mul, ne, neg, node_id, pat};\n+import syntax::ast::{pat_enum, pat_ident, path, prim_ty, pat_box, pat_uniq};\n+import syntax::ast::{pat_lit, pat_range, pat_rec, pat_struct, pat_tup};\n+import syntax::ast::{pat_wild, provided, required, rem, self_ty_, shl};\n+import syntax::ast::{stmt_decl, struct_variant_kind, sty_static, subtract};\n import syntax::ast::{tuple_variant_kind, ty};\n import syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n import syntax::ast::{ty_i16, ty_i32, ty_i64, ty_i8, ty_int, ty_param};\n@@ -1128,7 +1128,7 @@ class Resolver {\n     fn build_reduced_graph_for_variant(variant: variant,\n                                        item_id: def_id,\n                                        parent: ReducedGraphParent,\n-                                       &&_visitor: vt<ReducedGraphParent>) {\n+                                       &&visitor: vt<ReducedGraphParent>) {\n \n         let atom = (*self.atom_table).intern(variant.node.name);\n         let (child, _) = self.add_child(atom, parent, ~[ValueNS],\n@@ -1146,6 +1146,14 @@ class Resolver {\n                                      variant.span);\n                 self.structs.insert(local_def(variant.node.id), false);\n             }\n+            enum_variant_kind(variants) => {\n+                (*child).define_type(def_ty(local_def(variant.node.id)),\n+                                     variant.span);\n+                for variants.each |variant| {\n+                    self.build_reduced_graph_for_variant(variant, item_id,\n+                                                         parent, visitor);\n+                }\n+            }\n         }\n     }\n "}, {"sha": "15f7de84c5f13c00fd8d06486aa76ecdd39f6232", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f110e8f21c707cb4bbb5e54b45f4458987920322", "patch": "@@ -2235,7 +2235,9 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n                                    psubsts, d);\n             }\n             ast::struct_variant_kind(_) =>\n-                ccx.tcx.sess.bug(~\"can't monomorphize struct variants\")\n+                ccx.tcx.sess.bug(~\"can't monomorphize struct variants\"),\n+            ast::enum_variant_kind(_) =>\n+                ccx.tcx.sess.bug(~\"can't monomorphize enum variants\")\n         }\n         d\n       }\n@@ -4893,6 +4895,34 @@ fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n   lldecl\n }\n \n+fn trans_variants(ccx: @crate_ctxt, variants: ~[ast::variant],\n+                  id: ast::node_id, tps: ~[ast::ty_param], degen: bool,\n+                  path: @ast_map::path, vi: @~[ty::variant_info],\n+                  i: &mut uint) {\n+    for vec::each(variants) |variant| {\n+        let disr_val = vi[*i].disr_val;\n+        *i += 1;\n+\n+        match variant.node.kind {\n+            ast::tuple_variant_kind(args) if args.len() > 0 => {\n+                let llfn = get_item_val(ccx, variant.node.id);\n+                trans_enum_variant(ccx, id, variant, args, disr_val,\n+                                   degen, none, llfn);\n+            }\n+            ast::tuple_variant_kind(_) => {\n+                // Nothing to do.\n+            }\n+            ast::struct_variant_kind(struct_def) => {\n+                trans_struct_def(ccx, struct_def, tps, path,\n+                                 variant.node.name, variant.node.id);\n+            }\n+            ast::enum_variant_kind(variants) => {\n+                trans_variants(ccx, variants, id, tps, degen, path, vi, i);\n+            }\n+        }\n+    }\n+}\n+\n fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n     let _icx = ccx.insn_ctxt(~\"trans_item\");\n     let path = match check ccx.tcx.items.get(item.id) {\n@@ -4934,24 +4964,8 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             let degen = variants.len() == 1u;\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n             let mut i = 0;\n-            for vec::each(variants) |variant| {\n-                match variant.node.kind {\n-                    ast::tuple_variant_kind(args) if args.len() > 0 => {\n-                        let llfn = get_item_val(ccx, variant.node.id);\n-                        trans_enum_variant(ccx, item.id, variant, args,\n-                                           vi[i].disr_val, degen,\n-                                           none, llfn);\n-                    }\n-                    ast::tuple_variant_kind(_) => {\n-                        // Nothing to do.\n-                    }\n-                    ast::struct_variant_kind(struct_def) => {\n-                        trans_struct_def(ccx, struct_def, tps, path,\n-                                         variant.node.name, variant.node.id);\n-                    }\n-                }\n-                i += 1;\n-            }\n+            trans_variants(ccx, variants, item.id, tps, degen, path, vi,\n+                           &mut i);\n         }\n       }\n       ast::item_const(_, expr) => consts::trans_const(ccx, expr, item.id),\n@@ -5263,7 +5277,10 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                     };\n                 }\n                 ast::struct_variant_kind(_) => {\n-                    fail ~\"struct unexpected in get_item_val\"\n+                    fail ~\"struct variant kind unexpected in get_item_val\"\n+                }\n+                ast::enum_variant_kind(_) => {\n+                    fail ~\"enum variant kind unexpected in get_item_val\"\n                 }\n             }\n             set_inline_hint(llfn);"}, {"sha": "ff807cbcab24160c0b1e06f614bc96c63453e270", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=f110e8f21c707cb4bbb5e54b45f4458987920322", "patch": "@@ -2868,8 +2868,12 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[variant_info] {\n                           disr_val: disr_val\n                          }\n                     }\n-                    ast::struct_variant_kind(_) =>\n+                    ast::struct_variant_kind(_) => {\n                         fail ~\"struct variant kinds unimpl in enum_variants\"\n+                    }\n+                    ast::enum_variant_kind(_) => {\n+                        fail ~\"enum variant kinds unimpl in enum_variants\"\n+                    }\n                 }\n             })\n           }"}, {"sha": "16d93137ac7283bfb4ef6c5bc77e6e3a9eaf2b4f", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 65, "deletions": 42, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=f110e8f21c707cb4bbb5e54b45f4458987920322", "patch": "@@ -2043,53 +2043,76 @@ fn check_enum_variants(ccx: @crate_ctxt,\n                        sp: span,\n                        vs: ~[ast::variant],\n                        id: ast::node_id) {\n-    let rty = ty::node_id_to_type(ccx.tcx, id);\n-    let mut disr_vals: ~[int] = ~[];\n-    let mut disr_val = 0;\n-    let mut variants = ~[];\n-    for vs.each |v| {\n-        match v.node.disr_expr {\n-          some(e) => {\n-            let fcx = blank_fn_ctxt(ccx, rty, e.id);\n-            check_expr(fcx, e, none);\n-            let cty = fcx.expr_ty(e);\n-            let declty = ty::mk_int(ccx.tcx);\n-            demand::suptype(fcx, e.span, declty, cty);\n-            // FIXME: issue #1417\n-            // Also, check_expr (from check_const pass) doesn't guarantee that\n-            // the expression in an form that eval_const_expr can handle, so\n-            // we may still get an internal compiler error\n-            match const_eval::eval_const_expr(ccx.tcx, e) {\n-              const_eval::const_int(val) => {\n-                disr_val = val as int;\n-              }\n-              _ => {\n-                ccx.tcx.sess.span_err(e.span,\n-                                      ~\"expected signed integer constant\");\n+    fn do_check(ccx: @crate_ctxt, sp: span, vs: ~[ast::variant],\n+                id: ast::node_id, disr_vals: &mut ~[int], disr_val: &mut int,\n+                variants: &mut ~[ty::variant_info]) {\n+        let rty = ty::node_id_to_type(ccx.tcx, id);\n+        for vs.each |v| {\n+            match v.node.disr_expr {\n+              some(e) => {\n+                let fcx = blank_fn_ctxt(ccx, rty, e.id);\n+                check_expr(fcx, e, none);\n+                let cty = fcx.expr_ty(e);\n+                let declty = ty::mk_int(ccx.tcx);\n+                demand::suptype(fcx, e.span, declty, cty);\n+                // FIXME: issue #1417\n+                // Also, check_expr (from check_const pass) doesn't guarantee\n+                // that the expression is in an form that eval_const_expr can\n+                // handle, so we may still get an internal compiler error\n+                match const_eval::eval_const_expr(ccx.tcx, e) {\n+                  const_eval::const_int(val) => {\n+                    *disr_val = val as int;\n+                  }\n+                  _ => {\n+                    ccx.tcx.sess.span_err(e.span, ~\"expected signed integer \\\n+                                                    constant\");\n+                  }\n+                }\n               }\n+              _ => ()\n+            }\n+            if vec::contains(*disr_vals, *disr_val) {\n+                ccx.tcx.sess.span_err(v.span,\n+                                      ~\"discriminator value already exists\");\n+            }\n+            vec::push(*disr_vals, *disr_val);\n+            let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n+            let arg_tys;\n+\n+            let this_disr_val = *disr_val;\n+            *disr_val += 1;\n+\n+            match v.node.kind {\n+                ast::tuple_variant_kind(args) if args.len() > 0u => {\n+                    arg_tys = some(ty::ty_fn_args(ctor_ty).map(|a| a.ty));\n+                }\n+                ast::tuple_variant_kind(_) | ast::struct_variant_kind(_) => {\n+                    arg_tys = some(~[]);\n+                }\n+                ast::enum_variant_kind(subvariants) => {\n+                    arg_tys = none;\n+                    do_check(ccx, sp, vs, id, disr_vals, disr_val, variants);\n+                }\n+            }\n+\n+            match arg_tys {\n+                none => {}\n+                some(arg_tys) => {\n+                    vec::push(*variants, @{args: arg_tys, ctor_ty: ctor_ty,\n+                          name: v.node.name, id: local_def(v.node.id),\n+                          disr_val: this_disr_val});\n+                }\n             }\n-          }\n-          _ => ()\n-        }\n-        if vec::contains(disr_vals, disr_val) {\n-            ccx.tcx.sess.span_err(v.span,\n-                                  ~\"discriminator value already exists\");\n         }\n-        vec::push(disr_vals, disr_val);\n-        let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n-        let arg_tys;\n-        match v.node.kind {\n-            ast::tuple_variant_kind(args) if args.len() > 0u =>\n-                arg_tys = ty::ty_fn_args(ctor_ty).map(|a| a.ty),\n-            ast::tuple_variant_kind(_) | ast::struct_variant_kind(_) =>\n-                arg_tys = ~[]\n-        };\n-        vec::push(variants, @{args: arg_tys, ctor_ty: ctor_ty,\n-              name: v.node.name, id: local_def(v.node.id),\n-              disr_val: disr_val});\n-        disr_val += 1;\n     }\n \n+    let rty = ty::node_id_to_type(ccx.tcx, id);\n+    let mut disr_vals: ~[int] = ~[];\n+    let mut disr_val = 0;\n+    let mut variants = ~[];\n+\n+    do_check(ccx, sp, vs, id, &mut disr_vals, &mut disr_val, &mut variants);\n+\n     // cache so that ty::enum_variants won't repeat this work\n     ccx.tcx.enum_var_cache.insert(local_def(id), @variants);\n "}, {"sha": "08eaad73e65d91da1fdbe4fc106bd3e3c4b07762", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f110e8f21c707cb4bbb5e54b45f4458987920322/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=f110e8f21c707cb4bbb5e54b45f4458987920322", "patch": "@@ -124,21 +124,33 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n                     let arg_ty = ccx.to_ty(rs, va.ty);\n                     {mode: ast::expl(ast::by_copy), ty: arg_ty}\n                 });\n-                result_ty = ty::mk_fn(tcx, {purity: ast::pure_fn,\n+                result_ty = some(ty::mk_fn(tcx,\n+                                           {purity: ast::pure_fn,\n                                             proto: ast::proto_box,\n                                             bounds: @~[],\n                                             inputs: args,\n                                             output: enum_ty,\n-                                            ret_style: ast::return_val});\n+                                            ret_style: ast::return_val}));\n+            }\n+            ast::tuple_variant_kind(_) | ast::struct_variant_kind(_) => {\n+                result_ty = some(enum_ty);\n+            }\n+            ast::enum_variant_kind(variants) => {\n+                get_enum_variant_types(ccx, enum_ty, variants, ty_params, rp);\n+                result_ty = none;\n             }\n-            ast::tuple_variant_kind(_) | ast::struct_variant_kind(_) =>\n-                result_ty = enum_ty\n         };\n-        let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n-                   rp: rp,\n-                   ty: result_ty};\n-        tcx.tcache.insert(local_def(variant.node.id), tpt);\n-        write_ty_to_tcx(tcx, variant.node.id, result_ty);\n+\n+        match result_ty {\n+            none => {}\n+            some(result_ty) => {\n+                let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n+                           rp: rp,\n+                           ty: result_ty};\n+                tcx.tcache.insert(local_def(variant.node.id), tpt);\n+                write_ty_to_tcx(tcx, variant.node.id, result_ty);\n+            }\n+        }\n     }\n }\n "}]}