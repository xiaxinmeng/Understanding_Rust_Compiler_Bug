{"sha": "254022c13cd286d3697f97bc8ef6be7d90d18d9d", "node_id": "C_kwDOAAsO6NoAKDI1NDAyMmMxM2NkMjg2ZDM2OTdmOTdiYzhlZjZiZTdkOTBkMThkOWQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-21T14:15:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-21T14:15:53Z"}, "message": "Merge #10304\n\n10304: internal: Generate ast nodes for each ast trait r=Veykril a=Veykril\n\nGenerate a `DynTrait` node per ast trait that implements the trait itself as well as conversions via the `AstNode` trait. This is a trick already employed in `hir_def::attr` with `AttrsOwner` where it was manually implemented for.\r\n\r\nThis basically gives us stack trait objects for these(only useful for `hir_def::attr` currently) as well as simple conversions of `SyntaxNode` to a trait, in cases where only a result of a function call of such a trait is of interest.\r\n\r\nIt doesn't have many uses yet but as its autogenerated it doesn't add any maintenance costs. \r\n\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "80717fdcb726977c2e798c093c699b52816f873e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80717fdcb726977c2e798c093c699b52816f873e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/254022c13cd286d3697f97bc8ef6be7d90d18d9d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhSekZCRBK7hj4Ov3rIwAAf2sIAELRn6CfvOGfLI3lqaQie1Y4\nuaGAF6f9+6fP2HGsNIV/lZmmyqb5/FDwE2UDH875200My6MjTpkr8M/hE3iye6cp\nEDP7zYhfrqEETpJbiX+2D2AiLZKJOwWkhxAcml21R9gC7oPSrDPcjImW5BP9AQYb\nMmlfL1sVjJ02TQBhPDFM+krFKv88yXvq9cgURmC1bTPGsQqhQSevBMofDoAn+8Zg\nv5jtxnaAcGXPql+/7ZOfikiMO74dHx4TV+/uHsaE5gWr0HTAzJZQOPeHeQseMvrV\n/9vvPPzJhal2s74zQXolNZKfTf3kjlFeQuG6ODKK7JfTXYT8FetFJ5kmu/VuYLE=\n=lOeu\n-----END PGP SIGNATURE-----\n", "payload": "tree 80717fdcb726977c2e798c093c699b52816f873e\nparent 168b00fbba264346f24f770aea0e03c5c3bb3200\nparent 83e97adfff998e67c036ca17934d014c237afe45\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1632233753 +0000\ncommitter GitHub <noreply@github.com> 1632233753 +0000\n\nMerge #10304\n\n10304: internal: Generate ast nodes for each ast trait r=Veykril a=Veykril\n\nGenerate a `DynTrait` node per ast trait that implements the trait itself as well as conversions via the `AstNode` trait. This is a trick already employed in `hir_def::attr` with `AttrsOwner` where it was manually implemented for.\r\n\r\nThis basically gives us stack trait objects for these(only useful for `hir_def::attr` currently) as well as simple conversions of `SyntaxNode` to a trait, in cases where only a result of a function call of such a trait is of interest.\r\n\r\nIt doesn't have many uses yet but as its autogenerated it doesn't add any maintenance costs. \r\n\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/254022c13cd286d3697f97bc8ef6be7d90d18d9d", "html_url": "https://github.com/rust-lang/rust/commit/254022c13cd286d3697f97bc8ef6be7d90d18d9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/254022c13cd286d3697f97bc8ef6be7d90d18d9d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "168b00fbba264346f24f770aea0e03c5c3bb3200", "url": "https://api.github.com/repos/rust-lang/rust/commits/168b00fbba264346f24f770aea0e03c5c3bb3200", "html_url": "https://github.com/rust-lang/rust/commit/168b00fbba264346f24f770aea0e03c5c3bb3200"}, {"sha": "83e97adfff998e67c036ca17934d014c237afe45", "url": "https://api.github.com/repos/rust-lang/rust/commits/83e97adfff998e67c036ca17934d014c237afe45", "html_url": "https://github.com/rust-lang/rust/commit/83e97adfff998e67c036ca17934d014c237afe45"}], "stats": {"total": 406, "additions": 331, "deletions": 75}, "files": [{"sha": "51befc698c053d210ea5d3fdf71e7acac121013e", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/254022c13cd286d3697f97bc8ef6be7d90d18d9d/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254022c13cd286d3697f97bc8ef6be7d90d18d9d/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=254022c13cd286d3697f97bc8ef6be7d90d18d9d", "patch": "@@ -481,7 +481,7 @@ impl<'db> SemanticsImpl<'db> {\n         )\n     }\n \n-    // This might not be the correct way to due this, but it works for now\n+    // This might not be the correct way to do this, but it works for now\n     fn descend_node_into_attributes<N: AstNode>(&self, node: N) -> SmallVec<[N; 1]> {\n         let mut res = smallvec![];\n         let tokens = (|| {\n@@ -682,20 +682,7 @@ impl<'db> SemanticsImpl<'db> {\n     fn resolve_lifetime_param(&self, lifetime: &ast::Lifetime) -> Option<LifetimeParam> {\n         let text = lifetime.text();\n         let lifetime_param = lifetime.syntax().ancestors().find_map(|syn| {\n-            let gpl = match_ast! {\n-                match syn {\n-                    ast::Fn(it) => it.generic_param_list()?,\n-                    ast::TypeAlias(it) => it.generic_param_list()?,\n-                    ast::Struct(it) => it.generic_param_list()?,\n-                    ast::Enum(it) => it.generic_param_list()?,\n-                    ast::Union(it) => it.generic_param_list()?,\n-                    ast::Trait(it) => it.generic_param_list()?,\n-                    ast::Impl(it) => it.generic_param_list()?,\n-                    ast::WherePred(it) => it.generic_param_list()?,\n-                    ast::ForType(it) => it.generic_param_list()?,\n-                    _ => return None,\n-                }\n-            };\n+            let gpl = ast::DynGenericParamsOwner::cast(syn)?.generic_param_list()?;\n             gpl.lifetime_params()\n                 .find(|tp| tp.lifetime().as_ref().map(|lt| lt.text()).as_ref() == Some(&text))\n         })?;"}, {"sha": "0470b9510f3287f0efe35a14f11be99da6f82ed4", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/254022c13cd286d3697f97bc8ef6be7d90d18d9d/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254022c13cd286d3697f97bc8ef6be7d90d18d9d/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=254022c13cd286d3697f97bc8ef6be7d90d18d9d", "patch": "@@ -411,47 +411,47 @@ impl AttrsWithOwner {\n                 let file_id = id.parent.file_id(db);\n                 let root = db.parse_or_expand(file_id).unwrap();\n                 let owner = match &map[id.local_id] {\n-                    Either::Left(it) => ast::AttrsOwnerNode::new(it.to_node(&root)),\n-                    Either::Right(it) => ast::AttrsOwnerNode::new(it.to_node(&root)),\n+                    Either::Left(it) => ast::DynAttrsOwner::new(it.to_node(&root)),\n+                    Either::Right(it) => ast::DynAttrsOwner::new(it.to_node(&root)),\n                 };\n                 InFile::new(file_id, owner)\n             }\n             AttrDefId::AdtId(adt) => match adt {\n-                AdtId::StructId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n-                AdtId::UnionId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n-                AdtId::EnumId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+                AdtId::StructId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n+                AdtId::UnionId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n+                AdtId::EnumId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n             },\n-            AttrDefId::FunctionId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+            AttrDefId::FunctionId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n             AttrDefId::EnumVariantId(id) => {\n                 let map = db.variants_attrs_source_map(id.parent);\n                 let file_id = id.parent.lookup(db).id.file_id();\n                 let root = db.parse_or_expand(file_id).unwrap();\n-                InFile::new(file_id, ast::AttrsOwnerNode::new(map[id.local_id].to_node(&root)))\n+                InFile::new(file_id, ast::DynAttrsOwner::new(map[id.local_id].to_node(&root)))\n             }\n-            AttrDefId::StaticId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n-            AttrDefId::ConstId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n-            AttrDefId::TraitId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n-            AttrDefId::TypeAliasId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+            AttrDefId::StaticId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n+            AttrDefId::ConstId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n+            AttrDefId::TraitId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n+            AttrDefId::TypeAliasId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n             AttrDefId::MacroDefId(id) => id.ast_id().either(\n-                |it| it.with_value(ast::AttrsOwnerNode::new(it.to_node(db.upcast()))),\n-                |it| it.with_value(ast::AttrsOwnerNode::new(it.to_node(db.upcast()))),\n+                |it| it.with_value(ast::DynAttrsOwner::new(it.to_node(db.upcast()))),\n+                |it| it.with_value(ast::DynAttrsOwner::new(it.to_node(db.upcast()))),\n             ),\n-            AttrDefId::ImplId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+            AttrDefId::ImplId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n             AttrDefId::GenericParamId(id) => match id {\n                 GenericParamId::TypeParamId(id) => {\n                     id.parent.child_source(db).map(|source| match &source[id.local_id] {\n-                        Either::Left(id) => ast::AttrsOwnerNode::new(id.clone()),\n-                        Either::Right(id) => ast::AttrsOwnerNode::new(id.clone()),\n+                        Either::Left(id) => ast::DynAttrsOwner::new(id.clone()),\n+                        Either::Right(id) => ast::DynAttrsOwner::new(id.clone()),\n                     })\n                 }\n                 GenericParamId::LifetimeParamId(id) => id\n                     .parent\n                     .child_source(db)\n-                    .map(|source| ast::AttrsOwnerNode::new(source[id.local_id].clone())),\n+                    .map(|source| ast::DynAttrsOwner::new(source[id.local_id].clone())),\n                 GenericParamId::ConstParamId(id) => id\n                     .parent\n                     .child_source(db)\n-                    .map(|source| ast::AttrsOwnerNode::new(source[id.local_id].clone())),\n+                    .map(|source| ast::DynAttrsOwner::new(source[id.local_id].clone())),\n             },\n         };\n "}, {"sha": "7c9200f56888ed22ea75c852e2a11362e791dcba", "filename": "crates/syntax/src/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/254022c13cd286d3697f97bc8ef6be7d90d18d9d/crates%2Fsyntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254022c13cd286d3697f97bc8ef6be7d90d18d9d/crates%2Fsyntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast.rs?ref=254022c13cd286d3697f97bc8ef6be7d90d18d9d", "patch": "@@ -21,8 +21,8 @@ pub use self::{\n     expr_ext::{ArrayExprKind, Effect, ElseBranch, LiteralKind},\n     generated::{nodes::*, tokens::*},\n     node_ext::{\n-        AttrKind, AttrsOwnerNode, FieldKind, Macro, NameLike, NameOrNameRef, PathSegmentKind,\n-        SelfParamKind, SlicePatComponents, StructKind, TypeBoundKind, VisibilityKind,\n+        AttrKind, FieldKind, Macro, NameLike, NameOrNameRef, PathSegmentKind, SelfParamKind,\n+        SlicePatComponents, StructKind, TypeBoundKind, VisibilityKind,\n     },\n     operators::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, UnaryOp},\n     token_ext::{"}, {"sha": "547e7546364e6a92881ec553c7cfda865a2e080d", "filename": "crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/254022c13cd286d3697f97bc8ef6be7d90d18d9d/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254022c13cd286d3697f97bc8ef6be7d90d18d9d/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=254022c13cd286d3697f97bc8ef6be7d90d18d9d", "patch": "@@ -1445,6 +1445,46 @@ pub enum GenericParam {\n     TypeParam(TypeParam),\n }\n impl ast::AttrsOwner for GenericParam {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynArgListOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::ArgListOwner for DynArgListOwner {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynAttrsOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for DynAttrsOwner {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynGenericParamsOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::GenericParamsOwner for DynGenericParamsOwner {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynLoopBodyOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::LoopBodyOwner for DynLoopBodyOwner {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynModuleItemOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::ModuleItemOwner for DynModuleItemOwner {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynNameOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::NameOwner for DynNameOwner {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynTypeBoundsOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::TypeBoundsOwner for DynTypeBoundsOwner {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynVisibilityOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::VisibilityOwner for DynVisibilityOwner {}\n impl AstNode for Name {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -3564,6 +3604,219 @@ impl AstNode for GenericParam {\n         }\n     }\n }\n+impl DynArgListOwner {\n+    #[inline]\n+    pub fn new<T: ast::ArgListOwner>(node: T) -> DynArgListOwner {\n+        DynArgListOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynArgListOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            CALL_EXPR | METHOD_CALL_EXPR => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        Self::can_cast(syntax.kind()).then(|| DynArgListOwner { syntax })\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl DynAttrsOwner {\n+    #[inline]\n+    pub fn new<T: ast::AttrsOwner>(node: T) -> DynAttrsOwner {\n+        DynAttrsOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynAttrsOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MACRO_CALL\n+            | SOURCE_FILE\n+            | CONST\n+            | ENUM\n+            | EXTERN_BLOCK\n+            | EXTERN_CRATE\n+            | FN\n+            | IMPL\n+            | MACRO_RULES\n+            | MACRO_DEF\n+            | MODULE\n+            | STATIC\n+            | STRUCT\n+            | TRAIT\n+            | TYPE_ALIAS\n+            | UNION\n+            | USE\n+            | ITEM_LIST\n+            | BLOCK_EXPR\n+            | SELF_PARAM\n+            | PARAM\n+            | RECORD_FIELD\n+            | TUPLE_FIELD\n+            | VARIANT\n+            | ASSOC_ITEM_LIST\n+            | EXTERN_ITEM_LIST\n+            | CONST_PARAM\n+            | LIFETIME_PARAM\n+            | TYPE_PARAM\n+            | EXPR_STMT\n+            | LET_STMT\n+            | ARRAY_EXPR\n+            | AWAIT_EXPR\n+            | BIN_EXPR\n+            | BOX_EXPR\n+            | BREAK_EXPR\n+            | CALL_EXPR\n+            | CAST_EXPR\n+            | CLOSURE_EXPR\n+            | CONTINUE_EXPR\n+            | EFFECT_EXPR\n+            | FIELD_EXPR\n+            | FOR_EXPR\n+            | IF_EXPR\n+            | INDEX_EXPR\n+            | LITERAL\n+            | LOOP_EXPR\n+            | MATCH_EXPR\n+            | METHOD_CALL_EXPR\n+            | PAREN_EXPR\n+            | PATH_EXPR\n+            | PREFIX_EXPR\n+            | RANGE_EXPR\n+            | REF_EXPR\n+            | RETURN_EXPR\n+            | TRY_EXPR\n+            | TUPLE_EXPR\n+            | WHILE_EXPR\n+            | YIELD_EXPR\n+            | RECORD_EXPR_FIELD_LIST\n+            | RECORD_EXPR_FIELD\n+            | MATCH_ARM_LIST\n+            | MATCH_ARM\n+            | IDENT_PAT\n+            | RECORD_PAT_FIELD => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        Self::can_cast(syntax.kind()).then(|| DynAttrsOwner { syntax })\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl DynGenericParamsOwner {\n+    #[inline]\n+    pub fn new<T: ast::GenericParamsOwner>(node: T) -> DynGenericParamsOwner {\n+        DynGenericParamsOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynGenericParamsOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ENUM | FN | IMPL | STRUCT | TRAIT | TYPE_ALIAS | UNION => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        Self::can_cast(syntax.kind()).then(|| DynGenericParamsOwner { syntax })\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl DynLoopBodyOwner {\n+    #[inline]\n+    pub fn new<T: ast::LoopBodyOwner>(node: T) -> DynLoopBodyOwner {\n+        DynLoopBodyOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynLoopBodyOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            FOR_EXPR | LOOP_EXPR | WHILE_EXPR => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        Self::can_cast(syntax.kind()).then(|| DynLoopBodyOwner { syntax })\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl DynModuleItemOwner {\n+    #[inline]\n+    pub fn new<T: ast::ModuleItemOwner>(node: T) -> DynModuleItemOwner {\n+        DynModuleItemOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynModuleItemOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MACRO_ITEMS | SOURCE_FILE | ITEM_LIST => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        Self::can_cast(syntax.kind()).then(|| DynModuleItemOwner { syntax })\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl DynNameOwner {\n+    #[inline]\n+    pub fn new<T: ast::NameOwner>(node: T) -> DynNameOwner {\n+        DynNameOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynNameOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            CONST | ENUM | FN | MACRO_RULES | MACRO_DEF | MODULE | STATIC | STRUCT | TRAIT\n+            | TYPE_ALIAS | UNION | RENAME | SELF_PARAM | RECORD_FIELD | VARIANT | CONST_PARAM\n+            | TYPE_PARAM | IDENT_PAT => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        Self::can_cast(syntax.kind()).then(|| DynNameOwner { syntax })\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl DynTypeBoundsOwner {\n+    #[inline]\n+    pub fn new<T: ast::TypeBoundsOwner>(node: T) -> DynTypeBoundsOwner {\n+        DynTypeBoundsOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynTypeBoundsOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ASSOC_TYPE_ARG | TRAIT | TYPE_ALIAS | LIFETIME_PARAM | TYPE_PARAM | WHERE_PRED => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        Self::can_cast(syntax.kind()).then(|| DynTypeBoundsOwner { syntax })\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl DynVisibilityOwner {\n+    #[inline]\n+    pub fn new<T: ast::VisibilityOwner>(node: T) -> DynVisibilityOwner {\n+        DynVisibilityOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynVisibilityOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            CONST | ENUM | EXTERN_CRATE | FN | IMPL | MACRO_RULES | MACRO_DEF | MODULE | STATIC\n+            | STRUCT | TRAIT | TYPE_ALIAS | UNION | USE | RECORD_FIELD | TUPLE_FIELD | VARIANT => {\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        Self::can_cast(syntax.kind()).then(|| DynVisibilityOwner { syntax })\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n impl std::fmt::Display for GenericArg {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)"}, {"sha": "930e5ce74f77ebe174a053b01be4f7f6b0a0e87e", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/254022c13cd286d3697f97bc8ef6be7d90d18d9d/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254022c13cd286d3697f97bc8ef6be7d90d18d9d/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=254022c13cd286d3697f97bc8ef6be7d90d18d9d", "patch": "@@ -167,36 +167,6 @@ impl NameOwner for Macro {\n \n impl AttrsOwner for Macro {}\n \n-/// Basically an owned `dyn AttrsOwner` without extra boxing.\n-pub struct AttrsOwnerNode {\n-    node: SyntaxNode,\n-}\n-\n-impl AttrsOwnerNode {\n-    pub fn new<N: AttrsOwner>(node: N) -> Self {\n-        AttrsOwnerNode { node: node.syntax().clone() }\n-    }\n-}\n-\n-impl AttrsOwner for AttrsOwnerNode {}\n-impl AstNode for AttrsOwnerNode {\n-    fn can_cast(_: SyntaxKind) -> bool\n-    where\n-        Self: Sized,\n-    {\n-        false\n-    }\n-    fn cast(_: SyntaxNode) -> Option<Self>\n-    where\n-        Self: Sized,\n-    {\n-        None\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.node\n-    }\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum AttrKind {\n     Inner,\n@@ -602,16 +572,7 @@ impl ast::Variant {\n \n impl ast::Item {\n     pub fn generic_param_list(&self) -> Option<ast::GenericParamList> {\n-        match self {\n-            ast::Item::Enum(it) => it.generic_param_list(),\n-            ast::Item::Fn(it) => it.generic_param_list(),\n-            ast::Item::Impl(it) => it.generic_param_list(),\n-            ast::Item::Struct(it) => it.generic_param_list(),\n-            ast::Item::Trait(it) => it.generic_param_list(),\n-            ast::Item::TypeAlias(it) => it.generic_param_list(),\n-            ast::Item::Union(it) => it.generic_param_list(),\n-            _ => None,\n-        }\n+        ast::DynGenericParamsOwner::cast(self.syntax().clone())?.generic_param_list()\n     }\n }\n "}, {"sha": "1a0377830be1f345e6f152e251579874186c7377", "filename": "crates/syntax/src/tests/sourcegen_ast.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/254022c13cd286d3697f97bc8ef6be7d90d18d9d/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/254022c13cd286d3697f97bc8ef6be7d90d18d9d/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs?ref=254022c13cd286d3697f97bc8ef6be7d90d18d9d", "patch": "@@ -8,6 +8,7 @@ use std::{\n     fmt::Write,\n };\n \n+use itertools::Itertools;\n use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n use ungrammar::{rust_grammar, Grammar, Rule};\n@@ -208,6 +209,58 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> String {\n         })\n         .unzip();\n \n+    let (dyn_node_defs, dyn_node_boilerplate_impls): (Vec<_>, Vec<_>) = grammar\n+        .nodes\n+        .iter()\n+        .flat_map(|node| node.traits.iter().map(move |t| (t, node)))\n+        .into_group_map()\n+        .into_iter()\n+        .sorted_by_key(|(k, _)| k.clone())\n+        .map(|(trait_name, nodes)| {\n+            let name = format_ident!(\"Dyn{}\", trait_name);\n+            let trait_name = format_ident!(\"{}\", trait_name);\n+            let kinds: Vec<_> = nodes\n+                .iter()\n+                .map(|name| format_ident!(\"{}\", to_upper_snake_case(&name.name.to_string())))\n+                .collect();\n+\n+            (\n+                quote! {\n+                    #[pretty_doc_comment_placeholder_workaround]\n+                    #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+                    pub struct #name {\n+                        pub(crate) syntax: SyntaxNode,\n+                    }\n+                    impl ast::#trait_name for #name {}\n+                },\n+                quote! {\n+                    impl #name {\n+                        #[inline]\n+                        pub fn new<T: ast::#trait_name>(node: T) -> #name {\n+                            #name {\n+                                syntax: node.syntax().clone()\n+                            }\n+                        }\n+                    }\n+                    impl AstNode for #name {\n+                        fn can_cast(kind: SyntaxKind) -> bool {\n+                            match kind {\n+                                #(#kinds)|* => true,\n+                                _ => false,\n+                            }\n+                        }\n+                        fn cast(syntax: SyntaxNode) -> Option<Self> {\n+                            Self::can_cast(syntax.kind()).then(|| #name { syntax })\n+                        }\n+                        fn syntax(&self) -> &SyntaxNode {\n+                            &self.syntax\n+                        }\n+                    }\n+                },\n+            )\n+        })\n+        .unzip();\n+\n     let enum_names = grammar.enums.iter().map(|it| &it.name);\n     let node_names = grammar.nodes.iter().map(|it| &it.name);\n \n@@ -244,8 +297,10 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> String {\n \n         #(#node_defs)*\n         #(#enum_defs)*\n+        #(#dyn_node_defs)*\n         #(#node_boilerplate_impls)*\n         #(#enum_boilerplate_impls)*\n+        #(#dyn_node_boilerplate_impls)*\n         #(#display_impls)*\n     };\n "}]}