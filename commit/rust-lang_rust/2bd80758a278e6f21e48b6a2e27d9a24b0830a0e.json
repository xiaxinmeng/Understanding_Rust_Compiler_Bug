{"sha": "2bd80758a278e6f21e48b6a2e27d9a24b0830a0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiZDgwNzU4YTI3OGU2ZjIxZTQ4YjZhMmUyN2Q5YTI0YjA4MzBhMGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-02T01:56:55Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-03T16:13:00Z"}, "message": "Continue tightening holes in reachability\n\n* Don't flag any address_insignificant statics as reachable because the whole\n  point of the address_insignificant optimization is that the static is not\n  reachable. Additionally, there's no need for it to be reachable because LLVM\n  optimizes it away.\n\n* Be sure to not leak external node ids into our reachable set, this can\n  spuriously cause local items to be considered reachable if the node ids just\n  happen to line up", "tree": {"sha": "d3fb0be25091066d104c19f16d8677aa77900c73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3fb0be25091066d104c19f16d8677aa77900c73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bd80758a278e6f21e48b6a2e27d9a24b0830a0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd80758a278e6f21e48b6a2e27d9a24b0830a0e", "html_url": "https://github.com/rust-lang/rust/commit/2bd80758a278e6f21e48b6a2e27d9a24b0830a0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bd80758a278e6f21e48b6a2e27d9a24b0830a0e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18084be3164d2fe7c540662ea1e44cf73af9bf0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/18084be3164d2fe7c540662ea1e44cf73af9bf0f", "html_url": "https://github.com/rust-lang/rust/commit/18084be3164d2fe7c540662ea1e44cf73af9bf0f"}], "stats": {"total": 59, "additions": 45, "deletions": 14}, "files": [{"sha": "85d702d577ea3a9aa4d8497a15e9ca8996d83451", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2bd80758a278e6f21e48b6a2e27d9a24b0830a0e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd80758a278e6f21e48b6a2e27d9a24b0830a0e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=2bd80758a278e6f21e48b6a2e27d9a24b0830a0e", "patch": "@@ -128,25 +128,44 @@ impl Visitor<()> for MarkSymbolVisitor {\n                 };\n \n                 let def_id = def_id_of_def(def);\n-                if ReachableContext::\n-                    def_id_represents_local_inlined_item(self.tcx, def_id) {\n-                        self.worklist.push(def_id.node)\n+                if is_local(def_id) {\n+                    if ReachableContext::\n+                        def_id_represents_local_inlined_item(self.tcx, def_id) {\n+                            self.worklist.push(def_id.node)\n+                    } else {\n+                        match def {\n+                            // If this path leads to a static, then we may have\n+                            // to do some work to figure out whether the static\n+                            // is indeed reachable (address_insignificant\n+                            // statics are *never* reachable).\n+                            ast::DefStatic(..) => {\n+                                self.worklist.push(def_id.node);\n+                            }\n+\n+                            // If this wasn't a static, then this destination is\n+                            // surely reachable.\n+                            _ => {\n+                                self.reachable_symbols.insert(def_id.node);\n+                            }\n+                        }\n                     }\n-                self.reachable_symbols.insert(def_id.node);\n+                }\n             }\n             ast::ExprMethodCall(..) => {\n                 match self.method_map.find(&expr.id) {\n                     Some(&typeck::method_map_entry {\n                         origin: typeck::method_static(def_id),\n                         ..\n                     }) => {\n-                        if ReachableContext::\n-                            def_id_represents_local_inlined_item(\n-                                self.tcx,\n-                                def_id) {\n-                                self.worklist.push(def_id.node)\n-                            }\n-                        self.reachable_symbols.insert(def_id.node);\n+                        if is_local(def_id) {\n+                            if ReachableContext::\n+                                def_id_represents_local_inlined_item(\n+                                    self.tcx,\n+                                    def_id) {\n+                                    self.worklist.push(def_id.node)\n+                                }\n+                            self.reachable_symbols.insert(def_id.node);\n+                        }\n                     }\n                     Some(_) => {}\n                     None => {\n@@ -310,10 +329,19 @@ impl ReachableContext {\n                         }\n                     }\n \n+                    // Statics with insignificant addresses are not reachable\n+                    // because they're inlined specially into all other crates.\n+                    ast::item_static(..) => {\n+                        if attr::contains_name(item.attrs,\n+                                               \"address_insignificant\") {\n+                            self.reachable_symbols.remove(&search_item);\n+                        }\n+                    }\n+\n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n-                    ast::item_static(..) | ast::item_ty(..) |\n+                    ast::item_ty(..) |\n                     ast::item_mod(..) | ast::item_foreign_mod(..) |\n                     ast::item_impl(..) | ast::item_trait(..) |\n                     ast::item_struct(..) | ast::item_enum(..) => {}"}, {"sha": "d4586fc59905bd0244655da3ca6084f949dc7e50", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2bd80758a278e6f21e48b6a2e27d9a24b0830a0e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bd80758a278e6f21e48b6a2e27d9a24b0830a0e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2bd80758a278e6f21e48b6a2e27d9a24b0830a0e", "patch": "@@ -2521,9 +2521,12 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                                 // requested\n                                 if attr::contains_name(i.attrs,\n                                                        \"address_insignificant\"){\n+                                    if ccx.reachable.contains(&id) {\n+                                        ccx.sess.span_bug(i.span,\n+                                            \"insignificant static is \\\n+                                             reachable\");\n+                                    }\n                                     lib::llvm::SetUnnamedAddr(g, true);\n-                                    lib::llvm::SetLinkage(g,\n-                                        lib::llvm::InternalLinkage);\n \n                                     // This is a curious case where we must make\n                                     // all of these statics inlineable. If a"}]}