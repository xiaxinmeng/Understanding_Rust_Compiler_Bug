{"sha": "6938717ca5fe8035d4aea3cf89664afdd6b137b1", "node_id": "C_kwDOAAsO6NoAKDY5Mzg3MTdjYTVmZTgwMzVkNGFlYTNjZjg5NjY0YWZkZDZiMTM3YjE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-24T07:42:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-24T07:42:35Z"}, "message": "Rollup merge of #104753 - compiler-errors:drop-tracking-var-ice, r=oli-obk\n\nPass `InferCtxt` to `DropRangeVisitor` so we can resolve vars\n\nThe types that we encounter in the  `TypeckResults` that we pass to the `DropRangeVisitor` are not yet fully resolved, since that only happens in writeback after type checking is complete.\n\nInstead, pass down the whole `InferCtxt` so that we can resolve any inference vars that have been constrained since they were written into the results. This is similar to how the `MemCategorizationContext` in the `ExprUseVisitor` also needs to pass down both typeck results _and_ the inference context.\n\nFixes an ICE mentioned in this comment: https://github.com/rust-lang/rust/issues/104382#issuecomment-1324410781", "tree": {"sha": "fdf96bb1d8ee712a064b954ab5a715fe849a5a30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdf96bb1d8ee712a064b954ab5a715fe849a5a30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6938717ca5fe8035d4aea3cf89664afdd6b137b1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjfyBrCRBK7hj4Ov3rIwAA8/AIAIosD2f2gIiM4kNgKmvOFHcc\nh56Og2kbrMN5J9JEsqUlM5HHy9G2w+o47stlMRN8OXaSdvUQWSfwMfLtvOm67EMC\nmudJ65gfAoTDQtLzz0gS3hpAr8uG6JNZVQsci0rNfLbWobRc9RH/bIpZJcWQyUQ4\n9nKzy7ny+rpSCegrkzlA0f2K9J4XfhYOhKvXSSV+fP/a2lrhzaPbGY/Przm7zadU\nGl4G9ISNPnxx7En3gRLfhXTf53dA7BcBxTyO6q5dMe+xQKaa1ekean65ULW056f3\nIBe0UNpv5ZlGTwlmBCyBx3JaRiLYE0/NUYH6oiQEkS5iVKEYoBuZLfZn7c4sjZ4=\n=jSHe\n-----END PGP SIGNATURE-----\n", "payload": "tree fdf96bb1d8ee712a064b954ab5a715fe849a5a30\nparent c08c57e856e0536accad812d43f458004c439613\nparent 024bb8c7fb8b31e36e559a566bcaf4e7a85fe36b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1669275755 +0100\ncommitter GitHub <noreply@github.com> 1669275755 +0100\n\nRollup merge of #104753 - compiler-errors:drop-tracking-var-ice, r=oli-obk\n\nPass `InferCtxt` to `DropRangeVisitor` so we can resolve vars\n\nThe types that we encounter in the  `TypeckResults` that we pass to the `DropRangeVisitor` are not yet fully resolved, since that only happens in writeback after type checking is complete.\n\nInstead, pass down the whole `InferCtxt` so that we can resolve any inference vars that have been constrained since they were written into the results. This is similar to how the `MemCategorizationContext` in the `ExprUseVisitor` also needs to pass down both typeck results _and_ the inference context.\n\nFixes an ICE mentioned in this comment: https://github.com/rust-lang/rust/issues/104382#issuecomment-1324410781\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6938717ca5fe8035d4aea3cf89664afdd6b137b1", "html_url": "https://github.com/rust-lang/rust/commit/6938717ca5fe8035d4aea3cf89664afdd6b137b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6938717ca5fe8035d4aea3cf89664afdd6b137b1/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c08c57e856e0536accad812d43f458004c439613", "url": "https://api.github.com/repos/rust-lang/rust/commits/c08c57e856e0536accad812d43f458004c439613", "html_url": "https://github.com/rust-lang/rust/commit/c08c57e856e0536accad812d43f458004c439613"}, {"sha": "024bb8c7fb8b31e36e559a566bcaf4e7a85fe36b", "url": "https://api.github.com/repos/rust-lang/rust/commits/024bb8c7fb8b31e36e559a566bcaf4e7a85fe36b", "html_url": "https://github.com/rust-lang/rust/commit/024bb8c7fb8b31e36e559a566bcaf4e7a85fe36b"}], "stats": {"total": 235, "additions": 211, "deletions": 24}, "files": [{"sha": "fd8ea1ad7bff4c503d3e93203fe800a75601f995", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6938717ca5fe8035d4aea3cf89664afdd6b137b1/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6938717ca5fe8035d4aea3cf89664afdd6b137b1/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=6938717ca5fe8035d4aea3cf89664afdd6b137b1", "patch": "@@ -9,9 +9,10 @@ use hir::{\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_index::vec::IndexVec;\n+use rustc_infer::infer::InferCtxt;\n use rustc_middle::{\n     hir::map::Map,\n-    ty::{TyCtxt, TypeckResults},\n+    ty::{ParamEnv, TyCtxt, TypeVisitable, TypeckResults},\n };\n use std::mem::swap;\n \n@@ -21,20 +22,29 @@ use std::mem::swap;\n /// The resulting structure still needs to be iterated to a fixed point, which\n /// can be done with propagate_to_fixpoint in cfg_propagate.\n pub(super) fn build_control_flow_graph<'tcx>(\n-    hir: Map<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     typeck_results: &TypeckResults<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     consumed_borrowed_places: ConsumedAndBorrowedPlaces,\n     body: &'tcx Body<'tcx>,\n     num_exprs: usize,\n ) -> (DropRangesBuilder, FxHashSet<HirId>) {\n-    let mut drop_range_visitor =\n-        DropRangeVisitor::new(hir, tcx, typeck_results, consumed_borrowed_places, num_exprs);\n+    let mut drop_range_visitor = DropRangeVisitor::new(\n+        infcx,\n+        typeck_results,\n+        param_env,\n+        consumed_borrowed_places,\n+        num_exprs,\n+    );\n     intravisit::walk_body(&mut drop_range_visitor, body);\n \n     drop_range_visitor.drop_ranges.process_deferred_edges();\n-    if let Some(filename) = &tcx.sess.opts.unstable_opts.dump_drop_tracking_cfg {\n-        super::cfg_visualize::write_graph_to_file(&drop_range_visitor.drop_ranges, filename, tcx);\n+    if let Some(filename) = &infcx.tcx.sess.opts.unstable_opts.dump_drop_tracking_cfg {\n+        super::cfg_visualize::write_graph_to_file(\n+            &drop_range_visitor.drop_ranges,\n+            filename,\n+            infcx.tcx,\n+        );\n     }\n \n     (drop_range_visitor.drop_ranges, drop_range_visitor.places.borrowed_temporaries)\n@@ -82,40 +92,44 @@ pub(super) fn build_control_flow_graph<'tcx>(\n /// ```\n \n struct DropRangeVisitor<'a, 'tcx> {\n-    hir: Map<'tcx>,\n+    typeck_results: &'a TypeckResults<'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     places: ConsumedAndBorrowedPlaces,\n     drop_ranges: DropRangesBuilder,\n     expr_index: PostOrderId,\n-    tcx: TyCtxt<'tcx>,\n-    typeck_results: &'a TypeckResults<'tcx>,\n     label_stack: Vec<(Option<rustc_ast::Label>, PostOrderId)>,\n }\n \n impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n     fn new(\n-        hir: Map<'tcx>,\n-        tcx: TyCtxt<'tcx>,\n+        infcx: &'a InferCtxt<'tcx>,\n         typeck_results: &'a TypeckResults<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n         places: ConsumedAndBorrowedPlaces,\n         num_exprs: usize,\n     ) -> Self {\n         debug!(\"consumed_places: {:?}\", places.consumed);\n         let drop_ranges = DropRangesBuilder::new(\n             places.consumed.iter().flat_map(|(_, places)| places.iter().cloned()),\n-            hir,\n+            infcx.tcx.hir(),\n             num_exprs,\n         );\n         Self {\n-            hir,\n+            infcx,\n+            typeck_results,\n+            param_env,\n             places,\n             drop_ranges,\n             expr_index: PostOrderId::from_u32(0),\n-            typeck_results,\n-            tcx,\n             label_stack: vec![],\n         }\n     }\n \n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n     fn record_drop(&mut self, value: TrackedValue) {\n         if self.places.borrowed.contains(&value) {\n             debug!(\"not marking {:?} as dropped because it is borrowed at some point\", value);\n@@ -137,7 +151,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n             .map_or(vec![], |places| places.iter().cloned().collect());\n         for place in places {\n             trace!(?place, \"consuming place\");\n-            for_each_consumable(self.hir, place, |value| self.record_drop(value));\n+            for_each_consumable(self.tcx().hir(), place, |value| self.record_drop(value));\n         }\n     }\n \n@@ -214,10 +228,15 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n     /// return.\n     fn handle_uninhabited_return(&mut self, expr: &Expr<'tcx>) {\n         let ty = self.typeck_results.expr_ty(expr);\n-        let ty = self.tcx.erase_regions(ty);\n-        let m = self.tcx.parent_module(expr.hir_id).to_def_id();\n-        let param_env = self.tcx.param_env(m.expect_local());\n-        if !ty.is_inhabited_from(self.tcx, m, param_env) {\n+        let ty = self.infcx.resolve_vars_if_possible(ty);\n+        if ty.has_non_region_infer() {\n+            self.tcx()\n+                .sess\n+                .delay_span_bug(expr.span, format!(\"could not resolve infer vars in `{ty}`\"));\n+        }\n+        let ty = self.tcx().erase_regions(ty);\n+        let m = self.tcx().parent_module(expr.hir_id).to_def_id();\n+        if !ty.is_inhabited_from(self.tcx(), m, self.param_env) {\n             // This function will not return. We model this fact as an infinite loop.\n             self.drop_ranges.add_control_edge(self.expr_index + 1, self.expr_index + 1);\n         }\n@@ -238,7 +257,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n         destination: hir::Destination,\n     ) -> Result<HirId, LoopIdError> {\n         destination.target_id.map(|target| {\n-            let node = self.hir.get(target);\n+            let node = self.tcx().hir().get(target);\n             match node {\n                 hir::Node::Expr(_) => target,\n                 hir::Node::Block(b) => find_last_block_expression(b),"}, {"sha": "2abcadcc9ce7de4f6335daf6c9febc0ca8d3a6c4", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6938717ca5fe8035d4aea3cf89664afdd6b137b1/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6938717ca5fe8035d4aea3cf89664afdd6b137b1/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs?ref=6938717ca5fe8035d4aea3cf89664afdd6b137b1", "patch": "@@ -43,9 +43,9 @@ pub fn compute_drop_ranges<'a, 'tcx>(\n         let typeck_results = &fcx.typeck_results.borrow();\n         let num_exprs = fcx.tcx.region_scope_tree(def_id).body_expr_count(body.id()).unwrap_or(0);\n         let (mut drop_ranges, borrowed_temporaries) = build_control_flow_graph(\n-            fcx.tcx.hir(),\n-            fcx.tcx,\n+            &fcx,\n             typeck_results,\n+            fcx.param_env,\n             consumed_borrowed_places,\n             body,\n             num_exprs,"}, {"sha": "7f72942958141bf055d41db2272856dcd307ed7e", "filename": "src/test/ui/async-await/drop-tracking-unresolved-typeck-results.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/6938717ca5fe8035d4aea3cf89664afdd6b137b1/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6938717ca5fe8035d4aea3cf89664afdd6b137b1/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.rs?ref=6938717ca5fe8035d4aea3cf89664afdd6b137b1", "patch": "@@ -0,0 +1,106 @@\n+// compile-flags: -Zdrop-tracking\n+// incremental\n+// edition: 2021\n+\n+use std::future::*;\n+use std::marker::PhantomData;\n+use std::pin::Pin;\n+use std::task::*;\n+\n+fn send<T: Send>(_: T) {}\n+\n+pub trait Stream {\n+    type Item;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;\n+}\n+\n+struct Empty<T>(PhantomData<fn() -> T>);\n+\n+impl<T> Stream for Empty<T> {\n+    type Item = T;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        todo!()\n+    }\n+}\n+\n+pub trait FnOnce1<A> {\n+    type Output;\n+    fn call_once(self, arg: A) -> Self::Output;\n+}\n+\n+impl<T, A, R> FnOnce1<A> for T\n+where\n+    T: FnOnce(A) -> R,\n+{\n+    type Output = R;\n+    fn call_once(self, arg: A) -> R {\n+        self(arg)\n+    }\n+}\n+\n+pub trait FnMut1<A>: FnOnce1<A> {\n+    fn call_mut(&mut self, arg: A) -> Self::Output;\n+}\n+\n+impl<T, A, R> FnMut1<A> for T\n+where\n+    T: FnMut(A) -> R,\n+{\n+    fn call_mut(&mut self, arg: A) -> R {\n+        self(arg)\n+    }\n+}\n+\n+struct Map<St, F>(St, F);\n+\n+impl<St, F> Stream for Map<St, F>\n+where\n+    St: Stream,\n+    F: FnMut1<St::Item>,\n+{\n+    type Item = F::Output;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        todo!()\n+    }\n+}\n+\n+struct FuturesOrdered<T: Future>(PhantomData<fn() -> T::Output>);\n+\n+pub struct Buffered<St: Stream>(St, FuturesOrdered<St::Item>, usize)\n+where\n+    St::Item: Future;\n+\n+impl<St> Stream for Buffered<St>\n+where\n+    St: Stream,\n+    St::Item: Future,\n+{\n+    type Item = <St::Item as Future>::Output;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        todo!()\n+    }\n+}\n+\n+struct Next<'a, T: ?Sized>(&'a T);\n+\n+impl<St: ?Sized + Stream + Unpin> Future for Next<'_, St> {\n+    type Output = Option<St::Item>;\n+\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        todo!()\n+    }\n+}\n+\n+fn main() {\n+    send(async {\n+        //~^ ERROR implementation of `FnOnce` is not general enough\n+        //~| ERROR implementation of `FnOnce` is not general enough\n+        //~| ERROR implementation of `FnOnce` is not general enough\n+        //~| ERROR implementation of `FnOnce` is not general enough\n+        Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+    });\n+}"}, {"sha": "aa9a22e9e72ea53d4da1fc04f7c4a54635eed6a8", "filename": "src/test/ui/async-await/drop-tracking-unresolved-typeck-results.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6938717ca5fe8035d4aea3cf89664afdd6b137b1/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6938717ca5fe8035d4aea3cf89664afdd6b137b1/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-tracking-unresolved-typeck-results.stderr?ref=6938717ca5fe8035d4aea3cf89664afdd6b137b1", "patch": "@@ -0,0 +1,62 @@\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/drop-tracking-unresolved-typeck-results.rs:99:5\n+   |\n+LL | /     send(async {\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+LL | |     });\n+   | |______^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&'0 ()) -> std::future::Ready<&'0 ()> {std::future::ready::<&'0 ()>}` must implement `FnOnce<(&'1 (),)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but it actually implements `FnOnce<(&(),)>`\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/drop-tracking-unresolved-typeck-results.rs:99:5\n+   |\n+LL | /     send(async {\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+LL | |     });\n+   | |______^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&'0 ()) -> std::future::Ready<&'0 ()> {std::future::ready::<&'0 ()>}` must implement `FnOnce<(&'1 (),)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but it actually implements `FnOnce<(&(),)>`\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/drop-tracking-unresolved-typeck-results.rs:99:5\n+   |\n+LL | /     send(async {\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+LL | |     });\n+   | |______^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&'0 ()) -> std::future::Ready<&'0 ()> {std::future::ready::<&'0 ()>}` must implement `FnOnce<(&'1 (),)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but it actually implements `FnOnce<(&(),)>`\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/drop-tracking-unresolved-typeck-results.rs:99:5\n+   |\n+LL | /     send(async {\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | |         Next(&Buffered(Map(Empty(PhantomData), ready::<&()>), FuturesOrdered(PhantomData), 0)).await\n+LL | |     });\n+   | |______^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: `fn(&'0 ()) -> std::future::Ready<&'0 ()> {std::future::ready::<&'0 ()>}` must implement `FnOnce<(&'1 (),)>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but it actually implements `FnOnce<(&(),)>`\n+\n+error: aborting due to 4 previous errors\n+"}]}