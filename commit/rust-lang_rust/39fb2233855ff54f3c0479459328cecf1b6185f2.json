{"sha": "39fb2233855ff54f3c0479459328cecf1b6185f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZmIyMjMzODU1ZmY1NGYzYzA0Nzk0NTkzMjhjZWNmMWI2MTg1ZjI=", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-02-21T22:38:35Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2021-02-22T01:32:23Z"}, "message": "Partially carve macros.rs into other files\n\nThe base impl_vector! in macros.rs is staying put for the moment as\nit must go first before everything in order to work.\n\nEverything else, like transmutes, specific type impls, etc. have\nbeen moved into appropriate files elsewhere to subdivide concerns.", "tree": {"sha": "903ba7e139f08c22b308bf7606d39c2b8f6917d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/903ba7e139f08c22b308bf7606d39c2b8f6917d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39fb2233855ff54f3c0479459328cecf1b6185f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39fb2233855ff54f3c0479459328cecf1b6185f2", "html_url": "https://github.com/rust-lang/rust/commit/39fb2233855ff54f3c0479459328cecf1b6185f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39fb2233855ff54f3c0479459328cecf1b6185f2/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca15e4fcd8dbf2a5eaa33e7b548b7b3f61cd590f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca15e4fcd8dbf2a5eaa33e7b548b7b3f61cd590f", "html_url": "https://github.com/rust-lang/rust/commit/ca15e4fcd8dbf2a5eaa33e7b548b7b3f61cd590f"}], "stats": {"total": 230, "additions": 130, "deletions": 100}, "files": [{"sha": "5ed142197f8c01a2091827b52ad1120253619c5c", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39fb2233855ff54f3c0479459328cecf1b6185f2/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fb2233855ff54f3c0479459328cecf1b6185f2/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=39fb2233855ff54f3c0479459328cecf1b6185f2", "patch": "@@ -8,6 +8,8 @@\n mod macros;\n #[macro_use]\n mod permute;\n+#[macro_use]\n+mod transmute;\n \n mod fmt;\n mod intrinsics;"}, {"sha": "b18fe5213a3d184aaf1445c47c86e2dda7962251", "filename": "crates/core_simd/src/macros.rs", "status": "modified", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/39fb2233855ff54f3c0479459328cecf1b6185f2/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fb2233855ff54f3c0479459328cecf1b6185f2/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmacros.rs?ref=39fb2233855ff54f3c0479459328cecf1b6185f2", "patch": "@@ -1,31 +1,3 @@\n-/// Provides implementations of `From<$a> for $b` and `From<$b> for $a` that transmutes the value.\n-macro_rules! from_transmute {\n-    { unsafe $a:ty => $b:ty } => {\n-        from_transmute!{ @impl $a => $b }\n-        from_transmute!{ @impl $b => $a }\n-    };\n-    { @impl $from:ty => $to:ty } => {\n-        impl core::convert::From<$from> for $to {\n-            #[inline]\n-            fn from(value: $from) -> $to {\n-                unsafe { core::mem::transmute(value) }\n-            }\n-        }\n-    };\n-}\n-\n-/// Provides implementations of `From<$generic> for core::arch::{x86, x86_64}::$intel` and\n-/// vice-versa that transmutes the value.\n-macro_rules! from_transmute_x86 {\n-    { unsafe $generic:ty => $intel:ident } => {\n-        #[cfg(target_arch = \"x86\")]\n-        from_transmute! { unsafe $generic => core::arch::x86::$intel }\n-\n-        #[cfg(target_arch = \"x86_64\")]\n-        from_transmute! { unsafe $generic => core::arch::x86_64::$intel }\n-    }\n-}\n-\n /// Implements common traits on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_vector {\n     { $name:ident, $type:ty } => {\n@@ -150,69 +122,3 @@ macro_rules! impl_vector {\n         impl_shuffle_2pow_lanes!{ $name }\n     }\n }\n-\n-/// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n-macro_rules! impl_integer_vector {\n-    { $name:ident, $type:ty } => {\n-        impl_vector! { $name, $type }\n-\n-        impl<const LANES: usize> Eq for $name<LANES> where Self: crate::LanesAtMost64 {}\n-\n-        impl<const LANES: usize> Ord for $name<LANES> where Self: crate::LanesAtMost64 {\n-            #[inline]\n-            fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n-                // TODO use SIMD cmp\n-                self.to_array().cmp(other.as_ref())\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::hash::Hash for $name<LANES> where Self: crate::LanesAtMost64 {\n-            #[inline]\n-            fn hash<H>(&self, state: &mut H)\n-            where\n-                H: core::hash::Hasher\n-            {\n-                self.as_slice().hash(state)\n-            }\n-        }\n-    }\n-}\n-\n-/// Implements inherent methods for a float vector `$name` containing multiple\n-/// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n-/// representation. Called from `define_float_vector!`.\n-macro_rules! impl_float_vector {\n-    { $name:ident, $type:ty, $bits_ty:ident } => {\n-        impl_vector! { $name, $type }\n-\n-        impl<const LANES: usize> $name<LANES>\n-        where\n-            Self: crate::LanesAtMost64,\n-            crate::$bits_ty<LANES>: crate::LanesAtMost64,\n-        {\n-            /// Raw transmutation to an unsigned integer vector type with the\n-            /// same size and number of lanes.\n-            #[inline]\n-            pub fn to_bits(self) -> crate::$bits_ty<LANES> {\n-                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<crate::$bits_ty<LANES>>());\n-                unsafe { core::mem::transmute_copy(&self) }\n-            }\n-\n-            /// Raw transmutation from an unsigned integer vector type with the\n-            /// same size and number of lanes.\n-            #[inline]\n-            pub fn from_bits(bits: crate::$bits_ty<LANES>) -> Self {\n-                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<crate::$bits_ty<LANES>>());\n-                unsafe { core::mem::transmute_copy(&bits) }\n-            }\n-\n-            /// Produces a vector where every lane has the absolute value of the\n-            /// equivalently-indexed lane in `self`.\n-            #[inline]\n-            pub fn abs(self) -> Self {\n-                let no_sign = crate::$bits_ty::splat(!0 >> 1);\n-                Self::from_bits(self.to_bits() & no_sign)\n-            }\n-        }\n-    };\n-}"}, {"sha": "835d863029c5e6a0a137135eb8b227886b215ecc", "filename": "crates/core_simd/src/transmute.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/39fb2233855ff54f3c0479459328cecf1b6185f2/crates%2Fcore_simd%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fb2233855ff54f3c0479459328cecf1b6185f2/crates%2Fcore_simd%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ftransmute.rs?ref=39fb2233855ff54f3c0479459328cecf1b6185f2", "patch": "@@ -0,0 +1,27 @@\n+/// Provides implementations of `From<$a> for $b` and `From<$b> for $a` that transmutes the value.\n+macro_rules! from_transmute {\n+    { unsafe $a:ty => $b:ty } => {\n+        from_transmute!{ @impl $a => $b }\n+        from_transmute!{ @impl $b => $a }\n+    };\n+    { @impl $from:ty => $to:ty } => {\n+        impl core::convert::From<$from> for $to {\n+            #[inline]\n+            fn from(value: $from) -> $to {\n+                unsafe { core::mem::transmute(value) }\n+            }\n+        }\n+    };\n+}\n+\n+/// Provides implementations of `From<$generic> for core::arch::{x86, x86_64}::$intel` and\n+/// vice-versa that transmutes the value.\n+macro_rules! from_transmute_x86 {\n+    { unsafe $generic:ty => $intel:ident } => {\n+        #[cfg(target_arch = \"x86\")]\n+        from_transmute! { unsafe $generic => core::arch::x86::$intel }\n+\n+        #[cfg(target_arch = \"x86_64\")]\n+        from_transmute! { unsafe $generic => core::arch::x86_64::$intel }\n+    }\n+}"}, {"sha": "9031e12b604f7657869c53ec3e4c6d75d295b54a", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/39fb2233855ff54f3c0479459328cecf1b6185f2/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fb2233855ff54f3c0479459328cecf1b6185f2/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=39fb2233855ff54f3c0479459328cecf1b6185f2", "patch": "@@ -1,5 +1,45 @@\n #![allow(non_camel_case_types)]\n \n+/// Implements inherent methods for a float vector `$name` containing multiple\n+/// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n+/// representation. Called from `define_float_vector!`.\n+macro_rules! impl_float_vector {\n+    { $name:ident, $type:ty, $bits_ty:ident } => {\n+        impl_vector! { $name, $type }\n+\n+        impl<const LANES: usize> $name<LANES>\n+        where\n+            Self: crate::LanesAtMost64,\n+            crate::$bits_ty<LANES>: crate::LanesAtMost64,\n+        {\n+            /// Raw transmutation to an unsigned integer vector type with the\n+            /// same size and number of lanes.\n+            #[inline]\n+            pub fn to_bits(self) -> crate::$bits_ty<LANES> {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<crate::$bits_ty<LANES>>());\n+                unsafe { core::mem::transmute_copy(&self) }\n+            }\n+\n+            /// Raw transmutation from an unsigned integer vector type with the\n+            /// same size and number of lanes.\n+            #[inline]\n+            pub fn from_bits(bits: crate::$bits_ty<LANES>) -> Self {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<crate::$bits_ty<LANES>>());\n+                unsafe { core::mem::transmute_copy(&bits) }\n+            }\n+\n+            /// Produces a vector where every lane has the absolute value of the\n+            /// equivalently-indexed lane in `self`.\n+            #[inline]\n+            pub fn abs(self) -> Self {\n+                let no_sign = crate::$bits_ty::splat(!0 >> 1);\n+                Self::from_bits(self.to_bits() & no_sign)\n+            }\n+        }\n+    };\n+}\n+\n+\n /// A SIMD vector of containing `LANES` `f32` values.\n #[repr(simd)]\n pub struct SimdF32<const LANES: usize>([f32; LANES])"}, {"sha": "86762f74ff4778b173a0d349ec54d463ef98782e", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/39fb2233855ff54f3c0479459328cecf1b6185f2/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fb2233855ff54f3c0479459328cecf1b6185f2/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=39fb2233855ff54f3c0479459328cecf1b6185f2", "patch": "@@ -1,5 +1,32 @@\n #![allow(non_camel_case_types)]\n \n+/// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n+macro_rules! impl_integer_vector {\n+    { $name:ident, $type:ty } => {\n+        impl_vector! { $name, $type }\n+\n+        impl<const LANES: usize> Eq for $name<LANES> where Self: crate::LanesAtMost64 {}\n+\n+        impl<const LANES: usize> Ord for $name<LANES> where Self: crate::LanesAtMost64 {\n+            #[inline]\n+            fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+                // TODO use SIMD cmp\n+                self.to_array().cmp(other.as_ref())\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::hash::Hash for $name<LANES> where Self: crate::LanesAtMost64 {\n+            #[inline]\n+            fn hash<H>(&self, state: &mut H)\n+            where\n+                H: core::hash::Hasher\n+            {\n+                self.as_slice().hash(state)\n+            }\n+        }\n+    }\n+}\n+\n /// A SIMD vector of containing `LANES` `isize` values.\n #[repr(simd)]\n pub struct SimdIsize<const LANES: usize>([isize; LANES])"}, {"sha": "0f7a47eee30ec1e260c7e334665986643f1cbab2", "filename": "crates/core_simd/src/vector/uint.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/39fb2233855ff54f3c0479459328cecf1b6185f2/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fb2233855ff54f3c0479459328cecf1b6185f2/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=39fb2233855ff54f3c0479459328cecf1b6185f2", "patch": "@@ -1,12 +1,40 @@\n #![allow(non_camel_case_types)]\n \n+\n+/// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n+macro_rules! impl_unsigned_vector {\n+    { $name:ident, $type:ty } => {\n+        impl_vector! { $name, $type }\n+\n+        impl<const LANES: usize> Eq for $name<LANES> where Self: crate::LanesAtMost64 {}\n+\n+        impl<const LANES: usize> Ord for $name<LANES> where Self: crate::LanesAtMost64 {\n+            #[inline]\n+            fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+                // TODO use SIMD cmp\n+                self.to_array().cmp(other.as_ref())\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::hash::Hash for $name<LANES> where Self: crate::LanesAtMost64 {\n+            #[inline]\n+            fn hash<H>(&self, state: &mut H)\n+            where\n+                H: core::hash::Hasher\n+            {\n+                self.as_slice().hash(state)\n+            }\n+        }\n+    }\n+}\n+\n /// A SIMD vector of containing `LANES` `usize` values.\n #[repr(simd)]\n pub struct SimdUsize<const LANES: usize>([usize; LANES])\n where\n     Self: crate::LanesAtMost64;\n \n-impl_integer_vector! { SimdUsize, usize }\n+impl_unsigned_vector! { SimdUsize, usize }\n \n #[cfg(target_pointer_width = \"32\")]\n from_transmute_x86! { unsafe usizex4 => __m128i }\n@@ -26,7 +54,7 @@ pub struct SimdU128<const LANES: usize>([u128; LANES])\n where\n     Self: crate::LanesAtMost64;\n \n-impl_integer_vector! { SimdU128, u128 }\n+impl_unsigned_vector! { SimdU128, u128 }\n \n from_transmute_x86! { unsafe u128x2 => __m256i }\n //from_transmute_x86! { unsafe u128x4 => __m512i }\n@@ -37,7 +65,7 @@ pub struct SimdU16<const LANES: usize>([u16; LANES])\n where\n     Self: crate::LanesAtMost64;\n \n-impl_integer_vector! { SimdU16, u16 }\n+impl_unsigned_vector! { SimdU16, u16 }\n \n from_transmute_x86! { unsafe u16x8 => __m128i }\n from_transmute_x86! { unsafe u16x16 => __m256i }\n@@ -49,7 +77,7 @@ pub struct SimdU32<const LANES: usize>([u32; LANES])\n where\n     Self: crate::LanesAtMost64;\n \n-impl_integer_vector! { SimdU32, u32 }\n+impl_unsigned_vector! { SimdU32, u32 }\n \n from_transmute_x86! { unsafe u32x4 => __m128i }\n from_transmute_x86! { unsafe u32x8 => __m256i }\n@@ -61,7 +89,7 @@ pub struct SimdU64<const LANES: usize>([u64; LANES])\n where\n     Self: crate::LanesAtMost64;\n \n-impl_integer_vector! { SimdU64, u64 }\n+impl_unsigned_vector! { SimdU64, u64 }\n \n from_transmute_x86! { unsafe u64x2 => __m128i }\n from_transmute_x86! { unsafe u64x4 => __m256i }\n@@ -73,7 +101,7 @@ pub struct SimdU8<const LANES: usize>([u8; LANES])\n where\n     Self: crate::LanesAtMost64;\n \n-impl_integer_vector! { SimdU8, u8 }\n+impl_unsigned_vector! { SimdU8, u8 }\n \n from_transmute_x86! { unsafe u8x16 => __m128i }\n from_transmute_x86! { unsafe u8x32 => __m256i }"}]}