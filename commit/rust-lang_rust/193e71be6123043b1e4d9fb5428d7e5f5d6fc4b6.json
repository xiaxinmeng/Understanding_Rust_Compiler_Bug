{"sha": "193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5M2U3MWJlNjEyMzA0M2IxZTRkOWZiNTQyOGQ3ZTVmNWQ2ZmM0YjY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-27T05:39:40Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-27T05:39:40Z"}, "message": "Merge branch 'pr-228'\n\nConflicts:\n\tREADME.md\n\tsrc/methods.rs", "tree": {"sha": "f3be344126f3c153eb026949b0dd7a9a18bb8107", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3be344126f3c153eb026949b0dd7a9a18bb8107"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6", "html_url": "https://github.com/rust-lang/rust/commit/193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac8ab4eb8e6319f91619173868c1a40997e36f9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac8ab4eb8e6319f91619173868c1a40997e36f9f", "html_url": "https://github.com/rust-lang/rust/commit/ac8ab4eb8e6319f91619173868c1a40997e36f9f"}, {"sha": "56e8db476c437590f21be041c0e751ee185d8dd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/56e8db476c437590f21be041c0e751ee185d8dd0", "html_url": "https://github.com/rust-lang/rust/commit/56e8db476c437590f21be041c0e751ee185d8dd0"}], "stats": {"total": 145, "additions": 140, "deletions": 5}, "files": [{"sha": "478bb25272f9cfde1b2280bb9d7c68a40ed9dbc9", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6", "patch": "@@ -4,7 +4,7 @@\n A collection of lints that give helpful tips to newbies and catch oversights.\n \n ##Lints\n-There are 48 lints included in this crate:\n+There are 49 lints included in this crate:\n \n name                                                                                                 | default | meaning\n -----------------------------------------------------------------------------------------------------|---------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -47,6 +47,7 @@ name\n [shadow_reuse](https://github.com/Manishearth/rust-clippy/wiki#shadow_reuse)                         | allow   | rebinding a name to an expression that re-uses the original value, e.g. `let x = x + 1`\n [shadow_same](https://github.com/Manishearth/rust-clippy/wiki#shadow_same)                           | allow   | rebinding a name to itself, e.g. `let mut x = &mut x`\n [shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                 | warn    | The name is re-bound without even using the original value\n+[should_implement_trait](https://github.com/Manishearth/rust-clippy/wiki#should_implement_trait)     | warn    | defining a method that should be implementing a std trait\n [single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                         | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n [str_to_string](https://github.com/Manishearth/rust-clippy/wiki#str_to_string)                       | warn    | using `to_string()` on a str, which should be `to_owned()`\n [string_add](https://github.com/Manishearth/rust-clippy/wiki#string_add)                             | allow   | using `x + ..` where x is a `String`; suggests using `push_str()` instead"}, {"sha": "32fc953d1c3230adcbb3e2bf7a14ef4b870a0557", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6", "patch": "@@ -100,6 +100,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         matches::SINGLE_MATCH,\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n+        methods::SHOULD_IMPLEMENT_TRAIT,\n         methods::STR_TO_STRING,\n         methods::STRING_TO_STRING,\n         misc::CMP_NAN,"}, {"sha": "50f3512b4f00347702c3d856c7360cd38001110b", "filename": "src/methods.rs", "status": "modified", "additions": 116, "deletions": 2, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6", "patch": "@@ -4,9 +4,12 @@ use rustc::middle::ty;\n use std::iter;\n use std::borrow::Cow;\n \n-use utils::{snippet, span_lint, match_type, walk_ptrs_ty_depth};\n+use utils::{snippet, span_lint, match_path, match_type, walk_ptrs_ty_depth};\n use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n \n+use self::SelfKind::*;\n+use self::OutType::*;\n+\n #[derive(Copy,Clone)]\n pub struct MethodsPass;\n \n@@ -18,10 +21,13 @@ declare_lint!(pub STR_TO_STRING, Warn,\n               \"using `to_string()` on a str, which should be `to_owned()`\");\n declare_lint!(pub STRING_TO_STRING, Warn,\n               \"calling `String.to_string()` which is a no-op\");\n+declare_lint!(pub SHOULD_IMPLEMENT_TRAIT, Warn,\n+              \"defining a method that should be implementing a std trait\");\n \n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING)\n+        lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING,\n+                    SHOULD_IMPLEMENT_TRAIT)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n@@ -57,4 +63,112 @@ impl LintPass for MethodsPass {\n             }\n         }\n     }\n+\n+    fn check_item(&mut self, cx: &Context, item: &Item) {\n+        if let ItemImpl(_, _, _, None, _, ref items) = item.node {\n+            for item in items {\n+                let name = item.ident.name;\n+                for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n+                    if_let_chain! {\n+                        [\n+                            name == method_name,\n+                            let MethodImplItem(ref sig, _) = item.node,\n+                            sig.decl.inputs.len() == n_args,\n+                            out_type.matches(&sig.decl.output),\n+                            self_kind.matches(&sig.explicit_self.node)\n+                        ], {\n+                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, item.span, &format!(\n+                                \"defining a method called `{}` on this type; consider implementing \\\n+                                 the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+const TRAIT_METHODS: [(&'static str, usize, SelfKind, OutType, &'static str); 30] = [\n+    (\"add\",        2, ValueSelf,  AnyType,  \"std::ops::Add`\"),\n+    (\"sub\",        2, ValueSelf,  AnyType,  \"std::ops::Sub\"),\n+    (\"mul\",        2, ValueSelf,  AnyType,  \"std::ops::Mul\"),\n+    (\"div\",        2, ValueSelf,  AnyType,  \"std::ops::Div\"),\n+    (\"rem\",        2, ValueSelf,  AnyType,  \"std::ops::Rem\"),\n+    (\"shl\",        2, ValueSelf,  AnyType,  \"std::ops::Shl\"),\n+    (\"shr\",        2, ValueSelf,  AnyType,  \"std::ops::Shr\"),\n+    (\"bitand\",     2, ValueSelf,  AnyType,  \"std::ops::BitAnd\"),\n+    (\"bitor\",      2, ValueSelf,  AnyType,  \"std::ops::BitOr\"),\n+    (\"bitxor\",     2, ValueSelf,  AnyType,  \"std::ops::BitXor\"),\n+    (\"neg\",        1, ValueSelf,  AnyType,  \"std::ops::Neg\"),\n+    (\"not\",        1, ValueSelf,  AnyType,  \"std::ops::Not\"),\n+    (\"drop\",       1, RefMutSelf, UnitType, \"std::ops::Drop\"),\n+    (\"index\",      2, RefSelf,    RefType,  \"std::ops::Index\"),\n+    (\"index_mut\",  2, RefMutSelf, RefType,  \"std::ops::IndexMut\"),\n+    (\"deref\",      1, RefSelf,    RefType,  \"std::ops::Deref\"),\n+    (\"deref_mut\",  1, RefMutSelf, RefType,  \"std::ops::DerefMut\"),\n+    (\"clone\",      1, RefSelf,    AnyType,  \"std::clone::Clone\"),\n+    (\"borrow\",     1, RefSelf,    RefType,  \"std::borrow::Borrow\"),\n+    (\"borrow_mut\", 1, RefMutSelf, RefType,  \"std::borrow::BorrowMut\"),\n+    (\"as_ref\",     1, RefSelf,    RefType,  \"std::convert::AsRef\"),\n+    (\"as_mut\",     1, RefMutSelf, RefType,  \"std::convert::AsMut\"),\n+    (\"eq\",         2, RefSelf,    BoolType, \"std::cmp::PartialEq\"),\n+    (\"cmp\",        2, RefSelf,    AnyType,  \"std::cmp::Ord\"),\n+    (\"default\",    0, NoSelf,     AnyType,  \"std::default::Default\"),\n+    (\"hash\",       2, RefSelf,    UnitType, \"std::hash::Hash\"),\n+    (\"next\",       1, RefMutSelf, AnyType,  \"std::iter::Iterator\"),\n+    (\"into_iter\",  1, ValueSelf,  AnyType,  \"std::iter::IntoIterator\"),\n+    (\"from_iter\",  1, NoSelf,     AnyType,  \"std::iter::FromIterator\"),\n+    (\"from_str\",   1, NoSelf,     AnyType,  \"std::str::FromStr\"),\n+];\n+\n+#[derive(Clone, Copy)]\n+enum SelfKind {\n+    ValueSelf,\n+    RefSelf,\n+    RefMutSelf,\n+    NoSelf\n+}\n+\n+impl SelfKind {\n+    fn matches(&self, slf: &ExplicitSelf_) -> bool {\n+        match (self, slf) {\n+            (&ValueSelf, &SelfValue(_)) => true,\n+            (&RefSelf, &SelfRegion(_, Mutability::MutImmutable, _)) => true,\n+            (&RefMutSelf, &SelfRegion(_, Mutability::MutMutable, _)) => true,\n+            (&NoSelf, &SelfStatic) => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum OutType {\n+    UnitType,\n+    BoolType,\n+    AnyType,\n+    RefType,\n+}\n+\n+impl OutType {\n+    fn matches(&self, ty: &FunctionRetTy) -> bool {\n+        match (self, ty) {\n+            (&UnitType, &DefaultReturn(_)) => true,\n+            (&UnitType, &Return(ref ty)) if ty.node == TyTup(vec![]) => true,\n+            (&BoolType, &Return(ref ty)) if is_bool(ty) => true,\n+            (&AnyType, &Return(ref ty)) if ty.node != TyTup(vec![])  => true,\n+            (&RefType, &Return(ref ty)) => {\n+                if let TyRptr(_, _) = ty.node { true } else { false }\n+            }\n+            _ => false\n+        }\n+    }\n+}\n+\n+fn is_bool(ty: &Ty) -> bool {\n+    if let TyPath(None, ref p) = ty.node {\n+        if match_path(p, &[\"bool\"]) {\n+            return true;\n+        }\n+    }\n+    false\n }"}, {"sha": "05f77c1511e8c5e73bf9998f0ec996784dee9f63", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=193e71be6123043b1e4d9fb5428d7e5f5d6fc4b6", "patch": "@@ -1,8 +1,27 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n-#[deny(option_unwrap_used, result_unwrap_used)]\n-#[deny(str_to_string, string_to_string)]\n+#![allow(unused)]\n+#![deny(clippy)]\n+\n+use std::ops::Mul;\n+\n+struct T;\n+\n+impl T {\n+    fn add(self, other: T) -> T { self } //~ERROR defining a method called `add`\n+    fn drop(&mut self) { } //~ERROR defining a method called `drop`\n+\n+    fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n+    fn div(self) -> T { self } // no error, different #arguments\n+    fn rem(self, other: T) { } // no error, wrong return type\n+}\n+\n+impl Mul<T> for T {\n+    type Output = T;\n+    fn mul(self, other: T) -> T { self } // no error, obviously\n+}\n+\n fn main() {\n     let opt = Some(0);\n     let _ = opt.unwrap();  //~ERROR used unwrap() on an Option"}]}