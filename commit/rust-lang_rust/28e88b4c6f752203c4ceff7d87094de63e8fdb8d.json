{"sha": "28e88b4c6f752203c4ceff7d87094de63e8fdb8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZTg4YjRjNmY3NTIyMDNjNGNlZmY3ZDg3MDk0ZGU2M2U4ZmRiOGQ=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2013-09-27T16:57:52Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2013-10-03T19:37:33Z"}, "message": "Update std::ops docs as per feedback\n\nfrom @chris-morgan", "tree": {"sha": "435368bb9292d5e3ff6d5631ec579cde8d0543d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/435368bb9292d5e3ff6d5631ec579cde8d0543d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28e88b4c6f752203c4ceff7d87094de63e8fdb8d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28e88b4c6f752203c4ceff7d87094de63e8fdb8d", "html_url": "https://github.com/rust-lang/rust/commit/28e88b4c6f752203c4ceff7d87094de63e8fdb8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28e88b4c6f752203c4ceff7d87094de63e8fdb8d/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "964da1c9fd4ee0563cdcc7ff66cf60a3972127ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/964da1c9fd4ee0563cdcc7ff66cf60a3972127ee", "html_url": "https://github.com/rust-lang/rust/commit/964da1c9fd4ee0563cdcc7ff66cf60a3972127ee"}], "stats": {"total": 252, "additions": 112, "deletions": 140}, "files": [{"sha": "3418fd939bd430fda0f33762772a11e95fef6493", "filename": "src/libstd/ops.rs", "status": "modified", "additions": 112, "deletions": 140, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/28e88b4c6f752203c4ceff7d87094de63e8fdb8d/src%2Flibstd%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28e88b4c6f752203c4ceff7d87094de63e8fdb8d/src%2Flibstd%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fops.rs?ref=28e88b4c6f752203c4ceff7d87094de63e8fdb8d", "patch": "@@ -15,30 +15,30 @@\n  *\n  * Traits for the built-in operators. Implementing these traits allows you to get\n  * an effect similar to oveloading operators.\n- * \n+ *\n  * The values for the right hand side of an operator are automatically\n  * borrowed, so `a + b` is sugar for `a.add(&b)`.\n- * \n+ *\n+ * All of these traits are imported by the prelude, so they are available in\n+ * every Rust program.\n+ *\n  * # Example\n- * \n+ *\n  * This example creates a `Point` struct that implements `Add` and `Sub`, and then\n  * demonstrates adding and subtracting two `Point`s.\n- * \n+ *\n  * ```rust\n- * use std::ops::Add;\n- * use std::ops::Sub;\n- * \n  * struct Point {\n  *     x: int,\n  *     y: int\n  * }\n- * \n+ *\n  * impl Add<Point, Point> for Point {\n  *     fn add(&self, other: &Point) -> Point {\n  *         Point {x: self.x + other.x, y: self.y + other.y}\n  *     }\n  * }\n- * \n+ *\n  * impl Sub<Point, Point> for Point {\n  *     fn sub(&self, other: &Point) -> Point {\n  *         Point {x: self.x - other.x, y: self.y - other.y}\n@@ -49,33 +49,31 @@\n  *     println(format!(\"{:?}\", Point {x: 1, y: 0} - Point {x: 2, y: 3}));\n  * }\n  * ```\n- * \n+ *\n  * See the documentation for each trait for a minimum implementation that prints\n  * something to the screen.\n- * \n+ *\n  */\n \n /**\n- * \n+ *\n  * The `Drop` trait is used to run some code when a value goes out of scope. This\n  * is sometimes called a 'destructor'.\n- * \n+ *\n  * # Example\n- * \n+ *\n  * A trivial implementation of `Drop`. The `drop` method is called when `_x` goes\n  * out of scope, and therefore `main` prints `Dropping!`.\n- * \n+ *\n  * ```rust\n- * use std::ops::Drop;\n- * \n  * struct HasDrop;\n- * \n+ *\n  * impl Drop for HasDrop {\n  *   fn drop(&mut self) {\n  *       println(\"Dropping!\");\n  *   }\n  * }\n- * \n+ *\n  * fn main() {\n  *   let _x = HasDrop;\n  * }\n@@ -87,26 +85,24 @@ pub trait Drop {\n }\n \n /**\n- * \n- * The `Add` trait is used to override the functionality of `+`.\n- * \n+ *\n+ * The `Add` trait is used to specify the functionality of `+`.\n+ *\n  * # Example\n- * \n+ *\n  * A trivial implementation of `Add`. When `Foo + Foo` happens, it ends up\n  * calling `add`, and therefore, `main` prints `Adding!`.\n- * \n+ *\n  * ```rust\n- * use std::ops::Add;\n- * \n  * struct Foo;\n- * \n+ *\n  * impl Add<Foo, Foo> for Foo {\n  *     fn add(&self, _rhs: &Foo) -> Foo {\n  *       println(\"Adding!\");\n  *       *self\n  *   }\n  * }\n- * \n+ *\n  * fn main() {\n  *   Foo + Foo;\n  * }\n@@ -118,26 +114,24 @@ pub trait Add<RHS,Result> {\n }\n \n /**\n- * \n- * The `Sub` trait is used to override the functionality of `-`.\n- * \n+ *\n+ * The `Sub` trait is used to specify the functionality of `-`.\n+ *\n  * # Example\n- * \n+ *\n  * A trivial implementation of `Sub`. When `Foo - Foo` happens, it ends up\n  * calling `sub`, and therefore, `main` prints `Subtracting!`.\n- * \n- * ```\n- * use std::ops::Sub;\n- * \n+ *\n+ * ```rust\n  * struct Foo;\n- * \n+ *\n  * impl Sub<Foo, Foo> for Foo {\n  *     fn sub(&self, _rhs: &Foo) -> Foo {\n  *         println(\"Subtracting!\");\n  *         *self\n  *     }\n  * }\n- * \n+ *\n  * fn main() {\n  *     Foo - Foo;\n  * }\n@@ -149,26 +143,24 @@ pub trait Sub<RHS,Result> {\n }\n \n /**\n- * \n- * The `Mul` trait is used to override the functionality of `*`.\n- * \n+ *\n+ * The `Mul` trait is used to specify the functionality of `*`.\n+ *\n  * # Example\n- * \n+ *\n  * A trivial implementation of `Mul`. When `Foo * Foo` happens, it ends up\n  * calling `mul`, and therefore, `main` prints `Multiplying!`.\n- * \n+ *\n  * ```rust\n- * use std::ops::Mul;\n- * \n  * struct Foo;\n- * \n+ *\n  * impl Mul<Foo, Foo> for Foo {\n  *     fn mul(&self, _rhs: &Foo) -> Foo {\n  *         println(\"Multiplying!\");\n  *         *self\n  *     }\n  * }\n- * \n+ *\n  * fn main() {\n  *     Foo * Foo;\n  * }\n@@ -180,26 +172,24 @@ pub trait Mul<RHS,Result> {\n }\n \n /**\n- * \n- * The `Div` trait is used to override the functionality of `/`.\n- * \n+ *\n+ * The `Div` trait is used to specify the functionality of `/`.\n+ *\n  * # Example\n- * \n+ *\n  * A trivial implementation of `Div`. When `Foo / Foo` happens, it ends up\n  * calling `div`, and therefore, `main` prints `Dividing!`.\n- * \n+ *\n  * ```\n- * use std::ops::Div;\n- * \n  * struct Foo;\n- * \n+ *\n  * impl Div<Foo, Foo> for Foo {\n  *     fn div(&self, _rhs: &Foo) -> Foo {\n  *         println(\"Dividing!\");\n  *         *self\n  *     }\n  * }\n- * \n+ *\n  * fn main() {\n  *     Foo / Foo;\n  * }\n@@ -211,26 +201,24 @@ pub trait Div<RHS,Result> {\n }\n \n /**\n- * \n- * The `Rem` trait is used to override the functionality of `%`.\n- * \n+ *\n+ * The `Rem` trait is used to specify the functionality of `%`.\n+ *\n  * # Example\n- * \n- * A trivial implemtnation of `Rem`. When `Foo % Foo` happens, it ends up\n+ *\n+ * A trivial implementation of `Rem`. When `Foo % Foo` happens, it ends up\n  * calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n- * \n+ *\n  * ```\n- * use std::ops::Rem;\n- * \n  * struct Foo;\n- * \n+ *\n  * impl Rem<Foo, Foo> for Foo {\n  *     fn rem(&self, _rhs: &Foo) -> Foo {\n  *         println(\"Remainder-ing!\");\n  *         *self\n  *     }\n  * }\n- * \n+ *\n  * fn main() {\n  *     Foo % Foo;\n  * }\n@@ -242,26 +230,24 @@ pub trait Rem<RHS,Result> {\n }\n \n /**\n- * \n- * The `Neg` trait is used to override the functionality of unary `-`.\n- * \n+ *\n+ * The `Neg` trait is used to specify the functionality of unary `-`.\n+ *\n  * # Example\n- * \n- * A trivial implemtnation of `Neg`. When `-Foo` happens, it ends up calling\n+ *\n+ * A trivial implementation of `Neg`. When `-Foo` happens, it ends up calling\n  * `neg`, and therefore, `main` prints `Negating!`.\n- * \n+ *\n  * ```\n- * use std::ops::Neg;\n- * \n  * struct Foo;\n- * \n+ *\n  * impl Neg<Foo> for Foo {\n  *     fn neg(&self) -> Foo {\n  *         println(\"Negating!\");\n  *         *self\n  *     }\n  * }\n- * \n+ *\n  * fn main() {\n  *     -Foo;\n  * }\n@@ -273,26 +259,24 @@ pub trait Neg<Result> {\n }\n \n /**\n- * \n- * The `Not` trait is used to override the functionality of `!`.\n- * \n+ *\n+ * The `Not` trait is used to specify the functionality of unary `!`.\n+ *\n  * # Example\n- * \n+ *\n  * A trivial implementation of `Not`. When `!Foo` happens, it ends up calling\n  * `not`, and therefore, `main` prints `Not-ing!`.\n- * \n+ *\n  * ```\n- * use std::ops::Not;\n- * \n  * struct Foo;\n- * \n+ *\n  * impl Not<Foo> for Foo {\n  *     fn not(&self) -> Foo {\n  *         println(\"Not-ing!\");\n  *         *self\n  *     }\n  * }\n- * \n+ *\n  * fn main() {\n  *     !Foo;\n  * }\n@@ -304,26 +288,24 @@ pub trait Not<Result> {\n }\n \n /**\n- * \n- * The `BitAnd` trait is used to override the functionality of `&`.\n- * \n+ *\n+ * The `BitAnd` trait is used to specify the functionality of `&`.\n+ *\n  * # Example\n- * \n+ *\n  * A trivial implementation of `BitAnd`. When `Foo & Foo` happens, it ends up\n  * calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n- * \n+ *\n  * ```\n- * use std::ops::BitAnd;\n- * \n  * struct Foo;\n- * \n+ *\n  * impl BitAnd<Foo, Foo> for Foo {\n  *     fn bitand(&self, _rhs: &Foo) -> Foo {\n  *         println(\"Bitwise And-ing!\");\n  *         *self\n  *     }\n  * }\n- * \n+ *\n  * fn main() {\n  *     Foo & Foo;\n  * }\n@@ -335,26 +317,24 @@ pub trait BitAnd<RHS,Result> {\n }\n \n /**\n- * \n- * The `BitOr` trait is used to override the functionality of `|`.\n- * \n+ *\n+ * The `BitOr` trait is used to specify the functionality of `|`.\n+ *\n  * # Example\n- * \n+ *\n  * A trivial implementation of `BitOr`. When `Foo | Foo` happens, it ends up\n  * calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n- * \n+ *\n  * ```\n- * use std::ops::BitOr;\n- * \n  * struct Foo;\n- * \n+ *\n  * impl BitOr<Foo, Foo> for Foo {\n  *     fn bitor(&self, _rhs: &Foo) -> Foo {\n  *         println(\"Bitwise Or-ing!\");\n  *         *self\n  *     }\n  * }\n- * \n+ *\n  * fn main() {\n  *     Foo | Foo;\n  * }\n@@ -366,26 +346,24 @@ pub trait BitOr<RHS,Result> {\n }\n \n /**\n- * \n- * The `BitXor` trait is used to override the functionality of `^`.\n- * \n+ *\n+ * The `BitXor` trait is used to specify the functionality of `^`.\n+ *\n  * # Example\n- * \n+ *\n  * A trivial implementation of `BitXor`. When `Foo ^ Foo` happens, it ends up\n  * calling `bixtor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n- * \n+ *\n  * ```\n- * use std::ops::BitXor;\n- * \n  * struct Foo;\n- * \n+ *\n  * impl BitXor<Foo, Foo> for Foo {\n  *     fn bitxor(&self, _rhs: &Foo) -> Foo {\n  *         println(\"Bitwise Xor-ing!\");\n  *         *self\n  *     }\n  * }\n- * \n+ *\n  * fn main() {\n  *     Foo ^ Foo;\n  * }\n@@ -397,26 +375,24 @@ pub trait BitXor<RHS,Result> {\n }\n \n /**\n- * \n- * The `Shl` trait is used to override the functionality of `<<`.\n- * \n+ *\n+ * The `Shl` trait is used to specify the functionality of `<<`.\n+ *\n  * # Example\n- * \n+ *\n  * A trivial implementation of `Shl`. When `Foo << Foo` happens, it ends up\n  * calling `shl`, and therefore, `main` prints `Shifting left!`.\n- * \n+ *\n  * ```\n- * use std::ops::Shl;\n- * \n  * struct Foo;\n- * \n+ *\n  * impl Shl<Foo, Foo> for Foo {\n  *     fn shl(&self, _rhs: &Foo) -> Foo {\n  *         println(\"Shifting left!\");\n  *         *self\n  *     }\n  * }\n- * \n+ *\n  * fn main() {\n  *     Foo << Foo;\n  * }\n@@ -428,26 +404,24 @@ pub trait Shl<RHS,Result> {\n }\n \n /**\n- * \n- * The `Shr` trait is used to override the functionality of `>>`.\n- * \n+ *\n+ * The `Shr` trait is used to specify the functionality of `>>`.\n+ *\n  * # Example\n- * \n+ *\n  * A trivial implementation of `Shr`. When `Foo >> Foo` happens, it ends up\n  * calling `shr`, and therefore, `main` prints `Shifting right!`.\n- * \n+ *\n  * ```\n- * use std::ops::Shr;\n- * \n  * struct Foo;\n- * \n+ *\n  * impl Shr<Foo, Foo> for Foo {\n  *     fn shr(&self, _rhs: &Foo) -> Foo {\n  *         println(\"Shifting right!\");\n  *         *self\n  *     }\n  * }\n- * \n+ *\n  * fn main() {\n  *     Foo >> Foo;\n  * }\n@@ -459,27 +433,25 @@ pub trait Shr<RHS,Result> {\n }\n \n /**\n- * \n- * The `Index` trait is used to override the functionality of indexing operations\n+ *\n+ * The `Index` trait is used to specify the functionality of indexing operations\n  * like `arr[idx]`.\n- * \n+ *\n  * # Example\n- * \n- * A trivial implementation of `Index`. When `Foo[idx]` happens, it ends up\n+ *\n+ * A trivial implementation of `Index`. When `Foo[Foo]` happens, it ends up\n  * calling `index`, and therefore, `main` prints `Indexing!`.\n- * \n+ *\n  * ```\n- * use std::ops::Index;\n- * \n  * struct Foo;\n- * \n+ *\n  * impl Index<Foo, Foo> for Foo {\n  *     fn index(&self, _rhs: &Foo) -> Foo {\n  *         println(\"Indexing!\");\n  *         *self\n  *     }\n  * }\n- * \n+ *\n  * fn main() {\n  *     Foo[Foo];\n  * }"}]}