{"sha": "c0f14cb9301eacb51fc660f1d461cbc783f4aaa7", "node_id": "C_kwDOAAsO6NoAKGMwZjE0Y2I5MzAxZWFjYjUxZmM2NjBmMWQ0NjFjYmM3ODNmNGFhYTc", "commit": {"author": {"name": "Sean Chen", "email": "seanchen11235@gmail.com", "date": "2021-10-27T18:03:53Z"}, "committer": {"name": "Sean Chen", "email": "seanchen11235@gmail.com", "date": "2021-10-27T18:03:53Z"}, "message": "Attempt to fix tidy errors", "tree": {"sha": "4496d773b78de506776e6756e6acf17c04b3896a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4496d773b78de506776e6756e6acf17c04b3896a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0f14cb9301eacb51fc660f1d461cbc783f4aaa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0f14cb9301eacb51fc660f1d461cbc783f4aaa7", "html_url": "https://github.com/rust-lang/rust/commit/c0f14cb9301eacb51fc660f1d461cbc783f4aaa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0f14cb9301eacb51fc660f1d461cbc783f4aaa7/comments", "author": {"login": "seanchen1991", "id": 4572868, "node_id": "MDQ6VXNlcjQ1NzI4Njg=", "avatar_url": "https://avatars.githubusercontent.com/u/4572868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanchen1991", "html_url": "https://github.com/seanchen1991", "followers_url": "https://api.github.com/users/seanchen1991/followers", "following_url": "https://api.github.com/users/seanchen1991/following{/other_user}", "gists_url": "https://api.github.com/users/seanchen1991/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanchen1991/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanchen1991/subscriptions", "organizations_url": "https://api.github.com/users/seanchen1991/orgs", "repos_url": "https://api.github.com/users/seanchen1991/repos", "events_url": "https://api.github.com/users/seanchen1991/events{/privacy}", "received_events_url": "https://api.github.com/users/seanchen1991/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seanchen1991", "id": 4572868, "node_id": "MDQ6VXNlcjQ1NzI4Njg=", "avatar_url": "https://avatars.githubusercontent.com/u/4572868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanchen1991", "html_url": "https://github.com/seanchen1991", "followers_url": "https://api.github.com/users/seanchen1991/followers", "following_url": "https://api.github.com/users/seanchen1991/following{/other_user}", "gists_url": "https://api.github.com/users/seanchen1991/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanchen1991/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanchen1991/subscriptions", "organizations_url": "https://api.github.com/users/seanchen1991/orgs", "repos_url": "https://api.github.com/users/seanchen1991/repos", "events_url": "https://api.github.com/users/seanchen1991/events{/privacy}", "received_events_url": "https://api.github.com/users/seanchen1991/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6de41331c732a8f70088ceab12a5049e3db0caa", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6de41331c732a8f70088ceab12a5049e3db0caa", "html_url": "https://github.com/rust-lang/rust/commit/c6de41331c732a8f70088ceab12a5049e3db0caa"}], "stats": {"total": 424, "additions": 345, "deletions": 79}, "files": [{"sha": "d8859cf1e552e9e6b603a24f201844bf05a32d73", "filename": "library/std/src/error.rs", "status": "modified", "additions": 54, "deletions": 79, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/c0f14cb9301eacb51fc660f1d461cbc783f4aaa7/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0f14cb9301eacb51fc660f1d461cbc783f4aaa7/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=c0f14cb9301eacb51fc660f1d461cbc783f4aaa7", "patch": "@@ -25,7 +25,7 @@ use crate::backtrace::Backtrace;\n use crate::borrow::Cow;\n use crate::cell;\n use crate::char;\n-use crate::fmt::{self, Debug, Display, Write};\n+use crate::fmt::{self, Debug, Display};\n use crate::mem::transmute;\n use crate::num;\n use crate::str;\n@@ -816,6 +816,7 @@ impl dyn Error + Send + Sync {\n ///\n /// ```\n /// #![feature(error_reporter)]\n+/// #![feature(negative_impls)]\n ///\n /// use std::error::{Error, Report};\n /// use std::fmt;\n@@ -848,17 +849,48 @@ impl dyn Error + Send + Sync {\n ///\n /// impl Error for SuperErrorSideKick {}\n ///\n+/// // Note that the error doesn't need to be `Send` or `Sync`.\n+/// impl !Send for SuperError {}\n+/// impl !Sync for SuperError {}\n+///\n /// fn main() {\n ///     let error = SuperError { side: SuperErrorSideKick };\n ///     let report = Report::new(&error).pretty(true);\n ///\n ///     println!(\"{}\", report);\n /// }\n /// ```\n+///\n+/// `Report` only requires that the wrapped error implements `Error`. It doesn't require that the\n+/// wrapped error be `Send`, `Sync`, or `'static`.\n+///\n+/// ```rust\n+/// # #![feature(error_reporter)]\n+/// # use std::fmt;\n+/// # use std::error::{Error, Report};\n+/// #[derive(Debug)]\n+/// struct SuperError<'a> {\n+///     side: &'a str,\n+/// }\n+/// impl<'a> fmt::Display for SuperError<'a> {\n+///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+///         write!(f, \"SuperError is here: {}\", self.side)\n+///     }\n+/// }\n+/// impl<'a> Error for SuperError<'a> {}\n+/// fn main() {\n+///     let msg = String::from(\"Huzzah!\");\n+///     let report = Report::new(SuperError { side: &msg });\n+///     println!(\"{}\", report);\n+/// }\n+/// ```\n #[unstable(feature = \"error_reporter\", issue = \"90172\")]\n pub struct Report<E> {\n+    /// The error being reported.\n     error: E,\n+    /// Whether a backtrace should be included as part of the report.\n     show_backtrace: bool,\n+    /// Whether the report should be pretty-printed.\n     pretty: bool,\n }\n \n@@ -911,33 +943,26 @@ where\n             write!(f, \"\\n\\nCaused by:\")?;\n \n             let multiple = cause.source().is_some();\n-            let format = if multiple {\n-                Format::Numbered { ind: 0 }\n-            } else {\n-                Format::Uniform { indentation: \"    \" }\n-            };\n \n-            for error in cause.chain() {\n+            for (ind, error) in cause.chain().enumerate() {\n                 writeln!(f)?;\n \n-                let mut indented = Indented { inner: f, needs_indent: true, format };\n-\n-                write!(indented, \"{}\", error)?;\n+                if multiple {\n+                    write!(f, \"{: >4}: {}\", ind, Indented { source: error })?;\n+                } else {\n+                    write!(f, \"    {}\", error)?;\n+                }\n             }\n         }\n \n         if self.show_backtrace {\n             let backtrace = error.backtrace();\n \n             if let Some(backtrace) = backtrace {\n-                let mut backtrace = backtrace.to_string();\n-\n-                write!(f, \"\\n\\n\")?;\n-                writeln!(f, \"Stack backtrace:\")?;\n+                let backtrace = backtrace.to_string();\n \n-                backtrace.truncate(backtrace.trim_end().len());\n-\n-                write!(f, \"{}\", backtrace)?;\n+                f.write_str(\"\\n\\nStack backtrace:\\n\")?;\n+                f.write_str(backtrace.trim_end())?;\n             }\n         }\n \n@@ -977,76 +1002,26 @@ where\n     }\n }\n \n-/// Encapsulates how error sources are indented and formatted.\n-struct Indented<'a, D: ?Sized> {\n-    inner: &'a mut D,\n-    needs_indent: bool,\n-    format: Format,\n-}\n-\n-/// The possible variants that error sources can be formatted as.\n-#[derive(Clone, Copy)]\n-enum Format {\n-    /// Insert uniform indentation before every line.\n-    ///\n-    /// This format takes a static string as input and inserts it after every newline.\n-    Uniform {\n-        /// The string to insert as indentation.\n-        indentation: &'static str,\n-    },\n-    /// Inserts a number before the first line.\n-    ///\n-    /// This format hard codes the indentation level to match the indentation from\n-    /// `std::backtrace::Backtrace`.\n-    Numbered {\n-        /// The index to insert before the first line of output.\n-        ind: usize,\n-    },\n+/// Wrapper type for indenting the inner source.\n+struct Indented<D> {\n+    source: D,\n }\n \n-impl<D> Write for Indented<'_, D>\n+impl<D> fmt::Display for Indented<D>\n where\n-    D: Write + ?Sized,\n+    D: fmt::Display,\n {\n-    fn write_str(&mut self, s: &str) -> fmt::Result {\n-        for (ind, line) in s.split('\\n').enumerate() {\n-            if ind > 0 {\n-                self.inner.write_char('\\n')?;\n-                self.needs_indent = true;\n-            }\n-\n-            if self.needs_indent {\n-                if line.is_empty() {\n-                    continue;\n-                }\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let source = self.source.to_string();\n \n-                self.format.insert_indentation(ind, &mut self.inner)?;\n-                self.needs_indent = false;\n+        for (ind, line) in source.trim().split('\\n').filter(|l| !l.is_empty()).enumerate() {\n+            if ind > 0 {\n+                write!(f, \"\\n      {}\", line)?;\n+            } else {\n+                write!(f, \"{}\", line)?;\n             }\n-\n-            self.inner.write_fmt(format_args!(\"{}\", line))?;\n         }\n \n         Ok(())\n     }\n }\n-\n-impl Format {\n-    /// Write the specified formatting to the write buffer.\n-    fn insert_indentation(&mut self, line: usize, f: &mut dyn Write) -> fmt::Result {\n-        match self {\n-            Format::Uniform { indentation } => {\n-                write!(f, \"{}\", indentation)\n-            }\n-            Format::Numbered { ind } => {\n-                if line == 0 {\n-                    write!(f, \"{: >4}: \", ind)?;\n-                    *ind += 1;\n-                    Ok(())\n-                } else {\n-                    write!(f, \"      \")\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "c408915ca71a9f7569684f47fbda17f8b510d25e", "filename": "library/std/src/error/tests.rs", "status": "modified", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/c0f14cb9301eacb51fc660f1d461cbc783f4aaa7/library%2Fstd%2Fsrc%2Ferror%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0f14cb9301eacb51fc660f1d461cbc783f4aaa7/library%2Fstd%2Fsrc%2Ferror%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror%2Ftests.rs?ref=c0f14cb9301eacb51fc660f1d461cbc783f4aaa7", "patch": "@@ -35,3 +35,294 @@ fn downcasting() {\n         Err(e) => assert_eq!(*e.downcast::<A>().unwrap(), A),\n     }\n }\n+\n+use crate::backtrace;\n+use crate::env;\n+use crate::error::Report;\n+\n+#[derive(Debug)]\n+struct SuperError {\n+    side: SuperErrorSideKick,\n+}\n+\n+impl fmt::Display for SuperError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"SuperError is here!\")\n+    }\n+}\n+\n+impl Error for SuperError {\n+    fn source(&self) -> Option<&(dyn Error + 'static)> {\n+        Some(&self.side)\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct SuperErrorSideKick;\n+\n+impl fmt::Display for SuperErrorSideKick {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"SuperErrorSideKick is here!\")\n+    }\n+}\n+\n+impl Error for SuperErrorSideKick {}\n+\n+#[test]\n+fn single_line_formatting() {\n+    let error = SuperError { side: SuperErrorSideKick };\n+    let report = Report::new(&error);\n+    let actual = report.to_string();\n+    let expected = String::from(\"SuperError is here!: SuperErrorSideKick is here!\");\n+\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn multi_line_formatting() {\n+    let error = SuperError { side: SuperErrorSideKick };\n+    let report = Report::new(&error).pretty(true);\n+    let actual = report.to_string();\n+    let expected =\n+        String::from(\"SuperError is here!\\n\\nCaused by:\\n    SuperErrorSideKick is here!\");\n+\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn error_with_no_sources_formats_single_line_correctly() {\n+    let report = Report::new(SuperErrorSideKick);\n+    let actual = report.to_string();\n+    let expected = String::from(\"SuperErrorSideKick is here!\");\n+\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn error_with_no_sources_formats_multi_line_correctly() {\n+    let report = Report::new(SuperErrorSideKick).pretty(true);\n+    let actual = report.to_string();\n+    let expected = String::from(\"SuperErrorSideKick is here!\");\n+\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn error_with_backtrace_outputs_correctly() {\n+    use backtrace::Backtrace;\n+\n+    env::remove_var(\"RUST_BACKTRACE\");\n+\n+    #[derive(Debug)]\n+    struct ErrorWithBacktrace<'a> {\n+        msg: &'a str,\n+        trace: Backtrace,\n+    }\n+\n+    impl<'a> fmt::Display for ErrorWithBacktrace<'a> {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            write!(f, \"Error with backtrace: {}\", self.msg)\n+        }\n+    }\n+\n+    impl<'a> Error for ErrorWithBacktrace<'a> {\n+        fn backtrace(&self) -> Option<&Backtrace> {\n+            Some(&self.trace)\n+        }\n+    }\n+\n+    let msg = String::from(\"The source of the error\");\n+    let report = Report::new(ErrorWithBacktrace { msg: &msg, trace: Backtrace::capture() })\n+        .pretty(true)\n+        .show_backtrace(true);\n+\n+    let expected = String::from(\n+        \"Error with backtrace: The source of the error\\n\\nStack backtrace:\\ndisabled backtrace\",\n+    );\n+\n+    assert_eq!(expected, report.to_string());\n+}\n+\n+#[derive(Debug)]\n+struct GenericError<D> {\n+    message: D,\n+    source: Option<Box<dyn Error + 'static>>,\n+}\n+\n+impl<D> GenericError<D> {\n+    fn new(message: D) -> GenericError<D> {\n+        Self { message, source: None }\n+    }\n+\n+    fn new_with_source<E>(message: D, source: E) -> GenericError<D>\n+    where\n+        E: Error + 'static,\n+    {\n+        let source: Box<dyn Error + 'static> = Box::new(source);\n+        let source = Some(source);\n+        GenericError { message, source }\n+    }\n+}\n+\n+impl<D> fmt::Display for GenericError<D>\n+where\n+    D: fmt::Display,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.message, f)\n+    }\n+}\n+\n+impl<D> Error for GenericError<D>\n+where\n+    D: fmt::Debug + fmt::Display,\n+{\n+    fn source(&self) -> Option<&(dyn Error + 'static)> {\n+        self.source.as_deref()\n+    }\n+}\n+\n+#[test]\n+fn error_formats_single_line_with_rude_display_impl() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"line 1\\nline 2\")?;\n+            f.write_str(\"\\nline 3\\nline 4\\n\")?;\n+            f.write_str(\"line 5\\nline 6\")?;\n+            Ok(())\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error);\n+    let expected = r#\"line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6: line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6: line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6: line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6\"#;\n+\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn error_formats_multi_line_with_rude_display_impl() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"line 1\\nline 2\")?;\n+            f.write_str(\"\\nline 3\\nline 4\\n\")?;\n+            f.write_str(\"line 5\\nline 6\")?;\n+            Ok(())\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = r#\"line 1\n+line 2\n+line 3\n+line 4\n+line 5\n+line 6\n+\n+Caused by:\n+   0: line 1\n+      line 2\n+      line 3\n+      line 4\n+      line 5\n+      line 6\n+   1: line 1\n+      line 2\n+      line 3\n+      line 4\n+      line 5\n+      line 6\n+   2: line 1\n+      line 2\n+      line 3\n+      line 4\n+      line 5\n+      line 6\"#;\n+\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn errors_that_start_with_newline_formats_correctly() {\n+    #[derive(Debug)]\n+    struct MyMessage;\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"\\nThe message\\n\")\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let error = GenericError::new_with_source(MyMessage, error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = r#\"\n+The message\n+\n+\n+Caused by:\n+   0: The message\n+   1: The message\"#;\n+\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}\n+\n+#[test]\n+fn errors_with_string_interpolation_formats_correctly() {\n+    #[derive(Debug)]\n+    struct MyMessage(usize);\n+\n+    impl fmt::Display for MyMessage {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            write!(f, \"Got an error code: ({}). \", self.0)?;\n+            write!(f, \"What would you like to do in response?\")\n+        }\n+    }\n+\n+    let error = GenericError::new(MyMessage(10));\n+    let error = GenericError::new_with_source(MyMessage(20), error);\n+    let report = Report::new(error).pretty(true);\n+    let expected = r#\"Got an error code: (20). What would you like to do in response?\n+\n+Caused by:\n+    Got an error code: (10). What would you like to do in response?\"#;\n+    let actual = report.to_string();\n+    assert_eq!(expected, actual);\n+}"}]}