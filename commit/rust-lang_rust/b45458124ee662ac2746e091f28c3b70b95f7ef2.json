{"sha": "b45458124ee662ac2746e091f28c3b70b95f7ef2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NTQ1ODEyNGVlNjYyYWMyNzQ2ZTA5MWYyOGMzYjcwYjk1ZjdlZjI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril@gmail.com", "date": "2019-09-23T15:36:42Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-01T17:22:32Z"}, "message": "Extract constructor application as a Constructor method", "tree": {"sha": "783b6f08a6090579cc038ac4d0972c79b9363df3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/783b6f08a6090579cc038ac4d0972c79b9363df3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b45458124ee662ac2746e091f28c3b70b95f7ef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b45458124ee662ac2746e091f28c3b70b95f7ef2", "html_url": "https://github.com/rust-lang/rust/commit/b45458124ee662ac2746e091f28c3b70b95f7ef2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b45458124ee662ac2746e091f28c3b70b95f7ef2/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c02c19ac894669d5244dca69d7c177fe2a5752d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c02c19ac894669d5244dca69d7c177fe2a5752d", "html_url": "https://github.com/rust-lang/rust/commit/0c02c19ac894669d5244dca69d7c177fe2a5752d"}], "stats": {"total": 106, "additions": 64, "deletions": 42}, "files": [{"sha": "093df57087cbe7ec6f19e151bb1329c4873c561e", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 64, "deletions": 42, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b45458124ee662ac2746e091f28c3b70b95f7ef2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b45458124ee662ac2746e091f28c3b70b95f7ef2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=b45458124ee662ac2746e091f28c3b70b95f7ef2", "patch": "@@ -674,6 +674,67 @@ impl<'tcx> Constructor<'tcx> {\n             _ => 0,\n         }\n     }\n+\n+    /// Apply a constructor to a list of patterns, yielding a new pattern. `pats`\n+    /// must have as many elements as this constructor's arity.\n+    ///\n+    /// Examples:\n+    /// self: Single\n+    /// ty: tuple of 3 elements\n+    /// pats: [10, 20, _]           => (10, 20, _)\n+    ///\n+    /// self: Option::Some\n+    /// ty: Option<bool>\n+    /// pats: [false]  => Some(false)\n+    fn apply<'a>(\n+        &self,\n+        cx: &MatchCheckCtxt<'a, 'tcx>,\n+        ty: Ty<'tcx>,\n+        pats: impl IntoIterator<Item = Pat<'tcx>>,\n+    ) -> Pat<'tcx> {\n+        let mut pats = pats.into_iter();\n+        let pat = match ty.kind {\n+            ty::Adt(..) | ty::Tuple(..) => {\n+                let pats = pats\n+                    .enumerate()\n+                    .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n+                    .collect();\n+\n+                if let ty::Adt(adt, substs) = ty.kind {\n+                    if adt.is_enum() {\n+                        PatKind::Variant {\n+                            adt_def: adt,\n+                            substs,\n+                            variant_index: self.variant_index_for_adt(cx, adt),\n+                            subpatterns: pats,\n+                        }\n+                    } else {\n+                        PatKind::Leaf { subpatterns: pats }\n+                    }\n+                } else {\n+                    PatKind::Leaf { subpatterns: pats }\n+                }\n+            }\n+\n+            ty::Ref(..) => PatKind::Deref { subpattern: pats.nth(0).unwrap() },\n+\n+            ty::Slice(_) | ty::Array(..) => {\n+                PatKind::Slice { prefix: pats.collect(), slice: None, suffix: vec![] }\n+            }\n+\n+            _ => match *self {\n+                ConstantValue(value, _) => PatKind::Constant { value },\n+                ConstantRange(lo, hi, ty, end, _) => PatKind::Range(PatRange {\n+                    lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n+                    hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n+                    end,\n+                }),\n+                _ => PatKind::Wild,\n+            },\n+        };\n+\n+        Pat { ty, span: DUMMY_SP, kind: Box::new(pat) }\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -778,50 +839,11 @@ impl<'tcx> Witness<'tcx> {\n         let arity = ctor.arity(cx, ty);\n         let pat = {\n             let len = self.0.len() as u64;\n-            let mut pats = self.0.drain((len - arity) as usize..).rev();\n-\n-            match ty.kind {\n-                ty::Adt(..) | ty::Tuple(..) => {\n-                    let pats = pats\n-                        .enumerate()\n-                        .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n-                        .collect();\n-\n-                    if let ty::Adt(adt, substs) = ty.kind {\n-                        if adt.is_enum() {\n-                            PatKind::Variant {\n-                                adt_def: adt,\n-                                substs,\n-                                variant_index: ctor.variant_index_for_adt(cx, adt),\n-                                subpatterns: pats,\n-                            }\n-                        } else {\n-                            PatKind::Leaf { subpatterns: pats }\n-                        }\n-                    } else {\n-                        PatKind::Leaf { subpatterns: pats }\n-                    }\n-                }\n-\n-                ty::Ref(..) => PatKind::Deref { subpattern: pats.nth(0).unwrap() },\n-\n-                ty::Slice(_) | ty::Array(..) => {\n-                    PatKind::Slice { prefix: pats.collect(), slice: None, suffix: vec![] }\n-                }\n-\n-                _ => match *ctor {\n-                    ConstantValue(value, _) => PatKind::Constant { value },\n-                    ConstantRange(lo, hi, ty, end, _) => PatKind::Range(PatRange {\n-                        lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n-                        hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n-                        end,\n-                    }),\n-                    _ => PatKind::Wild,\n-                },\n-            }\n+            let pats = self.0.drain((len - arity) as usize..).rev();\n+            ctor.apply(cx, ty, pats)\n         };\n \n-        self.0.push(Pat { ty, span: DUMMY_SP, kind: Box::new(pat) });\n+        self.0.push(pat);\n \n         self\n     }"}]}