{"sha": "53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzYzE5NTZjZmJiZThhNTk1N2JmYTYyZjU3YmZiMGU0Yjk5OWE3YjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-24T22:32:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-01T11:13:05Z"}, "message": "Introduce the notion of deferred resolutions and use it to hold off on\ndoing the final checking for closure calls until after trait inference\nis performed. This isn't important now, but it's essential if we are to\ndelay inferring the closure kind.", "tree": {"sha": "71e0b35cb679108b2e620ec4ca01a22fc169e64e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71e0b35cb679108b2e620ec4ca01a22fc169e64e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0", "html_url": "https://github.com/rust-lang/rust/commit/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe4340ab18abc53af40e40a6696dfbe2375238b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe4340ab18abc53af40e40a6696dfbe2375238b0", "html_url": "https://github.com/rust-lang/rust/commit/fe4340ab18abc53af40e40a6696dfbe2375238b0"}], "stats": {"total": 452, "additions": 308, "deletions": 144}, "files": [{"sha": "c4b7ffb87296e8a79a1277f7284d6180b0f84f61", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0", "patch": "@@ -30,7 +30,7 @@ use syntax::print::pprust;\n use syntax::ptr::P;\n \n pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n-                           pat: &ast::Pat,\n+                           pat: &'tcx ast::Pat,\n                            expected: Ty<'tcx>)\n {\n     let fcx = pcx.fcx;\n@@ -157,9 +157,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         }\n         ast::PatIdent(_, ref path, _) => {\n             let path = ast_util::ident_to_path(path.span, path.node);\n-            check_pat_enum(pcx, pat, &path, &Some(vec![]), expected);\n+            check_pat_enum(pcx, pat, &path, Some(&[]), expected);\n         }\n         ast::PatEnum(ref path, ref subpats) => {\n+            let subpats = subpats.as_ref().map(|v| &v[]);\n             check_pat_enum(pcx, pat, path, subpats, expected);\n         }\n         ast::PatStruct(ref path, ref fields, etc) => {\n@@ -335,9 +336,9 @@ pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n }\n \n pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                             expr: &ast::Expr,\n-                             discrim: &ast::Expr,\n-                             arms: &[ast::Arm],\n+                             expr: &'tcx ast::Expr,\n+                             discrim: &'tcx ast::Expr,\n+                             arms: &'tcx [ast::Arm],\n                              expected: Expectation<'tcx>,\n                              match_src: ast::MatchSource) {\n     let tcx = fcx.ccx.tcx;\n@@ -424,8 +425,8 @@ pub struct pat_ctxt<'a, 'tcx: 'a> {\n     pub map: PatIdMap,\n }\n \n-pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n-                                  path: &ast::Path, fields: &[Spanned<ast::FieldPat>],\n+pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n+                                  path: &ast::Path, fields: &'tcx [Spanned<ast::FieldPat>],\n                                   etc: bool, expected: Ty<'tcx>) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n@@ -483,10 +484,12 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n                             variant_def_id, etc);\n }\n \n-pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n-                                path: &ast::Path, subpats: &Option<Vec<P<ast::Pat>>>,\n-                                expected: Ty<'tcx>) {\n-\n+pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n+                                pat: &ast::Pat,\n+                                path: &ast::Path,\n+                                subpats: Option<&'tcx [P<ast::Pat>]>,\n+                                expected: Ty<'tcx>)\n+{\n     // Typecheck the path.\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n@@ -536,7 +539,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n                 \"`{}` does not name a non-struct variant or a tuple struct\", name);\n             fcx.write_error(pat.id);\n \n-            if let Some(ref subpats) = *subpats {\n+            if let Some(subpats) = subpats {\n                 for pat in subpats.iter() {\n                     check_pat(pcx, &**pat, tcx.types.err);\n                 }\n@@ -545,7 +548,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n         }\n     };\n \n-    if let Some(ref subpats) = *subpats {\n+    if let Some(subpats) = subpats {\n         if subpats.len() == arg_tys.len() {\n             for (subpat, arg_ty) in subpats.iter().zip(arg_tys.iter()) {\n                 check_pat(pcx, &**subpat, *arg_ty);\n@@ -579,7 +582,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n /// `etc` is true if the pattern said '...' and false otherwise.\n pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                                          span: Span,\n-                                         fields: &[Spanned<ast::FieldPat>],\n+                                         fields: &'tcx [Spanned<ast::FieldPat>],\n                                          struct_fields: &[ty::field<'tcx>],\n                                          struct_id: ast::DefId,\n                                          etc: bool) {"}, {"sha": "dc8bde9f84d6dfaf9502141329e132364d8a3ad6", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 166, "deletions": 22, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0", "patch": "@@ -13,6 +13,8 @@ use super::AutorefArgs;\n use super::check_argument_types;\n use super::check_expr;\n use super::check_method_argument_types;\n+use super::demand;\n+use super::DeferredResolution;\n use super::err_args;\n use super::Expectation;\n use super::expected_types_for_fn_args;\n@@ -24,13 +26,14 @@ use super::TupleArgumentsFlag;\n use super::UnresolvedTypeAction;\n use super::write_call;\n \n+use CrateCtxt;\n use middle::infer;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, ClosureTyper};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::ptr::P;\n-use CrateCtxt;\n+use util::ppaux::Repr;\n \n /// Check that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n@@ -66,9 +69,9 @@ pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id:\n }\n \n pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                            call_expr: &ast::Expr,\n-                            callee_expr: &ast::Expr,\n-                            arg_exprs: &[P<ast::Expr>],\n+                            call_expr: &'tcx ast::Expr,\n+                            callee_expr: &'tcx ast::Expr,\n+                            arg_exprs: &'tcx [P<ast::Expr>],\n                             expected: Expectation<'tcx>)\n {\n     check_expr(fcx, callee_expr);\n@@ -96,24 +99,35 @@ pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             confirm_builtin_call(fcx, call_expr, callee_ty, arg_exprs, expected);\n         }\n \n+        Some(CallStep::Closure(fn_sig)) => {\n+            confirm_closure_call(fcx, call_expr, arg_exprs, expected, fn_sig);\n+        }\n+\n         Some(CallStep::Overloaded(method_callee)) => {\n-            confirm_overloaded_call(fcx, call_expr, arg_exprs, method_callee, expected);\n+            confirm_overloaded_call(fcx, call_expr, callee_expr,\n+                                    arg_exprs, expected, method_callee);\n         }\n     }\n }\n \n enum CallStep<'tcx> {\n     Builtin,\n+    Closure(ty::FnSig<'tcx>),\n     Overloaded(ty::MethodCallee<'tcx>)\n }\n \n fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                      call_expr: &ast::Expr,\n-                                      callee_expr: &ast::Expr,\n+                                      call_expr: &'tcx ast::Expr,\n+                                      callee_expr: &'tcx ast::Expr,\n                                       adjusted_ty: Ty<'tcx>,\n                                       autoderefref: ty::AutoDerefRef<'tcx>)\n                                       -> Option<CallStep<'tcx>>\n {\n+    debug!(\"try_overloaded_call_step(call_expr={}, adjusted_ty={}, autoderefref={})\",\n+           call_expr.repr(fcx.tcx()),\n+           adjusted_ty.repr(fcx.tcx()),\n+           autoderefref.repr(fcx.tcx()));\n+\n     // If the callee is a bare function or a closure, then we're all set.\n     match structurally_resolved_type(fcx, callee_expr.span, adjusted_ty).sty {\n         ty::ty_bare_fn(..) => {\n@@ -123,9 +137,37 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             return Some(CallStep::Builtin);\n         }\n \n+        ty::ty_closure(def_id, _, substs) => {\n+            let closure_ty =\n+                fcx.closure_type(def_id, substs);\n+            let fn_sig =\n+                fcx.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n+                                                                      infer::FnCall,\n+                                                                      &closure_ty.sig).0;\n+            fcx.record_deferred_resolution(box CallResolution {\n+                call_expr: call_expr,\n+                callee_expr: callee_expr,\n+                adjusted_ty: adjusted_ty,\n+                autoderefref: autoderefref,\n+                fn_sig: fn_sig.clone(),\n+            });\n+            return Some(CallStep::Closure(fn_sig));\n+        }\n+\n         _ => {}\n     }\n \n+    try_overloaded_call_traits(fcx, call_expr, callee_expr, adjusted_ty, autoderefref)\n+        .map(|method_callee| CallStep::Overloaded(method_callee))\n+}\n+\n+fn try_overloaded_call_traits<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                       call_expr: &ast::Expr,\n+                                       callee_expr: &ast::Expr,\n+                                       adjusted_ty: Ty<'tcx>,\n+                                       autoderefref: ty::AutoDerefRef<'tcx>)\n+                                       -> Option<ty::MethodCallee<'tcx>>\n+{\n     // Try the options that are least restrictive on the caller first.\n     for &(opt_trait_def_id, method_name) in [\n         (fcx.tcx().lang_items.fn_trait(), token::intern(\"call\")),\n@@ -147,7 +189,7 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                None) {\n             None => continue,\n             Some(method_callee) => {\n-                return Some(CallStep::Overloaded(method_callee));\n+                return Some(method_callee);\n             }\n         }\n     }\n@@ -158,7 +200,7 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                  call_expr: &ast::Expr,\n                                  callee_ty: Ty<'tcx>,\n-                                 arg_exprs: &[P<ast::Expr>],\n+                                 arg_exprs: &'tcx [P<ast::Expr>],\n                                  expected: Expectation<'tcx>)\n {\n     let error_fn_sig;\n@@ -215,22 +257,124 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     write_call(fcx, call_expr, fn_sig.output);\n }\n \n+fn confirm_closure_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                 call_expr: &ast::Expr,\n+                                 arg_exprs: &'tcx [P<ast::Expr>],\n+                                 expected: Expectation<'tcx>,\n+                                 fn_sig: ty::FnSig<'tcx>)\n+{\n+    // `fn_sig` is the *signature* of the cosure being called. We\n+    // don't know the full details yet (`Fn` vs `FnMut` etc), but we\n+    // do know the types expected for each argument and the return\n+    // type.\n+\n+    let expected_arg_tys =\n+        expected_types_for_fn_args(fcx,\n+                                   call_expr.span,\n+                                   expected,\n+                                   fn_sig.output.clone(),\n+                                   &*fn_sig.inputs);\n+\n+    check_argument_types(fcx,\n+                         call_expr.span,\n+                         &*fn_sig.inputs,\n+                         &*expected_arg_tys,\n+                         arg_exprs,\n+                         AutorefArgs::No,\n+                         fn_sig.variadic,\n+                         TupleArgumentsFlag::TupleArguments);\n+\n+    write_call(fcx, call_expr, fn_sig.output);\n+}\n+\n fn confirm_overloaded_call<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                     call_expr: &ast::Expr,\n-                                    arg_exprs: &[P<ast::Expr>],\n-                                    method_callee: ty::MethodCallee<'tcx>,\n-                                    expected: Expectation<'tcx>)\n+                                    callee_expr: &'tcx ast::Expr,\n+                                    arg_exprs: &'tcx [P<ast::Expr>],\n+                                    expected: Expectation<'tcx>,\n+                                    method_callee: ty::MethodCallee<'tcx>)\n {\n-    let output_type = check_method_argument_types(fcx,\n-                                                  call_expr.span,\n-                                                  method_callee.ty,\n-                                                  call_expr,\n-                                                  arg_exprs,\n-                                                  AutorefArgs::No,\n-                                                  TupleArgumentsFlag::TupleArguments,\n-                                                  expected);\n+    let output_type =\n+        check_method_argument_types(fcx,\n+                                    call_expr.span,\n+                                    method_callee.ty,\n+                                    callee_expr,\n+                                    arg_exprs,\n+                                    AutorefArgs::No,\n+                                    TupleArgumentsFlag::TupleArguments,\n+                                    expected);\n+    write_call(fcx, call_expr, output_type);\n+\n+    write_overloaded_call_method_map(fcx, call_expr, method_callee);\n+}\n+\n+fn write_overloaded_call_method_map<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                             call_expr: &ast::Expr,\n+                                             method_callee: ty::MethodCallee<'tcx>) {\n     let method_call = ty::MethodCall::expr(call_expr.id);\n     fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n-    write_call(fcx, call_expr, output_type);\n }\n \n+struct CallResolution<'tcx> {\n+    call_expr: &'tcx ast::Expr,\n+    callee_expr: &'tcx ast::Expr,\n+    adjusted_ty: Ty<'tcx>,\n+    autoderefref: ty::AutoDerefRef<'tcx>,\n+    fn_sig: ty::FnSig<'tcx>,\n+}\n+\n+impl<'tcx> Repr<'tcx> for CallResolution<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"CallResolution(call_expr={}, callee_expr={}, adjusted_ty={}, \\\n+                autoderefref={}, fn_sig={})\",\n+                self.call_expr.repr(tcx),\n+                self.callee_expr.repr(tcx),\n+                self.adjusted_ty.repr(tcx),\n+                self.autoderefref.repr(tcx),\n+                self.fn_sig.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> DeferredResolution<'tcx> for CallResolution<'tcx> {\n+    fn attempt_resolution<'a>(&self, fcx: &FnCtxt<'a,'tcx>) -> bool {\n+        debug!(\"attempt_resolution() {}\",\n+               self.repr(fcx.tcx()));\n+\n+        // We may now know enough to figure out fn vs fnmut etc.\n+        match try_overloaded_call_traits(fcx, self.call_expr, self.callee_expr,\n+                                         self.adjusted_ty, self.autoderefref.clone()) {\n+            None => false,\n+            Some(method_callee) => {\n+                // One problem is that when we get here, we are going\n+                // to have a newly instantiated function signature\n+                // from the call trait. This has to be reconciled with\n+                // the older function signature we had before. In\n+                // principle we *should* be able to fn_sigs(), but we\n+                // can't because of the annoying need for a TypeTrace.\n+                // (This always bites me, should find a way to\n+                // refactor it.)\n+                let method_sig =\n+                    ty::assert_no_late_bound_regions(fcx.tcx(),\n+                                                     ty::ty_fn_sig(method_callee.ty));\n+\n+                debug!(\"attempt_resolution: method_callee={}\",\n+                       method_callee.repr(fcx.tcx()));\n+\n+                for (&method_arg_ty, &self_arg_ty) in\n+                    method_sig.inputs[1..].iter().zip(self.fn_sig.inputs.iter())\n+                {\n+                    demand::eqtype(fcx, self.call_expr.span, self_arg_ty, method_arg_ty);\n+                }\n+\n+                demand::eqtype(fcx,\n+                               self.call_expr.span,\n+                               method_sig.output.unwrap(),\n+                               self.fn_sig.output.unwrap());\n+\n+                write_overloaded_call_method_map(fcx, self.call_expr, method_callee);\n+\n+                true\n+            }\n+        }\n+    }\n+}"}, {"sha": "906a8a33314cc4070398bd948f8250111a855182", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0", "patch": "@@ -26,8 +26,8 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                    expr: &ast::Expr,\n                                    _capture: ast::CaptureClause,\n                                    opt_kind: Option<ast::ClosureKind>,\n-                                   decl: &ast::FnDecl,\n-                                   body: &ast::Block,\n+                                   decl: &'tcx ast::FnDecl,\n+                                   body: &'tcx ast::Block,\n                                    expected: Expectation<'tcx>) {\n     debug!(\"check_expr_closure(expr={},expected={})\",\n            expr.repr(fcx.tcx()),\n@@ -76,8 +76,8 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                           expr: &ast::Expr,\n                           kind: ty::ClosureKind,\n-                          decl: &ast::FnDecl,\n-                          body: &ast::Block,\n+                          decl: &'tcx ast::FnDecl,\n+                          body: &'tcx ast::Block,\n                           expected_sig: Option<ty::FnSig<'tcx>>) {\n     let expr_def_id = ast_util::local_def(expr.id);\n "}, {"sha": "c326116cbd5449b3fbbf8709212af0a69039d67b", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0", "patch": "@@ -31,8 +31,8 @@ use util::ppaux::Repr;\n struct ConfirmContext<'a, 'tcx:'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n-    self_expr: &'a ast::Expr,\n-    call_expr: &'a ast::Expr,\n+    self_expr: &'tcx ast::Expr,\n+    call_expr: &'tcx ast::Expr,\n }\n \n struct InstantiatedMethodSig<'tcx> {\n@@ -51,8 +51,8 @@ struct InstantiatedMethodSig<'tcx> {\n \n pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                          span: Span,\n-                         self_expr: &ast::Expr,\n-                         call_expr: &ast::Expr,\n+                         self_expr: &'tcx ast::Expr,\n+                         call_expr: &'tcx ast::Expr,\n                          unadjusted_self_ty: Ty<'tcx>,\n                          pick: probe::Pick<'tcx>,\n                          supplied_method_types: Vec<Ty<'tcx>>)\n@@ -70,8 +70,8 @@ pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n            span: Span,\n-           self_expr: &'a ast::Expr,\n-           call_expr: &'a ast::Expr)\n+           self_expr: &'tcx ast::Expr,\n+           call_expr: &'tcx ast::Expr)\n            -> ConfirmContext<'a, 'tcx>\n     {\n         ConfirmContext { fcx: fcx, span: span, self_expr: self_expr, call_expr: call_expr }"}, {"sha": "24e9f1c8720eef68e5ecca9b24bd04b6e10faf18", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0", "patch": "@@ -90,8 +90,8 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         method_name: ast::Name,\n                         self_ty: Ty<'tcx>,\n                         supplied_method_types: Vec<Ty<'tcx>>,\n-                        call_expr: &ast::Expr,\n-                        self_expr: &ast::Expr)\n+                        call_expr: &'tcx ast::Expr,\n+                        self_expr: &'tcx ast::Expr)\n                         -> Result<MethodCallee<'tcx>, MethodError>\n {\n     debug!(\"lookup(method_name={}, self_ty={}, call_expr={}, self_expr={})\","}, {"sha": "565e96483b9a2b841d2f05236759eefadc5f9513", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 110, "deletions": 96, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0", "patch": "@@ -170,8 +170,17 @@ pub struct Inherited<'a, 'tcx: 'a> {\n \n     // Tracks trait obligations incurred during this function body.\n     fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n+\n+    //\n+    deferred_resolutions: RefCell<Vec<DeferredResolutionHandler<'tcx>>>,\n+}\n+\n+trait DeferredResolution<'tcx> {\n+    fn attempt_resolution<'a>(&self, fcx: &FnCtxt<'a,'tcx>) -> bool;\n }\n \n+type DeferredResolutionHandler<'tcx> = Box<DeferredResolution<'tcx>+'tcx>;\n+\n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n #[derive(Copy)]\n@@ -377,6 +386,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             closures: RefCell::new(DefIdMap()),\n             fn_sig_map: RefCell::new(NodeMap()),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n+            deferred_resolutions: RefCell::new(Vec::new()),\n         }\n     }\n \n@@ -425,13 +435,13 @@ fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n \n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemTypesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item) {\n+impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &'tcx ast::Item) {\n         check_item(self.ccx, i);\n         visit::walk_item(self, i);\n     }\n \n-    fn visit_ty(&mut self, t: &ast::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx ast::Ty) {\n         match t.node {\n             ast::TyFixedLengthVec(_, ref expr) => {\n                 check_const_in_type(self.ccx, &**expr, self.ccx.tcx.types.uint);\n@@ -459,8 +469,8 @@ pub fn check_item_types(ccx: &CrateCtxt) {\n }\n \n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                           decl: &ast::FnDecl,\n-                           body: &ast::Block,\n+                           decl: &'tcx ast::FnDecl,\n+                           body: &'tcx ast::Block,\n                            id: ast::NodeId,\n                            raw_fty: Ty<'tcx>,\n                            param_env: ty::ParameterEnvironment<'a, 'tcx>)\n@@ -512,9 +522,9 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     // Add explicitly-declared locals.\n-    fn visit_local(&mut self, local: &ast::Local) {\n+    fn visit_local(&mut self, local: &'tcx ast::Local) {\n         let o_ty = match local.ty {\n             Some(ref ty) => Some(self.fcx.to_ty(&**ty)),\n             None => None\n@@ -528,7 +538,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n     }\n \n     // Add pattern bindings.\n-    fn visit_pat(&mut self, p: &ast::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx ast::Pat) {\n         if let ast::PatIdent(_, ref path1, _) = p.node {\n             if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map, p) {\n                 let var_ty = self.assign(p.span, p.id, None);\n@@ -546,7 +556,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n         visit::walk_pat(self, p);\n     }\n \n-    fn visit_block(&mut self, b: &ast::Block) {\n+    fn visit_block(&mut self, b: &'tcx ast::Block) {\n         // non-obvious: the `blk` variable maps to region lb, so\n         // we have to keep this up-to-date.  This\n         // is... unfortunate.  It'd be nice to not need this.\n@@ -555,7 +565,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n \n     // Since an expr occurs as part of the type fixed size arrays we\n     // need to record the type for that node\n-    fn visit_ty(&mut self, t: &ast::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx ast::Ty) {\n         match t.node {\n             ast::TyFixedLengthVec(ref ty, ref count_expr) => {\n                 self.visit_ty(&**ty);\n@@ -566,8 +576,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n     }\n \n     // Don't descend into fns and items\n-    fn visit_fn(&mut self, _: visit::FnKind<'v>, _: &'v ast::FnDecl,\n-                _: &'v ast::Block, _: Span, _: ast::NodeId) { }\n+    fn visit_fn(&mut self, _: visit::FnKind<'tcx>, _: &'tcx ast::FnDecl,\n+                _: &'tcx ast::Block, _: Span, _: ast::NodeId) { }\n     fn visit_item(&mut self, _: &ast::Item) { }\n \n }\n@@ -582,9 +592,9 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                       unsafety: ast::Unsafety,\n                       unsafety_id: ast::NodeId,\n                       fn_sig: &ty::FnSig<'tcx>,\n-                      decl: &ast::FnDecl,\n+                      decl: &'tcx ast::FnDecl,\n                       fn_id: ast::NodeId,\n-                      body: &ast::Block,\n+                      body: &'tcx ast::Block,\n                       inherited: &'a Inherited<'a, 'tcx>)\n                       -> FnCtxt<'a, 'tcx>\n {\n@@ -677,7 +687,7 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n-pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n+pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n     debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n@@ -829,7 +839,7 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n /// * `method`: the method definition\n fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                item_generics: &ty::Generics<'tcx>,\n-                               method: &ast::Method) {\n+                               method: &'tcx ast::Method) {\n     debug!(\"check_method_body(item_generics={}, method.id={})\",\n             item_generics.repr(ccx.tcx),\n             method.id);\n@@ -1133,10 +1143,10 @@ fn check_cast_inner<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-fn check_cast(fcx: &FnCtxt,\n-              cast_expr: &ast::Expr,\n-              e: &ast::Expr,\n-              t: &ast::Ty) {\n+fn check_cast<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                       cast_expr: &ast::Expr,\n+                       e: &'tcx ast::Expr,\n+                       t: &ast::Ty) {\n     let id = cast_expr.id;\n     let span = cast_expr.span;\n \n@@ -1279,6 +1289,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if ty::type_has_ty_infer(t) || ty::type_is_error(t) { Err(()) } else { Ok(t) }\n     }\n \n+    fn record_deferred_resolution(&self, r: DeferredResolutionHandler<'tcx>) {\n+        self.inh.deferred_resolutions.borrow_mut().push(r);\n+    }\n+\n     pub fn tag(&self) -> String {\n         format!(\"{:?}\", self as *const FnCtxt)\n     }\n@@ -2068,7 +2082,7 @@ fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             method_call: MethodCall,\n                             expr: &ast::Expr,\n-                            base_expr: &ast::Expr,\n+                            base_expr: &'tcx ast::Expr,\n                             adjusted_ty: Ty<'tcx>,\n                             adjustment: ty::AutoDerefRef<'tcx>,\n                             lvalue_pref: LvaluePreference,\n@@ -2138,8 +2152,8 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          sp: Span,\n                                          method_fn_ty: Ty<'tcx>,\n-                                         callee_expr: &ast::Expr,\n-                                         args_no_rcvr: &[P<ast::Expr>],\n+                                         callee_expr: &'tcx ast::Expr,\n+                                         args_no_rcvr: &'tcx [P<ast::Expr>],\n                                          autoref_args: AutorefArgs,\n                                          tuple_arguments: TupleArgumentsFlag,\n                                          expected: Expectation<'tcx>)\n@@ -2194,7 +2208,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   sp: Span,\n                                   fn_inputs: &[Ty<'tcx>],\n                                   expected_arg_tys: &[Ty<'tcx>],\n-                                  args: &[P<ast::Expr>],\n+                                  args: &'tcx [P<ast::Expr>],\n                                   autoref_args: AutorefArgs,\n                                   variadic: bool,\n                                   tuple_arguments: TupleArgumentsFlag) {\n@@ -2462,50 +2476,50 @@ pub fn valid_range_bounds(ccx: &CrateCtxt,\n }\n \n pub fn check_expr_has_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                     expr: &ast::Expr,\n+                                     expr: &'tcx ast::Expr,\n                                      expected: Ty<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr)));\n }\n \n fn check_expr_coercable_to_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                          expr: &ast::Expr,\n+                                          expr: &'tcx ast::Expr,\n                                           expected: Ty<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || demand::coerce(fcx, expr.span, expected, expr));\n }\n \n-fn check_expr_with_hint<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, expr: &ast::Expr,\n+fn check_expr_with_hint<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, expr: &'tcx ast::Expr,\n                                   expected: Ty<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || ())\n }\n \n fn check_expr_with_expectation<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                         expr: &ast::Expr,\n+                                         expr: &'tcx ast::Expr,\n                                          expected: Expectation<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, expected, NoPreference,\n         || ())\n }\n \n fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                         expr: &ast::Expr,\n+                                                         expr: &'tcx ast::Expr,\n                                                          expected: Expectation<'tcx>,\n                                                          lvalue_pref: LvaluePreference)\n {\n     check_expr_with_unifier(fcx, expr, expected, lvalue_pref, || ())\n }\n \n-fn check_expr(fcx: &FnCtxt, expr: &ast::Expr)  {\n+fn check_expr<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, expr: &'tcx ast::Expr)  {\n     check_expr_with_unifier(fcx, expr, NoExpectation, NoPreference, || ())\n }\n \n-fn check_expr_with_lvalue_pref(fcx: &FnCtxt, expr: &ast::Expr,\n-                               lvalue_pref: LvaluePreference)  {\n+fn check_expr_with_lvalue_pref<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, expr: &'tcx ast::Expr,\n+                                        lvalue_pref: LvaluePreference)  {\n     check_expr_with_unifier(fcx, expr, NoExpectation, lvalue_pref, || ())\n }\n \n@@ -2613,7 +2627,7 @@ fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// that there are actually multiple representations for `ty_err`, so avoid\n /// that when err needs to be handled differently.\n fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        expr: &ast::Expr,\n+                                        expr: &'tcx ast::Expr,\n                                         expected: Expectation<'tcx>,\n                                         lvalue_pref: LvaluePreference,\n                                         unifier: F) where\n@@ -2624,9 +2638,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Checks a method call.\n     fn check_method_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                   expr: &ast::Expr,\n+                                   expr: &'tcx ast::Expr,\n                                    method_name: ast::SpannedIdent,\n-                                   args: &[P<ast::Expr>],\n+                                   args: &'tcx [P<ast::Expr>],\n                                    tps: &[P<ast::Ty>],\n                                    expected: Expectation<'tcx>,\n                                    lvalue_pref: LvaluePreference) {\n@@ -2675,9 +2689,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     // A generic function for checking the then and else in an if\n     // or if-else.\n     fn check_then_else<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                 cond_expr: &ast::Expr,\n-                                 then_blk: &ast::Block,\n-                                 opt_else_expr: Option<&ast::Expr>,\n+                                 cond_expr: &'tcx ast::Expr,\n+                                 then_blk: &'tcx ast::Block,\n+                                 opt_else_expr: Option<&'tcx ast::Expr>,\n                                  id: ast::NodeId,\n                                  sp: Span,\n                                  expected: Expectation<'tcx>) {\n@@ -2717,12 +2731,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     fn lookup_op_method<'a, 'tcx, F>(fcx: &'a FnCtxt<'a, 'tcx>,\n-                                     op_ex: &ast::Expr,\n+                                     op_ex: &'tcx ast::Expr,\n                                      lhs_ty: Ty<'tcx>,\n                                      opname: ast::Name,\n                                      trait_did: Option<ast::DefId>,\n                                      lhs: &'a ast::Expr,\n-                                     rhs: Option<&P<ast::Expr>>,\n+                                     rhs: Option<&'tcx P<ast::Expr>>,\n                                      unbound_method: F,\n                                      autoref_args: AutorefArgs) -> Ty<'tcx> where\n         F: FnOnce(),\n@@ -2803,12 +2817,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     // could be either an expr_binop or an expr_assign_binop\n-    fn check_binop(fcx: &FnCtxt,\n-                   expr: &ast::Expr,\n-                   op: ast::BinOp,\n-                   lhs: &ast::Expr,\n-                   rhs: &P<ast::Expr>,\n-                   is_binop_assignment: IsBinopAssignment) {\n+    fn check_binop<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                            expr: &'tcx ast::Expr,\n+                            op: ast::BinOp,\n+                            lhs: &'tcx ast::Expr,\n+                            rhs: &'tcx P<ast::Expr>,\n+                            is_binop_assignment: IsBinopAssignment) {\n         let tcx = fcx.ccx.tcx;\n \n         let lvalue_pref = match is_binop_assignment {\n@@ -2923,11 +2937,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     fn check_user_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                  ex: &ast::Expr,\n-                                  lhs_expr: &ast::Expr,\n+                                  ex: &'tcx ast::Expr,\n+                                  lhs_expr: &'tcx ast::Expr,\n                                   lhs_resolved_t: Ty<'tcx>,\n                                   op: ast::BinOp,\n-                                  rhs: &P<ast::Expr>) -> Ty<'tcx> {\n+                                  rhs: &'tcx P<ast::Expr>) -> Ty<'tcx> {\n         let tcx = fcx.ccx.tcx;\n         let lang = &tcx.lang_items;\n         let (name, trait_did) = match op.node {\n@@ -2966,8 +2980,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  op_str: &str,\n                                  mname: &str,\n                                  trait_did: Option<ast::DefId>,\n-                                 ex: &ast::Expr,\n-                                 rhs_expr: &ast::Expr,\n+                                 ex: &'tcx ast::Expr,\n+                                 rhs_expr: &'tcx ast::Expr,\n                                  rhs_t: Ty<'tcx>,\n                                  op: ast::UnOp) -> Ty<'tcx> {\n        lookup_op_method(fcx, ex, rhs_t, token::intern(mname),\n@@ -2980,11 +2994,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     // Check field access expressions\n-    fn check_field(fcx: &FnCtxt,\n-                   expr: &ast::Expr,\n-                   lvalue_pref: LvaluePreference,\n-                   base: &ast::Expr,\n-                   field: &ast::SpannedIdent) {\n+    fn check_field<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                            expr: &'tcx ast::Expr,\n+                            lvalue_pref: LvaluePreference,\n+                            base: &'tcx ast::Expr,\n+                            field: &ast::SpannedIdent) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -3077,11 +3091,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     // Check tuple index expressions\n-    fn check_tup_field(fcx: &FnCtxt,\n-                       expr: &ast::Expr,\n-                       lvalue_pref: LvaluePreference,\n-                       base: &ast::Expr,\n-                       idx: codemap::Spanned<uint>) {\n+    fn check_tup_field<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                expr: &'tcx ast::Expr,\n+                                lvalue_pref: LvaluePreference,\n+                                base: &'tcx ast::Expr,\n+                                idx: codemap::Spanned<uint>) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -3149,7 +3163,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 node_id: ast::NodeId,\n                                                 substitutions: &'tcx subst::Substs<'tcx>,\n                                                 field_types: &[ty::field_ty],\n-                                                ast_fields: &[ast::Field],\n+                                                ast_fields: &'tcx [ast::Field],\n                                                 check_completeness: bool,\n                                                 enum_id_opt: Option<ast::DefId>)  {\n         let tcx = fcx.ccx.tcx;\n@@ -3252,12 +3266,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n \n-    fn check_struct_constructor(fcx: &FnCtxt,\n-                                id: ast::NodeId,\n-                                span: codemap::Span,\n-                                class_id: ast::DefId,\n-                                fields: &[ast::Field],\n-                                base_expr: Option<&ast::Expr>) {\n+    fn check_struct_constructor<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                         id: ast::NodeId,\n+                                         span: codemap::Span,\n+                                         class_id: ast::DefId,\n+                                         fields: &'tcx [ast::Field],\n+                                         base_expr: Option<&'tcx ast::Expr>) {\n         let tcx = fcx.ccx.tcx;\n \n         // Generate the struct type.\n@@ -3294,12 +3308,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, struct_type);\n     }\n \n-    fn check_struct_enum_variant(fcx: &FnCtxt,\n-                                 id: ast::NodeId,\n-                                 span: codemap::Span,\n-                                 enum_id: ast::DefId,\n-                                 variant_id: ast::DefId,\n-                                 fields: &[ast::Field]) {\n+    fn check_struct_enum_variant<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                          id: ast::NodeId,\n+                                          span: codemap::Span,\n+                                          enum_id: ast::DefId,\n+                                          variant_id: ast::DefId,\n+                                          fields: &'tcx [ast::Field]) {\n         let tcx = fcx.ccx.tcx;\n \n         // Look up the number of type parameters and the raw type, and\n@@ -3324,10 +3338,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, enum_type);\n     }\n \n-    fn check_struct_fields_on_error(fcx: &FnCtxt,\n-                                    id: ast::NodeId,\n-                                    fields: &[ast::Field],\n-                                    base_expr: &Option<P<ast::Expr>>) {\n+    fn check_struct_fields_on_error<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                             id: ast::NodeId,\n+                                             fields: &'tcx [ast::Field],\n+                                             base_expr: &'tcx Option<P<ast::Expr>>) {\n         // Make sure to still write the types\n         // otherwise we might ICE\n         fcx.write_error(id);\n@@ -4126,15 +4140,15 @@ impl<'tcx> Repr<'tcx> for Expectation<'tcx> {\n     }\n }\n \n-pub fn check_decl_initializer(fcx: &FnCtxt,\n-                              nid: ast::NodeId,\n-                              init: &ast::Expr)\n+pub fn check_decl_initializer<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                       nid: ast::NodeId,\n+                                       init: &'tcx ast::Expr)\n {\n     let local_ty = fcx.local_ty(init.span, nid);\n     check_expr_coercable_to_type(fcx, init, local_ty)\n }\n \n-pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n+pub fn check_decl_local<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, local: &'tcx ast::Local)  {\n     let tcx = fcx.ccx.tcx;\n \n     let t = fcx.local_ty(local.span, local.id);\n@@ -4159,7 +4173,7 @@ pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n     }\n }\n \n-pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n+pub fn check_stmt<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, stmt: &'tcx ast::Stmt)  {\n     let node_id;\n     let mut saw_bot = false;\n     let mut saw_err = false;\n@@ -4204,7 +4218,7 @@ pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n     }\n }\n \n-pub fn check_block_no_value(fcx: &FnCtxt, blk: &ast::Block)  {\n+pub fn check_block_no_value<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, blk: &'tcx ast::Block)  {\n     check_block_with_expected(fcx, blk, ExpectHasType(ty::mk_nil(fcx.tcx())));\n     let blkty = fcx.node_ty(blk.id);\n     if ty::type_is_error(blkty) {\n@@ -4216,7 +4230,7 @@ pub fn check_block_no_value(fcx: &FnCtxt, blk: &ast::Block)  {\n }\n \n fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                       blk: &ast::Block,\n+                                       blk: &'tcx ast::Block,\n                                        expected: Expectation<'tcx>) {\n     let prev = {\n         let mut fcx_ps = fcx.ps.borrow_mut();\n@@ -4299,17 +4313,17 @@ fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n /// length expression in a fixed-length vector, but someday it might be\n /// extended to type-level numeric literals.\n fn check_const_in_type<'a,'tcx>(ccx: &'a CrateCtxt<'a,'tcx>,\n-                                expr: &ast::Expr,\n+                                expr: &'tcx ast::Expr,\n                                 expected_type: Ty<'tcx>) {\n     let inh = static_inherited_fields(ccx);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(expected_type), expr.id);\n     check_const_with_ty(&fcx, expr.span, expr, expected_type);\n }\n \n-fn check_const(ccx: &CrateCtxt,\n-               sp: Span,\n-               e: &ast::Expr,\n-               id: ast::NodeId) {\n+fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                        sp: Span,\n+                        e: &'tcx ast::Expr,\n+                        id: ast::NodeId) {\n     let inh = static_inherited_fields(ccx);\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n@@ -4319,7 +4333,7 @@ fn check_const(ccx: &CrateCtxt,\n \n fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                  _: Span,\n-                                 e: &ast::Expr,\n+                                 e: &'tcx ast::Expr,\n                                  declty: Ty<'tcx>) {\n     // Gather locals in statics (because of block expressions).\n     // This is technically unnecessary because locals in static items are forbidden,\n@@ -4420,10 +4434,10 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     }\n }\n \n-pub fn check_enum_variants(ccx: &CrateCtxt,\n-                           sp: Span,\n-                           vs: &[P<ast::Variant>],\n-                           id: ast::NodeId) {\n+pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                    sp: Span,\n+                                    vs: &'tcx [P<ast::Variant>],\n+                                    id: ast::NodeId) {\n \n     fn disr_in_range(ccx: &CrateCtxt,\n                      ty: attr::IntType,\n@@ -4453,7 +4467,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     }\n \n     fn do_check<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                          vs: &[P<ast::Variant>],\n+                          vs: &'tcx [P<ast::Variant>],\n                           id: ast::NodeId,\n                           hint: attr::ReprAttr)\n                           -> Vec<Rc<ty::VariantInfo<'tcx>>> {"}, {"sha": "9d8eaf98569fa10882f0a9e46e30adc58e3c25b6", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=53c1956cfbbe8a5957bfa62f57bfb0e4b999a7b0", "patch": "@@ -280,6 +280,9 @@ fn check_object_type_binds_all_associated_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n     debug!(\"select_all_fcx_obligations_or_error\");\n \n+    fcx.inh.deferred_resolutions.borrow_mut()\n+                                .retain(|r| !r.attempt_resolution(fcx));\n+\n     select_fcx_obligations_where_possible(fcx);\n     fcx.default_type_parameters();\n "}]}