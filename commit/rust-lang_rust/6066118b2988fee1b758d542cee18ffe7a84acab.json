{"sha": "6066118b2988fee1b758d542cee18ffe7a84acab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNjYxMThiMjk4OGZlZTFiNzU4ZDU0MmNlZTE4ZmZlN2E4NGFjYWI=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-15T03:23:33Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-18T16:39:47Z"}, "message": "std::to_bytes: Delimit sequences &[A] and ~str when hashing\n\nAddress issue #5257, for example these values all had the same hash value:\n\n\t(\"aaa\", \"bbb\", \"ccc\")\n\t(\"aaab\", \"bb\", \"ccc\")\n\t(\"aaabbb\", \"\", \"ccc\")\n\nIterBytes for &[A] now includes the length, before calling iter_bytes on\neach element.\n\nIterBytes for &str is now terminated by a byte that does not appear in\nUTF-8. This way only one more byte is processed when hashing strings.", "tree": {"sha": "aa5fadca63d12e8298653a9bc9f8186b7ac2778a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa5fadca63d12e8298653a9bc9f8186b7ac2778a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6066118b2988fee1b758d542cee18ffe7a84acab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6066118b2988fee1b758d542cee18ffe7a84acab", "html_url": "https://github.com/rust-lang/rust/commit/6066118b2988fee1b758d542cee18ffe7a84acab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6066118b2988fee1b758d542cee18ffe7a84acab/comments", "author": null, "committer": null, "parents": [{"sha": "0a238288d343fc6323b37aad8678b3ea701fb7e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a238288d343fc6323b37aad8678b3ea701fb7e3", "html_url": "https://github.com/rust-lang/rust/commit/0a238288d343fc6323b37aad8678b3ea701fb7e3"}], "stats": {"total": 89, "additions": 47, "deletions": 42}, "files": [{"sha": "1af885100cd64d94acbc4451ecfe909c650a18c1", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6066118b2988fee1b758d542cee18ffe7a84acab/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6066118b2988fee1b758d542cee18ffe7a84acab/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=6066118b2988fee1b758d542cee18ffe7a84acab", "patch": "@@ -409,6 +409,14 @@ mod tests {\n \n     use uint;\n \n+    // Hash just the bytes of the slice, without length prefix\n+    struct Bytes<'self>(&'self [u8]);\n+    impl<'self> IterBytes for Bytes<'self> {\n+        fn iter_bytes(&self, _lsb0: bool, f: &fn(&[u8]) -> bool) -> bool {\n+            f(**self)\n+        }\n+    }\n+\n     #[test]\n     fn test_siphash() {\n         let vecs : [[u8, ..8], ..64] = [\n@@ -496,7 +504,7 @@ mod tests {\n         while t < 64 {\n             debug!(\"siphash test %?\", t);\n             let vec = u8to64_le!(vecs[t], 0);\n-            let out = buf.hash_keyed(k0, k1);\n+            let out = Bytes(buf.as_slice()).hash_keyed(k0, k1);\n             debug!(\"got %?, expected %?\", out, vec);\n             assert_eq!(vec, out);\n "}, {"sha": "1cfbf841537c5504f30f365848bc202076fd5610", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6066118b2988fee1b758d542cee18ffe7a84acab/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6066118b2988fee1b758d542cee18ffe7a84acab/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=6066118b2988fee1b758d542cee18ffe7a84acab", "patch": "@@ -376,7 +376,6 @@ static ASCII_UPPER_MAP: &'static [u8] = &[\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use to_bytes::ToBytes;\n     use str::from_char;\n \n     macro_rules! v2ascii (\n@@ -445,7 +444,6 @@ mod tests {\n \n     #[test]\n     fn test_ascii_to_bytes() {\n-        assert_eq!(v2ascii!(~[40, 32, 59]).to_bytes(false), ~[40u8, 32u8, 59u8]);\n         assert_eq!(v2ascii!(~[40, 32, 59]).into_bytes(), ~[40u8, 32u8, 59u8]);\n     }\n "}, {"sha": "a831c97438a16dcb6fc9e8ee975fa9d17c6d301d", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6066118b2988fee1b758d542cee18ffe7a84acab/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6066118b2988fee1b758d542cee18ffe7a84acab/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=6066118b2988fee1b758d542cee18ffe7a84acab", "patch": "@@ -15,37 +15,43 @@ The `ToBytes` and `IterBytes` traits\n */\n \n use cast;\n+use container::Container;\n use io;\n use io::Writer;\n use iterator::Iterator;\n use option::{None, Option, Some};\n-use str::StrSlice;\n-use vec::ImmutableVector;\n+use str::{Str, StrSlice};\n+use vec::{Vector, ImmutableVector};\n \n pub type Cb<'self> = &'self fn(buf: &[u8]) -> bool;\n \n-/**\n- * A trait to implement in order to make a type hashable;\n- * This works in combination with the trait `Hash::Hash`, and\n- * may in the future be merged with that trait or otherwise\n- * modified when default methods and trait inheritance are\n- * completed.\n- */\n+///\n+/// A trait to implement in order to make a type hashable;\n+/// This works in combination with the trait `std::hash::Hash`, and\n+/// may in the future be merged with that trait or otherwise\n+/// modified when default methods and trait inheritance are\n+/// completed.\n+///\n+/// IterBytes should be implemented so that the extent of the\n+/// produced byte stream can be discovered, given the original\n+/// type.\n+/// For example, the IterBytes implementation for vectors emits\n+/// its length first, and enums should emit their discriminant.\n+///\n pub trait IterBytes {\n-    /**\n-     * Call the provided callback `f` one or more times with\n-     * byte-slices that should be used when computing a hash\n-     * value or otherwise \"flattening\" the structure into\n-     * a sequence of bytes. The `lsb0` parameter conveys\n-     * whether the caller is asking for little-endian bytes\n-     * (`true`) or big-endian (`false`); this should only be\n-     * relevant in implementations that represent a single\n-     * multi-byte datum such as a 32 bit integer or 64 bit\n-     * floating-point value. It can be safely ignored for\n-     * larger structured types as they are usually processed\n-     * left-to-right in declaration order, regardless of\n-     * underlying memory endianness.\n-     */\n+    /// Call the provided callback `f` one or more times with\n+    /// byte-slices that should be used when computing a hash\n+    /// value or otherwise \"flattening\" the structure into\n+    /// a sequence of bytes. The `lsb0` parameter conveys\n+    /// whether the caller is asking for little-endian bytes\n+    /// (`true`) or big-endian (`false`); this should only be\n+    /// relevant in implementations that represent a single\n+    /// multi-byte datum such as a 32 bit integer or 64 bit\n+    /// floating-point value. It can be safely ignored for\n+    /// larger structured types as they are usually processed\n+    /// left-to-right in declaration order, regardless of\n+    /// underlying memory endianness.\n+    ///\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool;\n }\n \n@@ -224,6 +230,7 @@ impl IterBytes for f64 {\n impl<'self,A:IterBytes> IterBytes for &'self [A] {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        self.len().iter_bytes(lsb0, |b| f(b)) &&\n         self.iter().advance(|elt| elt.iter_bytes(lsb0, |b| f(b)))\n     }\n }\n@@ -251,47 +258,39 @@ impl<A:IterBytes,B:IterBytes,C:IterBytes> IterBytes for (A,B,C) {\n   }\n }\n \n-// Move this to vec, probably.\n-fn borrow<'x,A>(a: &'x [A]) -> &'x [A] {\n-    a\n-}\n-\n impl<A:IterBytes> IterBytes for ~[A] {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        borrow(*self).iter_bytes(lsb0, f)\n+        self.as_slice().iter_bytes(lsb0, f)\n     }\n }\n \n impl<A:IterBytes> IterBytes for @[A] {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        borrow(*self).iter_bytes(lsb0, f)\n+        self.as_slice().iter_bytes(lsb0, f)\n     }\n }\n \n impl<'self> IterBytes for &'self str {\n     #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n-        f(self.as_bytes())\n+        // Terminate the string with a byte that does not appear in UTF-8\n+        f(self.as_bytes()) && f([0xFF])\n     }\n }\n \n impl IterBytes for ~str {\n     #[inline]\n-    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n-        // this should possibly include the null terminator, but that\n-        // breaks .find_equiv on hashmaps.\n-        f(self.as_bytes())\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        self.as_slice().iter_bytes(lsb0, f)\n     }\n }\n \n impl IterBytes for @str {\n     #[inline]\n-    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n-        // this should possibly include the null terminator, but that\n-        // breaks .find_equiv on hashmaps.\n-        f(self.as_bytes())\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        self.as_slice().iter_bytes(lsb0, f)\n     }\n }\n "}]}