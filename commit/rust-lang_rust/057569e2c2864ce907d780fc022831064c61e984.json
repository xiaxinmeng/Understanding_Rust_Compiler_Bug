{"sha": "057569e2c2864ce907d780fc022831064c61e984", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NzU2OWUyYzI4NjRjZTkwN2Q3ODBmYzAyMjgzMTA2NGM2MWU5ODQ=", "commit": {"author": {"name": "Alex Zatelepin", "email": "mvzp10@gmail.com", "date": "2019-09-18T15:08:56Z"}, "committer": {"name": "Alex Zatelepin", "email": "mvzp10@gmail.com", "date": "2019-10-01T14:48:37Z"}, "message": "fix spurious unreachable_code lints for try{} block ok-wrapping", "tree": {"sha": "b9ed988e30973cd4dd2e56b0e377ee3dccb6bd8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9ed988e30973cd4dd2e56b0e377ee3dccb6bd8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/057569e2c2864ce907d780fc022831064c61e984", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/057569e2c2864ce907d780fc022831064c61e984", "html_url": "https://github.com/rust-lang/rust/commit/057569e2c2864ce907d780fc022831064c61e984", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/057569e2c2864ce907d780fc022831064c61e984/comments", "author": {"login": "ztlpn", "id": 2301957, "node_id": "MDQ6VXNlcjIzMDE5NTc=", "avatar_url": "https://avatars.githubusercontent.com/u/2301957?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ztlpn", "html_url": "https://github.com/ztlpn", "followers_url": "https://api.github.com/users/ztlpn/followers", "following_url": "https://api.github.com/users/ztlpn/following{/other_user}", "gists_url": "https://api.github.com/users/ztlpn/gists{/gist_id}", "starred_url": "https://api.github.com/users/ztlpn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ztlpn/subscriptions", "organizations_url": "https://api.github.com/users/ztlpn/orgs", "repos_url": "https://api.github.com/users/ztlpn/repos", "events_url": "https://api.github.com/users/ztlpn/events{/privacy}", "received_events_url": "https://api.github.com/users/ztlpn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ztlpn", "id": 2301957, "node_id": "MDQ6VXNlcjIzMDE5NTc=", "avatar_url": "https://avatars.githubusercontent.com/u/2301957?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ztlpn", "html_url": "https://github.com/ztlpn", "followers_url": "https://api.github.com/users/ztlpn/followers", "following_url": "https://api.github.com/users/ztlpn/following{/other_user}", "gists_url": "https://api.github.com/users/ztlpn/gists{/gist_id}", "starred_url": "https://api.github.com/users/ztlpn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ztlpn/subscriptions", "organizations_url": "https://api.github.com/users/ztlpn/orgs", "repos_url": "https://api.github.com/users/ztlpn/repos", "events_url": "https://api.github.com/users/ztlpn/events{/privacy}", "received_events_url": "https://api.github.com/users/ztlpn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48081065f4badf0544ec02d6ecde673716fd6695", "url": "https://api.github.com/repos/rust-lang/rust/commits/48081065f4badf0544ec02d6ecde673716fd6695", "html_url": "https://github.com/rust-lang/rust/commit/48081065f4badf0544ec02d6ecde673716fd6695"}], "stats": {"total": 78, "additions": 57, "deletions": 21}, "files": [{"sha": "0d2c7c13a85b9d8b445abe69bce61b5f389671ca", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/057569e2c2864ce907d780fc022831064c61e984/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057569e2c2864ce907d780fc022831064c61e984/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=057569e2c2864ce907d780fc022831064c61e984", "patch": "@@ -394,30 +394,49 @@ impl LoweringContext<'_> {\n \n     fn lower_expr_try_block(&mut self, body: &Block) -> hir::ExprKind {\n         self.with_catch_scope(body.id, |this| {\n-            let unstable_span = this.mark_span_with_reason(\n+            let mut block = this.lower_block(body, true).into_inner();\n+\n+            let tail_expr = block.expr.take().map_or_else(\n+                || {\n+                    let unit_span = this.mark_span_with_reason(\n+                        DesugaringKind::TryBlock,\n+                        this.sess.source_map().end_point(body.span),\n+                        None\n+                    );\n+                    this.expr_unit(unit_span)\n+                },\n+                |x: P<hir::Expr>| x.into_inner(),\n+            );\n+\n+            let from_ok_span = this.mark_span_with_reason(\n                 DesugaringKind::TryBlock,\n-                body.span,\n+                tail_expr.span,\n                 this.allow_try_trait.clone(),\n             );\n-            let mut block = this.lower_block(body, true).into_inner();\n-            let tail = block.expr.take().map_or_else(\n-                || this.expr_unit(this.sess.source_map().end_point(unstable_span)),\n-                |x: P<hir::Expr>| x.into_inner(),\n+\n+            let ok_wrapped_span = this.mark_span_with_reason(\n+                DesugaringKind::TryBlock,\n+                tail_expr.span,\n+                None\n             );\n-            block.expr = Some(this.wrap_in_try_constructor(sym::from_ok, tail, unstable_span));\n+\n+            block.expr = Some(this.wrap_in_try_constructor(\n+                sym::from_ok, from_ok_span, tail_expr, ok_wrapped_span));\n+\n             hir::ExprKind::Block(P(block), None)\n         })\n     }\n \n     fn wrap_in_try_constructor(\n         &mut self,\n         method: Symbol,\n-        e: hir::Expr,\n-        unstable_span: Span,\n+        method_span: Span,\n+        expr: hir::Expr,\n+        overall_span: Span,\n     ) -> P<hir::Expr> {\n         let path = &[sym::ops, sym::Try, method];\n-        let from_err = P(self.expr_std_path(unstable_span, path, None, ThinVec::new()));\n-        P(self.expr_call(e.span, from_err, hir_vec![e]))\n+        let constructor = P(self.expr_std_path(method_span, path, None, ThinVec::new()));\n+        P(self.expr_call(overall_span, constructor, hir_vec![expr]))\n     }\n \n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm {\n@@ -1244,7 +1263,7 @@ impl LoweringContext<'_> {\n                 self.expr_call_std_path(try_span, from_path, hir_vec![err_expr])\n             };\n             let from_err_expr =\n-                self.wrap_in_try_constructor(sym::from_error, from_expr, unstable_span);\n+                self.wrap_in_try_constructor(sym::from_error, unstable_span, from_expr, try_span);\n             let thin_attrs = ThinVec::from(attrs);\n             let catch_scope = self.catch_scopes.last().map(|x| *x);\n             let ret_expr = if let Some(catch_node) = catch_scope {"}, {"sha": "9b4d88a5a09671cb283c93f200cc5f1ffc658adb", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/057569e2c2864ce907d780fc022831064c61e984/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057569e2c2864ce907d780fc022831064c61e984/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=057569e2c2864ce907d780fc022831064c61e984", "patch": "@@ -861,7 +861,7 @@ pub struct Block {\n     pub span: Span,\n     /// If true, then there may exist `break 'a` values that aim to\n     /// break out of this block early.\n-    /// Used by `'label: {}` blocks and by `catch` statements.\n+    /// Used by `'label: {}` blocks and by `try {}` blocks.\n     pub targeted_by_break: bool,\n }\n "}, {"sha": "a93ea0cc00467c767271d326fe88523d92944beb", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/057569e2c2864ce907d780fc022831064c61e984/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057569e2c2864ce907d780fc022831064c61e984/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=057569e2c2864ce907d780fc022831064c61e984", "patch": "@@ -18,6 +18,7 @@ use crate::util::nodemap::FxHashMap;\n use crate::astconv::AstConv as _;\n \n use errors::{Applicability, DiagnosticBuilder, pluralise};\n+use syntax_pos::hygiene::DesugaringKind;\n use syntax::ast;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax::source_map::Span;\n@@ -150,8 +151,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\">> type-checking: expr={:?} expected={:?}\",\n                expr, expected);\n \n+        // If when desugaring the try block we ok-wrapped an expression that diverges\n+        // (e.g. `try { return }`) then technically the ok-wrapping expression is unreachable.\n+        // But since it is autogenerated code the resulting warning is confusing for the user\n+        // so we want avoid generating it.\n+        // Ditto for the autogenerated `Try::from_ok(())` at the end of e.g. `try { return; }`.\n+        let (is_try_block_ok_wrapped_expr, is_try_block_generated_expr) = match expr.node {\n+            ExprKind::Call(_, ref args) if expr.span.is_desugaring(DesugaringKind::TryBlock) => {\n+                (true, args.len() == 1 && args[0].span.is_desugaring(DesugaringKind::TryBlock))\n+            }\n+            _ => (false, false),\n+        };\n+\n         // Warn for expressions after diverging siblings.\n-        self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\");\n+        if !is_try_block_generated_expr {\n+            self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\");\n+        }\n \n         // Hide the outer diverging and has_errors flags.\n         let old_diverges = self.diverges.get();\n@@ -162,13 +177,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = self.check_expr_kind(expr, expected, needs);\n \n         // Warn for non-block expressions with diverging children.\n-        match expr.kind {\n-            ExprKind::Block(..) | ExprKind::Loop(..) | ExprKind::Match(..) => {},\n-            ExprKind::Call(ref callee, _) =>\n-                self.warn_if_unreachable(expr.hir_id, callee.span, \"call\"),\n-            ExprKind::MethodCall(_, ref span, _) =>\n-                self.warn_if_unreachable(expr.hir_id, *span, \"call\"),\n-            _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\"),\n+        if !is_try_block_ok_wrapped_expr {\n+            match expr.kind {\n+                ExprKind::Block(..) | ExprKind::Loop(..) | ExprKind::Match(..) => {},\n+                ExprKind::Call(ref callee, _) =>\n+                    self.warn_if_unreachable(expr.hir_id, callee.span, \"call\"),\n+                ExprKind::MethodCall(_, ref span, _) =>\n+                    self.warn_if_unreachable(expr.hir_id, *span, \"call\"),\n+                _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\"),\n+            }\n         }\n \n         // Any expression that produces a value of type `!` must have diverged"}]}