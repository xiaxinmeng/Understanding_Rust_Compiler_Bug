{"sha": "e50105e3f5e351aee668c9faf9b4d86ac1d28899", "node_id": "C_kwDOAAsO6NoAKGU1MDEwNWUzZjVlMzUxYWVlNjY4YzlmYWY5YjRkODZhYzFkMjg4OTk", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-21T18:55:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-21T18:55:18Z"}, "message": "Rollup merge of #95434 - cjgillot:dump-dep-kind, r=oli-obk\n\nOnly output DepKind in dump-dep-graph.\n\nWhen printing the whole DepNode, the output file is simply too massive to\nbe actually useful for profiling.\n\nThis trimmed down version mixes a lot of information together, but it also\nallows to ask questions such that \"why does this query ever access HIR?\".", "tree": {"sha": "1d748dfc94a9b02255068a553e7677be88ed403b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d748dfc94a9b02255068a553e7677be88ed403b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e50105e3f5e351aee668c9faf9b4d86ac1d28899", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiYaiWCRBK7hj4Ov3rIwAA/XoIAC50vAnV8JmFyZ42hKKKt8s7\naQXYvLaT46JCMKZ4jUFVYsT15zVEdczHDziDLTT+fQSq7fjAG4I4aBvDhrGSs8dI\nZGd5vtpSO42ZR2/jLrFw75iIrY7U0vyqumeMd5DUDLYYfEHKD1fqW4KkVUWaDu8Q\nKdXY6dsuHHVsdSFsvMbMAWoQXYgISnEXwxqCMfPwtQGdcXPFN48Z78nST23hGoSH\nuSy9XMI0OSUqZasj/GbtbrHD0gFWObToEBOKiSzTim1J7EK1198s5R98rg0/QEoS\nL4EwrT3Brbqvglbuj3eeaR9Ds7xBXdUnlsvpABNW6YzYP9+Oc70Y6gbGwWq/J8s=\n=enNK\n-----END PGP SIGNATURE-----\n", "payload": "tree 1d748dfc94a9b02255068a553e7677be88ed403b\nparent b04c5329e1e145fb2fb46c5a7e775638712b03aa\nparent 87dd3def59e729f7be0a0e69cd4e7adc5ea37dcb\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1650567318 +0200\ncommitter GitHub <noreply@github.com> 1650567318 +0200\n\nRollup merge of #95434 - cjgillot:dump-dep-kind, r=oli-obk\n\nOnly output DepKind in dump-dep-graph.\n\nWhen printing the whole DepNode, the output file is simply too massive to\nbe actually useful for profiling.\n\nThis trimmed down version mixes a lot of information together, but it also\nallows to ask questions such that \"why does this query ever access HIR?\".\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e50105e3f5e351aee668c9faf9b4d86ac1d28899", "html_url": "https://github.com/rust-lang/rust/commit/e50105e3f5e351aee668c9faf9b4d86ac1d28899", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e50105e3f5e351aee668c9faf9b4d86ac1d28899/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b04c5329e1e145fb2fb46c5a7e775638712b03aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/b04c5329e1e145fb2fb46c5a7e775638712b03aa", "html_url": "https://github.com/rust-lang/rust/commit/b04c5329e1e145fb2fb46c5a7e775638712b03aa"}, {"sha": "87dd3def59e729f7be0a0e69cd4e7adc5ea37dcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/87dd3def59e729f7be0a0e69cd4e7adc5ea37dcb", "html_url": "https://github.com/rust-lang/rust/commit/87dd3def59e729f7be0a0e69cd4e7adc5ea37dcb"}], "stats": {"total": 53, "additions": 28, "deletions": 25}, "files": [{"sha": "2d06c9d8ec92c60d8f6cb3d56820d56d7c0d29d7", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e50105e3f5e351aee668c9faf9b4d86ac1d28899/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50105e3f5e351aee668c9faf9b4d86ac1d28899/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=e50105e3f5e351aee668c9faf9b4d86ac1d28899", "patch": "@@ -241,7 +241,7 @@ fn dump_graph(query: &DepGraphQuery) {\n             let targets = node_set(&query, &edge_filter.target);\n             filter_nodes(&query, &sources, &targets)\n         }\n-        Err(_) => query.nodes().into_iter().collect(),\n+        Err(_) => query.nodes().into_iter().map(|n| n.kind).collect(),\n     };\n     let edges = filter_edges(&query, &nodes);\n \n@@ -264,41 +264,41 @@ fn dump_graph(query: &DepGraphQuery) {\n }\n \n #[allow(missing_docs)]\n-pub struct GraphvizDepGraph<'q>(FxHashSet<&'q DepNode>, Vec<(&'q DepNode, &'q DepNode)>);\n+pub struct GraphvizDepGraph(FxHashSet<DepKind>, Vec<(DepKind, DepKind)>);\n \n-impl<'a, 'q> dot::GraphWalk<'a> for GraphvizDepGraph<'q> {\n-    type Node = &'q DepNode;\n-    type Edge = (&'q DepNode, &'q DepNode);\n-    fn nodes(&self) -> dot::Nodes<'_, &'q DepNode> {\n+impl<'a> dot::GraphWalk<'a> for GraphvizDepGraph {\n+    type Node = DepKind;\n+    type Edge = (DepKind, DepKind);\n+    fn nodes(&self) -> dot::Nodes<'_, DepKind> {\n         let nodes: Vec<_> = self.0.iter().cloned().collect();\n         nodes.into()\n     }\n-    fn edges(&self) -> dot::Edges<'_, (&'q DepNode, &'q DepNode)> {\n+    fn edges(&self) -> dot::Edges<'_, (DepKind, DepKind)> {\n         self.1[..].into()\n     }\n-    fn source(&self, edge: &(&'q DepNode, &'q DepNode)) -> &'q DepNode {\n+    fn source(&self, edge: &(DepKind, DepKind)) -> DepKind {\n         edge.0\n     }\n-    fn target(&self, edge: &(&'q DepNode, &'q DepNode)) -> &'q DepNode {\n+    fn target(&self, edge: &(DepKind, DepKind)) -> DepKind {\n         edge.1\n     }\n }\n \n-impl<'a, 'q> dot::Labeller<'a> for GraphvizDepGraph<'q> {\n-    type Node = &'q DepNode;\n-    type Edge = (&'q DepNode, &'q DepNode);\n+impl<'a> dot::Labeller<'a> for GraphvizDepGraph {\n+    type Node = DepKind;\n+    type Edge = (DepKind, DepKind);\n     fn graph_id(&self) -> dot::Id<'_> {\n         dot::Id::new(\"DependencyGraph\").unwrap()\n     }\n-    fn node_id(&self, n: &&'q DepNode) -> dot::Id<'_> {\n+    fn node_id(&self, n: &DepKind) -> dot::Id<'_> {\n         let s: String = format!(\"{:?}\", n)\n             .chars()\n             .map(|c| if c == '_' || c.is_alphanumeric() { c } else { '_' })\n             .collect();\n         debug!(\"n={:?} s={:?}\", n, s);\n         dot::Id::new(s).unwrap()\n     }\n-    fn node_label(&self, n: &&'q DepNode) -> dot::LabelText<'_> {\n+    fn node_label(&self, n: &DepKind) -> dot::LabelText<'_> {\n         dot::LabelText::label(format!(\"{:?}\", n))\n     }\n }\n@@ -323,7 +323,7 @@ fn filter_nodes<'q>(\n     query: &'q DepGraphQuery,\n     sources: &Option<FxHashSet<&'q DepNode>>,\n     targets: &Option<FxHashSet<&'q DepNode>>,\n-) -> FxHashSet<&'q DepNode> {\n+) -> FxHashSet<DepKind> {\n     if let Some(sources) = sources {\n         if let Some(targets) = targets {\n             walk_between(query, sources, targets)\n@@ -333,25 +333,25 @@ fn filter_nodes<'q>(\n     } else if let Some(targets) = targets {\n         walk_nodes(query, targets, INCOMING)\n     } else {\n-        query.nodes().into_iter().collect()\n+        query.nodes().into_iter().map(|n| n.kind).collect()\n     }\n }\n \n fn walk_nodes<'q>(\n     query: &'q DepGraphQuery,\n     starts: &FxHashSet<&'q DepNode>,\n     direction: Direction,\n-) -> FxHashSet<&'q DepNode> {\n+) -> FxHashSet<DepKind> {\n     let mut set = FxHashSet::default();\n     for &start in starts {\n         debug!(\"walk_nodes: start={:?} outgoing?={:?}\", start, direction == OUTGOING);\n-        if set.insert(start) {\n+        if set.insert(start.kind) {\n             let mut stack = vec![query.indices[start]];\n             while let Some(index) = stack.pop() {\n                 for (_, edge) in query.graph.adjacent_edges(index, direction) {\n                     let neighbor_index = edge.source_or_target(direction);\n                     let neighbor = query.graph.node_data(neighbor_index);\n-                    if set.insert(neighbor) {\n+                    if set.insert(neighbor.kind) {\n                         stack.push(neighbor_index);\n                     }\n                 }\n@@ -365,7 +365,7 @@ fn walk_between<'q>(\n     query: &'q DepGraphQuery,\n     sources: &FxHashSet<&'q DepNode>,\n     targets: &FxHashSet<&'q DepNode>,\n-) -> FxHashSet<&'q DepNode> {\n+) -> FxHashSet<DepKind> {\n     // This is a bit tricky. We want to include a node only if it is:\n     // (a) reachable from a source and (b) will reach a target. And we\n     // have to be careful about cycles etc.  Luckily efficiency is not\n@@ -396,6 +396,7 @@ fn walk_between<'q>(\n             let index = query.indices[n];\n             node_states[index.0] == State::Included\n         })\n+        .map(|n| n.kind)\n         .collect();\n \n     fn recurse(query: &DepGraphQuery, node_states: &mut [State], node: NodeIndex) -> bool {\n@@ -433,11 +434,13 @@ fn walk_between<'q>(\n \n fn filter_edges<'q>(\n     query: &'q DepGraphQuery,\n-    nodes: &FxHashSet<&'q DepNode>,\n-) -> Vec<(&'q DepNode, &'q DepNode)> {\n-    query\n+    nodes: &FxHashSet<DepKind>,\n+) -> Vec<(DepKind, DepKind)> {\n+    let uniq: FxHashSet<_> = query\n         .edges()\n         .into_iter()\n-        .filter(|&(source, target)| nodes.contains(source) && nodes.contains(target))\n-        .collect()\n+        .map(|(s, t)| (s.kind, t.kind))\n+        .filter(|(source, target)| nodes.contains(source) && nodes.contains(target))\n+        .collect();\n+    uniq.into_iter().collect()\n }"}]}