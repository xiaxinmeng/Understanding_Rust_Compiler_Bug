{"sha": "d5205f23d3ba4b51e56b2c1a7ca68f8a1b9fa15f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MjA1ZjIzZDNiYTRiNTFlNTZiMmMxYTdjYTY4ZjhhMWI5ZmExNWY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-28T05:29:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-28T05:29:59Z"}, "message": "Rollup merge of #73758 - davidtwco:issue-60855-remaining-reveal-all, r=matthewjasper\n\nimproper_ctypes: fix remaining `Reveal:All`\n\nFixes #60855.\n\nThis PR replaces the remaining uses of `ParamEnv::reveal_all` with `LateContext`'s `param_env` (normally `Reveal::UserFacing`) in the improper ctypes lint.", "tree": {"sha": "4feb1ffaa67d20a85e50b8faec2c7b20b1ed3b9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4feb1ffaa67d20a85e50b8faec2c7b20b1ed3b9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5205f23d3ba4b51e56b2c1a7ca68f8a1b9fa15f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe+CrYCRBK7hj4Ov3rIwAAdHIIAEAoaNcSvZfgm7r8bIF0kolr\n+vPvE41y92gjIRgcr34deILKh7XpVBi04OK4OYTswyfLL3qJTA8ELL0WD2fkiLzL\nEjpPmrUNnv438l8QnmJeKNERs0BVsEsf0QBfzUela3/bc3ScRLruCI97XBj/aFEG\nDe8UWrtwNXxNUqlBfpthmi6V2aGxKqPmpj4fg+9gLKXrj83neiN3SAhG0pq+X4Bg\nZlcMmeEVKgdW4qpp8IrW9l/PqvKFqJ6Flh5q3r/GX5r95ky0wo87PzAXov7RrL5Y\ngQnQESLT77RkGbHZH20theIg59YqbweDZqQUxiSQ2PaqnvemSKlOD5+XWQantzs=\n=aUt4\n-----END PGP SIGNATURE-----\n", "payload": "tree 4feb1ffaa67d20a85e50b8faec2c7b20b1ed3b9d\nparent b236e49f097dbe7089d8349974f9c0bcd73993b2\nparent a6417b9c3822a08e27e0f556d76b880e26c0554d\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593322199 -0700\ncommitter GitHub <noreply@github.com> 1593322199 -0700\n\nRollup merge of #73758 - davidtwco:issue-60855-remaining-reveal-all, r=matthewjasper\n\nimproper_ctypes: fix remaining `Reveal:All`\n\nFixes #60855.\n\nThis PR replaces the remaining uses of `ParamEnv::reveal_all` with `LateContext`'s `param_env` (normally `Reveal::UserFacing`) in the improper ctypes lint.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5205f23d3ba4b51e56b2c1a7ca68f8a1b9fa15f", "html_url": "https://github.com/rust-lang/rust/commit/d5205f23d3ba4b51e56b2c1a7ca68f8a1b9fa15f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5205f23d3ba4b51e56b2c1a7ca68f8a1b9fa15f/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b236e49f097dbe7089d8349974f9c0bcd73993b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b236e49f097dbe7089d8349974f9c0bcd73993b2", "html_url": "https://github.com/rust-lang/rust/commit/b236e49f097dbe7089d8349974f9c0bcd73993b2"}, {"sha": "a6417b9c3822a08e27e0f556d76b880e26c0554d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6417b9c3822a08e27e0f556d76b880e26c0554d", "html_url": "https://github.com/rust-lang/rust/commit/a6417b9c3822a08e27e0f556d76b880e26c0554d"}], "stats": {"total": 128, "additions": 66, "deletions": 62}, "files": [{"sha": "d0275a0dd0dcbf72d451822f4e6f2d09bf3ea117", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 66, "deletions": 62, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/d5205f23d3ba4b51e56b2c1a7ca68f8a1b9fa15f/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5205f23d3ba4b51e56b2c1a7ca68f8a1b9fa15f/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=d5205f23d3ba4b51e56b2c1a7ca68f8a1b9fa15f", "patch": "@@ -11,7 +11,7 @@ use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{sign_extend, truncate};\n use rustc_middle::ty::layout::{IntegerExt, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, AdtKind, Ty, TypeFoldable};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n@@ -525,78 +525,82 @@ enum FfiResult<'tcx> {\n     FfiUnsafe { ty: Ty<'tcx>, reason: String, help: Option<String> },\n }\n \n-fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.kind {\n-        ty::FnPtr(_) => true,\n-        ty::Ref(..) => true,\n-        ty::Adt(field_def, substs) if field_def.repr.transparent() && !field_def.is_union() => {\n-            for field in field_def.all_fields() {\n-                let field_ty =\n-                    tcx.normalize_erasing_regions(ParamEnv::reveal_all(), field.ty(tcx, substs));\n-                if field_ty.is_zst(tcx, field.did) {\n-                    continue;\n-                }\n+impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n+    /// Is type known to be non-null?\n+    fn ty_is_known_nonnull(&self, ty: Ty<'tcx>) -> bool {\n+        match ty.kind {\n+            ty::FnPtr(_) => true,\n+            ty::Ref(..) => true,\n+            ty::Adt(field_def, substs) if field_def.repr.transparent() && !field_def.is_union() => {\n+                for field in field_def.all_fields() {\n+                    let field_ty = self.cx.tcx.normalize_erasing_regions(\n+                        self.cx.param_env,\n+                        field.ty(self.cx.tcx, substs),\n+                    );\n+                    if field_ty.is_zst(self.cx.tcx, field.did) {\n+                        continue;\n+                    }\n \n-                let attrs = tcx.get_attrs(field_def.did);\n-                if attrs.iter().any(|a| a.check_name(sym::rustc_nonnull_optimization_guaranteed))\n-                    || ty_is_known_nonnull(tcx, field_ty)\n-                {\n-                    return true;\n+                    let attrs = self.cx.tcx.get_attrs(field_def.did);\n+                    if attrs\n+                        .iter()\n+                        .any(|a| a.check_name(sym::rustc_nonnull_optimization_guaranteed))\n+                        || self.ty_is_known_nonnull(field_ty)\n+                    {\n+                        return true;\n+                    }\n                 }\n-            }\n \n-            false\n+                false\n+            }\n+            _ => false,\n         }\n-        _ => false,\n     }\n-}\n \n-/// Check if this enum can be safely exported based on the\n-/// \"nullable pointer optimization\". Currently restricted\n-/// to function pointers, references, core::num::NonZero*,\n-/// core::ptr::NonNull, and #[repr(transparent)] newtypes.\n-/// FIXME: This duplicates code in codegen.\n-fn is_repr_nullable_ptr<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n-    ty_def: &'tcx ty::AdtDef,\n-    substs: SubstsRef<'tcx>,\n-) -> bool {\n-    if ty_def.variants.len() != 2 {\n-        return false;\n-    }\n+    /// Check if this enum can be safely exported based on the \"nullable pointer optimization\".\n+    /// Currently restricted to function pointers, references, `core::num::NonZero*`,\n+    /// `core::ptr::NonNull`, and `#[repr(transparent)]` newtypes.\n+    fn is_repr_nullable_ptr(\n+        &self,\n+        ty: Ty<'tcx>,\n+        ty_def: &'tcx ty::AdtDef,\n+        substs: SubstsRef<'tcx>,\n+    ) -> bool {\n+        if ty_def.variants.len() != 2 {\n+            return false;\n+        }\n \n-    let get_variant_fields = |index| &ty_def.variants[VariantIdx::new(index)].fields;\n-    let variant_fields = [get_variant_fields(0), get_variant_fields(1)];\n-    let fields = if variant_fields[0].is_empty() {\n-        &variant_fields[1]\n-    } else if variant_fields[1].is_empty() {\n-        &variant_fields[0]\n-    } else {\n-        return false;\n-    };\n+        let get_variant_fields = |index| &ty_def.variants[VariantIdx::new(index)].fields;\n+        let variant_fields = [get_variant_fields(0), get_variant_fields(1)];\n+        let fields = if variant_fields[0].is_empty() {\n+            &variant_fields[1]\n+        } else if variant_fields[1].is_empty() {\n+            &variant_fields[0]\n+        } else {\n+            return false;\n+        };\n \n-    if fields.len() != 1 {\n-        return false;\n-    }\n+        if fields.len() != 1 {\n+            return false;\n+        }\n \n-    let field_ty = fields[0].ty(tcx, substs);\n-    if !ty_is_known_nonnull(tcx, field_ty) {\n-        return false;\n-    }\n+        let field_ty = fields[0].ty(self.cx.tcx, substs);\n+        if !self.ty_is_known_nonnull(field_ty) {\n+            return false;\n+        }\n \n-    // At this point, the field's type is known to be nonnull and the parent enum is Option-like.\n-    // If the computed size for the field and the enum are different, the nonnull optimization isn't\n-    // being applied (and we've got a problem somewhere).\n-    let compute_size_skeleton = |t| SizeSkeleton::compute(t, tcx, ParamEnv::reveal_all()).unwrap();\n-    if !compute_size_skeleton(ty).same_size(compute_size_skeleton(field_ty)) {\n-        bug!(\"improper_ctypes: Option nonnull optimization not applied?\");\n-    }\n+        // At this point, the field's type is known to be nonnull and the parent enum is\n+        // Option-like. If the computed size for the field and the enum are different, the non-null\n+        // optimization isn't being applied (and we've got a problem somewhere).\n+        let compute_size_skeleton =\n+            |t| SizeSkeleton::compute(t, self.cx.tcx, self.cx.param_env).unwrap();\n+        if !compute_size_skeleton(ty).same_size(compute_size_skeleton(field_ty)) {\n+            bug!(\"improper_ctypes: Option nonnull optimization not applied?\");\n+        }\n \n-    true\n-}\n+        true\n+    }\n \n-impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the type is array and emit an unsafe type lint.\n     fn check_for_array_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n         if let ty::Array(..) = ty.kind {\n@@ -738,7 +742,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         // discriminant.\n                         if !def.repr.c() && !def.repr.transparent() && def.repr.int.is_none() {\n                             // Special-case types like `Option<extern fn()>`.\n-                            if !is_repr_nullable_ptr(cx, ty, def, substs) {\n+                            if !self.is_repr_nullable_ptr(ty, def, substs) {\n                                 return FfiUnsafe {\n                                     ty,\n                                     reason: \"enum has no representation hint\".into(),"}]}