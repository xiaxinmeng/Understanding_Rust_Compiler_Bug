{"sha": "b695ed3f2032d349a5cb9f26a8df67936943c075", "node_id": "C_kwDOAAsO6NoAKGI2OTVlZDNmMjAzMmQzNDlhNWNiOWYyNmE4ZGY2NzkzNjk0M2MwNzU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-11-08T05:53:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-08T05:53:50Z"}, "message": "Rollup merge of #103446 - the8472:tra-array-chunks, r=Mark-Simulacrum\n\nSpecialize `iter::ArrayChunks::fold` for TrustedRandomAccess iterators\n\n```\nOLD:\ntest iter::bench_trusted_random_access_chunks                      ... bench:         368 ns/iter (+/- 4)\nNEW:\ntest iter::bench_trusted_random_access_chunks                      ... bench:          30 ns/iter (+/- 0)\n```\n\nThe resulting assembly is similar to #103166 but the specialization kicks in under different (partially overlapping) conditions compared to that PR. They're complementary.\n\nIn principle a TRA-based specialization could be applied to all `ArrayChunks` methods, including `next()` as we do for `Zip` but that would have all the same hazards as the Zip specialization. Only doing it for `fold` is far less hazardous. The downside is that it only helps with internal, exhaustive iteration. I.e. `for _ in` or `try_fold` will not benefit.\n\nNote that the regular, `try_fold`-based and the specialized `fold()` impl have observably slightly different behavior. Namely the specialized variant does not fetch the remainder elements from the underlying iterator. We do have a few other places in the standard library where beyond-the-end-of-iteration side-effects are being elided under some circumstances but not others.\n\nInspired by https://old.reddit.com/r/rust/comments/yaft60/zerocost_iterator_abstractionsnot_so_zerocost/", "tree": {"sha": "761258b611d0c454802f4b70edbe18aeee4d8119", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/761258b611d0c454802f4b70edbe18aeee4d8119"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b695ed3f2032d349a5cb9f26a8df67936943c075", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjae7uCRBK7hj4Ov3rIwAAHUMIAGJbksv9F4wu0w0NLozkDSg+\nhANwpmYTprRq+z7VkG++2kMKcoetVTziwN0PNeFMIjzgR/SIqEFjXg4ReGi+1GNN\naZQ2hQJypyUlt+B0AWiLFaqzbL8LbHZ7ku3KyrfXZ24/PFzgTnr9+wOqcp0IjgUJ\nMnBLbdIYkvDPPPfVo14YQ7TEz7wFbLA8tgg1wbS0P/eUaozXI7lqX3JM9/q4NtNE\ntuVKOPU+2hXkGmxkTveFhaLfAUL18YWrWU/BSOEnZBEtxwkf5HKsFwpdQ+FVRY/r\ninlmev8Z9dEOgYofdw7tlGBcrk/557npiJ+l87k1uhxNZwhNk1Qwon865D6Wtak=\n=5IRi\n-----END PGP SIGNATURE-----\n", "payload": "tree 761258b611d0c454802f4b70edbe18aeee4d8119\nparent 6184a963f71f934f43fb75ca7effd656b23cd9f8\nparent 3925fc0c8e0b4ad9be48fbc1136281841d8985fa\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1667886830 +0530\ncommitter GitHub <noreply@github.com> 1667886830 +0530\n\nRollup merge of #103446 - the8472:tra-array-chunks, r=Mark-Simulacrum\n\nSpecialize `iter::ArrayChunks::fold` for TrustedRandomAccess iterators\n\n```\nOLD:\ntest iter::bench_trusted_random_access_chunks                      ... bench:         368 ns/iter (+/- 4)\nNEW:\ntest iter::bench_trusted_random_access_chunks                      ... bench:          30 ns/iter (+/- 0)\n```\n\nThe resulting assembly is similar to #103166 but the specialization kicks in under different (partially overlapping) conditions compared to that PR. They're complementary.\n\nIn principle a TRA-based specialization could be applied to all `ArrayChunks` methods, including `next()` as we do for `Zip` but that would have all the same hazards as the Zip specialization. Only doing it for `fold` is far less hazardous. The downside is that it only helps with internal, exhaustive iteration. I.e. `for _ in` or `try_fold` will not benefit.\n\nNote that the regular, `try_fold`-based and the specialized `fold()` impl have observably slightly different behavior. Namely the specialized variant does not fetch the remainder elements from the underlying iterator. We do have a few other places in the standard library where beyond-the-end-of-iteration side-effects are being elided under some circumstances but not others.\n\nInspired by https://old.reddit.com/r/rust/comments/yaft60/zerocost_iterator_abstractionsnot_so_zerocost/\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b695ed3f2032d349a5cb9f26a8df67936943c075", "html_url": "https://github.com/rust-lang/rust/commit/b695ed3f2032d349a5cb9f26a8df67936943c075", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b695ed3f2032d349a5cb9f26a8df67936943c075/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6184a963f71f934f43fb75ca7effd656b23cd9f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6184a963f71f934f43fb75ca7effd656b23cd9f8", "html_url": "https://github.com/rust-lang/rust/commit/6184a963f71f934f43fb75ca7effd656b23cd9f8"}, {"sha": "3925fc0c8e0b4ad9be48fbc1136281841d8985fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/3925fc0c8e0b4ad9be48fbc1136281841d8985fa", "html_url": "https://github.com/rust-lang/rust/commit/3925fc0c8e0b4ad9be48fbc1136281841d8985fa"}], "stats": {"total": 177, "additions": 148, "deletions": 29}, "files": [{"sha": "9193c79bee875daf690d6f3af31e252cee70ff21", "filename": "library/core/benches/iter.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b695ed3f2032d349a5cb9f26a8df67936943c075/library%2Fcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b695ed3f2032d349a5cb9f26a8df67936943c075/library%2Fcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fiter.rs?ref=b695ed3f2032d349a5cb9f26a8df67936943c075", "patch": "@@ -1,3 +1,4 @@\n+use core::borrow::Borrow;\n use core::iter::*;\n use core::mem;\n use core::num::Wrapping;\n@@ -403,13 +404,31 @@ fn bench_trusted_random_access_adapters(b: &mut Bencher) {\n \n /// Exercises the iter::Copied specialization for slice::Iter\n #[bench]\n-fn bench_copied_array_chunks(b: &mut Bencher) {\n+fn bench_copied_chunks(b: &mut Bencher) {\n+    let v = vec![1u8; 1024];\n+\n+    b.iter(|| {\n+        let mut iter = black_box(&v).iter().copied();\n+        let mut acc = Wrapping(0);\n+        // This uses a while-let loop to side-step the TRA specialization in ArrayChunks\n+        while let Ok(chunk) = iter.next_chunk::<{ mem::size_of::<u64>() }>() {\n+            let d = u64::from_ne_bytes(chunk);\n+            acc += Wrapping(d.rotate_left(7).wrapping_add(1));\n+        }\n+        acc\n+    })\n+}\n+\n+/// Exercises the TrustedRandomAccess specialization in ArrayChunks\n+#[bench]\n+fn bench_trusted_random_access_chunks(b: &mut Bencher) {\n     let v = vec![1u8; 1024];\n \n     b.iter(|| {\n         black_box(&v)\n             .iter()\n-            .copied()\n+            // this shows that we're not relying on the slice::Iter specialization in Copied\n+            .map(|b| *b.borrow())\n             .array_chunks::<{ mem::size_of::<u64>() }>()\n             .map(|ary| {\n                 let d = u64::from_ne_bytes(ary);"}, {"sha": "cf5a7cada93ce30b4a5925b7ea9f21b2793b8d78", "filename": "library/core/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b695ed3f2032d349a5cb9f26a8df67936943c075/library%2Fcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b695ed3f2032d349a5cb9f26a8df67936943c075/library%2Fcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Flib.rs?ref=b695ed3f2032d349a5cb9f26a8df67936943c075", "patch": "@@ -5,6 +5,7 @@\n #![feature(test)]\n #![feature(trusted_random_access)]\n #![feature(iter_array_chunks)]\n+#![feature(iter_next_chunk)]\n \n extern crate test;\n "}, {"sha": "2090756d7a3ec82252be10dc39e91d16cdff1234", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 52, "deletions": 23, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b695ed3f2032d349a5cb9f26a8df67936943c075/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b695ed3f2032d349a5cb9f26a8df67936943c075/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=b695ed3f2032d349a5cb9f26a8df67936943c075", "patch": "@@ -865,24 +865,6 @@ where\n         return Ok(Try::from_output(unsafe { mem::zeroed() }));\n     }\n \n-    struct Guard<'a, T, const N: usize> {\n-        array_mut: &'a mut [MaybeUninit<T>; N],\n-        initialized: usize,\n-    }\n-\n-    impl<T, const N: usize> Drop for Guard<'_, T, N> {\n-        fn drop(&mut self) {\n-            debug_assert!(self.initialized <= N);\n-\n-            // SAFETY: this slice will contain only initialized objects.\n-            unsafe {\n-                crate::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(\n-                    &mut self.array_mut.get_unchecked_mut(..self.initialized),\n-                ));\n-            }\n-        }\n-    }\n-\n     let mut array = MaybeUninit::uninit_array::<N>();\n     let mut guard = Guard { array_mut: &mut array, initialized: 0 };\n \n@@ -896,13 +878,11 @@ where\n                     ControlFlow::Continue(elem) => elem,\n                 };\n \n-                // SAFETY: `guard.initialized` starts at 0, is increased by one in the\n-                // loop and the loop is aborted once it reaches N (which is\n-                // `array.len()`).\n+                // SAFETY: `guard.initialized` starts at 0, which means push can be called\n+                // at most N times, which this loop does.\n                 unsafe {\n-                    guard.array_mut.get_unchecked_mut(guard.initialized).write(item);\n+                    guard.push_unchecked(item);\n                 }\n-                guard.initialized += 1;\n             }\n             None => {\n                 let alive = 0..guard.initialized;\n@@ -920,6 +900,55 @@ where\n     Ok(Try::from_output(output))\n }\n \n+/// Panic guard for incremental initialization of arrays.\n+///\n+/// Disarm the guard with `mem::forget` once the array has been initialized.\n+///\n+/// # Safety\n+///\n+/// All write accesses to this structure are unsafe and must maintain a correct\n+/// count of `initialized` elements.\n+///\n+/// To minimize indirection fields are still pub but callers should at least use\n+/// `push_unchecked` to signal that something unsafe is going on.\n+pub(crate) struct Guard<'a, T, const N: usize> {\n+    /// The array to be initialized.\n+    pub array_mut: &'a mut [MaybeUninit<T>; N],\n+    /// The number of items that have been initialized so far.\n+    pub initialized: usize,\n+}\n+\n+impl<T, const N: usize> Guard<'_, T, N> {\n+    /// Adds an item to the array and updates the initialized item counter.\n+    ///\n+    /// # Safety\n+    ///\n+    /// No more than N elements must be initialized.\n+    #[inline]\n+    pub unsafe fn push_unchecked(&mut self, item: T) {\n+        // SAFETY: If `initialized` was correct before and the caller does not\n+        // invoke this method more than N times then writes will be in-bounds\n+        // and slots will not be initialized more than once.\n+        unsafe {\n+            self.array_mut.get_unchecked_mut(self.initialized).write(item);\n+            self.initialized = self.initialized.unchecked_add(1);\n+        }\n+    }\n+}\n+\n+impl<T, const N: usize> Drop for Guard<'_, T, N> {\n+    fn drop(&mut self) {\n+        debug_assert!(self.initialized <= N);\n+\n+        // SAFETY: this slice will contain only initialized objects.\n+        unsafe {\n+            crate::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(\n+                &mut self.array_mut.get_unchecked_mut(..self.initialized),\n+            ));\n+        }\n+    }\n+}\n+\n /// Returns the next chunk of `N` items from the iterator or errors with an\n /// iterator over the remainder. Used for `Iterator::next_chunk`.\n #[inline]"}, {"sha": "5e4211058aa6f2b8bcd0182ef18fc340f54c771d", "filename": "library/core/src/iter/adapters/array_chunks.rs", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b695ed3f2032d349a5cb9f26a8df67936943c075/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b695ed3f2032d349a5cb9f26a8df67936943c075/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs?ref=b695ed3f2032d349a5cb9f26a8df67936943c075", "patch": "@@ -1,6 +1,8 @@\n use crate::array;\n-use crate::iter::{ByRefSized, FusedIterator, Iterator};\n-use crate::ops::{ControlFlow, Try};\n+use crate::const_closure::ConstFnMutClosure;\n+use crate::iter::{ByRefSized, FusedIterator, Iterator, TrustedRandomAccessNoCoerce};\n+use crate::mem::{self, MaybeUninit};\n+use crate::ops::{ControlFlow, NeverShortCircuit, Try};\n \n /// An iterator over `N` elements of the iterator at a time.\n ///\n@@ -82,7 +84,13 @@ where\n         }\n     }\n \n-    impl_fold_via_try_fold! { fold -> try_fold }\n+    fn fold<B, F>(self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        <Self as SpecFold>::fold(self, init, f)\n+    }\n }\n \n #[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n@@ -168,3 +176,64 @@ where\n         self.iter.len() < N\n     }\n }\n+\n+trait SpecFold: Iterator {\n+    fn fold<B, F>(self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B;\n+}\n+\n+impl<I, const N: usize> SpecFold for ArrayChunks<I, N>\n+where\n+    I: Iterator,\n+{\n+    #[inline]\n+    default fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        let fold = ConstFnMutClosure::new(&mut f, NeverShortCircuit::wrap_mut_2_imp);\n+        self.try_fold(init, fold).0\n+    }\n+}\n+\n+impl<I, const N: usize> SpecFold for ArrayChunks<I, N>\n+where\n+    I: Iterator + TrustedRandomAccessNoCoerce,\n+{\n+    #[inline]\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        let mut accum = init;\n+        let inner_len = self.iter.size();\n+        let mut i = 0;\n+        // Use a while loop because (0..len).step_by(N) doesn't optimize well.\n+        while inner_len - i >= N {\n+            let mut chunk = MaybeUninit::uninit_array();\n+            let mut guard = array::Guard { array_mut: &mut chunk, initialized: 0 };\n+            while guard.initialized < N {\n+                // SAFETY: The method consumes the iterator and the loop condition ensures that\n+                // all accesses are in bounds and only happen once.\n+                unsafe {\n+                    let idx = i + guard.initialized;\n+                    guard.push_unchecked(self.iter.__iterator_get_unchecked(idx));\n+                }\n+            }\n+            mem::forget(guard);\n+            // SAFETY: The loop above initialized all elements\n+            let chunk = unsafe { MaybeUninit::array_assume_init(chunk) };\n+            accum = f(accum, chunk);\n+            i += N;\n+        }\n+\n+        // unlike try_fold this method does not need to take care of the remainder\n+        // since `self` will be dropped\n+\n+        accum\n+    }\n+}"}, {"sha": "ef4a7e53bdd339caa6f7b22fbfb37fb16927b201", "filename": "library/core/tests/iter/adapters/array_chunks.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b695ed3f2032d349a5cb9f26a8df67936943c075/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b695ed3f2032d349a5cb9f26a8df67936943c075/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs?ref=b695ed3f2032d349a5cb9f26a8df67936943c075", "patch": "@@ -139,7 +139,8 @@ fn test_iterator_array_chunks_fold() {\n     let result =\n         (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>().fold(0, |acc, _item| acc + 1);\n     assert_eq!(result, 3);\n-    assert_eq!(count.get(), 10);\n+    // fold impls may or may not process the remainder\n+    assert!(count.get() <= 10 && count.get() >= 9);\n }\n \n #[test]"}]}