{"sha": "8110119fef9dbbd5b68e27245e84900b5faf0a3e", "node_id": "C_kwDOAAsO6NoAKDgxMTAxMTlmZWY5ZGJiZDViNjhlMjcyNDVlODQ5MDBiNWZhZjBhM2U", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-09-01T12:54:47Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-09-01T12:54:47Z"}, "message": "Properly handle break resolution inside non-breakable expressions", "tree": {"sha": "ab67b2776345e4205e1bee9907d613491530e75d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab67b2776345e4205e1bee9907d613491530e75d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8110119fef9dbbd5b68e27245e84900b5faf0a3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8110119fef9dbbd5b68e27245e84900b5faf0a3e", "html_url": "https://github.com/rust-lang/rust/commit/8110119fef9dbbd5b68e27245e84900b5faf0a3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8110119fef9dbbd5b68e27245e84900b5faf0a3e/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e66a5a8ce38c0ec96479f234e87d10850264e09", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e66a5a8ce38c0ec96479f234e87d10850264e09", "html_url": "https://github.com/rust-lang/rust/commit/1e66a5a8ce38c0ec96479f234e87d10850264e09"}], "stats": {"total": 180, "additions": 163, "deletions": 17}, "files": [{"sha": "10ffde87eef1491b4c6777db2c19309ff6f36f4e", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8110119fef9dbbd5b68e27245e84900b5faf0a3e/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8110119fef9dbbd5b68e27245e84900b5faf0a3e/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=8110119fef9dbbd5b68e27245e84900b5faf0a3e", "patch": "@@ -424,15 +424,39 @@ struct BreakableContext {\n     coerce: CoerceMany,\n     /// The optional label of the context.\n     label: Option<name::Name>,\n+    kind: BreakableKind,\n+}\n+\n+#[derive(Clone, Debug)]\n+enum BreakableKind {\n+    Block,\n+    Loop,\n+    /// A border is something like an async block, closure etc. Anything that prevents\n+    /// breaking/continuing through\n+    Border,\n }\n \n fn find_breakable<'c>(\n     ctxs: &'c mut [BreakableContext],\n     label: Option<&name::Name>,\n+) -> Option<&'c mut BreakableContext> {\n+    let mut ctxs = ctxs\n+        .iter_mut()\n+        .rev()\n+        .take_while(|it| matches!(it.kind, BreakableKind::Block | BreakableKind::Loop));\n+    match label {\n+        Some(_) => ctxs.find(|ctx| ctx.label.as_ref() == label),\n+        None => ctxs.find(|ctx| matches!(ctx.kind, BreakableKind::Loop)),\n+    }\n+}\n+\n+fn find_continuable<'c>(\n+    ctxs: &'c mut [BreakableContext],\n+    label: Option<&name::Name>,\n ) -> Option<&'c mut BreakableContext> {\n     match label {\n-        Some(_) => ctxs.iter_mut().rev().find(|ctx| ctx.label.as_ref() == label),\n-        None => ctxs.last_mut(),\n+        Some(_) => find_breakable(ctxs, label).filter(|it| matches!(it.kind, BreakableKind::Loop)),\n+        None => find_breakable(ctxs, label),\n     }\n }\n "}, {"sha": "f3f4ee65bb2e18f5e3316765084fa602e9dd7594", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8110119fef9dbbd5b68e27245e84900b5faf0a3e/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8110119fef9dbbd5b68e27245e84900b5faf0a3e/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=8110119fef9dbbd5b68e27245e84900b5faf0a3e", "patch": "@@ -23,7 +23,7 @@ use syntax::ast::RangeOp;\n use crate::{\n     autoderef::{self, Autoderef},\n     consteval,\n-    infer::coerce::CoerceMany,\n+    infer::{coerce::CoerceMany, find_continuable, BreakableKind},\n     lower::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n@@ -120,25 +120,37 @@ impl<'a> InferenceContext<'a> {\n                 let ty = match label {\n                     Some(_) => {\n                         let break_ty = self.table.new_type_var();\n-                        let (breaks, ty) =\n-                            self.with_breakable_ctx(break_ty.clone(), *label, |this| {\n+                        let (breaks, ty) = self.with_breakable_ctx(\n+                            BreakableKind::Block,\n+                            break_ty.clone(),\n+                            *label,\n+                            |this| {\n                                 this.infer_block(\n                                     tgt_expr,\n                                     statements,\n                                     *tail,\n                                     &Expectation::has_type(break_ty),\n                                 )\n-                            });\n+                            },\n+                        );\n                         breaks.unwrap_or(ty)\n                     }\n                     None => self.infer_block(tgt_expr, statements, *tail, expected),\n                 };\n                 self.resolver = old_resolver;\n                 ty\n             }\n-            Expr::Unsafe { body } | Expr::Const { body } => self.infer_expr(*body, expected),\n+            Expr::Unsafe { body } => self.infer_expr(*body, expected),\n+            Expr::Const { body } => {\n+                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                    this.infer_expr(*body, expected)\n+                })\n+                .1\n+            }\n             Expr::TryBlock { body } => {\n-                let _inner = self.infer_expr(*body, expected);\n+                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                    let _inner = this.infer_expr(*body, expected);\n+                });\n                 // FIXME should be std::result::Result<{inner}, _>\n                 self.err_ty()\n             }\n@@ -147,7 +159,10 @@ impl<'a> InferenceContext<'a> {\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n \n-                let inner_ty = self.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n+                let (_, inner_ty) =\n+                    self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                        this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty))\n+                    });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n@@ -161,9 +176,10 @@ impl<'a> InferenceContext<'a> {\n             }\n             &Expr::Loop { body, label } => {\n                 let ty = self.table.new_type_var();\n-                let (breaks, ()) = self.with_breakable_ctx(ty, label, |this| {\n-                    this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n-                });\n+                let (breaks, ()) =\n+                    self.with_breakable_ctx(BreakableKind::Loop, ty, label, |this| {\n+                        this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                    });\n \n                 match breaks {\n                     Some(breaks) => {\n@@ -174,7 +190,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n             &Expr::While { condition, body, label } => {\n-                self.with_breakable_ctx(self.err_ty(), label, |this| {\n+                self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n                     this.infer_expr(\n                         condition,\n                         &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n@@ -192,7 +208,7 @@ impl<'a> InferenceContext<'a> {\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n                 self.infer_pat(pat, &pat_ty, BindingMode::default());\n-                self.with_breakable_ctx(self.err_ty(), label, |this| {\n+                self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n                     this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n                 });\n \n@@ -251,7 +267,9 @@ impl<'a> InferenceContext<'a> {\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n \n-                self.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n+                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                    this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n+                });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n@@ -355,7 +373,7 @@ impl<'a> InferenceContext<'a> {\n                 self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or_else(|| self.err_ty())\n             }\n             Expr::Continue { label } => {\n-                if let None = find_breakable(&mut self.breakables, label.as_ref()) {\n+                if let None = find_continuable(&mut self.breakables, label.as_ref()) {\n                     self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                         expr: tgt_expr,\n                         is_break: false,\n@@ -1466,13 +1484,14 @@ impl<'a> InferenceContext<'a> {\n \n     fn with_breakable_ctx<T>(\n         &mut self,\n+        kind: BreakableKind,\n         ty: Ty,\n         label: Option<LabelId>,\n         cb: impl FnOnce(&mut Self) -> T,\n     ) -> (Option<Ty>, T) {\n         self.breakables.push({\n             let label = label.map(|label| self.body[label].name.clone());\n-            BreakableContext { may_break: false, coerce: CoerceMany::new(ty), label }\n+            BreakableContext { kind, may_break: false, coerce: CoerceMany::new(ty), label }\n         });\n         let res = cb(self);\n         let ctx = self.breakables.pop().expect(\"breakable stack broken\");"}, {"sha": "0c92e706b3916f65c73df4b6e3945b4e6501a052", "filename": "crates/ide-diagnostics/src/handlers/break_outside_of_loop.rs", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/8110119fef9dbbd5b68e27245e84900b5faf0a3e/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8110119fef9dbbd5b68e27245e84900b5faf0a3e/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs?ref=8110119fef9dbbd5b68e27245e84900b5faf0a3e", "patch": "@@ -33,6 +33,109 @@ fn foo() {\n     continue 'a;\n   //^^^^^^^^^^^ error: continue outside of loop\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_blocks_are_borders() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        try {\n+                break;\n+              //^^^^^ error: break outside of loop\n+                break 'a;\n+              //^^^^^^^^ error: break outside of loop\n+                continue;\n+              //^^^^^^^^ error: continue outside of loop\n+                continue 'a;\n+              //^^^^^^^^^^^ error: continue outside of loop\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn async_blocks_are_borders() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        try {\n+                break;\n+              //^^^^^ error: break outside of loop\n+                break 'a;\n+              //^^^^^^^^ error: break outside of loop\n+                continue;\n+              //^^^^^^^^ error: continue outside of loop\n+                continue 'a;\n+              //^^^^^^^^^^^ error: continue outside of loop\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn closures_are_borders() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        try {\n+                break;\n+              //^^^^^ error: break outside of loop\n+                break 'a;\n+              //^^^^^^^^ error: break outside of loop\n+                continue;\n+              //^^^^^^^^ error: continue outside of loop\n+                continue 'a;\n+              //^^^^^^^^^^^ error: continue outside of loop\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn blocks_pass_through() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        {\n+            break;\n+            break 'a;\n+            continue;\n+            continue 'a;\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn label_blocks() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: {\n+        break;\n+      //^^^^^ error: break outside of loop\n+        break 'a;\n+        continue;\n+      //^^^^^^^^ error: continue outside of loop\n+        continue 'a;\n+      //^^^^^^^^^^^ error: continue outside of loop\n+    }\n+}\n \"#,\n         );\n     }"}]}