{"sha": "eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNDE5ZmQ4Yzc4ZjkwN2YxYTVjZDIwZjVlNzEwMDliYTM3ZWY3ZTk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-13T13:17:24Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-13T15:20:39Z"}, "message": "Extend crate format to allow multiple definitions for a single name\n\nThe type/value namespace distinction pretty much works now. Module\nnamespace is up next.", "tree": {"sha": "924709adb23c244bb06f23bde47dff88b48eb20e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/924709adb23c244bb06f23bde47dff88b48eb20e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9", "html_url": "https://github.com/rust-lang/rust/commit/eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a12a7b04b5c279b897dda998e946085883d9cf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a12a7b04b5c279b897dda998e946085883d9cf9", "html_url": "https://github.com/rust-lang/rust/commit/1a12a7b04b5c279b897dda998e946085883d9cf9"}], "stats": {"total": 198, "additions": 85, "deletions": 113}, "files": [{"sha": "023ede508659b4f301a66995cc425b721d8c559c", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 51, "deletions": 82, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9", "patch": "@@ -34,11 +34,6 @@ type env = @rec(\n     mutable int next_crate_num\n );\n \n-tag resolve_result {\n-    rr_ok(ast::def_id);\n-    rr_not_found(ast::ident);\n-}\n-\n // Type decoding\n \n // Compact string representation for ty::t values. API ty_str & parse_from_str\n@@ -282,64 +277,58 @@ fn parse_def_id(vec[u8] buf) -> ast::def_id {\n }\n \n fn lookup_hash(&ebml::doc d, fn(vec[u8]) -> bool eq_fn, uint hash)\n-    -> option::t[ebml::doc] {\n+    -> vec[ebml::doc] {\n     auto index = ebml::get_doc(d, metadata::tag_index);\n     auto table = ebml::get_doc(index, metadata::tag_index_table);\n \n     auto hash_pos = table.start + (hash % 256u) * 4u;\n     auto pos = ebml::be_uint_from_bytes(d.data, hash_pos, 4u);\n     auto bucket = ebml::doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n-    auto result = option::none[ebml::doc];\n+    let vec[ebml::doc] result = vec();\n     auto belt = metadata::tag_index_buckets_bucket_elt;\n     for each (ebml::doc elt in ebml::tagged_docs(bucket, belt)) {\n-        alt (result) {\n-            case (option::none[ebml::doc]) {\n-                auto pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n-                if (eq_fn(_vec::slice[u8](elt.data, elt.start+4u, elt.end))) {\n-                    result = option::some[ebml::doc]\n-                        (ebml::doc_at(d.data, pos));\n-                }\n-            }\n-            case (_) {}\n+        auto pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n+        if (eq_fn(_vec::slice[u8](elt.data, elt.start+4u, elt.end))) {\n+            _vec::push(result, ebml::doc_at(d.data, pos));\n         }\n     }\n     ret result;\n }\n \n // Given a path and serialized crate metadata, returns the ID of the\n // definition the path refers to.\n-fn resolve_path(vec[ast::ident] path, vec[u8] data) -> resolve_result {\n+fn resolve_path(vec[ast::ident] path, vec[u8] data) -> vec[ast::def_id] {\n     fn eq_item(vec[u8] data, str s) -> bool {\n         ret _str::eq(_str::unsafe_from_bytes(data), s);\n     }\n     auto s = _str::connect(path, \"::\");\n     auto md = ebml::new_doc(data);\n     auto paths = ebml::get_doc(md, metadata::tag_paths);\n     auto eqer = bind eq_item(_, s);\n-    alt (lookup_hash(paths, eqer, metadata::hash_path(s))) {\n-        case (option::some[ebml::doc](?d)) {\n-            auto did_doc = ebml::get_doc(d, metadata::tag_def_id);\n-            ret rr_ok(parse_def_id(ebml::doc_data(did_doc)));\n-        }\n-        case (option::none[ebml::doc]) {\n-            ret rr_not_found(s);\n-        }\n+    let vec[ast::def_id] result = vec();\n+    for (ebml::doc doc in lookup_hash(paths, eqer, metadata::hash_path(s))) {\n+        auto did_doc = ebml::get_doc(doc, metadata::tag_def_id);\n+        _vec::push(result, parse_def_id(ebml::doc_data(did_doc)));\n     }\n+    ret result;\n }\n \n fn maybe_find_item(int item_id, &ebml::doc items) -> option::t[ebml::doc] {\n     fn eq_item(vec[u8] bytes, int item_id) -> bool {\n         ret ebml::be_uint_from_bytes(bytes, 0u, 4u) as int == item_id;\n     }\n     auto eqer = bind eq_item(_, item_id);\n-    ret lookup_hash(items, eqer, metadata::hash_def_num(item_id));\n+    auto found = lookup_hash(items, eqer, metadata::hash_def_num(item_id));\n+    if (_vec::len(found) == 0u) {\n+        ret option::none[ebml::doc];\n+    } else {\n+        ret option::some[ebml::doc](found.(0));\n+    }\n }\n \n fn find_item(int item_id, &ebml::doc items) -> ebml::doc {\n-    alt (maybe_find_item(item_id, items)) {\n-        case (option::some[ebml::doc](?d)) {ret d;}\n-    }\n+    ret option::get(maybe_find_item(item_id, items));\n }\n \n // Looks up an item in the given metadata and returns an ebml doc pointing\n@@ -478,67 +467,49 @@ fn read_crates(session::session sess,\n \n \n fn kind_has_type_params(u8 kind_ch) -> bool {\n-    // FIXME: It'd be great if we had u8 char literals.\n-    if (kind_ch == ('c' as u8))      { ret false; }\n-    else if (kind_ch == ('f' as u8)) { ret true;  }\n-    else if (kind_ch == ('F' as u8)) { ret true;  }\n-    else if (kind_ch == ('y' as u8)) { ret true;  }\n-    else if (kind_ch == ('o' as u8)) { ret true;  }\n-    else if (kind_ch == ('t' as u8)) { ret true;  }\n-    else if (kind_ch == ('T' as u8)) { ret false;  }\n-    else if (kind_ch == ('m' as u8)) { ret false; }\n-    else if (kind_ch == ('n' as u8)) { ret false; }\n-    else if (kind_ch == ('v' as u8)) { ret true;  }\n-    else {\n-        log_err #fmt(\"kind_has_type_params(): unknown kind char: %d\",\n-                     kind_ch as int);\n-        fail;\n-    }\n+    ret alt (kind_ch as char) {\n+        case ('c') { false } case ('f') { true  } case ('F') { true  }\n+        case ('y') { true  } case ('o') { true  } case ('t') { true  }\n+        case ('T') { false } case ('m') { false } case ('n') { false }\n+        case ('v') { true  }\n+    };\n }\n \n-\n // Crate metadata queries\n \n-fn lookup_def(session::session sess, int cnum, vec[ast::ident] path)\n-        -> option::t[ast::def] {\n+fn lookup_defs(session::session sess, int cnum, vec[ast::ident] path)\n+    -> vec[ast::def] {\n     auto data = sess.get_external_crate(cnum).data;\n \n-    auto did;\n-    alt (resolve_path(path, data)) {\n-        case (rr_ok(?di)) { did = di; }\n-        case (rr_not_found(?name)) {\n-            ret none[ast::def];\n-        }\n-    }\n+    ret _vec::map(bind lookup_def(cnum, data, _),\n+                  resolve_path(path, data));\n+}\n \n+// FIXME doesn't yet handle re-exported externals\n+fn lookup_def(int cnum, vec[u8] data, &ast::def_id did) -> ast::def {\n     auto item = lookup_item(did._1, data);\n     auto kind_ch = item_kind(item);\n \n     did = tup(cnum, did._1);\n \n-    // FIXME: It'd be great if we had u8 char literals.\n-    auto def;\n-    if (kind_ch == ('c' as u8))         { def = ast::def_const(did);      }\n-    else if (kind_ch == ('f' as u8))    { def = ast::def_fn(did);         }\n-    else if (kind_ch == ('F' as u8))    { def = ast::def_native_fn(did);  }\n-    else if (kind_ch == ('y' as u8))    { def = ast::def_ty(did);         }\n-    else if (kind_ch == ('o' as u8))    { def = ast::def_obj(did);        }\n-    else if (kind_ch == ('T' as u8))    { def = ast::def_native_ty(did);  }\n-    else if (kind_ch == ('t' as u8)) {\n+    auto def = alt (kind_ch as char) {\n+        case ('c') { ast::def_const(did) }\n+        case ('f') { ast::def_fn(did) }\n+        case ('F') { ast::def_native_fn(did) }\n+        case ('y') { ast::def_ty(did) }\n+        case ('o') { ast::def_obj(did) }\n+        case ('T') { ast::def_native_ty(did) }\n         // We treat references to tags as references to types.\n-        def = ast::def_ty(did);\n-    } else if (kind_ch == ('m' as u8))  { def = ast::def_mod(did);        }\n-    else if (kind_ch == ('n' as u8))    { def = ast::def_native_mod(did); }\n-    else if (kind_ch == ('v' as u8)) {\n-        auto tid = variant_tag_id(item);\n-        tid = tup(cnum, tid._1);\n-        def = ast::def_variant(tid, did);\n-    } else {\n-        log_err #fmt(\"lookup_def(): unknown kind char: %d\", kind_ch as int);\n-        fail;\n-    }\n-\n-    ret some[ast::def](def);\n+        case ('t') { ast::def_ty(did) }\n+        case ('m') { ast::def_mod(did) }\n+        case ('n') { ast::def_native_mod(did) }\n+        case ('v') {\n+            auto tid = variant_tag_id(item);\n+            tid = tup(cnum, tid._1);\n+            ast::def_variant(tid, did)\n+        }\n+    };\n+    ret def;\n }\n \n fn get_type(session::session sess, ty::ctxt tcx, ast::def_id def)\n@@ -563,8 +534,7 @@ fn get_type(session::session sess, ty::ctxt tcx, ast::def_id def)\n fn get_symbol(session::session sess, ast::def_id def) -> str {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id).data;\n-    auto item = lookup_item(def._1, data);\n-    ret item_symbol(item);\n+    ret item_symbol(lookup_item(def._1, data));\n }\n \n fn get_tag_variants(session::session sess, ty::ctxt tcx, ast::def_id def)\n@@ -636,9 +606,8 @@ fn list_crate_metadata(vec[u8] bytes, io::writer out) {\n }\n \n fn describe_def(&ebml::doc items, ast::def_id id) -> str {\n-    if (id._0 != 0) {ret \"external\";}\n-    auto item = find_item(id._1, items);\n-    ret item_kind_to_str(item_kind(item));\n+    if (id._0 != 0) { ret \"external\"; }\n+    ret item_kind_to_str(item_kind(find_item(id._1, items)));\n }\n \n fn item_kind_to_str(u8 kind) -> str {"}, {"sha": "b307842412da4967f9be54a2b6630d1233bf9f4f", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9", "patch": "@@ -37,7 +37,6 @@ const uint tag_items_data_item_type = 0x0cu;\n const uint tag_items_data_item_symbol = 0x0du;\n const uint tag_items_data_item_variant = 0x0eu;\n const uint tag_items_data_item_tag_id = 0x0fu;\n-const uint tag_items_data_item_obj_type_id = 0x10u;\n \n const uint tag_index = 0x11u;\n const uint tag_index_buckets = 0x12u;\n@@ -165,7 +164,7 @@ mod Encode {\n             }\n             case (ty::ty_char) {w.write_char('c');}\n             case (ty::ty_str) {w.write_char('s');}\n-            case (ty::ty_tag(?def,?tys)) { // TODO restore def_id\n+            case (ty::ty_tag(?def,?tys)) {\n                 w.write_str(\"t[\");\n                 w.write_str(cx.ds(def));\n                 w.write_char('|');\n@@ -387,7 +386,12 @@ fn encode_module_item_paths(&ebml::writer ebml_w,\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n                 encode_def_id(ebml_w, odid.ctor);\n-                encode_obj_type_id(ebml_w, odid.ty);\n+                ebml::end_tag(ebml_w);\n+\n+                add_to_index(ebml_w, path, index, id);\n+                ebml::start_tag(ebml_w, tag_paths_data_item);\n+                encode_name(ebml_w, id);\n+                encode_def_id(ebml_w, odid.ty);\n                 ebml::end_tag(ebml_w);\n             }\n         }\n@@ -459,11 +463,6 @@ fn encode_tag_id(&ebml::writer ebml_w, &ast::def_id id) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_obj_type_id(&ebml::writer ebml_w, &ast::def_id id) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_obj_type_id);\n-    ebml_w.writer.write(_str::bytes(def_to_str(id)));\n-    ebml::end_tag(ebml_w);\n-}\n \n \n fn encode_tag_variant_info(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n@@ -550,6 +549,7 @@ fn encode_info_for_item(@trans::crate_ctxt cx, &ebml::writer ebml_w,\n             encode_symbol(cx, ebml_w, odid.ctor);\n             ebml::end_tag(ebml_w);\n \n+            index += vec(tup(odid.ty._1, ebml_w.writer.tell()));\n             ebml::start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, odid.ty);\n             encode_kind(ebml_w, 'y' as u8);"}, {"sha": "ad1a5fe926a379863d4116918429cf42981e106e", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9", "patch": "@@ -47,16 +47,22 @@ tag import_state {\n     resolved(option::t[def] /* value */, option::t[def] /* type */);\n }\n \n-type ext_hash = hashmap[tup(def_id,str),def];\n+type ext_hash = hashmap[tup(def_id,str,namespace),def];\n fn new_ext_hash() -> ext_hash {\n-    fn hash(&tup(def_id,str) v) -> uint {\n-        ret _str::hash(v._1) + util::common::hash_def(v._0);\n-    }\n-    fn eq(&tup(def_id,str) v1, &tup(def_id,str) v2) -> bool {\n+    fn hash(&tup(def_id,str,namespace) v) -> uint {\n+        ret _str::hash(v._1) + util::common::hash_def(v._0) + (alt (v._2) {\n+            case (ns_value) { 1u }\n+            case (ns_type) { 2u }\n+            case (ns_module) { 3u }\n+        });\n+    }\n+    fn eq(&tup(def_id,str,namespace) v1,\n+          &tup(def_id,str,namespace) v2) -> bool {\n         ret util::common::def_eq(v1._0, v2._0) &&\n-            _str::eq(v1._1, v2._1);\n+            _str::eq(v1._1, v2._1) &&\n+            v1._2 == v2._2;\n     }\n-    ret std::map::mk_hashmap[tup(def_id,str),def](hash, eq);\n+    ret std::map::mk_hashmap[tup(def_id,str,namespace),def](hash, eq);\n }\n \n tag mod_index_entry {\n@@ -509,7 +515,7 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n             }\n             case (cons[scope](?hd, ?tl)) {\n                 auto fnd = in_scope(e, id, hd, ns);\n-                if (fnd != none[def]) {\n+                if (!option::is_none(fnd)) {\n                     auto df = option::get(fnd);\n                     if ((left_fn && def_is_local(df)) ||\n                         (left_fn_level2 && def_is_obj_field(df))) {\n@@ -550,7 +556,7 @@ fn lookup_in_pat(&ident id, &ast::pat pat) -> option::t[def] {\n         case (ast::pat_tag(_, ?pats, _)) {\n             for (@ast::pat p in pats) {\n                 auto found = lookup_in_pat(id, *p);\n-                if (found != none[def]) { ret found; }\n+                if (!option::is_none(found)) { ret found; }\n             }\n         }\n     }\n@@ -617,7 +623,7 @@ fn lookup_in_block(&ident id, &ast::block_ b, namespace ns)\n                             case (_) {\n                                 if (_str::eq(ast::item_ident(it), id)) {\n                                     auto found = found_def_item(it, ns);\n-                                    if (found != none[def]) { ret found; }\n+                                    if (!option::is_none(found)) { ret found; }\n                                 }\n                             }\n                         }\n@@ -676,17 +682,15 @@ fn lookup_in_mod(&env e, def m, &ident id, namespace ns, dir dr)\n     -> option::t[def] {\n     auto defid = ast::def_id_of_def(m);\n     if (defid._0 != ast::local_crate) { // Not in this crate\n-        auto cached = e.ext_cache.find(tup(defid,id));\n-        if (cached != none[def] && check_def_by_ns(option::get(cached), ns)) {\n-            ret cached;\n-        }\n+        auto cached = e.ext_cache.find(tup(defid,id,ns));\n+        if (!option::is_none(cached)) { ret cached; }\n         auto path = vec(id);\n         if (defid._1 != -1) {\n             path = e.ext_map.get(defid) + path;\n         }\n         auto fnd = lookup_external(e, defid._0, path, ns);\n-        if (fnd != none[def]) {\n-            e.ext_cache.insert(tup(defid,id), option::get(fnd));\n+        if (!option::is_none(fnd)) {\n+            e.ext_cache.insert(tup(defid,id,ns), option::get(fnd));\n         }\n         ret fnd;\n     }\n@@ -728,8 +732,8 @@ fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n     }\n }\n \n-fn lookup_in_regular_mod(&env e, def_id defid, &ident id, namespace ns, dir dr)\n-    -> option::t[def] {\n+fn lookup_in_regular_mod(&env e, def_id defid, &ident id, namespace ns,\n+                         dir dr) -> option::t[def] {\n     auto info = e.mod_map.get(defid._1);\n     auto found = info.index.find(id);\n     if (option::is_none(found) || \n@@ -935,13 +939,11 @@ fn check_def_by_ns(def d, namespace ns) -> bool {\n \n fn lookup_external(&env e, int cnum, vec[ident] ids, namespace ns)\n     -> option::t[def] {\n-    auto found = creader::lookup_def(e.sess, cnum, ids);\n-    if (found != none[def]) {\n-        auto d = option::get(found);\n-        if (!check_def_by_ns(d, ns)) { ret none[def]; }\n+    for (def d in creader::lookup_defs(e.sess, cnum, ids)) {\n         e.ext_map.insert(ast::def_id_of_def(d), ids);\n+        if (check_def_by_ns(d, ns)) { ret some(d); }\n     }\n-    ret found;\n+    ret none[def];\n }\n \n // Local Variables:"}, {"sha": "ccbbeed07b1c35c0e4a3d3d0ab461987ef60c148", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=eb419fd8c78f907f1a5cd20f5e71009ba37ef7e9", "patch": "@@ -1929,6 +1929,7 @@ mod Unify {\n             } else if (actual_input.mode == mo_either) {\n                 result_mode = expected_input.mode;\n             } else if (expected_input.mode != actual_input.mode) {\n+                // FIXME this is the wrong error\n                 ret fn_common_res_err(ures_err(terr_arg_count,\n                                                expected, actual));\n             } else {"}]}