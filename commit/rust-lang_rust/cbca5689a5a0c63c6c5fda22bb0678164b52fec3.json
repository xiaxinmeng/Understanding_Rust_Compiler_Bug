{"sha": "cbca5689a5a0c63c6c5fda22bb0678164b52fec3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiY2E1Njg5YTVhMGM2M2M2YzVmZGEyMmJiMDY3ODE2NGI1MmZlYzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-03T05:45:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-03T05:45:50Z"}, "message": "Auto merge of #76345 - okready:sgx-mem-range-overflow-checks, r=joshtriplett\n\nAdd is_enclave_range/is_user_range overflow checks\n\nFixes #76343.\n\nThis adds overflow checking to `is_enclave_range` and `is_user_range` in `sgx::os::fortanix_sgx::mem` in order to mitigate possible security issues with enclave code. It also accounts for an edge case where the memory range provided ends exactly at the end of the address space, where calculating `p + len` would overflow back to zero despite the range potentially being valid.", "tree": {"sha": "fe4110e6d7b108a21fe434e976db4cc3a298baaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe4110e6d7b108a21fe434e976db4cc3a298baaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbca5689a5a0c63c6c5fda22bb0678164b52fec3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbca5689a5a0c63c6c5fda22bb0678164b52fec3", "html_url": "https://github.com/rust-lang/rust/commit/cbca5689a5a0c63c6c5fda22bb0678164b52fec3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbca5689a5a0c63c6c5fda22bb0678164b52fec3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35dbef235048f9a2939dc20effe083ca483c37ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/35dbef235048f9a2939dc20effe083ca483c37ff", "html_url": "https://github.com/rust-lang/rust/commit/35dbef235048f9a2939dc20effe083ca483c37ff"}, {"sha": "c989de52b8ad76439f6178170d94ead64ee3ffc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c989de52b8ad76439f6178170d94ead64ee3ffc7", "html_url": "https://github.com/rust-lang/rust/commit/c989de52b8ad76439f6178170d94ead64ee3ffc7"}], "stats": {"total": 42, "additions": 34, "deletions": 8}, "files": [{"sha": "3753fdd353617d8f92dec3f52d10b76c9a821ace", "filename": "library/std/src/sys/sgx/abi/mem.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cbca5689a5a0c63c6c5fda22bb0678164b52fec3/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbca5689a5a0c63c6c5fda22bb0678164b52fec3/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fmem.rs?ref=cbca5689a5a0c63c6c5fda22bb0678164b52fec3", "patch": "@@ -47,20 +47,46 @@ pub fn image_base() -> u64 {\n \n /// Returns `true` if the specified memory range is in the enclave.\n ///\n-/// `p + len` must not overflow.\n+/// For safety, this function also checks whether the range given overflows,\n+/// returning `false` if so.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn is_enclave_range(p: *const u8, len: usize) -> bool {\n-    let start = p as u64;\n-    let end = start + (len as u64);\n-    start >= image_base() && end <= image_base() + (unsafe { ENCLAVE_SIZE } as u64) // unsafe ok: link-time constant\n+    let start = p as usize;\n+\n+    // Subtract one from `len` when calculating `end` in case `p + len` is\n+    // exactly at the end of addressable memory (`p + len` would overflow, but\n+    // the range is still valid).\n+    let end = if len == 0 {\n+        start\n+    } else if let Some(end) = start.checked_add(len - 1) {\n+        end\n+    } else {\n+        return false;\n+    };\n+\n+    let base = image_base() as usize;\n+    start >= base && end <= base + (unsafe { ENCLAVE_SIZE } - 1) // unsafe ok: link-time constant\n }\n \n /// Returns `true` if the specified memory range is in userspace.\n ///\n-/// `p + len` must not overflow.\n+/// For safety, this function also checks whether the range given overflows,\n+/// returning `false` if so.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn is_user_range(p: *const u8, len: usize) -> bool {\n-    let start = p as u64;\n-    let end = start + (len as u64);\n-    end <= image_base() || start >= image_base() + (unsafe { ENCLAVE_SIZE } as u64) // unsafe ok: link-time constant\n+    let start = p as usize;\n+\n+    // Subtract one from `len` when calculating `end` in case `p + len` is\n+    // exactly at the end of addressable memory (`p + len` would overflow, but\n+    // the range is still valid).\n+    let end = if len == 0 {\n+        start\n+    } else if let Some(end) = start.checked_add(len - 1) {\n+        end\n+    } else {\n+        return false;\n+    };\n+\n+    let base = image_base() as usize;\n+    end < base || start > base + (unsafe { ENCLAVE_SIZE } - 1) // unsafe ok: link-time constant\n }"}]}