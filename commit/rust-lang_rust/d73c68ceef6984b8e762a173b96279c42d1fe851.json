{"sha": "d73c68ceef6984b8e762a173b96279c42d1fe851", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3M2M2OGNlZWY2OTg0YjhlNzYyYTE3M2I5NjI3OWM0MmQxZmU4NTE=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-10-26T22:23:38Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-11-02T22:05:56Z"}, "message": "leb128-encode integers before hashing them in IchHasher.\n\nThis significantly reduces the number of bytes hashed by IchHasher.", "tree": {"sha": "4fa840d207a389c4439c65ddf9997c64a74446d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fa840d207a389c4439c65ddf9997c64a74446d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d73c68ceef6984b8e762a173b96279c42d1fe851", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d73c68ceef6984b8e762a173b96279c42d1fe851", "html_url": "https://github.com/rust-lang/rust/commit/d73c68ceef6984b8e762a173b96279c42d1fe851", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d73c68ceef6984b8e762a173b96279c42d1fe851/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af0b27e01fc23ddeb43d6e48aa810294e526e334", "url": "https://api.github.com/repos/rust-lang/rust/commits/af0b27e01fc23ddeb43d6e48aa810294e526e334", "html_url": "https://github.com/rust-lang/rust/commit/af0b27e01fc23ddeb43d6e48aa810294e526e334"}], "stats": {"total": 38, "additions": 37, "deletions": 1}, "files": [{"sha": "d7d9c231a91f48ea772b72585da7cd23dcfd316b", "filename": "src/librustc_incremental/calculate_svh/hasher.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d73c68ceef6984b8e762a173b96279c42d1fe851/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73c68ceef6984b8e762a173b96279c42d1fe851/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs?ref=d73c68ceef6984b8e762a173b96279c42d1fe851", "patch": "@@ -9,13 +9,16 @@\n // except according to those terms.\n \n use std::mem;\n+use std::hash::Hasher;\n use rustc_data_structures::blake2b::Blake2bHasher;\n use rustc::ty::util::ArchIndependentHasher;\n use ich::Fingerprint;\n+use rustc_serialize::leb128::write_unsigned_leb128;\n \n #[derive(Debug)]\n pub struct IchHasher {\n     state: ArchIndependentHasher<Blake2bHasher>,\n+    leb128_helper: Vec<u8>,\n     bytes_hashed: u64,\n }\n \n@@ -24,6 +27,7 @@ impl IchHasher {\n         let hash_size = mem::size_of::<Fingerprint>();\n         IchHasher {\n             state: ArchIndependentHasher::new(Blake2bHasher::new(hash_size, &[])),\n+            leb128_helper: vec![],\n             bytes_hashed: 0\n         }\n     }\n@@ -37,9 +41,19 @@ impl IchHasher {\n         fingerprint.0.copy_from_slice(self.state.into_inner().finalize());\n         fingerprint\n     }\n+\n+    #[inline]\n+    fn write_uleb128(&mut self, value: u64) {\n+        let len = write_unsigned_leb128(&mut self.leb128_helper, 0, value);\n+        self.state.write(&self.leb128_helper[0..len]);\n+        self.bytes_hashed += len as u64;\n+    }\n }\n \n-impl ::std::hash::Hasher for IchHasher {\n+// For the non-u8 integer cases we leb128 encode them first. Because small\n+// integers dominate, this significantly and cheaply reduces the number of\n+// bytes hashed, which is good because blake2b is expensive.\n+impl Hasher for IchHasher {\n     fn finish(&self) -> u64 {\n         bug!(\"Use other finish() implementation to get the full 128-bit hash.\");\n     }\n@@ -49,4 +63,26 @@ impl ::std::hash::Hasher for IchHasher {\n         self.state.write(bytes);\n         self.bytes_hashed += bytes.len() as u64;\n     }\n+\n+    // There is no need to leb128-encode u8 values.\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.write_uleb128(i as u64);\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.write_uleb128(i as u64);\n+    }\n+\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.write_uleb128(i);\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        self.write_uleb128(i as u64);\n+    }\n }"}]}