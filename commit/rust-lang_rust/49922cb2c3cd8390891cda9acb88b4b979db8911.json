{"sha": "49922cb2c3cd8390891cda9acb88b4b979db8911", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5OTIyY2IyYzNjZDgzOTA4OTFjZGE5YWNiODhiNGI5NzlkYjg5MTE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-19T19:07:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-19T19:07:05Z"}, "message": "Merge #8885 #8887\n\n8885: internal: greatly simplify eager macro representation r=jonas-schievink a=jonas-schievink\n\n- Share structures with lazy macros, make both use `MacroCallLoc`.\r\n- Remove `intern_eager_expansion`, `EagerCallLoc`, `EagerMacroId`, and *many* matches on `MacroCallId`.\r\n- Make a lot of FIXMEs obsolete since the code no longer distinguishes between eager and lazy macros.\r\n- Add `EagerCallInfo`, which is `Some` for calls to eager macros and holds the argument or expansion result and the included file.\n\n8887: fix: fix derive collection after unresolved attribute fallback r=jonas-schievink a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/pull/8882#issuecomment-844379170\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "c7aae61f580601b307541d05f4f7ea17db788def", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7aae61f580601b307541d05f4f7ea17db788def"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49922cb2c3cd8390891cda9acb88b4b979db8911", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgpWHZCRBK7hj4Ov3rIwAAazkIAHPpYOO5rhMZL3+mpDfb14BV\n5g1PyDfiwhemE7Lsvvt/rCiOz+k7AaxrwErwVTU6/O91rgB/17Ybe3oJHt5sDSUN\nDdfUTtS1iUsS06DCudcwHwVF3X8CFMExWtTKtcNTSy5gK7c9Mu56J3Rt81PgT1Rv\nNXTuvBMykiXI3nyR1sBYG+zkz2OjoBy81S7se9dQbHDHdIGLwARXUar1a6mCi+kl\n3C89nB15J53kI/u0QQ9VpXSRgGj+NOUofdQl7uWRBoF0AhvgRTvHqccTard64hg/\nwV33hYmqSxUkToCg3BqiGWcVcyAtUhhwhN5ZOadj/HBtif7PvGhukKlxlKOxUDg=\n=lRET\n-----END PGP SIGNATURE-----\n", "payload": "tree c7aae61f580601b307541d05f4f7ea17db788def\nparent 2d76b176c0b0f86648a038a5e4ca84fb04e809dc\nparent c0d93bc4d60d71fb6fec6e6c7305401f96ac18e8\nparent 274d813cff34576d3fe9d343e73669385214d3c3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1621451225 +0000\ncommitter GitHub <noreply@github.com> 1621451225 +0000\n\nMerge #8885 #8887\n\n8885: internal: greatly simplify eager macro representation r=jonas-schievink a=jonas-schievink\n\n- Share structures with lazy macros, make both use `MacroCallLoc`.\r\n- Remove `intern_eager_expansion`, `EagerCallLoc`, `EagerMacroId`, and *many* matches on `MacroCallId`.\r\n- Make a lot of FIXMEs obsolete since the code no longer distinguishes between eager and lazy macros.\r\n- Add `EagerCallInfo`, which is `Some` for calls to eager macros and holds the argument or expansion result and the included file.\n\n8887: fix: fix derive collection after unresolved attribute fallback r=jonas-schievink a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/pull/8882#issuecomment-844379170\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49922cb2c3cd8390891cda9acb88b4b979db8911", "html_url": "https://github.com/rust-lang/rust/commit/49922cb2c3cd8390891cda9acb88b4b979db8911", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49922cb2c3cd8390891cda9acb88b4b979db8911/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d76b176c0b0f86648a038a5e4ca84fb04e809dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d76b176c0b0f86648a038a5e4ca84fb04e809dc", "html_url": "https://github.com/rust-lang/rust/commit/2d76b176c0b0f86648a038a5e4ca84fb04e809dc"}, {"sha": "c0d93bc4d60d71fb6fec6e6c7305401f96ac18e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0d93bc4d60d71fb6fec6e6c7305401f96ac18e8", "html_url": "https://github.com/rust-lang/rust/commit/c0d93bc4d60d71fb6fec6e6c7305401f96ac18e8"}, {"sha": "274d813cff34576d3fe9d343e73669385214d3c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/274d813cff34576d3fe9d343e73669385214d3c3", "html_url": "https://github.com/rust-lang/rust/commit/274d813cff34576d3fe9d343e73669385214d3c3"}], "stats": {"total": 474, "additions": 193, "deletions": 281}, "files": [{"sha": "ffc8155b945b39dc1eadf55b478339d333c66c90", "filename": "crates/hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdb.rs?ref=49922cb2c3cd8390891cda9acb88b4b979db8911", "patch": "@@ -2,8 +2,8 @@\n \n pub use hir_def::db::*;\n pub use hir_expand::db::{\n-    AstDatabase, AstDatabaseStorage, AstIdMapQuery, HygieneFrameQuery, InternEagerExpansionQuery,\n-    InternMacroQuery, MacroArgTextQuery, MacroDefQuery, MacroExpandQuery, ParseMacroExpansionQuery,\n+    AstDatabase, AstDatabaseStorage, AstIdMapQuery, HygieneFrameQuery, InternMacroQuery,\n+    MacroArgTextQuery, MacroDefQuery, MacroExpandQuery, ParseMacroExpansionQuery,\n };\n pub use hir_ty::db::*;\n "}, {"sha": "be645a25d089357270495ecd2bfd270c774ef903", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=49922cb2c3cd8390891cda9acb88b4b979db8911", "patch": "@@ -367,6 +367,8 @@ impl DefCollector<'_> {\n     /// This improves UX when proc macros are turned off or don't work, and replicates the behavior\n     /// before we supported proc. attribute macros.\n     fn reseed_with_unresolved_attributes(&mut self) -> ReachedFixedPoint {\n+        cov_mark::hit!(unresolved_attribute_fallback);\n+\n         let mut added_items = false;\n         let unexpanded_macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n         for directive in &unexpanded_macros {\n@@ -391,7 +393,9 @@ impl DefCollector<'_> {\n                 added_items = true;\n             }\n         }\n-        self.unexpanded_macros = unexpanded_macros;\n+\n+        // The collection above might add new unresolved macros (eg. derives), so merge the lists.\n+        self.unexpanded_macros.extend(unexpanded_macros);\n \n         if added_items {\n             // Continue name resolution with the new data.\n@@ -948,20 +952,17 @@ impl DefCollector<'_> {\n         // incrementality).\n         let err = self.db.macro_expand_error(macro_call_id);\n         if let Some(err) = err {\n-            if let MacroCallId::LazyMacro(id) = macro_call_id {\n-                let loc: MacroCallLoc = self.db.lookup_intern_macro(id);\n+            let loc: MacroCallLoc = self.db.lookup_intern_macro(macro_call_id);\n \n-                let diag = match err {\n-                    hir_expand::ExpandError::UnresolvedProcMacro => {\n-                        // Missing proc macros are non-fatal, so they are handled specially.\n-                        DefDiagnostic::unresolved_proc_macro(module_id, loc.kind)\n-                    }\n-                    _ => DefDiagnostic::macro_error(module_id, loc.kind, err.to_string()),\n-                };\n+            let diag = match err {\n+                hir_expand::ExpandError::UnresolvedProcMacro => {\n+                    // Missing proc macros are non-fatal, so they are handled specially.\n+                    DefDiagnostic::unresolved_proc_macro(module_id, loc.kind)\n+                }\n+                _ => DefDiagnostic::macro_error(module_id, loc.kind, err.to_string()),\n+            };\n \n-                self.def_map.diagnostics.push(diag);\n-            }\n-            // FIXME: Handle eager macros.\n+            self.def_map.diagnostics.push(diag);\n         }\n \n         // Then, fetch and process the item tree. This will reuse the expansion result from above."}, {"sha": "b34ba885d8a58a0222b42834aeacb6e97a736405", "filename": "crates/hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=49922cb2c3cd8390891cda9acb88b4b979db8911", "patch": "@@ -685,6 +685,27 @@ pub trait Clone {}\n     );\n }\n \n+#[test]\n+fn builtin_derive_with_unresolved_attributes_fall_back() {\n+    // Tests that we still resolve derives after ignoring an unresolved attribute.\n+    cov_mark::check!(unresolved_attribute_fallback);\n+    let map = compute_crate_def_map(\n+        r#\"\n+        //- /main.rs crate:main deps:core\n+        use core::Clone;\n+\n+        #[derive(Clone)]\n+        #[unresolved]\n+        struct Foo;\n+\n+        //- /core.rs crate:core\n+        #[rustc_builtin_macro]\n+        pub macro Clone {}\n+        \"#,\n+    );\n+    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n+}\n+\n #[test]\n fn macro_expansion_overflow() {\n     cov_mark::check!(macro_expansion_overflow);\n@@ -842,7 +863,6 @@ fn collects_derive_helpers() {\n fn resolve_macro_def() {\n     check(\n         r#\"\n-//- /lib.rs\n pub macro structs($($i:ident),*) {\n     $(struct $i { field: u32 } )*\n }"}, {"sha": "fe9497b50ec37fccc8f64b4fb51ff3a708a21346", "filename": "crates/hir_expand/src/builtin_derive.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=49922cb2c3cd8390891cda9acb88b4b979db8911", "patch": "@@ -8,7 +8,7 @@ use syntax::{\n     match_ast,\n };\n \n-use crate::{db::AstDatabase, name, quote, AstId, CrateId, LazyMacroId, MacroDefId, MacroDefKind};\n+use crate::{db::AstDatabase, name, quote, AstId, CrateId, MacroCallId, MacroDefId, MacroDefKind};\n \n macro_rules! register_builtin {\n     ( $($trait:ident => $expand:ident),* ) => {\n@@ -21,7 +21,7 @@ macro_rules! register_builtin {\n             pub fn expand(\n                 &self,\n                 db: &dyn AstDatabase,\n-                id: LazyMacroId,\n+                id: MacroCallId,\n                 tt: &tt::Subtree,\n             ) -> Result<tt::Subtree, mbe::ExpandError> {\n                 let expander = match *self {\n@@ -164,7 +164,7 @@ fn expand_simple_derive(\n     Ok(expanded)\n }\n \n-fn find_builtin_crate(db: &dyn AstDatabase, id: LazyMacroId) -> tt::TokenTree {\n+fn find_builtin_crate(db: &dyn AstDatabase, id: MacroCallId) -> tt::TokenTree {\n     // FIXME: make hygiene works for builtin derive macro\n     // such that $crate can be used here.\n     let cg = db.crate_graph();\n@@ -184,7 +184,7 @@ fn find_builtin_crate(db: &dyn AstDatabase, id: LazyMacroId) -> tt::TokenTree {\n \n fn copy_expand(\n     db: &dyn AstDatabase,\n-    id: LazyMacroId,\n+    id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let krate = find_builtin_crate(db, id);\n@@ -193,7 +193,7 @@ fn copy_expand(\n \n fn clone_expand(\n     db: &dyn AstDatabase,\n-    id: LazyMacroId,\n+    id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let krate = find_builtin_crate(db, id);\n@@ -202,7 +202,7 @@ fn clone_expand(\n \n fn default_expand(\n     db: &dyn AstDatabase,\n-    id: LazyMacroId,\n+    id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let krate = find_builtin_crate(db, id);\n@@ -211,7 +211,7 @@ fn default_expand(\n \n fn debug_expand(\n     db: &dyn AstDatabase,\n-    id: LazyMacroId,\n+    id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let krate = find_builtin_crate(db, id);\n@@ -220,7 +220,7 @@ fn debug_expand(\n \n fn hash_expand(\n     db: &dyn AstDatabase,\n-    id: LazyMacroId,\n+    id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let krate = find_builtin_crate(db, id);\n@@ -229,7 +229,7 @@ fn hash_expand(\n \n fn eq_expand(\n     db: &dyn AstDatabase,\n-    id: LazyMacroId,\n+    id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let krate = find_builtin_crate(db, id);\n@@ -238,7 +238,7 @@ fn eq_expand(\n \n fn partial_eq_expand(\n     db: &dyn AstDatabase,\n-    id: LazyMacroId,\n+    id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let krate = find_builtin_crate(db, id);\n@@ -247,7 +247,7 @@ fn partial_eq_expand(\n \n fn ord_expand(\n     db: &dyn AstDatabase,\n-    id: LazyMacroId,\n+    id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let krate = find_builtin_crate(db, id);\n@@ -256,7 +256,7 @@ fn ord_expand(\n \n fn partial_ord_expand(\n     db: &dyn AstDatabase,\n-    id: LazyMacroId,\n+    id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     let krate = find_builtin_crate(db, id);\n@@ -317,6 +317,7 @@ $0\n                 local_inner: false,\n             },\n             krate: CrateId(0),\n+            eager: None,\n             kind: MacroCallKind::Derive {\n                 ast_id,\n                 derive_name: name.to_string(),"}, {"sha": "94d7aecb6fa7dfbbb94e5f66b38cd069904bae75", "filename": "crates/hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=49922cb2c3cd8390891cda9acb88b4b979db8911", "patch": "@@ -1,7 +1,7 @@\n //! Builtin macro\n use crate::{\n-    db::AstDatabase, name, quote, AstId, CrateId, EagerMacroId, LazyMacroId, MacroCallId,\n-    MacroCallLoc, MacroDefId, MacroDefKind, TextSize,\n+    db::AstDatabase, name, quote, AstId, CrateId, MacroCallId, MacroCallLoc, MacroDefId,\n+    MacroDefKind, TextSize,\n };\n \n use base_db::{AnchoredPath, Edition, FileId};\n@@ -27,7 +27,7 @@ macro_rules! register_builtin {\n             pub fn expand(\n                 &self,\n                 db: &dyn AstDatabase,\n-                id: LazyMacroId,\n+                id: MacroCallId,\n                 tt: &tt::Subtree,\n             ) -> ExpandResult<tt::Subtree> {\n                 let expander = match *self {\n@@ -41,7 +41,7 @@ macro_rules! register_builtin {\n             pub fn expand(\n                 &self,\n                 db: &dyn AstDatabase,\n-                arg_id: EagerMacroId,\n+                arg_id: MacroCallId,\n                 tt: &tt::Subtree,\n             ) -> ExpandResult<Option<ExpandedEager>> {\n                 let expander = match *self {\n@@ -128,7 +128,7 @@ register_builtin! {\n \n fn module_path_expand(\n     _db: &dyn AstDatabase,\n-    _id: LazyMacroId,\n+    _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     // Just return a dummy result.\n@@ -137,7 +137,7 @@ fn module_path_expand(\n \n fn line_expand(\n     _db: &dyn AstDatabase,\n-    _id: LazyMacroId,\n+    _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     // dummy implementation for type-checking purposes\n@@ -151,7 +151,7 @@ fn line_expand(\n \n fn stringify_expand(\n     db: &dyn AstDatabase,\n-    id: LazyMacroId,\n+    id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     let loc = db.lookup_intern_macro(id);\n@@ -176,7 +176,7 @@ fn stringify_expand(\n \n fn column_expand(\n     _db: &dyn AstDatabase,\n-    _id: LazyMacroId,\n+    _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     // dummy implementation for type-checking purposes\n@@ -190,7 +190,7 @@ fn column_expand(\n \n fn assert_expand(\n     _db: &dyn AstDatabase,\n-    _id: LazyMacroId,\n+    _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     // A hacky implementation for goto def and hover\n@@ -214,7 +214,7 @@ fn assert_expand(\n \n fn file_expand(\n     _db: &dyn AstDatabase,\n-    _id: LazyMacroId,\n+    _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     // FIXME: RA purposefully lacks knowledge of absolute file names\n@@ -230,7 +230,7 @@ fn file_expand(\n \n fn format_args_expand(\n     _db: &dyn AstDatabase,\n-    _id: LazyMacroId,\n+    _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     // We expand `format_args!(\"\", a1, a2)` to\n@@ -265,7 +265,7 @@ fn format_args_expand(\n \n fn asm_expand(\n     _db: &dyn AstDatabase,\n-    _id: LazyMacroId,\n+    _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     // both asm and llvm_asm don't return anything, so we can expand them to nothing,\n@@ -278,7 +278,7 @@ fn asm_expand(\n \n fn global_asm_expand(\n     _db: &dyn AstDatabase,\n-    _id: LazyMacroId,\n+    _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     // Expand to nothing (at item-level)\n@@ -287,7 +287,7 @@ fn global_asm_expand(\n \n fn cfg_expand(\n     db: &dyn AstDatabase,\n-    id: LazyMacroId,\n+    id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     let loc = db.lookup_intern_macro(id);\n@@ -299,7 +299,7 @@ fn cfg_expand(\n \n fn panic_expand(\n     db: &dyn AstDatabase,\n-    id: LazyMacroId,\n+    id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     let loc: MacroCallLoc = db.lookup_intern_macro(id);\n@@ -324,7 +324,7 @@ fn unquote_str(lit: &tt::Literal) -> Option<String> {\n \n fn compile_error_expand(\n     _db: &dyn AstDatabase,\n-    _id: EagerMacroId,\n+    _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<Option<ExpandedEager>> {\n     let err = match &*tt.token_trees {\n@@ -345,7 +345,7 @@ fn compile_error_expand(\n \n fn concat_expand(\n     _db: &dyn AstDatabase,\n-    _arg_id: EagerMacroId,\n+    _arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<Option<ExpandedEager>> {\n     let mut err = None;\n@@ -376,7 +376,7 @@ fn concat_expand(\n \n fn concat_idents_expand(\n     _db: &dyn AstDatabase,\n-    _arg_id: EagerMacroId,\n+    _arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<Option<ExpandedEager>> {\n     let mut err = None;\n@@ -427,7 +427,7 @@ fn parse_string(tt: &tt::Subtree) -> Result<String, mbe::ExpandError> {\n \n fn include_expand(\n     db: &dyn AstDatabase,\n-    arg_id: EagerMacroId,\n+    arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<Option<ExpandedEager>> {\n     let res = (|| {\n@@ -457,7 +457,7 @@ fn include_expand(\n \n fn include_bytes_expand(\n     _db: &dyn AstDatabase,\n-    _arg_id: EagerMacroId,\n+    _arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<Option<ExpandedEager>> {\n     if let Err(e) = parse_string(tt) {\n@@ -477,7 +477,7 @@ fn include_bytes_expand(\n \n fn include_str_expand(\n     db: &dyn AstDatabase,\n-    arg_id: EagerMacroId,\n+    arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<Option<ExpandedEager>> {\n     let path = match parse_string(tt) {\n@@ -502,14 +502,14 @@ fn include_str_expand(\n     ExpandResult::ok(Some(ExpandedEager::new(quote!(#text), FragmentKind::Expr)))\n }\n \n-fn get_env_inner(db: &dyn AstDatabase, arg_id: EagerMacroId, key: &str) -> Option<String> {\n-    let krate = db.lookup_intern_eager_expansion(arg_id).krate;\n+fn get_env_inner(db: &dyn AstDatabase, arg_id: MacroCallId, key: &str) -> Option<String> {\n+    let krate = db.lookup_intern_macro(arg_id).krate;\n     db.crate_graph()[krate].env.get(key)\n }\n \n fn env_expand(\n     db: &dyn AstDatabase,\n-    arg_id: EagerMacroId,\n+    arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<Option<ExpandedEager>> {\n     let key = match parse_string(tt) {\n@@ -540,7 +540,7 @@ fn env_expand(\n \n fn option_env_expand(\n     db: &dyn AstDatabase,\n-    arg_id: EagerMacroId,\n+    arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<Option<ExpandedEager>> {\n     let key = match parse_string(tt) {\n@@ -560,7 +560,7 @@ fn option_env_expand(\n mod tests {\n     use super::*;\n     use crate::{\n-        name::AsName, test_db::TestDB, AstNode, EagerCallLoc, MacroCallId, MacroCallKind,\n+        name::AsName, test_db::TestDB, AstNode, EagerCallInfo, MacroCallId, MacroCallKind,\n         MacroCallLoc,\n     };\n     use base_db::{fixture::WithFixture, SourceDatabase};\n@@ -599,6 +599,7 @@ mod tests {\n                 let loc = MacroCallLoc {\n                     def,\n                     krate,\n+                    eager: None,\n                     kind: MacroCallKind::FnLike {\n                         ast_id: AstId::new(file_id.into(), ast_id_map.ast_id(&macro_call)),\n                         fragment: FragmentKind::Expr,\n@@ -620,28 +621,28 @@ mod tests {\n                 let parsed_args = mbe::ast_to_token_tree(&args).0;\n                 let call_id = AstId::new(file_id.into(), ast_id_map.ast_id(&macro_call));\n \n-                let arg_id = db.intern_eager_expansion({\n-                    EagerCallLoc {\n-                        def,\n-                        fragment: FragmentKind::Expr,\n-                        subtree: Arc::new(parsed_args.clone()),\n-                        krate,\n-                        call: call_id,\n+                let arg_id = db.intern_macro(MacroCallLoc {\n+                    def,\n+                    krate,\n+                    eager: Some(EagerCallInfo {\n+                        arg_or_expansion: Arc::new(parsed_args.clone()),\n                         included_file: None,\n-                    }\n+                    }),\n+                    kind: MacroCallKind::FnLike { ast_id: call_id, fragment: FragmentKind::Expr },\n                 });\n \n                 let expanded = expander.expand(&db, arg_id, &parsed_args).value.unwrap();\n-                let eager = EagerCallLoc {\n+                let loc = MacroCallLoc {\n                     def,\n-                    fragment: expanded.fragment,\n-                    subtree: Arc::new(expanded.subtree),\n                     krate,\n-                    call: call_id,\n-                    included_file: expanded.included_file,\n+                    eager: Some(EagerCallInfo {\n+                        arg_or_expansion: Arc::new(expanded.subtree),\n+                        included_file: expanded.included_file,\n+                    }),\n+                    kind: MacroCallKind::FnLike { ast_id: call_id, fragment: expanded.fragment },\n                 };\n \n-                let id: MacroCallId = db.intern_eager_expansion(eager).into();\n+                let id: MacroCallId = db.intern_macro(loc).into();\n                 id.as_file()\n             }\n         };"}, {"sha": "5c769c1bf2c44605855c5aca7774552263e3f66b", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 39, "deletions": 81, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=49922cb2c3cd8390891cda9acb88b4b979db8911", "patch": "@@ -13,8 +13,8 @@ use syntax::{\n \n use crate::{\n     ast_id_map::AstIdMap, hygiene::HygieneFrame, input::process_macro_input, BuiltinDeriveExpander,\n-    BuiltinFnLikeExpander, EagerCallLoc, EagerMacroId, HirFileId, HirFileIdRepr, LazyMacroId,\n-    MacroCallId, MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n+    BuiltinFnLikeExpander, HirFileId, HirFileIdRepr, MacroCallId, MacroCallLoc, MacroDefId,\n+    MacroDefKind, MacroFile, ProcMacroExpander,\n };\n \n /// Total limit on the number of tokens produced by any macro invocation.\n@@ -41,7 +41,7 @@ impl TokenExpander {\n     fn expand(\n         &self,\n         db: &dyn AstDatabase,\n-        id: LazyMacroId,\n+        id: MacroCallId,\n         tt: &tt::Subtree,\n     ) -> mbe::ExpandResult<tt::Subtree> {\n         match self {\n@@ -101,11 +101,7 @@ pub trait AstDatabase: SourceDatabase {\n     /// We encode macro definitions into ids of macro calls, this what allows us\n     /// to be incremental.\n     #[salsa::interned]\n-    fn intern_macro(&self, macro_call: MacroCallLoc) -> LazyMacroId;\n-    /// Certain built-in macros are eager (`format!(concat!(\"file: \", file!(), \"{}\"\")), 92`).\n-    /// For them, we actually want to encode the whole token tree as an argument.\n-    #[salsa::interned]\n-    fn intern_eager_expansion(&self, eager: EagerCallLoc) -> EagerMacroId;\n+    fn intern_macro(&self, macro_call: MacroCallLoc) -> MacroCallId;\n \n     /// Lowers syntactic macro call to a token tree representation.\n     #[salsa::transparent]\n@@ -146,17 +142,12 @@ pub fn expand_hypothetical(\n         token_to_map.text_range().checked_sub(hypothetical_args.syntax().text_range().start())?;\n     let token_id = tmap_1.token_by_range(range)?;\n \n-    let lazy_id = match actual_macro_call {\n-        MacroCallId::LazyMacro(id) => id,\n-        MacroCallId::EagerMacro(_) => return None,\n-    };\n-\n     let macro_def = {\n-        let loc = db.lookup_intern_macro(lazy_id);\n+        let loc: MacroCallLoc = db.lookup_intern_macro(actual_macro_call);\n         db.macro_def(loc.def)?\n     };\n \n-    let hypothetical_expansion = macro_def.expand(db, lazy_id, &tt);\n+    let hypothetical_expansion = macro_def.expand(db, actual_macro_call, &tt);\n \n     let fragment_kind = macro_fragment_kind(db, actual_macro_call);\n \n@@ -194,30 +185,22 @@ fn parse_macro_expansion(\n         // Note:\n         // The final goal we would like to make all parse_macro success,\n         // such that the following log will not call anyway.\n-        match macro_file.macro_call_id {\n-            MacroCallId::LazyMacro(id) => {\n-                let loc: MacroCallLoc = db.lookup_intern_macro(id);\n-                let node = loc.kind.node(db);\n-\n-                // collect parent information for warning log\n-                let parents = std::iter::successors(loc.kind.file_id().call_node(db), |it| {\n-                    it.file_id.call_node(db)\n-                })\n+        let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n+        let node = loc.kind.node(db);\n+\n+        // collect parent information for warning log\n+        let parents =\n+            std::iter::successors(loc.kind.file_id().call_node(db), |it| it.file_id.call_node(db))\n                 .map(|n| format!(\"{:#}\", n.value))\n                 .collect::<Vec<_>>()\n                 .join(\"\\n\");\n \n-                log::warn!(\n-                    \"fail on macro_parse: (reason: {:?} macro_call: {:#}) parents: {}\",\n-                    err,\n-                    node.value,\n-                    parents\n-                );\n-            }\n-            _ => {\n-                log::warn!(\"fail on macro_parse: (reason: {:?})\", err);\n-            }\n-        }\n+        log::warn!(\n+            \"fail on macro_parse: (reason: {:?} macro_call: {:#}) parents: {}\",\n+            err,\n+            node.value,\n+            parents\n+        );\n     }\n     let tt = match result.value {\n         Some(tt) => tt,\n@@ -269,25 +252,16 @@ fn macro_arg(db: &dyn AstDatabase, id: MacroCallId) -> Option<Arc<(tt::Subtree,\n     let arg = db.macro_arg_text(id)?;\n     let (mut tt, tmap) = mbe::syntax_node_to_token_tree(&SyntaxNode::new_root(arg));\n \n-    if let MacroCallId::LazyMacro(id) = id {\n-        let loc: MacroCallLoc = db.lookup_intern_macro(id);\n-        if loc.def.is_proc_macro() {\n-            // proc macros expect their inputs without parentheses, MBEs expect it with them included\n-            tt.delimiter = None;\n-        }\n+    let loc: MacroCallLoc = db.lookup_intern_macro(id);\n+    if loc.def.is_proc_macro() {\n+        // proc macros expect their inputs without parentheses, MBEs expect it with them included\n+        tt.delimiter = None;\n     }\n \n     Some(Arc::new((tt, tmap)))\n }\n \n fn macro_arg_text(db: &dyn AstDatabase, id: MacroCallId) -> Option<GreenNode> {\n-    let id = match id {\n-        MacroCallId::LazyMacro(id) => id,\n-        MacroCallId::EagerMacro(_id) => {\n-            // FIXME: support macro_arg for eager macro\n-            return None;\n-        }\n-    };\n     let loc = db.lookup_intern_macro(id);\n     let arg = loc.kind.arg(db)?;\n     let arg = process_macro_input(db, arg, id);\n@@ -347,24 +321,21 @@ fn macro_expand_with_arg(\n     arg: Option<Arc<(tt::Subtree, mbe::TokenMap)>>,\n ) -> ExpandResult<Option<Arc<tt::Subtree>>> {\n     let _p = profile::span(\"macro_expand\");\n-    let lazy_id = match id {\n-        MacroCallId::LazyMacro(id) => id,\n-        MacroCallId::EagerMacro(id) => {\n-            if arg.is_some() {\n-                return ExpandResult::str_err(\n-                    \"hypothetical macro expansion not implemented for eager macro\".to_owned(),\n-                );\n-            } else {\n-                return ExpandResult {\n-                    value: Some(db.lookup_intern_eager_expansion(id).subtree),\n-                    // FIXME: There could be errors here!\n-                    err: None,\n-                };\n-            }\n+    let loc: MacroCallLoc = db.lookup_intern_macro(id);\n+    if let Some(eager) = &loc.eager {\n+        if arg.is_some() {\n+            return ExpandResult::str_err(\n+                \"hypothetical macro expansion not implemented for eager macro\".to_owned(),\n+            );\n+        } else {\n+            return ExpandResult {\n+                value: Some(eager.arg_or_expansion.clone()),\n+                // FIXME: There could be errors here!\n+                err: None,\n+            };\n         }\n-    };\n+    }\n \n-    let loc = db.lookup_intern_macro(lazy_id);\n     let macro_arg = match arg.or_else(|| db.macro_arg(id)) {\n         Some(it) => it,\n         None => return ExpandResult::str_err(\"Fail to args in to tt::TokenTree\".into()),\n@@ -374,7 +345,7 @@ fn macro_expand_with_arg(\n         Some(it) => it,\n         None => return ExpandResult::str_err(\"Fail to find macro definition\".into()),\n     };\n-    let ExpandResult { value: tt, err } = macro_rules.expand(db, lazy_id, &macro_arg.0);\n+    let ExpandResult { value: tt, err } = macro_rules.expand(db, id, &macro_arg.0);\n     // Set a hard limit for the expanded tt\n     let count = tt.count();\n     if count > TOKEN_LIMIT {\n@@ -391,12 +362,7 @@ fn expand_proc_macro(\n     db: &dyn AstDatabase,\n     id: MacroCallId,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n-    let lazy_id = match id {\n-        MacroCallId::LazyMacro(id) => id,\n-        MacroCallId::EagerMacro(_) => unreachable!(),\n-    };\n-\n-    let loc = db.lookup_intern_macro(lazy_id);\n+    let loc: MacroCallLoc = db.lookup_intern_macro(id);\n     let macro_arg = match db.macro_arg(id) {\n         Some(it) => it,\n         None => {\n@@ -436,14 +402,6 @@ fn hygiene_frame(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<HygieneFrame>\n }\n \n fn macro_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n-    match id {\n-        MacroCallId::LazyMacro(id) => {\n-            let loc: MacroCallLoc = db.lookup_intern_macro(id);\n-            loc.kind.fragment_kind()\n-        }\n-        MacroCallId::EagerMacro(id) => {\n-            let loc: EagerCallLoc = db.lookup_intern_eager_expansion(id);\n-            loc.fragment\n-        }\n-    }\n+    let loc: MacroCallLoc = db.lookup_intern_macro(id);\n+    loc.kind.fragment_kind()\n }"}, {"sha": "e165b9c5fb7d195cc8dc6c78619dc1a6ff940ac2", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=49922cb2c3cd8390891cda9acb88b4b979db8911", "patch": "@@ -22,7 +22,7 @@\n use crate::{\n     ast::{self, AstNode},\n     db::AstDatabase,\n-    EagerCallLoc, EagerMacroId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+    EagerCallInfo, InFile, MacroCallId, MacroCallKind, MacroCallLoc, MacroDefId, MacroDefKind,\n };\n \n use base_db::CrateId;\n@@ -105,7 +105,7 @@ pub fn expand_eager_macro(\n     def: MacroDefId,\n     resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n     mut diagnostic_sink: &mut dyn FnMut(mbe::ExpandError),\n-) -> Result<EagerMacroId, ErrorEmitted> {\n+) -> Result<MacroCallId, ErrorEmitted> {\n     let parsed_args = diagnostic_sink.option_with(\n         || Some(mbe::ast_to_token_tree(&macro_call.value.token_tree()?).0),\n         || err(\"malformed macro invocation\"),\n@@ -118,15 +118,14 @@ pub fn expand_eager_macro(\n     // When `lazy_expand` is called, its *parent* file must be already exists.\n     // Here we store an eager macro id for the argument expanded subtree here\n     // for that purpose.\n-    let arg_id = db.intern_eager_expansion({\n-        EagerCallLoc {\n-            def,\n-            fragment: FragmentKind::Expr,\n-            subtree: Arc::new(parsed_args.clone()),\n-            krate,\n-            call: call_id,\n+    let arg_id = db.intern_macro(MacroCallLoc {\n+        def,\n+        krate,\n+        eager: Some(EagerCallInfo {\n+            arg_or_expansion: Arc::new(parsed_args.clone()),\n             included_file: None,\n-        }\n+        }),\n+        kind: MacroCallKind::FnLike { ast_id: call_id, fragment: FragmentKind::Expr },\n     });\n     let arg_file_id: MacroCallId = arg_id.into();\n \n@@ -146,16 +145,17 @@ pub fn expand_eager_macro(\n         let res = eager.expand(db, arg_id, &subtree);\n \n         let expanded = diagnostic_sink.expand_result_option(res)?;\n-        let eager = EagerCallLoc {\n+        let loc = MacroCallLoc {\n             def,\n-            fragment: expanded.fragment,\n-            subtree: Arc::new(expanded.subtree),\n             krate,\n-            call: call_id,\n-            included_file: expanded.included_file,\n+            eager: Some(EagerCallInfo {\n+                arg_or_expansion: Arc::new(expanded.subtree),\n+                included_file: expanded.included_file,\n+            }),\n+            kind: MacroCallKind::FnLike { ast_id: call_id, fragment: expanded.fragment },\n         };\n \n-        Ok(db.intern_eager_expansion(eager))\n+        Ok(db.intern_macro(loc))\n     } else {\n         panic!(\"called `expand_eager_macro` on non-eager macro def {:?}\", def);\n     }"}, {"sha": "38e09fdd4f7490349a2176e66306c15be54ca7b4", "filename": "crates/hir_expand/src/hygiene.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs?ref=49922cb2c3cd8390891cda9acb88b4b979db8911", "patch": "@@ -14,7 +14,7 @@ use syntax::{ast, AstNode, SyntaxNode, TextRange, TextSize};\n use crate::{\n     db::{self, AstDatabase},\n     name::{AsName, Name},\n-    HirFileId, HirFileIdRepr, InFile, MacroCallId, MacroCallLoc, MacroDefKind, MacroFile,\n+    HirFileId, HirFileIdRepr, InFile, MacroCallLoc, MacroDefKind, MacroFile,\n };\n \n #[derive(Clone, Debug)]\n@@ -140,10 +140,7 @@ impl HygieneInfo {\n         let (token_id, origin) = self.macro_def.map_id_up(token_id);\n         let (token_map, tt) = match origin {\n             mbe::Origin::Call => {\n-                let call_id = match self.file.macro_call_id {\n-                    MacroCallId::LazyMacro(lazy) => lazy,\n-                    MacroCallId::EagerMacro(_) => unreachable!(),\n-                };\n+                let call_id = self.file.macro_call_id;\n                 let loc: MacroCallLoc = db.lookup_intern_macro(call_id);\n                 let arg_start = loc.kind.arg(db)?.text_range().start();\n                 (&self.macro_arg.1, InFile::new(loc.kind.file_id(), arg_start))\n@@ -186,23 +183,20 @@ impl HygieneFrame {\n     pub(crate) fn new(db: &dyn AstDatabase, file_id: HirFileId) -> HygieneFrame {\n         let (info, krate, local_inner) = match file_id.0 {\n             HirFileIdRepr::FileId(_) => (None, None, false),\n-            HirFileIdRepr::MacroFile(macro_file) => match macro_file.macro_call_id {\n-                MacroCallId::EagerMacro(_id) => (None, None, false),\n-                MacroCallId::LazyMacro(id) => {\n-                    let loc = db.lookup_intern_macro(id);\n-                    let info = make_hygiene_info(db, macro_file, &loc)\n-                        .map(|info| (loc.kind.file_id(), info));\n-                    match loc.def.kind {\n-                        MacroDefKind::Declarative(_) => {\n-                            (info, Some(loc.def.krate), loc.def.local_inner)\n-                        }\n-                        MacroDefKind::BuiltIn(..) => (info, Some(loc.def.krate), false),\n-                        MacroDefKind::BuiltInDerive(..) => (info, None, false),\n-                        MacroDefKind::BuiltInEager(..) => (info, None, false),\n-                        MacroDefKind::ProcMacro(..) => (info, None, false),\n+            HirFileIdRepr::MacroFile(macro_file) => {\n+                let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n+                let info =\n+                    make_hygiene_info(db, macro_file, &loc).map(|info| (loc.kind.file_id(), info));\n+                match loc.def.kind {\n+                    MacroDefKind::Declarative(_) => {\n+                        (info, Some(loc.def.krate), loc.def.local_inner)\n                     }\n+                    MacroDefKind::BuiltIn(..) => (info, Some(loc.def.krate), false),\n+                    MacroDefKind::BuiltInDerive(..) => (info, None, false),\n+                    MacroDefKind::BuiltInEager(..) => (info, None, false),\n+                    MacroDefKind::ProcMacro(..) => (info, None, false),\n                 }\n-            },\n+            }\n         };\n \n         let (calling_file, info) = match info {"}, {"sha": "fe4790e7b6ba76680ced79dc7db9540cfb1edc9b", "filename": "crates/hir_expand/src/input.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_expand%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_expand%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Finput.rs?ref=49922cb2c3cd8390891cda9acb88b4b979db8911", "patch": "@@ -8,13 +8,13 @@ use syntax::{\n use crate::{\n     db::AstDatabase,\n     name::{name, AsName},\n-    LazyMacroId, MacroCallKind, MacroCallLoc,\n+    MacroCallId, MacroCallKind, MacroCallLoc,\n };\n \n pub(crate) fn process_macro_input(\n     db: &dyn AstDatabase,\n     node: SyntaxNode,\n-    id: LazyMacroId,\n+    id: MacroCallId,\n ) -> SyntaxNode {\n     let loc: MacroCallLoc = db.lookup_intern_macro(id);\n "}, {"sha": "b93c0c3456c78c676f71780e9292150185548b07", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 31, "deletions": 93, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=49922cb2c3cd8390891cda9acb88b4b979db8911", "patch": "@@ -80,19 +80,10 @@ impl HirFileId {\n         match self.0 {\n             HirFileIdRepr::FileId(file_id) => file_id,\n             HirFileIdRepr::MacroFile(macro_file) => {\n-                let file_id = match macro_file.macro_call_id {\n-                    MacroCallId::LazyMacro(id) => {\n-                        let loc = db.lookup_intern_macro(id);\n-                        loc.kind.file_id()\n-                    }\n-                    MacroCallId::EagerMacro(id) => {\n-                        let loc = db.lookup_intern_eager_expansion(id);\n-                        if let Some(included_file) = loc.included_file {\n-                            return included_file;\n-                        } else {\n-                            loc.call.file_id\n-                        }\n-                    }\n+                let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n+                let file_id = match &loc.eager {\n+                    Some(EagerCallInfo { included_file: Some(file), .. }) => (*file).into(),\n+                    _ => loc.kind.file_id(),\n                 };\n                 file_id.original_file(db)\n             }\n@@ -103,17 +94,10 @@ impl HirFileId {\n         let mut level = 0;\n         let mut curr = self;\n         while let HirFileIdRepr::MacroFile(macro_file) = curr.0 {\n+            let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n+\n             level += 1;\n-            curr = match macro_file.macro_call_id {\n-                MacroCallId::LazyMacro(id) => {\n-                    let loc = db.lookup_intern_macro(id);\n-                    loc.kind.file_id()\n-                }\n-                MacroCallId::EagerMacro(id) => {\n-                    let loc = db.lookup_intern_eager_expansion(id);\n-                    loc.call.file_id\n-                }\n-            };\n+            curr = loc.kind.file_id();\n         }\n         level\n     }\n@@ -122,16 +106,10 @@ impl HirFileId {\n     pub fn call_node(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxNode>> {\n         match self.0 {\n             HirFileIdRepr::FileId(_) => None,\n-            HirFileIdRepr::MacroFile(macro_file) => match macro_file.macro_call_id {\n-                MacroCallId::LazyMacro(lazy_id) => {\n-                    let loc: MacroCallLoc = db.lookup_intern_macro(lazy_id);\n-                    Some(loc.kind.node(db))\n-                }\n-                MacroCallId::EagerMacro(id) => {\n-                    let loc: EagerCallLoc = db.lookup_intern_eager_expansion(id);\n-                    Some(loc.call.with_value(loc.call.to_node(db).syntax().clone()))\n-                }\n-            },\n+            HirFileIdRepr::MacroFile(macro_file) => {\n+                let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n+                Some(loc.kind.node(db))\n+            }\n         }\n     }\n \n@@ -140,14 +118,7 @@ impl HirFileId {\n         match self.0 {\n             HirFileIdRepr::FileId(_) => None,\n             HirFileIdRepr::MacroFile(macro_file) => {\n-                let lazy_id = match macro_file.macro_call_id {\n-                    MacroCallId::LazyMacro(id) => id,\n-                    MacroCallId::EagerMacro(_id) => {\n-                        // FIXME: handle expansion_info for eager macro\n-                        return None;\n-                    }\n-                };\n-                let loc: MacroCallLoc = db.lookup_intern_macro(lazy_id);\n+                let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n \n                 let arg_tt = loc.kind.arg(db)?;\n \n@@ -180,13 +151,7 @@ impl HirFileId {\n         match self.0 {\n             HirFileIdRepr::FileId(_) => None,\n             HirFileIdRepr::MacroFile(macro_file) => {\n-                let lazy_id = match macro_file.macro_call_id {\n-                    MacroCallId::LazyMacro(id) => id,\n-                    MacroCallId::EagerMacro(_id) => {\n-                        return None;\n-                    }\n-                };\n-                let loc: MacroCallLoc = db.lookup_intern_macro(lazy_id);\n+                let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n                 let item = match loc.def.kind {\n                     MacroDefKind::BuiltInDerive(..) => loc.kind.node(db),\n                     _ => return None,\n@@ -199,16 +164,12 @@ impl HirFileId {\n     /// Return whether this file is an include macro\n     pub fn is_include_macro(&self, db: &dyn db::AstDatabase) -> bool {\n         match self.0 {\n-            HirFileIdRepr::MacroFile(macro_file) => match macro_file.macro_call_id {\n-                MacroCallId::EagerMacro(id) => {\n-                    let loc = db.lookup_intern_eager_expansion(id);\n-                    return loc.included_file.is_some();\n-                }\n-                _ => {}\n-            },\n-            _ => {}\n+            HirFileIdRepr::MacroFile(macro_file) => {\n+                let loc: MacroCallLoc = db.lookup_intern_macro(macro_file.macro_call_id);\n+                matches!(loc.eager, Some(EagerCallInfo { included_file: Some(_), .. }))\n+            }\n+            _ => false,\n         }\n-        false\n     }\n }\n \n@@ -220,29 +181,8 @@ pub struct MacroFile {\n /// `MacroCallId` identifies a particular macro invocation, like\n /// `println!(\"Hello, {}\", world)`.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum MacroCallId {\n-    LazyMacro(LazyMacroId),\n-    EagerMacro(EagerMacroId),\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct LazyMacroId(salsa::InternId);\n-impl_intern_key!(LazyMacroId);\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct EagerMacroId(salsa::InternId);\n-impl_intern_key!(EagerMacroId);\n-\n-impl From<LazyMacroId> for MacroCallId {\n-    fn from(it: LazyMacroId) -> Self {\n-        MacroCallId::LazyMacro(it)\n-    }\n-}\n-impl From<EagerMacroId> for MacroCallId {\n-    fn from(it: EagerMacroId) -> Self {\n-        MacroCallId::EagerMacro(it)\n-    }\n-}\n+pub struct MacroCallId(salsa::InternId);\n+impl_intern_key!(MacroCallId);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct MacroDefId {\n@@ -258,8 +198,8 @@ impl MacroDefId {\n         db: &dyn db::AstDatabase,\n         krate: CrateId,\n         kind: MacroCallKind,\n-    ) -> LazyMacroId {\n-        db.intern_macro(MacroCallLoc { def: self, krate, kind })\n+    ) -> MacroCallId {\n+        db.intern_macro(MacroCallLoc { def: self, krate, eager: None, kind })\n     }\n \n     pub fn ast_id(&self) -> Either<AstId<ast::Macro>, AstId<ast::Fn>> {\n@@ -288,10 +228,18 @@ pub enum MacroDefKind {\n     ProcMacro(ProcMacroExpander, AstId<ast::Fn>),\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+struct EagerCallInfo {\n+    /// NOTE: This can be *either* the expansion result, *or* the argument to the eager macro!\n+    arg_or_expansion: Arc<tt::Subtree>,\n+    included_file: Option<FileId>,\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCallLoc {\n     pub(crate) def: MacroDefId,\n     pub(crate) krate: CrateId,\n+    eager: Option<EagerCallInfo>,\n     pub kind: MacroCallKind,\n }\n \n@@ -313,6 +261,7 @@ pub enum MacroCallKind {\n }\n \n impl MacroCallKind {\n+    /// Returns the file containing the macro invocation.\n     fn file_id(&self) -> HirFileId {\n         match self {\n             MacroCallKind::FnLike { ast_id, .. } => ast_id.file_id,\n@@ -354,17 +303,6 @@ impl MacroCallId {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct EagerCallLoc {\n-    pub(crate) def: MacroDefId,\n-    pub(crate) fragment: FragmentKind,\n-    pub(crate) subtree: Arc<tt::Subtree>,\n-    pub(crate) krate: CrateId,\n-    pub(crate) call: AstId<ast::MacroCall>,\n-    // The included file ID of the include macro.\n-    pub(crate) included_file: Option<FileId>,\n-}\n-\n /// ExpansionInfo mainly describes how to map text range between src and expanded macro\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ExpansionInfo {"}, {"sha": "f988572ae7223d579946c21bfa9b14b0c2e5ab00", "filename": "crates/ide_db/src/apply_change.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fide_db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49922cb2c3cd8390891cda9acb88b4b979db8911/crates%2Fide_db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fapply_change.rs?ref=49922cb2c3cd8390891cda9acb88b4b979db8911", "patch": "@@ -222,7 +222,6 @@ impl RootDatabase {\n         sweep_each_query![\n             // AstDatabase\n             hir::db::InternMacroQuery\n-            hir::db::InternEagerExpansionQuery\n \n             // InternDatabase\n             hir::db::InternFunctionQuery"}]}