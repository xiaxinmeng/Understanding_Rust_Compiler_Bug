{"sha": "753a569c79c5a4a1dd7624028cc85fa9590da53d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1M2E1NjljNzljNWE0YTFkZDc2MjQwMjhjYzg1ZmE5NTkwZGE1M2Q=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-10T17:29:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-10T17:29:22Z"}, "message": "Merge #1809\n\n1809: add fragmets to expansion r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "bda5c9cccae5835990e89ffbd5671dad8f248706", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bda5c9cccae5835990e89ffbd5671dad8f248706"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/753a569c79c5a4a1dd7624028cc85fa9590da53d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdd91yCRBK7hj4Ov3rIwAAdHIIAJ3Pq6PctJSh6340FH6pHDjB\nb6dLGln0S8RXbLWQqxPet3yGZP51ZxzQhlpKI31L2ojiWqcoyu2h67ELqHcUD30i\nY/ekk8Us1ClBeQgL3Wxsz/WT0VmYL+iiHvmVxPmJakqIhkMGo9yyXhWHcpDE9AUD\n1XrA+whE5XlKkFS3SagzpjuTMhYD4Y6INyndfzdNfbp76DdSKMNmrZ5SYngL4+EU\nTYbHns/WglAadWXfizcdP+clKGNPy4HUswNYBXPXmuvg0cVBA5oXvsV+9KEqtSoU\n/D3+zqc+kvTLamzOYKcTQIDWfDkkHAOZaMSIT8tqTnosHBaaMS9/8T9HKkSVa9Q=\n=xTcT\n-----END PGP SIGNATURE-----\n", "payload": "tree bda5c9cccae5835990e89ffbd5671dad8f248706\nparent 9d3c78e2eee6635772c99d7351b621cefb08bac5\nparent 4fdaec99c0b97c56b67483b57fe2bcb89570d7c8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1568136562 +0000\ncommitter GitHub <noreply@github.com> 1568136562 +0000\n\nMerge #1809\n\n1809: add fragmets to expansion r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/753a569c79c5a4a1dd7624028cc85fa9590da53d", "html_url": "https://github.com/rust-lang/rust/commit/753a569c79c5a4a1dd7624028cc85fa9590da53d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/753a569c79c5a4a1dd7624028cc85fa9590da53d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d3c78e2eee6635772c99d7351b621cefb08bac5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3c78e2eee6635772c99d7351b621cefb08bac5", "html_url": "https://github.com/rust-lang/rust/commit/9d3c78e2eee6635772c99d7351b621cefb08bac5"}, {"sha": "4fdaec99c0b97c56b67483b57fe2bcb89570d7c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fdaec99c0b97c56b67483b57fe2bcb89570d7c8", "html_url": "https://github.com/rust-lang/rust/commit/4fdaec99c0b97c56b67483b57fe2bcb89570d7c8"}], "stats": {"total": 87, "additions": 35, "deletions": 52}, "files": [{"sha": "78df96880611febb2146762b14bad8374d9dc677", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 33, "deletions": 49, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/753a569c79c5a4a1dd7624028cc85fa9590da53d/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753a569c79c5a4a1dd7624028cc85fa9590da53d/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=753a569c79c5a4a1dd7624028cc85fa9590da53d", "patch": "@@ -81,21 +81,26 @@ struct Bindings {\n \n #[derive(Debug)]\n enum Binding {\n-    Simple(tt::TokenTree),\n+    Fragment(Fragment),\n     Nested(Vec<Binding>),\n     Empty,\n }\n \n+#[derive(Debug, Clone)]\n+enum Fragment {\n+    /// token fragments are just copy-pasted into the output\n+    Tokens(tt::TokenTree),\n+    /// Ast fragments are inserted with fake delimiters, so as to make things\n+    /// like `$i * 2` where `$i = 1 + 1` work as expectd.\n+    Ast(tt::TokenTree),\n+}\n+\n impl Bindings {\n     fn push_optional(&mut self, name: &SmolStr) {\n         // FIXME: Do we have a better way to represent an empty token ?\n         // Insert an empty subtree for empty token\n-        self.inner.insert(\n-            name.clone(),\n-            Binding::Simple(\n-                tt::Subtree { delimiter: tt::Delimiter::None, token_trees: vec![] }.into(),\n-            ),\n-        );\n+        let tt = tt::Subtree { delimiter: tt::Delimiter::None, token_trees: vec![] }.into();\n+        self.inner.insert(name.clone(), Binding::Fragment(Fragment::Tokens(tt)));\n     }\n \n     fn push_empty(&mut self, name: &SmolStr) {\n@@ -106,13 +111,13 @@ impl Bindings {\n         self.inner.contains_key(name)\n     }\n \n-    fn get(&self, name: &SmolStr, nesting: &[usize]) -> Result<&tt::TokenTree, ExpandError> {\n+    fn get(&self, name: &SmolStr, nesting: &[usize]) -> Result<&Fragment, ExpandError> {\n         let mut b = self.inner.get(name).ok_or_else(|| {\n             ExpandError::BindingError(format!(\"could not find binding `{}`\", name))\n         })?;\n         for &idx in nesting.iter() {\n             b = match b {\n-                Binding::Simple(_) => break,\n+                Binding::Fragment(_) => break,\n                 Binding::Nested(bs) => bs.get(idx).ok_or_else(|| {\n                     ExpandError::BindingError(format!(\"could not find nested binding `{}`\", name))\n                 })?,\n@@ -125,7 +130,7 @@ impl Bindings {\n             };\n         }\n         match b {\n-            Binding::Simple(it) => Ok(it),\n+            Binding::Fragment(it) => Ok(it),\n             Binding::Nested(_) => Err(ExpandError::BindingError(format!(\n                 \"expected simple binding, found nested binding `{}`\",\n                 name\n@@ -195,8 +200,8 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                 crate::Leaf::Var(crate::Var { text, kind }) => {\n                     let kind = kind.as_ref().ok_or(ExpandError::UnexpectedToken)?;\n                     match match_meta_var(kind.as_str(), input)? {\n-                        Some(tt) => {\n-                            res.inner.insert(text.clone(), Binding::Simple(tt));\n+                        Some(fragment) => {\n+                            res.inner.insert(text.clone(), Binding::Fragment(fragment));\n                         }\n                         None => res.push_optional(text),\n                     }\n@@ -292,7 +297,7 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n     Ok(res)\n }\n \n-fn match_meta_var(kind: &str, input: &mut TtCursor) -> Result<Option<tt::TokenTree>, ExpandError> {\n+fn match_meta_var(kind: &str, input: &mut TtCursor) -> Result<Option<Fragment>, ExpandError> {\n     let fragment = match kind {\n         \"path\" => Path,\n         \"expr\" => Expr,\n@@ -303,7 +308,7 @@ fn match_meta_var(kind: &str, input: &mut TtCursor) -> Result<Option<tt::TokenTr\n         \"meta\" => MetaItem,\n         \"item\" => Item,\n         _ => {\n-            let binding = match kind {\n+            let tt = match kind {\n                 \"ident\" => {\n                     let ident = input.eat_ident().ok_or(ExpandError::UnexpectedToken)?.clone();\n                     tt::Leaf::from(ident).into()\n@@ -321,11 +326,12 @@ fn match_meta_var(kind: &str, input: &mut TtCursor) -> Result<Option<tt::TokenTr\n                 },\n                 _ => return Err(ExpandError::UnexpectedToken),\n             };\n-            return Ok(Some(binding));\n+            return Ok(Some(Fragment::Tokens(tt)));\n         }\n     };\n-    let binding = input.eat_fragment(fragment).ok_or(ExpandError::UnexpectedToken)?;\n-    Ok(Some(binding))\n+    let tt = input.eat_fragment(fragment).ok_or(ExpandError::UnexpectedToken)?;\n+    let fragment = if kind == \"expr\" { Fragment::Ast(tt) } else { Fragment::Tokens(tt) };\n+    Ok(Some(fragment))\n }\n \n #[derive(Debug)]\n@@ -342,30 +348,13 @@ fn expand_subtree(\n     let mut buf: Vec<tt::TokenTree> = Vec::new();\n     for tt in template.token_trees.iter() {\n         let tt = expand_tt(tt, ctx)?;\n-        push_tt(&mut buf, tt);\n+        push_fragment(&mut buf, tt);\n     }\n \n     Ok(tt::Subtree { delimiter: template.delimiter, token_trees: buf })\n }\n \n-/// Reduce single token subtree to single token\n-/// In `tt` matcher case, all tt tokens will be braced by a Delimiter::None\n-/// which makes all sort of problems.\n-fn reduce_single_token(mut subtree: tt::Subtree) -> tt::TokenTree {\n-    if subtree.delimiter != tt::Delimiter::None || subtree.token_trees.len() != 1 {\n-        return subtree.into();\n-    }\n-\n-    match subtree.token_trees.pop().unwrap() {\n-        tt::TokenTree::Subtree(subtree) => reduce_single_token(subtree),\n-        tt::TokenTree::Leaf(token) => token.into(),\n-    }\n-}\n-\n-fn expand_tt(\n-    template: &crate::TokenTree,\n-    ctx: &mut ExpandCtx,\n-) -> Result<tt::TokenTree, ExpandError> {\n+fn expand_tt(template: &crate::TokenTree, ctx: &mut ExpandCtx) -> Result<Fragment, ExpandError> {\n     let res: tt::TokenTree = match template {\n         crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, ctx)?.into(),\n         crate::TokenTree::Repeat(repeat) => {\n@@ -451,7 +440,7 @@ fn expand_tt(\n \n             // Check if it is a single token subtree without any delimiter\n             // e.g {Delimiter:None> ['>'] /Delimiter:None>}\n-            reduce_single_token(tt::Subtree { delimiter: tt::Delimiter::None, token_trees: buf })\n+            tt::Subtree { delimiter: tt::Delimiter::None, token_trees: buf }.into()\n         }\n         crate::TokenTree::Leaf(leaf) => match leaf {\n             crate::Leaf::Ident(ident) => {\n@@ -492,20 +481,15 @@ fn expand_tt(\n                     }\n                     .into()\n                 } else {\n-                    let tkn = ctx.bindings.get(&v.text, &ctx.nesting)?.clone();\n+                    let fragment = ctx.bindings.get(&v.text, &ctx.nesting)?.clone();\n                     ctx.var_expanded = true;\n-\n-                    if let tt::TokenTree::Subtree(subtree) = tkn {\n-                        reduce_single_token(subtree)\n-                    } else {\n-                        tkn\n-                    }\n+                    return Ok(fragment);\n                 }\n             }\n             crate::Leaf::Literal(l) => tt::Leaf::from(tt::Literal { text: l.text.clone() }).into(),\n         },\n     };\n-    Ok(res)\n+    Ok(Fragment::Tokens(res))\n }\n \n #[cfg(test)]\n@@ -579,10 +563,10 @@ mod tests {\n     }\n }\n \n-fn push_tt(buf: &mut Vec<tt::TokenTree>, tt: tt::TokenTree) {\n-    match tt {\n-        tt::TokenTree::Subtree(tt) => push_subtree(buf, tt),\n-        _ => buf.push(tt),\n+fn push_fragment(buf: &mut Vec<tt::TokenTree>, fragment: Fragment) {\n+    match fragment {\n+        Fragment::Tokens(tt::TokenTree::Subtree(tt)) => push_subtree(buf, tt),\n+        Fragment::Tokens(tt) | Fragment::Ast(tt) => buf.push(tt),\n     }\n }\n "}, {"sha": "0f07e935dce04e02e8679311684b36ff158e2f2b", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/753a569c79c5a4a1dd7624028cc85fa9590da53d/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753a569c79c5a4a1dd7624028cc85fa9590da53d/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=753a569c79c5a4a1dd7624028cc85fa9590da53d", "patch": "@@ -657,7 +657,6 @@ fn test_expr() {\n }\n \n #[test]\n-#[ignore]\n fn test_expr_order() {\n     let rules = create_rules(\n         r#\"\n@@ -668,9 +667,9 @@ fn test_expr_order() {\n         }\n \"#,\n     );\n-\n+    let dump = format!(\"{:#?}\", expand_to_items(&rules, \"foo! { 1 + 1  }\").syntax());\n     assert_eq_text!(\n-        &format!(\"{:#?}\", expand_to_items(&rules, \"foo! { 1 + 1  }\").syntax()),\n+        dump.trim(),\n         r#\"MACRO_ITEMS@[0; 15)\n   FN_DEF@[0; 15)\n     FN_KW@[0; 2) \"fn\""}]}