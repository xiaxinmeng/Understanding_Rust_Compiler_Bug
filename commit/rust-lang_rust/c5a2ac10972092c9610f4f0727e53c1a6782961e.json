{"sha": "c5a2ac10972092c9610f4f0727e53c1a6782961e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YTJhYzEwOTcyMDkyYzk2MTBmNGYwNzI3ZTUzYzFhNjc4Mjk2MWU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-06T21:08:09Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-14T19:27:07Z"}, "message": "rustc: Invert some rpath dependencies", "tree": {"sha": "54c5ddc2ae80563bb1e9b0929dc39c2947ad5f67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54c5ddc2ae80563bb1e9b0929dc39c2947ad5f67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5a2ac10972092c9610f4f0727e53c1a6782961e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5a2ac10972092c9610f4f0727e53c1a6782961e", "html_url": "https://github.com/rust-lang/rust/commit/c5a2ac10972092c9610f4f0727e53c1a6782961e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5a2ac10972092c9610f4f0727e53c1a6782961e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf360f328aad26bd19490270aa9716645aa4d4cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf360f328aad26bd19490270aa9716645aa4d4cf", "html_url": "https://github.com/rust-lang/rust/commit/cf360f328aad26bd19490270aa9716645aa4d4cf"}], "stats": {"total": 162, "additions": 77, "deletions": 85}, "files": [{"sha": "e08c071ff4e6249b8dbbf704d6b2b6c9a090f532", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c5a2ac10972092c9610f4f0727e53c1a6782961e/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a2ac10972092c9610f4f0727e53c1a6782961e/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=c5a2ac10972092c9610f4f0727e53c1a6782961e", "patch": "@@ -10,6 +10,7 @@\n \n use super::archive::{Archive, METADATA_FILENAME};\n use super::rpath;\n+use super::rpath::RPathConfig;\n use super::svh::Svh;\n use driver::driver::{CrateTranslation, OutputFilenames, Input, FileInput};\n use driver::config::NoDebugInfo;\n@@ -1385,7 +1386,24 @@ fn link_args(cmd: &mut Command,\n     // where extern libraries might live, based on the\n     // addl_lib_search_paths\n     if sess.opts.cg.rpath {\n-        cmd.args(rpath::get_rpath_flags(sess, out_filename).as_slice());\n+        let sysroot = sess.sysroot();\n+        let target_triple = sess.opts.target_triple.as_slice();\n+        let get_install_prefix_lib_path = || {\n+            let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n+            let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n+            let mut path = Path::new(install_prefix);\n+            path.push(&tlib);\n+\n+            path\n+        };\n+        let rpath_config = RPathConfig {\n+            os: sess.targ_cfg.os,\n+            used_crates: sess.cstore.get_used_crates(cstore::RequireDynamic),\n+            out_filename: out_filename.clone(),\n+            get_install_prefix_lib_path: get_install_prefix_lib_path,\n+            realpath: ::util::fs::realpath\n+        };\n+        cmd.args(rpath::get_rpath_flags(rpath_config).as_slice());\n     }\n \n     // compiler-rt contains implementations of low-level LLVM helpers. This is"}, {"sha": "6a133d8619abcd446f096fa7ea98e2cb9705c374", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 58, "deletions": 84, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/c5a2ac10972092c9610f4f0727e53c1a6782961e/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5a2ac10972092c9610f4f0727e53c1a6782961e/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=c5a2ac10972092c9610f4f0727e53c1a6782961e", "patch": "@@ -9,81 +9,70 @@\n // except according to those terms.\n \n \n-use driver::session::Session;\n-use metadata::cstore;\n-use metadata::filesearch;\n-use util::fs;\n-\n use std::collections::HashSet;\n use std::os;\n+use std::io::IoError;\n use syntax::abi;\n-\n-fn not_win32(os: abi::Os) -> bool {\n-  os != abi::OsWin32\n+use syntax::ast;\n+\n+pub struct RPathConfig<'a> {\n+    pub os: abi::Os,\n+    pub used_crates: Vec<(ast::CrateNum, Option<Path>)>,\n+    pub out_filename: Path,\n+    pub get_install_prefix_lib_path: ||:'a -> Path,\n+    pub realpath: |&Path|:'a -> Result<Path, IoError>\n }\n \n-pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<String> {\n-    let os = sess.targ_cfg.os;\n+pub fn get_rpath_flags(config: RPathConfig) -> Vec<String> {\n \n     // No rpath on windows\n-    if os == abi::OsWin32 {\n+    if config.os == abi::OsWin32 {\n         return Vec::new();\n     }\n \n     let mut flags = Vec::new();\n \n-    if sess.targ_cfg.os == abi::OsFreebsd {\n+    if config.os == abi::OsFreebsd {\n         flags.push_all([\"-Wl,-rpath,/usr/local/lib/gcc46\".to_string(),\n                         \"-Wl,-rpath,/usr/local/lib/gcc44\".to_string(),\n                         \"-Wl,-z,origin\".to_string()]);\n     }\n \n     debug!(\"preparing the RPATH!\");\n \n-    let sysroot = sess.sysroot();\n-    let output = out_filename;\n-    let libs = sess.cstore.get_used_crates(cstore::RequireDynamic);\n+    let libs = config.used_crates.clone();\n     let libs = libs.move_iter().filter_map(|(_, l)| {\n         l.map(|p| p.clone())\n     }).collect::<Vec<_>>();\n \n-    let rpaths = get_rpaths(os,\n-                            sysroot,\n-                            output,\n-                            libs.as_slice(),\n-                            sess.opts.target_triple.as_slice());\n+    let rpaths = get_rpaths(config, libs.as_slice());\n     flags.push_all(rpaths_to_flags(rpaths.as_slice()).as_slice());\n     flags\n }\n \n-pub fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n+fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     let mut ret = Vec::new();\n     for rpath in rpaths.iter() {\n         ret.push(format!(\"-Wl,-rpath,{}\", (*rpath).as_slice()));\n     }\n     return ret;\n }\n \n-fn get_rpaths(os: abi::Os,\n-              sysroot: &Path,\n-              output: &Path,\n-              libs: &[Path],\n-              target_triple: &str) -> Vec<String> {\n-    debug!(\"sysroot: {}\", sysroot.display());\n-    debug!(\"output: {}\", output.display());\n+fn get_rpaths(mut config: RPathConfig,\n+              libs: &[Path]) -> Vec<String> {\n+    debug!(\"output: {}\", config.out_filename.display());\n     debug!(\"libs:\");\n     for libpath in libs.iter() {\n         debug!(\"    {}\", libpath.display());\n     }\n-    debug!(\"target_triple: {}\", target_triple);\n \n     // Use relative paths to the libraries. Binaries can be moved\n     // as long as they maintain the relative relationship to the\n     // crates they depend on.\n-    let rel_rpaths = get_rpaths_relative_to_output(os, output, libs);\n+    let rel_rpaths = get_rpaths_relative_to_output(&mut config, libs);\n \n     // And a final backup rpath to the global library location.\n-    let fallback_rpaths = vec!(get_install_prefix_rpath(sysroot, target_triple));\n+    let fallback_rpaths = vec!(get_install_prefix_rpath(config));\n \n     fn log_rpaths(desc: &str, rpaths: &[String]) {\n         debug!(\"{} rpaths:\", desc);\n@@ -103,31 +92,28 @@ fn get_rpaths(os: abi::Os,\n     return rpaths;\n }\n \n-fn get_rpaths_relative_to_output(os: abi::Os,\n-                                 output: &Path,\n+fn get_rpaths_relative_to_output(config: &mut RPathConfig,\n                                  libs: &[Path]) -> Vec<String> {\n-    libs.iter().map(|a| get_rpath_relative_to_output(os, output, a)).collect()\n+    libs.iter().map(|a| get_rpath_relative_to_output(config, a)).collect()\n }\n \n-pub fn get_rpath_relative_to_output(os: abi::Os,\n-                                    output: &Path,\n-                                    lib: &Path)\n-                                 -> String {\n+fn get_rpath_relative_to_output(config: &mut RPathConfig,\n+                                lib: &Path) -> String {\n     use std::os;\n \n-    assert!(not_win32(os));\n+    assert!(config.os != abi::OsWin32);\n \n     // Mac doesn't appear to support $ORIGIN\n-    let prefix = match os {\n+    let prefix = match config.os {\n         abi::OsAndroid | abi::OsLinux | abi::OsFreebsd\n                           => \"$ORIGIN\",\n         abi::OsMacos => \"@loader_path\",\n         abi::OsWin32 | abi::OsiOS => unreachable!()\n     };\n \n-    let mut lib = fs::realpath(&os::make_absolute(lib)).unwrap();\n+    let mut lib = (config.realpath)(&os::make_absolute(lib)).unwrap();\n     lib.pop();\n-    let mut output = fs::realpath(&os::make_absolute(output)).unwrap();\n+    let mut output = (config.realpath)(&os::make_absolute(&config.out_filename)).unwrap();\n     output.pop();\n     let relative = lib.path_relative_from(&output);\n     let relative = relative.expect(\"could not create rpath relative to output\");\n@@ -137,18 +123,14 @@ pub fn get_rpath_relative_to_output(os: abi::Os,\n             relative.as_str().expect(\"non-utf8 component in path\"))\n }\n \n-pub fn get_install_prefix_rpath(sysroot: &Path, target_triple: &str) -> String {\n-    let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n-\n-    let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n-    let mut path = Path::new(install_prefix);\n-    path.push(&tlib);\n+fn get_install_prefix_rpath(config: RPathConfig) -> String {\n+    let path = (config.get_install_prefix_lib_path)();\n     let path = os::make_absolute(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     path.as_str().expect(\"non-utf8 component in rpath\").to_string()\n }\n \n-pub fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n+fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n     for rpath in rpaths.iter() {\n@@ -161,10 +143,9 @@ pub fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n \n #[cfg(unix, test)]\n mod test {\n-    use back::rpath::get_install_prefix_rpath;\n-    use back::rpath::{minimize_rpaths, rpaths_to_flags, get_rpath_relative_to_output};\n+    use super::{RPathConfig};\n+    use super::{minimize_rpaths, rpaths_to_flags, get_rpath_relative_to_output};\n     use syntax::abi;\n-    use metadata::filesearch;\n \n     #[test]\n     fn test_rpaths_to_flags() {\n@@ -177,27 +158,6 @@ mod test {\n                         \"-Wl,-rpath,path2\".to_string()));\n     }\n \n-    #[test]\n-    fn test_prefix_rpath() {\n-        let sysroot = filesearch::get_or_default_sysroot();\n-        let res = get_install_prefix_rpath(&sysroot, \"triple\");\n-        let mut d = Path::new((option_env!(\"CFG_PREFIX\")).expect(\"CFG_PREFIX\"));\n-        d.push(\"lib\");\n-        d.push(filesearch::rustlibdir());\n-        d.push(\"triple/lib\");\n-        debug!(\"test_prefix_path: {} vs. {}\",\n-               res,\n-               d.display());\n-        assert!(res.as_bytes().ends_with(d.as_vec()));\n-    }\n-\n-    #[test]\n-    fn test_prefix_rpath_abs() {\n-        let sysroot = filesearch::get_or_default_sysroot();\n-        let res = get_install_prefix_rpath(&sysroot, \"triple\");\n-        assert!(Path::new(res).is_absolute());\n-    }\n-\n     #[test]\n     fn test_minimize1() {\n         let res = minimize_rpaths([\n@@ -237,28 +197,42 @@ mod test {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     fn test_rpath_relative() {\n-      let o = abi::OsLinux;\n-      let res = get_rpath_relative_to_output(o,\n-            &Path::new(\"bin/rustc\"), &Path::new(\"lib/libstd.so\"));\n-      assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n+        let config = &mut RPathConfig {\n+            os: abi::OsLinux,\n+            used_crates: Vec::new(),\n+            out_filename: Path::new(\"bin/rustc\"),\n+            get_install_prefix_lib_path: || fail!(),\n+            realpath: |p| Ok(p.clone())\n+        };\n+        let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n+        assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n     }\n \n     #[test]\n     #[cfg(target_os = \"freebsd\")]\n     fn test_rpath_relative() {\n-        let o = abi::OsFreebsd;\n-        let res = get_rpath_relative_to_output(o,\n-            &Path::new(\"bin/rustc\"), &Path::new(\"lib/libstd.so\"));\n+        let config = &mut RPathConfig {\n+            os: abi::OsFreebsd,\n+            used_crates: Vec::new(),\n+            out_filename: Path::new(\"bin/rustc\"),\n+            get_install_prefix_lib_path: || fail!(),\n+            realpath: |p| Ok(p.clone())\n+        };\n+        let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n         assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n     }\n \n     #[test]\n     #[cfg(target_os = \"macos\")]\n     fn test_rpath_relative() {\n-        let o = abi::OsMacos;\n-        let res = get_rpath_relative_to_output(o,\n-                                               &Path::new(\"bin/rustc\"),\n-                                               &Path::new(\"lib/libstd.so\"));\n+        let config = &mut RPathConfig {\n+            os: abi::OsMacos,\n+            used_crates: Vec::new(),\n+            out_filename: Path::new(\"bin/rustc\"),\n+            get_install_prefix_lib_path: || fail!(),\n+            realpath: |p| p.clone()\n+        };\n+        let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n         assert_eq!(res.as_slice(), \"@loader_path/../lib\");\n     }\n }"}]}