{"sha": "0bc30039609e34b7df251340f71c7b3446e5a0a6", "node_id": "C_kwDOAAsO6NoAKDBiYzMwMDM5NjA5ZTM0YjdkZjI1MTM0MGY3MWM3YjM0NDZlNWEwYTY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-22T16:58:36Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-22T16:58:36Z"}, "message": "Document token up/down mapping", "tree": {"sha": "0d89c391c0f6ff3eec93babeb50e8aca236f2bff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d89c391c0f6ff3eec93babeb50e8aca236f2bff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bc30039609e34b7df251340f71c7b3446e5a0a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bc30039609e34b7df251340f71c7b3446e5a0a6", "html_url": "https://github.com/rust-lang/rust/commit/0bc30039609e34b7df251340f71c7b3446e5a0a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bc30039609e34b7df251340f71c7b3446e5a0a6/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64cb09ddea942c6cbcb28812226c5a53dceeb182", "url": "https://api.github.com/repos/rust-lang/rust/commits/64cb09ddea942c6cbcb28812226c5a53dceeb182", "html_url": "https://github.com/rust-lang/rust/commit/64cb09ddea942c6cbcb28812226c5a53dceeb182"}], "stats": {"total": 73, "additions": 52, "deletions": 21}, "files": [{"sha": "bca380a4d6f8e6c660d2f07393ed958068eb8b6b", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 52, "deletions": 21, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0bc30039609e34b7df251340f71c7b3446e5a0a6/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc30039609e34b7df251340f71c7b3446e5a0a6/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=0bc30039609e34b7df251340f71c7b3446e5a0a6", "patch": "@@ -279,6 +279,13 @@ impl HirFileId {\n     pub fn is_macro(self) -> bool {\n         matches!(self.0, HirFileIdRepr::MacroFile(_))\n     }\n+\n+    pub fn macro_file(self) -> Option<MacroFile> {\n+        match self.0 {\n+            HirFileIdRepr::FileId(_) => None,\n+            HirFileIdRepr::MacroFile(m) => Some(m),\n+        }\n+    }\n }\n \n impl MacroDefId {\n@@ -377,6 +384,8 @@ pub struct ExpansionInfo {\n \n     macro_def: Arc<TokenExpander>,\n     macro_arg: Arc<(tt::Subtree, mbe::TokenMap)>,\n+    /// A shift built from `macro_arg`'s subtree, relevant for attributes as the item is the macro arg\n+    /// and as such we need to shift tokens if they are part of an attributes input instead of their item.\n     macro_arg_shift: mbe::Shift,\n     exp_map: Arc<mbe::TokenMap>,\n }\n@@ -390,19 +399,31 @@ impl ExpansionInfo {\n         Some(self.arg.with_value(self.arg.value.parent()?))\n     }\n \n+    /// Map a token down from macro input into the macro expansion.\n+    ///\n+    /// The inner workings of this function differ slightly depending on the type of macro we are dealing with:\n+    /// - declarative:\n+    ///     For declarative macros, we need to accommodate for the macro definition site(which acts as a second unchanging input)\n+    ///     , as tokens can mapped in and out of it.\n+    ///     To do this we shift all ids in the expansion by the maximum id of the definition site giving us an easy\n+    ///     way to map all the tokens.\n+    /// - attribute:\n+    ///     Attributes have two different inputs, the input tokentree in the attribute node and the item\n+    ///     the attribute is annotating. Similarly as for declarative macros we need to do a shift here\n+    ///     as well. Currently this is done by shifting the attribute input by the maximum id of the item.\n+    /// - function-like and derives:\n+    ///     Both of these only have one simple call site input so no special handling is required here.\n     pub fn map_token_down(\n         &self,\n         db: &dyn db::AstDatabase,\n         item: Option<ast::Item>,\n         token: InFile<&SyntaxToken>,\n     ) -> Option<impl Iterator<Item = InFile<SyntaxToken>> + '_> {\n         assert_eq!(token.file_id, self.arg.file_id);\n-        let token_id = if let Some(item) = item {\n+        let token_id_in_attr_input = if let Some(item) = item {\n             // check if we are mapping down in an attribute input\n-            let call_id = match self.expanded.file_id.0 {\n-                HirFileIdRepr::FileId(_) => return None,\n-                HirFileIdRepr::MacroFile(macro_file) => macro_file.macro_call_id,\n-            };\n+            // this is a special case as attributes can have two inputs\n+            let call_id = self.expanded.file_id.macro_file()?.macro_call_id;\n             let loc = db.lookup_intern_macro_call(call_id);\n \n             let token_range = token.value.text_range();\n@@ -415,9 +436,12 @@ impl ExpansionInfo {\n                         {\n                             let attr_input_start =\n                                 token_tree.left_delimiter_token()?.text_range().start();\n-                            let range = token.value.text_range().checked_sub(attr_input_start)?;\n-                            let token_id =\n-                                self.macro_arg_shift.shift(attr_args.1.token_by_range(range)?);\n+                            let relative_range =\n+                                token.value.text_range().checked_sub(attr_input_start)?;\n+                            // shift by the item's tree's max id\n+                            let token_id = self\n+                                .macro_arg_shift\n+                                .shift(attr_args.1.token_by_range(relative_range)?);\n                             Some(token_id)\n                         }\n                         _ => None,\n@@ -429,12 +453,14 @@ impl ExpansionInfo {\n             None\n         };\n \n-        let token_id = match token_id {\n+        let token_id = match token_id_in_attr_input {\n             Some(token_id) => token_id,\n+            // the token is not inside an attribute's input so do the lookup in the macro_arg as ususal\n             None => {\n-                let range =\n+                let relative_range =\n                     token.value.text_range().checked_sub(self.arg.value.text_range().start())?;\n-                let token_id = self.macro_arg.1.token_by_range(range)?;\n+                let token_id = self.macro_arg.1.token_by_range(relative_range)?;\n+                // conditionally shift the id by a declaratives macro definition\n                 self.macro_def.map_id_down(token_id)\n             }\n         };\n@@ -447,28 +473,33 @@ impl ExpansionInfo {\n         Some(tokens.map(move |token| self.expanded.with_value(token)))\n     }\n \n+    /// Map a token up out of the expansion it resides in into the arguments of the macro call of the expansion.\n     pub fn map_token_up(\n         &self,\n         db: &dyn db::AstDatabase,\n         token: InFile<&SyntaxToken>,\n     ) -> Option<(InFile<SyntaxToken>, Origin)> {\n+        // Fetch the id through its text range,\n         let token_id = self.exp_map.token_by_range(token.value.text_range())?;\n+        // conditionally unshifting the id to accommodate for macro-rules def site\n         let (mut token_id, origin) = self.macro_def.map_id_up(token_id);\n \n-        let call_id = match self.expanded.file_id.0 {\n-            HirFileIdRepr::FileId(_) => return None,\n-            HirFileIdRepr::MacroFile(macro_file) => macro_file.macro_call_id,\n-        };\n+        let call_id = self.expanded.file_id.macro_file()?.macro_call_id;\n         let loc = db.lookup_intern_macro_call(call_id);\n \n+        // Attributes are a bit special for us, they have two inputs, the input tokentree and the annotated item.\n         let (token_map, tt) = match &loc.kind {\n-            MacroCallKind::Attr { attr_args, .. } => match self.macro_arg_shift.unshift(token_id) {\n-                Some(unshifted) => {\n-                    token_id = unshifted;\n-                    (&attr_args.1, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n+            MacroCallKind::Attr { attr_args: (_, arg_token_map), .. } => {\n+                // try unshifting the the token id, if unshifting fails, the token resides in the non-item attribute input\n+                // note that the `TokenExpander::map_id_up` earlier only unshifts for declarative macros, so we don't double unshift with this\n+                match self.macro_arg_shift.unshift(token_id) {\n+                    Some(unshifted) => {\n+                        token_id = unshifted;\n+                        (arg_token_map, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n+                    }\n+                    None => (&self.macro_arg.1, self.arg.clone()),\n                 }\n-                None => (&self.macro_arg.1, self.arg.clone()),\n-            },\n+            }\n             _ => match origin {\n                 mbe::Origin::Call => (&self.macro_arg.1, self.arg.clone()),\n                 mbe::Origin::Def => match (&*self.macro_def, &self.attr_input_or_mac_def) {"}]}