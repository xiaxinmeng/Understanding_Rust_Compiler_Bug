{"sha": "d94830830f81bde37124efd6b4c8b6c9649180e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NDgzMDgzMGY4MWJkZTM3MTI0ZWZkNmI0YzhiNmM5NjQ5MTgwZTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-27T09:40:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-05T09:36:02Z"}, "message": "Move the replacement of bound regions out from `check_arguments` and into check_call / method_resolution", "tree": {"sha": "24c6dd4a3060396985cbd57d8caf52fd6ea3fee2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24c6dd4a3060396985cbd57d8caf52fd6ea3fee2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d94830830f81bde37124efd6b4c8b6c9649180e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d94830830f81bde37124efd6b4c8b6c9649180e0", "html_url": "https://github.com/rust-lang/rust/commit/d94830830f81bde37124efd6b4c8b6c9649180e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d94830830f81bde37124efd6b4c8b6c9649180e0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1745a2cd08d1aa7437ec3d080c9ca85434b54cf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1745a2cd08d1aa7437ec3d080c9ca85434b54cf5", "html_url": "https://github.com/rust-lang/rust/commit/1745a2cd08d1aa7437ec3d080c9ca85434b54cf5"}], "stats": {"total": 220, "additions": 142, "deletions": 78}, "files": [{"sha": "7740485e82c00d0ec4f4804259e665446d93a42d", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d94830830f81bde37124efd6b4c8b6c9649180e0/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94830830f81bde37124efd6b4c8b6c9649180e0/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=d94830830f81bde37124efd6b4c8b6c9649180e0", "patch": "@@ -463,7 +463,7 @@ pub impl VisitContext {\n             expr_method_call(callee, _, _, ref args, _) => { // callee.m(args)\n                 // Implicit self is equivalent to & mode, but every\n                 // other kind should be + mode.\n-                self.use_receiver(expr.id, expr.span, callee, visitor);\n+                self.use_receiver(callee, visitor);\n                 self.use_fn_args(expr.callee_id, *args, visitor);\n             }\n \n@@ -665,7 +665,7 @@ pub impl VisitContext {\n             return false;\n         }\n \n-        self.use_receiver(expr.id, expr.span, receiver_expr, visitor);\n+        self.use_receiver(receiver_expr, visitor);\n \n         // for overloaded operatrs, we are always passing in a\n         // borrowed pointer, so it's always read mode:\n@@ -718,8 +718,6 @@ pub impl VisitContext {\n     }\n \n     fn use_receiver(&self,\n-                    _expr_id: node_id,\n-                    _span: span,\n                     receiver_expr: @expr,\n                     visitor: vt<VisitContext>)\n     {"}, {"sha": "19ffb4edc8447da0cd540ee26d91a12555a55061", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d94830830f81bde37124efd6b4c8b6c9649180e0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94830830f81bde37124efd6b4c8b6c9649180e0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d94830830f81bde37124efd6b4c8b6c9649180e0", "patch": "@@ -2726,6 +2726,16 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n     cx.node_type_substs.contains_key(&id)\n }\n \n+pub fn ty_fn_sig(fty: t) -> FnSig {\n+    match get(fty).sty {\n+        ty_bare_fn(ref f) => copy f.sig,\n+        ty_closure(ref f) => copy f.sig,\n+        ref s => {\n+            fail!(fmt!(\"ty_fn_sig() called on non-fn type: %?\", s))\n+        }\n+    }\n+}\n+\n // Type accessors for substructures of types\n pub fn ty_fn_args(fty: t) -> ~[arg] {\n     match get(fty).sty {"}, {"sha": "69d8fb495e131c0859ed3b6a9c9af76370f3f6f8", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d94830830f81bde37124efd6b4c8b6c9649180e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94830830f81bde37124efd6b4c8b6c9649180e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=d94830830f81bde37124efd6b4c8b6c9649180e0", "patch": "@@ -92,13 +92,15 @@ use middle::typeck::check;\n use middle::typeck::infer;\n use middle::typeck::{method_map_entry, method_origin, method_param};\n use middle::typeck::{method_self, method_static, method_trait, method_super};\n+use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use util::common::indenter;\n use util::ppaux::expr_repr;\n \n use core::hashmap::HashSet;\n use core::result;\n use core::uint;\n use core::vec;\n+use std::list::Nil;\n use syntax::ast::{def_id, sty_value, sty_region, sty_box};\n use syntax::ast::{sty_uniq, sty_static, node_id, by_copy, by_ref};\n use syntax::ast::{m_const, m_mutbl, m_imm};\n@@ -121,7 +123,7 @@ pub fn lookup(\n         fcx: @mut FnCtxt,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n-        expr: @ast::expr,                   // The expression `a.b`.\n+        expr: @ast::expr,                   // The expression `a.b(...)`.\n         self_expr: @ast::expr,              // The expression `a`.\n         callee_id: node_id,                 // Where to store `a.b`'s type\n         m_name: ast::ident,                 // The ident `b`.\n@@ -1092,10 +1094,16 @@ pub impl<'self> LookupContext<'self> {\n     fn confirm_candidate(&self,\n                          self_ty: ty::t,\n                          candidate: &Candidate)\n-        -> method_map_entry {\n+        -> method_map_entry\n+    {\n         let tcx = self.tcx();\n         let fty = self.fn_ty_from_origin(&candidate.origin);\n \n+        debug!(\"confirm_candidate(expr=%s, candidate=%s, fty=%s)\",\n+               expr_repr(tcx, self.expr),\n+               self.cand_to_str(candidate),\n+               self.ty_to_str(fty));\n+\n         self.enforce_trait_instance_limitations(fty, candidate);\n         self.enforce_drop_trait_limitations(candidate);\n \n@@ -1145,7 +1153,33 @@ pub impl<'self> LookupContext<'self> {\n             ../*bad*/copy candidate.rcvr_substs\n         };\n \n-        self.fcx.write_ty_substs(self.callee_id, fty, all_substs);\n+        // Compute the method type with type parameters substituted\n+        debug!(\"fty=%s all_substs=%s\",\n+               self.ty_to_str(fty),\n+               ty::substs_to_str(tcx, &all_substs));\n+        let fty = ty::subst(tcx, &all_substs, fty);\n+        debug!(\"after subst, fty=%s\", self.ty_to_str(fty));\n+\n+        // Replace any bound regions that appear in the function\n+        // signature with region variables\n+        let bare_fn_ty = match ty::get(fty).sty {\n+            ty::ty_bare_fn(ref f) => copy *f,\n+            ref s => {\n+                tcx.sess.span_bug(\n+                    self.expr.span,\n+                    fmt!(\"Invoking method with non-bare-fn ty: %?\", s));\n+            }\n+        };\n+        let (_, _, fn_sig) =\n+            replace_bound_regions_in_fn_sig(\n+                tcx, @Nil, None, &bare_fn_ty.sig,\n+                |_br| self.fcx.infcx().next_region_var(\n+                    self.expr.span, self.expr.id));\n+        let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {sig: fn_sig, ..bare_fn_ty});\n+        debug!(\"after replacing bound regions, fty=%s\", self.ty_to_str(fty));\n+\n+        self.fcx.write_ty(self.callee_id, fty);\n+        self.fcx.write_substs(self.callee_id, all_substs);\n         method_map_entry {\n             self_arg: arg {\n                 mode: ast::expl(candidate.self_mode),"}, {"sha": "32009495772171a33a9889cce948080d2a7bf047", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 93, "deletions": 71, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/d94830830f81bde37124efd6b4c8b6c9649180e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d94830830f81bde37124efd6b4c8b6c9649180e0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d94830830f81bde37124efd6b4c8b6c9649180e0", "patch": "@@ -1122,15 +1122,43 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                unifier: &fn()) {\n     debug!(\">> typechecking %s\", fcx.expr_to_str(expr));\n \n-    fn check_argument_types(\n+    fn check_method_argument_types(\n         fcx: @mut FnCtxt,\n         sp: span,\n-        call_expr_id: ast::node_id,\n-        in_fty: ty::t,\n+        method_fn_ty: ty::t,\n         callee_expr: @ast::expr,\n         args: &[@ast::expr],\n         sugar: ast::CallSugar,\n         deref_args: DerefArgs) -> ty::t\n+    {\n+        match ty::get(method_fn_ty).sty {\n+            ty::ty_bare_fn(ref fty) => {\n+                check_argument_types(fcx, sp, fty.sig.inputs, callee_expr,\n+                                     args, sugar, deref_args);\n+                fty.sig.output\n+            }\n+            ty::ty_err => {\n+                let err_inputs = err_args(fcx.tcx(), args.len());\n+                check_argument_types(fcx, sp, err_inputs, callee_expr,\n+                                     args, sugar, deref_args);\n+                method_fn_ty\n+            }\n+            _ => {\n+                fcx.tcx().sess.span_bug(\n+                    sp,\n+                    fmt!(\"Method without bare fn type\"));\n+            }\n+        }\n+    }\n+\n+    fn check_argument_types(\n+        fcx: @mut FnCtxt,\n+        sp: span,\n+        fn_inputs: &[ty::arg],\n+        callee_expr: @ast::expr,\n+        args: &[@ast::expr],\n+        sugar: ast::CallSugar,\n+        deref_args: DerefArgs)\n     {\n         /*!\n          *\n@@ -1140,59 +1168,12 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         let tcx = fcx.ccx.tcx;\n \n-        // Replace all region parameters in the arguments and return\n-        // type with fresh region variables.\n-\n-        debug!(\"check_argument_types: before universal quant., in_fty=%s\",\n-               fcx.infcx().ty_to_str(in_fty));\n-\n-        let sty = structure_of(fcx, sp, in_fty);\n-\n-        // FIXME(#3678) For now, do not permit calls to C abi functions.\n-        match sty {\n-            ty::ty_bare_fn(ty::BareFnTy {abis, _}) => {\n-                if !abis.is_rust() {\n-                    tcx.sess.span_err(\n-                        sp,\n-                        fmt!(\"Calls to C ABI functions are not (yet) \\\n-                              supported; be patient, dear user\"));\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        // Extract the function signature from `in_fty`.\n-        let sig = match sty {\n-            ty::ty_bare_fn(ty::BareFnTy {sig: sig, _}) |\n-            ty::ty_closure(ty::ClosureTy {sig: sig, _}) => sig,\n-            _ => {\n-                fcx.type_error_message(sp, |actual| {\n-                    fmt!(\"expected function but \\\n-                          found `%s`\", actual) }, in_fty, None);\n-\n-                // check each arg against \"error\", in order to set up\n-                // all the node type bindings\n-                FnSig {bound_lifetime_names: opt_vec::Empty,\n-                       inputs: args.map(|_x| ty::arg {mode: ast::expl(ast::by_copy),\n-                                                      ty: ty::mk_err(tcx)}),\n-                       output: ty::mk_err(tcx)}\n-            }\n-        };\n-\n-        // Replace any bound regions that appear in the function\n-        // signature with region variables\n-        let (_, _, sig) =\n-            replace_bound_regions_in_fn_sig(\n-                tcx, @Nil, None, &sig,\n-                |_br| fcx.infcx().next_region_var(\n-                    sp, call_expr_id));\n-\n         // Grab the argument types, supplying fresh type variables\n         // if the wrong number of arguments were supplied\n         let supplied_arg_count = args.len();\n-        let expected_arg_count = sig.inputs.len();\n+        let expected_arg_count = fn_inputs.len();\n         let formal_tys = if expected_arg_count == supplied_arg_count {\n-            sig.inputs.map(|a| a.ty)\n+            fn_inputs.map(|a| a.ty)\n         } else {\n             let suffix = match sugar {\n                 ast::NoSugar => \"\",\n@@ -1216,10 +1197,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             vec::from_elem(supplied_arg_count, ty::mk_err(tcx))\n         };\n \n-        debug!(\"check_argument_types: after universal quant., \\\n-                formal_tys=%? sig.output=%s\",\n-               formal_tys.map(|t| fcx.infcx().ty_to_str(*t)),\n-               fcx.infcx().ty_to_str(sig.output));\n+        debug!(\"check_argument_types: formal_tys=%?\",\n+               formal_tys.map(|t| fcx.infcx().ty_to_str(*t)));\n \n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n@@ -1269,8 +1248,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 }\n             }\n         }\n+    }\n \n-        sig.output\n+    fn err_args(tcx: ty::ctxt, len: uint) -> ~[ty::arg] {\n+        vec::from_fn(len, |_| ty::arg {mode: ast::expl(ast::by_copy),\n+                                       ty: ty::mk_err(tcx)})\n     }\n \n     // A generic function for checking assignment expressions\n@@ -1295,13 +1277,53 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // that they appear in call position.\n         check_expr(fcx, f);\n \n+\n+        // Extract the function signature from `in_fty`.\n+        let fn_ty = fcx.expr_ty(f);\n+        let fn_sty = structure_of(fcx, f.span, fn_ty);\n+\n+        // FIXME(#3678) For now, do not permit calls to C abi functions.\n+        match fn_sty {\n+            ty::ty_bare_fn(ty::BareFnTy {abis, _}) => {\n+                if !abis.is_rust() {\n+                    fcx.tcx().sess.span_err(\n+                        call_expr.span,\n+                        fmt!(\"Calls to C ABI functions are not (yet) \\\n+                              supported; be patient, dear user\"));\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        let fn_sig = match fn_sty {\n+            ty::ty_bare_fn(ty::BareFnTy {sig: sig, _}) |\n+            ty::ty_closure(ty::ClosureTy {sig: sig, _}) => sig,\n+            _ => {\n+                fcx.type_error_message(call_expr.span, |actual| {\n+                    fmt!(\"expected function but \\\n+                          found `%s`\", actual) }, fn_ty, None);\n+\n+                // check each arg against \"error\", in order to set up\n+                // all the node type bindings\n+                FnSig {bound_lifetime_names: opt_vec::Empty,\n+                       inputs: err_args(fcx.tcx(), args.len()),\n+                       output: ty::mk_err(fcx.tcx())}\n+            }\n+        };\n+\n+        // Replace any bound regions that appear in the function\n+        // signature with region variables\n+        let (_, _, fn_sig) =\n+            replace_bound_regions_in_fn_sig(\n+                fcx.tcx(), @Nil, None, &fn_sig,\n+                |_br| fcx.infcx().next_region_var(call_expr.span, call_expr.id));\n+\n         // Call the generic checker.\n-        let ret_ty = check_argument_types(fcx, call_expr.span, call_expr.id,\n-                                          fcx.expr_ty(f), f, args, sugar,\n-                                          DontDerefArgs);\n+        check_argument_types(fcx, call_expr.span, fn_sig.inputs, f,\n+                             args, sugar, DontDerefArgs);\n \n         // Pull the return type out of the type of the function.\n-        fcx.write_ty(call_expr.id, ret_ty);\n+        fcx.write_ty(call_expr.id, fn_sig.output);\n     }\n \n     // Checks a method call.\n@@ -1313,6 +1335,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                          tps: &[@ast::Ty],\n                          sugar: ast::CallSugar) {\n         check_expr(fcx, rcvr);\n+\n         // no need to check for bot/err -- callee does that\n         let expr_t = structurally_resolved_type(fcx,\n                                                 expr.span,\n@@ -1352,9 +1375,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // Call the generic checker.\n         let fn_ty = fcx.node_ty(expr.callee_id);\n-        let ret_ty = check_argument_types(fcx, expr.span, expr.id,\n-                                          fn_ty, expr, args, sugar,\n-                                          DontDerefArgs);\n+        let ret_ty = check_method_argument_types(fcx, expr.span,\n+                                                 fn_ty, expr, args, sugar,\n+                                                 DontDerefArgs);\n \n         // Pull the return type out of the type of the function.\n         fcx.write_ty(expr.id, ret_ty);\n@@ -1405,20 +1428,19 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 let method_ty = fcx.node_ty(op_ex.callee_id);\n                 let method_map = fcx.inh.method_map;\n                 method_map.insert(op_ex.id, *origin);\n-                check_argument_types(fcx, op_ex.span,\n-                                     op_ex.id, method_ty,\n-                                     op_ex, args,\n-                                     ast::NoSugar, deref_args)\n+                check_method_argument_types(fcx, op_ex.span,\n+                                            method_ty, op_ex, args,\n+                                            ast::NoSugar, deref_args)\n             }\n             _ => {\n                 let tcx = fcx.tcx();\n                 unbound_method();\n                 // Check the args anyway\n                 // so we get all the error messages\n                 let expected_ty = ty::mk_err(tcx);\n-                check_argument_types(fcx, op_ex.span, op_ex.id,\n-                                     expected_ty, op_ex, args,\n-                                     ast::NoSugar, deref_args);\n+                check_method_argument_types(fcx, op_ex.span,\n+                                            expected_ty, op_ex, args,\n+                                            ast::NoSugar, deref_args);\n                 ty::mk_err(tcx)\n             }\n         }"}]}