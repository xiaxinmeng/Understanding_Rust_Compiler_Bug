{"sha": "77447deb2184d618abb26a16fde43d153f85c3b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3NDQ3ZGViMjE4NGQ2MThhYmIyNmExNmZkZTQzZDE1M2Y4NWMzYjg=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-03-08T01:14:01Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-01T22:10:05Z"}, "message": "Add const_variable.rs\n\nCo-Authored-By: Gabriel Smith <yodaldevoid@users.noreply.github.com>", "tree": {"sha": "f640ebe54a08a5482de40cd1a10c27de39f54202", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f640ebe54a08a5482de40cd1a10c27de39f54202"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77447deb2184d618abb26a16fde43d153f85c3b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77447deb2184d618abb26a16fde43d153f85c3b8", "html_url": "https://github.com/rust-lang/rust/commit/77447deb2184d618abb26a16fde43d153f85c3b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77447deb2184d618abb26a16fde43d153f85c3b8/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "225472748094e4cb8b1628579d3e1f0c77f209ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/225472748094e4cb8b1628579d3e1f0c77f209ff", "html_url": "https://github.com/rust-lang/rust/commit/225472748094e4cb8b1628579d3e1f0c77f209ff"}], "stats": {"total": 242, "additions": 242, "deletions": 0}, "files": [{"sha": "5691bf08eae1cdb6e8625b4e6671d7fbf8888077", "filename": "src/librustc/infer/const_variable.rs", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/77447deb2184d618abb26a16fde43d153f85c3b8/src%2Flibrustc%2Finfer%2Fconst_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77447deb2184d618abb26a16fde43d153f85c3b8/src%2Flibrustc%2Finfer%2Fconst_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fconst_variable.rs?ref=77447deb2184d618abb26a16fde43d153f85c3b8", "patch": "@@ -0,0 +1,242 @@\n+use crate::mir::interpret::ConstValue;\n+use syntax::symbol::InternedString;\n+use syntax_pos::Span;\n+use crate::ty::{self, InferConst};\n+\n+use std::cmp;\n+use std::marker::PhantomData;\n+use rustc_data_structures::snapshot_vec as sv;\n+use rustc_data_structures::unify as ut;\n+\n+pub struct ConstVariableTable<'tcx> {\n+    values: sv::SnapshotVec<Delegate<'tcx>>,\n+\n+    relations: ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>,\n+}\n+\n+/// Reasons to create a const inference variable\n+#[derive(Copy, Clone, Debug)]\n+pub enum ConstVariableOrigin {\n+    MiscVariable(Span),\n+    ConstInference(Span),\n+    ConstParameterDefinition(Span, InternedString),\n+    SubstitutionPlaceholder(Span),\n+}\n+\n+struct ConstVariableData {\n+    origin: ConstVariableOrigin,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum ConstVariableValue<'tcx> {\n+    Known { value: &'tcx ty::LazyConst<'tcx> },\n+    Unknown { universe: ty::UniverseIndex },\n+}\n+\n+impl<'tcx> ConstVariableValue<'tcx> {\n+    /// If this value is known, returns the const it is known to be.\n+    /// Otherwise, `None`.\n+    pub fn known(&self) -> Option<&'tcx ty::LazyConst<'tcx>> {\n+        match *self {\n+            ConstVariableValue::Unknown { .. } => None,\n+            ConstVariableValue::Known { value } => Some(value),\n+        }\n+    }\n+\n+    pub fn is_unknown(&self) -> bool {\n+        match *self {\n+            ConstVariableValue::Unknown { .. } => true,\n+            ConstVariableValue::Known { .. } => false,\n+        }\n+    }\n+}\n+\n+pub struct Snapshot<'tcx> {\n+    snapshot: sv::Snapshot,\n+    relation_snapshot: ut::Snapshot<ut::InPlace<ty::ConstVid<'tcx>>>,\n+}\n+\n+struct Instantiate<'tcx> {\n+    _vid: ty::ConstVid<'tcx>,\n+}\n+\n+struct Delegate<'tcx> {\n+    pub phantom: PhantomData<&'tcx ()>,\n+}\n+\n+impl<'tcx> ConstVariableTable<'tcx> {\n+    pub fn new() -> ConstVariableTable<'tcx> {\n+        ConstVariableTable {\n+            values: sv::SnapshotVec::new(),\n+            relations: ut::UnificationTable::new(),\n+        }\n+    }\n+\n+    /// Returns the origin that was given when `vid` was created.\n+    ///\n+    /// Note that this function does not return care whether\n+    /// `vid` has been unified with something else or not.\n+    pub fn var_origin(&self, vid: ty::ConstVid<'tcx>) -> &ConstVariableOrigin {\n+        &self.values[vid.index as usize].origin\n+    }\n+\n+    pub fn unify_var_var(\n+        &mut self,\n+        a_id: ty::ConstVid<'tcx>,\n+        b_id: ty::ConstVid<'tcx>,\n+    ) -> Result<(), (&'tcx ty::LazyConst<'tcx>, &'tcx ty::LazyConst<'tcx>)> {\n+        self.relations.unify_var_var(a_id, b_id)\n+    }\n+\n+    pub fn unify_var_value(\n+        &mut self,\n+        a_id: ty::ConstVid<'tcx>,\n+        b: ConstVariableValue<'tcx>,\n+    ) -> Result<(), (&'tcx ty::LazyConst<'tcx>, &'tcx ty::LazyConst<'tcx>)> {\n+        self.relations.unify_var_value(a_id, b)\n+    }\n+\n+    /// Creates a new const variable.\n+    ///\n+    /// - `origin`: indicates *why* the const variable was created.\n+    ///   The code in this module doesn't care, but it can be useful\n+    ///   for improving error messages.\n+    pub fn new_var(\n+        &mut self,\n+        universe: ty::UniverseIndex,\n+        origin: ConstVariableOrigin,\n+    ) -> ty::ConstVid<'tcx> {\n+        let vid = self.relations.new_key(ConstVariableValue::Unknown{ universe });\n+\n+        let index = self.values.push(ConstVariableData {\n+            origin,\n+        });\n+        assert_eq!(vid.index, index as u32);\n+\n+        debug!(\"new_var(index={:?}, origin={:?}\", vid, origin);\n+\n+        vid\n+    }\n+\n+    /// Retrieves the type to which `vid` has been instantiated, if\n+    /// any.\n+    pub fn probe(\n+        &mut self,\n+        vid: ty::ConstVid<'tcx>\n+    ) -> ConstVariableValue<'tcx> {\n+        self.relations.probe_value(vid)\n+    }\n+\n+    /// If `t` is a type-inference variable, and it has been\n+    /// instantiated, then return the with which it was\n+    /// instantiated. Otherwise, returns `t`.\n+    pub fn replace_if_possible(\n+        &mut self,\n+        c: &'tcx ty::LazyConst<'tcx>\n+    ) -> &'tcx ty::LazyConst<'tcx> {\n+        if let ty::LazyConst::Evaluated(ty::Const {\n+            val: ConstValue::Infer(InferConst::Var(vid)),\n+            ..\n+        }) = c {\n+            match self.probe(*vid).known() {\n+                Some(c) => c,\n+                None => c,\n+            }\n+        } else {\n+            c\n+        }\n+    }\n+\n+    /// Creates a snapshot of the type variable state.  This snapshot\n+    /// must later be committed (`commit()`) or rolled back\n+    /// (`rollback_to()`).  Nested snapshots are permitted, but must\n+    /// be processed in a stack-like fashion.\n+    pub fn snapshot(&mut self) -> Snapshot<'tcx> {\n+        Snapshot {\n+            snapshot: self.values.start_snapshot(),\n+            relation_snapshot: self.relations.snapshot(),\n+        }\n+    }\n+\n+    /// Undoes all changes since the snapshot was created. Any\n+    /// snapshots created since that point must already have been\n+    /// committed or rolled back.\n+    pub fn rollback_to(&mut self, s: Snapshot<'tcx>) {\n+        debug!(\"rollback_to{:?}\", {\n+            for action in self.values.actions_since_snapshot(&s.snapshot) {\n+                if let sv::UndoLog::NewElem(index) = *action {\n+                    debug!(\"inference variable _#{}t popped\", index)\n+                }\n+            }\n+        });\n+\n+        let Snapshot { snapshot, relation_snapshot } = s;\n+        self.values.rollback_to(snapshot);\n+        self.relations.rollback_to(relation_snapshot);\n+    }\n+\n+    /// Commits all changes since the snapshot was created, making\n+    /// them permanent (unless this snapshot was created within\n+    /// another snapshot). Any snapshots created since that point\n+    /// must already have been committed or rolled back.\n+    pub fn commit(&mut self, s: Snapshot<'tcx>) {\n+        let Snapshot { snapshot, relation_snapshot } = s;\n+        self.values.commit(snapshot);\n+        self.relations.commit(relation_snapshot);\n+    }\n+}\n+\n+impl<'tcx> ut::UnifyKey for ty::ConstVid<'tcx> {\n+    type Value = ConstVariableValue<'tcx>;\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> Self { ty::ConstVid { index: i, phantom: PhantomData } }\n+    fn tag() -> &'static str { \"ConstVid\" }\n+}\n+\n+impl<'tcx> ut::UnifyValue for ConstVariableValue<'tcx> {\n+    type Error = (&'tcx ty::LazyConst<'tcx>, &'tcx ty::LazyConst<'tcx>);\n+\n+    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, Self::Error> {\n+        match (value1, value2) {\n+            (\n+                &ConstVariableValue::Known { value: value1 },\n+                &ConstVariableValue::Known { value: value2 }\n+            ) => {\n+                match <&'tcx ty::LazyConst<'tcx>>::unify_values(&value1, &value2) {\n+                    Ok(value) => Ok(ConstVariableValue::Known { value }),\n+                    Err(err) => Err(err),\n+                }\n+            }\n+\n+            // If one side is known, prefer that one.\n+            (&ConstVariableValue::Known { .. }, &ConstVariableValue::Unknown { .. }) => Ok(*value1),\n+            (&ConstVariableValue::Unknown { .. }, &ConstVariableValue::Known { .. }) => Ok(*value2),\n+\n+            // If both sides are *unknown*, it hardly matters, does it?\n+            (&ConstVariableValue::Unknown { universe: universe1 },\n+             &ConstVariableValue::Unknown { universe: universe2 }) =>  {\n+                // If we unify two unbound variables, ?T and ?U, then whatever\n+                // value they wind up taking (which must be the same value) must\n+                // be nameable by both universes. Therefore, the resulting\n+                // universe is the minimum of the two universes, because that is\n+                // the one which contains the fewest names in scope.\n+                let universe = cmp::min(universe1, universe2);\n+                Ok(ConstVariableValue::Unknown { universe })\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> ut::EqUnifyValue for &'tcx ty::LazyConst<'tcx> {}\n+\n+impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n+    type Value = ConstVariableData;\n+    type Undo = Instantiate<'tcx>;\n+\n+    fn reverse(_values: &mut Vec<ConstVariableData>, _action: Instantiate<'tcx>) {\n+        // We don't actually have to *do* anything to reverse an\n+        // instantiation; the value for a variable is stored in the\n+        // `relations` and hence its rollback code will handle\n+        // it.\n+    }\n+}"}]}