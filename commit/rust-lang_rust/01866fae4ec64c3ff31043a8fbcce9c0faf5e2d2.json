{"sha": "01866fae4ec64c3ff31043a8fbcce9c0faf5e2d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxODY2ZmFlNGVjNjRjM2ZmMzEwNDNhOGZiY2NlOWMwZmFmNWUyZDI=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-24T23:58:05Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-24T23:59:03Z"}, "message": "Document task shutdown protocol and justify its concurrency safety. Close #2696. Close bblum's internship.", "tree": {"sha": "305c3a18639385e80746016bb8a80cb4c06ac632", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/305c3a18639385e80746016bb8a80cb4c06ac632"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01866fae4ec64c3ff31043a8fbcce9c0faf5e2d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01866fae4ec64c3ff31043a8fbcce9c0faf5e2d2", "html_url": "https://github.com/rust-lang/rust/commit/01866fae4ec64c3ff31043a8fbcce9c0faf5e2d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01866fae4ec64c3ff31043a8fbcce9c0faf5e2d2/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ebea76394afa5b864617889c41f3375f72e2980", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ebea76394afa5b864617889c41f3375f72e2980", "html_url": "https://github.com/rust-lang/rust/commit/5ebea76394afa5b864617889c41f3375f72e2980"}], "stats": {"total": 83, "additions": 76, "deletions": 7}, "files": [{"sha": "d815841879323bb774d2915bcb4bbc3152814050", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 76, "deletions": 7, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/01866fae4ec64c3ff31043a8fbcce9c0faf5e2d2/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/01866fae4ec64c3ff31043a8fbcce9c0faf5e2d2/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=01866fae4ec64c3ff31043a8fbcce9c0faf5e2d2", "patch": "@@ -12,17 +12,86 @@\n    * Switching between running Rust code on the Rust segmented stack and\n    foreign C code on large stacks owned by the scheduler\n \n+   # Lifetime\n+\n    The lifetime of a rust_task object closely mirrors that of a running Rust\n    task object, but they are not identical. In particular, the rust_task is an\n    atomically reference counted object that might be accessed from arbitrary\n    threads at any time. This may keep the task from being destroyed even after\n-   the task is dead from a Rust task lifecycle perspective.\n-\n-   FIXME (#2696): The task and the scheduler have an over-complicated,\n-   undocumented protocol for shutting down the task, hopefully without\n-   races. It would be easier to reason about if other runtime objects could\n-   not access the task from arbitrary threads, and didn't need to be\n-   atomically refcounted.\n+   the task is dead from a Rust task lifecycle perspective. The rust_tasks are\n+   reference counted in the following places:\n+\n+   * By the task's lifetime (i.e., running tasks hold a reference to themself)\n+\n+   * In the rust_task_kill_all -> rust_kernel::fail ->\n+     rust_sched_loop::kill_all_tasks path. When a task brings down the whole\n+     runtime, each sched_loop must use refcounts to take a 'snapshot' of all\n+     existing tasks so it can be sure to kill all of them.\n+\n+   * In core::pipes, tasks that use select() use reference counts to avoid\n+     use-after-free races with multiple different signallers.\n+\n+   # Death\n+\n+   All task death goes through a single central path: The task invokes\n+   rust_task::die(), which invokes transition(task_state_dead), which pumps\n+   the scheduler loop, which switches to rust_sched_loop::run_single_turn(),\n+   which calls reap_dead_tasks(), which cleans up the task's stack segments\n+   and drops the reference count.\n+\n+   When a task's reference count hits zero, rust_sched_loop::release_task()\n+   is called. This frees the memory and deregisters the task from the kernel,\n+   which may trigger the sched_loop, the scheduler, and/or the kernel to exit\n+   completely in the case it was the last task alive.\n+\n+   die() is called from two places: the successful exit path, in cleanup_task,\n+   and on failure (on linux, this is also in cleanup_task, after unwinding\n+   completes; on windows, it is in begin_failure).\n+\n+   Tasks do not force-quit other tasks; a task die()s only itself. However...\n+\n+   # Killing\n+\n+   Tasks may kill each other. This happens when propagating failure between\n+   tasks (see the task::spawn options interface). The code path for this is\n+   rust_task_kill_other() -> rust_task::kill().\n+\n+   It also happens when the main (\"root\") task (or any task in that task's\n+   linked-failure-group) fails: this brings down the whole runtime, and kills\n+   all tasks in all groups. The code path for this is rust_task_kill_all() ->\n+   rust_kernel::fail() -> rust_scheduler::kill_all_tasks() ->\n+   rust_sched_loop::kill_all_tasks() -> rust_task::kill().\n+\n+   In either case, killing a task involves, under the protection of its\n+   lifecycle_lock, (a) setting the 'killed' flag, and (b) checking if it is\n+   'blocked'* and if so punting it awake.\n+   (* and also isn't unkillable, which may happen via task::unkillable()\n+   or via calling an extern rust function from C.)\n+\n+   The killed task will then (wake up if it was asleep, and) eventually call\n+   yield() (or wait_event()), which will check the killed flag, see that it is\n+   true, and then invoke 'fail', which begins the death process described\n+   above.\n+\n+   Three things guarantee concurrency safety in this whole affair:\n+\n+   * The lifecycle_lock protects tasks accessing each other's state: it makes\n+     killing-and-waking up atomic with respect to a task in block() deciding\n+     whether it's allowed to go to sleep, so tasks can't 'escape' being woken.\n+\n+   * In the case of linked failure propagation, we ensure (in task.rs) that\n+     tasks can only see another task's rust_task pointer if that task is\n+     already alive. Even before entering the runtime failure path, a task will\n+     access (locked) the linked-failure data structures to remove its task\n+     pointer so that no subsequently-failing tasks will do a use-after-free.\n+\n+   * In the case of bringing down the whole runtime, each sched_loop takes an\n+     \"atomic snapshot\" of all its tasks, protected by the sched_loop's lock,\n+     and also sets a 'failing' flag so that any subsequently-failing task will\n+     know that it must fail immediately upon creation (which is also checked\n+     under the same lock). A similar process exists at the one-step-higher\n+     level of the kernel killing all the schedulers (the kernel snapshots all\n+     the schedulers and sets a 'failing' flag in the scheduler table).\n  */\n \n #ifndef RUST_TASK_H"}]}