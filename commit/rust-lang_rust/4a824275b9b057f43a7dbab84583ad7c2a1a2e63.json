{"sha": "4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhODI0Mjc1YjliMDU3ZjQzYTdkYmFiODQ1ODNhZDdjMmExYTJlNjM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-09T07:14:20Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-10T16:06:21Z"}, "message": "trans: Use LLVM's writeArchive to modify archives\n\nWe have previously always relied upon an external tool, `ar`, to modify archives\nthat the compiler produces (staticlibs, rlibs, etc). This approach, however, has\na number of downsides:\n\n* Spawning a process is relatively expensive for small compilations\n* Encoding arguments across process boundaries often incurs unnecessary overhead\n  or lossiness. For example `ar` has a tough time dealing with files that have\n  the same name in archives, and the compiler copies many files around to ensure\n  they can be passed to `ar` in a reasonable fashion.\n* Most `ar` programs found do **not** have the ability to target arbitrary\n  platforms, so this is an extra tool which needs to be found/specified when\n  cross compiling.\n\nThe LLVM project has had a tool called `llvm-ar` for quite some time now, but it\nwasn't available in the standard LLVM libraries (it was just a standalone\nprogram). Recently, however, in LLVM 3.7, this functionality has been moved to a\nlibrary and is now accessible by consumers of LLVM via the `writeArchive`\nfunction.\n\nThis commit migrates our archive bindings to no longer invoke `ar` by default\nbut instead make a library call to LLVM to do various operations. This solves\nall of the downsides listed above:\n\n* Archive management is now much faster, for example creating a \"hello world\"\n  staticlib is now 6x faster (50ms => 8ms). Linking dynamic libraries also\n  recently started requiring modification of rlibs, and linking a hello world\n  dynamic library is now 2x faster.\n* The compiler is now one step closer to \"hassle free\" cross compilation because\n  no external tool is needed for managing archives, LLVM does the right thing!\n\nThis commit does not remove support for calling a system `ar` utility currently.\nWe will continue to maintain compatibility with LLVM 3.5 and 3.6 looking forward\n(so the system LLVM can be used wherever possible), and in these cases we must\nshell out to a system utility. All nightly builds of Rust, however, will stop\nneeding a system `ar`.", "tree": {"sha": "ba350349b3be436db5347c69264079b0b8d5df52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba350349b3be436db5347c69264079b0b8d5df52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "html_url": "https://github.com/rust-lang/rust/commit/4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66b9277b1364b130aed260ac219c1fe58eb02df2", "url": "https://api.github.com/repos/rust-lang/rust/commits/66b9277b1364b130aed260ac219c1fe58eb02df2", "html_url": "https://github.com/rust-lang/rust/commit/66b9277b1364b130aed260ac219c1fe58eb02df2"}], "stats": {"total": 1339, "additions": 788, "deletions": 551}, "files": [{"sha": "6adffda7d1b322ab10f5c7a9e83a73f13a8c5aad", "filename": "mk/rustllvm.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/mk%2Frustllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/mk%2Frustllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frustllvm.mk?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -24,7 +24,8 @@ LLVM_EXTRA_INCDIRS_$(1)= $$(call CFG_CC_INCLUDE_$(1),$(S)src/llvm/include) \\\n endif\n \n RUSTLLVM_OBJS_CS_$(1) := $$(addprefix rustllvm/, \\\n-\tExecutionEngineWrapper.cpp RustWrapper.cpp PassWrapper.cpp)\n+\tExecutionEngineWrapper.cpp RustWrapper.cpp PassWrapper.cpp \\\n+\tArchiveWrapper.cpp)\n \n RUSTLLVM_INCS_$(1) = $$(LLVM_EXTRA_INCDIRS_$(1)) \\\n                      $$(call CFG_CC_INCLUDE_$(1),$$(LLVM_INCDIR_$(1))) \\"}, {"sha": "732b77a626e88053381857c200484007e05b64ea", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -99,7 +99,6 @@ pub mod diagnostics;\n \n pub mod back {\n     pub use rustc_back::abi;\n-    pub use rustc_back::archive;\n     pub use rustc_back::arm;\n     pub use rustc_back::mips;\n     pub use rustc_back::mipsel;"}, {"sha": "81acaf66e08fcf742fa4376d9b36afdabaaa431a", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -212,7 +212,6 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::loader or metadata::creader for all the juicy details!\n \n-use back::archive::METADATA_FILENAME;\n use back::svh::Svh;\n use session::Session;\n use session::search_paths::PathKind;\n@@ -280,6 +279,8 @@ pub struct CratePaths {\n     pub rlib: Option<PathBuf>\n }\n \n+pub const METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n+\n impl CratePaths {\n     fn paths(&self) -> Vec<PathBuf> {\n         match (&self.dylib, &self.rlib) {"}, {"sha": "c7968db4733a2ace8be070c155a16e5f8ecc6a04", "filename": "src/librustc_back/archive.rs", "status": "removed", "additions": 0, "deletions": 361, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/66b9277b1364b130aed260ac219c1fe58eb02df2/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66b9277b1364b130aed260ac219c1fe58eb02df2/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=66b9277b1364b130aed260ac219c1fe58eb02df2", "patch": "@@ -1,361 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A helper class for dealing with static archives\n-\n-use std::env;\n-use std::ffi::OsString;\n-use std::fs::{self, File};\n-use std::io::prelude::*;\n-use std::io;\n-use std::path::{Path, PathBuf};\n-use std::process::{Command, Output, Stdio};\n-use std::str;\n-use syntax::diagnostic::Handler as ErrorHandler;\n-use rustc_llvm::archive_ro::ArchiveRO;\n-\n-use tempdir::TempDir;\n-\n-pub const METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n-\n-pub struct ArchiveConfig<'a> {\n-    pub handler: &'a ErrorHandler,\n-    pub dst: PathBuf,\n-    pub lib_search_paths: Vec<PathBuf>,\n-    pub slib_prefix: String,\n-    pub slib_suffix: String,\n-    pub ar_prog: String,\n-    pub command_path: OsString,\n-}\n-\n-pub struct Archive<'a> {\n-    config: ArchiveConfig<'a>,\n-}\n-\n-/// Helper for adding many files to an archive with a single invocation of\n-/// `ar`.\n-#[must_use = \"must call build() to finish building the archive\"]\n-pub struct ArchiveBuilder<'a> {\n-    archive: Archive<'a>,\n-    work_dir: TempDir,\n-    /// Filename of each member that should be added to the archive.\n-    members: Vec<PathBuf>,\n-    should_update_symbols: bool,\n-}\n-\n-enum Action<'a> {\n-    Remove(&'a Path),\n-    AddObjects(&'a [&'a PathBuf], bool),\n-    UpdateSymbols,\n-}\n-\n-pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n-                    search_paths: &[PathBuf],\n-                    handler: &ErrorHandler) -> PathBuf {\n-    // On Windows, static libraries sometimes show up as libfoo.a and other\n-    // times show up as foo.lib\n-    let oslibname = format!(\"{}{}{}\", osprefix, name, ossuffix);\n-    let unixlibname = format!(\"lib{}.a\", name);\n-\n-    for path in search_paths {\n-        debug!(\"looking for {} inside {:?}\", name, path);\n-        let test = path.join(&oslibname[..]);\n-        if test.exists() { return test }\n-        if oslibname != unixlibname {\n-            let test = path.join(&unixlibname[..]);\n-            if test.exists() { return test }\n-        }\n-    }\n-    handler.fatal(&format!(\"could not find native static library `{}`, \\\n-                           perhaps an -L flag is missing?\",\n-                          name));\n-}\n-\n-impl<'a> Archive<'a> {\n-    fn new(config: ArchiveConfig<'a>) -> Archive<'a> {\n-        Archive { config: config }\n-    }\n-\n-    /// Opens an existing static archive\n-    pub fn open(config: ArchiveConfig<'a>) -> Archive<'a> {\n-        let archive = Archive::new(config);\n-        assert!(archive.config.dst.exists());\n-        archive\n-    }\n-\n-    /// Removes a file from this archive\n-    pub fn remove_file(&mut self, file: &str) {\n-        self.run(None, Action::Remove(Path::new(file)));\n-    }\n-\n-    /// Lists all files in an archive\n-    pub fn files(&self) -> Vec<String> {\n-        let archive = match ArchiveRO::open(&self.config.dst) {\n-            Some(ar) => ar,\n-            None => return Vec::new(),\n-        };\n-        let ret = archive.iter().filter_map(|child| child.name())\n-                         .map(|name| name.to_string())\n-                         .collect();\n-        return ret;\n-    }\n-\n-    /// Creates an `ArchiveBuilder` for adding files to this archive.\n-    pub fn extend(self) -> ArchiveBuilder<'a> {\n-        ArchiveBuilder::new(self)\n-    }\n-\n-    fn run(&self, cwd: Option<&Path>, action: Action) -> Output {\n-        let abs_dst = env::current_dir().unwrap().join(&self.config.dst);\n-        let ar = &self.config.ar_prog;\n-        let mut cmd = Command::new(ar);\n-        cmd.env(\"PATH\", &self.config.command_path);\n-        cmd.stdout(Stdio::piped()).stderr(Stdio::piped());\n-        self.prepare_ar_action(&mut cmd, &abs_dst, action);\n-        info!(\"{:?}\", cmd);\n-\n-        if let Some(p) = cwd {\n-            cmd.current_dir(p);\n-            info!(\"inside {:?}\", p.display());\n-        }\n-\n-        let handler = &self.config.handler;\n-        match cmd.spawn() {\n-            Ok(prog) => {\n-                let o = prog.wait_with_output().unwrap();\n-                if !o.status.success() {\n-                    handler.err(&format!(\"{:?} failed with: {}\", cmd, o.status));\n-                    handler.note(&format!(\"stdout ---\\n{}\",\n-                                          str::from_utf8(&o.stdout).unwrap()));\n-                    handler.note(&format!(\"stderr ---\\n{}\",\n-                                          str::from_utf8(&o.stderr).unwrap()));\n-                    handler.abort_if_errors();\n-                }\n-                o\n-            },\n-            Err(e) => {\n-                handler.err(&format!(\"could not exec `{}`: {}\",\n-                                     self.config.ar_prog, e));\n-                handler.abort_if_errors();\n-                panic!(\"rustc::back::archive::run() should not reach this point\");\n-            }\n-        }\n-    }\n-\n-    fn prepare_ar_action(&self, cmd: &mut Command, dst: &Path, action: Action) {\n-        match action {\n-            Action::Remove(file) => {\n-                cmd.arg(\"d\").arg(dst).arg(file);\n-            }\n-            Action::AddObjects(objs, update_symbols) => {\n-                cmd.arg(if update_symbols {\"crs\"} else {\"crS\"})\n-                   .arg(dst)\n-                   .args(objs);\n-            }\n-            Action::UpdateSymbols => {\n-                cmd.arg(\"s\").arg(dst);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a> ArchiveBuilder<'a> {\n-    fn new(archive: Archive<'a>) -> ArchiveBuilder<'a> {\n-        ArchiveBuilder {\n-            archive: archive,\n-            work_dir: TempDir::new(\"rsar\").unwrap(),\n-            members: vec![],\n-            should_update_symbols: false,\n-        }\n-    }\n-\n-    /// Create a new static archive, ready for adding files.\n-    pub fn create(config: ArchiveConfig<'a>) -> ArchiveBuilder<'a> {\n-        let archive = Archive::new(config);\n-        ArchiveBuilder::new(archive)\n-    }\n-\n-    /// Adds all of the contents of a native library to this archive. This will\n-    /// search in the relevant locations for a library named `name`.\n-    pub fn add_native_library(&mut self, name: &str) -> io::Result<()> {\n-        let location = find_library(name,\n-                                    &self.archive.config.slib_prefix,\n-                                    &self.archive.config.slib_suffix,\n-                                    &self.archive.config.lib_search_paths,\n-                                    self.archive.config.handler);\n-        self.add_archive(&location, name, |_| false)\n-    }\n-\n-    /// Adds all of the contents of the rlib at the specified path to this\n-    /// archive.\n-    ///\n-    /// This ignores adding the bytecode from the rlib, and if LTO is enabled\n-    /// then the object file also isn't added.\n-    pub fn add_rlib(&mut self, rlib: &Path, name: &str,\n-                    lto: bool) -> io::Result<()> {\n-        // Ignoring obj file starting with the crate name\n-        // as simple comparison is not enough - there\n-        // might be also an extra name suffix\n-        let obj_start = format!(\"{}\", name);\n-        let obj_start = &obj_start[..];\n-        // Ignoring all bytecode files, no matter of\n-        // name\n-        let bc_ext = \".bytecode.deflate\";\n-\n-        self.add_archive(rlib, &name[..], |fname: &str| {\n-            let skip_obj = lto && fname.starts_with(obj_start)\n-                && fname.ends_with(\".o\");\n-            skip_obj || fname.ends_with(bc_ext) || fname == METADATA_FILENAME\n-        })\n-    }\n-\n-    /// Adds an arbitrary file to this archive\n-    pub fn add_file(&mut self, file: &Path) -> io::Result<()> {\n-        let filename = Path::new(file.file_name().unwrap());\n-        let new_file = self.work_dir.path().join(&filename);\n-        try!(fs::copy(file, &new_file));\n-        self.members.push(filename.to_path_buf());\n-        Ok(())\n-    }\n-\n-    /// Indicate that the next call to `build` should updates all symbols in\n-    /// the archive (run 'ar s' over it).\n-    pub fn update_symbols(&mut self) {\n-        self.should_update_symbols = true;\n-    }\n-\n-    /// Combine the provided files, rlibs, and native libraries into a single\n-    /// `Archive`.\n-    pub fn build(self) -> Archive<'a> {\n-        // Get an absolute path to the destination, so `ar` will work even\n-        // though we run it from `self.work_dir`.\n-        let mut objects = Vec::new();\n-        let mut total_len = self.archive.config.dst.to_string_lossy().len();\n-\n-        if self.members.is_empty() {\n-            if self.should_update_symbols {\n-                self.archive.run(Some(self.work_dir.path()),\n-                                 Action::UpdateSymbols);\n-            }\n-            return self.archive;\n-        }\n-\n-        // Don't allow the total size of `args` to grow beyond 32,000 bytes.\n-        // Windows will raise an error if the argument string is longer than\n-        // 32,768, and we leave a bit of extra space for the program name.\n-        const ARG_LENGTH_LIMIT: usize = 32_000;\n-\n-        for member_name in &self.members {\n-            let len = member_name.to_string_lossy().len();\n-\n-            // `len + 1` to account for the space that's inserted before each\n-            // argument.  (Windows passes command-line arguments as a single\n-            // string, not an array of strings.)\n-            if total_len + len + 1 > ARG_LENGTH_LIMIT {\n-                // Add the archive members seen so far, without updating the\n-                // symbol table.\n-                self.archive.run(Some(self.work_dir.path()),\n-                                 Action::AddObjects(&objects, false));\n-\n-                objects.clear();\n-                total_len = self.archive.config.dst.to_string_lossy().len();\n-            }\n-\n-            objects.push(member_name);\n-            total_len += len + 1;\n-        }\n-\n-        // Add the remaining archive members, and update the symbol table if\n-        // necessary.\n-        self.archive.run(Some(self.work_dir.path()),\n-                         Action::AddObjects(&objects, self.should_update_symbols));\n-\n-        self.archive\n-    }\n-\n-    fn add_archive<F>(&mut self, archive: &Path, name: &str,\n-                      mut skip: F) -> io::Result<()>\n-        where F: FnMut(&str) -> bool,\n-    {\n-        let archive = match ArchiveRO::open(archive) {\n-            Some(ar) => ar,\n-            None => return Err(io::Error::new(io::ErrorKind::Other,\n-                                              \"failed to open archive\")),\n-        };\n-\n-        // Next, we must rename all of the inputs to \"guaranteed unique names\".\n-        // We write each file into `self.work_dir` under its new unique name.\n-        // The reason for this renaming is that archives are keyed off the name\n-        // of the files, so if two files have the same name they will override\n-        // one another in the archive (bad).\n-        //\n-        // We skip any files explicitly desired for skipping, and we also skip\n-        // all SYMDEF files as these are just magical placeholders which get\n-        // re-created when we make a new archive anyway.\n-        for file in archive.iter() {\n-            let filename = match file.name() {\n-                Some(s) => s,\n-                None => continue,\n-            };\n-            if filename.contains(\".SYMDEF\") { continue }\n-            if skip(filename) { continue }\n-            let filename = Path::new(filename).file_name().unwrap()\n-                                              .to_str().unwrap();\n-\n-            // Archives on unix systems typically do not have slashes in\n-            // filenames as the `ar` utility generally only uses the last\n-            // component of a path for the filename list in the archive. On\n-            // Windows, however, archives assembled with `lib.exe` will preserve\n-            // the full path to the file that was placed in the archive,\n-            // including path separators.\n-            //\n-            // The code below is munging paths so it'll go wrong pretty quickly\n-            // if there's some unexpected slashes in the filename, so here we\n-            // just chop off everything but the filename component. Note that\n-            // this can cause duplicate filenames, but that's also handled below\n-            // as well.\n-            let filename = Path::new(filename).file_name().unwrap()\n-                                              .to_str().unwrap();\n-\n-            // An archive can contain files of the same name multiple times, so\n-            // we need to be sure to not have them overwrite one another when we\n-            // extract them. Consequently we need to find a truly unique file\n-            // name for us!\n-            let mut new_filename = String::new();\n-            for n in 0.. {\n-                let n = if n == 0 {String::new()} else {format!(\"-{}\", n)};\n-                new_filename = format!(\"r{}-{}-{}\", n, name, filename);\n-\n-                // LLDB (as mentioned in back::link) crashes on filenames of\n-                // exactly\n-                // 16 bytes in length. If we're including an object file with\n-                //    exactly 16-bytes of characters, give it some prefix so\n-                //    that it's not 16 bytes.\n-                new_filename = if new_filename.len() == 16 {\n-                    format!(\"lldb-fix-{}\", new_filename)\n-                } else {\n-                    new_filename\n-                };\n-\n-                let present = self.members.iter().filter_map(|p| {\n-                    p.file_name().and_then(|f| f.to_str())\n-                }).any(|s| s == new_filename);\n-                if !present {\n-                    break\n-                }\n-            }\n-            let dst = self.work_dir.path().join(&new_filename);\n-            try!(try!(File::create(&dst)).write_all(file.data()));\n-            self.members.push(PathBuf::from(new_filename));\n-        }\n-\n-        Ok(())\n-    }\n-}"}, {"sha": "ef5ba625e114b68bfef689aa4416e904fbf4a6a6", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -51,7 +51,6 @@ extern crate rustc_llvm;\n #[macro_use] extern crate log;\n \n pub mod abi;\n-pub mod archive;\n pub mod tempdir;\n pub mod arm;\n pub mod mips;"}, {"sha": "b2dcd5aae21139feaaf4275b2ac7abd001f92533", "filename": "src/librustc_back/target/linux_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -29,6 +29,7 @@ pub fn opts() -> TargetOptions {\n             \"-Wl,--as-needed\".to_string(),\n         ],\n         position_independent_executables: true,\n+        archive_format: \"gnu\".to_string(),\n         .. Default::default()\n     }\n }"}, {"sha": "8ecee61621941a7eb735028f8e234ce8fd0e6e68", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -166,6 +166,11 @@ pub struct TargetOptions {\n     /// the functions in the executable are not randomized and can be used\n     /// during an exploit of a vulnerability in any code.\n     pub position_independent_executables: bool,\n+    /// Format that archives should be emitted in. This affects whether we use\n+    /// LLVM to assemble an archive or fall back to the system linker, and\n+    /// currently only \"gnu\" is used to fall into LLVM. Unknown strings cause\n+    /// the system linker to be used.\n+    pub archive_format: String,\n }\n \n impl Default for TargetOptions {\n@@ -202,6 +207,7 @@ impl Default for TargetOptions {\n             position_independent_executables: false,\n             pre_link_objects: Vec::new(),\n             post_link_objects: Vec::new(),\n+            archive_format: String::new(),\n         }\n     }\n }"}, {"sha": "fd29fe89271cb8f38401794aa6175098edcb7953", "filename": "src/librustc_back/target/windows_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -25,6 +25,7 @@ pub fn opts() -> TargetOptions {\n         staticlib_suffix: \".lib\".to_string(),\n         morestack: false,\n         is_like_windows: true,\n+        archive_format: \"gnu\".to_string(),\n         pre_link_args: vec!(\n             // And here, we see obscure linker flags #45. On windows, it has been\n             // found to be necessary to have this flag to compile liblibc."}, {"sha": "2c6022bc6149584488f988552e1759a06b40f2b3", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -13,6 +13,7 @@\n use ArchiveRef;\n \n use std::ffi::CString;\n+use std::marker;\n use std::path::Path;\n use std::slice;\n use std::str;\n@@ -25,8 +26,8 @@ pub struct Iter<'a> {\n }\n \n pub struct Child<'a> {\n-    name: Option<&'a str>,\n-    data: &'a [u8],\n+    ptr: ::ArchiveChildRef,\n+    _data: marker::PhantomData<&'a ArchiveRO>,\n }\n \n impl ArchiveRO {\n@@ -60,6 +61,8 @@ impl ArchiveRO {\n         }\n     }\n \n+    pub fn raw(&self) -> ArchiveRef { self.ptr }\n+\n     pub fn iter(&self) -> Iter {\n         unsafe {\n             Iter { ptr: ::LLVMRustArchiveIteratorNew(self.ptr), archive: self }\n@@ -79,28 +82,11 @@ impl<'a> Iterator for Iter<'a> {\n     type Item = Child<'a>;\n \n     fn next(&mut self) -> Option<Child<'a>> {\n-        unsafe {\n-            let ptr = ::LLVMRustArchiveIteratorCurrent(self.ptr);\n-            if ptr.is_null() {\n-                return None\n-            }\n-            let mut name_len = 0;\n-            let name_ptr = ::LLVMRustArchiveChildName(ptr, &mut name_len);\n-            let mut data_len = 0;\n-            let data_ptr = ::LLVMRustArchiveChildData(ptr, &mut data_len);\n-            let child = Child {\n-                name: if name_ptr.is_null() {\n-                    None\n-                } else {\n-                    let name = slice::from_raw_parts(name_ptr as *const u8,\n-                                                     name_len as usize);\n-                    str::from_utf8(name).ok().map(|s| s.trim())\n-                },\n-                data: slice::from_raw_parts(data_ptr as *const u8,\n-                                            data_len as usize),\n-            };\n-            ::LLVMRustArchiveIteratorNext(self.ptr);\n-            Some(child)\n+        let ptr = unsafe { ::LLVMRustArchiveIteratorNext(self.ptr) };\n+        if ptr.is_null() {\n+            None\n+        } else {\n+            Some(Child { ptr: ptr, _data: marker::PhantomData })\n         }\n     }\n }\n@@ -114,6 +100,33 @@ impl<'a> Drop for Iter<'a> {\n }\n \n impl<'a> Child<'a> {\n-    pub fn name(&self) -> Option<&'a str> { self.name }\n-    pub fn data(&self) -> &'a [u8] { self.data }\n+    pub fn name(&self) -> Option<&'a str> {\n+        unsafe {\n+            let mut name_len = 0;\n+            let name_ptr = ::LLVMRustArchiveChildName(self.ptr, &mut name_len);\n+            if name_ptr.is_null() {\n+                None\n+            } else {\n+                let name = slice::from_raw_parts(name_ptr as *const u8,\n+                                                 name_len as usize);\n+                str::from_utf8(name).ok().map(|s| s.trim())\n+            }\n+        }\n+    }\n+\n+    pub fn data(&self) -> &'a [u8] {\n+        unsafe {\n+            let mut data_len = 0;\n+            let data_ptr = ::LLVMRustArchiveChildData(self.ptr, &mut data_len);\n+            slice::from_raw_parts(data_ptr as *const u8, data_len as usize)\n+        }\n+    }\n+\n+    pub fn raw(&self) -> ::ArchiveChildRef { self.ptr }\n+}\n+\n+impl<'a> Drop for Child<'a> {\n+    fn drop(&mut self) {\n+        unsafe { ::LLVMRustArchiveChildFree(self.ptr); }\n+    }\n }"}, {"sha": "7afcb54cce43613d2867aacbfd81ec2bbd832707", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -522,6 +522,9 @@ pub type DebugLocRef = *mut DebugLoc_opaque;\n #[allow(missing_copy_implementations)]\n pub enum SMDiagnostic_opaque {}\n pub type SMDiagnosticRef = *mut SMDiagnostic_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum RustArchiveMember_opaque {}\n+pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n \n pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n@@ -2069,12 +2072,12 @@ extern {\n \n     pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n     pub fn LLVMRustArchiveIteratorNew(AR: ArchiveRef) -> ArchiveIteratorRef;\n-    pub fn LLVMRustArchiveIteratorNext(AIR: ArchiveIteratorRef);\n-    pub fn LLVMRustArchiveIteratorCurrent(AIR: ArchiveIteratorRef) -> ArchiveChildRef;\n+    pub fn LLVMRustArchiveIteratorNext(AIR: ArchiveIteratorRef) -> ArchiveChildRef;\n     pub fn LLVMRustArchiveChildName(ACR: ArchiveChildRef,\n                                     size: *mut size_t) -> *const c_char;\n     pub fn LLVMRustArchiveChildData(ACR: ArchiveChildRef,\n                                     size: *mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveChildFree(ACR: ArchiveChildRef);\n     pub fn LLVMRustArchiveIteratorFree(AIR: ArchiveIteratorRef);\n     pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n \n@@ -2111,6 +2114,15 @@ extern {\n                                              CX: *mut c_void);\n \n     pub fn LLVMWriteSMDiagnosticToString(d: SMDiagnosticRef, s: RustStringRef);\n+\n+    pub fn LLVMRustWriteArchive(Dst: *const c_char,\n+                                NumMembers: size_t,\n+                                Members: *const RustArchiveMemberRef,\n+                                WriteSymbtab: bool) -> c_int;\n+    pub fn LLVMRustArchiveMemberNew(Filename: *const c_char,\n+                                    Name: *const c_char,\n+                                    Child: ArchiveChildRef) -> RustArchiveMemberRef;\n+    pub fn LLVMRustArchiveMemberFree(Member: RustArchiveMemberRef);\n }\n \n // LLVM requires symbols from this library, but apparently they're not printed"}, {"sha": "cc3d1d842fad0c9cd516a5fabd4a7147d0673b0f", "filename": "src/librustc_trans/back/archive.rs", "status": "added", "additions": 504, "deletions": 0, "changes": 504, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -0,0 +1,504 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A helper class for dealing with static archives\n+\n+use std::env;\n+use std::ffi::{CString, CStr, OsString};\n+use std::fs::{self, File};\n+use std::io::prelude::*;\n+use std::io;\n+use std::mem;\n+use std::path::{Path, PathBuf};\n+use std::process::{Command, Output, Stdio};\n+use std::str;\n+\n+use libc;\n+use llvm::archive_ro::{ArchiveRO, Child};\n+use llvm;\n+use rustc::metadata::loader::METADATA_FILENAME;\n+use rustc::session::Session;\n+use rustc_back::tempdir::TempDir;\n+\n+pub struct ArchiveConfig<'a> {\n+    pub sess: &'a Session,\n+    pub dst: PathBuf,\n+    pub src: Option<PathBuf>,\n+    pub lib_search_paths: Vec<PathBuf>,\n+    pub ar_prog: String,\n+    pub command_path: OsString,\n+}\n+\n+/// Helper for adding many files to an archive with a single invocation of\n+/// `ar`.\n+#[must_use = \"must call build() to finish building the archive\"]\n+pub struct ArchiveBuilder<'a> {\n+    config: ArchiveConfig<'a>,\n+    work_dir: TempDir,\n+    removals: Vec<String>,\n+    additions: Vec<Addition>,\n+    should_update_symbols: bool,\n+    src_archive: Option<Option<ArchiveRO>>,\n+}\n+\n+enum Addition {\n+    File {\n+        path: PathBuf,\n+        name_in_archive: String,\n+    },\n+    Archive {\n+        archive: ArchiveRO,\n+        archive_name: String,\n+        skip: Box<FnMut(&str) -> bool>,\n+    },\n+}\n+\n+enum Action<'a> {\n+    Remove(&'a [String]),\n+    AddObjects(&'a [&'a PathBuf], bool),\n+    UpdateSymbols,\n+}\n+\n+pub fn find_library(name: &str, search_paths: &[PathBuf], sess: &Session)\n+                    -> PathBuf {\n+    // On Windows, static libraries sometimes show up as libfoo.a and other\n+    // times show up as foo.lib\n+    let oslibname = format!(\"{}{}{}\",\n+                            sess.target.target.options.staticlib_prefix,\n+                            name,\n+                            sess.target.target.options.staticlib_suffix);\n+    let unixlibname = format!(\"lib{}.a\", name);\n+\n+    for path in search_paths {\n+        debug!(\"looking for {} inside {:?}\", name, path);\n+        let test = path.join(&oslibname[..]);\n+        if test.exists() { return test }\n+        if oslibname != unixlibname {\n+            let test = path.join(&unixlibname[..]);\n+            if test.exists() { return test }\n+        }\n+    }\n+    sess.fatal(&format!(\"could not find native static library `{}`, \\\n+                         perhaps an -L flag is missing?\", name));\n+}\n+\n+fn is_relevant_child(c: &Child) -> bool {\n+    match c.name() {\n+        Some(name) => !name.contains(\"SYMDEF\"),\n+        None => false,\n+    }\n+}\n+\n+impl<'a> ArchiveBuilder<'a> {\n+    /// Create a new static archive, ready for modifying the archive specified\n+    /// by `config`.\n+    pub fn new(config: ArchiveConfig<'a>) -> ArchiveBuilder<'a> {\n+        ArchiveBuilder {\n+            config: config,\n+            work_dir: TempDir::new(\"rsar\").unwrap(),\n+            removals: Vec::new(),\n+            additions: Vec::new(),\n+            should_update_symbols: false,\n+            src_archive: None,\n+        }\n+    }\n+\n+    /// Removes a file from this archive\n+    pub fn remove_file(&mut self, file: &str) {\n+        self.removals.push(file.to_string());\n+    }\n+\n+    /// Lists all files in an archive\n+    pub fn src_files(&mut self) -> Vec<String> {\n+        if self.src_archive().is_none() {\n+            return Vec::new()\n+        }\n+        let archive = self.src_archive.as_ref().unwrap().as_ref().unwrap();\n+        let ret = archive.iter()\n+                         .filter(is_relevant_child)\n+                         .filter_map(|child| child.name())\n+                         .filter(|name| !self.removals.iter().any(|x| x == name))\n+                         .map(|name| name.to_string())\n+                         .collect();\n+        return ret;\n+    }\n+\n+    fn src_archive(&mut self) -> Option<&ArchiveRO> {\n+        if let Some(ref a) = self.src_archive {\n+            return a.as_ref()\n+        }\n+        let src = match self.config.src {\n+            Some(ref src) => src,\n+            None => return None,\n+        };\n+        self.src_archive = Some(ArchiveRO::open(src));\n+        self.src_archive.as_ref().unwrap().as_ref()\n+    }\n+\n+    /// Adds all of the contents of a native library to this archive. This will\n+    /// search in the relevant locations for a library named `name`.\n+    pub fn add_native_library(&mut self, name: &str) -> io::Result<()> {\n+        let location = find_library(name, &self.config.lib_search_paths,\n+                                    self.config.sess);\n+        self.add_archive(&location, name, |_| false)\n+    }\n+\n+    /// Adds all of the contents of the rlib at the specified path to this\n+    /// archive.\n+    ///\n+    /// This ignores adding the bytecode from the rlib, and if LTO is enabled\n+    /// then the object file also isn't added.\n+    pub fn add_rlib(&mut self, rlib: &Path, name: &str, lto: bool)\n+                    -> io::Result<()> {\n+        // Ignoring obj file starting with the crate name\n+        // as simple comparison is not enough - there\n+        // might be also an extra name suffix\n+        let obj_start = format!(\"{}\", name);\n+\n+        // Ignoring all bytecode files, no matter of\n+        // name\n+        let bc_ext = \".bytecode.deflate\";\n+\n+        self.add_archive(rlib, &name[..], move |fname: &str| {\n+            let skip_obj = lto && fname.starts_with(&obj_start)\n+                && fname.ends_with(\".o\");\n+            skip_obj || fname.ends_with(bc_ext) || fname == METADATA_FILENAME\n+        })\n+    }\n+\n+    fn add_archive<F>(&mut self, archive: &Path, name: &str, skip: F)\n+                      -> io::Result<()>\n+        where F: FnMut(&str) -> bool + 'static\n+    {\n+        let archive = match ArchiveRO::open(archive) {\n+            Some(ar) => ar,\n+            None => return Err(io::Error::new(io::ErrorKind::Other,\n+                                              \"failed to open archive\")),\n+        };\n+        self.additions.push(Addition::Archive {\n+            archive: archive,\n+            archive_name: name.to_string(),\n+            skip: Box::new(skip),\n+        });\n+        Ok(())\n+    }\n+\n+    /// Adds an arbitrary file to this archive\n+    pub fn add_file(&mut self, file: &Path) {\n+        let name = file.file_name().unwrap().to_str().unwrap();\n+        self.additions.push(Addition::File {\n+            path: file.to_path_buf(),\n+            name_in_archive: name.to_string(),\n+        });\n+    }\n+\n+    /// Indicate that the next call to `build` should updates all symbols in\n+    /// the archive (run 'ar s' over it).\n+    pub fn update_symbols(&mut self) {\n+        self.should_update_symbols = true;\n+    }\n+\n+    /// Combine the provided files, rlibs, and native libraries into a single\n+    /// `Archive`.\n+    pub fn build(&mut self) {\n+        let res = if self.using_llvm() {\n+            self.build_with_llvm()\n+        } else {\n+            self.build_with_ar_cmd()\n+        };\n+        if let Err(e) = res {\n+            self.config.sess.fatal(&format!(\"failed to build archive: {}\", e));\n+        }\n+    }\n+\n+    pub fn using_llvm(&self) -> bool {\n+        if unsafe { llvm::LLVMVersionMinor() < 7 } {\n+            return false\n+        }\n+\n+        // Currently LLVM only supports writing archives in the 'gnu' format.\n+        match &self.config.sess.target.target.options.archive_format[..] {\n+            \"gnu\" => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn build_with_ar_cmd(&mut self) -> io::Result<()> {\n+        let removals = mem::replace(&mut self.removals, Vec::new());\n+        let additions = mem::replace(&mut self.additions, Vec::new());\n+        let should_update_symbols = mem::replace(&mut self.should_update_symbols,\n+                                                 false);\n+\n+        // Don't use fs::copy because libs may be installed as read-only and we\n+        // want to modify this archive, so we use `io::copy` to not preserve\n+        // permission bits.\n+        if let Some(ref s) = self.config.src {\n+            try!(io::copy(&mut try!(File::open(s)),\n+                          &mut try!(File::create(&self.config.dst))));\n+        }\n+\n+        if removals.len() > 0 {\n+            self.run(None, Action::Remove(&removals));\n+        }\n+\n+        let mut members = Vec::new();\n+        for addition in additions {\n+            match addition {\n+                Addition::File { path, name_in_archive } => {\n+                    let dst = self.work_dir.path().join(&name_in_archive);\n+                    try!(fs::copy(&path, &dst));\n+                    members.push(PathBuf::from(name_in_archive));\n+                }\n+                Addition::Archive { archive, archive_name, mut skip } => {\n+                    try!(self.add_archive_members(&mut members, archive,\n+                                                  &archive_name, &mut *skip));\n+                }\n+            }\n+        }\n+\n+        // Get an absolute path to the destination, so `ar` will work even\n+        // though we run it from `self.work_dir`.\n+        let mut objects = Vec::new();\n+        let mut total_len = self.config.dst.to_string_lossy().len();\n+\n+        if members.is_empty() {\n+            if should_update_symbols {\n+                self.run(Some(self.work_dir.path()), Action::UpdateSymbols);\n+            }\n+            return Ok(())\n+        }\n+\n+        // Don't allow the total size of `args` to grow beyond 32,000 bytes.\n+        // Windows will raise an error if the argument string is longer than\n+        // 32,768, and we leave a bit of extra space for the program name.\n+        const ARG_LENGTH_LIMIT: usize = 32_000;\n+\n+        for member_name in &members {\n+            let len = member_name.to_string_lossy().len();\n+\n+            // `len + 1` to account for the space that's inserted before each\n+            // argument.  (Windows passes command-line arguments as a single\n+            // string, not an array of strings.)\n+            if total_len + len + 1 > ARG_LENGTH_LIMIT {\n+                // Add the archive members seen so far, without updating the\n+                // symbol table.\n+                self.run(Some(self.work_dir.path()),\n+                         Action::AddObjects(&objects, false));\n+\n+                objects.clear();\n+                total_len = self.config.dst.to_string_lossy().len();\n+            }\n+\n+            objects.push(member_name);\n+            total_len += len + 1;\n+        }\n+\n+        // Add the remaining archive members, and update the symbol table if\n+        // necessary.\n+        self.run(Some(self.work_dir.path()),\n+                         Action::AddObjects(&objects, should_update_symbols));\n+        Ok(())\n+    }\n+\n+    fn add_archive_members(&mut self, members: &mut Vec<PathBuf>,\n+                           archive: ArchiveRO, name: &str,\n+                           skip: &mut FnMut(&str) -> bool) -> io::Result<()> {\n+        // Next, we must rename all of the inputs to \"guaranteed unique names\".\n+        // We write each file into `self.work_dir` under its new unique name.\n+        // The reason for this renaming is that archives are keyed off the name\n+        // of the files, so if two files have the same name they will override\n+        // one another in the archive (bad).\n+        //\n+        // We skip any files explicitly desired for skipping, and we also skip\n+        // all SYMDEF files as these are just magical placeholders which get\n+        // re-created when we make a new archive anyway.\n+        for file in archive.iter().filter(is_relevant_child) {\n+            let filename = file.name().unwrap();\n+            if skip(filename) { continue }\n+            let filename = Path::new(filename).file_name().unwrap()\n+                                              .to_str().unwrap();\n+\n+            // Archives on unix systems typically do not have slashes in\n+            // filenames as the `ar` utility generally only uses the last\n+            // component of a path for the filename list in the archive. On\n+            // Windows, however, archives assembled with `lib.exe` will preserve\n+            // the full path to the file that was placed in the archive,\n+            // including path separators.\n+            //\n+            // The code below is munging paths so it'll go wrong pretty quickly\n+            // if there's some unexpected slashes in the filename, so here we\n+            // just chop off everything but the filename component. Note that\n+            // this can cause duplicate filenames, but that's also handled below\n+            // as well.\n+            let filename = Path::new(filename).file_name().unwrap()\n+                                              .to_str().unwrap();\n+\n+            // An archive can contain files of the same name multiple times, so\n+            // we need to be sure to not have them overwrite one another when we\n+            // extract them. Consequently we need to find a truly unique file\n+            // name for us!\n+            let mut new_filename = String::new();\n+            for n in 0.. {\n+                let n = if n == 0 {String::new()} else {format!(\"-{}\", n)};\n+                new_filename = format!(\"r{}-{}-{}\", n, name, filename);\n+\n+                // LLDB (as mentioned in back::link) crashes on filenames of\n+                // exactly\n+                // 16 bytes in length. If we're including an object file with\n+                //    exactly 16-bytes of characters, give it some prefix so\n+                //    that it's not 16 bytes.\n+                new_filename = if new_filename.len() == 16 {\n+                    format!(\"lldb-fix-{}\", new_filename)\n+                } else {\n+                    new_filename\n+                };\n+\n+                let present = members.iter().filter_map(|p| {\n+                    p.file_name().and_then(|f| f.to_str())\n+                }).any(|s| s == new_filename);\n+                if !present {\n+                    break\n+                }\n+            }\n+            let dst = self.work_dir.path().join(&new_filename);\n+            try!(try!(File::create(&dst)).write_all(file.data()));\n+            members.push(PathBuf::from(new_filename));\n+        }\n+        Ok(())\n+    }\n+\n+    fn run(&self, cwd: Option<&Path>, action: Action) -> Output {\n+        let abs_dst = env::current_dir().unwrap().join(&self.config.dst);\n+        let ar = &self.config.ar_prog;\n+        let mut cmd = Command::new(ar);\n+        cmd.env(\"PATH\", &self.config.command_path);\n+        cmd.stdout(Stdio::piped()).stderr(Stdio::piped());\n+        self.prepare_ar_action(&mut cmd, &abs_dst, action);\n+        info!(\"{:?}\", cmd);\n+\n+        if let Some(p) = cwd {\n+            cmd.current_dir(p);\n+            info!(\"inside {:?}\", p.display());\n+        }\n+\n+        let sess = &self.config.sess;\n+        match cmd.spawn() {\n+            Ok(prog) => {\n+                let o = prog.wait_with_output().unwrap();\n+                if !o.status.success() {\n+                    sess.err(&format!(\"{:?} failed with: {}\", cmd, o.status));\n+                    sess.note(&format!(\"stdout ---\\n{}\",\n+                                       str::from_utf8(&o.stdout).unwrap()));\n+                    sess.note(&format!(\"stderr ---\\n{}\",\n+                                       str::from_utf8(&o.stderr).unwrap()));\n+                    sess.abort_if_errors();\n+                }\n+                o\n+            },\n+            Err(e) => {\n+                sess.fatal(&format!(\"could not exec `{}`: {}\",\n+                                    self.config.ar_prog, e));\n+            }\n+        }\n+    }\n+\n+    fn prepare_ar_action(&self, cmd: &mut Command, dst: &Path, action: Action) {\n+        match action {\n+            Action::Remove(files) => {\n+                cmd.arg(\"d\").arg(dst).args(files);\n+            }\n+            Action::AddObjects(objs, update_symbols) => {\n+                cmd.arg(if update_symbols {\"crs\"} else {\"crS\"})\n+                   .arg(dst)\n+                   .args(objs);\n+            }\n+            Action::UpdateSymbols => {\n+                cmd.arg(\"s\").arg(dst);\n+            }\n+        }\n+    }\n+\n+    fn build_with_llvm(&mut self) -> io::Result<()> {\n+        let mut archives = Vec::new();\n+        let mut strings = Vec::new();\n+        let mut members = Vec::new();\n+        let removals = mem::replace(&mut self.removals, Vec::new());\n+\n+        unsafe {\n+            if let Some(archive) = self.src_archive() {\n+                for child in archive.iter() {\n+                    let child_name = match child.name() {\n+                        Some(s) => s,\n+                        None => continue,\n+                    };\n+                    if removals.iter().any(|r| r == child_name) {\n+                        continue\n+                    }\n+\n+                    let name = try!(CString::new(child_name));\n+                    members.push(llvm::LLVMRustArchiveMemberNew(0 as *const _,\n+                                                                name.as_ptr(),\n+                                                                child.raw()));\n+                    strings.push(name);\n+                }\n+            }\n+            for addition in mem::replace(&mut self.additions, Vec::new()) {\n+                match addition {\n+                    Addition::File { path, name_in_archive } => {\n+                        let path = try!(CString::new(path.to_str().unwrap()));\n+                        let name = try!(CString::new(name_in_archive));\n+                        members.push(llvm::LLVMRustArchiveMemberNew(path.as_ptr(),\n+                                                                    name.as_ptr(),\n+                                                                    0 as *mut _));\n+                        strings.push(path);\n+                        strings.push(name);\n+                    }\n+                    Addition::Archive { archive, archive_name: _, mut skip } => {\n+                        for child in archive.iter().filter(is_relevant_child) {\n+                            let child_name = child.name().unwrap();\n+                            if skip(child_name) { continue }\n+\n+                            let name = try!(CString::new(child_name));\n+                            let m = llvm::LLVMRustArchiveMemberNew(0 as *const _,\n+                                                                   name.as_ptr(),\n+                                                                   child.raw());\n+                            members.push(m);\n+                            strings.push(name);\n+                        }\n+                        archives.push(archive);\n+                    }\n+                }\n+            }\n+\n+            let dst = self.config.dst.to_str().unwrap().as_bytes();\n+            let dst = try!(CString::new(dst));\n+            let r = llvm::LLVMRustWriteArchive(dst.as_ptr(),\n+                                               members.len() as libc::size_t,\n+                                               members.as_ptr(),\n+                                               self.should_update_symbols);\n+            let ret = if r != 0 {\n+                let err = llvm::LLVMRustGetLastError();\n+                let msg = if err.is_null() {\n+                    \"failed to write archive\".to_string()\n+                } else {\n+                    String::from_utf8_lossy(CStr::from_ptr(err).to_bytes())\n+                            .into_owned()\n+                };\n+                Err(io::Error::new(io::ErrorKind::Other, msg))\n+            } else {\n+                Ok(())\n+            };\n+            for member in members {\n+                llvm::LLVMRustArchiveMemberFree(member);\n+            }\n+            return ret\n+        }\n+    }\n+}"}, {"sha": "d24d836975110b5e294bd7de7f4d2c22d6703a4c", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 47, "deletions": 49, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::archive::{Archive, ArchiveBuilder, ArchiveConfig, METADATA_FILENAME};\n+use super::archive::{ArchiveBuilder, ArchiveConfig};\n use super::linker::{Linker, GnuLinker, MsvcLinker};\n use super::rpath::RPathConfig;\n use super::rpath;\n@@ -20,8 +20,9 @@ use session::config::{OutputFilenames, Input, OutputTypeBitcode, OutputTypeExe,\n use session::search_paths::PathKind;\n use session::Session;\n use metadata::common::LinkMeta;\n-use metadata::{encoder, cstore, filesearch, csearch, creader};\n use metadata::filesearch::FileDoesntMatch;\n+use metadata::loader::METADATA_FILENAME;\n+use metadata::{encoder, cstore, filesearch, csearch, creader};\n use middle::ty::{self, Ty};\n use rustc::ast_map::{PathElem, PathElems, PathName};\n use trans::{CrateContext, CrateTranslation, gensym_name};\n@@ -513,18 +514,22 @@ fn link_binary_output(sess: &Session,\n         }\n     }\n \n+    let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n     match crate_type {\n         config::CrateTypeRlib => {\n-            link_rlib(sess, Some(trans), &objects, &out_filename).build();\n+            link_rlib(sess, Some(trans), &objects, &out_filename,\n+                      tmpdir.path()).build();\n         }\n         config::CrateTypeStaticlib => {\n-            link_staticlib(sess, &objects, &out_filename);\n+            link_staticlib(sess, &objects, &out_filename, tmpdir.path());\n         }\n         config::CrateTypeExecutable => {\n-            link_natively(sess, trans, false, &objects, &out_filename, outputs);\n+            link_natively(sess, trans, false, &objects, &out_filename, outputs,\n+                          tmpdir.path());\n         }\n         config::CrateTypeDylib => {\n-            link_natively(sess, trans, true, &objects, &out_filename, outputs);\n+            link_natively(sess, trans, true, &objects, &out_filename, outputs,\n+                          tmpdir.path());\n         }\n     }\n \n@@ -548,13 +553,13 @@ fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n }\n \n fn archive_config<'a>(sess: &'a Session,\n-                      output: &Path) -> ArchiveConfig<'a> {\n+                      output: &Path,\n+                      input: Option<&Path>) -> ArchiveConfig<'a> {\n     ArchiveConfig {\n-        handler: &sess.diagnostic().handler,\n+        sess: sess,\n         dst: output.to_path_buf(),\n+        src: input.map(|p| p.to_path_buf()),\n         lib_search_paths: archive_search_paths(sess),\n-        slib_prefix: sess.target.target.options.staticlib_prefix.clone(),\n-        slib_suffix: sess.target.target.options.staticlib_suffix.clone(),\n         ar_prog: get_ar_prog(sess),\n         command_path: command_path(sess),\n     }\n@@ -569,11 +574,12 @@ fn archive_config<'a>(sess: &'a Session,\n fn link_rlib<'a>(sess: &'a Session,\n                  trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n                  objects: &[PathBuf],\n-                 out_filename: &Path) -> ArchiveBuilder<'a> {\n+                 out_filename: &Path,\n+                 tmpdir: &Path) -> ArchiveBuilder<'a> {\n     info!(\"preparing rlib from {:?} to {:?}\", objects, out_filename);\n-    let mut ab = ArchiveBuilder::create(archive_config(sess, out_filename));\n+    let mut ab = ArchiveBuilder::new(archive_config(sess, out_filename, None));\n     for obj in objects {\n-        ab.add_file(obj).unwrap();\n+        ab.add_file(obj);\n     }\n \n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n@@ -587,13 +593,12 @@ fn link_rlib<'a>(sess: &'a Session,\n     // symbol table of the archive.\n     ab.update_symbols();\n \n-    let mut ab = match sess.target.target.options.is_like_osx {\n-        // For OSX/iOS, we must be careful to update symbols only when adding\n-        // object files.  We're about to start adding non-object files, so run\n-        // `ar` now to process the object files.\n-        true => ab.build().extend(),\n-        false => ab,\n-    };\n+    // For OSX/iOS, we must be careful to update symbols only when adding\n+    // object files.  We're about to start adding non-object files, so run\n+    // `ar` now to process the object files.\n+    if sess.target.target.options.is_like_osx && !ab.using_llvm() {\n+        ab.build();\n+    }\n \n     // Note that it is important that we add all of our non-object \"magical\n     // files\" *after* all of the object files in the archive. The reason for\n@@ -622,8 +627,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // contain the metadata in a separate file. We use a temp directory\n             // here so concurrent builds in the same directory don't try to use\n             // the same filename for metadata (stomping over one another)\n-            let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n-            let metadata = tmpdir.path().join(METADATA_FILENAME);\n+            let metadata = tmpdir.join(METADATA_FILENAME);\n             match fs::File::create(&metadata).and_then(|mut f| {\n                 f.write_all(&trans.metadata)\n             }) {\n@@ -633,8 +637,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                                         metadata.display(), e));\n                 }\n             }\n-            ab.add_file(&metadata).unwrap();\n-            remove(sess, &metadata);\n+            ab.add_file(&metadata);\n \n             // For LTO purposes, the bytecode of this library is also inserted\n             // into the archive.  If codegen_units > 1, we insert each of the\n@@ -646,7 +649,9 @@ fn link_rlib<'a>(sess: &'a Session,\n                 // would cause it to crash if the name of a file in an archive\n                 // was exactly 16 bytes.\n                 let bc_filename = obj.with_extension(\"bc\");\n-                let bc_deflated_filename = obj.with_extension(\"bytecode.deflate\");\n+                let bc_deflated_filename = tmpdir.join({\n+                    obj.with_extension(\"bytecode.deflate\").file_name().unwrap()\n+                });\n \n                 let mut bc_data = Vec::new();\n                 match fs::File::open(&bc_filename).and_then(|mut f| {\n@@ -676,8 +681,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                     }\n                 };\n \n-                ab.add_file(&bc_deflated_filename).unwrap();\n-                remove(sess, &bc_deflated_filename);\n+                ab.add_file(&bc_deflated_filename);\n \n                 // See the bottom of back::write::run_passes for an explanation\n                 // of when we do and don't keep .0.bc files around.\n@@ -692,7 +696,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // After adding all files to the archive, we need to update the\n             // symbol table of the archive. This currently dies on OSX (see\n             // #11162), and isn't necessary there anyway\n-            if !sess.target.target.options.is_like_osx {\n+            if !sess.target.target.options.is_like_osx || ab.using_llvm() {\n                 ab.update_symbols();\n             }\n         }\n@@ -749,12 +753,12 @@ fn write_rlib_bytecode_object_v1(writer: &mut Write,\n // There's no need to include metadata in a static archive, so ensure to not\n // link in the metadata object file (and also don't prepare the archive with a\n // metadata file).\n-fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path) {\n-    let ab = link_rlib(sess, None, objects, out_filename);\n-    let mut ab = match sess.target.target.options.is_like_osx {\n-        true => ab.build().extend(),\n-        false => ab,\n-    };\n+fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n+                  tempdir: &Path) {\n+    let mut ab = link_rlib(sess, None, objects, out_filename, tempdir);\n+    if sess.target.target.options.is_like_osx && !ab.using_llvm() {\n+        ab.build();\n+    }\n     if sess.target.target.options.morestack {\n         ab.add_native_library(\"morestack\").unwrap();\n     }\n@@ -781,7 +785,7 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path) {\n     }\n \n     ab.update_symbols();\n-    let _ = ab.build();\n+    ab.build();\n \n     if !all_native_libs.is_empty() {\n         sess.note(\"link against the following native artifacts when linking against \\\n@@ -806,10 +810,10 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path) {\n // links to all upstream files as well.\n fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n                  objects: &[PathBuf], out_filename: &Path,\n-                 outputs: &OutputFilenames) {\n+                 outputs: &OutputFilenames,\n+                 tmpdir: &Path) {\n     info!(\"preparing dylib? ({}) from {:?} to {:?}\", dylib, objects,\n           out_filename);\n-    let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n \n     // The invocations of cc share some flags across platforms\n     let (pname, mut cmd) = get_linker(sess);\n@@ -827,7 +831,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         } else {\n             Box::new(GnuLinker { cmd: &mut cmd, sess: &sess }) as Box<Linker>\n         };\n-        link_args(&mut *linker, sess, dylib, tmpdir.path(),\n+        link_args(&mut *linker, sess, dylib, tmpdir,\n                   trans, objects, out_filename, outputs);\n         if !sess.target.target.options.no_compiler_rt {\n             linker.link_staticlib(\"compiler-rt\");\n@@ -1185,20 +1189,13 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n         let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n \n         time(sess.time_passes(), &format!(\"altering {}.rlib\", name), (), |()| {\n-            let err = (|| {\n-                io::copy(&mut try!(fs::File::open(&cratepath)),\n-                         &mut try!(fs::File::create(&dst)))\n-            })();\n-            if let Err(e) = err {\n-                sess.fatal(&format!(\"failed to copy {} to {}: {}\",\n-                                    cratepath.display(), dst.display(), e));\n-            }\n-\n-            let mut archive = Archive::open(archive_config(sess, &dst));\n+            let cfg = archive_config(sess, &dst, Some(cratepath));\n+            let mut archive = ArchiveBuilder::new(cfg);\n             archive.remove_file(METADATA_FILENAME);\n+            archive.update_symbols();\n \n             let mut any_objects = false;\n-            for f in archive.files() {\n+            for f in archive.src_files() {\n                 if f.ends_with(\"bytecode.deflate\") {\n                     archive.remove_file(&f);\n                     continue\n@@ -1217,6 +1214,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n             }\n \n             if any_objects {\n+                archive.build();\n                 cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n             }\n         });"}, {"sha": "a272e7c4c8f04792c1cb75c6f9c09fc108249b4b", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -13,7 +13,7 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::fs;\n \n-use rustc_back::archive;\n+use back::archive;\n use session::Session;\n use session::config;\n \n@@ -88,11 +88,7 @@ impl<'a> Linker for GnuLinker<'a> {\n             // -force_load is the OSX equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n             let mut v = OsString::from(\"-Wl,-force_load,\");\n-            v.push(&archive::find_library(lib,\n-                                          &target.options.staticlib_prefix,\n-                                          &target.options.staticlib_suffix,\n-                                          search_path,\n-                                          &self.sess.diagnostic().handler));\n+            v.push(&archive::find_library(lib, search_path, &self.sess));\n             self.cmd.arg(&v);\n         }\n     }"}, {"sha": "0e425e1fd991029e66ef37b24a08a8194493f7b6", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -53,8 +53,8 @@ extern crate graphviz;\n extern crate libc;\n extern crate rustc;\n extern crate rustc_back;\n-extern crate serialize;\n extern crate rustc_llvm as llvm;\n+extern crate serialize;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -68,7 +68,6 @@ pub use rustc::util;\n \n pub mod back {\n     pub use rustc_back::abi;\n-    pub use rustc_back::archive;\n     pub use rustc_back::arm;\n     pub use rustc_back::mips;\n     pub use rustc_back::mipsel;\n@@ -78,6 +77,7 @@ pub mod back {\n     pub use rustc_back::x86;\n     pub use rustc_back::x86_64;\n \n+    pub mod archive;\n     pub mod linker;\n     pub mod link;\n     pub mod lto;"}, {"sha": "2e94c1969354a28cd51093cec27fa5c2c35c8d59", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -0,0 +1,168 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include \"rustllvm.h\"\n+\n+#include \"llvm/Object/Archive.h\"\n+\n+#if LLVM_VERSION_MINOR >= 7\n+#include \"llvm/Object/ArchiveWriter.h\"\n+#endif\n+\n+using namespace llvm;\n+using namespace llvm::object;\n+\n+struct LLVMRustArchiveMember {\n+  const char *filename;\n+  const char *name;\n+  Archive::Child child;\n+\n+  LLVMRustArchiveMember(): filename(NULL), name(NULL), child(NULL, NULL) {}\n+  ~LLVMRustArchiveMember() {}\n+};\n+\n+#if LLVM_VERSION_MINOR >= 6\n+typedef OwningBinary<Archive> RustArchive;\n+#define GET_ARCHIVE(a) ((a)->getBinary())\n+#else\n+typedef Archive RustArchive;\n+#define GET_ARCHIVE(a) (a)\n+#endif\n+\n+extern \"C\" void*\n+LLVMRustOpenArchive(char *path) {\n+    ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or = MemoryBuffer::getFile(path,\n+                                                                          -1,\n+                                                                          false);\n+    if (!buf_or) {\n+        LLVMRustSetLastError(buf_or.getError().message().c_str());\n+        return nullptr;\n+    }\n+\n+#if LLVM_VERSION_MINOR >= 6\n+    ErrorOr<std::unique_ptr<Archive>> archive_or =\n+        Archive::create(buf_or.get()->getMemBufferRef());\n+\n+    if (!archive_or) {\n+        LLVMRustSetLastError(archive_or.getError().message().c_str());\n+        return nullptr;\n+    }\n+\n+    OwningBinary<Archive> *ret = new OwningBinary<Archive>(\n+            std::move(archive_or.get()), std::move(buf_or.get()));\n+#else\n+    std::error_code err;\n+    Archive *ret = new Archive(std::move(buf_or.get()), err);\n+    if (err) {\n+        LLVMRustSetLastError(err.message().c_str());\n+        return nullptr;\n+    }\n+#endif\n+\n+    return ret;\n+}\n+\n+extern \"C\" void\n+LLVMRustDestroyArchive(RustArchive *ar) {\n+    delete ar;\n+}\n+\n+struct RustArchiveIterator {\n+    Archive::child_iterator cur;\n+    Archive::child_iterator end;\n+};\n+\n+extern \"C\" RustArchiveIterator*\n+LLVMRustArchiveIteratorNew(RustArchive *ra) {\n+    Archive *ar = GET_ARCHIVE(ra);\n+    RustArchiveIterator *rai = new RustArchiveIterator();\n+    rai->cur = ar->child_begin();\n+    rai->end = ar->child_end();\n+    return rai;\n+}\n+\n+extern \"C\" const Archive::Child*\n+LLVMRustArchiveIteratorNext(RustArchiveIterator *rai) {\n+    if (rai->cur == rai->end)\n+        return NULL;\n+    const Archive::Child *cur = rai->cur.operator->();\n+    Archive::Child *ret = new Archive::Child(*cur);\n+    ++rai->cur;\n+    return ret;\n+}\n+\n+extern \"C\" void\n+LLVMRustArchiveChildFree(Archive::Child *child) {\n+    delete child;\n+}\n+\n+extern \"C\" void\n+LLVMRustArchiveIteratorFree(RustArchiveIterator *rai) {\n+    delete rai;\n+}\n+\n+extern \"C\" const char*\n+LLVMRustArchiveChildName(const Archive::Child *child, size_t *size) {\n+    ErrorOr<StringRef> name_or_err = child->getName();\n+    if (name_or_err.getError())\n+        return NULL;\n+    StringRef name = name_or_err.get();\n+    *size = name.size();\n+    return name.data();\n+}\n+\n+extern \"C\" const char*\n+LLVMRustArchiveChildData(Archive::Child *child, size_t *size) {\n+    StringRef buf = child->getBuffer();\n+    *size = buf.size();\n+    return buf.data();\n+}\n+\n+extern \"C\" LLVMRustArchiveMember*\n+LLVMRustArchiveMemberNew(char *Filename, char *Name, Archive::Child *child) {\n+    LLVMRustArchiveMember *Member = new LLVMRustArchiveMember;\n+    Member->filename = Filename;\n+    Member->name = Name;\n+    if (child)\n+        Member->child = *child;\n+    return Member;\n+}\n+\n+extern \"C\" void\n+LLVMRustArchiveMemberFree(LLVMRustArchiveMember *Member) {\n+    delete Member;\n+}\n+\n+extern \"C\" int\n+LLVMRustWriteArchive(char *Dst,\n+                     size_t NumMembers,\n+                     const LLVMRustArchiveMember **NewMembers,\n+                     bool WriteSymbtab) {\n+#if LLVM_VERSION_MINOR >= 7\n+  std::vector<NewArchiveIterator> Members;\n+\n+  for (size_t i = 0; i < NumMembers; i++) {\n+    auto Member = NewMembers[i];\n+    assert(Member->name);\n+    if (Member->filename) {\n+      Members.push_back(NewArchiveIterator(Member->filename, Member->name));\n+    } else {\n+      Members.push_back(NewArchiveIterator(Member->child, Member->name));\n+    }\n+  }\n+  auto pair = writeArchive(Dst, Members, WriteSymbtab);\n+  if (!pair.second)\n+    return 0;\n+  LLVMRustSetLastError(pair.second.message().c_str());\n+#else\n+  LLVMRustSetLastError(\"writing archives not supported with this LLVM version\");\n+#endif\n+  return -1;\n+}"}, {"sha": "6861ad43a3cfa334b4db01dd177afb461d89d562", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4a824275b9b057f43a7dbab84583ad7c2a1a2e63/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=4a824275b9b057f43a7dbab84583ad7c2a1a2e63", "patch": "@@ -825,107 +825,6 @@ LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n     return true;\n }\n \n-extern \"C\" void*\n-LLVMRustOpenArchive(char *path) {\n-    ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or = MemoryBuffer::getFile(path,\n-                                                                          -1,\n-                                                                          false);\n-    if (!buf_or) {\n-        LLVMRustSetLastError(buf_or.getError().message().c_str());\n-        return nullptr;\n-    }\n-\n-#if LLVM_VERSION_MINOR >= 6\n-    ErrorOr<std::unique_ptr<Archive>> archive_or =\n-        Archive::create(buf_or.get()->getMemBufferRef());\n-\n-    if (!archive_or) {\n-        LLVMRustSetLastError(archive_or.getError().message().c_str());\n-        return nullptr;\n-    }\n-\n-    OwningBinary<Archive> *ret = new OwningBinary<Archive>(\n-            std::move(archive_or.get()), std::move(buf_or.get()));\n-#else\n-    std::error_code err;\n-    Archive *ret = new Archive(std::move(buf_or.get()), err);\n-    if (err) {\n-        LLVMRustSetLastError(err.message().c_str());\n-        return nullptr;\n-    }\n-#endif\n-\n-    return ret;\n-}\n-\n-#if LLVM_VERSION_MINOR >= 6\n-typedef OwningBinary<Archive> RustArchive;\n-#define GET_ARCHIVE(a) ((a)->getBinary())\n-#else\n-typedef Archive RustArchive;\n-#define GET_ARCHIVE(a) (a)\n-#endif\n-\n-extern \"C\" void\n-LLVMRustDestroyArchive(RustArchive *ar) {\n-    delete ar;\n-}\n-\n-struct RustArchiveIterator {\n-    Archive::child_iterator cur;\n-    Archive::child_iterator end;\n-};\n-\n-extern \"C\" RustArchiveIterator*\n-LLVMRustArchiveIteratorNew(RustArchive *ra) {\n-    Archive *ar = GET_ARCHIVE(ra);\n-    RustArchiveIterator *rai = new RustArchiveIterator();\n-    rai->cur = ar->child_begin();\n-    rai->end = ar->child_end();\n-    return rai;\n-}\n-\n-extern \"C\" const Archive::Child*\n-LLVMRustArchiveIteratorCurrent(RustArchiveIterator *rai) {\n-    if (rai->cur == rai->end)\n-        return NULL;\n-#if LLVM_VERSION_MINOR >= 6\n-    const Archive::Child &ret = *rai->cur;\n-    return &ret;\n-#else\n-    return rai->cur.operator->();\n-#endif\n-}\n-\n-extern \"C\" void\n-LLVMRustArchiveIteratorNext(RustArchiveIterator *rai) {\n-    if (rai->cur == rai->end)\n-        return;\n-    ++rai->cur;\n-}\n-\n-extern \"C\" void\n-LLVMRustArchiveIteratorFree(RustArchiveIterator *rai) {\n-    delete rai;\n-}\n-\n-extern \"C\" const char*\n-LLVMRustArchiveChildName(const Archive::Child *child, size_t *size) {\n-    ErrorOr<StringRef> name_or_err = child->getName();\n-    if (name_or_err.getError())\n-        return NULL;\n-    StringRef name = name_or_err.get();\n-    *size = name.size();\n-    return name.data();\n-}\n-\n-extern \"C\" const char*\n-LLVMRustArchiveChildData(Archive::Child *child, size_t *size) {\n-    StringRef buf = child->getBuffer();\n-    *size = buf.size();\n-    return buf.data();\n-}\n-\n extern \"C\" void\n LLVMRustSetDLLStorageClass(LLVMValueRef Value,\n                            GlobalValue::DLLStorageClassTypes Class) {"}]}