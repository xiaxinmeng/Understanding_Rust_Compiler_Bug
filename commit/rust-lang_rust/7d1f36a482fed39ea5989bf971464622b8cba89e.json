{"sha": "7d1f36a482fed39ea5989bf971464622b8cba89e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMWYzNmE0ODJmZWQzOWVhNTk4OWJmOTcxNDY0NjIyYjhjYmE4OWU=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-02-04T23:09:55Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-02-10T17:47:09Z"}, "message": "Inline open_drop_for_variant & clean matches::test", "tree": {"sha": "a6aca8fd5242a7a7927c41dc93806d4814f55726", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6aca8fd5242a7a7927c41dc93806d4814f55726"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d1f36a482fed39ea5989bf971464622b8cba89e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d1f36a482fed39ea5989bf971464622b8cba89e", "html_url": "https://github.com/rust-lang/rust/commit/7d1f36a482fed39ea5989bf971464622b8cba89e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d1f36a482fed39ea5989bf971464622b8cba89e/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49ccc106da350ecc9c5dd6540f3c7e5d51caa2c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/49ccc106da350ecc9c5dd6540f3c7e5d51caa2c8", "html_url": "https://github.com/rust-lang/rust/commit/49ccc106da350ecc9c5dd6540f3c7e5d51caa2c8"}], "stats": {"total": 86, "additions": 32, "deletions": 54}, "files": [{"sha": "5899c9f31d14dc4c4d00c73a2183a37db193b566", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 22, "deletions": 43, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7d1f36a482fed39ea5989bf971464622b8cba89e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d1f36a482fed39ea5989bf971464622b8cba89e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=7d1f36a482fed39ea5989bf971464622b8cba89e", "patch": "@@ -620,48 +620,11 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         self.elaborated_drop_block(&inner_c)\n     }\n \n-    fn open_drop_for_variant<'a>(&mut self,\n-                                 c: &DropCtxt<'a, 'tcx>,\n-                                 drop_block: &mut Option<BasicBlock>,\n-                                 adt: &'tcx ty::AdtDef,\n-                                 substs: &'tcx Substs<'tcx>,\n-                                 variant_index: usize)\n-                                 -> (BasicBlock, bool)\n-    {\n-        let subpath = super::move_path_children_matching(\n-            self.move_data(), c.path, |proj| match proj {\n-                &Projection {\n-                    elem: ProjectionElem::Downcast(_, idx), ..\n-                } => idx == variant_index,\n-                _ => false\n-            });\n-\n-        if let Some(variant_path) = subpath {\n-            let base_lv = c.lvalue.clone().elem(\n-                ProjectionElem::Downcast(adt, variant_index)\n-            );\n-            let fields = self.move_paths_for_fields(\n-                &base_lv,\n-                variant_path,\n-                &adt.variants[variant_index],\n-                substs);\n-            (self.drop_ladder(c, fields), true)\n-        } else {\n-            // variant not found - drop the entire enum\n-            if let None = *drop_block {\n-                *drop_block = Some(self.complete_drop(c, true));\n-            }\n-            (drop_block.unwrap(), false)\n-        }\n-    }\n-\n     fn open_drop_for_adt<'a>(&mut self, c: &DropCtxt<'a, 'tcx>,\n                              adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n                              -> BasicBlock {\n         debug!(\"open_drop_for_adt({:?}, {:?}, {:?})\", c, adt, substs);\n \n-        let mut drop_block = None;\n-\n         match adt.variants.len() {\n             1 => {\n                 let fields = self.move_paths_for_fields(\n@@ -676,17 +639,33 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 let mut values = Vec::with_capacity(adt.variants.len());\n                 let mut blocks = Vec::with_capacity(adt.variants.len());\n                 let mut otherwise = None;\n-                for (idx, variant) in adt.variants.iter().enumerate() {\n+                for (variant_index, variant) in adt.variants.iter().enumerate() {\n                     let discr = ConstInt::new_inttype(variant.disr_val, adt.discr_ty,\n                                                       self.tcx.sess.target.uint_type,\n                                                       self.tcx.sess.target.int_type).unwrap();\n-                    let (blk, is_ladder) = self.open_drop_for_variant(c, &mut drop_block, adt,\n-                                                                      substs, idx);\n-                    if is_ladder {\n+                    let subpath = super::move_path_children_matching(\n+                        self.move_data(), c.path, |proj| match proj {\n+                            &Projection {\n+                                elem: ProjectionElem::Downcast(_, idx), ..\n+                            } => idx == variant_index,\n+                            _ => false\n+                        });\n+                    if let Some(variant_path) = subpath {\n+                        let base_lv = c.lvalue.clone().elem(\n+                            ProjectionElem::Downcast(adt, variant_index)\n+                        );\n+                        let fields = self.move_paths_for_fields(\n+                            &base_lv,\n+                            variant_path,\n+                            &adt.variants[variant_index],\n+                            substs);\n                         values.push(discr);\n-                        blocks.push(blk);\n+                        blocks.push(self.drop_ladder(c, fields));\n                     } else {\n-                        otherwise = Some(blk)\n+                        // variant not found - drop the entire enum\n+                        if let None = otherwise {\n+                            otherwise = Some(self.complete_drop(c, true));\n+                        }\n                     }\n                 }\n                 if let Some(block) = otherwise {"}, {"sha": "01c0433112bf33aa1edd2929d187bc1564ed9e14", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7d1f36a482fed39ea5989bf971464622b8cba89e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d1f36a482fed39ea5989bf971464622b8cba89e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=7d1f36a482fed39ea5989bf971464622b8cba89e", "patch": "@@ -227,8 +227,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             TestKind::SwitchInt { switch_ty, ref options, indices: _ } => {\n-                let (values, targets, ret) = if switch_ty.sty == ty::TyBool {\n-                    static BOOL_SWITCH_FALSE: &'static [ConstInt] = &[ConstInt::Infer(0)];\n+                let (ret, terminator) = if switch_ty.sty == ty::TyBool {\n                     assert!(options.len() > 0 && options.len() <= 2);\n                     let (true_bb, false_bb) = (self.cfg.start_new_block(),\n                                                self.cfg.start_new_block());\n@@ -237,7 +236,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         &ConstVal::Bool(false) => vec![false_bb, true_bb],\n                         v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n                     };\n-                    (From::from(BOOL_SWITCH_FALSE), vec![false_bb, true_bb], ret)\n+                    (ret, TerminatorKind::if_(self.hir.tcx(), Operand::Consume(lvalue.clone()),\n+                                              true_bb, false_bb))\n                 } else {\n                     // The switch may be inexhaustive so we\n                     // add a catch all block\n@@ -250,15 +250,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let values: Vec<_> = options.iter().map(|v|\n                         v.to_const_int().expect(\"switching on integral\")\n                     ).collect();\n-                    (From::from(values), targets.clone(), targets)\n+                    (targets.clone(), TerminatorKind::SwitchInt {\n+                        discr: Operand::Consume(lvalue.clone()),\n+                        switch_ty: switch_ty,\n+                        values: From::from(values),\n+                        targets: targets,\n+                    })\n                 };\n-\n-                self.cfg.terminate(block, source_info, TerminatorKind::SwitchInt {\n-                    discr: Operand::Consume(lvalue.clone()),\n-                    switch_ty: switch_ty,\n-                    values: values,\n-                    targets: targets.clone(),\n-                });\n+                self.cfg.terminate(block, source_info, terminator);\n                 ret\n             }\n "}]}