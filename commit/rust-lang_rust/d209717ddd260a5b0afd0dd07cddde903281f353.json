{"sha": "d209717ddd260a5b0afd0dd07cddde903281f353", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMDk3MTdkZGQyNjBhNWIwYWZkMGRkMDdjZGRkZTkwMzI4MWYzNTM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-09-21T01:49:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-09-26T03:05:56Z"}, "message": "std::rt: Implement task yielding. Fix a starvation problem", "tree": {"sha": "6c04e6cd4444c87239db877c2a4ca4ba3c05d0a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c04e6cd4444c87239db877c2a4ca4ba3c05d0a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d209717ddd260a5b0afd0dd07cddde903281f353", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d209717ddd260a5b0afd0dd07cddde903281f353", "html_url": "https://github.com/rust-lang/rust/commit/d209717ddd260a5b0afd0dd07cddde903281f353", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d209717ddd260a5b0afd0dd07cddde903281f353/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00db6f6e7be04882b67660adcf04811511d4b8c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/00db6f6e7be04882b67660adcf04811511d4b8c2", "html_url": "https://github.com/rust-lang/rust/commit/00db6f6e7be04882b67660adcf04811511d4b8c2"}], "stats": {"total": 173, "additions": 141, "deletions": 32}, "files": [{"sha": "d7b444691776805d78728d295095d1809ed62bd3", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d209717ddd260a5b0afd0dd07cddde903281f353/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d209717ddd260a5b0afd0dd07cddde903281f353/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=d209717ddd260a5b0afd0dd07cddde903281f353", "patch": "@@ -118,6 +118,17 @@ impl<T> ChanOne<T> {\n             rtassert!(!rt::in_sched_context());\n         }\n \n+        // In order to prevent starvation of other tasks in situations\n+        // where a task sends repeatedly without ever receiving, we\n+        // occassionally yield instead of doing a send immediately.\n+        // Only doing this if we're doing a rescheduling send,\n+        // otherwise the caller is expecting not to context switch.\n+        if do_resched {\n+            // XXX: This TLS hit should be combined with other uses of the scheduler below\n+            let sched: ~Scheduler = Local::take();\n+            sched.maybe_yield();\n+        }\n+\n         let mut this = self;\n         let mut recvr_active = true;\n         let packet = this.packet();"}, {"sha": "a62d3335644573a43462fd54865aca5300bb9556", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 129, "deletions": 28, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/d209717ddd260a5b0afd0dd07cddde903281f353/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d209717ddd260a5b0afd0dd07cddde903281f353/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=d209717ddd260a5b0afd0dd07cddde903281f353", "patch": "@@ -26,7 +26,7 @@ use rt::local::Local;\n use rt::rtio::{RemoteCallback, PausibleIdleCallback};\n use borrow::{to_uint};\n use cell::Cell;\n-use rand::{XorShiftRng, Rng};\n+use rand::{XorShiftRng, Rng, Rand};\n use iter::range;\n use vec::{OwnedVector};\n \n@@ -78,7 +78,14 @@ pub struct Scheduler {\n     /// A fast XorShift rng for scheduler use\n     rng: XorShiftRng,\n     /// A toggleable idle callback\n-    idle_callback: Option<~PausibleIdleCallback>\n+    idle_callback: Option<~PausibleIdleCallback>,\n+    /// A countdown that starts at a random value and is decremented\n+    /// every time a yield check is performed. When it hits 0 a task\n+    /// will yield.\n+    yield_check_count: uint,\n+    /// A flag to tell the scheduler loop it needs to do some stealing\n+    /// in order to introduce randomness as part of a yield\n+    steal_for_yield: bool\n }\n \n /// An indication of how hard to work on a given operation, the difference\n@@ -89,6 +96,13 @@ enum EffortLevel {\n     GiveItYourBest\n }\n \n+static MAX_YIELD_CHECKS: uint = 200;\n+\n+fn reset_yield_check(rng: &mut XorShiftRng) -> uint {\n+    let r: uint = Rand::rand(rng);\n+    r % MAX_YIELD_CHECKS + 1\n+}\n+\n impl Scheduler {\n \n     // * Initialization Functions\n@@ -113,7 +127,7 @@ impl Scheduler {\n                        friend: Option<SchedHandle>)\n         -> Scheduler {\n \n-        Scheduler {\n+        let mut sched = Scheduler {\n             sleeper_list: sleeper_list,\n             message_queue: MessageQueue::new(),\n             sleepy: false,\n@@ -127,8 +141,14 @@ impl Scheduler {\n             run_anything: run_anything,\n             friend_handle: friend,\n             rng: XorShiftRng::new(),\n-            idle_callback: None\n-        }\n+            idle_callback: None,\n+            yield_check_count: 0,\n+            steal_for_yield: false\n+        };\n+\n+        sched.yield_check_count = reset_yield_check(&mut sched.rng);\n+\n+        return sched;\n     }\n \n     // XXX: This may eventually need to be refactored so that\n@@ -307,8 +327,7 @@ impl Scheduler {\n             }\n             Some(TaskFromFriend(task)) => {\n                 rtdebug!(\"got a task from a friend. lovely!\");\n-                this.process_task(task,\n-                                  Scheduler::resume_task_immediately_cl).map_move(Local::put);\n+                this.process_task(task, Scheduler::resume_task_immediately_cl);\n                 return None;\n             }\n             Some(Wake) => {\n@@ -352,8 +371,8 @@ impl Scheduler {\n         match this.find_work() {\n             Some(task) => {\n                 rtdebug!(\"found some work! processing the task\");\n-                return this.process_task(task,\n-                                         Scheduler::resume_task_immediately_cl);\n+                this.process_task(task, Scheduler::resume_task_immediately_cl);\n+                return None;\n             }\n             None => {\n                 rtdebug!(\"no work was found, returning the scheduler struct\");\n@@ -373,14 +392,35 @@ impl Scheduler {\n     // there, trying to steal from the remote work queues.\n     fn find_work(&mut self) -> Option<~Task> {\n         rtdebug!(\"scheduler looking for work\");\n-        match self.work_queue.pop() {\n-            Some(task) => {\n-                rtdebug!(\"found a task locally\");\n-                return Some(task)\n+        if !self.steal_for_yield {\n+            match self.work_queue.pop() {\n+                Some(task) => {\n+                    rtdebug!(\"found a task locally\");\n+                    return Some(task)\n+                }\n+                None => {\n+                    rtdebug!(\"scheduler trying to steal\");\n+                    return self.try_steals();\n+                }\n             }\n-            None => {\n-                rtdebug!(\"scheduler trying to steal\");\n-                return self.try_steals();\n+        } else {\n+            // During execution of the last task, it performed a 'yield',\n+            // so we're doing some work stealing in order to introduce some\n+            // scheduling randomness. Otherwise we would just end up popping\n+            // that same task again. This is pretty lame and is to work around\n+            // the problem that work stealing is not designed for 'non-strict'\n+            // (non-fork-join) task parallelism.\n+            self.steal_for_yield = false;\n+            match self.try_steals() {\n+                Some(task) => {\n+                    rtdebug!(\"stole a task after yielding\");\n+                    return Some(task);\n+                }\n+                None => {\n+                    rtdebug!(\"did not steal a task after yielding\");\n+                    // Back to business\n+                    return self.find_work();\n+                }\n             }\n         }\n     }\n@@ -409,7 +449,7 @@ impl Scheduler {\n     // place.\n \n     fn process_task(~self, task: ~Task,\n-                    schedule_fn: SchedulingFn) -> Option<~Scheduler> {\n+                    schedule_fn: SchedulingFn) {\n         let mut this = self;\n         let mut task = task;\n \n@@ -422,23 +462,23 @@ impl Scheduler {\n                     rtdebug!(\"sending task home\");\n                     task.give_home(Sched(home_handle));\n                     Scheduler::send_task_home(task);\n-                    return Some(this);\n+                    Local::put(this);\n                 } else {\n                     rtdebug!(\"running task here\");\n                     task.give_home(Sched(home_handle));\n-                    return schedule_fn(this, task);\n+                    schedule_fn(this, task);\n                 }\n             }\n             AnySched if this.run_anything => {\n                 rtdebug!(\"running anysched task here\");\n                 task.give_home(AnySched);\n-                return schedule_fn(this, task);\n+                schedule_fn(this, task);\n             }\n             AnySched => {\n                 rtdebug!(\"sending task to friend\");\n                 task.give_home(AnySched);\n                 this.send_to_friend(task);\n-                return Some(this);\n+                Local::put(this);\n             }\n         }\n     }\n@@ -607,15 +647,14 @@ impl Scheduler {\n \n     // * Context Swapping Helpers - Here be ugliness!\n \n-    pub fn resume_task_immediately(~self, task: ~Task) -> Option<~Scheduler> {\n+    pub fn resume_task_immediately(~self, task: ~Task) {\n         do self.change_task_context(task) |sched, stask| {\n             sched.sched_task = Some(stask);\n         }\n-        return None;\n     }\n \n     fn resume_task_immediately_cl(sched: ~Scheduler,\n-                                  task: ~Task) -> Option<~Scheduler> {\n+                                  task: ~Task) {\n         sched.resume_task_immediately(task)\n     }\n \n@@ -662,11 +701,10 @@ impl Scheduler {\n         }\n     }\n \n-    fn switch_task(sched: ~Scheduler, task: ~Task) -> Option<~Scheduler> {\n+    fn switch_task(sched: ~Scheduler, task: ~Task) {\n         do sched.switch_running_tasks_and_then(task) |sched, last_task| {\n             sched.enqueue_blocked_task(last_task);\n         };\n-        return None;\n     }\n \n     // * Task Context Helpers\n@@ -686,7 +724,7 @@ impl Scheduler {\n \n     pub fn run_task(task: ~Task) {\n         let sched: ~Scheduler = Local::take();\n-        sched.process_task(task, Scheduler::switch_task).map_move(Local::put);\n+        sched.process_task(task, Scheduler::switch_task);\n     }\n \n     pub fn run_task_later(next_task: ~Task) {\n@@ -696,6 +734,33 @@ impl Scheduler {\n         };\n     }\n \n+    /// Yield control to the scheduler, executing another task. This is guaranteed\n+    /// to introduce some amount of randomness to the scheduler. Currently the\n+    /// randomness is a result of performing a round of work stealing (which\n+    /// may end up stealing from the current scheduler).\n+    pub fn yield_now(~self) {\n+        let mut this = self;\n+        this.yield_check_count = reset_yield_check(&mut this.rng);\n+        // Tell the scheduler to start stealing on the next iteration\n+        this.steal_for_yield = true;\n+        do this.deschedule_running_task_and_then |sched, task| {\n+            sched.enqueue_blocked_task(task);\n+        }\n+    }\n+\n+    pub fn maybe_yield(~self) {\n+        // The number of times to do the yield check before yielding, chosen arbitrarily.\n+        let mut this = self;\n+        rtassert!(this.yield_check_count > 0);\n+        this.yield_check_count -= 1;\n+        if this.yield_check_count == 0 {\n+            this.yield_now();\n+        } else {\n+            Local::put(this);\n+        }\n+    }\n+\n+\n     // * Utility Functions\n \n     pub fn sched_id(&self) -> uint { to_uint(self) }\n@@ -718,7 +783,7 @@ impl Scheduler {\n \n // Supporting types\n \n-type SchedulingFn = ~fn(~Scheduler, ~Task) -> Option<~Scheduler>;\n+type SchedulingFn = ~fn(~Scheduler, ~Task);\n \n pub enum SchedMessage {\n     Wake,\n@@ -1231,4 +1296,40 @@ mod test {\n             }\n         }\n     }\n+\n+    #[test]\n+    fn dont_starve_2() {\n+        use rt::comm::oneshot;\n+\n+        do stress_factor().times {\n+            do run_in_newsched_task {\n+                let (port, chan) = oneshot();\n+                let (_port2, chan2) = stream();\n+\n+                // This task should not be able to starve the other task.\n+                // The sends should eventually yield.\n+                do spawntask {\n+                    while !port.peek() {\n+                        chan2.send(());\n+                    }\n+                }\n+\n+                chan.send(());\n+            }\n+        }\n+    }\n+\n+    // Regression test for a logic bug that would cause single-threaded schedulers\n+    // to sleep forever after yielding and stealing another task.\n+    #[test]\n+    fn single_threaded_yield() {\n+        use task::{spawn, spawn_sched, SingleThreaded, deschedule};\n+        use num::Times;\n+\n+        do spawn_sched(SingleThreaded) {\n+            do 5.times { deschedule(); }\n+        }\n+        do spawn { }\n+        do spawn { }\n+    }\n }"}, {"sha": "e6f6536956c9ff077789e109a7226f69e2cc3741", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d209717ddd260a5b0afd0dd07cddde903281f353/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d209717ddd260a5b0afd0dd07cddde903281f353/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=d209717ddd260a5b0afd0dd07cddde903281f353", "patch": "@@ -542,12 +542,9 @@ pub fn deschedule() {\n     use rt::local::Local;\n     use rt::sched::Scheduler;\n \n-    // FIXME #6842: What does yield really mean in newsched?\n     // FIXME(#7544): Optimize this, since we know we won't block.\n     let sched: ~Scheduler = Local::take();\n-    do sched.deschedule_running_task_and_then |sched, task| {\n-        sched.enqueue_blocked_task(task);\n-    }\n+    sched.yield_now();\n }\n \n pub fn failing() -> bool {"}]}