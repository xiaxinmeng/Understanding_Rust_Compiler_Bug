{"sha": "5b2291cfa6ae9374ca22cf5d0aafde1a3f23ea57", "node_id": "C_kwDOAAsO6NoAKDViMjI5MWNmYTZhZTkzNzRjYTIyY2Y1ZDBhYWZkZTFhM2YyM2VhNTc", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-11T07:36:37Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-15T17:17:07Z"}, "message": "introduce gather_gat_bounds", "tree": {"sha": "15d3138e00c0fcf86704c84e5d5653175353467b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15d3138e00c0fcf86704c84e5d5653175353467b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b2291cfa6ae9374ca22cf5d0aafde1a3f23ea57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b2291cfa6ae9374ca22cf5d0aafde1a3f23ea57", "html_url": "https://github.com/rust-lang/rust/commit/5b2291cfa6ae9374ca22cf5d0aafde1a3f23ea57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b2291cfa6ae9374ca22cf5d0aafde1a3f23ea57/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55697574915ca58c3fcd7b1c854c1c93e002dc85", "url": "https://api.github.com/repos/rust-lang/rust/commits/55697574915ca58c3fcd7b1c854c1c93e002dc85", "html_url": "https://github.com/rust-lang/rust/commit/55697574915ca58c3fcd7b1c854c1c93e002dc85"}], "stats": {"total": 254, "additions": 131, "deletions": 123}, "files": [{"sha": "9a269e024483004450d0cdbdd1b81aac5721838f", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 131, "deletions": 123, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/5b2291cfa6ae9374ca22cf5d0aafde1a3f23ea57/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b2291cfa6ae9374ca22cf5d0aafde1a3f23ea57/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=5b2291cfa6ae9374ca22cf5d0aafde1a3f23ea57", "patch": "@@ -298,145 +298,49 @@ fn check_gat_where_clauses(\n     for item in\n         associated_items.in_definition_order().filter(|item| matches!(item.kind, ty::AssocKind::Fn))\n     {\n-        // The clauses we that we would require from this function\n-        let mut function_clauses = FxHashSet::default();\n-\n         let id = hir::HirId::make_owner(item.def_id.expect_local());\n         let param_env = tcx.param_env(item.def_id.expect_local());\n \n-        let sig = tcx.fn_sig(item.def_id);\n         // Get the signature using placeholders. In our example, this would\n         // convert the late-bound 'a into a free region.\n-        let sig = tcx.liberate_late_bound_regions(item.def_id, sig);\n-        // Collect the arguments that are given to this GAT in the return type\n-        // of  the function signature. In our example, the GAT in the return\n-        // type is `<Self as LendingIterator>::Item<'a>`, so 'a and Self are arguments.\n-        let (regions, types) =\n-            GATSubstCollector::visit(tcx, trait_item.def_id.to_def_id(), sig.output());\n-\n-        // If both regions and types are empty, then this GAT isn't in the\n-        // return type, and we shouldn't try to do clause analysis\n-        // (particularly, doing so would end up with an empty set of clauses,\n-        // since the current method would require none, and we take the\n-        // intersection of requirements of all methods)\n-        if types.is_empty() && regions.is_empty() {\n-            continue;\n-        }\n+        let sig = tcx.liberate_late_bound_regions(item.def_id, tcx.fn_sig(item.def_id));\n \n         // The types we can assume to be well-formed. In our example, this\n         // would be &'a mut Self, from the first argument.\n         let mut wf_tys = FxHashSet::default();\n         wf_tys.extend(sig.inputs());\n \n-        // For each region argument (e.g., 'a in our example), check for a\n-        // relationship to the type arguments (e.g., Self). If there is an\n-        // outlives relationship (`Self: 'a`), then we want to ensure that is\n-        // reflected in a where clause on the GAT itself.\n-        for (region, region_idx) in &regions {\n-            // Ignore `'static` lifetimes for the purpose of this lint: it's\n-            // because we know it outlives everything and so doesn't give meaninful\n-            // clues\n-            if region.is_static() {\n-                continue;\n-            }\n-            for (ty, ty_idx) in &types {\n-                // In our example, requires that Self: 'a\n-                if ty_known_to_outlive(tcx, id, param_env, &wf_tys, *ty, *region) {\n-                    debug!(?ty_idx, ?region_idx);\n-                    debug!(\"required clause: {} must outlive {}\", ty, region);\n-                    // Translate into the generic parameters of the GAT. In\n-                    // our example, the type was Self, which will also be\n-                    // Self in the GAT.\n-                    let ty_param = generics.param_at(*ty_idx, tcx);\n-                    let ty_param = tcx.mk_ty(ty::Param(ty::ParamTy {\n-                        index: ty_param.index,\n-                        name: ty_param.name,\n-                    }));\n-                    // Same for the region. In our example, 'a corresponds\n-                    // to the 'me parameter.\n-                    let region_param = generics.param_at(*region_idx, tcx);\n-                    let region_param = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                        def_id: region_param.def_id,\n-                        index: region_param.index,\n-                        name: region_param.name,\n-                    }));\n-                    // The predicate we expect to see. (In our example,\n-                    // `Self: 'me`.)\n-                    let clause = ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                        ty_param,\n-                        region_param,\n-                    ));\n-                    let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n-                    function_clauses.insert(clause);\n-                }\n-            }\n-        }\n+        // The clauses we that we would require from this function\n+        let function_clauses = gather_gat_bounds(\n+            tcx,\n+            param_env,\n+            id,\n+            sig.output(),\n+            &wf_tys,\n+            trait_item.def_id,\n+            generics,\n+        );\n \n-        // For each region argument (e.g., 'a in our example), also check for a\n-        // relationship to the other region arguments. If there is an\n-        // outlives relationship, then we want to ensure that is\n-        // reflected in a where clause on the GAT itself.\n-        for (region_a, region_a_idx) in &regions {\n-            // Ignore `'static` lifetimes for the purpose of this lint: it's\n-            // because we know it outlives everything and so doesn't give meaninful\n-            // clues\n-            if region_a.is_static() {\n-                continue;\n-            }\n-            for (region_b, region_b_idx) in &regions {\n-                if region_a == region_b {\n-                    continue;\n-                }\n-                if region_b.is_static() {\n-                    continue;\n+        if let Some(function_clauses) = function_clauses {\n+            // Imagine we have:\n+            // ```\n+            // trait Foo {\n+            //   type Bar<'me>;\n+            //   fn gimme(&self) -> Self::Bar<'_>;\n+            //   fn gimme_default(&self) -> Self::Bar<'static>;\n+            // }\n+            // ```\n+            // We only want to require clauses on `Bar` that we can prove from *all* functions (in this\n+            // case, `'me` can be `static` from `gimme_default`)\n+            match clauses.as_mut() {\n+                Some(clauses) => {\n+                    clauses.drain_filter(|p| !function_clauses.contains(p));\n                 }\n-\n-                if region_known_to_outlive(tcx, id, param_env, &wf_tys, *region_a, *region_b) {\n-                    debug!(?region_a_idx, ?region_b_idx);\n-                    debug!(\"required clause: {} must outlive {}\", region_a, region_b);\n-                    // Translate into the generic parameters of the GAT.\n-                    let region_a_param = generics.param_at(*region_a_idx, tcx);\n-                    let region_a_param = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                        def_id: region_a_param.def_id,\n-                        index: region_a_param.index,\n-                        name: region_a_param.name,\n-                    }));\n-                    // Same for the region.\n-                    let region_b_param = generics.param_at(*region_b_idx, tcx);\n-                    let region_b_param = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                        def_id: region_b_param.def_id,\n-                        index: region_b_param.index,\n-                        name: region_b_param.name,\n-                    }));\n-                    // The predicate we expect to see.\n-                    let clause = ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n-                        region_a_param,\n-                        region_b_param,\n-                    ));\n-                    let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n-                    function_clauses.insert(clause);\n+                None => {\n+                    clauses = Some(function_clauses);\n                 }\n             }\n         }\n-\n-        // Imagine we have:\n-        // ```\n-        // trait Foo {\n-        //   type Bar<'me>;\n-        //   fn gimme(&self) -> Self::Bar<'_>;\n-        //   fn gimme_default(&self) -> Self::Bar<'static>;\n-        // }\n-        // ```\n-        // We only want to require clauses on `Bar` that we can prove from *all* functions (in this\n-        // case, `'me` can be `static` from `gimme_default`)\n-        match clauses.as_mut() {\n-            Some(clauses) => {\n-                clauses.drain_filter(|p| !function_clauses.contains(p));\n-            }\n-            None => {\n-                clauses = Some(function_clauses);\n-            }\n-        }\n     }\n \n     // If there are any clauses that aren't provable, emit an error\n@@ -515,6 +419,110 @@ fn check_gat_where_clauses(\n     }\n }\n \n+fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    item_hir: hir::HirId,\n+    to_check: T,\n+    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    gat_def_id: LocalDefId,\n+    gat_generics: &'tcx ty::Generics,\n+) -> Option<FxHashSet<ty::Predicate<'tcx>>> {\n+    // The bounds we that we would require from this function\n+    let mut bounds = FxHashSet::default();\n+\n+    let (regions, types) = GATSubstCollector::visit(tcx, gat_def_id.to_def_id(), to_check);\n+\n+    // If both regions and types are empty, then this GAT isn't in the\n+    // return type, and we shouldn't try to do clause analysis\n+    // (particularly, doing so would end up with an empty set of clauses,\n+    // since the current method would require none, and we take the\n+    // intersection of requirements of all methods)\n+    if types.is_empty() && regions.is_empty() {\n+        return None;\n+    }\n+\n+    for (region_a, region_a_idx) in &regions {\n+        // Ignore `'static` lifetimes for the purpose of this lint: it's\n+        // because we know it outlives everything and so doesn't give meaninful\n+        // clues\n+        if let ty::ReStatic = **region_a {\n+            continue;\n+        }\n+        // For each region argument (e.g., 'a in our example), check for a\n+        // relationship to the type arguments (e.g., Self). If there is an\n+        // outlives relationship (`Self: 'a`), then we want to ensure that is\n+        // reflected in a where clause on the GAT itself.\n+        for (ty, ty_idx) in &types {\n+            // In our example, requires that Self: 'a\n+            if ty_known_to_outlive(tcx, item_hir, param_env, &wf_tys, *ty, *region_a) {\n+                debug!(?ty_idx, ?region_a_idx);\n+                debug!(\"required clause: {} must outlive {}\", ty, region_a);\n+                // Translate into the generic parameters of the GAT. In\n+                // our example, the type was Self, which will also be\n+                // Self in the GAT.\n+                let ty_param = gat_generics.param_at(*ty_idx, tcx);\n+                let ty_param = tcx\n+                    .mk_ty(ty::Param(ty::ParamTy { index: ty_param.index, name: ty_param.name }));\n+                // Same for the region. In our example, 'a corresponds\n+                // to the 'me parameter.\n+                let region_param = gat_generics.param_at(*region_a_idx, tcx);\n+                let region_param =\n+                    tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n+                        def_id: region_param.def_id,\n+                        index: region_param.index,\n+                        name: region_param.name,\n+                    }));\n+                // The predicate we expect to see. (In our example,\n+                // `Self: 'me`.)\n+                let clause =\n+                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_param, region_param));\n+                let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n+                bounds.insert(clause);\n+            }\n+        }\n+\n+        // For each region argument (e.g., 'a in our example), also check for a\n+        // relationship to the other region arguments. If there is an\n+        // outlives relationship, then we want to ensure that is\n+        // reflected in a where clause on the GAT itself.\n+        for (region_b, region_b_idx) in &regions {\n+            if ty::ReStatic == **region_b || region_a == region_b {\n+                continue;\n+            }\n+            if region_known_to_outlive(tcx, item_hir, param_env, &wf_tys, *region_a, *region_b) {\n+                debug!(?region_a_idx, ?region_b_idx);\n+                debug!(\"required clause: {} must outlive {}\", region_a, region_b);\n+                // Translate into the generic parameters of the GAT.\n+                let region_a_param = gat_generics.param_at(*region_a_idx, tcx);\n+                let region_a_param =\n+                    tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n+                        def_id: region_a_param.def_id,\n+                        index: region_a_param.index,\n+                        name: region_a_param.name,\n+                    }));\n+                // Same for the region.\n+                let region_b_param = gat_generics.param_at(*region_b_idx, tcx);\n+                let region_b_param =\n+                    tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n+                        def_id: region_b_param.def_id,\n+                        index: region_b_param.index,\n+                        name: region_b_param.name,\n+                    }));\n+                // The predicate we expect to see.\n+                let clause = ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n+                    region_a_param,\n+                    region_b_param,\n+                ));\n+                let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n+                bounds.insert(clause);\n+            }\n+        }\n+    }\n+\n+    Some(bounds)\n+}\n+\n /// Given a known `param_env` and a set of well formed types, can we prove that\n /// `ty` outlives `region`.\n fn ty_known_to_outlive<'tcx>("}]}