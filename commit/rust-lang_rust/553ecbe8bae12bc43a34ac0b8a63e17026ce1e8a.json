{"sha": "553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "node_id": "C_kwDOAAsO6NoAKDU1M2VjYmU4YmFlMTJiYzQzYTM0YWMwYjhhNjNlMTcwMjZjZTFlOGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-27T10:44:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-27T10:44:27Z"}, "message": "Auto merge of #109652 - matthiaskrgr:rollup-pbw3hi3, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #97506 (Stabilize `nonnull_slice_from_raw_parts`)\n - #98651 (Follow C-RW-VALUE in std::io::Cursor example)\n - #102742 (Remove unnecessary raw pointer in __rust_start_panic arg)\n - #109587 (Use an IndexVec to debug fingerprints.)\n - #109613 (fix type suggestions in match arms)\n - #109633 (Fix \"Directly go to item in search if there is only one result\" setting)\n - #109635 (debuginfo: Get pointer size/align from tcx.data_layout instead of layout_of)\n - #109641 (Don't elaborate non-obligations into obligations)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a6f0f5595f20fea86645f5d4cb75a91722ff5578", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6f0f5595f20fea86645f5d4cb75a91722ff5578"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "html_url": "https://github.com/rust-lang/rust/commit/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309", "html_url": "https://github.com/rust-lang/rust/commit/7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309"}, {"sha": "6535e66fa545acaa3c0fe015b83a2e502c10119a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6535e66fa545acaa3c0fe015b83a2e502c10119a", "html_url": "https://github.com/rust-lang/rust/commit/6535e66fa545acaa3c0fe015b83a2e502c10119a"}], "stats": {"total": 416, "additions": 235, "deletions": 181}, "files": [{"sha": "e2a592d851a8cd9a55e28e88bf603668cbdbd4a7", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -176,15 +176,14 @@ fn build_pointer_or_reference_di_node<'ll, 'tcx>(\n \n     return_if_di_node_created_in_meantime!(cx, unique_type_id);\n \n-    let (thin_pointer_size, thin_pointer_align) =\n-        cx.size_and_align_of(cx.tcx.mk_imm_ptr(cx.tcx.types.unit));\n+    let data_layout = &cx.tcx.data_layout;\n     let ptr_type_debuginfo_name = compute_debuginfo_type_name(cx.tcx, ptr_type, true);\n \n     match fat_pointer_kind(cx, pointee_type) {\n         None => {\n             // This is a thin pointer. Create a regular pointer type and give it the correct name.\n             debug_assert_eq!(\n-                (thin_pointer_size, thin_pointer_align),\n+                (data_layout.pointer_size, data_layout.pointer_align.abi),\n                 cx.size_and_align_of(ptr_type),\n                 \"ptr_type={}, pointee_type={}\",\n                 ptr_type,\n@@ -195,8 +194,8 @@ fn build_pointer_or_reference_di_node<'ll, 'tcx>(\n                 llvm::LLVMRustDIBuilderCreatePointerType(\n                     DIB(cx),\n                     pointee_type_di_node,\n-                    thin_pointer_size.bits(),\n-                    thin_pointer_align.bits() as u32,\n+                    data_layout.pointer_size.bits(),\n+                    data_layout.pointer_align.abi.bits() as u32,\n                     0, // Ignore DWARF address space.\n                     ptr_type_debuginfo_name.as_ptr().cast(),\n                     ptr_type_debuginfo_name.len(),"}, {"sha": "4ab6bb5908bcdc279cd2b3fd80e9af3b8dd44f57", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -1427,13 +1427,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         for (base_trait_ref, span, constness) in regular_traits_refs_spans {\n             assert_eq!(constness, ty::BoundConstness::NotConst);\n \n-            for obligation in traits::elaborate_trait_ref(tcx, base_trait_ref) {\n-                debug!(\n-                    \"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\",\n-                    obligation.predicate\n-                );\n+            for pred in traits::elaborate_trait_ref(tcx, base_trait_ref) {\n+                debug!(\"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\", pred);\n \n-                let bound_predicate = obligation.predicate.kind();\n+                let bound_predicate = pred.kind();\n                 match bound_predicate.skip_binder() {\n                     ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n                         let pred = bound_predicate.rebind(pred);"}, {"sha": "c912a8a640d4567e1ff3dd464407282849b41453", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -1912,14 +1912,13 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n         // Check elaborated bounds.\n         let implied_obligations = traits::elaborate_predicates_with_span(tcx, predicates_with_span);\n \n-        for obligation in implied_obligations {\n+        for (pred, obligation_span) in implied_obligations {\n             // We lower empty bounds like `Vec<dyn Copy>:` as\n             // `WellFormed(Vec<dyn Copy>)`, which will later get checked by\n             // regular WF checking\n-            if let ty::PredicateKind::WellFormed(..) = obligation.predicate.kind().skip_binder() {\n+            if let ty::PredicateKind::WellFormed(..) = pred.kind().skip_binder() {\n                 continue;\n             }\n-            let pred = obligation.predicate;\n             // Match the existing behavior.\n             if pred.is_global() && !pred.has_late_bound_vars() {\n                 let pred = self.normalize(span, None, pred);\n@@ -1930,8 +1929,6 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n                 if let Some(hir::Generics { predicates, .. }) =\n                     hir_node.and_then(|node| node.generics())\n                 {\n-                    let obligation_span = obligation.cause.span();\n-\n                     span = predicates\n                         .iter()\n                         // There seems to be no better way to find out which predicate we are in"}, {"sha": "d2e45c28658bd5f1a9a84d78ff69cb7fd055c255", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -130,12 +130,9 @@ pub(super) fn item_bounds(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n ) -> ty::EarlyBinder<&'_ ty::List<ty::Predicate<'_>>> {\n-    let bounds = tcx.mk_predicates_from_iter(\n-        util::elaborate_predicates(\n-            tcx,\n-            tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),\n-        )\n-        .map(|obligation| obligation.predicate),\n-    );\n+    let bounds = tcx.mk_predicates_from_iter(util::elaborate_predicates(\n+        tcx,\n+        tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),\n+    ));\n     ty::EarlyBinder(bounds)\n }"}, {"sha": "dfa9e6148aab5fe5ae2d0e07b51730974c604a35", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -318,16 +318,8 @@ fn check_predicates<'tcx>(\n     span: Span,\n ) {\n     let instantiated = tcx.predicates_of(impl1_def_id).instantiate(tcx, impl1_substs);\n-    let impl1_predicates: Vec<_> = traits::elaborate_predicates_with_span(\n-        tcx,\n-        std::iter::zip(\n-            instantiated.predicates,\n-            // Don't drop predicates (unsound!) because `spans` is too short\n-            instantiated.spans.into_iter().chain(std::iter::repeat(span)),\n-        ),\n-    )\n-    .map(|obligation| (obligation.predicate, obligation.cause.span))\n-    .collect();\n+    let impl1_predicates: Vec<_> =\n+        traits::elaborate_predicates_with_span(tcx, instantiated.into_iter()).collect();\n \n     let mut impl2_predicates = if impl2_node.is_from_trait() {\n         // Always applicable traits have to be always applicable without any\n@@ -341,7 +333,6 @@ fn check_predicates<'tcx>(\n                 .predicates\n                 .into_iter(),\n         )\n-        .map(|obligation| obligation.predicate)\n         .collect()\n     };\n     debug!(?impl1_predicates, ?impl2_predicates);\n@@ -361,12 +352,16 @@ fn check_predicates<'tcx>(\n     // which is sound because we forbid impls like the following\n     //\n     // impl<D: Debug> AlwaysApplicable for D { }\n-    let always_applicable_traits = impl1_predicates.iter().copied().filter(|&(predicate, _)| {\n-        matches!(\n-            trait_predicate_kind(tcx, predicate),\n-            Some(TraitSpecializationKind::AlwaysApplicable)\n-        )\n-    });\n+    let always_applicable_traits = impl1_predicates\n+        .iter()\n+        .copied()\n+        .filter(|&(predicate, _)| {\n+            matches!(\n+                trait_predicate_kind(tcx, predicate),\n+                Some(TraitSpecializationKind::AlwaysApplicable)\n+            )\n+        })\n+        .map(|(pred, _span)| pred);\n \n     // Include the well-formed predicates of the type parameters of the impl.\n     for arg in tcx.impl_trait_ref(impl1_def_id).unwrap().subst_identity().substs {\n@@ -380,10 +375,7 @@ fn check_predicates<'tcx>(\n             traits::elaborate_obligations(tcx, obligations).map(|obligation| obligation.predicate),\n         )\n     }\n-    impl2_predicates.extend(\n-        traits::elaborate_predicates_with_span(tcx, always_applicable_traits)\n-            .map(|obligation| obligation.predicate),\n-    );\n+    impl2_predicates.extend(traits::elaborate_predicates(tcx, always_applicable_traits));\n \n     for (predicate, span) in impl1_predicates {\n         if !impl2_predicates.iter().any(|pred2| trait_predicates_eq(tcx, predicate, *pred2, span)) {"}, {"sha": "47a8b0801664fec04f254dee2816e65a6146b67f", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -204,25 +204,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut expected_sig = None;\n         let mut expected_kind = None;\n \n-        for obligation in traits::elaborate_predicates_with_span(\n+        for (pred, span) in traits::elaborate_predicates_with_span(\n             self.tcx,\n             // Reverse the obligations here, since `elaborate_*` uses a stack,\n             // and we want to keep inference generally in the same order of\n             // the registered obligations.\n             predicates.rev(),\n         ) {\n-            debug!(?obligation.predicate);\n-            let bound_predicate = obligation.predicate.kind();\n+            debug!(?pred);\n+            let bound_predicate = pred.kind();\n \n             // Given a Projection predicate, we can potentially infer\n             // the complete signature.\n             if expected_sig.is_none()\n                 && let ty::PredicateKind::Clause(ty::Clause::Projection(proj_predicate)) = bound_predicate.skip_binder()\n             {\n                 let inferred_sig = self.normalize(\n-                    obligation.cause.span,\n+                    span,\n                     self.deduce_sig_from_projection(\n-                    Some(obligation.cause.span),\n+                    Some(span),\n                         bound_predicate.rebind(proj_predicate),\n                     ),\n                 );"}, {"sha": "2762e778591eeca204e7aeed74f7ce048b0f00da", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -576,17 +576,13 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n             // We don't care about regions here.\n-            .filter_map(|obligation| match obligation.predicate.kind().skip_binder() {\n+            .filter_map(|pred| match pred.kind().skip_binder() {\n                 ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))\n                     if trait_pred.def_id() == sized_def_id =>\n                 {\n                     let span = predicates\n                         .iter()\n-                        .find_map(\n-                            |(p, span)| {\n-                                if p == obligation.predicate { Some(span) } else { None }\n-                            },\n-                        )\n+                        .find_map(|(p, span)| if p == pred { Some(span) } else { None })\n                         .unwrap_or(rustc_span::DUMMY_SP);\n                     Some((trait_pred, span))\n                 }"}, {"sha": "75c3d9f641ddaad282be8e526e17dea465853894", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -1942,7 +1942,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     escaped\n                 }\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0308, \"{}\", failure_str);\n-                if let Some((expected, found)) = trace.values.ty() {\n+                let values = self.resolve_vars_if_possible(trace.values);\n+                if let Some((expected, found)) = values.ty() {\n                     match (expected.kind(), found.kind()) {\n                         (ty::Tuple(_), ty::Tuple(_)) => {}\n                         // If a tuple of length one was expected and the found expression has"}, {"sha": "f3797499866acbe12c10e60f249ee4911a9d257b", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -74,44 +74,58 @@ pub struct Elaborator<'tcx> {\n pub fn elaborate_trait_ref<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> Elaborator<'tcx> {\n+) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n     elaborate_predicates(tcx, std::iter::once(trait_ref.without_const().to_predicate(tcx)))\n }\n \n pub fn elaborate_trait_refs<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> Elaborator<'tcx> {\n-    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate(tcx));\n+) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n+    let predicates = trait_refs.map(move |trait_ref| trait_ref.without_const().to_predicate(tcx));\n     elaborate_predicates(tcx, predicates)\n }\n \n pub fn elaborate_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n-) -> Elaborator<'tcx> {\n-    let obligations = predicates\n-        .map(|predicate| {\n-            predicate_obligation(predicate, ty::ParamEnv::empty(), ObligationCause::dummy())\n-        })\n-        .collect();\n-    elaborate_obligations(tcx, obligations)\n+) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n+    elaborate_obligations(\n+        tcx,\n+        predicates\n+            .map(|predicate| {\n+                Obligation::new(\n+                    tcx,\n+                    // We'll dump the cause/param-env later\n+                    ObligationCause::dummy(),\n+                    ty::ParamEnv::empty(),\n+                    predicate,\n+                )\n+            })\n+            .collect(),\n+    )\n+    .map(|obl| obl.predicate)\n }\n \n pub fn elaborate_predicates_with_span<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicates: impl Iterator<Item = (ty::Predicate<'tcx>, Span)>,\n-) -> Elaborator<'tcx> {\n-    let obligations = predicates\n-        .map(|(predicate, span)| {\n-            predicate_obligation(\n-                predicate,\n-                ty::ParamEnv::empty(),\n-                ObligationCause::dummy_with_span(span),\n-            )\n-        })\n-        .collect();\n-    elaborate_obligations(tcx, obligations)\n+) -> impl Iterator<Item = (ty::Predicate<'tcx>, Span)> {\n+    elaborate_obligations(\n+        tcx,\n+        predicates\n+            .map(|(predicate, span)| {\n+                Obligation::new(\n+                    tcx,\n+                    // We'll dump the cause/param-env later\n+                    ObligationCause::dummy_with_span(span),\n+                    ty::ParamEnv::empty(),\n+                    predicate,\n+                )\n+            })\n+            .collect(),\n+    )\n+    .map(|obl| (obl.predicate, obl.cause.span))\n }\n \n pub fn elaborate_obligations<'tcx>(\n@@ -141,10 +155,6 @@ impl<'tcx> Elaborator<'tcx> {\n         self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate)));\n     }\n \n-    pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n-        FilterToTraits::new(self)\n-    }\n-\n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n \n@@ -325,20 +335,18 @@ impl<'tcx> Iterator for Elaborator<'tcx> {\n // Supertrait iterator\n ///////////////////////////////////////////////////////////////////////////\n \n-pub type Supertraits<'tcx> = FilterToTraits<Elaborator<'tcx>>;\n-\n pub fn supertraits<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> Supertraits<'tcx> {\n-    elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n+) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n+    FilterToTraits::new(elaborate_trait_ref(tcx, trait_ref))\n }\n \n pub fn transitive_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> Supertraits<'tcx> {\n-    elaborate_trait_refs(tcx, bounds).filter_to_traits()\n+    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n+    FilterToTraits::new(elaborate_trait_refs(tcx, trait_refs))\n }\n \n /// A specialized variant of `elaborate_trait_refs` that only elaborates trait references that may\n@@ -393,12 +401,12 @@ impl<I> FilterToTraits<I> {\n     }\n }\n \n-impl<'tcx, I: Iterator<Item = PredicateObligation<'tcx>>> Iterator for FilterToTraits<I> {\n+impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     type Item = ty::PolyTraitRef<'tcx>;\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n-        while let Some(obligation) = self.base_iterator.next() {\n-            if let Some(data) = obligation.predicate.to_opt_poly_trait_pred() {\n+        while let Some(pred) = self.base_iterator.next() {\n+            if let Some(data) = pred.to_opt_poly_trait_pred() {\n                 return Some(data.map_bound(|t| t.trait_ref));\n             }\n         }"}, {"sha": "42e59f92840e08d11ef08e7f8761606bae231148", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -258,11 +258,11 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         cx.tcx,\n                         cx.tcx.explicit_item_bounds(def).iter().cloned(),\n                     )\n-                    .find_map(|obligation| {\n+                    .find_map(|(pred, _span)| {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n                         if let ty::PredicateKind::Clause(ty::Clause::Trait(\n                             ref poly_trait_predicate,\n-                        )) = obligation.predicate.kind().skip_binder()\n+                        )) = pred.kind().skip_binder()\n                         {\n                             let def_id = poly_trait_predicate.trait_ref.def_id;\n "}, {"sha": "e7075d5e79120fbbf78bcf2844a9aa1723a81ffa", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -117,7 +117,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n             .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n         if traits::impossible_predicates(\n             tcx,\n-            traits::elaborate_predicates(tcx, predicates).map(|o| o.predicate).collect(),\n+            traits::elaborate_predicates(tcx, predicates).collect(),\n         ) {\n             trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", def_id);\n             return;"}, {"sha": "60401b054922a85ca1fc955210af8766024458cb", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -93,7 +93,7 @@ impl<'tcx> MirLint<'tcx> for ConstProp {\n             .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n         if traits::impossible_predicates(\n             tcx,\n-            traits::elaborate_predicates(tcx, predicates).map(|o| o.predicate).collect(),\n+            traits::elaborate_predicates(tcx, predicates).collect(),\n         ) {\n             trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", def_id);\n             return;"}, {"sha": "2ff7de8cb9efc8f60e1602749208f4c339b19dc9", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -1065,7 +1065,7 @@ pub(super) struct CurrentDepGraph<K: DepKind> {\n     /// This is used to verify that fingerprints do not change between the creation of a node\n     /// and its recomputation.\n     #[cfg(debug_assertions)]\n-    fingerprints: Lock<FxHashMap<DepNode<K>, Fingerprint>>,\n+    fingerprints: Lock<IndexVec<DepNodeIndex, Option<Fingerprint>>>,\n \n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n@@ -1151,7 +1151,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             #[cfg(debug_assertions)]\n             forbidden_edge,\n             #[cfg(debug_assertions)]\n-            fingerprints: Lock::new(Default::default()),\n+            fingerprints: Lock::new(IndexVec::from_elem_n(None, new_node_count_estimate)),\n             total_read_count: AtomicU64::new(0),\n             total_duplicate_read_count: AtomicU64::new(0),\n             node_intern_event_id,\n@@ -1163,14 +1163,8 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         if let Some(forbidden_edge) = &self.forbidden_edge {\n             forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n         }\n-        match self.fingerprints.lock().entry(key) {\n-            Entry::Vacant(v) => {\n-                v.insert(fingerprint);\n-            }\n-            Entry::Occupied(o) => {\n-                assert_eq!(*o.get(), fingerprint, \"Unstable fingerprints for {:?}\", key);\n-            }\n-        }\n+        let previous = *self.fingerprints.lock().get_or_insert_with(dep_node_index, || fingerprint);\n+        assert_eq!(previous, fingerprint, \"Unstable fingerprints for {:?}\", key);\n     }\n \n     /// Writes the node to the current dep-graph and allocates a `DepNodeIndex` for it."}, {"sha": "b2658614fd3df77ca6f1d2b37303bf6c20efce43", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -470,7 +470,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         for assumption in\n             elaborate_predicates(tcx, bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)))\n         {\n-            match G::consider_object_bound_candidate(self, goal, assumption.predicate) {\n+            match G::consider_object_bound_candidate(self, goal, assumption) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n                 }"}, {"sha": "878c502655cf6897494364b3ab0ae8ab36d0e7bf", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -349,8 +349,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n             let normalized_preds = elaborate_predicates(\n                 tcx,\n                 computed_preds.clone().chain(user_computed_preds.iter().cloned()),\n-            )\n-            .map(|o| o.predicate);\n+            );\n             new_env = ty::ParamEnv::new(\n                 tcx.mk_predicates_from_iter(normalized_preds),\n                 param_env.reveal(),"}, {"sha": "03ba125cf2b5f8cea70c9f1a2a4d18cdcf1d2af1", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -367,8 +367,8 @@ fn negative_impl_exists<'tcx>(\n     }\n \n     // Try to prove a negative obligation exists for super predicates\n-    for o in util::elaborate_predicates(infcx.tcx, iter::once(o.predicate)) {\n-        if resolve_negative_obligation(infcx.fork(), &o, body_def_id) {\n+    for pred in util::elaborate_predicates(infcx.tcx, iter::once(o.predicate)) {\n+        if resolve_negative_obligation(infcx.fork(), &o.with(infcx.tcx, pred), body_def_id) {\n             return true;\n         }\n     }"}, {"sha": "672b3365ff4a9d41d694c64718d05eb149064827", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/ambiguity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -82,15 +82,15 @@ pub fn recompute_applicable_impls<'tcx>(\n \n     let predicates =\n         tcx.predicates_of(obligation.cause.body_id.to_def_id()).instantiate_identity(tcx);\n-    for obligation in elaborate_predicates_with_span(tcx, predicates.into_iter()) {\n-        let kind = obligation.predicate.kind();\n+    for (pred, span) in elaborate_predicates_with_span(tcx, predicates.into_iter()) {\n+        let kind = pred.kind();\n         if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = kind.skip_binder()\n             && param_env_candidate_may_apply(kind.rebind(trait_pred))\n         {\n             if kind.rebind(trait_pred.trait_ref) == ty::TraitRef::identity(tcx, trait_pred.def_id()) {\n                 ambiguities.push(Ambiguity::ParamEnv(tcx.def_span(trait_pred.def_id())))\n             } else {\n-                ambiguities.push(Ambiguity::ParamEnv(obligation.cause.span))\n+                ambiguities.push(Ambiguity::ParamEnv(span))\n             }\n         }\n     }"}, {"sha": "c19798213b70ce9ef482e6c0cc9e6a666f270d53", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -1624,8 +1624,8 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n         };\n \n-        for obligation in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n-            let bound_predicate = obligation.predicate.kind();\n+        for pred in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n+            let bound_predicate = pred.kind();\n             if let ty::PredicateKind::Clause(ty::Clause::Trait(implication)) =\n                 bound_predicate.skip_binder()\n             {"}, {"sha": "8d831dca6e3099c2508763a64e58d626227b39de", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -66,7 +66,7 @@ pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n pub use self::util::{get_vtable_index_of_object_method, impl_item_is_final, upcast_choices};\n pub use self::util::{\n     supertrait_def_ids, supertraits, transitive_bounds, transitive_bounds_that_define_assoc_type,\n-    SupertraitDefIds, Supertraits,\n+    SupertraitDefIds,\n };\n \n pub use self::chalk_fulfill::FulfillmentContext as ChalkFulfillmentContext;\n@@ -267,9 +267,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // and errors will get reported then; so outside of type inference we\n     // can be sure that no errors should occur.\n     let mut predicates: Vec<_> =\n-        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds().into_iter())\n-            .map(|obligation| obligation.predicate)\n-            .collect();\n+        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds().into_iter()).collect();\n \n     debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\", predicates);\n "}, {"sha": "dbf6b78572a191f0285776e26fe389e93260234a", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -379,26 +379,24 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n     let predicates = tcx.predicates_of(def_id);\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n-    elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| {\n-        match obligation.predicate.kind().skip_binder() {\n-            ty::PredicateKind::Clause(ty::Clause::Trait(ref trait_pred)) => {\n-                trait_pred.def_id() == sized_def_id && trait_pred.self_ty().is_param(0)\n-            }\n-            ty::PredicateKind::Clause(ty::Clause::Projection(..))\n-            | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-            | ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::Coerce(..)\n-            | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n-            | ty::PredicateKind::WellFormed(..)\n-            | ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::AliasRelate(..)\n-            | ty::PredicateKind::Ambiguous\n-            | ty::PredicateKind::TypeWellFormedFromEnv(..) => false,\n+    elaborate_predicates(tcx, predicates.into_iter()).any(|pred| match pred.kind().skip_binder() {\n+        ty::PredicateKind::Clause(ty::Clause::Trait(ref trait_pred)) => {\n+            trait_pred.def_id() == sized_def_id && trait_pred.self_ty().is_param(0)\n         }\n+        ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+        | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n+        | ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::Coerce(..)\n+        | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n+        | ty::PredicateKind::WellFormed(..)\n+        | ty::PredicateKind::ObjectSafe(..)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n+        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::AliasRelate(..)\n+        | ty::PredicateKind::Ambiguous\n+        | ty::PredicateKind::TypeWellFormedFromEnv(..) => false,\n     })\n }\n \n@@ -669,9 +667,9 @@ fn object_ty_for_trait<'tcx>(\n     debug!(?trait_predicate);\n \n     let mut elaborated_predicates: Vec<_> = elaborate_trait_ref(tcx, trait_ref)\n-        .filter_map(|obligation| {\n-            debug!(?obligation);\n-            let pred = obligation.predicate.to_opt_poly_projection_pred()?;\n+        .filter_map(|pred| {\n+            debug!(?pred);\n+            let pred = pred.to_opt_poly_projection_pred()?;\n             Some(pred.map_bound(|p| {\n                 ty::ExistentialPredicate::Projection(ty::ExistentialProjection::erase_self_ty(\n                     tcx, p,"}, {"sha": "156674e33c334c58f594cabfd3daf300e094f798", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -921,9 +921,9 @@ pub(crate) fn required_region_bounds<'tcx>(\n     assert!(!erased_self_ty.has_escaping_bound_vars());\n \n     traits::elaborate_predicates(tcx, predicates)\n-        .filter_map(|obligation| {\n-            debug!(?obligation);\n-            match obligation.predicate.kind().skip_binder() {\n+        .filter_map(|pred| {\n+            debug!(?pred);\n+            match pred.kind().skip_binder() {\n                 ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                 | ty::PredicateKind::Clause(ty::Clause::Trait(..))\n                 | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))"}, {"sha": "55e18b04956012bf1d177a4690cc3bb87b7e2674", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -135,7 +135,6 @@\n #![feature(maybe_uninit_uninit_array)]\n #![feature(maybe_uninit_uninit_array_transpose)]\n #![cfg_attr(test, feature(new_uninit))]\n-#![feature(nonnull_slice_from_raw_parts)]\n #![feature(pattern)]\n #![feature(pointer_byte_offsets)]\n #![feature(provide_any)]"}, {"sha": "966cf57511630793dd01ace6c6f1e2f92b90eb43", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -8,7 +8,7 @@\n #![feature(const_cow_is_borrowed)]\n #![feature(const_heap)]\n #![feature(const_mut_refs)]\n-#![feature(const_nonnull_slice_from_raw_parts)]\n+#![feature(const_slice_from_raw_parts_mut)]\n #![feature(const_ptr_write)]\n #![feature(const_try)]\n #![feature(core_intrinsics)]\n@@ -38,7 +38,6 @@\n #![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n #![feature(const_str_from_utf8)]\n-#![feature(nonnull_slice_from_raw_parts)]\n #![feature(panic_update_hook)]\n #![feature(pointer_is_aligned)]\n #![feature(slice_flatten)]"}, {"sha": "a46804c186c2887bc82ff9cb702e74bbd885fa64", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -462,8 +462,6 @@ impl<T> NonNull<[T]> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// #![feature(nonnull_slice_from_raw_parts)]\n-    ///\n     /// use std::ptr::NonNull;\n     ///\n     /// // create a slice pointer when starting out with a pointer to the first element\n@@ -475,8 +473,8 @@ impl<T> NonNull<[T]> {\n     ///\n     /// (Note that this example artificially demonstrates a use of this method,\n     /// but `let slice = NonNull::from(&x[..]);` would be a better way to write code like this.)\n-    #[unstable(feature = \"nonnull_slice_from_raw_parts\", issue = \"71941\")]\n-    #[rustc_const_unstable(feature = \"const_nonnull_slice_from_raw_parts\", issue = \"71941\")]\n+    #[stable(feature = \"nonnull_slice_from_raw_parts\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_unstable(feature = \"const_slice_from_raw_parts_mut\", issue = \"67456\")]\n     #[must_use]\n     #[inline]\n     pub const fn slice_from_raw_parts(data: NonNull<T>, len: usize) -> Self {\n@@ -494,7 +492,6 @@ impl<T> NonNull<[T]> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// #![feature(nonnull_slice_from_raw_parts)]\n     /// use std::ptr::NonNull;\n     ///\n     /// let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n@@ -514,7 +511,7 @@ impl<T> NonNull<[T]> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// #![feature(slice_ptr_get, nonnull_slice_from_raw_parts)]\n+    /// #![feature(slice_ptr_get)]\n     /// use std::ptr::NonNull;\n     ///\n     /// let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n@@ -534,7 +531,7 @@ impl<T> NonNull<[T]> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// #![feature(slice_ptr_get, nonnull_slice_from_raw_parts)]\n+    /// #![feature(slice_ptr_get)]\n     /// use std::ptr::NonNull;\n     ///\n     /// let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n@@ -668,7 +665,7 @@ impl<T> NonNull<[T]> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(slice_ptr_get, nonnull_slice_from_raw_parts)]\n+    /// #![feature(slice_ptr_get)]\n     /// use std::ptr::NonNull;\n     ///\n     /// let x = &mut [1, 2, 4];"}, {"sha": "20b5b6b514685b7b98bf3bf10687a13057988b36", "filename": "library/panic_abort/src/android.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Fpanic_abort%2Fsrc%2Fandroid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Fpanic_abort%2Fsrc%2Fandroid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2Fsrc%2Fandroid.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -15,15 +15,15 @@ type SetAbortMessageType = unsafe extern \"C\" fn(*const libc::c_char) -> ();\n //\n // Weakly resolve the symbol for android_set_abort_message. This function is only available\n // for API >= 21.\n-pub(crate) unsafe fn android_set_abort_message(payload: *mut &mut dyn BoxMeUp) {\n+pub(crate) unsafe fn android_set_abort_message(payload: &mut dyn BoxMeUp) {\n     let func_addr =\n         libc::dlsym(libc::RTLD_DEFAULT, ANDROID_SET_ABORT_MESSAGE.as_ptr() as *const libc::c_char)\n             as usize;\n     if func_addr == 0 {\n         return;\n     }\n \n-    let payload = (*payload).get();\n+    let payload = payload.get();\n     let msg = match payload.downcast_ref::<&'static str>() {\n         Some(msg) => msg.as_bytes(),\n         None => match payload.downcast_ref::<String>() {"}, {"sha": "b193d79b0e1a8bd90a8e085d5642c48c44283773", "filename": "library/panic_abort/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Fpanic_abort%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Fpanic_abort%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2Fsrc%2Flib.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -29,7 +29,7 @@ pub unsafe extern \"C\" fn __rust_panic_cleanup(_: *mut u8) -> *mut (dyn Any + Sen\n \n // \"Leak\" the payload and shim to the relevant abort on the platform in question.\n #[rustc_std_internal_symbol]\n-pub unsafe fn __rust_start_panic(_payload: *mut &mut dyn BoxMeUp) -> u32 {\n+pub unsafe fn __rust_start_panic(_payload: &mut dyn BoxMeUp) -> u32 {\n     // Android has the ability to attach a message as part of the abort.\n     #[cfg(target_os = \"android\")]\n     android::android_set_abort_message(_payload);"}, {"sha": "ce78ab82ef9422fedcbdec995a8e59ef1a3ffc52", "filename": "library/panic_unwind/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Flib.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -99,8 +99,8 @@ pub unsafe extern \"C\" fn __rust_panic_cleanup(payload: *mut u8) -> *mut (dyn Any\n // Entry point for raising an exception, just delegates to the platform-specific\n // implementation.\n #[rustc_std_internal_symbol]\n-pub unsafe fn __rust_start_panic(payload: *mut &mut dyn BoxMeUp) -> u32 {\n-    let payload = Box::from_raw((*payload).take_box());\n+pub unsafe fn __rust_start_panic(payload: &mut dyn BoxMeUp) -> u32 {\n+    let payload = Box::from_raw(payload.take_box());\n \n     imp::panic(payload)\n }"}, {"sha": "25c64240e74807a61b39f835c7d296f7d91fa954", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -34,7 +34,7 @@ use crate::io::{self, BorrowedCursor, ErrorKind, IoSlice, IoSliceMut, SeekFrom};\n /// use std::fs::File;\n ///\n /// // a library function we've written\n-/// fn write_ten_bytes_at_end<W: Write + Seek>(writer: &mut W) -> io::Result<()> {\n+/// fn write_ten_bytes_at_end<W: Write + Seek>(mut writer: W) -> io::Result<()> {\n ///     writer.seek(SeekFrom::End(-10))?;\n ///\n ///     for i in 0..10 {"}, {"sha": "baad6de707bc28f2e87d6470bd6a283370d106c4", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -292,7 +292,6 @@\n #![feature(is_some_and)]\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_write_slice)]\n-#![feature(nonnull_slice_from_raw_parts)]\n #![feature(panic_can_unwind)]\n #![feature(panic_info_message)]\n #![feature(panic_internals)]"}, {"sha": "e505466e535a0e37dd05d4b374dd023efe3eeb6e", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -46,12 +46,10 @@ extern \"C\" {\n     fn __rust_panic_cleanup(payload: *mut u8) -> *mut (dyn Any + Send + 'static);\n }\n \n-#[allow(improper_ctypes)]\n extern \"Rust\" {\n-    /// `payload` is passed through another layer of raw pointers as `&mut dyn Trait` is not\n-    /// FFI-safe. `BoxMeUp` lazily performs allocation only when needed (this avoids allocations\n-    /// when using the \"abort\" panic runtime).\n-    fn __rust_start_panic(payload: *mut &mut dyn BoxMeUp) -> u32;\n+    /// `BoxMeUp` lazily performs allocation only when needed (this avoids\n+    /// allocations when using the \"abort\" panic runtime).\n+    fn __rust_start_panic(payload: &mut dyn BoxMeUp) -> u32;\n }\n \n /// This function is called by the panic runtime if FFI code catches a Rust\n@@ -738,10 +736,7 @@ pub fn rust_panic_without_hook(payload: Box<dyn Any + Send>) -> ! {\n /// yer breakpoints.\n #[inline(never)]\n #[cfg_attr(not(test), rustc_std_internal_symbol)]\n-fn rust_panic(mut msg: &mut dyn BoxMeUp) -> ! {\n-    let code = unsafe {\n-        let obj = &mut msg as *mut &mut dyn BoxMeUp;\n-        __rust_start_panic(obj)\n-    };\n+fn rust_panic(msg: &mut dyn BoxMeUp) -> ! {\n+    let code = unsafe { __rust_start_panic(msg) };\n     rtabort!(\"failed to initiate panic, error {code}\")\n }"}, {"sha": "c081578b8d4bb75c8338d80b7ebd7503b04a54de", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -1946,11 +1946,7 @@ function initSearch(rawSearchIndex) {\n     function showResults(results, go_to_first, filterCrates) {\n         const search = searchState.outputElement();\n         if (go_to_first || (results.others.length === 1\n-            && getSettingValue(\"go-to-only-result\") === \"true\"\n-            // By default, the search DOM element is \"empty\" (meaning it has no children not\n-            // text content). Once a search has been run, it won't be empty, even if you press\n-            // ESC or empty the search input (which also \"cancels\" the search).\n-            && (!search.firstChild || search.firstChild.innerText !== searchState.loadingText))\n+            && getSettingValue(\"go-to-only-result\") === \"true\")\n         ) {\n             const elem = document.createElement(\"a\");\n             elem.href = results.others[0].href;"}, {"sha": "327e090d38be886e612786373c783a1620e720be", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -124,9 +124,9 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n \n         let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds().iter())\n             .filter(|p| !p.is_global())\n-            .filter_map(|obligation| {\n+            .filter_map(|pred| {\n                 // Note that we do not want to deal with qualified predicates here.\n-                match obligation.predicate.kind().no_bound_vars() {\n+                match pred.kind().no_bound_vars() {\n                     Some(ty::PredicateKind::Clause(ty::Clause::Trait(pred))) if pred.def_id() != sized_trait => {\n                         Some(pred)\n                     },"}, {"sha": "fd06c0b86775a12dc3fe56625a3eb96aa1e1962d", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -2106,7 +2106,6 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n     traits::impossible_predicates(\n         cx.tcx,\n         traits::elaborate_predicates(cx.tcx, predicates)\n-            .map(|o| o.predicate)\n             .collect::<Vec<_>>(),\n     )\n }"}, {"sha": "3811011a64e6f70f977710080fe6ab569a526905", "filename": "tests/rustdoc-gui/setting-go-to-only-result.goml", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/tests%2Frustdoc-gui%2Fsetting-go-to-only-result.goml", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/tests%2Frustdoc-gui%2Fsetting-go-to-only-result.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsetting-go-to-only-result.goml?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -0,0 +1,63 @@\n+// Checks that the setting \"Directly go to item in search if there is only one result \" is working as expected.\n+\n+define-function: (\n+    \"check-setting\",\n+    (storage_value, setting_attribute_value),\n+    block {\n+        assert-local-storage: {\"rustdoc-go-to-only-result\": |storage_value|}\n+        click: \"#settings-menu\"\n+        wait-for: \"#settings\"\n+        assert-property: (\"#go-to-only-result\", {\"checked\": |setting_attribute_value|})\n+    }\n+)\n+\n+goto: \"file://\" + |DOC_PATH| + \"/lib2/index.html\"\n+\n+call-function: (\"check-setting\", {\n+    \"storage_value\": null,\n+    \"setting_attribute_value\": \"false\",\n+})\n+\n+// By default, the search doesn't automatically go to the page if there is only one result.\n+goto: \"file://\" + |DOC_PATH| + \"/lib2/index.html?search=HasALongTraitWithParams\"\n+// It will timeout if the setting isn't working.\n+wait-for: \"#search\"\n+assert-document-property: ({\"URL\": \"/lib2/index.html\"}, CONTAINS)\n+\n+// Now we change its value.\n+click: \"#settings-menu\"\n+wait-for: \"#settings\"\n+click: \"#go-to-only-result\"\n+assert-local-storage: {\"rustdoc-go-to-only-result\": \"true\"}\n+\n+goto: \"file://\" + |DOC_PATH| + \"/lib2/index.html\"\n+// We enter it into the search.\n+write: (\".search-input\", \"HasALongTraitWithParams\")\n+wait-for-document-property: {\"title\": \"HasALongTraitWithParams in lib2 - Rust\"}\n+assert-document-property: ({\"URL\": \"/lib2/struct.HasALongTraitWithParams.html\"}, ENDS_WITH)\n+\n+// We try again to see if it goes to the only result\n+goto: \"file://\" + |DOC_PATH| + \"/lib2/index.html?search=HasALongTraitWithParams\"\n+wait-for-document-property: {\"title\": \"HasALongTraitWithParams in lib2 - Rust\"}\n+assert-document-property: ({\"URL\": \"/lib2/struct.HasALongTraitWithParams.html\"}, ENDS_WITH)\n+\n+// We check the settings\n+call-function: (\"check-setting\", {\n+    \"storage_value\": \"true\",\n+    \"setting_attribute_value\": \"true\",\n+})\n+\n+// And now we re-disable the setting.\n+click: \"#go-to-only-result\"\n+assert-local-storage: {\"rustdoc-go-to-only-result\": \"false\"}\n+\n+goto: \"file://\" + |DOC_PATH| + \"/lib2/index.html?search=HasALongTraitWithParams\"\n+// It will timeout if the setting isn't working.\n+wait-for: \"#search\"\n+assert-document-property: ({\"URL\": \"/lib2/index.html\"}, CONTAINS)\n+\n+// And we check everything is back the way it was before.\n+call-function: (\"check-setting\", {\n+    \"storage_value\": \"false\",\n+    \"setting_attribute_value\": \"false\",\n+})"}, {"sha": "1621a279f03ff7abb1b2bb65aeac25603928cd8c", "filename": "tests/ui/inference/char-as-str-single.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/tests%2Fui%2Finference%2Fchar-as-str-single.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/tests%2Fui%2Finference%2Fchar-as-str-single.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Fchar-as-str-single.fixed?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -10,3 +10,12 @@ fn main() {\n     let _: char = '\u4eba'; //~ ERROR mismatched types\n     let _: char = '\\''; //~ ERROR mismatched types\n }\n+\n+// regression test for https://github.com/rust-lang/rust/issues/109586\n+#[allow(dead_code)]\n+fn convert_c_to_str(c: char) {\n+    match c {\n+        'A' => {} //~ ERROR mismatched types\n+        _ => {}\n+    }\n+}"}, {"sha": "2903142f1599195a67cab54d7f90c7407c268049", "filename": "tests/ui/inference/char-as-str-single.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/tests%2Fui%2Finference%2Fchar-as-str-single.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/tests%2Fui%2Finference%2Fchar-as-str-single.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Fchar-as-str-single.rs?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -10,3 +10,12 @@ fn main() {\n     let _: char = \"\u4eba\"; //~ ERROR mismatched types\n     let _: char = \"'\"; //~ ERROR mismatched types\n }\n+\n+// regression test for https://github.com/rust-lang/rust/issues/109586\n+#[allow(dead_code)]\n+fn convert_c_to_str(c: char) {\n+    match c {\n+        \"A\" => {} //~ ERROR mismatched types\n+        _ => {}\n+    }\n+}"}, {"sha": "9149efe32407119524112b8319edf1d9f2018e0e", "filename": "tests/ui/inference/char-as-str-single.stderr", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/tests%2Fui%2Finference%2Fchar-as-str-single.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a/tests%2Fui%2Finference%2Fchar-as-str-single.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Fchar-as-str-single.stderr?ref=553ecbe8bae12bc43a34ac0b8a63e17026ce1e8a", "patch": "@@ -37,6 +37,19 @@ help: if you meant to write a `char` literal, use single quotes\n LL |     let _: char = '\\'';\n    |                   ~~~~\n \n-error: aborting due to 3 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/char-as-str-single.rs:18:9\n+   |\n+LL |     match c {\n+   |           - this expression has type `char`\n+LL |         \"A\" => {}\n+   |         ^^^ expected `char`, found `&str`\n+   |\n+help: if you meant to write a `char` literal, use single quotes\n+   |\n+LL |         'A' => {}\n+   |         ~~~\n+\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}