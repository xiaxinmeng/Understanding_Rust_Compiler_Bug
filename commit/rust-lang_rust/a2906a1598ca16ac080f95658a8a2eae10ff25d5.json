{"sha": "a2906a1598ca16ac080f95658a8a2eae10ff25d5", "node_id": "C_kwDOAAsO6NoAKGEyOTA2YTE1OThjYTE2YWMwODBmOTU2NThhOGEyZWFlMTBmZjI1ZDU", "commit": {"author": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2023-02-01T21:31:09Z"}, "committer": {"name": "Alex Macleod", "email": "alex@macleod.io", "date": "2023-03-06T21:38:32Z"}, "message": "Migrate `write.rs` to `rustc_ast::FormatArgs`", "tree": {"sha": "e66cfe3de55406f8e8f259f83ef4e4f88fcf7224", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e66cfe3de55406f8e8f259f83ef4e4f88fcf7224"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2906a1598ca16ac080f95658a8a2eae10ff25d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2906a1598ca16ac080f95658a8a2eae10ff25d5", "html_url": "https://github.com/rust-lang/rust/commit/a2906a1598ca16ac080f95658a8a2eae10ff25d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2906a1598ca16ac080f95658a8a2eae10ff25d5/comments", "author": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Alexendoo", "id": 1830331, "node_id": "MDQ6VXNlcjE4MzAzMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1830331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexendoo", "html_url": "https://github.com/Alexendoo", "followers_url": "https://api.github.com/users/Alexendoo/followers", "following_url": "https://api.github.com/users/Alexendoo/following{/other_user}", "gists_url": "https://api.github.com/users/Alexendoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexendoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexendoo/subscriptions", "organizations_url": "https://api.github.com/users/Alexendoo/orgs", "repos_url": "https://api.github.com/users/Alexendoo/repos", "events_url": "https://api.github.com/users/Alexendoo/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexendoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "903595801e86c1d6bf8bd8aeeeb9127b04f19036", "url": "https://api.github.com/repos/rust-lang/rust/commits/903595801e86c1d6bf8bd8aeeeb9127b04f19036", "html_url": "https://github.com/rust-lang/rust/commit/903595801e86c1d6bf8bd8aeeeb9127b04f19036"}], "stats": {"total": 238, "additions": 173, "deletions": 65}, "files": [{"sha": "a025e3cc12a073def4317648800ca6f88bb1151a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2906a1598ca16ac080f95658a8a2eae10ff25d5/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2906a1598ca16ac080f95658a8a2eae10ff25d5/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a2906a1598ca16ac080f95658a8a2eae10ff25d5", "patch": "@@ -870,6 +870,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let allow_dbg_in_tests = conf.allow_dbg_in_tests;\n     store.register_late_pass(move |_| Box::new(dbg_macro::DbgMacro::new(allow_dbg_in_tests)));\n     let allow_print_in_tests = conf.allow_print_in_tests;\n+    store.register_early_pass(move || Box::new(write::Write::new(allow_print_in_tests)));\n     store.register_late_pass(move |_| Box::new(write::Write::new(allow_print_in_tests)));\n     let cargo_ignore_publish = conf.cargo_ignore_publish;\n     store.register_late_pass(move |_| {"}, {"sha": "ce419ec9373c374f7b4b1a52be042e5ea0b32c7f", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 94, "deletions": 64, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/a2906a1598ca16ac080f95658a8a2eae10ff25d5/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2906a1598ca16ac080f95658a8a2eae10ff25d5/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=a2906a1598ca16ac080f95658a8a2eae10ff25d5", "patch": "@@ -1,11 +1,14 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n-use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn, MacroCall};\n+use clippy_utils::macros::{\n+    find_format_args, format_arg_removal_span, populate_ast_format_args, root_macro_call_first_node, MacroCall,\n+};\n use clippy_utils::source::{expand_past_previous_comma, snippet_opt};\n use clippy_utils::{is_in_cfg_test, is_in_test_function};\n-use rustc_ast::LitKind;\n+use rustc_ast::token::LitKind;\n+use rustc_ast::{FormatArgPosition, FormatArgs, FormatArgsPiece, FormatOptions, FormatPlaceholder, FormatTrait};\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, HirIdMap, Impl, Item, ItemKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_hir::{Expr, Impl, Item, ItemKind};\n+use rustc_lint::{EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, BytePos};\n \n@@ -257,6 +260,12 @@ impl_lint_pass!(Write => [\n     WRITE_LITERAL,\n ]);\n \n+impl EarlyLintPass for Write {\n+    fn check_expr(&mut self, _: &rustc_lint::EarlyContext<'_>, expr: &rustc_ast::Expr) {\n+        populate_ast_format_args(expr);\n+    }\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for Write {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         if is_debug_impl(cx, item) {\n@@ -297,34 +306,40 @@ impl<'tcx> LateLintPass<'tcx> for Write {\n             _ => return,\n         }\n \n-        let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, macro_call.expn) else { return };\n-\n-        // ignore `writeln!(w)` and `write!(v, some_macro!())`\n-        if format_args.format_string.span.from_expansion() {\n-            return;\n-        }\n+        find_format_args(cx, expr, macro_call.expn, |format_args| {\n+            // ignore `writeln!(w)` and `write!(v, some_macro!())`\n+            if format_args.span.from_expansion() {\n+                return;\n+            }\n \n-        match diag_name {\n-            sym::print_macro | sym::eprint_macro | sym::write_macro => {\n-                check_newline(cx, &format_args, &macro_call, name);\n-            },\n-            sym::println_macro | sym::eprintln_macro | sym::writeln_macro => {\n-                check_empty_string(cx, &format_args, &macro_call, name);\n-            },\n-            _ => {},\n-        }\n+            match diag_name {\n+                sym::print_macro | sym::eprint_macro | sym::write_macro => {\n+                    check_newline(cx, format_args, &macro_call, name);\n+                },\n+                sym::println_macro | sym::eprintln_macro | sym::writeln_macro => {\n+                    check_empty_string(cx, format_args, &macro_call, name);\n+                },\n+                _ => {},\n+            }\n \n-        check_literal(cx, &format_args, name);\n+            check_literal(cx, format_args, name);\n \n-        if !self.in_debug_impl {\n-            for arg in &format_args.args {\n-                if arg.format.r#trait == sym::Debug {\n-                    span_lint(cx, USE_DEBUG, arg.span, \"use of `Debug`-based formatting\");\n+            if !self.in_debug_impl {\n+                for piece in &format_args.template {\n+                    if let &FormatArgsPiece::Placeholder(FormatPlaceholder {\n+                        span: Some(span),\n+                        format_trait: FormatTrait::Debug,\n+                        ..\n+                    }) = piece\n+                    {\n+                        span_lint(cx, USE_DEBUG, span, \"use of `Debug`-based formatting\");\n+                    }\n                 }\n             }\n-        }\n+        });\n     }\n }\n+\n fn is_debug_impl(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n     if let ItemKind::Impl(Impl { of_trait: Some(trait_ref), .. }) = &item.kind\n         && let Some(trait_id) = trait_ref.trait_def_id()\n@@ -335,27 +350,28 @@ fn is_debug_impl(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n     }\n }\n \n-fn check_newline(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, macro_call: &MacroCall, name: &str) {\n-    let format_string_parts = &format_args.format_string.parts;\n-    let mut format_string_span = format_args.format_string.span;\n-\n-    let Some(last) = format_string_parts.last() else { return };\n+fn check_newline(cx: &LateContext<'_>, format_args: &FormatArgs, macro_call: &MacroCall, name: &str) {\n+    let Some(FormatArgsPiece::Literal(last)) = format_args.template.last() else { return };\n \n     let count_vertical_whitespace = || {\n-        format_string_parts\n+        format_args\n+            .template\n             .iter()\n-            .flat_map(|part| part.as_str().chars())\n+            .filter_map(|piece| match piece {\n+                FormatArgsPiece::Literal(literal) => Some(literal),\n+                FormatArgsPiece::Placeholder(_) => None,\n+            })\n+            .flat_map(|literal| literal.as_str().chars())\n             .filter(|ch| matches!(ch, '\\r' | '\\n'))\n             .count()\n     };\n \n     if last.as_str().ends_with('\\n')\n         // ignore format strings with other internal vertical whitespace\n         && count_vertical_whitespace() == 1\n-\n-        // ignore trailing arguments: `print!(\"Issue\\n{}\", 1265);`\n-        && format_string_parts.len() > format_args.args.len()\n     {\n+        let mut format_string_span = format_args.span;\n+\n         let lint = if name == \"write\" {\n             format_string_span = expand_past_previous_comma(cx, format_string_span);\n \n@@ -373,7 +389,7 @@ fn check_newline(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, macro_c\n                 let name_span = cx.sess().source_map().span_until_char(macro_call.span, '!');\n                 let Some(format_snippet) = snippet_opt(cx, format_string_span) else { return };\n \n-                if format_string_parts.len() == 1 && last.as_str() == \"\\n\" {\n+                if format_args.template.len() == 1 && last.as_str() == \"\\n\" {\n                     // print!(\"\\n\"), write!(f, \"\\n\")\n \n                     diag.multipart_suggestion(\n@@ -398,11 +414,12 @@ fn check_newline(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, macro_c\n     }\n }\n \n-fn check_empty_string(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, macro_call: &MacroCall, name: &str) {\n-    if let [part] = &format_args.format_string.parts[..]\n-        && let mut span = format_args.format_string.span\n-        && part.as_str() == \"\\n\"\n+fn check_empty_string(cx: &LateContext<'_>, format_args: &FormatArgs, macro_call: &MacroCall, name: &str) {\n+    if let [FormatArgsPiece::Literal(literal)] = &format_args.template[..]\n+        && literal.as_str() == \"\\n\"\n     {\n+        let mut span = format_args.span;\n+\n         let lint = if name == \"writeln\" {\n             span = expand_past_previous_comma(cx, span);\n \n@@ -428,33 +445,43 @@ fn check_empty_string(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, ma\n     }\n }\n \n-fn check_literal(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, name: &str) {\n-    let mut counts = HirIdMap::<usize>::default();\n-    for param in format_args.params() {\n-        *counts.entry(param.value.hir_id).or_default() += 1;\n+fn check_literal(cx: &LateContext<'_>, format_args: &FormatArgs, name: &str) {\n+    let arg_index = |argument: &FormatArgPosition| argument.index.unwrap_or_else(|pos| pos);\n+\n+    let mut counts = vec![0u32; format_args.arguments.all_args().len()];\n+    for piece in &format_args.template {\n+        if let FormatArgsPiece::Placeholder(placeholder) = piece {\n+            counts[arg_index(&placeholder.argument)] += 1;\n+        }\n     }\n \n-    for arg in &format_args.args {\n-        let value = arg.param.value;\n-\n-        if counts[&value.hir_id] == 1\n-            && arg.format.is_default()\n-            && let ExprKind::Lit(lit) = &value.kind\n-            && !value.span.from_expansion()\n-            && let Some(value_string) = snippet_opt(cx, value.span)\n-        {\n-            let (replacement, replace_raw) = match lit.node {\n-                LitKind::Str(..) => extract_str_literal(&value_string),\n-                LitKind::Char(ch) => (\n-                    match ch {\n-                        '\"' => \"\\\\\\\"\",\n-                        '\\'' => \"'\",\n+    for piece in &format_args.template {\n+        if let FormatArgsPiece::Placeholder(FormatPlaceholder {\n+            argument,\n+            span: Some(placeholder_span),\n+            format_trait: FormatTrait::Display,\n+            format_options,\n+        }) = piece\n+            && *format_options == FormatOptions::default()\n+            && let index = arg_index(argument)\n+            && counts[index] == 1\n+            && let Some(arg) = format_args.arguments.by_index(index)\n+            && let rustc_ast::ExprKind::Lit(lit) = &arg.expr.kind\n+            && !arg.expr.span.from_expansion()\n+            && let Some(value_string) = snippet_opt(cx, arg.expr.span)\n+    {\n+            let (replacement, replace_raw) = match lit.kind {\n+                LitKind::Str | LitKind::StrRaw(_)  => extract_str_literal(&value_string),\n+                LitKind::Char => (\n+                    match lit.symbol.as_str() {\n+                        \"\\\"\" => \"\\\\\\\"\",\n+                        \"\\\\'\" => \"'\",\n                         _ => &value_string[1..value_string.len() - 1],\n                     }\n                     .to_string(),\n                     false,\n                 ),\n-                LitKind::Bool(b) => (b.to_string(), false),\n+                LitKind::Bool => (lit.symbol.to_string(), false),\n                 _ => continue,\n             };\n \n@@ -464,7 +491,9 @@ fn check_literal(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, name: &\n                 PRINT_LITERAL\n             };\n \n-            let format_string_is_raw = format_args.format_string.style.is_some();\n+            let Some(format_string_snippet) = snippet_opt(cx, format_args.span) else { continue };\n+            let format_string_is_raw = format_string_snippet.starts_with('r');\n+\n             let replacement = match (format_string_is_raw, replace_raw) {\n                 (false, false) => Some(replacement),\n                 (false, true) => Some(replacement.replace('\"', \"\\\\\\\"\").replace('\\\\', \"\\\\\\\\\")),\n@@ -485,23 +514,24 @@ fn check_literal(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, name: &\n             span_lint_and_then(\n                 cx,\n                 lint,\n-                value.span,\n+                arg.expr.span,\n                 \"literal with an empty format string\",\n                 |diag| {\n                     if let Some(replacement) = replacement\n                         // `format!(\"{}\", \"a\")`, `format!(\"{named}\", named = \"b\")\n                         //              ~~~~~                      ~~~~~~~~~~~~~\n-                        && let Some(value_span) = format_args.value_with_prev_comma_span(value.hir_id)\n+                        && let Some(removal_span) = format_arg_removal_span(format_args, index)\n                     {\n                         let replacement = replacement.replace('{', \"{{\").replace('}', \"}}\");\n                         diag.multipart_suggestion(\n                             \"try this\",\n-                            vec![(arg.span, replacement), (value_span, String::new())],\n+                            vec![(*placeholder_span, replacement), (removal_span, String::new())],\n                             Applicability::MachineApplicable,\n                         );\n                     }\n                 },\n             );\n+\n         }\n     }\n }"}, {"sha": "8e0edd72f92f090e225067b28b784758402bcd95", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a2906a1598ca16ac080f95658a8a2eae10ff25d5/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2906a1598ca16ac080f95658a8a2eae10ff25d5/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=a2906a1598ca16ac080f95658a8a2eae10ff25d5", "patch": "@@ -6,6 +6,8 @@ use crate::visitors::{for_each_expr, Descend};\n use arrayvec::ArrayVec;\n use itertools::{izip, Either, Itertools};\n use rustc_ast::ast::LitKind;\n+use rustc_ast::FormatArgs;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::{self as hir, Expr, ExprField, ExprKind, HirId, LangItem, Node, QPath, TyKind};\n use rustc_lexer::unescape::unescape_literal;\n@@ -15,8 +17,10 @@ use rustc_parse_format::{self as rpf, Alignment};\n use rustc_span::def_id::DefId;\n use rustc_span::hygiene::{self, MacroKind, SyntaxContext};\n use rustc_span::{sym, BytePos, ExpnData, ExpnId, ExpnKind, Pos, Span, SpanData, Symbol};\n+use std::cell::RefCell;\n use std::iter::{once, zip};\n-use std::ops::ControlFlow;\n+use std::ops::{ControlFlow, Deref};\n+use std::sync::atomic::{AtomicBool, Ordering};\n \n const FORMAT_MACRO_DIAG_ITEMS: &[Symbol] = &[\n     sym::assert_eq_macro,\n@@ -339,6 +343,79 @@ fn is_assert_arg(cx: &LateContext<'_>, expr: &Expr<'_>, assert_expn: ExpnId) ->\n     }\n }\n \n+thread_local! {\n+    /// We preserve the [`FormatArgs`] structs from the early pass for use in the late pass to be\n+    /// able to access the many features of a [`LateContext`].\n+    ///\n+    /// A thread local is used because [`FormatArgs`] is `!Send` and `!Sync`, we are making an\n+    /// assumption that the early pass the populates the map and the later late passes will all be\n+    /// running on the same thread.\n+    static AST_FORMAT_ARGS: RefCell<FxHashMap<Span, FormatArgs>> = {\n+        static CALLED: AtomicBool = AtomicBool::new(false);\n+        debug_assert!(\n+            !CALLED.swap(true, Ordering::SeqCst),\n+            \"incorrect assumption: `AST_FORMAT_ARGS` should only be accessed by a single thread\",\n+        );\n+\n+        RefCell::default()\n+    };\n+}\n+\n+/// Record [`rustc_ast::FormatArgs`] for use in late lint passes, this only needs to be called by\n+/// one lint pass.\n+pub fn populate_ast_format_args(expr: &rustc_ast::Expr) {\n+    if let rustc_ast::ExprKind::FormatArgs(args) = &expr.kind {\n+        AST_FORMAT_ARGS.with(|ast_format_args| {\n+            ast_format_args.borrow_mut().insert(expr.span, args.deref().clone());\n+        });\n+    }\n+}\n+\n+/// Calls `callback` with an AST [`FormatArgs`] node if one is found\n+pub fn find_format_args(cx: &LateContext<'_>, start: &Expr<'_>, expn_id: ExpnId, callback: impl FnOnce(&FormatArgs)) {\n+    let format_args_expr = for_each_expr(start, |expr| {\n+        let ctxt = expr.span.ctxt();\n+        if ctxt == start.span.ctxt() {\n+            ControlFlow::Continue(Descend::Yes)\n+        } else if ctxt.outer_expn().is_descendant_of(expn_id)\n+            && macro_backtrace(expr.span)\n+                .map(|macro_call| cx.tcx.item_name(macro_call.def_id))\n+                .any(|name| matches!(name, sym::const_format_args | sym::format_args | sym::format_args_nl))\n+        {\n+            ControlFlow::Break(expr)\n+        } else {\n+            ControlFlow::Continue(Descend::No)\n+        }\n+    });\n+\n+    if let Some(format_args_expr) = format_args_expr {\n+        AST_FORMAT_ARGS.with(|ast_format_args| {\n+            ast_format_args.borrow().get(&format_args_expr.span).map(callback);\n+        });\n+    }\n+}\n+\n+/// Returns the [`Span`] of the value at `index` extended to the previous comma, e.g. for the value\n+/// `10`\n+///\n+/// ```ignore\n+/// format(\"{}.{}\", 10, 11)\n+/// //            ^^^^\n+/// ```\n+pub fn format_arg_removal_span(format_args: &FormatArgs, index: usize) -> Option<Span> {\n+    let ctxt = format_args.span.ctxt();\n+\n+    let current = hygiene::walk_chain(format_args.arguments.by_index(index)?.expr.span, ctxt);\n+\n+    let prev = if index == 0 {\n+        format_args.span\n+    } else {\n+        hygiene::walk_chain(format_args.arguments.by_index(index - 1)?.expr.span, ctxt)\n+    };\n+\n+    Some(current.with_lo(prev.hi()))\n+}\n+\n /// The format string doesn't exist in the HIR, so we reassemble it from source code\n #[derive(Debug)]\n pub struct FormatString {"}]}