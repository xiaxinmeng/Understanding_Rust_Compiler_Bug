{"sha": "bba81c975d9136d2bf10413826c743d25e54d97b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYTgxYzk3NWQ5MTM2ZDJiZjEwNDEzODI2Yzc0M2QyNWU1NGQ5N2I=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-29T00:25:35Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-29T09:48:17Z"}, "message": "rustc_borrowck: replace \"lvalue\" terminology with \"place\" in docs.", "tree": {"sha": "89a1ad0d41b21409a2ab7ff65d0bc34013d6ba6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89a1ad0d41b21409a2ab7ff65d0bc34013d6ba6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bba81c975d9136d2bf10413826c743d25e54d97b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bba81c975d9136d2bf10413826c743d25e54d97b", "html_url": "https://github.com/rust-lang/rust/commit/bba81c975d9136d2bf10413826c743d25e54d97b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bba81c975d9136d2bf10413826c743d25e54d97b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f8d263e876106a3c05a05b93fb78a4de07b37f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f8d263e876106a3c05a05b93fb78a4de07b37f5", "html_url": "https://github.com/rust-lang/rust/commit/6f8d263e876106a3c05a05b93fb78a4de07b37f5"}], "stats": {"total": 162, "additions": 81, "deletions": 81}, "files": [{"sha": "da2b1ef0b1c02a3aef7b1345945d3858285a1e11", "filename": "src/librustc_borrowck/borrowck/README.md", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/bba81c975d9136d2bf10413826c743d25e54d97b/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bba81c975d9136d2bf10413826c743d25e54d97b/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md?ref=bba81c975d9136d2bf10413826c743d25e54d97b", "patch": "@@ -43,22 +43,22 @@ it is safe with respect to the in-scope loans.\n # Formal model\n \n Throughout the docs we'll consider a simple subset of Rust in which\n-you can only borrow from lvalues, defined like so:\n+you can only borrow from places, defined like so:\n \n ```text\n-LV = x | LV.f | *LV\n+P = x | P.f | *P\n ```\n \n-Here `x` represents some variable, `LV.f` is a field reference,\n-and `*LV` is a pointer dereference. There is no auto-deref or other\n+Here `x` represents some variable, `P.f` is a field reference,\n+and `*P` is a pointer dereference. There is no auto-deref or other\n niceties. This means that if you have a type like:\n \n ```rust\n struct S { f: i32 }\n ```\n \n and a variable `a: Box<S>`, then the rust expression `a.f` would correspond\n-to an `LV` of `(*a).f`.\n+to an `P` of `(*a).f`.\n \n Here is the formal grammar for the types we'll consider:\n \n@@ -99,7 +99,7 @@ this sort of thing.\n #### Loans and restrictions\n \n The way the borrow checker works is that it analyzes each borrow\n-expression (in our simple model, that's stuff like `&LV`, though in\n+expression (in our simple model, that's stuff like `&P`, though in\n real life there are a few other cases to consider). For each borrow\n expression, it computes a `Loan`, which is a data structure that\n records (1) the value being borrowed, (2) the mutability and scope of\n@@ -108,29 +108,29 @@ struct defined in `middle::borrowck`. Formally, we define `LOAN` as\n follows:\n \n ```text\n-LOAN = (LV, LT, MQ, RESTRICTION*)\n-RESTRICTION = (LV, ACTION*)\n+LOAN = (P, LT, MQ, RESTRICTION*)\n+RESTRICTION = (P, ACTION*)\n ACTION = MUTATE | CLAIM | FREEZE\n ```\n \n-Here the `LOAN` tuple defines the lvalue `LV` being borrowed; the\n+Here the `LOAN` tuple defines the place `P` being borrowed; the\n lifetime `LT` of that borrow; the mutability `MQ` of the borrow; and a\n list of restrictions. The restrictions indicate actions which, if\n taken, could invalidate the loan and lead to type safety violations.\n \n-Each `RESTRICTION` is a pair of a restrictive lvalue `LV` (which will\n+Each `RESTRICTION` is a pair of a restrictive place `P` (which will\n either be the path that was borrowed or some prefix of the path that\n was borrowed) and a set of restricted actions.  There are three kinds\n-of actions that may be restricted for the path `LV`:\n+of actions that may be restricted for the path `P`:\n \n-- `MUTATE` means that `LV` cannot be assigned to;\n-- `CLAIM` means that the `LV` cannot be borrowed mutably;\n-- `FREEZE` means that the `LV` cannot be borrowed immutably;\n+- `MUTATE` means that `P` cannot be assigned to;\n+- `CLAIM` means that the `P` cannot be borrowed mutably;\n+- `FREEZE` means that the `P` cannot be borrowed immutably;\n \n-Finally, it is never possible to move from an lvalue that appears in a\n-restriction. This implies that the \"empty restriction\" `(LV, [])`,\n+Finally, it is never possible to move from a place that appears in a\n+restriction. This implies that the \"empty restriction\" `(P, [])`,\n which contains an empty set of actions, still has a purpose---it\n-prevents moves from `LV`. I chose not to make `MOVE` a fourth kind of\n+prevents moves from `P`. I chose not to make `MOVE` a fourth kind of\n action because that would imply that sometimes moves are permitted\n from restricted values, which is not the case.\n \n@@ -239,22 +239,22 @@ live. (This is done via restrictions, read on.)\n \n We start with the `gather_loans` pass, which walks the AST looking for\n borrows.  For each borrow, there are three bits of information: the\n-lvalue `LV` being borrowed and the mutability `MQ` and lifetime `LT`\n+place `P` being borrowed and the mutability `MQ` and lifetime `LT`\n of the resulting pointer. Given those, `gather_loans` applies four\n validity tests:\n \n-1. `MUTABILITY(LV, MQ)`: The mutability of the reference is\n-compatible with the mutability of `LV` (i.e., not borrowing immutable\n+1. `MUTABILITY(P, MQ)`: The mutability of the reference is\n+compatible with the mutability of `P` (i.e., not borrowing immutable\n data as mutable).\n \n-2. `ALIASABLE(LV, MQ)`: The aliasability of the reference is\n-compatible with the aliasability of `LV`. The goal is to prevent\n+2. `ALIASABLE(P, MQ)`: The aliasability of the reference is\n+compatible with the aliasability of `P`. The goal is to prevent\n `&mut` borrows of aliasability data.\n \n-3. `LIFETIME(LV, LT, MQ)`: The lifetime of the borrow does not exceed\n+3. `LIFETIME(P, LT, MQ)`: The lifetime of the borrow does not exceed\n the lifetime of the value being borrowed.\n \n-4. `RESTRICTIONS(LV, LT, ACTIONS) = RS`: This pass checks and computes the\n+4. `RESTRICTIONS(P, LT, ACTIONS) = RS`: This pass checks and computes the\n restrictions to maintain memory safety. These are the restrictions\n that will go into the final loan. We'll discuss in more detail below.\n \n@@ -263,7 +263,7 @@ that will go into the final loan. We'll discuss in more detail below.\n Checking mutability is fairly straightforward. We just want to prevent\n immutable data from being borrowed as mutable. Note that it is ok to borrow\n mutable data as immutable, since that is simply a freeze. The judgement\n-`MUTABILITY(LV, MQ)` means the mutability of `LV` is compatible with a borrow\n+`MUTABILITY(P, MQ)` means the mutability of `P` is compatible with a borrow\n of mutability `MQ`. The Rust code corresponding to this predicate is the\n function `check_mutability` in `middle::borrowck::gather_loans`.\n \n@@ -288,15 +288,15 @@ MUTABILITY(X, imm)                  // M-Var-Imm\n \n Fields and boxes inherit their mutability from\n their base expressions, so both of their rules basically\n-delegate the check to the base expression `LV`:\n+delegate the check to the base expression `P`:\n \n ```text\n-MUTABILITY(LV.f, MQ)                // M-Field\n-  MUTABILITY(LV, MQ)\n+MUTABILITY(P.f, MQ)                // M-Field\n+  MUTABILITY(P, MQ)\n \n-MUTABILITY(*LV, MQ)                 // M-Deref-Unique\n-  TYPE(LV) = Box<Ty>\n-  MUTABILITY(LV, MQ)\n+MUTABILITY(*P, MQ)                 // M-Deref-Unique\n+  TYPE(P) = Box<Ty>\n+  MUTABILITY(P, MQ)\n ```\n \n ### Checking mutability of immutable pointer types\n@@ -305,24 +305,24 @@ Immutable pointer types like `&T` can only\n be borrowed if MQ is immutable:\n \n ```text\n-MUTABILITY(*LV, imm)               // M-Deref-Borrowed-Imm\n-  TYPE(LV) = &Ty\n+MUTABILITY(*P, imm)               // M-Deref-Borrowed-Imm\n+  TYPE(P) = &Ty\n ```\n \n ### Checking mutability of mutable pointer types\n \n `&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n \n ```text\n-MUTABILITY(*LV, MQ)                 // M-Deref-Borrowed-Mut\n-  TYPE(LV) = &mut Ty\n+MUTABILITY(*P, MQ)                 // M-Deref-Borrowed-Mut\n+  TYPE(P) = &mut Ty\n ```\n \n ## Checking aliasability\n \n The goal of the aliasability check is to ensure that we never permit `&mut`\n-borrows of aliasable data. The judgement `ALIASABLE(LV, MQ)` means the\n-aliasability of `LV` is compatible with a borrow of mutability `MQ`. The Rust\n+borrows of aliasable data. The judgement `ALIASABLE(P, MQ)` means the\n+aliasability of `P` is compatible with a borrow of mutability `MQ`. The Rust\n code corresponding to this predicate is the function `check_aliasability()` in\n `middle::borrowck::gather_loans`.\n \n@@ -340,11 +340,11 @@ the stack frame.\n Owned content is aliasable if it is found in an aliasable location:\n \n ```text\n-ALIASABLE(LV.f, MQ)                // M-Field\n-  ALIASABLE(LV, MQ)\n+ALIASABLE(P.f, MQ)                // M-Field\n+  ALIASABLE(P, MQ)\n \n-ALIASABLE(*LV, MQ)                 // M-Deref-Unique\n-  ALIASABLE(LV, MQ)\n+ALIASABLE(*P, MQ)                 // M-Deref-Unique\n+  ALIASABLE(P, MQ)\n ```\n \n ### Checking aliasability of immutable pointer types\n@@ -353,25 +353,25 @@ Immutable pointer types like `&T` are aliasable, and hence can only be\n borrowed immutably:\n \n ```text\n-ALIASABLE(*LV, imm)                // M-Deref-Borrowed-Imm\n-  TYPE(LV) = &Ty\n+ALIASABLE(*P, imm)                // M-Deref-Borrowed-Imm\n+  TYPE(P) = &Ty\n ```\n \n ### Checking aliasability of mutable pointer types\n \n `&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n \n ```text\n-ALIASABLE(*LV, MQ)                 // M-Deref-Borrowed-Mut\n-  TYPE(LV) = &mut Ty\n+ALIASABLE(*P, MQ)                 // M-Deref-Borrowed-Mut\n+  TYPE(P) = &mut Ty\n ```\n \n ## Checking lifetime\n \n These rules aim to ensure that no data is borrowed for a scope that exceeds\n its lifetime. These two computations wind up being intimately related.\n-Formally, we define a predicate `LIFETIME(LV, LT, MQ)`, which states that\n-\"the lvalue `LV` can be safely borrowed for the lifetime `LT` with mutability\n+Formally, we define a predicate `LIFETIME(P, LT, MQ)`, which states that\n+\"the place `P` can be safely borrowed for the lifetime `LT` with mutability\n `MQ`\". The Rust code corresponding to this predicate is the module\n `middle::borrowck::gather_loans::lifetime`.\n \n@@ -391,12 +391,12 @@ The lifetime of a field or box is the same as the lifetime\n of its owner:\n \n ```text\n-LIFETIME(LV.f, LT, MQ)              // L-Field\n-  LIFETIME(LV, LT, MQ)\n+LIFETIME(P.f, LT, MQ)              // L-Field\n+  LIFETIME(P, LT, MQ)\n \n-LIFETIME(*LV, LT, MQ)               // L-Deref-Send\n-  TYPE(LV) = Box<Ty>\n-  LIFETIME(LV, LT, MQ)\n+LIFETIME(*P, LT, MQ)               // L-Deref-Send\n+  TYPE(P) = Box<Ty>\n+  LIFETIME(P, LT, MQ)\n ```\n \n ### Checking lifetime for derefs of references\n@@ -408,26 +408,26 @@ of the borrow is shorter than the lifetime `LT'` of the pointer\n itself:\n \n ```text\n-LIFETIME(*LV, LT, MQ)               // L-Deref-Borrowed\n-  TYPE(LV) = &LT' Ty OR &LT' mut Ty\n+LIFETIME(*P, LT, MQ)               // L-Deref-Borrowed\n+  TYPE(P) = &LT' Ty OR &LT' mut Ty\n   LT <= LT'\n ```\n \n ## Computing the restrictions\n \n The final rules govern the computation of *restrictions*, meaning that\n we compute the set of actions that will be illegal for the life of the\n-loan. The predicate is written `RESTRICTIONS(LV, LT, ACTIONS) =\n+loan. The predicate is written `RESTRICTIONS(P, LT, ACTIONS) =\n RESTRICTION*`, which can be read \"in order to prevent `ACTIONS` from\n-occurring on `LV`, the restrictions `RESTRICTION*` must be respected\n+occurring on `P`, the restrictions `RESTRICTION*` must be respected\n for the lifetime of the loan\".\n \n Note that there is an initial set of restrictions: these restrictions\n are computed based on the kind of borrow:\n \n ```text\n-&mut LV =>   RESTRICTIONS(LV, LT, MUTATE|CLAIM|FREEZE)\n-&LV =>       RESTRICTIONS(LV, LT, MUTATE|CLAIM)\n+&mut P =>   RESTRICTIONS(P, LT, MUTATE|CLAIM|FREEZE)\n+&P =>       RESTRICTIONS(P, LT, MUTATE|CLAIM)\n ```\n \n The reasoning here is that a mutable borrow must be the only writer,\n@@ -451,8 +451,8 @@ Restricting a field is the same as restricting the owner of that\n field:\n \n ```text\n-RESTRICTIONS(LV.f, LT, ACTIONS) = RS, (LV.f, ACTIONS)  // R-Field\n-  RESTRICTIONS(LV, LT, ACTIONS) = RS\n+RESTRICTIONS(P.f, LT, ACTIONS) = RS, (P.f, ACTIONS)  // R-Field\n+  RESTRICTIONS(P, LT, ACTIONS) = RS\n ```\n \n The reasoning here is as follows. If the field must not be mutated,\n@@ -467,32 +467,32 @@ origin of inherited mutability.\n Because the mutability of owned referents is inherited, restricting an\n owned referent is similar to restricting a field, in that it implies\n restrictions on the pointer. However, boxes have an important\n-twist: if the owner `LV` is mutated, that causes the owned referent\n-`*LV` to be freed! So whenever an owned referent `*LV` is borrowed, we\n-must prevent the box `LV` from being mutated, which means\n+twist: if the owner `P` is mutated, that causes the owned referent\n+`*P` to be freed! So whenever an owned referent `*P` is borrowed, we\n+must prevent the box `P` from being mutated, which means\n that we always add `MUTATE` and `CLAIM` to the restriction set imposed\n-on `LV`:\n+on `P`:\n \n ```text\n-RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Send-Pointer\n-  TYPE(LV) = Box<Ty>\n-  RESTRICTIONS(LV, LT, ACTIONS|MUTATE|CLAIM) = RS\n+RESTRICTIONS(*P, LT, ACTIONS) = RS, (*P, ACTIONS)    // R-Deref-Send-Pointer\n+  TYPE(P) = Box<Ty>\n+  RESTRICTIONS(P, LT, ACTIONS|MUTATE|CLAIM) = RS\n ```\n \n ### Restrictions for loans of immutable borrowed referents\n \n Immutable borrowed referents are freely aliasable, meaning that\n the compiler does not prevent you from copying the pointer.  This\n implies that issuing restrictions is useless. We might prevent the\n-user from acting on `*LV` itself, but there could be another path\n-`*LV1` that refers to the exact same memory, and we would not be\n+user from acting on `*P` itself, but there could be another path\n+`*P1` that refers to the exact same memory, and we would not be\n restricting that path. Therefore, the rule for `&Ty` pointers\n always returns an empty set of restrictions, and it only permits\n restricting `MUTATE` and `CLAIM` actions:\n \n ```text\n-RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n-  TYPE(LV) = &LT' Ty\n+RESTRICTIONS(*P, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n+  TYPE(P) = &LT' Ty\n   LT <= LT'                                            // (1)\n   ACTIONS subset of [MUTATE, CLAIM]\n ```\n@@ -546,7 +546,7 @@ This function is legal. The reason for this is that the inner pointer\n (`*point : &'b Point`) is enough to guarantee the memory is immutable\n and valid for the lifetime `'b`.  This is reflected in\n `RESTRICTIONS()` by the fact that we do not recurse (i.e., we impose\n-no restrictions on `LV`, which in this particular case is the pointer\n+no restrictions on `P`, which in this particular case is the pointer\n `point : &'a &'b Point`).\n \n #### Why both `LIFETIME()` and `RESTRICTIONS()`?\n@@ -612,10 +612,10 @@ while the new claimant is live.\n The rule for mutable borrowed pointers is as follows:\n \n ```text\n-RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Mut-Borrowed\n-  TYPE(LV) = &LT' mut Ty\n+RESTRICTIONS(*P, LT, ACTIONS) = RS, (*P, ACTIONS)    // R-Deref-Mut-Borrowed\n+  TYPE(P) = &LT' mut Ty\n   LT <= LT'                                            // (1)\n-  RESTRICTIONS(LV, LT, ACTIONS) = RS                   // (2)\n+  RESTRICTIONS(P, LT, ACTIONS) = RS                   // (2)\n ```\n \n Let's examine the two numbered clauses:\n@@ -670,7 +670,7 @@ fn foo(t0: &mut i32) {\n \n Remember that `&mut` pointers are linear, and hence `let t1 = t0` is a\n move of `t0` -- or would be, if it were legal. Instead, we get an\n-error, because clause (2) imposes restrictions on `LV` (`t0`, here),\n+error, because clause (2) imposes restrictions on `P` (`t0`, here),\n and any restrictions on a path make it impossible to move from that\n path.\n \n@@ -906,7 +906,7 @@ results of a dataflow computation.\n \n The `MovePath` tree tracks every path that is moved or assigned to.\n These paths have the same form as the `LoanPath` data structure, which\n-in turn is the \"real world version of the lvalues `LV` that we\n+in turn is the \"real world version of the places `P` that we\n introduced earlier. The difference between a `MovePath` and a `LoanPath`\n is that move paths are:\n \n@@ -1132,7 +1132,7 @@ is implied by the relevant moves.\n While writing up these docs, I encountered some rules I believe to be\n stricter than necessary:\n \n-- I think restricting the `&mut` LV against moves and `ALIAS` is sufficient,\n+- I think restricting the `&mut` P against moves and `ALIAS` is sufficient,\n   `MUTATE` and `CLAIM` are overkill. `MUTATE` was necessary when swap was\n   a built-in operator, but as it is not, it is implied by `CLAIM`,\n   and `CLAIM` is implied by `ALIAS`. The only net effect of this is an"}, {"sha": "84ca2a9318ab36a226efd894a4dc2ef1ac647ea8", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bba81c975d9136d2bf10413826c743d25e54d97b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba81c975d9136d2bf10413826c743d25e54d97b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=bba81c975d9136d2bf10413826c743d25e54d97b", "patch": "@@ -384,9 +384,9 @@ impl ToInteriorKind for mc::InteriorKind {\n }\n \n // This can be:\n-// - a pointer dereference (`*LV` in README.md)\n+// - a pointer dereference (`*P` in README.md)\n // - a field reference, with an optional definition of the containing\n-//   enum variant (`LV.f` in README.md)\n+//   enum variant (`P.f` in README.md)\n // `DefId` is present when the field is part of struct that is in\n // a variant of an enum. For instance in:\n // `enum E { X { foo: u32 }, Y { foo: u32 }}`"}, {"sha": "9a6d83b8eb75904c81d2b45a128992cf328c4dde", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bba81c975d9136d2bf10413826c743d25e54d97b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bba81c975d9136d2bf10413826c743d25e54d97b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=bba81c975d9136d2bf10413826c743d25e54d97b", "patch": "@@ -607,7 +607,7 @@ enum ArtificialField {\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum ShallowOrDeep {\n     /// From the RFC: \"A *shallow* access means that the immediate\n-    /// fields reached at LV are accessed, but references or pointers\n+    /// fields reached at P are accessed, but references or pointers\n     /// found within are not dereferenced. Right now, the only access\n     /// that is shallow is an assignment like `x = ...;`, which would\n     /// be a *shallow write* of `x`.\""}]}