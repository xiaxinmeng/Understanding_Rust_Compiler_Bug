{"sha": "6c2c29c43206d6e2f1091fa278d2792ea10e3659", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMmMyOWM0MzIwNmQ2ZTJmMTA5MWZhMjc4ZDI3OTJlYTEwZTM2NTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-25T14:27:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-25T14:27:08Z"}, "message": "Auto merge of #64766 - Centril:rollup-gdy5jr6, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #62975 (Almost fully deprecate hir::map::Map.hir_to_node_id)\n - #64386 (use `sign` variable in abs and wrapping_abs methods)\n - #64508 (or-patterns: Push `PatKind/PatternKind::Or` at top level to HIR & HAIR)\n - #64738 (Add const-eval support for SIMD types, insert, and extract)\n - #64759 (Refactor mbe a tiny bit)\n - #64764 (Master is now 1.40 )\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "8cfaca24961df42b0c4f69dd214d1b9e552ce7d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cfaca24961df42b0c4f69dd214d1b9e552ce7d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c2c29c43206d6e2f1091fa278d2792ea10e3659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c2c29c43206d6e2f1091fa278d2792ea10e3659", "html_url": "https://github.com/rust-lang/rust/commit/6c2c29c43206d6e2f1091fa278d2792ea10e3659", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c2c29c43206d6e2f1091fa278d2792ea10e3659/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acf7b50c737cfb8f4003477559305bedf3c316fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/acf7b50c737cfb8f4003477559305bedf3c316fe", "html_url": "https://github.com/rust-lang/rust/commit/acf7b50c737cfb8f4003477559305bedf3c316fe"}, {"sha": "1e8dd3756171a8a01f3951d61ff6ba8d1ef5bd7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e8dd3756171a8a01f3951d61ff6ba8d1ef5bd7d", "html_url": "https://github.com/rust-lang/rust/commit/1e8dd3756171a8a01f3951d61ff6ba8d1ef5bd7d"}], "stats": {"total": 1235, "additions": 568, "deletions": 667}, "files": [{"sha": "ef1b6e217a24f05746289822a9448a6378c20784", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -13,7 +13,7 @@ use build_helper::output;\n use crate::Build;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.39.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.40.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "9bc76f51570e15fd67c49bc8ff8dfa6bafe308f4", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -240,7 +240,6 @@ pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[rustc_allocator_nounwind]\n pub fn handle_alloc_error(layout: Layout) -> ! {\n-    #[cfg_attr(bootstrap, allow(improper_ctypes))]\n     extern \"Rust\" {\n         #[lang = \"oom\"]\n         fn oom_impl(layout: Layout) -> !;"}, {"sha": "247cd9a020161333fe7c2711ecab1762b2a81c74", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -117,7 +117,6 @@\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n #![feature(rustc_const_unstable)]\n-#![cfg_attr(bootstrap, feature(const_vec_new))]\n #![feature(slice_partition_dedup)]\n #![feature(maybe_uninit_extra, maybe_uninit_slice)]\n #![feature(alloc_layout_extra)]"}, {"sha": "abe50fdb7a396030c3adcc1a2e6e9bf4a893c30f", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -369,7 +369,6 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(bootstrap, rustc_const_unstable(feature = \"const_string_new\"))]\n     pub const fn new() -> String {\n         String { vec: Vec::new() }\n     }"}, {"sha": "e5672f8542ff65de2e781f399d77cbd5a18f7068", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -291,7 +291,7 @@ use crate::raw_vec::RawVec;\n /// [`reserve`]: ../../std/vec/struct.Vec.html#method.reserve\n /// [owned slice]: ../../std/boxed/struct.Box.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[cfg_attr(all(not(bootstrap), not(test)), rustc_diagnostic_item = \"vec_type\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"vec_type\")]\n pub struct Vec<T> {\n     buf: RawVec<T>,\n     len: usize,\n@@ -314,7 +314,6 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(bootstrap, rustc_const_unstable(feature = \"const_vec_new\"))]\n     pub const fn new() -> Vec<T> {\n         Vec {\n             buf: RawVec::NEW,"}, {"sha": "617bdd238f4c63d4660628b84cf5e4d5a140af6a", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -1,6 +1,5 @@\n //! impl bool {}\n \n-#[cfg(not(bootstrap))]\n #[lang = \"bool\"]\n impl bool {\n     /// Returns `Some(t)` if the `bool` is `true`, or `None` otherwise."}, {"sha": "14d947ccf2402d765933b9cb0536282209e13e16", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -135,7 +135,6 @@ pub trait Clone : Sized {\n \n /// Derive macro generating an impl of the trait `Clone`.\n #[rustc_builtin_macro]\n-#[cfg_attr(bootstrap, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n pub macro Clone($item:item) { /* compiler built-in */ }"}, {"sha": "d0ea75c7623f4d0010f67d5467d444690677c3a0", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -210,7 +210,6 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n \n /// Derive macro generating an impl of the trait `PartialEq`.\n #[rustc_builtin_macro]\n-#[cfg_attr(bootstrap, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n pub macro PartialEq($item:item) { /* compiler built-in */ }\n@@ -273,7 +272,6 @@ pub trait Eq: PartialEq<Self> {\n \n /// Derive macro generating an impl of the trait `Eq`.\n #[rustc_builtin_macro]\n-#[cfg_attr(bootstrap, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_eq)]\n pub macro Eq($item:item) { /* compiler built-in */ }\n@@ -624,7 +622,6 @@ pub trait Ord: Eq + PartialOrd<Self> {\n \n /// Derive macro generating an impl of the trait `Ord`.\n #[rustc_builtin_macro]\n-#[cfg_attr(bootstrap, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n pub macro Ord($item:item) { /* compiler built-in */ }\n@@ -873,7 +870,6 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n \n /// Derive macro generating an impl of the trait `PartialOrd`.\n #[rustc_builtin_macro]\n-#[cfg_attr(bootstrap, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n pub macro PartialOrd($item:item) { /* compiler built-in */ }"}, {"sha": "1aadc77cfb8da75b3bd68747866e75bbba6911e1", "filename": "src/libcore/default.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -117,7 +117,6 @@ pub trait Default: Sized {\n \n /// Derive macro generating an impl of the trait `Default`.\n #[rustc_builtin_macro]\n-#[cfg_attr(bootstrap, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics)]\n pub macro Default($item:item) { /* compiler built-in */ }"}, {"sha": "aafa35873bb65544440e8e4647c5cb53f4e9e86f", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -518,8 +518,7 @@ impl Display for Arguments<'_> {\n     label=\"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\",\n )]\n #[doc(alias = \"{:?}\")]\n-#[cfg_attr(bootstrap, lang = \"debug_trait\")]\n-#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"debug_trait\")]\n+#[rustc_diagnostic_item = \"debug_trait\"]\n pub trait Debug {\n     /// Formats the value using the given formatter.\n     ///\n@@ -550,7 +549,6 @@ pub trait Debug {\n pub(crate) mod macros {\n     /// Derive macro generating an impl of the trait `Debug`.\n     #[rustc_builtin_macro]\n-    #[cfg_attr(bootstrap, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n     pub macro Debug($item:item) { /* compiler built-in */ }"}, {"sha": "020e085abf8a8eb365f552c909f8d092df76e5e8", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -202,7 +202,6 @@ pub trait Hash {\n pub(crate) mod macros {\n     /// Derive macro generating an impl of the trait `Hash`.\n     #[rustc_builtin_macro]\n-    #[cfg_attr(bootstrap, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n     pub macro Hash($item:item) { /* compiler built-in */ }"}, {"sha": "b240d059114eb7e67bdf65efde9f8f498bd960d4", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -1299,38 +1299,16 @@ extern \"rust-intrinsic\" {\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_add` method. For example,\n     /// [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n-    #[cfg(bootstrap)]\n-    pub fn overflowing_add<T>(a: T, b: T) -> T;\n-    /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n-    /// The stabilized versions of this intrinsic are available on the integer\n-    /// primitives via the `wrapping_sub` method. For example,\n-    /// [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n-    #[cfg(bootstrap)]\n-    pub fn overflowing_sub<T>(a: T, b: T) -> T;\n-    /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n-    /// The stabilized versions of this intrinsic are available on the integer\n-    /// primitives via the `wrapping_mul` method. For example,\n-    /// [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n-    #[cfg(bootstrap)]\n-    pub fn overflowing_mul<T>(a: T, b: T) -> T;\n-\n-    /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n-    /// The stabilized versions of this intrinsic are available on the integer\n-    /// primitives via the `wrapping_add` method. For example,\n-    /// [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n-    #[cfg(not(bootstrap))]\n     pub fn wrapping_add<T>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_sub` method. For example,\n     /// [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n-    #[cfg(not(bootstrap))]\n     pub fn wrapping_sub<T>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `wrapping_mul` method. For example,\n     /// [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n-    #[cfg(not(bootstrap))]\n     pub fn wrapping_mul<T>(a: T, b: T) -> T;\n \n     /// Computes `a + b`, while saturating at numeric bounds."}, {"sha": "e8c76b49a8e567a92ead873465484b63d10d8a55", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -87,7 +87,6 @@\n #![feature(link_llvm_intrinsics)]\n #![feature(never_type)]\n #![feature(nll)]\n-#![cfg_attr(bootstrap, feature(bind_by_move_pattern_guards))]\n #![feature(exhaustive_patterns)]\n #![feature(no_core)]\n #![feature(on_unimplemented)]\n@@ -120,9 +119,6 @@\n #![feature(rtm_target_feature)]\n #![feature(f16c_target_feature)]\n #![feature(hexagon_target_feature)]\n-#![cfg_attr(bootstrap, feature(const_slice_len))]\n-#![cfg_attr(bootstrap, feature(const_str_as_bytes))]\n-#![cfg_attr(bootstrap, feature(const_str_len))]\n #![feature(const_int_conversion)]\n #![feature(const_transmute)]\n #![feature(non_exhaustive)]"}, {"sha": "ef91c3559d8be2b4c92388cf23b46482c94dd36e", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -1236,10 +1236,8 @@ pub(crate) mod builtin {\n     pub macro test($item:item) { /* compiler built-in */ }\n \n     /// Attribute macro applied to a function to turn it into a benchmark test.\n-    #[cfg_attr(not(bootstrap), unstable(soft, feature = \"test\", issue = \"50297\",\n-               reason = \"`bench` is a part of custom test frameworks which are unstable\"))]\n-    #[cfg_attr(bootstrap, unstable(feature = \"test\", issue = \"50297\",\n-               reason = \"`bench` is a part of custom test frameworks which are unstable\"))]\n+    #[unstable(soft, feature = \"test\", issue = \"50297\",\n+               reason = \"`bench` is a part of custom test frameworks which are unstable\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n     pub macro bench($item:item) { /* compiler built-in */ }"}, {"sha": "7f3d958f5dc80c683de7c3a8eda1cdb268266120", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -290,7 +290,6 @@ pub trait Copy : Clone {\n \n /// Derive macro generating an impl of the trait `Copy`.\n #[rustc_builtin_macro]\n-#[cfg_attr(bootstrap, rustc_macro_transparency = \"semitransparent\")]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n pub macro Copy($item:item) { /* compiler built-in */ }"}, {"sha": "933a2a124733b72abfd49d10785d31fc05197147", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 32, "deletions": 45, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -1112,13 +1112,7 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_add(self, rhs: Self) -> Self {\n-                #[cfg(bootstrap)] {\n-                    intrinsics::overflowing_add(self, rhs)\n-                }\n-\n-                #[cfg(not(bootstrap))] {\n-                    intrinsics::wrapping_add(self, rhs)\n-                }\n+                intrinsics::wrapping_add(self, rhs)\n             }\n         }\n \n@@ -1141,13 +1135,7 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_sub(self, rhs: Self) -> Self {\n-                #[cfg(bootstrap)] {\n-                    intrinsics::overflowing_sub(self, rhs)\n-                }\n-\n-                #[cfg(not(bootstrap))] {\n-                    intrinsics::wrapping_sub(self, rhs)\n-                }\n+                intrinsics::wrapping_sub(self, rhs)\n             }\n         }\n \n@@ -1169,13 +1157,7 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_mul(self, rhs: Self) -> Self {\n-                #[cfg(bootstrap)] {\n-                    intrinsics::overflowing_mul(self, rhs)\n-                }\n-\n-                #[cfg(not(bootstrap))] {\n-                    intrinsics::wrapping_mul(self, rhs)\n-                }\n+                intrinsics::wrapping_mul(self, rhs)\n             }\n         }\n \n@@ -1402,7 +1384,16 @@ $EndFeature, \"\n             #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n             #[inline]\n             pub const fn wrapping_abs(self) -> Self {\n-                (self ^ (self >> ($BITS - 1))).wrapping_sub(self >> ($BITS - 1))\n+                // sign is -1 (all ones) for negative numbers, 0 otherwise.\n+                let sign = self >> ($BITS - 1);\n+                // For positive self, sign == 0 so the expression is simply\n+                // (self ^ 0).wrapping_sub(0) == self == abs(self).\n+                //\n+                // For negative self, self ^ sign == self ^ all_ones.\n+                // But all_ones ^ self == all_ones - self == -1 - self.\n+                // So for negative numbers, (self ^ sign).wrapping_sub(sign) is\n+                // (-1 - self).wrapping_sub(-1) == -self == abs(self).\n+                (self ^ sign).wrapping_sub(sign)\n             }\n         }\n \n@@ -1761,7 +1752,7 @@ $EndFeature, \"\n             #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n             #[inline]\n             pub const fn overflowing_abs(self) -> (Self, bool) {\n-                (self ^ (self >> ($BITS - 1))).overflowing_sub(self >> ($BITS - 1))\n+                (self.wrapping_abs(), self == Self::min_value())\n             }\n         }\n \n@@ -1969,7 +1960,21 @@ $EndFeature, \"\n                 // Note that the #[inline] above means that the overflow\n                 // semantics of the subtraction depend on the crate we're being\n                 // inlined into.\n-                (self ^ (self >> ($BITS - 1))) - (self >> ($BITS - 1))\n+\n+                // sign is -1 (all ones) for negative numbers, 0 otherwise.\n+                let sign = self >> ($BITS - 1);\n+                // For positive self, sign == 0 so the expression is simply\n+                // (self ^ 0) - 0 == self == abs(self).\n+                //\n+                // For negative self, self ^ sign == self ^ all_ones.\n+                // But all_ones ^ self == all_ones - self == -1 - self.\n+                // So for negative numbers, (self ^ sign) - sign is\n+                // (-1 - self) - -1 == -self == abs(self).\n+                //\n+                // The subtraction overflows when self is min_value(), because\n+                // (-1 - min_value()) - -1 is max_value() - -1 which overflows.\n+                // This is exactly when we want self.abs() to overflow.\n+                (self ^ sign) - sign\n             }\n         }\n \n@@ -3040,13 +3045,7 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_add(self, rhs: Self) -> Self {\n-                #[cfg(bootstrap)] {\n-                    intrinsics::overflowing_add(self, rhs)\n-                }\n-\n-                #[cfg(not(bootstrap))] {\n-                    intrinsics::wrapping_add(self, rhs)\n-                }\n+                intrinsics::wrapping_add(self, rhs)\n             }\n         }\n \n@@ -3068,13 +3067,7 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_sub(self, rhs: Self) -> Self {\n-                #[cfg(bootstrap)] {\n-                    intrinsics::overflowing_sub(self, rhs)\n-                }\n-\n-                #[cfg(not(bootstrap))] {\n-                    intrinsics::wrapping_sub(self, rhs)\n-                }\n+                intrinsics::wrapping_sub(self, rhs)\n             }\n         }\n \n@@ -3097,13 +3090,7 @@ $EndFeature, \"\n                           without modifying the original\"]\n         #[inline]\n         pub const fn wrapping_mul(self, rhs: Self) -> Self {\n-            #[cfg(bootstrap)] {\n-                intrinsics::overflowing_mul(self, rhs)\n-            }\n-\n-            #[cfg(not(bootstrap))] {\n-                intrinsics::wrapping_mul(self, rhs)\n-            }\n+            intrinsics::wrapping_mul(self, rhs)\n         }\n \n         doc_comment! {"}, {"sha": "e8f0561604aec9aedf51ba77da44493a192418bd", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -71,7 +71,6 @@ pub fn panic_fmt(fmt: fmt::Arguments<'_>, file_line_col: &(&'static str, u32, u3\n     }\n \n     // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n-    #[cfg_attr(bootstrap, allow(improper_ctypes))]\n     extern \"Rust\" {\n         #[lang = \"panic_impl\"]\n         fn panic_impl(pi: &PanicInfo<'_>) -> !;"}, {"sha": "5ec21e6d9286266d4ceb5561367ac3ef01ec1890", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -62,9 +62,8 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    #[cfg_attr(bootstrap, rustc_const_unstable(feature = \"const_slice_len\"))]\n     // SAFETY: const sound because we transmute out the length field as a usize (which it must be)\n-    #[cfg_attr(not(bootstrap), allow_internal_unstable(const_fn_union))]\n+    #[allow_internal_unstable(const_fn_union)]\n     pub const fn len(&self) -> usize {\n         unsafe {\n             crate::ptr::Repr { rust: self }.raw.len\n@@ -81,7 +80,6 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    #[cfg_attr(bootstrap, rustc_const_unstable(feature = \"const_slice_len\"))]\n     pub const fn is_empty(&self) -> bool {\n         self.len() == 0\n     }"}, {"sha": "ece61dde490fd5cb8a3d843448544bcd1106863a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -2090,7 +2090,6 @@ impl str {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    #[cfg_attr(bootstrap, rustc_const_unstable(feature = \"const_str_len\"))]\n     pub const fn len(&self) -> usize {\n         self.as_bytes().len()\n     }\n@@ -2110,7 +2109,6 @@ impl str {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg_attr(bootstrap, rustc_const_unstable(feature = \"const_str_len\"))]\n     pub const fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n@@ -2168,9 +2166,8 @@ impl str {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline(always)]\n-    #[cfg_attr(bootstrap, rustc_const_unstable(feature = \"const_str_as_bytes\"))]\n     // SAFETY: const sound because we transmute two types with the same layout\n-    #[cfg_attr(not(bootstrap), allow_internal_unstable(const_fn_union))]\n+    #[allow_internal_unstable(const_fn_union)]\n     pub const fn as_bytes(&self) -> &[u8] {\n         #[repr(C)]\n         union Slices<'a> {"}, {"sha": "d5cdc266acb6accbdb10bb8a76b05aa3bd73d4a8", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -227,7 +227,7 @@ pub mod token_stream {\n /// To quote `$` itself, use `$$`.\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n #[allow_internal_unstable(proc_macro_def_site)]\n-#[cfg_attr(not(bootstrap), rustc_builtin_macro)]\n+#[rustc_builtin_macro]\n pub macro quote ($($t:tt)*) { /* compiler built-in */ }\n \n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]"}, {"sha": "91fc004b893bae3b421219803829ca6d30f7e273", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -1103,7 +1103,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n \n pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n     visitor.visit_id(arm.hir_id);\n-    walk_list!(visitor, visit_pat, &arm.pats);\n+    visitor.visit_pat(&arm.pat);\n     if let Some(ref g) = arm.guard {\n         match g {\n             Guard::If(ref e) => visitor.visit_expr(e),"}, {"sha": "f861499cfe4180a0b40be157d1eea20d2aae66bf", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -97,7 +97,7 @@ pub struct LoweringContext<'a> {\n \n     trait_impls: BTreeMap<DefId, Vec<hir::HirId>>,\n \n-    modules: BTreeMap<NodeId, hir::ModuleItems>,\n+    modules: BTreeMap<hir::HirId, hir::ModuleItems>,\n \n     generator_kind: Option<hir::GeneratorKind>,\n \n@@ -141,7 +141,7 @@ pub struct LoweringContext<'a> {\n     /// vector.\n     in_scope_lifetimes: Vec<ParamName>,\n \n-    current_module: NodeId,\n+    current_module: hir::HirId,\n \n     type_def_lifetime_params: DefIdMap<usize>,\n \n@@ -262,7 +262,7 @@ pub fn lower_crate(\n         is_in_dyn_type: false,\n         anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n         type_def_lifetime_params: Default::default(),\n-        current_module: CRATE_NODE_ID,\n+        current_module: hir::CRATE_HIR_ID,\n         current_hir_id_owner: vec![(CRATE_DEF_INDEX, 0)],\n         item_local_id_counters: Default::default(),\n         node_id_to_hir_id: IndexVec::new(),\n@@ -434,35 +434,6 @@ impl<'a> LoweringContext<'a> {\n                 visit::walk_pat(self, p)\n             }\n \n-            // HACK(or_patterns; Centril | dlrobertson): Avoid creating\n-            // HIR  nodes for `PatKind::Or` for the top level of a `ast::Arm`.\n-            // This is a temporary hack that should go away once we push down\n-            // `arm.pats: HirVec<P<Pat>>` -> `arm.pat: P<Pat>` to HIR. // Centril\n-            fn visit_arm(&mut self, arm: &'tcx Arm) {\n-                match &arm.pat.node {\n-                    PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n-                    _ => self.visit_pat(&arm.pat),\n-                }\n-                walk_list!(self, visit_expr, &arm.guard);\n-                self.visit_expr(&arm.body);\n-                walk_list!(self, visit_attribute, &arm.attrs);\n-            }\n-\n-            // HACK(or_patterns; Centril | dlrobertson): Same as above. // Centril\n-            fn visit_expr(&mut self, e: &'tcx Expr) {\n-                if let ExprKind::Let(pat, scrutinee) = &e.node {\n-                    walk_list!(self, visit_attribute, e.attrs.iter());\n-                    match &pat.node {\n-                        PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n-                        _ => self.visit_pat(&pat),\n-                    }\n-                    self.visit_expr(scrutinee);\n-                    self.visit_expr_post(e);\n-                    return;\n-                }\n-                visit::walk_expr(self, e)\n-            }\n-\n             fn visit_item(&mut self, item: &'tcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n "}, {"sha": "90b6c9474acb02e0a6d3de017200ec71edad6556", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -247,14 +247,14 @@ impl LoweringContext<'_> {\n         // 4. The return type of the block is `bool` which seems like what the user wanted.\n         let scrutinee = self.lower_expr(scrutinee);\n         let then_arm = {\n-            let pat = self.lower_pat_top_hack(pat);\n+            let pat = self.lower_pat(pat);\n             let expr = self.expr_bool(span, true);\n             self.arm(pat, P(expr))\n         };\n         let else_arm = {\n             let pat = self.pat_wild(span);\n             let expr = self.expr_bool(span, false);\n-            self.arm(hir_vec![pat], P(expr))\n+            self.arm(pat, P(expr))\n         };\n         hir::ExprKind::Match(\n             P(scrutinee),\n@@ -278,15 +278,15 @@ impl LoweringContext<'_> {\n             None => (self.expr_block_empty(span), false),\n             Some(els) => (self.lower_expr(els), true),\n         };\n-        let else_arm = self.arm(hir_vec![else_pat], P(else_expr));\n+        let else_arm = self.arm(else_pat, P(else_expr));\n \n         // Handle then + scrutinee:\n         let then_expr = self.lower_block_expr(then);\n         let (then_pat, scrutinee, desugar) = match cond.node {\n             // `<pat> => <then>`:\n             ExprKind::Let(ref pat, ref scrutinee) => {\n                 let scrutinee = self.lower_expr(scrutinee);\n-                let pat = self.lower_pat_top_hack(pat);\n+                let pat = self.lower_pat(pat);\n                 (pat, scrutinee, hir::MatchSource::IfLetDesugar { contains_else_clause })\n             }\n             // `true => <then>`:\n@@ -303,7 +303,7 @@ impl LoweringContext<'_> {\n                 // let temporaries live outside of `cond`.\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n                 let pat = self.pat_bool(span, true);\n-                (hir_vec![pat], cond, hir::MatchSource::IfDesugar { contains_else_clause })\n+                (pat, cond, hir::MatchSource::IfDesugar { contains_else_clause })\n             }\n         };\n         let then_arm = self.arm(then_pat, P(then_expr));\n@@ -327,7 +327,7 @@ impl LoweringContext<'_> {\n         let else_arm = {\n             let else_pat = self.pat_wild(span);\n             let else_expr = self.expr_break(span, ThinVec::new());\n-            self.arm(hir_vec![else_pat], else_expr)\n+            self.arm(else_pat, else_expr)\n         };\n \n         // Handle then + scrutinee:\n@@ -343,7 +343,7 @@ impl LoweringContext<'_> {\n                 //     }\n                 //   }\n                 let scrutinee = self.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n-                let pat = self.lower_pat_top_hack(pat);\n+                let pat = self.lower_pat(pat);\n                 (pat, scrutinee, hir::MatchSource::WhileLetDesugar, hir::LoopSource::WhileLet)\n             }\n             _ => {\n@@ -371,7 +371,7 @@ impl LoweringContext<'_> {\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n                 // `true => <then>`:\n                 let pat = self.pat_bool(span, true);\n-                (hir_vec![pat], cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n+                (pat, cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n             }\n         };\n         let then_arm = self.arm(then_pat, P(then_expr));\n@@ -424,7 +424,7 @@ impl LoweringContext<'_> {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: self.lower_attrs(&arm.attrs),\n-            pats: self.lower_pat_top_hack(&arm.pat),\n+            pat: self.lower_pat(&arm.pat),\n             guard: match arm.guard {\n                 Some(ref x) => Some(hir::Guard::If(P(self.lower_expr(x)))),\n                 _ => None,\n@@ -434,16 +434,6 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n-    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n-    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n-    fn lower_pat_top_hack(&mut self, pat: &Pat) -> HirVec<P<hir::Pat>> {\n-        match pat.node {\n-            PatKind::Or(ref ps) => ps.iter().map(|x| self.lower_pat(x)).collect(),\n-            _ => hir_vec![self.lower_pat(pat)],\n-        }\n-    }\n-\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n@@ -592,7 +582,7 @@ impl LoweringContext<'_> {\n                 );\n                 P(this.expr(await_span, expr_break, ThinVec::new()))\n             });\n-            self.arm(hir_vec![ready_pat], break_x)\n+            self.arm(ready_pat, break_x)\n         };\n \n         // `::std::task::Poll::Pending => {}`\n@@ -603,7 +593,7 @@ impl LoweringContext<'_> {\n                 hir_vec![],\n             );\n             let empty_block = P(self.expr_block_empty(span));\n-            self.arm(hir_vec![pending_pat], empty_block)\n+            self.arm(pending_pat, empty_block)\n         };\n \n         let inner_match_stmt = {\n@@ -645,7 +635,7 @@ impl LoweringContext<'_> {\n         });\n \n         // mut pinned => loop { ... }\n-        let pinned_arm = self.arm(hir_vec![pinned_pat], loop_expr);\n+        let pinned_arm = self.arm(pinned_pat, loop_expr);\n \n         // match <expr> {\n         //     mut pinned => loop { .. }\n@@ -1079,15 +1069,15 @@ impl LoweringContext<'_> {\n                 ThinVec::new(),\n             ));\n             let some_pat = self.pat_some(pat.span, val_pat);\n-            self.arm(hir_vec![some_pat], assign)\n+            self.arm(some_pat, assign)\n         };\n \n         // `::std::option::Option::None => break`\n         let break_arm = {\n             let break_expr =\n                 self.with_loop_scope(e.id, |this| this.expr_break(e.span, ThinVec::new()));\n             let pat = self.pat_none(e.span);\n-            self.arm(hir_vec![pat], break_expr)\n+            self.arm(pat, break_expr)\n         };\n \n         // `mut iter`\n@@ -1158,7 +1148,7 @@ impl LoweringContext<'_> {\n         });\n \n         // `mut iter => { ... }`\n-        let iter_arm = self.arm(hir_vec![iter_pat], loop_expr);\n+        let iter_arm = self.arm(iter_pat, loop_expr);\n \n         // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n         let into_iter_expr = {\n@@ -1244,7 +1234,7 @@ impl LoweringContext<'_> {\n                 ThinVec::from(attrs.clone()),\n             ));\n             let ok_pat = self.pat_ok(span, val_pat);\n-            self.arm(hir_vec![ok_pat], val_expr)\n+            self.arm(ok_pat, val_expr)\n         };\n \n         // `Err(err) => #[allow(unreachable_code)]\n@@ -1279,7 +1269,7 @@ impl LoweringContext<'_> {\n             };\n \n             let err_pat = self.pat_err(try_span, err_local);\n-            self.arm(hir_vec![err_pat], ret_expr)\n+            self.arm(err_pat, ret_expr)\n         };\n \n         hir::ExprKind::Match(\n@@ -1474,14 +1464,11 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n-    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n-    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n-    fn arm(&mut self, pats: HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+    fn arm(&mut self, pat: P<hir::Pat>, expr: P<hir::Expr>) -> hir::Arm {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: hir_vec![],\n-            pats,\n+            pat,\n             guard: None,\n             span: expr.span,\n             body: expr,"}, {"sha": "5a8d5daaf09b89e80847cd1414df3b250eaa4d1b", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -45,14 +45,16 @@ impl<'tcx, 'interner> ItemLowerer<'tcx, 'interner> {\n \n impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n     fn visit_mod(&mut self, m: &'tcx Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n-        self.lctx.modules.insert(n, hir::ModuleItems {\n+        let hir_id = self.lctx.lower_node_id(n);\n+\n+        self.lctx.modules.insert(hir_id, hir::ModuleItems {\n             items: BTreeSet::new(),\n             trait_items: BTreeSet::new(),\n             impl_items: BTreeSet::new(),\n         });\n \n         let old = self.lctx.current_module;\n-        self.lctx.current_module = n;\n+        self.lctx.current_module = hir_id;\n         visit::walk_mod(self, m);\n         self.lctx.current_module = old;\n     }"}, {"sha": "b66c2ce1178a4aae1207c59003ca107a1ee94b26", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -10,7 +10,7 @@ pub fn check_crate(hir_map: &hir::map::Map<'_>) {\n     let errors = Lock::new(Vec::new());\n \n     par_iter(&hir_map.krate().modules).for_each(|(module_id, _)| {\n-        let local_def_id = hir_map.local_def_id_from_node_id(*module_id);\n+        let local_def_id = hir_map.local_def_id(*module_id);\n         hir_map.visit_item_likes_in_module(local_def_id, &mut OuterVisitor {\n             hir_map,\n             errors: &errors,"}, {"sha": "956cb36c6b1396b604dee2354ae55f1b517d7484", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -536,9 +536,7 @@ impl<'hir> Map<'hir> {\n         // in the expect_* calls the loops below\n         self.read(hir_id);\n \n-        let node_id = self.hir_to_node_id[&hir_id];\n-\n-        let module = &self.forest.krate.modules[&node_id];\n+        let module = &self.forest.krate.modules[&hir_id];\n \n         for id in &module.items {\n             visitor.visit_item(self.expect_item(*id));"}, {"sha": "6fdc126e216aa2d7f1ae0411b00b6c87e31a4d25", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 58, "deletions": 30, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -766,7 +766,7 @@ pub struct Crate {\n \n     /// A list of modules written out in the order in which they\n     /// appear in the crate. This includes the main crate module.\n-    pub modules: BTreeMap<NodeId, ModuleItems>,\n+    pub modules: BTreeMap<HirId, ModuleItems>,\n }\n \n impl Crate {\n@@ -882,44 +882,61 @@ impl fmt::Debug for Pat {\n \n impl Pat {\n     // FIXME(#19596) this is a workaround, but there should be a better way\n-    fn walk_<G>(&self, it: &mut G) -> bool\n-        where G: FnMut(&Pat) -> bool\n-    {\n+    fn walk_short_(&self, it: &mut impl FnMut(&Pat) -> bool) -> bool {\n         if !it(self) {\n             return false;\n         }\n \n-        match self.node {\n-            PatKind::Binding(.., Some(ref p)) => p.walk_(it),\n-            PatKind::Struct(_, ref fields, _) => {\n-                fields.iter().all(|field| field.pat.walk_(it))\n-            }\n-            PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) => {\n-                s.iter().all(|p| p.walk_(it))\n-            }\n-            PatKind::Or(ref pats) => pats.iter().all(|p| p.walk_(it)),\n-            PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n-                s.walk_(it)\n-            }\n-            PatKind::Slice(ref before, ref slice, ref after) => {\n+        use PatKind::*;\n+        match &self.node {\n+            Wild | Lit(_) | Range(..) | Binding(.., None) | Path(_) => true,\n+            Box(s) | Ref(s, _) | Binding(.., Some(s)) => s.walk_short_(it),\n+            Struct(_, fields, _) => fields.iter().all(|field| field.pat.walk_short_(it)),\n+            TupleStruct(_, s, _) | Tuple(s, _) | Or(s) => s.iter().all(|p| p.walk_short_(it)),\n+            Slice(before, slice, after) => {\n                 before.iter()\n                       .chain(slice.iter())\n                       .chain(after.iter())\n-                      .all(|p| p.walk_(it))\n+                      .all(|p| p.walk_short_(it))\n             }\n-            PatKind::Wild |\n-            PatKind::Lit(_) |\n-            PatKind::Range(..) |\n-            PatKind::Binding(..) |\n-            PatKind::Path(_) => {\n-                true\n+        }\n+    }\n+\n+    /// Walk the pattern in left-to-right order,\n+    /// short circuiting (with `.all(..)`) if `false` is returned.\n+    ///\n+    /// Note that when visiting e.g. `Tuple(ps)`,\n+    /// if visiting `ps[0]` returns `false`,\n+    /// then `ps[1]` will not be visited.\n+    pub fn walk_short(&self, mut it: impl FnMut(&Pat) -> bool) -> bool {\n+        self.walk_short_(&mut it)\n+    }\n+\n+    // FIXME(#19596) this is a workaround, but there should be a better way\n+    fn walk_(&self, it: &mut impl FnMut(&Pat) -> bool) {\n+        if !it(self) {\n+            return;\n+        }\n+\n+        use PatKind::*;\n+        match &self.node {\n+            Wild | Lit(_) | Range(..) | Binding(.., None) | Path(_) => {},\n+            Box(s) | Ref(s, _) | Binding(.., Some(s)) => s.walk_(it),\n+            Struct(_, fields, _) => fields.iter().for_each(|field| field.pat.walk_(it)),\n+            TupleStruct(_, s, _) | Tuple(s, _) | Or(s) => s.iter().for_each(|p| p.walk_(it)),\n+            Slice(before, slice, after) => {\n+                before.iter()\n+                      .chain(slice.iter())\n+                      .chain(after.iter())\n+                      .for_each(|p| p.walk_(it))\n             }\n         }\n     }\n \n-    pub fn walk<F>(&self, mut it: F) -> bool\n-        where F: FnMut(&Pat) -> bool\n-    {\n+    /// Walk the pattern in left-to-right order.\n+    ///\n+    /// If `it(pat)` returns `false`, the children are not visited.\n+    pub fn walk(&self, mut it: impl FnMut(&Pat) -> bool) {\n         self.walk_(&mut it)\n     }\n }\n@@ -1259,21 +1276,32 @@ pub struct Local {\n }\n \n /// Represents a single arm of a `match` expression, e.g.\n-/// `<pats> (if <guard>) => <body>`.\n+/// `<pat> (if <guard>) => <body>`.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Arm {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     pub span: Span,\n     pub attrs: HirVec<Attribute>,\n-    /// Multiple patterns can be combined with `|`\n-    pub pats: HirVec<P<Pat>>,\n+    /// If this pattern and the optional guard matches, then `body` is evaluated.\n+    pub pat: P<Pat>,\n     /// Optional guard clause.\n     pub guard: Option<Guard>,\n     /// The expression the arm evaluates to if this arm matches.\n     pub body: P<Expr>,\n }\n \n+impl Arm {\n+    // HACK(or_patterns; Centril | dlrobertson): Remove this and\n+    // correctly handle each case in which this method is used.\n+    pub fn top_pats_hack(&self) -> &[P<Pat>] {\n+        match &self.pat.node {\n+            PatKind::Or(pats) => pats,\n+            _ => std::slice::from_ref(&self.pat),\n+        }\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Guard {\n     If(P<Expr>),"}, {"sha": "118e168f877678eb519d6f5b380429f2809c7a28", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 58, "deletions": 57, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -66,9 +66,7 @@ impl hir::Pat {\n \n     /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n     /// `match foo() { Some(a) => (), None => () }`\n-    pub fn each_binding<F>(&self, mut f: F)\n-        where F: FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident),\n-    {\n+    pub fn each_binding(&self, mut f: impl FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident)) {\n         self.walk(|p| {\n             if let PatKind::Binding(binding_mode, _, ident, _) = p.node {\n                 f(binding_mode, p.hir_id, p.span, ident);\n@@ -77,35 +75,57 @@ impl hir::Pat {\n         });\n     }\n \n+    /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n+    /// `match foo() { Some(a) => (), None => () }`.\n+    ///\n+    /// When encountering an or-pattern `p_0 | ... | p_n` only `p_0` will be visited.\n+    pub fn each_binding_or_first(\n+        &self,\n+        f: &mut impl FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident),\n+    ) {\n+        self.walk(|p| match &p.node {\n+            PatKind::Or(ps) => {\n+                ps[0].each_binding_or_first(f);\n+                false\n+            },\n+            PatKind::Binding(bm,  _, ident, _) => {\n+                f(*bm, p.hir_id, p.span, *ident);\n+                true\n+            }\n+            _ => true,\n+        })\n+    }\n+\n     /// Checks if the pattern contains any patterns that bind something to\n     /// an ident, e.g., `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n     pub fn contains_bindings(&self) -> bool {\n-        let mut contains_bindings = false;\n-        self.walk(|p| {\n-            if let PatKind::Binding(..) = p.node {\n-                contains_bindings = true;\n-                false // there's at least one binding, can short circuit now.\n-            } else {\n-                true\n-            }\n-        });\n-        contains_bindings\n+        self.satisfies(|p| match p.node {\n+            PatKind::Binding(..) => true,\n+            _ => false,\n+        })\n     }\n \n     /// Checks if the pattern contains any patterns that bind something to\n     /// an ident or wildcard, e.g., `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n     pub fn contains_bindings_or_wild(&self) -> bool {\n-        let mut contains_bindings = false;\n-        self.walk(|p| {\n-            match p.node {\n-                PatKind::Binding(..) | PatKind::Wild => {\n-                    contains_bindings = true;\n-                    false // there's at least one binding/wildcard, can short circuit now.\n-                }\n-                _ => true\n+        self.satisfies(|p| match p.node {\n+            PatKind::Binding(..) | PatKind::Wild => true,\n+            _ => false,\n+        })\n+    }\n+\n+    /// Checks if the pattern satisfies the given predicate on some sub-pattern.\n+    fn satisfies(&self, pred: impl Fn(&Self) -> bool) -> bool {\n+        let mut satisfies = false;\n+        self.walk_short(|p| {\n+            if pred(p) {\n+                satisfies = true;\n+                false // Found one, can short circuit now.\n+            } else {\n+                true\n             }\n         });\n-        contains_bindings\n+        satisfies\n     }\n \n     pub fn simple_ident(&self) -> Option<ast::Ident> {\n@@ -119,20 +139,20 @@ impl hir::Pat {\n     /// Returns variants that are necessary to exist for the pattern to match.\n     pub fn necessary_variants(&self) -> Vec<DefId> {\n         let mut variants = vec![];\n-        self.walk(|p| {\n-            match p.node {\n-                PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n-                PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n-                PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n-                    match path.res {\n-                        Res::Def(DefKind::Variant, id) => variants.push(id),\n-                        Res::Def(DefKind::Ctor(CtorOf::Variant, ..), id) => variants.push(id),\n-                        _ => ()\n-                    }\n+        self.walk(|p| match &p.node {\n+            PatKind::Or(_) => false,\n+            PatKind::Path(hir::QPath::Resolved(_, path)) |\n+            PatKind::TupleStruct(hir::QPath::Resolved(_, path), ..) |\n+            PatKind::Struct(hir::QPath::Resolved(_, path), ..) => {\n+                if let Res::Def(DefKind::Variant, id)\n+                    | Res::Def(DefKind::Ctor(CtorOf::Variant, ..), id)\n+                    = path.res\n+                {\n+                    variants.push(id);\n                 }\n-                _ => ()\n+                true\n             }\n-            true\n+            _ => true,\n         });\n         variants.sort();\n         variants.dedup();\n@@ -148,33 +168,14 @@ impl hir::Pat {\n         let mut result = None;\n         self.each_binding(|annotation, _, _, _| {\n             match annotation {\n-                hir::BindingAnnotation::Ref => {\n-                    match result {\n-                        None | Some(hir::MutImmutable) => result = Some(hir::MutImmutable),\n-                        _ => (),\n-                    }\n+                hir::BindingAnnotation::Ref => match result {\n+                    None | Some(hir::MutImmutable) => result = Some(hir::MutImmutable),\n+                    _ => {}\n                 }\n                 hir::BindingAnnotation::RefMut => result = Some(hir::MutMutable),\n-                _ => (),\n+                _ => {}\n             }\n         });\n         result\n     }\n }\n-\n-impl hir::Arm {\n-    /// Checks if the patterns for this arm contain any `ref` or `ref mut`\n-    /// bindings, and if yes whether its containing mutable ones or just immutables ones.\n-    pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n-        // FIXME(tschottdorf): contains_explicit_ref_binding() must be removed\n-        // for #42640 (default match binding modes).\n-        //\n-        // See #44848.\n-        self.pats.iter()\n-                 .filter_map(|pat| pat.contains_explicit_ref_binding())\n-                 .max_by_key(|m| match *m {\n-                    hir::MutMutable => 1,\n-                    hir::MutImmutable => 0,\n-                 })\n-    }\n-}"}, {"sha": "3cbc9ebec0ad8c10de64894a26e5c2430fb799a7", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -1790,16 +1790,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Arm(arm));\n         self.ibox(0);\n         self.print_outer_attributes(&arm.attrs);\n-        let mut first = true;\n-        for p in &arm.pats {\n-            if first {\n-                first = false;\n-            } else {\n-                self.s.space();\n-                self.word_space(\"|\");\n-            }\n-            self.print_pat(&p);\n-        }\n+        self.print_pat(&arm.pat);\n         self.s.space();\n         if let Some(ref g) = arm.guard {\n             match g {"}, {"sha": "f6063875ac40284aa72f09bcd17390fe96341848", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -1510,7 +1510,7 @@ pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n         time(tcx.sess, \"module lints\", || {\n             // Run per-module lints\n             par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n-                tcx.ensure().lint_mod(tcx.hir().local_def_id_from_node_id(module));\n+                tcx.ensure().lint_mod(tcx.hir().local_def_id(module));\n             });\n         });\n     });"}, {"sha": "2746794e2a2c1f78508e58ef275d1b3e63e8c185", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -259,19 +259,13 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n-        if arm.pats.len() == 1 {\n-            let variants = arm.pats[0].necessary_variants();\n-\n-            // Inside the body, ignore constructions of variants\n-            // necessary for the pattern to match. Those construction sites\n-            // can't be reached unless the variant is constructed elsewhere.\n-            let len = self.ignore_variant_stack.len();\n-            self.ignore_variant_stack.extend_from_slice(&variants);\n-            intravisit::walk_arm(self, arm);\n-            self.ignore_variant_stack.truncate(len);\n-        } else {\n-            intravisit::walk_arm(self, arm);\n-        }\n+        // Inside the body, ignore constructions of variants\n+        // necessary for the pattern to match. Those construction sites\n+        // can't be reached unless the variant is constructed elsewhere.\n+        let len = self.ignore_variant_stack.len();\n+        self.ignore_variant_stack.extend(arm.pat.necessary_variants());\n+        intravisit::walk_arm(self, arm);\n+        self.ignore_variant_stack.truncate(len);\n     }\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {"}, {"sha": "a3110c000fb2223de06fc2c2aca4668157e36d46", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -779,16 +779,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm) -> TrackMatchMode {\n         let mut mode = Unknown;\n-        for pat in &arm.pats {\n-            self.determine_pat_move_mode(discr_cmt.clone(), &pat, &mut mode);\n-        }\n+        self.determine_pat_move_mode(discr_cmt.clone(), &arm.pat, &mut mode);\n         mode\n     }\n \n     fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm, mode: MatchMode) {\n-        for pat in &arm.pats {\n-            self.walk_pat(discr_cmt.clone(), &pat, mode);\n-        }\n+        self.walk_pat(discr_cmt.clone(), &arm.pat, mode);\n \n         if let Some(hir::Guard::If(ref e)) = arm.guard {\n             self.consume_expr(e)"}, {"sha": "9f6611712a8aa9328b31d4ffd1ee8dc0c8bc7ef6", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 125, "deletions": 194, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -96,7 +96,11 @@\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n+use crate::hir;\n+use crate::hir::{Expr, HirId};\n use crate::hir::def::*;\n+use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n use crate::hir::Node;\n use crate::hir::ptr::P;\n use crate::ty::{self, TyCtxt};\n@@ -105,20 +109,16 @@ use crate::lint;\n use crate::util::nodemap::{HirIdMap, HirIdSet};\n \n use errors::Applicability;\n-use std::collections::{BTreeMap, VecDeque};\n+use rustc_data_structures::fx::FxIndexMap;\n+use std::collections::VecDeque;\n use std::{fmt, u32};\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::symbol::{kw, sym};\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n-use crate::hir;\n-use crate::hir::{Expr, HirId};\n-use crate::hir::def_id::DefId;\n-use crate::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n-\n #[derive(Copy, Clone, PartialEq)]\n struct Variable(u32);\n \n@@ -404,34 +404,29 @@ fn visit_fn<'tcx>(\n     lsets.warn_about_unused_args(body, entry_ln);\n }\n \n-fn add_from_pat<'tcx>(ir: &mut IrMaps<'tcx>, pat: &P<hir::Pat>) {\n+fn add_from_pat(ir: &mut IrMaps<'_>, pat: &P<hir::Pat>) {\n     // For struct patterns, take note of which fields used shorthand\n     // (`x` rather than `x: x`).\n     let mut shorthand_field_ids = HirIdSet::default();\n     let mut pats = VecDeque::new();\n     pats.push_back(pat);\n     while let Some(pat) = pats.pop_front() {\n         use crate::hir::PatKind::*;\n-        match pat.node {\n-            Binding(_, _, _, ref inner_pat) => {\n+        match &pat.node {\n+            Binding(.., inner_pat) => {\n                 pats.extend(inner_pat.iter());\n             }\n-            Struct(_, ref fields, _) => {\n-                for field in fields {\n-                    if field.is_shorthand {\n-                        shorthand_field_ids.insert(field.pat.hir_id);\n-                    }\n-                }\n+            Struct(_, fields, _) => {\n+                let ids = fields.iter().filter(|f| f.is_shorthand).map(|f| f.pat.hir_id);\n+                shorthand_field_ids.extend(ids);\n             }\n-            Ref(ref inner_pat, _) |\n-            Box(ref inner_pat) => {\n+            Ref(inner_pat, _) | Box(inner_pat) => {\n                 pats.push_back(inner_pat);\n             }\n-            TupleStruct(_, ref inner_pats, _) |\n-            Tuple(ref inner_pats, _) => {\n+            TupleStruct(_, inner_pats, _) | Tuple(inner_pats, _) | Or(inner_pats) => {\n                 pats.extend(inner_pats.iter());\n             }\n-            Slice(ref pre_pats, ref inner_pat, ref post_pats) => {\n+            Slice(pre_pats, inner_pat, post_pats) => {\n                 pats.extend(pre_pats.iter());\n                 pats.extend(inner_pat.iter());\n                 pats.extend(post_pats.iter());\n@@ -440,7 +435,7 @@ fn add_from_pat<'tcx>(ir: &mut IrMaps<'tcx>, pat: &P<hir::Pat>) {\n         }\n     }\n \n-    pat.each_binding(|_bm, hir_id, _sp, ident| {\n+    pat.each_binding(|_, hir_id, _, ident| {\n         ir.add_live_node_for_node(hir_id, VarDefNode(ident.span));\n         ir.add_variable(Local(LocalInfo {\n             id: hir_id,\n@@ -456,9 +451,7 @@ fn visit_local<'tcx>(ir: &mut IrMaps<'tcx>, local: &'tcx hir::Local) {\n }\n \n fn visit_arm<'tcx>(ir: &mut IrMaps<'tcx>, arm: &'tcx hir::Arm) {\n-    for pat in &arm.pats {\n-        add_from_pat(ir, pat);\n-    }\n+    add_from_pat(ir, &arm.pat);\n     intravisit::walk_arm(ir, arm);\n }\n \n@@ -734,35 +727,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.ir.variable(hir_id, span)\n     }\n \n-    fn pat_bindings<F>(&mut self, pat: &hir::Pat, mut f: F) where\n-        F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, HirId),\n-    {\n-        pat.each_binding(|_bm, hir_id, sp, n| {\n-            let ln = self.live_node(hir_id, sp);\n-            let var = self.variable(hir_id, n.span);\n-            f(self, ln, var, n.span, hir_id);\n-        })\n-    }\n-\n-    fn arm_pats_bindings<F>(&mut self, pat: Option<&hir::Pat>, f: F) where\n-        F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, HirId),\n-    {\n-        if let Some(pat) = pat {\n-            self.pat_bindings(pat, f);\n-        }\n-    }\n-\n-    fn define_bindings_in_pat(&mut self, pat: &hir::Pat, succ: LiveNode)\n-                              -> LiveNode {\n-        self.define_bindings_in_arm_pats(Some(pat), succ)\n-    }\n-\n-    fn define_bindings_in_arm_pats(&mut self, pat: Option<&hir::Pat>, succ: LiveNode)\n-                                   -> LiveNode {\n-        let mut succ = succ;\n-        self.arm_pats_bindings(pat, |this, ln, var, _sp, _id| {\n-            this.init_from_succ(ln, succ);\n-            this.define(ln, var);\n+    fn define_bindings_in_pat(&mut self, pat: &hir::Pat, mut succ: LiveNode) -> LiveNode {\n+        // In an or-pattern, only consider the first pattern; any later patterns\n+        // must have the same bindings, and we also consider the first pattern\n+        // to be the \"authoritative\" set of ids.\n+        pat.each_binding_or_first(&mut |_, hir_id, pat_sp, ident| {\n+            let ln = self.live_node(hir_id, pat_sp);\n+            let var = self.variable(hir_id, ident.span);\n+            self.init_from_succ(ln, succ);\n+            self.define(ln, var);\n             succ = ln;\n         });\n         succ\n@@ -1076,12 +1049,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                         arm.guard.as_ref().map(|hir::Guard::If(e)| &**e),\n                         body_succ\n                     );\n-                    // only consider the first pattern; any later patterns must have\n-                    // the same bindings, and we also consider the first pattern to be\n-                    // the \"authoritative\" set of ids\n-                    let arm_succ =\n-                        self.define_bindings_in_arm_pats(arm.pats.first().map(|p| &**p),\n-                                                         guard_succ);\n+                    let arm_succ = self.define_bindings_in_pat(&arm.pat, guard_succ);\n                     self.merge_from_succ(ln, arm_succ, first_merge);\n                     first_merge = false;\n                 };\n@@ -1388,74 +1356,36 @@ impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_local(&mut self, l: &'tcx hir::Local) {\n-        check_local(self, l);\n-    }\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n-        check_expr(self, ex);\n-    }\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n-        check_arm(self, a);\n-    }\n-}\n+    fn visit_local(&mut self, local: &'tcx hir::Local) {\n+        self.check_unused_vars_in_pat(&local.pat, None, |spans, hir_id, ln, var| {\n+            if local.init.is_some() {\n+                self.warn_about_dead_assign(spans, hir_id, ln, var);\n+            }\n+        });\n \n-fn check_local<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, local: &'tcx hir::Local) {\n-    match local.init {\n-        Some(_) => {\n-            this.warn_about_unused_or_dead_vars_in_pat(&local.pat);\n-        },\n-        None => {\n-            this.pat_bindings(&local.pat, |this, ln, var, sp, id| {\n-                let span = local.pat.simple_ident().map_or(sp, |ident| ident.span);\n-                this.warn_about_unused(vec![span], id, ln, var);\n-            })\n-        }\n+        intravisit::walk_local(self, local);\n     }\n \n-    intravisit::walk_local(this, local);\n-}\n-\n-fn check_arm<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, arm: &'tcx hir::Arm) {\n-    // Only consider the variable from the first pattern; any later patterns must have\n-    // the same bindings, and we also consider the first pattern to be the \"authoritative\" set of\n-    // ids. However, we should take the spans of variables with the same name from the later\n-    // patterns so the suggestions to prefix with underscores will apply to those too.\n-    let mut vars: BTreeMap<String, (LiveNode, Variable, HirId, Vec<Span>)> = Default::default();\n-\n-    for pat in &arm.pats {\n-        this.arm_pats_bindings(Some(&*pat), |this, ln, var, sp, id| {\n-            let name = this.ir.variable_name(var);\n-            vars.entry(name)\n-                .and_modify(|(.., spans)| {\n-                    spans.push(sp);\n-                })\n-                .or_insert_with(|| {\n-                    (ln, var, id, vec![sp])\n-                });\n-        });\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n+        check_expr(self, ex);\n     }\n \n-    for (_, (ln, var, id, spans)) in vars {\n-        this.warn_about_unused(spans, id, ln, var);\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n+        self.check_unused_vars_in_pat(&arm.pat, None, |_, _, _, _| {});\n+        intravisit::walk_arm(self, arm);\n     }\n-\n-    intravisit::walk_arm(this, arm);\n }\n \n-fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n+fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n         hir::ExprKind::Assign(ref l, _) => {\n             this.check_place(&l);\n-\n-            intravisit::walk_expr(this, expr);\n         }\n \n         hir::ExprKind::AssignOp(_, ref l, _) => {\n             if !this.tables.is_method_call(expr) {\n                 this.check_place(&l);\n             }\n-\n-            intravisit::walk_expr(this, expr);\n         }\n \n         hir::ExprKind::InlineAsm(ref ia, ref outputs, ref inputs) => {\n@@ -1470,8 +1400,6 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n                 }\n                 this.visit_expr(output);\n             }\n-\n-            intravisit::walk_expr(this, expr);\n         }\n \n         // no correctness conditions related to liveness\n@@ -1484,13 +1412,13 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n         hir::ExprKind::Lit(_) | hir::ExprKind::Block(..) | hir::ExprKind::AddrOf(..) |\n         hir::ExprKind::Struct(..) | hir::ExprKind::Repeat(..) |\n         hir::ExprKind::Closure(..) | hir::ExprKind::Path(_) | hir::ExprKind::Yield(..) |\n-        hir::ExprKind::Box(..) | hir::ExprKind::Type(..) | hir::ExprKind::Err => {\n-            intravisit::walk_expr(this, expr);\n-        }\n+        hir::ExprKind::Box(..) | hir::ExprKind::Type(..) | hir::ExprKind::Err => {}\n     }\n+\n+    intravisit::walk_expr(this, expr);\n }\n \n-impl<'a, 'tcx> Liveness<'a, 'tcx> {\n+impl<'tcx> Liveness<'_, 'tcx> {\n     fn check_place(&mut self, expr: &'tcx Expr) {\n         match expr.node {\n             hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n@@ -1503,7 +1431,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                         // as being used.\n                         let ln = self.live_node(expr.hir_id, expr.span);\n                         let var = self.variable(var_hid, expr.span);\n-                        self.warn_about_dead_assign(expr.span, expr.hir_id, ln, var);\n+                        self.warn_about_dead_assign(vec![expr.span], expr.hir_id, ln, var);\n                     }\n                 }\n             }\n@@ -1525,109 +1453,112 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn warn_about_unused_args(&self, body: &hir::Body, entry_ln: LiveNode) {\n-        for param in &body.params {\n-            param.pat.each_binding(|_bm, hir_id, _, ident| {\n-                let sp = ident.span;\n-                let var = self.variable(hir_id, sp);\n-                // Ignore unused self.\n-                if ident.name != kw::SelfLower {\n-                    if !self.warn_about_unused(vec![sp], hir_id, entry_ln, var) {\n-                        if self.live_on_entry(entry_ln, var).is_none() {\n-                            self.report_dead_assign(hir_id, sp, var, true);\n-                        }\n-                    }\n+        for p in &body.params {\n+            self.check_unused_vars_in_pat(&p.pat, Some(entry_ln), |spans, hir_id, ln, var| {\n+                if self.live_on_entry(ln, var).is_none() {\n+                    self.report_dead_assign(hir_id, spans, var, true);\n                 }\n-            })\n+            });\n         }\n     }\n \n-    fn warn_about_unused_or_dead_vars_in_pat(&mut self, pat: &hir::Pat) {\n-        self.pat_bindings(pat, |this, ln, var, sp, id| {\n-            if !this.warn_about_unused(vec![sp], id, ln, var) {\n-                this.warn_about_dead_assign(sp, id, ln, var);\n+    fn check_unused_vars_in_pat(\n+        &self,\n+        pat: &hir::Pat,\n+        entry_ln: Option<LiveNode>,\n+        on_used_on_entry: impl Fn(Vec<Span>, HirId, LiveNode, Variable),\n+    ) {\n+        // In an or-pattern, only consider the variable; any later patterns must have the same\n+        // bindings, and we also consider the first pattern to be the \"authoritative\" set of ids.\n+        // However, we should take the spans of variables with the same name from the later\n+        // patterns so the suggestions to prefix with underscores will apply to those too.\n+        let mut vars: FxIndexMap<String, (LiveNode, Variable, HirId, Vec<Span>)> = <_>::default();\n+\n+        pat.each_binding(|_, hir_id, pat_sp, ident| {\n+            let ln = entry_ln.unwrap_or_else(|| self.live_node(hir_id, pat_sp));\n+            let var = self.variable(hir_id, ident.span);\n+            vars.entry(self.ir.variable_name(var))\n+                .and_modify(|(.., spans)| spans.push(ident.span))\n+                .or_insert_with(|| (ln, var, hir_id, vec![ident.span]));\n+        });\n+\n+        for (_, (ln, var, id, spans)) in vars {\n+            if self.used_on_entry(ln, var) {\n+                on_used_on_entry(spans, id, ln, var);\n+            } else {\n+                self.report_unused(spans, id, ln, var);\n             }\n-        })\n+        }\n     }\n \n-    fn warn_about_unused(&self,\n-                         spans: Vec<Span>,\n-                         hir_id: HirId,\n-                         ln: LiveNode,\n-                         var: Variable)\n-                         -> bool {\n-        if !self.used_on_entry(ln, var) {\n-            let r = self.should_warn(var);\n-            if let Some(name) = r {\n-                // annoying: for parameters in funcs like `fn(x: i32)\n-                // {ret}`, there is only one node, so asking about\n-                // assigned_on_exit() is not meaningful.\n-                let is_assigned = if ln == self.s.exit_ln {\n-                    false\n-                } else {\n-                    self.assigned_on_exit(ln, var).is_some()\n-                };\n+    fn report_unused(&self, spans: Vec<Span>, hir_id: HirId, ln: LiveNode, var: Variable) {\n+        if let Some(name) = self.should_warn(var).filter(|name| name != \"self\") {\n+            // annoying: for parameters in funcs like `fn(x: i32)\n+            // {ret}`, there is only one node, so asking about\n+            // assigned_on_exit() is not meaningful.\n+            let is_assigned = if ln == self.s.exit_ln {\n+                false\n+            } else {\n+                self.assigned_on_exit(ln, var).is_some()\n+            };\n \n-                if is_assigned {\n-                    self.ir.tcx.lint_hir_note(\n-                        lint::builtin::UNUSED_VARIABLES,\n-                        hir_id,\n-                        spans,\n-                        &format!(\"variable `{}` is assigned to, but never used\", name),\n-                        &format!(\"consider using `_{}` instead\", name),\n-                    );\n-                } else if name != \"self\" {\n-                    let mut err = self.ir.tcx.struct_span_lint_hir(\n-                        lint::builtin::UNUSED_VARIABLES,\n-                        hir_id,\n-                        spans.clone(),\n-                        &format!(\"unused variable: `{}`\", name),\n-                    );\n+            if is_assigned {\n+                self.ir.tcx.lint_hir_note(\n+                    lint::builtin::UNUSED_VARIABLES,\n+                    hir_id,\n+                    spans,\n+                    &format!(\"variable `{}` is assigned to, but never used\", name),\n+                    &format!(\"consider using `_{}` instead\", name),\n+                );\n+            } else {\n+                let mut err = self.ir.tcx.struct_span_lint_hir(\n+                    lint::builtin::UNUSED_VARIABLES,\n+                    hir_id,\n+                    spans.clone(),\n+                    &format!(\"unused variable: `{}`\", name),\n+                );\n+\n+                if self.ir.variable_is_shorthand(var) {\n+                    if let Node::Binding(pat) = self.ir.tcx.hir().get(hir_id) {\n+                        // Handle `ref` and `ref mut`.\n+                        let spans = spans.iter()\n+                            .map(|_span| (pat.span, format!(\"{}: _\", name)))\n+                            .collect();\n \n-                    if self.ir.variable_is_shorthand(var) {\n-                        if let Node::Binding(pat) = self.ir.tcx.hir().get(hir_id) {\n-                            // Handle `ref` and `ref mut`.\n-                            let spans = spans.iter()\n-                                .map(|_span| (pat.span, format!(\"{}: _\", name)))\n-                                .collect();\n-\n-                            err.multipart_suggestion(\n-                                \"try ignoring the field\",\n-                                spans,\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    } else {\n                         err.multipart_suggestion(\n-                            \"consider prefixing with an underscore\",\n-                            spans.iter().map(|span| (*span, format!(\"_{}\", name))).collect(),\n+                            \"try ignoring the field\",\n+                            spans,\n                             Applicability::MachineApplicable,\n                         );\n                     }\n-\n-                    err.emit()\n+                } else {\n+                    err.multipart_suggestion(\n+                        \"consider prefixing with an underscore\",\n+                        spans.iter().map(|span| (*span, format!(\"_{}\", name))).collect(),\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n+\n+                err.emit()\n             }\n-            true\n-        } else {\n-            false\n         }\n     }\n \n-    fn warn_about_dead_assign(&self, sp: Span, hir_id: HirId, ln: LiveNode, var: Variable) {\n+    fn warn_about_dead_assign(&self, spans: Vec<Span>, hir_id: HirId, ln: LiveNode, var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n-            self.report_dead_assign(hir_id, sp, var, false);\n+            self.report_dead_assign(hir_id, spans, var, false);\n         }\n     }\n \n-    fn report_dead_assign(&self, hir_id: HirId, sp: Span, var: Variable, is_argument: bool) {\n+    fn report_dead_assign(&self, hir_id: HirId, spans: Vec<Span>, var: Variable, is_param: bool) {\n         if let Some(name) = self.should_warn(var) {\n-            if is_argument {\n-                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n+            if is_param {\n+                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, spans,\n                 &format!(\"value passed to `{}` is never read\", name))\n                 .help(\"maybe it is overwritten before being read?\")\n                 .emit();\n             } else {\n-                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n+                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, spans,\n                 &format!(\"value assigned to `{}` is never read\", name))\n                 .help(\"maybe it is overwritten before being read?\")\n                 .emit();"}, {"sha": "a25ef21d6978f782b343f5ace5cc921847d91189", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -974,7 +974,7 @@ pub struct FreeRegionInfo {\n ///\n /// [rustc guide]: https://rust-lang.github.io/rustc-guide/ty.html\n #[derive(Copy, Clone)]\n-#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"TyCtxt\")]\n+#[rustc_diagnostic_item = \"TyCtxt\"]\n pub struct TyCtxt<'tcx> {\n     gcx: &'tcx GlobalCtxt<'tcx>,\n }"}, {"sha": "61483fa8a498e98eced21a1674ee30c5d3c51701", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -581,7 +581,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::TyS<'tcx> {\n     }\n }\n \n-#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"Ty\")]\n+#[rustc_diagnostic_item = \"Ty\"]\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n impl<'tcx> rustc_serialize::UseSpecializedEncodable for Ty<'tcx> {}"}, {"sha": "036f41a4043d4892b449b83f74013b037534bea6", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -86,7 +86,7 @@ impl BoundRegion {\n /// AST structure in `libsyntax/ast.rs` as well.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n          RustcEncodable, RustcDecodable, HashStable, Debug)]\n-#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"TyKind\")]\n+#[rustc_diagnostic_item = \"TyKind\"]\n pub enum TyKind<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n     Bool,"}, {"sha": "e2c5de648a2766f93b63e2716aae7244b5848481", "filename": "src/librustc_ast_borrowck/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -390,7 +390,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             // patterns and the guard (if there is one) in the arm.\n             let bindings_exit = self.add_dummy_node(&[]);\n \n-            for pat in &arm.pats {\n+            for pat in arm.top_pats_hack() {\n                 // Visit the pattern, coming from the discriminant exit\n                 let mut pat_exit = self.pat(&pat, discr_exit);\n "}, {"sha": "37b33466d70b83c22466c4878005508f760b6bec", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -905,10 +905,10 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n             });\n         }, {\n             par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n-                tcx.ensure().check_mod_loops(tcx.hir().local_def_id_from_node_id(module));\n-                tcx.ensure().check_mod_attrs(tcx.hir().local_def_id_from_node_id(module));\n-                tcx.ensure().check_mod_unstable_api_usage(\n-                    tcx.hir().local_def_id_from_node_id(module));\n+                let local_def_id = tcx.hir().local_def_id(module);\n+                tcx.ensure().check_mod_loops(local_def_id);\n+                tcx.ensure().check_mod_attrs(local_def_id);\n+                tcx.ensure().check_mod_unstable_api_usage(local_def_id);\n             });\n         });\n     });\n@@ -931,9 +931,10 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n                     // \"not all control paths return a value\" is reported here.\n                     //\n                     // maybe move the check to a MIR pass?\n-                    tcx.ensure().check_mod_liveness(tcx.hir().local_def_id_from_node_id(module));\n+                    let local_def_id = tcx.hir().local_def_id(module);\n \n-                    tcx.ensure().check_mod_intrinsics(tcx.hir().local_def_id_from_node_id(module));\n+                    tcx.ensure().check_mod_liveness(local_def_id);\n+                    tcx.ensure().check_mod_intrinsics(local_def_id);\n                 });\n             });\n         });\n@@ -993,7 +994,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n         }, {\n             time(sess, \"privacy checking modules\", || {\n                 par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n-                    tcx.ensure().check_mod_privacy(tcx.hir().local_def_id_from_node_id(module));\n+                    tcx.ensure().check_mod_privacy(tcx.hir().local_def_id(module));\n                 });\n             });\n         });"}, {"sha": "5f1bd3e9115ca5c05cb201e8c8b807dad377fb56", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Step 2. Create the otherwise and prebinding blocks.\n \n         // create binding start block for link them by false edges\n-        let candidate_count = arms.iter().map(|c| c.patterns.len()).sum::<usize>();\n+        let candidate_count = arms.iter().map(|c| c.top_pats_hack().len()).sum::<usize>();\n         let pre_binding_blocks: Vec<_> = (0..candidate_count)\n             .map(|_| self.cfg.start_new_block())\n             .collect();\n@@ -159,7 +159,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .map(|arm| {\n                 let arm_has_guard = arm.guard.is_some();\n                 match_has_guard |= arm_has_guard;\n-                let arm_candidates: Vec<_> = arm.patterns\n+                let arm_candidates: Vec<_> = arm.top_pats_hack()\n                     .iter()\n                     .zip(candidate_pre_binding_blocks.by_ref())\n                     .map(\n@@ -238,7 +238,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let scope = this.declare_bindings(\n                     None,\n                     arm.span,\n-                    &arm.patterns[0],\n+                    &arm.top_pats_hack()[0],\n                     ArmHasGuard(arm.guard.is_some()),\n                     Some((Some(&scrutinee_place), scrutinee_span)),\n                 );"}, {"sha": "bdfcacd0f462921b033f8817fbab7da2933767a4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -860,9 +860,9 @@ impl ToBorrowKind for hir::Mutability {\n     }\n }\n \n-fn convert_arm<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n+fn convert_arm<'tcx>(cx: &mut Cx<'_, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     Arm {\n-        patterns: arm.pats.iter().map(|p| cx.pattern_from_hir(p)).collect(),\n+        pattern: cx.pattern_from_hir(&arm.pat),\n         guard: match arm.guard {\n                 Some(hir::Guard::If(ref e)) => Some(Guard::If(e.to_ref())),\n                 _ => None,"}, {"sha": "63a9a83154b4f6c5fb029f096ab24b790f9312f6", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -293,14 +293,25 @@ pub struct FruInfo<'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct Arm<'tcx> {\n-    pub patterns: Vec<Pattern<'tcx>>,\n+    pub pattern: Pattern<'tcx>,\n     pub guard: Option<Guard<'tcx>>,\n     pub body: ExprRef<'tcx>,\n     pub lint_level: LintLevel,\n     pub scope: region::Scope,\n     pub span: Span,\n }\n \n+impl Arm<'tcx> {\n+    // HACK(or_patterns; Centril | dlrobertson): Remove this and\n+    // correctly handle each case in which this method is used.\n+    pub fn top_pats_hack(&self) -> &[Pattern<'tcx>] {\n+        match &*self.pattern.kind {\n+            PatternKind::Or { pats } => pats,\n+            _ => std::slice::from_ref(&self.pattern),\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub enum Guard<'tcx> {\n     If(ExprRef<'tcx>),"}, {"sha": "6301d9c390b028c9c910b08a67d0b6b820c4f222", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 43, "deletions": 66, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -14,7 +14,6 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::ptr::P;\n use rustc::hir::{self, Pat, PatKind};\n \n use smallvec::smallvec;\n@@ -76,15 +75,15 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n         });\n \n         // Check legality of move bindings and `@` patterns.\n-        self.check_patterns(false, slice::from_ref(&loc.pat));\n+        self.check_patterns(false, &loc.pat);\n     }\n \n     fn visit_body(&mut self, body: &'tcx hir::Body) {\n         intravisit::walk_body(self, body);\n \n         for param in &body.params {\n             self.check_irrefutable(&param.pat, \"function argument\");\n-            self.check_patterns(false, slice::from_ref(&param.pat));\n+            self.check_patterns(false, &param.pat);\n         }\n     }\n }\n@@ -122,11 +121,9 @@ impl PatternContext<'_, '_> {\n }\n \n impl<'tcx> MatchVisitor<'_, 'tcx> {\n-    fn check_patterns(&mut self, has_guard: bool, pats: &[P<Pat>]) {\n-        check_legality_of_move_bindings(self, has_guard, pats);\n-        for pat in pats {\n-            check_legality_of_bindings_in_at_patterns(self, pat);\n-        }\n+    fn check_patterns(&mut self, has_guard: bool, pat: &Pat) {\n+        check_legality_of_move_bindings(self, has_guard, pat);\n+        check_legality_of_bindings_in_at_patterns(self, pat);\n     }\n \n     fn check_match(\n@@ -137,7 +134,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     ) {\n         for arm in arms {\n             // First, check legality of move bindings.\n-            self.check_patterns(arm.guard.is_some(), &arm.pats);\n+            self.check_patterns(arm.guard.is_some(), &arm.pat);\n \n             // Second, if there is a guard on each arm, make sure it isn't\n             // assigning or borrowing anything mutably.\n@@ -146,17 +143,15 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             }\n \n             // Third, perform some lints.\n-            for pat in &arm.pats {\n-                check_for_bindings_named_same_as_variants(self, pat);\n-            }\n+            check_for_bindings_named_same_as_variants(self, &arm.pat);\n         }\n \n         let module = self.tcx.hir().get_module_parent(scrut.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut have_errors = false;\n \n             let inlined_arms : Vec<(Vec<_>, _)> = arms.iter().map(|arm| (\n-                arm.pats.iter().map(|pat| {\n+                arm.top_pats_hack().iter().map(|pat| {\n                     let mut patcx = PatternContext::new(self.tcx,\n                                                         self.param_env.and(self.identity_substs),\n                                                         self.tables);\n@@ -545,78 +540,60 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[Pattern<'_>]) -> Vec<Span> {\n     covered\n }\n \n-// Legality of move bindings checking\n-fn check_legality_of_move_bindings(\n-    cx: &mut MatchVisitor<'_, '_>,\n-    has_guard: bool,\n-    pats: &[P<Pat>],\n-) {\n+// Check the legality of legality of by-move bindings.\n+fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: bool, pat: &Pat) {\n     let mut by_ref_span = None;\n-    for pat in pats {\n-        pat.each_binding(|_, hir_id, span, _path| {\n-            if let Some(&bm) = cx.tables.pat_binding_modes().get(hir_id) {\n-                if let ty::BindByReference(..) = bm {\n-                    by_ref_span = Some(span);\n-                }\n-            } else {\n-                cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n+    pat.each_binding(|_, hir_id, span, _| {\n+        if let Some(&bm) = cx.tables.pat_binding_modes().get(hir_id) {\n+            if let ty::BindByReference(..) = bm {\n+                by_ref_span = Some(span);\n             }\n-        })\n-    }\n+        } else {\n+            cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n+        }\n+    });\n+\n     let span_vec = &mut Vec::new();\n-    let check_move = |\n-        cx: &mut MatchVisitor<'_, '_>,\n-        p: &Pat,\n-        sub: Option<&Pat>,\n-        span_vec: &mut Vec<Span>,\n-    | {\n-        // check legality of moving out of the enum\n-\n-        // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n+    let mut check_move = |p: &Pat, sub: Option<&Pat>| {\n+        // Check legality of moving out of the enum.\n+        //\n+        // `x @ Foo(..)` is legal, but `x @ Foo(y)` isn't.\n         if sub.map_or(false, |p| p.contains_bindings()) {\n-            struct_span_err!(cx.tcx.sess, p.span, E0007,\n-                             \"cannot bind by-move with sub-bindings\")\n+            struct_span_err!(cx.tcx.sess, p.span, E0007, \"cannot bind by-move with sub-bindings\")\n                 .span_label(p.span, \"binds an already bound by-move value by moving it\")\n                 .emit();\n-        } else if !has_guard {\n-            if let Some(_by_ref_span) = by_ref_span {\n-                span_vec.push(p.span);\n-            }\n+        } else if !has_guard && by_ref_span.is_some() {\n+            span_vec.push(p.span);\n         }\n     };\n \n-    for pat in pats {\n-        pat.walk(|p| {\n-            if let PatKind::Binding(_, _, _, ref sub) = p.node {\n-                if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n-                    match bm {\n-                        ty::BindByValue(..) => {\n-                            let pat_ty = cx.tables.node_type(p.hir_id);\n-                            if !pat_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, pat.span) {\n-                                check_move(cx, p, sub.as_ref().map(|p| &**p), span_vec);\n-                            }\n-                        }\n-                        _ => {}\n+    pat.walk(|p| {\n+        if let PatKind::Binding(.., sub) = &p.node {\n+            if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n+                if let ty::BindByValue(..) = bm {\n+                    let pat_ty = cx.tables.node_type(p.hir_id);\n+                    if !pat_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, pat.span) {\n+                        check_move(p, sub.as_deref());\n                     }\n-                } else {\n-                    cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                 }\n+            } else {\n+                cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n             }\n-            true\n-        });\n-    }\n-    if !span_vec.is_empty(){\n-        let span = MultiSpan::from_spans(span_vec.clone());\n+        }\n+        true\n+    });\n+\n+    if !span_vec.is_empty() {\n         let mut err = struct_span_err!(\n             cx.tcx.sess,\n-            span,\n+            MultiSpan::from_spans(span_vec.clone()),\n             E0009,\n             \"cannot bind by-move and by-ref in the same pattern\",\n         );\n         if let Some(by_ref_span) = by_ref_span {\n             err.span_label(by_ref_span, \"both by-ref and by-move used\");\n         }\n-        for span in span_vec.iter(){\n+        for span in span_vec.iter() {\n             err.span_label(*span, \"by-move pattern here\");\n         }\n         err.emit();\n@@ -627,7 +604,7 @@ fn check_legality_of_move_bindings(\n /// because of the way rvalues are handled in the borrow check. (See issue\n /// #14587.)\n fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n-    AtBindingPatternVisitor { cx: cx, bindings_allowed: true }.visit_pat(pat);\n+    AtBindingPatternVisitor { cx, bindings_allowed: true }.visit_pat(pat);\n }\n \n struct AtBindingPatternVisitor<'a, 'b, 'tcx> {"}, {"sha": "5fc23b4a69ec576d958f7836536d4e6d040c2548", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -239,7 +239,52 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             \"transmute\" => {\n                 self.copy_op_transmute(args[0], dest)?;\n             }\n+            \"simd_insert\" => {\n+                let index = self.read_scalar(args[1])?.to_u32()? as u64;\n+                let scalar = args[2];\n+                let input = args[0];\n+                let (len, e_ty) = self.read_vector_ty(input);\n+                assert!(\n+                    index < len,\n+                    \"Index `{}` must be in bounds of vector type `{}`: `[0, {})`\",\n+                    index, e_ty, len\n+                );\n+                assert_eq!(\n+                    input.layout, dest.layout,\n+                    \"Return type `{}` must match vector type `{}`\",\n+                    dest.layout.ty, input.layout.ty\n+                );\n+                assert_eq!(\n+                    scalar.layout.ty, e_ty,\n+                    \"Scalar type `{}` must match vector element type `{}`\",\n+                    scalar.layout.ty, e_ty\n+                );\n \n+                for i in 0..len {\n+                    let place = self.place_field(dest, i)?;\n+                    let value = if i == index {\n+                        scalar\n+                    } else {\n+                        self.operand_field(input, i)?\n+                    };\n+                    self.copy_op(value, place)?;\n+                }\n+            }\n+            \"simd_extract\" => {\n+                let index = self.read_scalar(args[1])?.to_u32()? as _;\n+                let (len, e_ty) = self.read_vector_ty(args[0]);\n+                assert!(\n+                    index < len,\n+                    \"index `{}` is out-of-bounds of vector type `{}` with length `{}`\",\n+                    index, e_ty, len\n+                );\n+                assert_eq!(\n+                    e_ty, dest.layout.ty,\n+                    \"Return type `{}` must match vector element type `{}`\",\n+                    dest.layout.ty, e_ty\n+                );\n+                self.copy_op(self.operand_field(args[0], index)?, dest)?;\n+            }\n             _ => return Ok(false),\n         }\n "}, {"sha": "afaf9d7ed9d67072c1ebf7902e8e2ac263b58f70", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -335,6 +335,17 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n+    /// Read vector length and element type\n+    pub fn read_vector_ty(\n+        &self, op: OpTy<'tcx, M::PointerTag>\n+    ) -> (u64, &rustc::ty::TyS<'tcx>) {\n+        if let layout::Abi::Vector { .. } = op.layout.abi {\n+            (op.layout.ty.simd_size(*self.tcx) as _, op.layout.ty.simd_type(*self.tcx))\n+        } else {\n+            bug!(\"Type `{}` is not a SIMD vector type\", op.layout.ty)\n+        }\n+    }\n+\n     /// Read a scalar from a place\n     pub fn read_scalar(\n         &self,"}, {"sha": "8666c937ce4c2e45cf19c246b4c72ff0cc5409c8", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -249,9 +249,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n-                if caller_abi != Abi::RustIntrinsic {\n-                    throw_unsup!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic))\n-                }\n                 // The intrinsic itself cannot diverge, so if we got here without a return\n                 // place... (can happen e.g., for transmute returning `!`)\n                 let dest = match dest {"}, {"sha": "938dab57181d676903c4f45ccca9d22545546dff", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -6,6 +6,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #![feature(nll)]\n #![feature(in_band_lifetimes)]\n+#![feature(inner_deref)]\n #![feature(slice_patterns)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]"}, {"sha": "8a6dcd1d2b476f2cce48af9e796c864701ad0f0b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -557,6 +557,8 @@ impl Qualif for IsNotPromotable {\n                             | \"saturating_add\"\n                             | \"saturating_sub\"\n                             | \"transmute\"\n+                            | \"simd_insert\"\n+                            | \"simd_extract\"\n                             => return true,\n \n                             _ => {}"}, {"sha": "4e29706714f3dde9d3a5ddd9fcfa731e7f087f28", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -8,7 +8,6 @@\n \n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n-#![cfg_attr(bootstrap, feature(bind_by_move_pattern_guards))]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "12978cd117b52a49e8209b19229adf33dc7bcddb", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -499,19 +499,15 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n \n         // Conditional control flow (possible to implement).\n-        hir::ExprKind::Match(ref expr, ref hirvec_arm, ref _match_source) => {\n+        hir::ExprKind::Match(ref expr, ref arms, ref _match_source) => {\n             // Compute the most demanding borrow from all the arms'\n             // patterns and set that on the discriminator.\n-            let mut mut_borrow = false;\n-            for pat in hirvec_arm.iter().flat_map(|arm| &arm.pats) {\n-                mut_borrow = v.remove_mut_rvalue_borrow(pat);\n-            }\n-            if mut_borrow {\n+            if arms.iter().fold(false, |_, arm| v.remove_mut_rvalue_borrow(&arm.pat)) {\n                 v.mut_rvalue_borrows.insert(expr.hir_id);\n             }\n \n             let _ = v.check_expr(expr);\n-            for index in hirvec_arm.iter() {\n+            for index in arms.iter() {\n                 let _ = v.check_expr(&*index.body);\n                 if let Some(hir::Guard::If(ref expr)) = index.guard {\n                     let _ = v.check_expr(&expr);"}, {"sha": "14a07c8c9c7e289aaa272c19738f11cc9d925e7f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -58,11 +58,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // collection into `Vec`), so we get types for all bindings.\n         let all_arm_pats_diverge: Vec<_> = arms.iter().map(|arm| {\n             let mut all_pats_diverge = Diverges::WarnedAlways;\n-            for p in &arm.pats {\n-                self.diverges.set(Diverges::Maybe);\n-                self.check_pat_top(&p, discrim_ty, Some(discrim.span));\n-                all_pats_diverge &= self.diverges.get();\n-            }\n+            self.diverges.set(Diverges::Maybe);\n+            self.check_pat_top(&arm.pat, discrim_ty, Some(discrim.span));\n+            all_pats_diverge &= self.diverges.get();\n \n             // As discussed with @eddyb, this is for disabling unreachable_code\n             // warnings on patterns (they're now subsumed by unreachable_patterns\n@@ -428,11 +426,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         //\n         // See #44848.\n         let contains_ref_bindings = arms.iter()\n-                                        .filter_map(|a| a.contains_explicit_ref_binding())\n-                                        .max_by_key(|m| match *m {\n-                                            hir::MutMutable => 1,\n-                                            hir::MutImmutable => 0,\n-                                        });\n+            .filter_map(|a| a.pat.contains_explicit_ref_binding())\n+            .max_by_key(|m| match *m {\n+                hir::MutMutable => 1,\n+                hir::MutImmutable => 0,\n+            });\n \n         if let Some(m) = contains_ref_bindings {\n             self.check_expr_with_needs(discrim, Needs::maybe_mut_place(m))"}, {"sha": "a2f7a8fe4febcbbae6f65981441f72794907c2de", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -97,11 +97,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_pat_struct(pat, qpath, fields, *etc, expected, def_bm, discrim_span)\n             }\n             PatKind::Or(pats) => {\n-                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                 for pat in pats {\n                     self.check_pat(pat, expected, def_bm, discrim_span);\n                 }\n-                expected_ty\n+                expected\n             }\n             PatKind::Tuple(elements, ddpos) => {\n                 self.check_pat_tuple(pat.span, elements, *ddpos, expected, def_bm, discrim_span)\n@@ -208,7 +207,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match pat.node {\n             PatKind::Struct(..) |\n             PatKind::TupleStruct(..) |\n-            PatKind::Or(_) |\n             PatKind::Tuple(..) |\n             PatKind::Box(_) |\n             PatKind::Range(..) |\n@@ -226,6 +224,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     _ => true,\n                 }\n             }\n+            // FIXME(or_patterns; Centril | dlrobertson): To keep things compiling\n+            // for or-patterns at the top level, we need to make `p_0 | ... | p_n`\n+            // a \"non reference pattern\". For example the following currently compiles:\n+            // ```\n+            // match &1 {\n+            //     e @ &(1...2) | e @ &(3...4) => {}\n+            //     _ => {}\n+            // }\n+            // ```\n+            //\n+            // We should consider whether we should do something special in nested or-patterns.\n+            PatKind::Or(_) |\n             PatKind::Wild |\n             PatKind::Binding(..) |\n             PatKind::Ref(..) => false,\n@@ -426,12 +436,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // If the binding is like `ref x | ref const x | ref mut x`\n                 // then `x` is assigned a value of type `&M T` where M is the\n                 // mutability and T is the expected type.\n-                let region_ty = self.new_ref_ty(pat.span, mutbl, expected);\n-\n+                //\n                 // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)`\n                 // is required. However, we use equality, which is stronger.\n                 // See (note_1) for an explanation.\n-                region_ty\n+                self.new_ref_ty(pat.span, mutbl, expected)\n             }\n             // Otherwise, the type of x is the expected type `T`.\n             ty::BindByValue(_) => {"}, {"sha": "6fa8a016b54588231b8283a9b1e1c38d6bbdeb9d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -488,9 +488,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n \n     fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n         // see above\n-        for p in &arm.pats {\n-            self.constrain_bindings_in_pat(p);\n-        }\n+        self.constrain_bindings_in_pat(&arm.pat);\n         intravisit::walk_arm(self, arm);\n     }\n \n@@ -1069,9 +1067,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         let discr_cmt = Rc::new(ignore_err!(self.with_mc(|mc| mc.cat_expr(discr))));\n         debug!(\"discr_cmt={:?}\", discr_cmt);\n         for arm in arms {\n-            for root_pat in &arm.pats {\n-                self.link_pattern(discr_cmt.clone(), &root_pat);\n-            }\n+            self.link_pattern(discr_cmt.clone(), &arm.pat);\n         }\n     }\n "}, {"sha": "854549bb66b331d51d9ada0027f05641fc7a8d7a", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -54,7 +54,7 @@ pub fn impl_wf_check(tcx: TyCtxt<'_>) {\n     // but it's one that we must perform earlier than the rest of\n     // WfCheck.\n     for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().check_mod_impl_wf(tcx.hir().local_def_id_from_node_id(module));\n+        tcx.ensure().check_mod_impl_wf(tcx.hir().local_def_id(module));\n     }\n }\n "}, {"sha": "e97d6db5db08c64f995a55fec2aee5793995e023", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -303,7 +303,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n     tcx.sess.track_errors(|| {\n         time(tcx.sess, \"type collecting\", || {\n             for &module in tcx.hir().krate().modules.keys() {\n-                tcx.ensure().collect_mod_item_types(tcx.hir().local_def_id_from_node_id(module));\n+                tcx.ensure().collect_mod_item_types(tcx.hir().local_def_id(module));\n             }\n         });\n     })?;\n@@ -338,7 +338,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n \n     time(tcx.sess, \"item-types checking\", || {\n         for &module in tcx.hir().krate().modules.keys() {\n-            tcx.ensure().check_mod_item_types(tcx.hir().local_def_id_from_node_id(module));\n+            tcx.ensure().check_mod_item_types(tcx.hir().local_def_id(module));\n         }\n     });\n "}, {"sha": "2985e7f70b52f649b0dce3c67243b749ebc10d81", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -1,7 +1,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\")]\n \n-#![cfg_attr(bootstrap, feature(bind_by_move_pattern_guards))]\n #![feature(rustc_private)]\n #![feature(arbitrary_self_types)]\n #![feature(box_patterns)]"}, {"sha": "5d9683f8deda9642731bf110e70f4de94041c2b6", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -238,7 +238,6 @@\n #![feature(array_error_internals)]\n #![feature(asm)]\n #![feature(associated_type_bounds)]\n-#![cfg_attr(bootstrap, feature(bind_by_move_pattern_guards))]\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n #![feature(cfg_target_has_atomic)]"}, {"sha": "8f49ba9572d774ba76c006020780f283f6101daa", "filename": "src/libsyntax/ext/mbe/macro_parser.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -413,18 +413,6 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n     Success(ret_val)\n }\n \n-/// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For\n-/// other tokens, this is \"unexpected token...\".\n-crate fn parse_failure_msg(tok: &Token) -> String {\n-    match tok.kind {\n-        token::Eof => \"unexpected end of macro invocation\".to_string(),\n-        _ => format!(\n-            \"no rules expected the token `{}`\",\n-            pprust::token_to_string(tok)\n-        ),\n-    }\n-}\n-\n /// Performs a token equality check, ignoring syntax context (that is, an unhygienic comparison)\n fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n     if let (Some((ident1, is_raw1)), Some((ident2, is_raw2))) = (t1.ident(), t2.ident()) {"}, {"sha": "c24f6a666039fffeed8c05c9f247c990647e7c9c", "filename": "src/libsyntax/ext/mbe/macro_rules.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_rules.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -6,7 +6,7 @@ use crate::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n use crate::ext::mbe;\n use crate::ext::mbe::macro_check;\n-use crate::ext::mbe::macro_parser::{parse, parse_failure_msg};\n+use crate::ext::mbe::macro_parser::parse;\n use crate::ext::mbe::macro_parser::{Error, Failure, Success};\n use crate::ext::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedParseResult};\n use crate::ext::mbe::transcribe::transcribe;\n@@ -15,6 +15,7 @@ use crate::parse::parser::Parser;\n use crate::parse::token::TokenKind::*;\n use crate::parse::token::{self, NtTT, Token};\n use crate::parse::{Directory, ParseSess};\n+use crate::print::pprust;\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n \n@@ -371,10 +372,6 @@ pub fn compile_declarative_macro(\n                             tt.clone().into(),\n                             true,\n                             sess,\n-                            features,\n-                            &def.attrs,\n-                            edition,\n-                            def.id,\n                         )\n                         .pop()\n                         .unwrap();\n@@ -398,10 +395,6 @@ pub fn compile_declarative_macro(\n                             tt.clone().into(),\n                             false,\n                             sess,\n-                            features,\n-                            &def.attrs,\n-                            edition,\n-                            def.id,\n                         )\n                         .pop()\n                         .unwrap();\n@@ -1184,3 +1177,15 @@ impl TokenTree {\n         parse(cx.parse_sess(), tts, mtch, Some(directory), true)\n     }\n }\n+\n+/// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For\n+/// other tokens, this is \"unexpected token...\".\n+fn parse_failure_msg(tok: &Token) -> String {\n+    match tok.kind {\n+        token::Eof => \"unexpected end of macro invocation\".to_string(),\n+        _ => format!(\n+            \"no rules expected the token `{}`\",\n+            pprust::token_to_string(tok),\n+        ),\n+    }\n+}"}, {"sha": "8cb85bdef762fe023d3120c98e6aa8f50048d679", "filename": "src/libsyntax/ext/mbe/quoted.rs", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibsyntax%2Fext%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibsyntax%2Fext%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fquoted.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -1,18 +1,15 @@\n use crate::ast;\n-use crate::ast::NodeId;\n use crate::ext::mbe::macro_parser;\n use crate::ext::mbe::{TokenTree, KleeneOp, KleeneToken, SequenceRepetition, Delimited};\n-use crate::feature_gate::Features;\n use crate::parse::token::{self, Token};\n use crate::parse::ParseSess;\n use crate::print::pprust;\n use crate::symbol::kw;\n use crate::tokenstream;\n \n-use syntax_pos::{edition::Edition, Span};\n+use syntax_pos::Span;\n \n use rustc_data_structures::sync::Lrc;\n-use std::iter::Peekable;\n \n /// Takes a `tokenstream::TokenStream` and returns a `Vec<self::TokenTree>`. Specifically, this\n /// takes a generic `TokenStream`, such as is used in the rest of the compiler, and returns a\n@@ -39,17 +36,13 @@ pub(super) fn parse(\n     input: tokenstream::TokenStream,\n     expect_matchers: bool,\n     sess: &ParseSess,\n-    features: &Features,\n-    attrs: &[ast::Attribute],\n-    edition: Edition,\n-    macro_node_id: NodeId,\n ) -> Vec<TokenTree> {\n     // Will contain the final collection of `self::TokenTree`\n     let mut result = Vec::new();\n \n     // For each token tree in `input`, parse the token into a `self::TokenTree`, consuming\n     // additional trees if need be.\n-    let mut trees = input.trees().peekable();\n+    let mut trees = input.trees();\n     while let Some(tree) = trees.next() {\n         // Given the parsed tree, if there is a metavar and we are expecting matchers, actually\n         // parse out the matcher (i.e., in `$id:ident` this would parse the `:` and `ident`).\n@@ -58,10 +51,6 @@ pub(super) fn parse(\n             &mut trees,\n             expect_matchers,\n             sess,\n-            features,\n-            attrs,\n-            edition,\n-            macro_node_id,\n         );\n         match tree {\n             TokenTree::MetaVar(start_sp, ident) if expect_matchers => {\n@@ -109,13 +98,9 @@ pub(super) fn parse(\n ///   unstable features or not.\n fn parse_tree(\n     tree: tokenstream::TokenTree,\n-    trees: &mut Peekable<impl Iterator<Item = tokenstream::TokenTree>>,\n+    trees: &mut impl Iterator<Item = tokenstream::TokenTree>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n-    features: &Features,\n-    attrs: &[ast::Attribute],\n-    edition: Edition,\n-    macro_node_id: NodeId,\n ) -> TokenTree {\n     // Depending on what `tree` is, we could be parsing different parts of a macro\n     match tree {\n@@ -135,10 +120,6 @@ fn parse_tree(\n                     tts.into(),\n                     expect_matchers,\n                     sess,\n-                    features,\n-                    attrs,\n-                    edition,\n-                    macro_node_id,\n                 );\n                 // Get the Kleene operator and optional separator\n                 let (separator, kleene) = parse_sep_and_kleene_op(trees, span.entire(), sess);\n@@ -192,10 +173,6 @@ fn parse_tree(\n                     tts.into(),\n                     expect_matchers,\n                     sess,\n-                    features,\n-                    attrs,\n-                    edition,\n-                    macro_node_id,\n                 ),\n             }),\n         ),\n@@ -244,7 +221,7 @@ fn parse_kleene_op(\n /// operator and separator, then a tuple with `(separator, KleeneOp)` is returned. Otherwise, an\n /// error with the appropriate span is emitted to `sess` and a dummy value is returned.\n fn parse_sep_and_kleene_op(\n-    input: &mut Peekable<impl Iterator<Item = tokenstream::TokenTree>>,\n+    input: &mut impl Iterator<Item = tokenstream::TokenTree>,\n     span: Span,\n     sess: &ParseSess,\n ) -> (Option<Token>, KleeneToken) {"}, {"sha": "2c10220c766a8ab4b64877d166d8c8c14376881a", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -7,7 +7,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(attr(deny(warnings))))]\n \n-#![cfg_attr(bootstrap, feature(bind_by_move_pattern_guards))]\n #![feature(box_syntax)]\n #![feature(const_fn)]\n #![feature(const_transmute)]"}, {"sha": "4fc29d70540fd25e904b0ceb44710458e9d9d271", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -834,8 +834,6 @@ pub fn walk_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a Param) {\n \n pub fn walk_arm<'a, V: Visitor<'a>>(visitor: &mut V, arm: &'a Arm) {\n     visitor.visit_pat(&arm.pat);\n-    // NOTE(or_patterns; Centril | dlrobertson):\n-    // If you change this, also change the hack in `lowering.rs`.\n     walk_list!(visitor, visit_expr, &arm.guard);\n     visitor.visit_expr(&arm.body);\n     walk_list!(visitor, visit_attribute, &arm.attrs);"}, {"sha": "9509d3e99612fbd0170fb5fd73669b93b9c9736d", "filename": "src/stage0.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -12,7 +12,7 @@\n # source tarball for a stable release you'll likely see `1.x.0` for rustc and\n # `0.x.0` for Cargo where they were released on `date`.\n \n-date: 2019-08-13\n+date: 2019-09-25\n rustc: beta\n cargo: beta\n "}, {"sha": "d3462d802ea4e9c6fd666edabea7d54baac0b13b", "filename": "src/test/ui/consts/const-eval/simd/insert_extract.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -0,0 +1,53 @@\n+// run-pass\n+#![feature(const_fn)]\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)] struct i8x1(i8);\n+#[repr(simd)] struct u16x2(u16, u16);\n+#[repr(simd)] struct f32x3(f32, f32, f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_insert<T, U>(x: T, idx: u32, val: U) -> T;\n+    fn simd_extract<T, U>(x: T, idx: u32) -> U;\n+}\n+\n+fn main() {\n+    {\n+        const U: i8x1 = i8x1(13);\n+        const V: i8x1 = unsafe { simd_insert(U, 0_u32, 42_i8) };\n+        const X0: i8 = V.0;\n+        const Y0: i8 = unsafe { simd_extract(V, 0) };\n+        assert_eq!(X0, 42);\n+        assert_eq!(Y0, 42);\n+    }\n+    {\n+        const U: u16x2 = u16x2(13, 14);\n+        const V: u16x2 = unsafe { simd_insert(U, 1_u32, 42_u16) };\n+        const X0: u16 = V.0;\n+        const X1: u16 = V.1;\n+        const Y0: u16 = unsafe { simd_extract(V, 0) };\n+        const Y1: u16 = unsafe { simd_extract(V, 1) };\n+        assert_eq!(X0, 13);\n+        assert_eq!(X1, 42);\n+        assert_eq!(Y0, 13);\n+        assert_eq!(Y1, 42);\n+    }\n+    {\n+        const U: f32x3 = f32x3(13., 14., 15.);\n+        const V: f32x3 = unsafe { simd_insert(U, 1_u32, 42_f32) };\n+        const X0: f32 = V.0;\n+        const X1: f32 = V.1;\n+        const X2: f32 = V.2;\n+        const Y0: f32 = unsafe { simd_extract(V, 0) };\n+        const Y1: f32 = unsafe { simd_extract(V, 1) };\n+        const Y2: f32 = unsafe { simd_extract(V, 2) };\n+        assert_eq!(X0, 13.);\n+        assert_eq!(X1, 42.);\n+        assert_eq!(X2, 15.);\n+        assert_eq!(Y0, 13.);\n+        assert_eq!(Y1, 42.);\n+        assert_eq!(Y2, 15.);\n+    }\n+}"}, {"sha": "7870d394c8bfbd52696de62ce9939a1c19decb22", "filename": "src/test/ui/lint/issue-47390-unused-variable-in-struct-pattern.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.rs?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -33,6 +33,9 @@ fn main() {\n     let mut mut_unused_var = 1;\n \n     let (mut var, unused_var) = (1, 2);\n+    // NOTE: `var` comes after `unused_var` lexicographically yet the warning\n+    // for `var` will be emitted before the one for `unused_var`. We use an\n+    // `IndexMap` to ensure this is the case instead of a `BTreeMap`.\n \n     if let SoulHistory { corridors_of_light,\n                          mut hours_are_suns,"}, {"sha": "74bbef8adad0539bd604f76dc883e3bf85b2a8c3", "filename": "src/test/ui/lint/issue-47390-unused-variable-in-struct-pattern.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c29c43206d6e2f1091fa278d2792ea10e3659/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr?ref=6c2c29c43206d6e2f1091fa278d2792ea10e3659", "patch": "@@ -30,21 +30,21 @@ LL |     let (mut var, unused_var) = (1, 2);\n    |                   ^^^^^^^^^^ help: consider prefixing with an underscore: `_unused_var`\n \n warning: unused variable: `corridors_of_light`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:37:26\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:40:26\n    |\n LL |     if let SoulHistory { corridors_of_light,\n    |                          ^^^^^^^^^^^^^^^^^^ help: try ignoring the field: `corridors_of_light: _`\n \n warning: variable `hours_are_suns` is assigned to, but never used\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:38:30\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:41:30\n    |\n LL |                          mut hours_are_suns,\n    |                              ^^^^^^^^^^^^^^\n    |\n    = note: consider using `_hours_are_suns` instead\n \n warning: value assigned to `hours_are_suns` is never read\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:40:9\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:43:9\n    |\n LL |         hours_are_suns = false;\n    |         ^^^^^^^^^^^^^^\n@@ -58,43 +58,43 @@ LL | #![warn(unused)] // UI tests pass `-A unused` (#43896)\n    = help: maybe it is overwritten before being read?\n \n warning: unused variable: `fire`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:44:32\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:47:32\n    |\n LL |     let LovelyAmbition { lips, fire } = the_spirit;\n    |                                ^^^^ help: try ignoring the field: `fire: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:53:23\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:56:23\n    |\n LL |         Large::Suit { case } => {}\n    |                       ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:58:24\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:61:24\n    |\n LL |         &Large::Suit { case } => {}\n    |                        ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:63:27\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:66:27\n    |\n LL |         box Large::Suit { case } => {}\n    |                           ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:68:24\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:71:24\n    |\n LL |         (Large::Suit { case },) => {}\n    |                        ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:73:24\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:76:24\n    |\n LL |         [Large::Suit { case }] => {}\n    |                        ^^^^ help: try ignoring the field: `case: _`\n \n warning: unused variable: `case`\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:78:29\n+  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:81:29\n    |\n LL |         Tuple(Large::Suit { case }, ()) => {}\n    |                             ^^^^ help: try ignoring the field: `case: _`"}]}