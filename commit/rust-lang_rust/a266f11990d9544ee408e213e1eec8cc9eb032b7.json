{"sha": "a266f11990d9544ee408e213e1eec8cc9eb032b7", "node_id": "C_kwDOAAsO6NoAKGEyNjZmMTE5OTBkOTU0NGVlNDA4ZTIxM2UxZWVjOGNjOWViMDMyYjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-22T19:04:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-22T19:04:49Z"}, "message": "Auto merge of #109496 - Dylan-DPC:rollup-u8rsi3h, r=Dylan-DPC\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #100311 (Fix handling of trailing bare CR in str::lines)\n - #108997 (Change text -> rust highlighting in sanitizer.md)\n - #109179 (move Option::as_slice to intrinsic)\n - #109187 (Render source page layout with Askama)\n - #109280 (Remove `VecMap`)\n - #109295 (refactor `fn bootstrap::builder::Builder::compiler_for` logic)\n - #109312 (rustdoc: Cleanup parent module tracking for doc links)\n - #109317 (Update links for custom discriminants.)\n - #109405 (RPITITs are `DefKind::Opaque` with new lowering strategy)\n - #109414 (Do not consider synthesized RPITITs on missing items checks)\n - #109435 (Detect uninhabited types early in const eval)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8047ee2a1679b107542e980b2ffb2f1f9daf91b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8047ee2a1679b107542e980b2ffb2f1f9daf91b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a266f11990d9544ee408e213e1eec8cc9eb032b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a266f11990d9544ee408e213e1eec8cc9eb032b7", "html_url": "https://github.com/rust-lang/rust/commit/a266f11990d9544ee408e213e1eec8cc9eb032b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a266f11990d9544ee408e213e1eec8cc9eb032b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "439292bc7913399e406d9bb7e8da0f70c6317c6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/439292bc7913399e406d9bb7e8da0f70c6317c6e", "html_url": "https://github.com/rust-lang/rust/commit/439292bc7913399e406d9bb7e8da0f70c6317c6e"}, {"sha": "eda88a30c767d1933aaf82a83d679a245b7d26b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/eda88a30c767d1933aaf82a83d679a245b7d26b8", "html_url": "https://github.com/rust-lang/rust/commit/eda88a30c767d1933aaf82a83d679a245b7d26b8"}], "stats": {"total": 1189, "additions": 513, "deletions": 676}, "files": [{"sha": "2f2f7d0aaa4594bf16beefee8ea5a5e9ddb1680c", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -19,7 +19,6 @@ extern crate tracing;\n \n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::graph::dominators::Dominators;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticMessage, SubdiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n@@ -141,7 +140,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &Bor\n         debug!(\"Skipping borrowck because of injected body\");\n         // Let's make up a borrowck result! Fun times!\n         let result = BorrowCheckResult {\n-            concrete_opaque_types: VecMap::new(),\n+            concrete_opaque_types: FxIndexMap::default(),\n             closure_requirements: None,\n             used_mut_upvars: SmallVec::new(),\n             tainted_by_errors: None,"}, {"sha": "f0068fc9226be0282d84eeeb25c020145ba7e33a", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -2,7 +2,7 @@\n #![deny(rustc::diagnostic_outside_of_impl)]\n //! The entry point of the NLL borrow checker.\n \n-use rustc_data_structures::vec_map::VecMap;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::{create_dump_file, dump_enabled, dump_mir, PassWhere};\n@@ -44,7 +44,7 @@ pub type PoloniusOutput = Output<RustcFacts>;\n /// closure requirements to propagate, and any generated errors.\n pub(crate) struct NllOutput<'tcx> {\n     pub regioncx: RegionInferenceContext<'tcx>,\n-    pub opaque_type_values: VecMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n+    pub opaque_type_values: FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n     pub polonius_input: Option<Box<AllFacts>>,\n     pub polonius_output: Option<Rc<PoloniusOutput>>,\n     pub opt_closure_req: Option<ClosureRegionRequirements<'tcx>>,\n@@ -377,7 +377,7 @@ pub(super) fn dump_annotation<'tcx>(\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'tcx>>,\n-    opaque_type_values: &VecMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n+    opaque_type_values: &FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n     errors: &mut crate::error::BorrowckErrors<'tcx>,\n ) {\n     let tcx = infcx.tcx;"}, {"sha": "2b16655cf7d5a91a0ff85d14142654bc43e827af", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -1,5 +1,4 @@\n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n@@ -61,9 +60,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'tcx>,\n-        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n-    ) -> VecMap<LocalDefId, OpaqueHiddenType<'tcx>> {\n-        let mut result: VecMap<LocalDefId, OpaqueHiddenType<'tcx>> = VecMap::new();\n+        opaque_ty_decls: FxIndexMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n+    ) -> FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>> {\n+        let mut result: FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>> = FxIndexMap::default();\n \n         let member_constraints: FxIndexMap<_, _> = self\n             .member_constraints"}, {"sha": "f67dae9beb92537b89420683ff72c8272bb84070", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -10,7 +10,6 @@ use either::Either;\n use hir::OpaqueTyOrigin;\n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n@@ -894,7 +893,7 @@ pub(crate) struct MirTypeckResults<'tcx> {\n     pub(crate) constraints: MirTypeckRegionConstraints<'tcx>,\n     pub(crate) universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n     pub(crate) opaque_type_values:\n-        VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n+        FxIndexMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n }\n \n /// A collection of region constraints that must be satisfied for the"}, {"sha": "350ce529ef538855dd996453804a6935b932214c", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -2,7 +2,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::{LangItem, CRATE_HIR_ID};\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::PointerArithmetic;\n-use rustc_middle::ty::layout::FnAbiOf;\n+use rustc_middle::ty::layout::{FnAbiOf, TyAndLayout};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::builtin::INVALID_ALIGNMENT;\n use std::borrow::Borrow;\n@@ -335,8 +335,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     #[inline(always)]\n-    fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n-        ecx.tcx.sess.opts.unstable_opts.extra_const_ub_checks\n+    fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>, layout: TyAndLayout<'tcx>) -> bool {\n+        ecx.tcx.sess.opts.unstable_opts.extra_const_ub_checks || layout.abi.is_uninhabited()\n     }\n \n     fn alignment_check_failed("}, {"sha": "aca68dc454beeeb6c32e1790c2a9a4e724863b6c", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -8,6 +8,7 @@ use std::hash::Hash;\n \n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_middle::mir;\n+use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::DefId;\n use rustc_target::abi::{Align, Size};\n@@ -145,8 +146,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         check: CheckAlignment,\n     ) -> InterpResult<'tcx, ()>;\n \n-    /// Whether to enforce the validity invariant\n-    fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n+    /// Whether to enforce the validity invariant for a specific layout.\n+    fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>, layout: TyAndLayout<'tcx>) -> bool;\n \n     /// Whether function calls should be [ABI](CallAbi)-checked.\n     fn enforce_abi(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {"}, {"sha": "ff6db143ddfd974979fb1efac580cebf064e13c5", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -461,7 +461,7 @@ where\n     ) -> InterpResult<'tcx> {\n         self.write_immediate_no_validate(src, dest)?;\n \n-        if M::enforce_validity(self) {\n+        if M::enforce_validity(self, dest.layout) {\n             // Data got changed, better make sure it matches the type!\n             self.validate_operand(&self.place_to_op(dest)?)?;\n         }\n@@ -616,7 +616,7 @@ where\n     ) -> InterpResult<'tcx> {\n         self.copy_op_no_validate(src, dest, allow_transmute)?;\n \n-        if M::enforce_validity(self) {\n+        if M::enforce_validity(self, dest.layout) {\n             // Data got changed, better make sure it matches the type!\n             self.validate_operand(&self.place_to_op(dest)?)?;\n         }"}, {"sha": "0339fb925d4587870037fb09cab5dcb091c63646", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -79,7 +79,6 @@ pub mod sync;\n pub mod tiny_list;\n pub mod transitive_relation;\n pub mod vec_linked_list;\n-pub mod vec_map;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n pub mod frozen;"}, {"sha": "d1a99bcaeb75452a28b497c99f1bddddea8ecd3e", "filename": "compiler/rustc_data_structures/src/vec_map.rs", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/439292bc7913399e406d9bb7e8da0f70c6317c6e/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439292bc7913399e406d9bb7e8da0f70c6317c6e/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs?ref=439292bc7913399e406d9bb7e8da0f70c6317c6e", "patch": "@@ -1,192 +0,0 @@\n-use std::borrow::Borrow;\n-use std::fmt::Debug;\n-use std::slice::Iter;\n-use std::vec::IntoIter;\n-\n-use crate::stable_hasher::{HashStable, StableHasher};\n-\n-/// A map type implemented as a vector of pairs `K` (key) and `V` (value).\n-/// It currently provides a subset of all the map operations, the rest could be added as needed.\n-#[derive(Clone, Encodable, Decodable, Debug)]\n-pub struct VecMap<K, V>(Vec<(K, V)>);\n-\n-impl<K, V> VecMap<K, V>\n-where\n-    K: Debug + PartialEq,\n-    V: Debug,\n-{\n-    pub fn new() -> Self {\n-        VecMap(Default::default())\n-    }\n-\n-    /// Sets the value of the entry, and returns the entry's old value.\n-    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n-        if let Some(elem) = self.0.iter_mut().find(|(key, _)| *key == k) {\n-            Some(std::mem::replace(&mut elem.1, v))\n-        } else {\n-            self.0.push((k, v));\n-            None\n-        }\n-    }\n-\n-    /// Removes the entry from the map and returns the removed value\n-    pub fn remove(&mut self, k: &K) -> Option<V> {\n-        self.0.iter().position(|(k2, _)| k2 == k).map(|pos| self.0.remove(pos).1)\n-    }\n-\n-    /// Gets a reference to the value in the entry.\n-    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n-    where\n-        K: Borrow<Q>,\n-        Q: Eq,\n-    {\n-        self.0.iter().find(|(key, _)| k == key.borrow()).map(|elem| &elem.1)\n-    }\n-\n-    /// Gets a mutable reference to the value in the entry.\n-    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n-    where\n-        K: Borrow<Q>,\n-        Q: Eq,\n-    {\n-        self.0.iter_mut().find(|(key, _)| k == key.borrow()).map(|elem| &mut elem.1)\n-    }\n-\n-    /// Returns the any value corresponding to the supplied predicate filter.\n-    ///\n-    /// The supplied predicate will be applied to each (key, value) pair and it will return a\n-    /// reference to the values where the predicate returns `true`.\n-    pub fn any_value_matching(&self, mut predicate: impl FnMut(&(K, V)) -> bool) -> Option<&V> {\n-        self.0.iter().find(|kv| predicate(kv)).map(|elem| &elem.1)\n-    }\n-\n-    /// Returns the value corresponding to the supplied predicate filter. It crashes if there's\n-    /// more than one matching element.\n-    ///\n-    /// The supplied predicate will be applied to each (key, value) pair and it will return a\n-    /// reference to the value where the predicate returns `true`.\n-    pub fn get_value_matching(&self, mut predicate: impl FnMut(&(K, V)) -> bool) -> Option<&V> {\n-        let mut filter = self.0.iter().filter(|kv| predicate(kv));\n-        let (_, value) = filter.next()?;\n-        // This should return just one element, otherwise it's a bug\n-        assert!(\n-            filter.next().is_none(),\n-            \"Collection {self:#?} should have just one matching element\"\n-        );\n-        Some(value)\n-    }\n-\n-    /// Returns `true` if the map contains a value for the specified key.\n-    ///\n-    /// The key may be any borrowed form of the map's key type,\n-    /// [`Eq`] on the borrowed form *must* match those for\n-    /// the key type.\n-    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n-    where\n-        K: Borrow<Q>,\n-        Q: Eq,\n-    {\n-        self.get(k).is_some()\n-    }\n-\n-    /// Returns `true` if the map contains no elements.\n-    pub fn is_empty(&self) -> bool {\n-        self.0.is_empty()\n-    }\n-\n-    pub fn iter(&self) -> Iter<'_, (K, V)> {\n-        self.into_iter()\n-    }\n-\n-    pub fn iter_mut(&mut self) -> impl Iterator<Item = (&K, &mut V)> {\n-        self.into_iter()\n-    }\n-\n-    pub fn retain(&mut self, f: impl Fn(&(K, V)) -> bool) {\n-        self.0.retain(f)\n-    }\n-}\n-\n-impl<K, V> Default for VecMap<K, V> {\n-    #[inline]\n-    fn default() -> Self {\n-        Self(Default::default())\n-    }\n-}\n-\n-impl<K, V> From<Vec<(K, V)>> for VecMap<K, V> {\n-    fn from(vec: Vec<(K, V)>) -> Self {\n-        Self(vec)\n-    }\n-}\n-\n-impl<K, V> Into<Vec<(K, V)>> for VecMap<K, V> {\n-    fn into(self) -> Vec<(K, V)> {\n-        self.0\n-    }\n-}\n-\n-impl<K, V> FromIterator<(K, V)> for VecMap<K, V> {\n-    fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> Self {\n-        Self(iter.into_iter().collect())\n-    }\n-}\n-\n-impl<'a, K, V> IntoIterator for &'a VecMap<K, V> {\n-    type Item = &'a (K, V);\n-    type IntoIter = Iter<'a, (K, V)>;\n-\n-    #[inline]\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.0.iter()\n-    }\n-}\n-\n-impl<'a, K: 'a, V: 'a> IntoIterator for &'a mut VecMap<K, V> {\n-    type Item = (&'a K, &'a mut V);\n-    type IntoIter = impl Iterator<Item = Self::Item>;\n-\n-    #[inline]\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.0.iter_mut().map(|(k, v)| (&*k, v))\n-    }\n-}\n-\n-impl<K, V> IntoIterator for VecMap<K, V> {\n-    type Item = (K, V);\n-    type IntoIter = IntoIter<(K, V)>;\n-\n-    #[inline]\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.0.into_iter()\n-    }\n-}\n-\n-impl<K: PartialEq + Debug, V: Debug> Extend<(K, V)> for VecMap<K, V> {\n-    fn extend<I: IntoIterator<Item = (K, V)>>(&mut self, iter: I) {\n-        for (k, v) in iter {\n-            self.insert(k, v);\n-        }\n-    }\n-\n-    fn extend_one(&mut self, (k, v): (K, V)) {\n-        self.insert(k, v);\n-    }\n-\n-    fn extend_reserve(&mut self, additional: usize) {\n-        self.0.extend_reserve(additional);\n-    }\n-}\n-\n-impl<K, V, CTX> HashStable<CTX> for VecMap<K, V>\n-where\n-    K: HashStable<CTX> + Eq,\n-    V: HashStable<CTX>,\n-{\n-    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        self.0.hash_stable(hcx, hasher)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "458b60077dc75a76d5c3f63e31cf8bfbdb10012e", "filename": "compiler/rustc_data_structures/src/vec_map/tests.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/439292bc7913399e406d9bb7e8da0f70c6317c6e/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439292bc7913399e406d9bb7e8da0f70c6317c6e/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs?ref=439292bc7913399e406d9bb7e8da0f70c6317c6e", "patch": "@@ -1,48 +0,0 @@\n-use super::*;\n-\n-impl<K, V> VecMap<K, V> {\n-    fn into_vec(self) -> Vec<(K, V)> {\n-        self.0.into()\n-    }\n-}\n-\n-#[test]\n-fn test_from_iterator() {\n-    assert_eq!(\n-        std::iter::empty().collect::<VecMap<i32, bool>>().into_vec(),\n-        Vec::<(i32, bool)>::new()\n-    );\n-    assert_eq!(std::iter::once((42, true)).collect::<VecMap<_, _>>().into_vec(), vec![(42, true)]);\n-    assert_eq!(\n-        [(1, true), (2, false)].into_iter().collect::<VecMap<_, _>>().into_vec(),\n-        vec![(1, true), (2, false)]\n-    );\n-}\n-\n-#[test]\n-fn test_into_iterator_owned() {\n-    assert_eq!(VecMap::new().into_iter().collect::<Vec<(i32, bool)>>(), Vec::<(i32, bool)>::new());\n-    assert_eq!(VecMap::from(vec![(1, true)]).into_iter().collect::<Vec<_>>(), vec![(1, true)]);\n-    assert_eq!(\n-        VecMap::from(vec![(1, true), (2, false)]).into_iter().collect::<Vec<_>>(),\n-        vec![(1, true), (2, false)]\n-    );\n-}\n-\n-#[test]\n-fn test_insert() {\n-    let mut v = VecMap::new();\n-    assert_eq!(v.insert(1, true), None);\n-    assert_eq!(v.insert(2, false), None);\n-    assert_eq!(v.clone().into_vec(), vec![(1, true), (2, false)]);\n-    assert_eq!(v.insert(1, false), Some(true));\n-    assert_eq!(v.into_vec(), vec![(1, false), (2, false)]);\n-}\n-\n-#[test]\n-fn test_get() {\n-    let v = [(1, true), (2, false)].into_iter().collect::<VecMap<_, _>>();\n-    assert_eq!(v.get(&1), Some(&true));\n-    assert_eq!(v.get(&2), Some(&false));\n-    assert_eq!(v.get(&3), None);\n-}"}, {"sha": "71d6c6fe2ef2c5377fcf625456ab26d630665330", "filename": "compiler/rustc_error_codes/src/error_codes/E0080.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0080.md", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0080.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0080.md?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -15,9 +15,8 @@ or causing an integer overflow are two ways to induce this error.\n \n Ensure that the expressions given can be evaluated as the desired integer type.\n \n-See the [Custom Discriminants][custom-discriminants] section of the Reference\n-for more information about setting custom integer types on fieldless enums\n-using the [`repr` attribute][repr-attribute].\n+See the [Discriminants] section of the Reference for more information about\n+setting custom integer types on enums using the [`repr` attribute][repr-attribute].\n \n-[custom-discriminants]: https://doc.rust-lang.org/reference/items/enumerations.html#custom-discriminant-values-for-field-less-enumerations\n-[repr-attribute]: https://doc.rust-lang.org/reference/type-layout.html#reprc-enums\n+[discriminants]: https://doc.rust-lang.org/reference/items/enumerations.html#discriminants\n+[repr-attribute]: https://doc.rust-lang.org/reference/type-layout.html#representations"}, {"sha": "0863d65d8f9c8a4bdbafab19d6d8a04962f56755", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -301,6 +301,7 @@ language_item_table! {\n     Context,                 sym::Context,             context,                    Target::Struct,         GenericRequirement::None;\n     FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n \n+    Option,                  sym::Option,              option_type,                Target::Enum,           GenericRequirement::None;\n     OptionSome,              sym::Some,                option_some_variant,        Target::Variant,        GenericRequirement::None;\n     OptionNone,              sym::None,                option_none_variant,        Target::Variant,        GenericRequirement::None;\n "}, {"sha": "d8dda7a93be1369d36d13c9e718b6c3d74168cf7", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -305,7 +305,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n     }) = item.kind\n     {\n         let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-        let opaque_identity_ty = if in_trait {\n+        let opaque_identity_ty = if in_trait && !tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n             tcx.mk_projection(def_id.to_def_id(), substs)\n         } else {\n             tcx.mk_opaque(def_id.to_def_id(), substs)\n@@ -554,7 +554,15 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n             check_union(tcx, id.owner_id.def_id);\n         }\n         DefKind::OpaqueTy => {\n-            check_opaque(tcx, id);\n+            let opaque = tcx.hir().expect_item(id.owner_id.def_id).expect_opaque_ty();\n+            if let hir::OpaqueTyOrigin::FnReturn(fn_def_id) | hir::OpaqueTyOrigin::AsyncFn(fn_def_id) = opaque.origin\n+                && let hir::Node::TraitItem(trait_item) = tcx.hir().get_by_def_id(fn_def_id)\n+                && let (_, hir::TraitFn::Required(..)) = trait_item.expect_fn()\n+            {\n+                // Skip opaques from RPIT in traits with no default body.\n+            } else {\n+                check_opaque(tcx, id);\n+            }\n         }\n         DefKind::ImplTraitPlaceholder => {\n             let parent = tcx.impl_trait_in_trait_parent_fn(id.owner_id.to_def_id());"}, {"sha": "1b7475486dceace01728f805f507c1139fbc6d73", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -223,6 +223,21 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 ],\n                 tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Not }),\n             ),\n+            sym::option_payload_ptr => {\n+                let option_def_id = tcx.require_lang_item(hir::LangItem::Option, None);\n+                let p0 = param(0);\n+                (\n+                    1,\n+                    vec![tcx.mk_ptr(ty::TypeAndMut {\n+                        ty: tcx.mk_adt(\n+                            tcx.adt_def(option_def_id),\n+                            tcx.mk_substs_from_iter([ty::GenericArg::from(p0)].into_iter()),\n+                        ),\n+                        mutbl: hir::Mutability::Not,\n+                    })],\n+                    tcx.mk_ptr(ty::TypeAndMut { ty: p0, mutbl: hir::Mutability::Not }),\n+                )\n+            }\n             sym::ptr_mask => (\n                 1,\n                 vec!["}, {"sha": "8fe4c44fca43a6f0056a899067f749c2c09d4f96", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -202,8 +202,11 @@ fn missing_items_err(\n     missing_items: &[ty::AssocItem],\n     full_impl_span: Span,\n ) {\n+    let missing_items =\n+        missing_items.iter().filter(|trait_item| tcx.opt_rpitit_info(trait_item.def_id).is_none());\n+\n     let missing_items_msg = missing_items\n-        .iter()\n+        .clone()\n         .map(|trait_item| trait_item.name.to_string())\n         .collect::<Vec<_>>()\n         .join(\"`, `\");"}, {"sha": "225b1550580761773ccf860456777cc3bb71557b", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -778,7 +778,7 @@ fn find_opaque_ty_constraints_for_rpit(\n             // Use borrowck to get the type with unerased regions.\n             let concrete_opaque_types = &self.tcx.mir_borrowck(def_id).concrete_opaque_types;\n             debug!(?concrete_opaque_types);\n-            for &(def_id, concrete_type) in concrete_opaque_types {\n+            for (&def_id, &concrete_type) in concrete_opaque_types {\n                 if def_id != self.def_id {\n                     // Ignore constraints for other opaque types.\n                     continue;"}, {"sha": "268896b671adf50a9ff5cc429ff30c2c120ff53e", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -159,9 +159,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             .opaque_type_storage\n             .opaque_types\n             .iter()\n-            .map(|&(k, ref v)| {\n-                (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty)\n-            })\n+            .map(|(k, v)| (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty))\n             .collect()\n     }\n "}, {"sha": "3a0a0494a7ed33dc1c90a59d142b50936fd22e41", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -5,8 +5,8 @@ use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n use crate::traits;\n use hir::def_id::{DefId, LocalDefId};\n use hir::OpaqueTyOrigin;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n@@ -21,7 +21,7 @@ use std::ops::ControlFlow;\n \n mod table;\n \n-pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n+pub type OpaqueTypeMap<'tcx> = FxIndexMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n pub use table::{OpaqueTypeStorage, OpaqueTypeTable};\n \n /// Information about the opaque types whose values we"}, {"sha": "4dd433a50a73b7f984207b9be1702626cc1b101c", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -1016,7 +1016,6 @@ fn should_encode_type(tcx: TyCtxt<'_>, def_id: LocalDefId, def_kind: DefKind) ->\n         | DefKind::Const\n         | DefKind::Static(..)\n         | DefKind::TyAlias\n-        | DefKind::OpaqueTy\n         | DefKind::ForeignTy\n         | DefKind::Impl { .. }\n         | DefKind::AssocFn\n@@ -1027,6 +1026,18 @@ fn should_encode_type(tcx: TyCtxt<'_>, def_id: LocalDefId, def_kind: DefKind) ->\n         | DefKind::AnonConst\n         | DefKind::InlineConst => true,\n \n+        DefKind::OpaqueTy => {\n+            let opaque = tcx.hir().expect_item(def_id).expect_opaque_ty();\n+            if let hir::OpaqueTyOrigin::FnReturn(fn_def_id) | hir::OpaqueTyOrigin::AsyncFn(fn_def_id) = opaque.origin\n+                && let hir::Node::TraitItem(trait_item) = tcx.hir().get_by_def_id(fn_def_id)\n+                && let (_, hir::TraitFn::Required(..)) = trait_item.expect_fn()\n+            {\n+                false\n+            } else {\n+                true\n+            }\n+        }\n+\n         DefKind::ImplTraitPlaceholder => {\n             let parent_def_id = tcx.impl_trait_in_trait_parent_fn(def_id.to_def_id());\n             let assoc_item = tcx.associated_item(parent_def_id);\n@@ -1044,7 +1055,13 @@ fn should_encode_type(tcx: TyCtxt<'_>, def_id: LocalDefId, def_kind: DefKind) ->\n             let assoc_item = tcx.associated_item(def_id);\n             match assoc_item.container {\n                 ty::AssocItemContainer::ImplContainer => true,\n-                ty::AssocItemContainer::TraitContainer => assoc_item.defaultness(tcx).has_value(),\n+                // FIXME(-Zlower-impl-trait-in-trait-to-assoc-ty) always encode RPITITs,\n+                // since we need to be able to \"project\" from an RPITIT associated item\n+                // to an opaque when installing the default projection predicates in\n+                // default trait methods with RPITITs.\n+                ty::AssocItemContainer::TraitContainer => {\n+                    assoc_item.defaultness(tcx).has_value() || assoc_item.opt_rpitit_info.is_some()\n+                }\n             }\n         }\n         DefKind::TyParam => {"}, {"sha": "89a485b47ca8c03318187d27258db4a486eb3304", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -188,7 +188,7 @@ impl<'hir> Map<'hir> {\n                 ItemKind::Macro(_, macro_kind) => DefKind::Macro(macro_kind),\n                 ItemKind::Mod(..) => DefKind::Mod,\n                 ItemKind::OpaqueTy(ref opaque) => {\n-                    if opaque.in_trait {\n+                    if opaque.in_trait && !self.tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n                         DefKind::ImplTraitPlaceholder\n                     } else {\n                         DefKind::OpaqueTy"}, {"sha": "786c2e9cd943e426cbc1a9e789b4730360fb9f1a", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -2,8 +2,8 @@\n \n use crate::mir::{Body, ConstantKind, Promoted};\n use crate::ty::{self, OpaqueHiddenType, Ty, TyCtxt};\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::unord::UnordSet;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -227,7 +227,7 @@ pub struct BorrowCheckResult<'tcx> {\n     /// All the opaque types that are restricted to concrete types\n     /// by this function. Unlike the value in `TypeckResults`, this has\n     /// unerased regions.\n-    pub concrete_opaque_types: VecMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n+    pub concrete_opaque_types: FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n     pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,\n     pub used_mut_upvars: SmallVec<[Field; 8]>,\n     pub tainted_by_errors: Option<ErrorGuaranteed>,"}, {"sha": "2b0fb4dc2b7d6ce90488f69486545bbc45642b3a", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -8,10 +8,9 @@ use crate::{\n     },\n };\n use rustc_data_structures::{\n-    fx::FxHashMap,\n+    fx::{FxHashMap, FxIndexMap},\n     sync::Lrc,\n     unord::{UnordItems, UnordSet},\n-    vec_map::VecMap,\n };\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n@@ -155,7 +154,7 @@ pub struct TypeckResults<'tcx> {\n     /// by this function. We also store the\n     /// type here, so that mir-borrowck can use it as a hint for figuring out hidden types,\n     /// even if they are only set in dead code (which doesn't show up in MIR).\n-    pub concrete_opaque_types: VecMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n+    pub concrete_opaque_types: FxIndexMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n \n     /// Tracks the minimum captures required for a closure;\n     /// see `MinCaptureInformationMap` for more details."}, {"sha": "8b81abb23b0aa87c143b77a36e11dac6ade6bb09", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -180,7 +180,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     }\n \n     #[inline(always)]\n-    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>, _layout: TyAndLayout<'tcx>) -> bool {\n         false // for now, we don't enforce validity\n     }\n     fn alignment_check_failed("}, {"sha": "a7218a4f2500d97b91792b6a19facbc446943257", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -8,6 +8,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::DefKind;\n use rustc_middle::mir::visit::{MutVisitor, Visitor};\n use rustc_middle::mir::*;\n+use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_mir_dataflow::value_analysis::{Map, State, TrackElem, ValueAnalysis, ValueOrPlace};\n use rustc_mir_dataflow::{lattice::FlatSet, Analysis, ResultsVisitor, SwitchIntEdgeEffects};\n@@ -548,7 +549,7 @@ impl<'mir, 'tcx> rustc_const_eval::interpret::Machine<'mir, 'tcx> for DummyMachi\n         unimplemented!()\n     }\n \n-    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>, _layout: TyAndLayout<'tcx>) -> bool {\n         unimplemented!()\n     }\n     fn alignment_check_failed("}, {"sha": "46eab1184bdad1d45254cd74376ec085506e6f4f", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -6,6 +6,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n+use rustc_target::abi::VariantIdx;\n \n pub struct LowerIntrinsics;\n \n@@ -191,6 +192,35 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                             terminator.kind = TerminatorKind::Goto { target };\n                         }\n                     }\n+                    sym::option_payload_ptr => {\n+                        if let (Some(target), Some(arg)) = (*target, args[0].place()) {\n+                            let ty::RawPtr(ty::TypeAndMut { ty: dest_ty, .. }) =\n+                                destination.ty(local_decls, tcx).ty.kind()\n+                            else { bug!(); };\n+\n+                            block.statements.push(Statement {\n+                                source_info: terminator.source_info,\n+                                kind: StatementKind::Assign(Box::new((\n+                                    *destination,\n+                                    Rvalue::AddressOf(\n+                                        Mutability::Not,\n+                                        arg.project_deeper(\n+                                            &[\n+                                                PlaceElem::Deref,\n+                                                PlaceElem::Downcast(\n+                                                    Some(sym::Some),\n+                                                    VariantIdx::from_u32(1),\n+                                                ),\n+                                                PlaceElem::Field(Field::from_u32(0), *dest_ty),\n+                                            ],\n+                                            tcx,\n+                                        ),\n+                                    ),\n+                                ))),\n+                            });\n+                            terminator.kind = TerminatorKind::Goto { target };\n+                        }\n+                    }\n                     _ if intrinsic_name.as_str().starts_with(\"simd_shuffle\") => {\n                         validate_simd_shuffle(tcx, args, terminator.source_info.span);\n                     }"}, {"sha": "0e40f794f18608f6d5ae839cbdfe244680439cab", "filename": "compiler/rustc_resolve/src/rustdoc.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -26,11 +26,13 @@ pub enum DocFragmentKind {\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct DocFragment {\n     pub span: Span,\n-    /// The module this doc-comment came from.\n-    ///\n-    /// This allows distinguishing between the original documentation and a pub re-export.\n-    /// If it is `None`, the item was not re-exported.\n-    pub parent_module: Option<DefId>,\n+    /// The item this doc-comment came from.\n+    /// Used to determine the scope in which doc links in this fragment are resolved.\n+    /// Typically filled for reexport docs when they are merged into the docs of the\n+    /// original reexported item.\n+    /// If the id is not filled, which happens for the original reexported item, then\n+    /// it has to be taken from somewhere else during doc link resolution.\n+    pub item_id: Option<DefId>,\n     pub doc: Symbol,\n     pub kind: DocFragmentKind,\n     pub indent: usize,\n@@ -186,15 +188,15 @@ pub fn attrs_to_doc_fragments<'a>(\n ) -> (Vec<DocFragment>, ast::AttrVec) {\n     let mut doc_fragments = Vec::new();\n     let mut other_attrs = ast::AttrVec::new();\n-    for (attr, parent_module) in attrs {\n+    for (attr, item_id) in attrs {\n         if let Some((doc_str, comment_kind)) = attr.doc_str_and_comment_kind() {\n             let doc = beautify_doc_string(doc_str, comment_kind);\n             let kind = if attr.is_doc_comment() {\n                 DocFragmentKind::SugaredDoc\n             } else {\n                 DocFragmentKind::RawDoc\n             };\n-            let fragment = DocFragment { span: attr.span, doc, kind, parent_module, indent: 0 };\n+            let fragment = DocFragment { span: attr.span, doc, kind, item_id, indent: 0 };\n             doc_fragments.push(fragment);\n         } else if !doc_only {\n             other_attrs.push(attr.clone());\n@@ -216,7 +218,7 @@ pub fn prepare_to_doc_link_resolution(\n ) -> FxHashMap<Option<DefId>, String> {\n     let mut res = FxHashMap::default();\n     for fragment in doc_fragments {\n-        let out_str = res.entry(fragment.parent_module).or_default();\n+        let out_str = res.entry(fragment.item_id).or_default();\n         add_doc_fragment(out_str, fragment);\n     }\n     res"}, {"sha": "4a1abdf63180a1c5cd61a57a1c2bfc89418be661", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -1044,6 +1044,7 @@ symbols! {\n         optin_builtin_traits,\n         option,\n         option_env,\n+        option_payload_ptr,\n         options,\n         or,\n         or_patterns,"}, {"sha": "562f5bffba315fb83e48c095af8f857259af6ca0", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -254,13 +254,16 @@ fn associated_type_for_impl_trait_in_trait(\n     tcx: TyCtxt<'_>,\n     opaque_ty_def_id: LocalDefId,\n ) -> LocalDefId {\n-    let fn_def_id = tcx.impl_trait_in_trait_parent_fn(opaque_ty_def_id.to_def_id());\n-    let trait_def_id = tcx.parent(fn_def_id);\n+    let (hir::OpaqueTyOrigin::FnReturn(fn_def_id) | hir::OpaqueTyOrigin::AsyncFn(fn_def_id)) =\n+        tcx.hir().expect_item(opaque_ty_def_id).expect_opaque_ty().origin\n+    else {\n+        bug!(\"expected opaque for {opaque_ty_def_id:?}\");\n+    };\n+    let trait_def_id = tcx.local_parent(fn_def_id);\n     assert_eq!(tcx.def_kind(trait_def_id), DefKind::Trait);\n \n     let span = tcx.def_span(opaque_ty_def_id);\n-    let trait_assoc_ty =\n-        tcx.at(span).create_def(trait_def_id.expect_local(), DefPathData::ImplTraitAssocTy);\n+    let trait_assoc_ty = tcx.at(span).create_def(trait_def_id, DefPathData::ImplTraitAssocTy);\n \n     let local_def_id = trait_assoc_ty.def_id();\n     let def_id = local_def_id.to_def_id();\n@@ -282,7 +285,7 @@ fn associated_type_for_impl_trait_in_trait(\n         container: ty::TraitContainer,\n         fn_has_self_parameter: false,\n         opt_rpitit_info: Some(ImplTraitInTraitData::Trait {\n-            fn_def_id,\n+            fn_def_id: fn_def_id.to_def_id(),\n             opaque_def_id: opaque_ty_def_id.to_def_id(),\n         }),\n     });\n@@ -324,7 +327,7 @@ fn associated_type_for_impl_trait_in_trait(\n             params.iter().map(|param| (param.def_id, param.index)).collect();\n \n         ty::Generics {\n-            parent: Some(trait_def_id),\n+            parent: Some(trait_def_id.to_def_id()),\n             parent_count,\n             params,\n             param_def_id_to_index,\n@@ -335,7 +338,7 @@ fn associated_type_for_impl_trait_in_trait(\n \n     // There are no predicates for the synthesized associated type.\n     trait_assoc_ty.explicit_predicates_of(ty::GenericPredicates {\n-        parent: Some(trait_def_id),\n+        parent: Some(trait_def_id.to_def_id()),\n         predicates: &[],\n     });\n \n@@ -356,7 +359,6 @@ fn associated_type_for_impl_trait_in_impl(\n     impl_fn_def_id: LocalDefId,\n ) -> LocalDefId {\n     let impl_local_def_id = tcx.local_parent(impl_fn_def_id);\n-    let impl_def_id = impl_local_def_id.to_def_id();\n \n     // FIXME fix the span, we probably want the def_id of the return type of the function\n     let span = tcx.def_span(impl_fn_def_id);\n@@ -402,7 +404,7 @@ fn associated_type_for_impl_trait_in_impl(\n         let trait_assoc_parent_count = trait_assoc_generics.parent_count;\n         let mut params = trait_assoc_generics.params.clone();\n \n-        let parent_generics = tcx.generics_of(impl_def_id);\n+        let parent_generics = tcx.generics_of(impl_local_def_id.to_def_id());\n         let parent_count = parent_generics.parent_count + parent_generics.params.len();\n \n         for param in &mut params {\n@@ -413,7 +415,7 @@ fn associated_type_for_impl_trait_in_impl(\n             params.iter().map(|param| (param.def_id, param.index)).collect();\n \n         ty::Generics {\n-            parent: Some(impl_def_id),\n+            parent: Some(impl_local_def_id.to_def_id()),\n             parent_count,\n             params,\n             param_def_id_to_index,\n@@ -424,7 +426,7 @@ fn associated_type_for_impl_trait_in_impl(\n \n     // There are no predicates for the synthesized associated type.\n     impl_assoc_ty.explicit_predicates_of(ty::GenericPredicates {\n-        parent: Some(impl_def_id),\n+        parent: Some(impl_local_def_id.to_def_id()),\n         predicates: &[],\n     });\n "}, {"sha": "c1dbbde08b6b9ad390590630f246656616fe3670", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -1499,13 +1499,25 @@ fn test_split_whitespace() {\n \n #[test]\n fn test_lines() {\n-    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\r\\nLittle l\u00e4mb\\n\";\n-    let lines: Vec<&str> = data.lines().collect();\n-    assert_eq!(lines, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n-\n-    let data = \"\\r\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\"; // no trailing \\n\n-    let lines: Vec<&str> = data.lines().collect();\n-    assert_eq!(lines, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+    fn t(data: &str, expected: &[&str]) {\n+        let lines: Vec<&str> = data.lines().collect();\n+        assert_eq!(lines, expected);\n+    }\n+    t(\"\", &[]);\n+    t(\"\\n\", &[\"\"]);\n+    t(\"\\n2nd\", &[\"\", \"2nd\"]);\n+    t(\"\\r\\n\", &[\"\"]);\n+    t(\"bare\\r\", &[\"bare\\r\"]);\n+    t(\"bare\\rcr\", &[\"bare\\rcr\"]);\n+    t(\"Text\\n\\r\", &[\"Text\", \"\\r\"]);\n+    t(\n+        \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\r\\nLittle l\u00e4mb\\n\",\n+        &[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"],\n+    );\n+    t(\n+        \"\\r\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\",\n+        &[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"],\n+    );\n }\n \n #[test]"}, {"sha": "7482b8b0862e259a81f7522c708b8845ada71dd1", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -2214,6 +2214,12 @@ extern \"rust-intrinsic\" {\n     where\n         G: FnOnce<ARG, Output = RET>,\n         F: FnOnce<ARG, Output = RET>;\n+\n+    #[cfg(not(bootstrap))]\n+    /// This method creates a pointer to any `Some` value. If the argument is\n+    /// `None`, an invalid within-bounds pointer (that is still acceptable for\n+    /// constructing an empty slice) is returned.\n+    pub fn option_payload_ptr<T>(arg: *const Option<T>) -> *const T;\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "cba597e66aa136c90e8e4d3a36d99d4f2e70370a", "filename": "library/core/src/option.rs", "status": "modified", "additions": 36, "deletions": 72, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -559,6 +559,7 @@ use crate::{\n /// The `Option` type. See [the module level documentation](self) for more.\n #[derive(Copy, PartialOrd, Eq, Ord, Debug, Hash)]\n #[rustc_diagnostic_item = \"Option\"]\n+#[cfg_attr(not(bootstrap), lang = \"Option\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Option<T> {\n     /// No value.\n@@ -735,48 +736,6 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// This is a guess at how many bytes into the option the payload can be found.\n-    ///\n-    /// For niche-optimized types it's correct because it's pigeon-holed to only\n-    /// one possible place.  For other types, it's usually correct today, but\n-    /// tweaks to the layout algorithm (particularly expansions of\n-    /// `-Z randomize-layout`) might make it incorrect at any point.\n-    ///\n-    /// It's guaranteed to be a multiple of alignment (so will always give a\n-    /// correctly-aligned location) and to be within the allocated object, so\n-    /// is valid to use with `offset` and to use for a zero-sized read.\n-    ///\n-    /// FIXME: This is a horrible hack, but allows a nice optimization.  It should\n-    /// be replaced with `offset_of!` once that works on enum variants.\n-    const SOME_BYTE_OFFSET_GUESS: isize = {\n-        let some_uninit = Some(mem::MaybeUninit::<T>::uninit());\n-        let payload_ref = some_uninit.as_ref().unwrap();\n-        // SAFETY: `as_ref` gives an address inside the existing `Option`,\n-        // so both pointers are derived from the same thing and the result\n-        // cannot overflow an `isize`.\n-        let offset = unsafe { <*const _>::byte_offset_from(payload_ref, &some_uninit) };\n-\n-        // The offset is into the object, so it's guaranteed to be non-negative.\n-        assert!(offset >= 0);\n-\n-        // The payload and the overall option are aligned,\n-        // so the offset will be a multiple of the alignment too.\n-        assert!((offset as usize) % mem::align_of::<T>() == 0);\n-\n-        let max_offset = mem::size_of::<Self>() - mem::size_of::<T>();\n-        if offset as usize <= max_offset {\n-            // There's enough space after this offset for a `T` to exist without\n-            // overflowing the bounds of the object, so let's try it.\n-            offset\n-        } else {\n-            // The offset guess is definitely wrong, so use the address\n-            // of the original option since we have it already.\n-            // This also correctly handles the case of layout-optimized enums\n-            // where `max_offset == 0` and thus this is the only possibility.\n-            0\n-        }\n-    };\n-\n     /// Returns a slice of the contained value, if any. If this is `None`, an\n     /// empty slice is returned. This can be useful to have a single type of\n     /// iterator over an `Option` or slice.\n@@ -809,28 +768,29 @@ impl<T> Option<T> {\n     #[must_use]\n     #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n     pub fn as_slice(&self) -> &[T] {\n-        let payload_ptr: *const T =\n-            // The goal here is that both arms here are calculating exactly\n-            // the same pointer, and thus it'll be folded away when the guessed\n-            // offset is correct, but if the guess is wrong for some reason\n-            // it'll at least still be sound, just no longer optimal.\n-            if let Some(payload) = self {\n-                payload\n-            } else {\n-                let self_ptr: *const Self = self;\n-                // SAFETY: `SOME_BYTE_OFFSET_GUESS` guarantees that its value is\n-                // such that this will be in-bounds of the object.\n-                unsafe { self_ptr.byte_offset(Self::SOME_BYTE_OFFSET_GUESS).cast() }\n-            };\n-        let len = usize::from(self.is_some());\n+        #[cfg(bootstrap)]\n+        match self {\n+            Some(value) => slice::from_ref(value),\n+            None => &[],\n+        }\n \n+        #[cfg(not(bootstrap))]\n         // SAFETY: When the `Option` is `Some`, we're using the actual pointer\n         // to the payload, with a length of 1, so this is equivalent to\n         // `slice::from_ref`, and thus is safe.\n         // When the `Option` is `None`, the length used is 0, so to be safe it\n         // just needs to be aligned, which it is because `&self` is aligned and\n         // the offset used is a multiple of alignment.\n-        unsafe { slice::from_raw_parts(payload_ptr, len) }\n+        //\n+        // In the new version, the intrinsic always returns a pointer to an\n+        // in-bounds and correctly aligned position for a `T` (even if in the\n+        // `None` case it's just padding).\n+        unsafe {\n+            slice::from_raw_parts(\n+                crate::intrinsics::option_payload_ptr(crate::ptr::from_ref(self)),\n+                usize::from(self.is_some()),\n+            )\n+        }\n     }\n \n     /// Returns a mutable slice of the contained value, if any. If this is\n@@ -875,28 +835,32 @@ impl<T> Option<T> {\n     #[must_use]\n     #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        let payload_ptr: *mut T =\n-            // The goal here is that both arms here are calculating exactly\n-            // the same pointer, and thus it'll be folded away when the guessed\n-            // offset is correct, but if the guess is wrong for some reason\n-            // it'll at least still be sound, just no longer optimal.\n-            if let Some(payload) = self {\n-                payload\n-            } else {\n-                let self_ptr: *mut Self = self;\n-                // SAFETY: `SOME_BYTE_OFFSET_GUESS` guarantees that its value is\n-                // such that this will be in-bounds of the object.\n-                unsafe { self_ptr.byte_offset(Self::SOME_BYTE_OFFSET_GUESS).cast() }\n-            };\n-        let len = usize::from(self.is_some());\n+        #[cfg(bootstrap)]\n+        match self {\n+            Some(value) => slice::from_mut(value),\n+            None => &mut [],\n+        }\n \n+        #[cfg(not(bootstrap))]\n         // SAFETY: When the `Option` is `Some`, we're using the actual pointer\n         // to the payload, with a length of 1, so this is equivalent to\n         // `slice::from_mut`, and thus is safe.\n         // When the `Option` is `None`, the length used is 0, so to be safe it\n         // just needs to be aligned, which it is because `&self` is aligned and\n         // the offset used is a multiple of alignment.\n-        unsafe { slice::from_raw_parts_mut(payload_ptr, len) }\n+        //\n+        // In the new version, the intrinsic creates a `*const T` from a\n+        // mutable reference  so it is safe to cast back to a mutable pointer\n+        // here. As with `as_slice`, the intrinsic always returns a pointer to\n+        // an in-bounds and correctly aligned position for a `T` (even if in\n+        // the `None` case it's just padding).\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                crate::intrinsics::option_payload_ptr(crate::ptr::from_mut(self).cast_const())\n+                    .cast_mut(),\n+                usize::from(self.is_some()),\n+            )\n+        }\n     }\n \n     /////////////////////////////////////////////////////////////////////////"}, {"sha": "772c3605562cfa1ab006f5a7d45fc1c0814ee3bf", "filename": "library/core/src/str/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -13,7 +13,7 @@ use super::from_utf8_unchecked;\n use super::pattern::Pattern;\n use super::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n use super::validations::{next_code_point, next_code_point_reverse};\n-use super::LinesAnyMap;\n+use super::LinesMap;\n use super::{BytesIsNotEmpty, UnsafeBytesToStr};\n use super::{CharEscapeDebugContinue, CharEscapeDefault, CharEscapeUnicode};\n use super::{IsAsciiWhitespace, IsNotEmpty, IsWhitespace};\n@@ -1104,7 +1104,7 @@ generate_pattern_iterators! {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[derive(Clone, Debug)]\n-pub struct Lines<'a>(pub(super) Map<SplitTerminator<'a, char>, LinesAnyMap>);\n+pub struct Lines<'a>(pub(super) Map<SplitInclusive<'a, char>, LinesMap>);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Lines<'a> {"}, {"sha": "2b23f64732b03b9680cb793300ec0984f3c8d0ec", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -1011,7 +1011,7 @@ impl str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn lines(&self) -> Lines<'_> {\n-        Lines(self.split_terminator('\\n').map(LinesAnyMap))\n+        Lines(self.split_inclusive('\\n').map(LinesMap))\n     }\n \n     /// An iterator over the lines of a string.\n@@ -2604,10 +2604,10 @@ impl Default for &mut str {\n impl_fn_for_zst! {\n     /// A nameable, cloneable fn type\n     #[derive(Clone)]\n-    struct LinesAnyMap impl<'a> Fn = |line: &'a str| -> &'a str {\n-        let l = line.len();\n-        if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n-        else { line }\n+    struct LinesMap impl<'a> Fn = |line: &'a str| -> &'a str {\n+        let Some(line) = line.strip_suffix('\\n') else { return line };\n+        let Some(line) = line.strip_suffix('\\r') else { return line };\n+        line\n     };\n \n     #[derive(Clone)]"}, {"sha": "83a6d0ad29279afd500fc3e98b500f8726095385", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -919,9 +919,9 @@ impl<'a> Builder<'a> {\n         host: TargetSelection,\n         target: TargetSelection,\n     ) -> Compiler {\n-        if self.build.force_use_stage2() {\n+        if self.build.force_use_stage2(stage) {\n             self.compiler(2, self.config.build)\n-        } else if self.build.force_use_stage1(Compiler { stage, host }, target) {\n+        } else if self.build.force_use_stage1(stage, target) {\n             self.compiler(1, self.config.build)\n         } else {\n             self.compiler(stage, host)"}, {"sha": "54aa5a585bbcb2ff3e16a3ff02610555e419a977", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -1204,19 +1204,20 @@ impl Build {\n     ///\n     /// When all of these conditions are met the build will lift artifacts from\n     /// the previous stage forward.\n-    fn force_use_stage1(&self, compiler: Compiler, target: TargetSelection) -> bool {\n+    fn force_use_stage1(&self, stage: u32, target: TargetSelection) -> bool {\n         !self.config.full_bootstrap\n-            && compiler.stage >= 2\n+            && !self.config.download_rustc()\n+            && stage >= 2\n             && (self.hosts.iter().any(|h| *h == target) || target == self.build)\n     }\n \n     /// Checks whether the `compiler` compiling for `target` should be forced to\n     /// use a stage2 compiler instead.\n     ///\n-    /// When we download the pre-compiled version of rustc it should be forced to\n-    /// use a stage2 compiler.\n-    fn force_use_stage2(&self) -> bool {\n-        self.config.download_rustc()\n+    /// When we download the pre-compiled version of rustc and compiler stage is >= 2,\n+    /// it should be forced to use a stage2 compiler.\n+    fn force_use_stage2(&self, stage: u32) -> bool {\n+        self.config.download_rustc() && stage >= 2\n     }\n \n     /// Given `num` in the form \"a.b.c\" return a \"release string\" which"}, {"sha": "f71aceff4550c121d8c965ee4f72174db6a28246", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -213,7 +213,7 @@ See the [Clang ControlFlowIntegrity documentation][clang-cfi] for more details.\n \n ## Example\n \n-```text\n+```rust,ignore\n #![feature(naked_functions)]\n \n use std::arch::asm;\n@@ -238,7 +238,7 @@ pub extern \"C\" fn add_two(x: i32) {\n              nop\n              nop\n              nop\n-             lea rax, [rdi+2]\n+             lea eax, [edi+2]\n              ret\n         \",\n             options(noreturn)"}, {"sha": "768f8bb7bc899aa7b42da8b7d6c641da4f05f4d3", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 23, "deletions": 52, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -36,15 +36,11 @@ use crate::formats::item_type::ItemType;\n ///\n /// The returned value is `None` if the definition could not be inlined,\n /// and `Some` of a vector of items if it was successfully expanded.\n-///\n-/// `parent_module` refers to the parent of the *re-export*, not the original item.\n pub(crate) fn try_inline(\n     cx: &mut DocContext<'_>,\n-    parent_module: DefId,\n-    import_def_id: Option<DefId>,\n     res: Res,\n     name: Symbol,\n-    attrs: Option<&[ast::Attribute]>,\n+    attrs: Option<(&[ast::Attribute], Option<DefId>)>,\n     visited: &mut DefIdSet,\n ) -> Option<Vec<clean::Item>> {\n     let did = res.opt_def_id()?;\n@@ -55,38 +51,17 @@ pub(crate) fn try_inline(\n \n     debug!(\"attrs={:?}\", attrs);\n \n-    let attrs_without_docs = attrs.map(|attrs| {\n-        attrs.into_iter().filter(|a| a.doc_str().is_none()).cloned().collect::<Vec<_>>()\n+    let attrs_without_docs = attrs.map(|(attrs, def_id)| {\n+        (attrs.into_iter().filter(|a| a.doc_str().is_none()).cloned().collect::<Vec<_>>(), def_id)\n     });\n-    // We need this ugly code because:\n-    //\n-    // ```\n-    // attrs_without_docs.map(|a| a.as_slice())\n-    // ```\n-    //\n-    // will fail because it returns a temporary slice and:\n-    //\n-    // ```\n-    // attrs_without_docs.map(|s| {\n-    //     vec = s.as_slice();\n-    //     vec\n-    // })\n-    // ```\n-    //\n-    // will fail because we're moving an uninitialized variable into a closure.\n-    let vec;\n-    let attrs_without_docs = match attrs_without_docs {\n-        Some(s) => {\n-            vec = s;\n-            Some(vec.as_slice())\n-        }\n-        None => None,\n-    };\n+    let attrs_without_docs =\n+        attrs_without_docs.as_ref().map(|(attrs, def_id)| (&attrs[..], *def_id));\n \n+    let import_def_id = attrs.and_then(|(_, def_id)| def_id);\n     let kind = match res {\n         Res::Def(DefKind::Trait, did) => {\n             record_extern_fqn(cx, did, ItemType::Trait);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::TraitItem(Box::new(build_external_trait(cx, did)))\n         }\n         Res::Def(DefKind::Fn, did) => {\n@@ -95,27 +70,27 @@ pub(crate) fn try_inline(\n         }\n         Res::Def(DefKind::Struct, did) => {\n             record_extern_fqn(cx, did, ItemType::Struct);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::StructItem(build_struct(cx, did))\n         }\n         Res::Def(DefKind::Union, did) => {\n             record_extern_fqn(cx, did, ItemType::Union);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::UnionItem(build_union(cx, did))\n         }\n         Res::Def(DefKind::TyAlias, did) => {\n             record_extern_fqn(cx, did, ItemType::Typedef);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::TypedefItem(build_type_alias(cx, did))\n         }\n         Res::Def(DefKind::Enum, did) => {\n             record_extern_fqn(cx, did, ItemType::Enum);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::EnumItem(build_enum(cx, did))\n         }\n         Res::Def(DefKind::ForeignTy, did) => {\n             record_extern_fqn(cx, did, ItemType::ForeignType);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::ForeignTypeItem\n         }\n         // Never inline enum variants but leave them shown as re-exports.\n@@ -149,7 +124,7 @@ pub(crate) fn try_inline(\n         _ => return None,\n     };\n \n-    let (attrs, cfg) = merge_attrs(cx, Some(parent_module), load_attrs(cx, did), attrs);\n+    let (attrs, cfg) = merge_attrs(cx, load_attrs(cx, did), attrs);\n     cx.inlined.insert(did.into());\n     let mut item =\n         clean::Item::from_def_id_and_attrs_and_parts(did, Some(name), kind, Box::new(attrs), cfg);\n@@ -316,17 +291,16 @@ fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> Box<clean::Typedef>\n /// Builds all inherent implementations of an ADT (struct/union/enum) or Trait item/path/reexport.\n pub(crate) fn build_impls(\n     cx: &mut DocContext<'_>,\n-    parent_module: Option<DefId>,\n     did: DefId,\n-    attrs: Option<&[ast::Attribute]>,\n+    attrs: Option<(&[ast::Attribute], Option<DefId>)>,\n     ret: &mut Vec<clean::Item>,\n ) {\n     let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_inherent_impls\");\n     let tcx = cx.tcx;\n \n     // for each implementation of an item represented by `did`, build the clean::Item for that impl\n     for &did in tcx.inherent_impls(did).iter() {\n-        build_impl(cx, parent_module, did, attrs, ret);\n+        build_impl(cx, did, attrs, ret);\n     }\n \n     // This pretty much exists expressly for `dyn Error` traits that exist in the `alloc` crate.\n@@ -340,28 +314,26 @@ pub(crate) fn build_impls(\n         let type_ =\n             if tcx.is_trait(did) { TraitSimplifiedType(did) } else { AdtSimplifiedType(did) };\n         for &did in tcx.incoherent_impls(type_) {\n-            build_impl(cx, parent_module, did, attrs, ret);\n+            build_impl(cx, did, attrs, ret);\n         }\n     }\n }\n \n-/// `parent_module` refers to the parent of the re-export, not the original item\n pub(crate) fn merge_attrs(\n     cx: &mut DocContext<'_>,\n-    parent_module: Option<DefId>,\n     old_attrs: &[ast::Attribute],\n-    new_attrs: Option<&[ast::Attribute]>,\n+    new_attrs: Option<(&[ast::Attribute], Option<DefId>)>,\n ) -> (clean::Attributes, Option<Arc<clean::cfg::Cfg>>) {\n     // NOTE: If we have additional attributes (from a re-export),\n     // always insert them first. This ensure that re-export\n     // doc comments show up before the original doc comments\n     // when we render them.\n-    if let Some(inner) = new_attrs {\n+    if let Some((inner, item_id)) = new_attrs {\n         let mut both = inner.to_vec();\n         both.extend_from_slice(old_attrs);\n         (\n-            if let Some(new_id) = parent_module {\n-                Attributes::from_ast_with_additional(old_attrs, (inner, new_id))\n+            if let Some(item_id) = item_id {\n+                Attributes::from_ast_with_additional(old_attrs, (inner, item_id))\n             } else {\n                 Attributes::from_ast(&both)\n             },\n@@ -375,9 +347,8 @@ pub(crate) fn merge_attrs(\n /// Inline an `impl`, inherent or of a trait. The `did` must be for an `impl`.\n pub(crate) fn build_impl(\n     cx: &mut DocContext<'_>,\n-    parent_module: Option<DefId>,\n     did: DefId,\n-    attrs: Option<&[ast::Attribute]>,\n+    attrs: Option<(&[ast::Attribute], Option<DefId>)>,\n     ret: &mut Vec<clean::Item>,\n ) {\n     if !cx.inlined.insert(did.into()) {\n@@ -539,7 +510,7 @@ pub(crate) fn build_impl(\n         record_extern_trait(cx, did);\n     }\n \n-    let (merged_attrs, cfg) = merge_attrs(cx, parent_module, load_attrs(cx, did), attrs);\n+    let (merged_attrs, cfg) = merge_attrs(cx, load_attrs(cx, did), attrs);\n     trace!(\"merged_attrs={:?}\", merged_attrs);\n \n     trace!(\n@@ -635,7 +606,7 @@ fn build_module_items(\n                     cfg: None,\n                     inline_stmt_id: None,\n                 });\n-            } else if let Some(i) = try_inline(cx, did, None, res, item.ident.name, None, visited) {\n+            } else if let Some(i) = try_inline(cx, res, item.ident.name, None, visited) {\n                 items.extend(i)\n             }\n         }"}, {"sha": "2e1f456f50e2f4f6c4a65504214b817d6e399771", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -2388,12 +2388,12 @@ fn clean_maybe_renamed_item<'tcx>(\n             target_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n         }\n \n-        let import_parent = import_id.map(|import_id| cx.tcx.local_parent(import_id).to_def_id());\n-        let (attrs, cfg) =  merge_attrs(cx, import_parent, &target_attrs, Some(&import_attrs));\n+        let import_id = import_id.map(|def_id| def_id.to_def_id());\n+        let (attrs, cfg) =  merge_attrs(cx, &target_attrs, Some((&import_attrs, import_id)));\n \n         let mut item =\n             Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);\n-        item.inline_stmt_id = import_id.map(|def_id| def_id.to_def_id());\n+        item.inline_stmt_id = import_id;\n         vec![item]\n     })\n }\n@@ -2478,18 +2478,12 @@ fn clean_extern_crate<'tcx>(\n \n     let krate_owner_def_id = krate.owner_id.to_def_id();\n     if please_inline {\n-        let mut visited = DefIdSet::default();\n-\n-        let res = Res::Def(DefKind::Mod, crate_def_id);\n-\n         if let Some(items) = inline::try_inline(\n             cx,\n-            cx.tcx.parent_module(krate.hir_id()).to_def_id(),\n-            Some(krate_owner_def_id),\n-            res,\n+            Res::Def(DefKind::Mod, crate_def_id),\n             name,\n-            Some(attrs),\n-            &mut visited,\n+            Some((attrs, Some(krate_owner_def_id))),\n+            &mut Default::default(),\n         ) {\n             return items;\n         }\n@@ -2613,17 +2607,13 @@ fn clean_use_statement_inner<'tcx>(\n             denied = true;\n         }\n         if !denied {\n-            let mut visited = DefIdSet::default();\n             let import_def_id = import.owner_id.to_def_id();\n-\n             if let Some(mut items) = inline::try_inline(\n                 cx,\n-                cx.tcx.parent_module(import.hir_id()).to_def_id(),\n-                Some(import_def_id),\n                 path.res,\n                 name,\n-                Some(attrs),\n-                &mut visited,\n+                Some((attrs, Some(import_def_id))),\n+                &mut Default::default(),\n             ) {\n                 items.push(Item::from_def_id_and_parts(\n                     import_def_id,"}, {"sha": "8f2331785f50d6cbce2dac033a8e0ade60c6d534", "filename": "src/librustdoc/clean/types/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -10,7 +10,7 @@ use rustc_span::symbol::Symbol;\n fn create_doc_fragment(s: &str) -> Vec<DocFragment> {\n     vec![DocFragment {\n         span: DUMMY_SP,\n-        parent_module: None,\n+        item_id: None,\n         doc: Symbol::intern(s),\n         kind: DocFragmentKind::SugaredDoc,\n         indent: 0,"}, {"sha": "cca50df0db2136caf765307222c515d65eb8f097", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -195,12 +195,12 @@ pub(crate) fn build_deref_target_impls(\n         if let Some(prim) = target.primitive_type() {\n             let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_primitive_inherent_impls\");\n             for did in prim.impls(tcx).filter(|did| !did.is_local()) {\n-                inline::build_impl(cx, None, did, None, ret);\n+                inline::build_impl(cx, did, None, ret);\n             }\n         } else if let Type::Path { path } = target {\n             let did = path.def_id();\n             if !did.is_local() {\n-                inline::build_impls(cx, None, did, None, ret);\n+                inline::build_impls(cx, did, None, ret);\n             }\n         }\n     }"}, {"sha": "c099d0e4f3f4707b94808ea7dbc5e620ecd0fe2c", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 21, "deletions": 38, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -65,23 +65,6 @@ pub(crate) fn render_item_decl_with_highlighting(src: &str, out: &mut Buffer) {\n     write!(out, \"</pre>\");\n }\n \n-/// Highlights `src` as a source code page, returning the HTML output.\n-pub(crate) fn render_source_with_highlighting(\n-    src: &str,\n-    out: &mut Buffer,\n-    line_numbers: Buffer,\n-    href_context: HrefContext<'_, '_>,\n-    decoration_info: DecorationInfo,\n-    extra: Option<&str>,\n-) {\n-    write_header(out, \"\", Some(line_numbers), Tooltip::None);\n-    if let Some(extra) = extra {\n-        out.push_str(extra);\n-    }\n-    write_code(out, src, Some(href_context), Some(decoration_info));\n-    write_footer(out, None);\n-}\n-\n fn write_header(out: &mut Buffer, class: &str, extra_content: Option<Buffer>, tooltip: Tooltip) {\n     write!(\n         out,\n@@ -143,8 +126,8 @@ fn can_merge(class1: Option<Class>, class2: Option<Class>, text: &str) -> bool {\n \n /// This type is used as a conveniency to prevent having to pass all its fields as arguments into\n /// the various functions (which became its methods).\n-struct TokenHandler<'a, 'tcx> {\n-    out: &'a mut Buffer,\n+struct TokenHandler<'a, 'tcx, F: Write> {\n+    out: &'a mut F,\n     /// It contains the closing tag and the associated `Class`.\n     closing_tags: Vec<(&'static str, Class)>,\n     /// This is used because we don't automatically generate the closing tag on `ExitSpan` in\n@@ -159,7 +142,7 @@ struct TokenHandler<'a, 'tcx> {\n     href_context: Option<HrefContext<'a, 'tcx>>,\n }\n \n-impl<'a, 'tcx> TokenHandler<'a, 'tcx> {\n+impl<'a, 'tcx, F: Write> TokenHandler<'a, 'tcx, F> {\n     fn handle_exit_span(&mut self) {\n         // We can't get the last `closing_tags` element using `pop()` because `closing_tags` is\n         // being used in `write_pending_elems`.\n@@ -211,7 +194,7 @@ impl<'a, 'tcx> TokenHandler<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Drop for TokenHandler<'a, 'tcx> {\n+impl<'a, 'tcx, F: Write> Drop for TokenHandler<'a, 'tcx, F> {\n     /// When leaving, we need to flush all pending data to not have missing content.\n     fn drop(&mut self) {\n         if self.pending_exit_span.is_some() {\n@@ -233,8 +216,8 @@ impl<'a, 'tcx> Drop for TokenHandler<'a, 'tcx> {\n /// item definition.\n ///\n /// More explanations about spans and how we use them here are provided in the\n-fn write_code(\n-    out: &mut Buffer,\n+pub(super) fn write_code(\n+    out: &mut impl Write,\n     src: &str,\n     href_context: Option<HrefContext<'_, '_>>,\n     decoration_info: Option<DecorationInfo>,\n@@ -883,7 +866,7 @@ impl<'src> Classifier<'src> {\n /// Called when we start processing a span of text that should be highlighted.\n /// The `Class` argument specifies how it should be highlighted.\n fn enter_span(\n-    out: &mut Buffer,\n+    out: &mut impl Write,\n     klass: Class,\n     href_context: &Option<HrefContext<'_, '_>>,\n ) -> &'static str {\n@@ -894,8 +877,8 @@ fn enter_span(\n }\n \n /// Called at the end of a span of highlighted text.\n-fn exit_span(out: &mut Buffer, closing_tag: &str) {\n-    out.write_str(closing_tag);\n+fn exit_span(out: &mut impl Write, closing_tag: &str) {\n+    out.write_str(closing_tag).unwrap();\n }\n \n /// Called for a span of text. If the text should be highlighted differently\n@@ -915,15 +898,15 @@ fn exit_span(out: &mut Buffer, closing_tag: &str) {\n /// will then try to find this `span` in the `span_correspondance_map`. If found, it'll then\n /// generate a link for this element (which corresponds to where its definition is located).\n fn string<T: Display>(\n-    out: &mut Buffer,\n+    out: &mut impl Write,\n     text: T,\n     klass: Option<Class>,\n     href_context: &Option<HrefContext<'_, '_>>,\n     open_tag: bool,\n ) {\n     if let Some(closing_tag) = string_without_closing_tag(out, text, klass, href_context, open_tag)\n     {\n-        out.write_str(closing_tag);\n+        out.write_str(closing_tag).unwrap();\n     }\n }\n \n@@ -937,24 +920,24 @@ fn string<T: Display>(\n ///   in `span_map.rs::collect_spans_and_sources`. If it cannot retrieve the information, then it's\n ///   the same as the second point (`klass` is `Some` but doesn't have a [`rustc_span::Span`]).\n fn string_without_closing_tag<T: Display>(\n-    out: &mut Buffer,\n+    out: &mut impl Write,\n     text: T,\n     klass: Option<Class>,\n     href_context: &Option<HrefContext<'_, '_>>,\n     open_tag: bool,\n ) -> Option<&'static str> {\n     let Some(klass) = klass\n     else {\n-        write!(out, \"{}\", text);\n+        write!(out, \"{}\", text).unwrap();\n         return None;\n     };\n     let Some(def_span) = klass.get_span()\n     else {\n         if !open_tag {\n-            write!(out, \"{}\", text);\n+            write!(out, \"{}\", text).unwrap();\n             return None;\n         }\n-        write!(out, \"<span class=\\\"{}\\\">{}\", klass.as_html(), text);\n+        write!(out, \"<span class=\\\"{}\\\">{}\", klass.as_html(), text).unwrap();\n         return Some(\"</span>\");\n     };\n \n@@ -1009,28 +992,28 @@ fn string_without_closing_tag<T: Display>(\n             if !open_tag {\n                 // We're already inside an element which has the same klass, no need to give it\n                 // again.\n-                write!(out, \"<a href=\\\"{}\\\">{}\", href, text_s);\n+                write!(out, \"<a href=\\\"{}\\\">{}\", href, text_s).unwrap();\n             } else {\n                 let klass_s = klass.as_html();\n                 if klass_s.is_empty() {\n-                    write!(out, \"<a href=\\\"{}\\\">{}\", href, text_s);\n+                    write!(out, \"<a href=\\\"{}\\\">{}\", href, text_s).unwrap();\n                 } else {\n-                    write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}\", klass_s, href, text_s);\n+                    write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}\", klass_s, href, text_s).unwrap();\n                 }\n             }\n             return Some(\"</a>\");\n         }\n     }\n     if !open_tag {\n-        write!(out, \"{}\", text_s);\n+        write!(out, \"{}\", text_s).unwrap();\n         return None;\n     }\n     let klass_s = klass.as_html();\n     if klass_s.is_empty() {\n-        write!(out, \"{}\", text_s);\n+        out.write_str(&text_s).unwrap();\n         Some(\"\")\n     } else {\n-        write!(out, \"<span class=\\\"{}\\\">{}\", klass_s, text_s);\n+        write!(out, \"<span class=\\\"{}\\\">{}\", klass_s, text_s).unwrap();\n         Some(\"</span>\")\n     }\n }"}, {"sha": "1d298f52f7588d2b08b163d6bd986beb665c5044", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -1,12 +1,14 @@\n use crate::clean;\n use crate::docfs::PathError;\n use crate::error::Error;\n+use crate::html::format;\n use crate::html::format::Buffer;\n use crate::html::highlight;\n use crate::html::layout;\n use crate::html::render::Context;\n use crate::visit::DocVisitor;\n \n+use askama::Template;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::TyCtxt;\n@@ -16,6 +18,7 @@ use rustc_span::source_map::FileName;\n use std::cell::RefCell;\n use std::ffi::OsStr;\n use std::fs;\n+use std::ops::RangeInclusive;\n use std::path::{Component, Path, PathBuf};\n use std::rc::Rc;\n \n@@ -299,39 +302,32 @@ pub(crate) fn print_src(\n     decoration_info: highlight::DecorationInfo,\n     source_context: SourceContext,\n ) {\n+    #[derive(Template)]\n+    #[template(path = \"source.html\")]\n+    struct Source<Code: std::fmt::Display> {\n+        embedded: bool,\n+        needs_expansion: bool,\n+        lines: RangeInclusive<usize>,\n+        code_html: Code,\n+    }\n     let lines = s.lines().count();\n-    let mut line_numbers = Buffer::empty_from(buf);\n-    let extra;\n-    line_numbers.write_str(\"<pre class=\\\"src-line-numbers\\\">\");\n+    let (embedded, needs_expansion, lines) = match source_context {\n+        SourceContext::Standalone => (false, false, 1..=lines),\n+        SourceContext::Embedded { offset, needs_expansion } => {\n+            (true, needs_expansion, (1 + offset)..=(lines + offset))\n+        }\n+    };\n     let current_href = context\n         .href_from_span(clean::Span::new(file_span), false)\n         .expect(\"only local crates should have sources emitted\");\n-    match source_context {\n-        SourceContext::Standalone => {\n-            extra = None;\n-            for line in 1..=lines {\n-                writeln!(line_numbers, \"<a href=\\\"#{line}\\\" id=\\\"{line}\\\">{line}</a>\")\n-            }\n-        }\n-        SourceContext::Embedded { offset, needs_expansion } => {\n-            extra = if needs_expansion {\n-                Some(r#\"<button class=\"expand\">&varr;</button>\"#)\n-            } else {\n-                None\n-            };\n-            for line_number in 1..=lines {\n-                let line = line_number + offset;\n-                writeln!(line_numbers, \"<span>{line}</span>\")\n-            }\n-        }\n-    }\n-    line_numbers.write_str(\"</pre>\");\n-    highlight::render_source_with_highlighting(\n-        s,\n-        buf,\n-        line_numbers,\n-        highlight::HrefContext { context, file_span, root_path, current_href },\n-        decoration_info,\n-        extra,\n-    );\n+    let code = format::display_fn(move |fmt| {\n+        highlight::write_code(\n+            fmt,\n+            s,\n+            Some(highlight::HrefContext { context, file_span, root_path, current_href }),\n+            Some(decoration_info),\n+        );\n+        Ok(())\n+    });\n+    Source { embedded, needs_expansion, lines, code_html: code }.render_into(buf).unwrap();\n }"}, {"sha": "a224ff12f448eea51ad06ee29d42dfc7af61d75f", "filename": "src/librustdoc/html/templates/source.html", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsource.html", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsource.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsource.html?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -0,0 +1,19 @@\n+<div class=\"example-wrap\"> {# #}\n+    <pre class=\"src-line-numbers\">\n+        {% for line in lines.clone() %}\n+            {% if embedded %}\n+                <span>{{line|safe}}</span>\n+            {%~ else %}\n+                <a href=\"#{{line|safe}}\" id=\"{{line|safe}}\">{{line|safe}}</a>\n+            {%~ endif %}\n+        {% endfor %}\n+    </pre> {# #}\n+    <pre class=\"rust\"> {# #}\n+        <code>\n+            {% if needs_expansion %}\n+                <button class=\"expand\">&varr;</button>\n+            {% endif %}\n+            {{code_html|safe}}\n+        </code> {# #}\n+    </pre> {# #}\n+</div>"}, {"sha": "789523c561e57533783113e37ce5ea41ebe72140", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 63, "deletions": 100, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -28,7 +28,7 @@ use std::mem;\n use std::ops::Range;\n \n use crate::clean::{self, utils::find_nearest_parent_module};\n-use crate::clean::{Crate, Item, ItemId, ItemLink, PrimitiveType};\n+use crate::clean::{Crate, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::html::markdown::{markdown_links, MarkdownLink};\n use crate::lint::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS};\n@@ -42,8 +42,7 @@ pub(crate) const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n };\n \n fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n-    let mut collector =\n-        LinkCollector { cx, mod_ids: Vec::new(), visited_links: FxHashMap::default() };\n+    let mut collector = LinkCollector { cx, visited_links: FxHashMap::default() };\n     collector.visit_crate(&krate);\n     krate\n }\n@@ -149,7 +148,7 @@ impl TryFrom<ResolveRes> for Res {\n #[derive(Debug)]\n struct UnresolvedPath<'a> {\n     /// Item on which the link is resolved, used for resolving `Self`.\n-    item_id: ItemId,\n+    item_id: DefId,\n     /// The scope the link was resolved in.\n     module_id: DefId,\n     /// If part of the link resolved, this has the `Res`.\n@@ -225,7 +224,7 @@ impl UrlFragment {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n struct ResolutionInfo {\n-    item_id: ItemId,\n+    item_id: DefId,\n     module_id: DefId,\n     dis: Option<Disambiguator>,\n     path_str: Box<str>,\n@@ -242,11 +241,6 @@ struct DiagnosticInfo<'a> {\n \n struct LinkCollector<'a, 'tcx> {\n     cx: &'a mut DocContext<'tcx>,\n-    /// A stack of modules used to decide what scope to resolve in.\n-    ///\n-    /// The last module will be used if the parent scope of the current item is\n-    /// unknown.\n-    mod_ids: Vec<DefId>,\n     /// Cache the resolved links so we can avoid resolving (and emitting errors for) the same link.\n     /// The link will be `None` if it could not be resolved (i.e. the error was cached).\n     visited_links: FxHashMap<ResolutionInfo, Option<(Res, Option<UrlFragment>)>>,\n@@ -262,7 +256,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn variant_field<'path>(\n         &self,\n         path_str: &'path str,\n-        item_id: ItemId,\n+        item_id: DefId,\n         module_id: DefId,\n     ) -> Result<(Res, DefId), UnresolvedPath<'path>> {\n         let tcx = self.cx.tcx;\n@@ -333,35 +327,33 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         })\n     }\n \n-    fn resolve_self_ty(&self, path_str: &str, ns: Namespace, item_id: ItemId) -> Option<Res> {\n+    fn resolve_self_ty(&self, path_str: &str, ns: Namespace, item_id: DefId) -> Option<Res> {\n         if ns != TypeNS || path_str != \"Self\" {\n             return None;\n         }\n \n         let tcx = self.cx.tcx;\n-        item_id\n-            .as_def_id()\n-            .map(|def_id| match tcx.def_kind(def_id) {\n-                def_kind @ (DefKind::AssocFn\n-                | DefKind::AssocConst\n-                | DefKind::AssocTy\n-                | DefKind::Variant\n-                | DefKind::Field) => {\n-                    let parent_def_id = tcx.parent(def_id);\n-                    if def_kind == DefKind::Field && tcx.def_kind(parent_def_id) == DefKind::Variant\n-                    {\n-                        tcx.parent(parent_def_id)\n-                    } else {\n-                        parent_def_id\n-                    }\n+        let self_id = match tcx.def_kind(item_id) {\n+            def_kind @ (DefKind::AssocFn\n+            | DefKind::AssocConst\n+            | DefKind::AssocTy\n+            | DefKind::Variant\n+            | DefKind::Field) => {\n+                let parent_def_id = tcx.parent(item_id);\n+                if def_kind == DefKind::Field && tcx.def_kind(parent_def_id) == DefKind::Variant {\n+                    tcx.parent(parent_def_id)\n+                } else {\n+                    parent_def_id\n                 }\n-                _ => def_id,\n-            })\n-            .and_then(|self_id| match tcx.def_kind(self_id) {\n-                DefKind::Impl { .. } => self.def_id_to_res(self_id),\n-                DefKind::Use => None,\n-                def_kind => Some(Res::Def(def_kind, self_id)),\n-            })\n+            }\n+            _ => item_id,\n+        };\n+\n+        match tcx.def_kind(self_id) {\n+            DefKind::Impl { .. } => self.def_id_to_res(self_id),\n+            DefKind::Use => None,\n+            def_kind => Some(Res::Def(def_kind, self_id)),\n+        }\n     }\n \n     /// Convenience wrapper around `doc_link_resolutions`.\n@@ -373,7 +365,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &self,\n         path_str: &str,\n         ns: Namespace,\n-        item_id: ItemId,\n+        item_id: DefId,\n         module_id: DefId,\n     ) -> Option<Res> {\n         if let res @ Some(..) = self.resolve_self_ty(path_str, ns, item_id) {\n@@ -400,7 +392,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &mut self,\n         path_str: &'path str,\n         ns: Namespace,\n-        item_id: ItemId,\n+        item_id: DefId,\n         module_id: DefId,\n     ) -> Result<(Res, Option<DefId>), UnresolvedPath<'path>> {\n         if let Some(res) = self.resolve_path(path_str, ns, item_id, module_id) {\n@@ -779,48 +771,8 @@ fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_\n \n impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n-        let parent_node =\n-            item.item_id.as_def_id().and_then(|did| find_nearest_parent_module(self.cx.tcx, did));\n-        if parent_node.is_some() {\n-            trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.item_id);\n-        }\n-\n-        let inner_docs = item.inner_docs(self.cx.tcx);\n-\n-        if item.is_mod() && inner_docs {\n-            self.mod_ids.push(item.item_id.expect_def_id());\n-        }\n-\n-        // We want to resolve in the lexical scope of the documentation.\n-        // In the presence of re-exports, this is not the same as the module of the item.\n-        // Rather than merging all documentation into one, resolve it one attribute at a time\n-        // so we know which module it came from.\n-        for (parent_module, doc) in prepare_to_doc_link_resolution(&item.attrs.doc_strings) {\n-            if !may_have_doc_links(&doc) {\n-                continue;\n-            }\n-            debug!(\"combined_docs={}\", doc);\n-            // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n-            // This is a degenerate case and it's not supported by rustdoc.\n-            let parent_node = parent_module.or(parent_node);\n-            for md_link in preprocessed_markdown_links(&doc) {\n-                let link = self.resolve_link(item, &doc, parent_node, &md_link);\n-                if let Some(link) = link {\n-                    self.cx.cache.intra_doc_links.entry(item.item_id).or_default().push(link);\n-                }\n-            }\n-        }\n-\n-        if item.is_mod() {\n-            if !inner_docs {\n-                self.mod_ids.push(item.item_id.expect_def_id());\n-            }\n-\n-            self.visit_item_recur(item);\n-            self.mod_ids.pop();\n-        } else {\n-            self.visit_item_recur(item)\n-        }\n+        self.resolve_links(item);\n+        self.visit_item_recur(item)\n     }\n }\n \n@@ -946,14 +898,41 @@ fn preprocessed_markdown_links(s: &str) -> Vec<PreprocessedMarkdownLink> {\n }\n \n impl LinkCollector<'_, '_> {\n+    fn resolve_links(&mut self, item: &Item) {\n+        // We want to resolve in the lexical scope of the documentation.\n+        // In the presence of re-exports, this is not the same as the module of the item.\n+        // Rather than merging all documentation into one, resolve it one attribute at a time\n+        // so we know which module it came from.\n+        for (item_id, doc) in prepare_to_doc_link_resolution(&item.attrs.doc_strings) {\n+            if !may_have_doc_links(&doc) {\n+                continue;\n+            }\n+            debug!(\"combined_docs={}\", doc);\n+            // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n+            // This is a degenerate case and it's not supported by rustdoc.\n+            let item_id = item_id.unwrap_or_else(|| item.item_id.expect_def_id());\n+            let module_id = match self.cx.tcx.def_kind(item_id) {\n+                DefKind::Mod if item.inner_docs(self.cx.tcx) => item_id,\n+                _ => find_nearest_parent_module(self.cx.tcx, item_id).unwrap(),\n+            };\n+            for md_link in preprocessed_markdown_links(&doc) {\n+                let link = self.resolve_link(item, item_id, module_id, &doc, &md_link);\n+                if let Some(link) = link {\n+                    self.cx.cache.intra_doc_links.entry(item.item_id).or_default().push(link);\n+                }\n+            }\n+        }\n+    }\n+\n     /// This is the entry point for resolving an intra-doc link.\n     ///\n     /// FIXME(jynelson): this is way too many arguments\n     fn resolve_link(\n         &mut self,\n         item: &Item,\n+        item_id: DefId,\n+        module_id: DefId,\n         dox: &str,\n-        parent_node: Option<DefId>,\n         link: &PreprocessedMarkdownLink,\n     ) -> Option<ItemLink> {\n         let PreprocessedMarkdownLink(pp_link, ori_link) = link;\n@@ -970,25 +949,9 @@ impl LinkCollector<'_, '_> {\n             pp_link.as_ref().map_err(|err| err.report(self.cx, diag_info.clone())).ok()?;\n         let disambiguator = *disambiguator;\n \n-        // In order to correctly resolve intra-doc links we need to\n-        // pick a base AST node to work from.  If the documentation for\n-        // this module came from an inner comment (//!) then we anchor\n-        // our name resolution *inside* the module.  If, on the other\n-        // hand it was an outer comment (///) then we anchor the name\n-        // resolution in the parent module on the basis that the names\n-        // used are more likely to be intended to be parent names.  For\n-        // this, we set base_node to None for inner comments since\n-        // we've already pushed this node onto the resolution stack but\n-        // for outer comments we explicitly try and resolve against the\n-        // parent_node first.\n-        let inner_docs = item.inner_docs(self.cx.tcx);\n-        let base_node =\n-            if item.is_mod() && inner_docs { self.mod_ids.last().copied() } else { parent_node };\n-        let module_id = base_node.expect(\"doc link without parent module\");\n-\n         let (mut res, fragment) = self.resolve_with_disambiguator_cached(\n             ResolutionInfo {\n-                item_id: item.item_id,\n+                item_id,\n                 module_id,\n                 dis: disambiguator,\n                 path_str: path_str.clone(),\n@@ -1229,11 +1192,11 @@ impl LinkCollector<'_, '_> {\n         let disambiguator = key.dis;\n         let path_str = &key.path_str;\n         let item_id = key.item_id;\n-        let base_node = key.module_id;\n+        let module_id = key.module_id;\n \n         match disambiguator.map(Disambiguator::ns) {\n             Some(expected_ns) => {\n-                match self.resolve(path_str, expected_ns, item_id, base_node) {\n+                match self.resolve(path_str, expected_ns, item_id, module_id) {\n                     Ok(res) => Some(res),\n                     Err(err) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n@@ -1243,7 +1206,7 @@ impl LinkCollector<'_, '_> {\n                         for other_ns in [TypeNS, ValueNS, MacroNS] {\n                             if other_ns != expected_ns {\n                                 if let Ok(res) =\n-                                    self.resolve(path_str, other_ns, item_id, base_node)\n+                                    self.resolve(path_str, other_ns, item_id, module_id)\n                                 {\n                                     err = ResolutionFailure::WrongNamespace {\n                                         res: full_res(self.cx.tcx, res),\n@@ -1260,7 +1223,7 @@ impl LinkCollector<'_, '_> {\n             None => {\n                 // Try everything!\n                 let mut candidate = |ns| {\n-                    self.resolve(path_str, ns, item_id, base_node)\n+                    self.resolve(path_str, ns, item_id, module_id)\n                         .map_err(ResolutionFailure::NotResolved)\n                 };\n "}, {"sha": "8d204ddb79e3976f5e63749e0faf5042a3e071d7", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -49,7 +49,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n         let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_extern_trait_impls\");\n         for &cnum in cx.tcx.crates(()) {\n             for &impl_def_id in cx.tcx.trait_impls_in_crate(cnum) {\n-                inline::build_impl(cx, None, impl_def_id, None, &mut new_items_external);\n+                inline::build_impl(cx, impl_def_id, None, &mut new_items_external);\n             }\n         }\n     }\n@@ -75,7 +75,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n                 );\n                 parent = cx.tcx.opt_parent(did);\n             }\n-            inline::build_impl(cx, None, impl_def_id, Some(&attr_buf), &mut new_items_local);\n+            inline::build_impl(cx, impl_def_id, Some((&attr_buf, None)), &mut new_items_local);\n             attr_buf.clear();\n         }\n     }\n@@ -84,7 +84,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n         for def_id in PrimitiveType::all_impls(cx.tcx) {\n             // Try to inline primitive impls from other crates.\n             if !def_id.is_local() {\n-                inline::build_impl(cx, None, def_id, None, &mut new_items_external);\n+                inline::build_impl(cx, def_id, None, &mut new_items_external);\n             }\n         }\n         for (prim, did) in PrimitiveType::primitive_locations(cx.tcx) {"}, {"sha": "8a33e51b3beb1acac3dc621db268dd738235787b", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -57,7 +57,8 @@ impl<'a, 'tcx> CfgPropagator<'a, 'tcx> {\n             next_def_id = parent_def_id;\n         }\n \n-        let (_, cfg) = merge_attrs(self.cx, None, item.attrs.other_attrs.as_slice(), Some(&attrs));\n+        let (_, cfg) =\n+            merge_attrs(self.cx, item.attrs.other_attrs.as_slice(), Some((&attrs, None)));\n         item.cfg = cfg;\n     }\n }"}, {"sha": "cc1964de332c2183daeed04465116d58f5a5e164", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -812,7 +812,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     }\n \n     #[inline(always)]\n-    fn enforce_validity(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n+    fn enforce_validity(ecx: &MiriInterpCx<'mir, 'tcx>, _layout: TyAndLayout<'tcx>) -> bool {\n         ecx.machine.validate\n     }\n "}, {"sha": "e535141e772f816770805a0b1336592a27653338", "filename": "tests/mir-opt/lower_intrinsics.option_payload.LowerIntrinsics.diff", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -0,0 +1,54 @@\n+- // MIR for `option_payload` before LowerIntrinsics\n++ // MIR for `option_payload` after LowerIntrinsics\n+  \n+  fn option_payload(_1: &Option<usize>, _2: &Option<String>) -> () {\n+      debug o => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:23: +0:24\n+      debug p => _2;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:42: +0:43\n+      let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:62: +0:62\n+      let mut _4: *const std::option::Option<usize>; // in scope 0 at $DIR/lower_intrinsics.rs:+2:55: +2:56\n+      let mut _6: *const std::option::Option<std::string::String>; // in scope 0 at $DIR/lower_intrinsics.rs:+3:55: +3:56\n+      scope 1 {\n+          let _3: *const usize;            // in scope 1 at $DIR/lower_intrinsics.rs:+2:13: +2:15\n+          scope 2 {\n+              debug _x => _3;              // in scope 2 at $DIR/lower_intrinsics.rs:+2:13: +2:15\n+              let _5: *const std::string::String; // in scope 2 at $DIR/lower_intrinsics.rs:+3:13: +3:15\n+              scope 3 {\n+                  debug _y => _5;          // in scope 3 at $DIR/lower_intrinsics.rs:+3:13: +3:15\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:13: +2:15\n+          StorageLive(_4);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:55: +2:56\n+          _4 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+2:55: +2:56\n+-         _3 = option_payload_ptr::<usize>(move _4) -> bb1; // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:99:18: 99:54\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<usize>) -> *const usize {option_payload_ptr::<usize>}, val: Value(<ZST>) }\n++         _3 = &raw const (((*_4) as Some).0: usize); // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n++         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n+      }\n+  \n+      bb1: {\n+          StorageDead(_4);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:56: +2:57\n+          StorageLive(_5);                 // scope 2 at $DIR/lower_intrinsics.rs:+3:13: +3:15\n+          StorageLive(_6);                 // scope 2 at $DIR/lower_intrinsics.rs:+3:55: +3:56\n+          _6 = &raw const (*_2);           // scope 2 at $DIR/lower_intrinsics.rs:+3:55: +3:56\n+-         _5 = option_payload_ptr::<String>(move _6) -> bb2; // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:100:18: 100:54\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<String>) -> *const String {option_payload_ptr::<String>}, val: Value(<ZST>) }\n++         _5 = &raw const (((*_6) as Some).0: std::string::String); // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n++         goto -> bb2;                     // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n+      }\n+  \n+      bb2: {\n+          StorageDead(_6);                 // scope 2 at $DIR/lower_intrinsics.rs:+3:56: +3:57\n+          _0 = const ();                   // scope 1 at $DIR/lower_intrinsics.rs:+1:5: +4:6\n+          StorageDead(_5);                 // scope 2 at $DIR/lower_intrinsics.rs:+4:5: +4:6\n+          StorageDead(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:+4:5: +4:6\n+          return;                          // scope 0 at $DIR/lower_intrinsics.rs:+5:2: +5:2\n+      }\n+  }\n+  "}, {"sha": "f07e2816f4f41196761acd4859dd2e6869c1d65d", "filename": "tests/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -91,3 +91,12 @@ pub fn read_via_copy_uninhabited(r: &Never) -> Never {\n }\n \n pub enum Never {}\n+\n+// EMIT_MIR lower_intrinsics.option_payload.LowerIntrinsics.diff\n+#[cfg(not(bootstrap))]\n+pub fn option_payload(o: &Option<usize>, p: &Option<String>) {\n+    unsafe {\n+        let _x = core::intrinsics::option_payload_ptr(o);\n+        let _y = core::intrinsics::option_payload_ptr(p);\n+    }\n+}"}, {"sha": "15bf51e6f8e2b6319f8ab39ea95955d41b22e1a1", "filename": "tests/rustdoc-ui/intra-doc/auxiliary/inner-crate-doc.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Frustdoc-ui%2Fintra-doc%2Fauxiliary%2Finner-crate-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Frustdoc-ui%2Fintra-doc%2Fauxiliary%2Finner-crate-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fauxiliary%2Finner-crate-doc.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -0,0 +1 @@\n+//! Inner doc comment"}, {"sha": "4d6a325664578da09545bcadea3df882f133faab", "filename": "tests/rustdoc-ui/intra-doc/import-inline-merge-module.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge-module.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -0,0 +1,10 @@\n+// Test for issue #108501.\n+// Module parent scope doesn't hijack import's parent scope for the import's doc links.\n+\n+// check-pass\n+// aux-build: inner-crate-doc.rs\n+// compile-flags: --extern inner_crate_doc --edition 2018\n+\n+/// Import doc comment [inner_crate_doc]\n+#[doc(inline)]\n+pub use inner_crate_doc;"}, {"sha": "10edae437ee74283ab235c68f54142f1c24da29c", "filename": "tests/ui/consts/const-eval/ub-uninhabit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -14,12 +14,12 @@ union MaybeUninit<T: Copy> {\n }\n \n const BAD_BAD_BAD: Bar = unsafe { MaybeUninit { uninit: () }.init };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n \n const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n //~^ ERROR it is undefined behavior to use this value\n \n const BAD_BAD_ARRAY: [Bar; 1] = unsafe { MaybeUninit { uninit: () }.init };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n \n fn main() {}"}, {"sha": "733975fc0e9ce5e3011048f7e66f6a5860f54948", "filename": "tests/ui/consts/const-eval/ub-uninhabit.stderr", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -1,11 +1,8 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:16:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-uninhabit.rs:16:35\n    |\n LL | const BAD_BAD_BAD: Bar = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Bar\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {}\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a value of uninhabited type Bar\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-uninhabit.rs:19:1\n@@ -18,14 +15,11 @@ LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n                HEX_DUMP\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-uninhabit.rs:22:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-uninhabit.rs:22:42\n    |\n LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0]: encountered a value of uninhabited type Bar\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {}\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0]: encountered a value of uninhabited type Bar\n \n error: aborting due to 3 previous errors\n "}, {"sha": "231005d7e3975dc8bfe47d3a9f34abc7869efcf3", "filename": "tests/ui/consts/const-eval/validate_uninhabited_zsts.32bit.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -24,14 +24,11 @@ note: inside `FOO`\n LL | const FOO: [empty::Empty; 3] = [foo(); 3];\n    |                                 ^^^^^\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_uninhabited_zsts.rs:21:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/validate_uninhabited_zsts.rs:21:42\n    |\n LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0].0: encountered a value of uninhabited type empty::Void\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered a value of uninhabited type empty::Void\n \n warning: the type `empty::Empty` does not permit zero-initialization\n   --> $DIR/validate_uninhabited_zsts.rs:21:42"}, {"sha": "231005d7e3975dc8bfe47d3a9f34abc7869efcf3", "filename": "tests/ui/consts/const-eval/validate_uninhabited_zsts.64bit.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -24,14 +24,11 @@ note: inside `FOO`\n LL | const FOO: [empty::Empty; 3] = [foo(); 3];\n    |                                 ^^^^^\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_uninhabited_zsts.rs:21:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/validate_uninhabited_zsts.rs:21:42\n    |\n LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0].0: encountered a value of uninhabited type empty::Void\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered a value of uninhabited type empty::Void\n \n warning: the type `empty::Empty` does not permit zero-initialization\n   --> $DIR/validate_uninhabited_zsts.rs:21:42"}, {"sha": "b6783175dd3795bfc0b0eebb20e453bee4c5977d", "filename": "tests/ui/consts/const-eval/validate_uninhabited_zsts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -19,7 +19,7 @@ pub mod empty {\n const FOO: [empty::Empty; 3] = [foo(); 3];\n \n const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n //~| WARN the type `empty::Empty` does not permit zero-initialization\n \n fn main() {"}, {"sha": "9275a8a072ddecb68274ef93346854ee23296d6b", "filename": "tests/ui/consts/issue-64506.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fconsts%2Fissue-64506.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fconsts%2Fissue-64506.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-64506.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -1,4 +1,4 @@\n-// check-pass\n+// check-fail\n \n #[derive(Copy, Clone)]\n pub struct ChildStdin {\n@@ -14,6 +14,7 @@ const FOO: () = {\n         b: (),\n     }\n     let x = unsafe { Foo { b: () }.a };\n+    //~^ ERROR: evaluation of constant value failed\n     let x = &x.inner;\n };\n "}, {"sha": "31a5b1df837c5b186927af14c0593d7ef428f433", "filename": "tests/ui/consts/issue-64506.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fconsts%2Fissue-64506.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fconsts%2Fissue-64506.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-64506.stderr?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -0,0 +1,9 @@\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-64506.rs:16:22\n+   |\n+LL |     let x = unsafe { Foo { b: () }.a };\n+   |                      ^^^^^^^^^^^^^^^ constructing invalid value at .inner: encountered a value of uninhabited type AnonPipe\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "74f7bc603aafcb1f782ef26c0ce5ed327d709435", "filename": "tests/ui/impl-trait/in-trait/auxiliary/rpitit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fauxiliary%2Frpitit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fauxiliary%2Frpitit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fauxiliary%2Frpitit.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -1,3 +1,5 @@\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+\n #![feature(return_position_impl_trait_in_trait)]\n \n pub trait Foo {"}, {"sha": "b8a793e1a7bb5314feaa8b000c7610f1fa59e7ee", "filename": "tests/ui/impl-trait/in-trait/dont-project-to-rpitit-with-no-value.current.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.current.stderr?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -1,5 +1,5 @@\n warning: the feature `return_position_impl_trait_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/dont-project-to-rpitit-with-no-value.rs:1:12\n+  --> $DIR/dont-project-to-rpitit-with-no-value.rs:4:12\n    |\n LL | #![feature(return_position_impl_trait_in_trait)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -8,7 +8,7 @@ LL | #![feature(return_position_impl_trait_in_trait)]\n    = note: `#[warn(incomplete_features)]` on by default\n \n error[E0046]: not all trait items implemented, missing: `foo`\n-  --> $DIR/dont-project-to-rpitit-with-no-value.rs:9:1\n+  --> $DIR/dont-project-to-rpitit-with-no-value.rs:12:1\n    |\n LL |     fn foo(&self) -> impl Sized;\n    |     ---------------------------- `foo` from trait", "previous_filename": "tests/ui/impl-trait/in-trait/dont-project-to-rpitit-with-no-value.stderr"}, {"sha": "b8a793e1a7bb5314feaa8b000c7610f1fa59e7ee", "filename": "tests/ui/impl-trait/in-trait/dont-project-to-rpitit-with-no-value.next.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.next.stderr?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -0,0 +1,21 @@\n+warning: the feature `return_position_impl_trait_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/dont-project-to-rpitit-with-no-value.rs:4:12\n+   |\n+LL | #![feature(return_position_impl_trait_in_trait)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0046]: not all trait items implemented, missing: `foo`\n+  --> $DIR/dont-project-to-rpitit-with-no-value.rs:12:1\n+   |\n+LL |     fn foo(&self) -> impl Sized;\n+   |     ---------------------------- `foo` from trait\n+...\n+LL | impl MyTrait for i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^ missing `foo` in implementation\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0046`."}, {"sha": "8329ce1f835d04c8e58ab61ebb90a46844891971", "filename": "tests/ui/impl-trait/in-trait/dont-project-to-rpitit-with-no-value.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a266f11990d9544ee408e213e1eec8cc9eb032b7/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdont-project-to-rpitit-with-no-value.rs?ref=a266f11990d9544ee408e213e1eec8cc9eb032b7", "patch": "@@ -1,3 +1,6 @@\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n+\n #![feature(return_position_impl_trait_in_trait)]\n //~^ WARN the feature `return_position_impl_trait_in_trait` is incomplete\n \n@@ -7,7 +10,7 @@ trait MyTrait {\n }\n \n impl MyTrait for i32 {\n-//~^ ERROR not all trait items implemented, missing: `foo`\n+    //~^ ERROR not all trait items implemented, missing: `foo`\n     fn bar(&self) -> impl Sized {\n         self.foo()\n     }"}]}