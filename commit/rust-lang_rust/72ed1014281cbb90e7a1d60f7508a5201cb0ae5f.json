{"sha": "72ed1014281cbb90e7a1d60f7508a5201cb0ae5f", "node_id": "C_kwDOAAsO6NoAKDcyZWQxMDE0MjgxY2JiOTBlN2ExZDYwZjc1MDhhNTIwMWNiMGFlNWY", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-04-16T20:53:13Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-04-19T19:53:50Z"}, "message": "rustdoc: Optimize and refactor doc link resolution\n\n- Cache doc link resolutions obtained early\n- Cache markdown links retrieved from doc strings early\n- Rename and restructure the code in early doc link resolution to be closer to #94857", "tree": {"sha": "d1ea2e3f3e48748602c2814bdfbb09fd1d2e843f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1ea2e3f3e48748602c2814bdfbb09fd1d2e843f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72ed1014281cbb90e7a1d60f7508a5201cb0ae5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72ed1014281cbb90e7a1d60f7508a5201cb0ae5f", "html_url": "https://github.com/rust-lang/rust/commit/72ed1014281cbb90e7a1d60f7508a5201cb0ae5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72ed1014281cbb90e7a1d60f7508a5201cb0ae5f/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2d3a4f63187ed6b092b5ec4a7d8b66f897ca308", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2d3a4f63187ed6b092b5ec4a7d8b66f897ca308", "html_url": "https://github.com/rust-lang/rust/commit/e2d3a4f63187ed6b092b5ec4a7d8b66f897ca308"}], "stats": {"total": 152, "additions": 112, "deletions": 40}, "files": [{"sha": "bc9f64e1afcfed6956870dea6edbd918349e9adb", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72ed1014281cbb90e7a1d60f7508a5201cb0ae5f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed1014281cbb90e7a1d60f7508a5201cb0ae5f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=72ed1014281cbb90e7a1d60f7508a5201cb0ae5f", "patch": "@@ -1088,6 +1088,13 @@ impl Attributes {\n     crate fn from_ast(\n         attrs: &[ast::Attribute],\n         additional_attrs: Option<(&[ast::Attribute], DefId)>,\n+    ) -> Attributes {\n+        Attributes::from_ast_iter(attrs.iter(), additional_attrs)\n+    }\n+\n+    crate fn from_ast_iter<'a>(\n+        attrs: impl Iterator<Item = &'a ast::Attribute>,\n+        additional_attrs: Option<(&[ast::Attribute], DefId)>,\n     ) -> Attributes {\n         let mut doc_strings: Vec<DocFragment> = vec![];\n         let clean_attr = |(attr, parent_module): (&ast::Attribute, Option<DefId>)| {\n@@ -1115,7 +1122,7 @@ impl Attributes {\n         let other_attrs = additional_attrs\n             .into_iter()\n             .flat_map(|(attrs, id)| attrs.iter().map(move |attr| (attr, Some(id))))\n-            .chain(attrs.iter().map(|attr| (attr, None)))\n+            .chain(attrs.map(|attr| (attr, None)))\n             .filter_map(clean_attr)\n             .collect();\n "}, {"sha": "adf19aa8e74942c5befbdb9f771b4b13a031cf78", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72ed1014281cbb90e7a1d60f7508a5201cb0ae5f/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed1014281cbb90e7a1d60f7508a5201cb0ae5f/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=72ed1014281cbb90e7a1d60f7508a5201cb0ae5f", "patch": "@@ -4,7 +4,7 @@ use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n use rustc_feature::UnstableFeatures;\n-use rustc_hir::def::Res;\n+use rustc_hir::def::{Namespace, Res};\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{HirId, Path, TraitCandidate};\n@@ -29,11 +29,14 @@ use crate::clean::inline::build_external_trait;\n use crate::clean::{self, ItemId, TraitWithExtraInfo};\n use crate::config::{Options as RustdocOptions, OutputFormat, RenderOptions};\n use crate::formats::cache::Cache;\n+use crate::html::markdown::MarkdownLink;\n use crate::passes::{self, Condition::*};\n \n crate use rustc_session::config::{DebuggingOptions, Input, Options};\n \n crate struct ResolverCaches {\n+    crate markdown_links: Option<FxHashMap<String, Vec<MarkdownLink>>>,\n+    crate doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<NodeId>>>,\n     /// Traits in scope for a given module.\n     /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n     crate traits_in_scope: DefIdMap<Vec<TraitCandidate>>,"}, {"sha": "823a94048eb93066c2dc7ecfd0e171f59b1c0d66", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/72ed1014281cbb90e7a1d60f7508a5201cb0ae5f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed1014281cbb90e7a1d60f7508a5201cb0ae5f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=72ed1014281cbb90e7a1d60f7508a5201cb0ae5f", "patch": "@@ -3,6 +3,7 @@\n //! [RFC 1946]: https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md\n \n use pulldown_cmark::LinkType;\n+use rustc_ast::util::comments::may_have_doc_links;\n use rustc_data_structures::{fx::FxHashMap, intern::Interned, stable_set::FxHashSet};\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir::def::Namespace::*;\n@@ -556,7 +557,15 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         // Resolver doesn't know about true, false, and types that aren't paths (e.g. `()`).\n         let result = self\n             .cx\n-            .enter_resolver(|resolver| resolver.resolve_rustdoc_path(path_str, ns, module_id))\n+            .resolver_caches\n+            .doc_link_resolutions\n+            .get(&(Symbol::intern(path_str), ns, module_id))\n+            .copied()\n+            .unwrap_or_else(|| {\n+                self.cx.enter_resolver(|resolver| {\n+                    resolver.resolve_rustdoc_path(path_str, ns, module_id)\n+                })\n+            })\n             .and_then(|res| res.try_into().ok())\n             .or_else(|| resolve_primitive(path_str, ns))\n             .or_else(|| self.resolve_macro_rules(path_str, ns));\n@@ -1041,16 +1050,29 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n         // Rather than merging all documentation into one, resolve it one attribute at a time\n         // so we know which module it came from.\n         for (parent_module, doc) in item.attrs.collapsed_doc_value_by_module_level() {\n+            if !may_have_doc_links(&doc) {\n+                continue;\n+            }\n             debug!(\"combined_docs={}\", doc);\n             // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n             // This is a degenerate case and it's not supported by rustdoc.\n             let parent_node = parent_module.or(parent_node);\n-            for md_link in markdown_links(&doc) {\n+            let mut tmp_links = self\n+                .cx\n+                .resolver_caches\n+                .markdown_links\n+                .take()\n+                .expect(\"`markdown_links` are already borrowed\");\n+            if !tmp_links.contains_key(&doc) {\n+                tmp_links.insert(doc.clone(), markdown_links(&doc));\n+            }\n+            for md_link in &tmp_links[&doc] {\n                 let link = self.resolve_link(&item, &doc, parent_node, md_link);\n                 if let Some(link) = link {\n                     self.cx.cache.intra_doc_links.entry(item.item_id).or_default().push(link);\n                 }\n             }\n+            self.cx.resolver_caches.markdown_links = Some(tmp_links);\n         }\n \n         if item.is_mod() {\n@@ -1181,7 +1203,7 @@ impl LinkCollector<'_, '_> {\n         item: &Item,\n         dox: &str,\n         parent_node: Option<DefId>,\n-        ori_link: MarkdownLink,\n+        ori_link: &MarkdownLink,\n     ) -> Option<ItemLink> {\n         trace!(\"considering link '{}'\", ori_link.link);\n \n@@ -1320,7 +1342,7 @@ impl LinkCollector<'_, '_> {\n                 }\n \n                 Some(ItemLink {\n-                    link: ori_link.link,\n+                    link: ori_link.link.clone(),\n                     link_text,\n                     did: res.def_id(self.cx.tcx),\n                     fragment,\n@@ -1343,7 +1365,7 @@ impl LinkCollector<'_, '_> {\n                     &diag_info,\n                 )?;\n                 let id = clean::register_res(self.cx, rustc_hir::def::Res::Def(kind, id));\n-                Some(ItemLink { link: ori_link.link, link_text, did: id, fragment })\n+                Some(ItemLink { link: ori_link.link.clone(), link_text, did: id, fragment })\n             }\n         }\n     }"}, {"sha": "e8920d5e2886dca6a3b807fa689149149b869b0f", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 73, "deletions": 33, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/72ed1014281cbb90e7a1d60f7508a5201cb0ae5f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ed1014281cbb90e7a1d60f7508a5201cb0ae5f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=72ed1014281cbb90e7a1d60f7508a5201cb0ae5f", "patch": "@@ -1,19 +1,20 @@\n use crate::clean::Attributes;\n use crate::core::ResolverCaches;\n-use crate::html::markdown::markdown_links;\n+use crate::html::markdown::{markdown_links, MarkdownLink};\n use crate::passes::collect_intra_doc_links::preprocess_link;\n \n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, ItemKind};\n use rustc_ast_lowering::ResolverAstLowering;\n-use rustc_hir::def::Namespace::TypeNS;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def::Namespace::*;\n+use rustc_hir::def::{DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::TraitCandidate;\n use rustc_middle::ty::{DefIdTree, Visibility};\n use rustc_resolve::{ParentScope, Resolver};\n use rustc_session::config::Externs;\n-use rustc_span::SyntaxContext;\n+use rustc_span::{Symbol, SyntaxContext};\n \n use std::collections::hash_map::Entry;\n use std::mem;\n@@ -28,6 +29,8 @@ crate fn early_resolve_intra_doc_links(\n         resolver,\n         current_mod: CRATE_DEF_ID,\n         visited_mods: Default::default(),\n+        markdown_links: Default::default(),\n+        doc_link_resolutions: Default::default(),\n         traits_in_scope: Default::default(),\n         all_traits: Default::default(),\n         all_trait_impls: Default::default(),\n@@ -36,7 +39,7 @@ crate fn early_resolve_intra_doc_links(\n \n     // Overridden `visit_item` below doesn't apply to the crate root,\n     // so we have to visit its attributes and reexports separately.\n-    link_resolver.load_links_in_attrs(&krate.attrs);\n+    link_resolver.resolve_doc_links_local(&krate.attrs);\n     link_resolver.process_module_children_or_reexports(CRATE_DEF_ID.to_def_id());\n     visit::walk_crate(&mut link_resolver, krate);\n     link_resolver.process_extern_impls();\n@@ -50,17 +53,27 @@ crate fn early_resolve_intra_doc_links(\n     }\n \n     ResolverCaches {\n+        markdown_links: Some(link_resolver.markdown_links),\n+        doc_link_resolutions: link_resolver.doc_link_resolutions,\n         traits_in_scope: link_resolver.traits_in_scope,\n         all_traits: Some(link_resolver.all_traits),\n         all_trait_impls: Some(link_resolver.all_trait_impls),\n         all_macro_rules: link_resolver.resolver.take_all_macro_rules(),\n     }\n }\n \n+fn doc_attrs<'a>(attrs: impl Iterator<Item = &'a ast::Attribute>) -> Attributes {\n+    let mut attrs = Attributes::from_ast_iter(attrs.filter(|attr| attr.doc_str().is_some()), None);\n+    attrs.unindent_doc_comments();\n+    attrs\n+}\n+\n struct EarlyDocLinkResolver<'r, 'ra> {\n     resolver: &'r mut Resolver<'ra>,\n     current_mod: LocalDefId,\n     visited_mods: DefIdSet,\n+    markdown_links: FxHashMap<String, Vec<MarkdownLink>>,\n+    doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<ast::NodeId>>>,\n     traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n     all_traits: Vec<DefId>,\n     all_trait_impls: Vec<DefId>,\n@@ -92,18 +105,11 @@ impl EarlyDocLinkResolver<'_, '_> {\n         }\n     }\n \n-    fn add_traits_in_parent_scope(&mut self, def_id: DefId) {\n-        if let Some(module_id) = self.resolver.parent(def_id) {\n-            self.add_traits_in_scope(module_id);\n-        }\n-    }\n-\n     /// Add traits in scope for links in impls collected by the `collect-intra-doc-links` pass.\n     /// That pass filters impls using type-based information, but we don't yet have such\n     /// information here, so we just conservatively calculate traits in scope for *all* modules\n     /// having impls in them.\n     fn process_extern_impls(&mut self) {\n-        // FIXME: Need to resolve doc links on all these impl and trait items below.\n         // Resolving links in already existing crates may trigger loading of new crates.\n         let mut start_cnum = 0;\n         loop {\n@@ -124,7 +130,7 @@ impl EarlyDocLinkResolver<'_, '_> {\n                 // the current crate, and links in their doc comments are not resolved.\n                 for &def_id in &all_traits {\n                     if self.resolver.cstore().visibility_untracked(def_id) == Visibility::Public {\n-                        self.add_traits_in_parent_scope(def_id);\n+                        self.resolve_doc_links_extern_impl(def_id, false);\n                     }\n                 }\n                 for &(trait_def_id, impl_def_id, simplified_self_ty) in &all_trait_impls {\n@@ -135,17 +141,17 @@ impl EarlyDocLinkResolver<'_, '_> {\n                                 == Visibility::Public\n                         })\n                     {\n-                        self.add_traits_in_parent_scope(impl_def_id);\n+                        self.resolve_doc_links_extern_impl(impl_def_id, false);\n                     }\n                 }\n                 for (ty_def_id, impl_def_id) in all_inherent_impls {\n                     if self.resolver.cstore().visibility_untracked(ty_def_id) == Visibility::Public\n                     {\n-                        self.add_traits_in_parent_scope(impl_def_id);\n+                        self.resolve_doc_links_extern_impl(impl_def_id, true);\n                     }\n                 }\n-                for def_id in all_incoherent_impls {\n-                    self.add_traits_in_parent_scope(def_id);\n+                for impl_def_id in all_incoherent_impls {\n+                    self.resolve_doc_links_extern_impl(impl_def_id, true);\n                 }\n \n                 self.all_traits.extend(all_traits);\n@@ -161,16 +167,52 @@ impl EarlyDocLinkResolver<'_, '_> {\n         }\n     }\n \n-    fn load_links_in_attrs(&mut self, attrs: &[ast::Attribute]) {\n+    fn resolve_doc_links_extern_impl(&mut self, def_id: DefId, _is_inherent: bool) {\n+        // FIXME: Resolve links in associated items in addition to traits themselves,\n+        // `force` is used to provide traits in scope for the associated items.\n+        self.resolve_doc_links_extern_outer(def_id, def_id, true);\n+    }\n+\n+    fn resolve_doc_links_extern_outer(&mut self, def_id: DefId, scope_id: DefId, force: bool) {\n+        if !force && !self.resolver.cstore().may_have_doc_links_untracked(def_id) {\n+            return;\n+        }\n+        // FIXME: actually resolve links, not just add traits in scope.\n+        if let Some(parent_id) = self.resolver.parent(scope_id) {\n+            self.add_traits_in_scope(parent_id);\n+        }\n+    }\n+\n+    fn resolve_doc_links_extern_inner(&mut self, def_id: DefId) {\n+        if !self.resolver.cstore().may_have_doc_links_untracked(def_id) {\n+            return;\n+        }\n+        // FIXME: actually resolve links, not just add traits in scope.\n+        self.add_traits_in_scope(def_id);\n+    }\n+\n+    fn resolve_doc_links_local(&mut self, attrs: &[ast::Attribute]) {\n+        if !attrs.iter().any(|attr| attr.may_have_doc_links()) {\n+            return;\n+        }\n         let module_id = self.current_mod.to_def_id();\n+        self.resolve_doc_links(doc_attrs(attrs.iter()), module_id);\n+    }\n+\n+    fn resolve_doc_links(&mut self, attrs: Attributes, module_id: DefId) {\n         let mut need_traits_in_scope = false;\n-        for (doc_module, doc) in\n-            Attributes::from_ast(attrs, None).collapsed_doc_value_by_module_level()\n-        {\n+        for (doc_module, doc) in attrs.collapsed_doc_value_by_module_level() {\n             assert_eq!(doc_module, None);\n-            for link in markdown_links(&doc.as_str()) {\n+            for link in self.markdown_links.entry(doc).or_insert_with_key(|doc| markdown_links(doc))\n+            {\n                 if let Some(Ok(pinfo)) = preprocess_link(&link) {\n-                    self.resolver.resolve_rustdoc_path(&pinfo.path_str, TypeNS, module_id);\n+                    // FIXME: Resolve the path in all namespaces and resolve its prefixes too.\n+                    let ns = TypeNS;\n+                    self.doc_link_resolutions\n+                        .entry((Symbol::intern(&pinfo.path_str), ns, module_id))\n+                        .or_insert_with_key(|(path, ns, module_id)| {\n+                            self.resolver.resolve_rustdoc_path(path.as_str(), *ns, *module_id)\n+                        });\n                     need_traits_in_scope = true;\n                 }\n             }\n@@ -197,15 +239,13 @@ impl EarlyDocLinkResolver<'_, '_> {\n                     && module_id.is_local()\n             {\n                 if let Some(def_id) = child.res.opt_def_id() && !def_id.is_local() {\n-                    // FIXME: Need to resolve doc links on all these extern items\n-                    // reached through reexports.\n                     let scope_id = match child.res {\n                         Res::Def(DefKind::Variant, ..) => self.resolver.parent(def_id).unwrap(),\n                         _ => def_id,\n                     };\n-                    self.add_traits_in_parent_scope(scope_id); // Outer attribute scope\n+                    self.resolve_doc_links_extern_outer(def_id, scope_id, false); // Outer attribute scope\n                     if let Res::Def(DefKind::Mod, ..) = child.res {\n-                        self.add_traits_in_scope(def_id); // Inner attribute scope\n+                        self.resolve_doc_links_extern_inner(def_id); // Inner attribute scope\n                     }\n                     // Traits are processed in `add_extern_traits_in_scope`.\n                     if let Res::Def(DefKind::Mod | DefKind::Enum, ..) = child.res {\n@@ -219,10 +259,10 @@ impl EarlyDocLinkResolver<'_, '_> {\n \n impl Visitor<'_> for EarlyDocLinkResolver<'_, '_> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        self.load_links_in_attrs(&item.attrs); // Outer attribute scope\n+        self.resolve_doc_links_local(&item.attrs); // Outer attribute scope\n         if let ItemKind::Mod(..) = item.kind {\n             let old_mod = mem::replace(&mut self.current_mod, self.resolver.local_def_id(item.id));\n-            self.load_links_in_attrs(&item.attrs); // Inner attribute scope\n+            self.resolve_doc_links_local(&item.attrs); // Inner attribute scope\n             self.process_module_children_or_reexports(self.current_mod.to_def_id());\n             visit::walk_item(self, item);\n             self.current_mod = old_mod;\n@@ -241,22 +281,22 @@ impl Visitor<'_> for EarlyDocLinkResolver<'_, '_> {\n     }\n \n     fn visit_assoc_item(&mut self, item: &ast::AssocItem, ctxt: AssocCtxt) {\n-        self.load_links_in_attrs(&item.attrs);\n+        self.resolve_doc_links_local(&item.attrs);\n         visit::walk_assoc_item(self, item, ctxt)\n     }\n \n     fn visit_foreign_item(&mut self, item: &ast::ForeignItem) {\n-        self.load_links_in_attrs(&item.attrs);\n+        self.resolve_doc_links_local(&item.attrs);\n         visit::walk_foreign_item(self, item)\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant) {\n-        self.load_links_in_attrs(&v.attrs);\n+        self.resolve_doc_links_local(&v.attrs);\n         visit::walk_variant(self, v)\n     }\n \n     fn visit_field_def(&mut self, field: &ast::FieldDef) {\n-        self.load_links_in_attrs(&field.attrs);\n+        self.resolve_doc_links_local(&field.attrs);\n         visit::walk_field_def(self, field)\n     }\n "}]}