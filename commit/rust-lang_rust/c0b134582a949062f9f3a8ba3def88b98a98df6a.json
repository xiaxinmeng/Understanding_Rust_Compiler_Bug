{"sha": "c0b134582a949062f9f3a8ba3def88b98a98df6a", "node_id": "C_kwDOAAsO6NoAKGMwYjEzNDU4MmE5NDkwNjJmOWYzYThiYTNkZWY4OGI5OGE5OGRmNmE", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2021-08-19T18:40:00Z"}, "committer": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2021-10-31T12:14:04Z"}, "message": "Lint against RTL unicode codepoints in literals and comments\n\nAddress CVE-2021-42574.", "tree": {"sha": "bc303a0c9cac3405bea3973e3ce075759b88c136", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc303a0c9cac3405bea3973e3ce075759b88c136"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0b134582a949062f9f3a8ba3def88b98a98df6a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE1JbYPtLJAsc22U9xPgar6Auq8ZwFAmF+iIwACgkQPgar6Auq\n8Zwl7A//e5oFBebNj9fWQY2RlyuRlWIQ6rFyuvFD603jL2Ab9wjSBXmdNuI3Bgqn\nrSpQULKFrCoKkky3zam2i10znA6pnGU3N2rPhj6LurZcL8U9uT994F1q6wmaNHPL\nDn+JyRcG8im17FcfNkcM8aYuKwgvurWj2I+Ovz+HT4fhGwgjyDInzs16JJBEqMN/\ndx25texw4n/yhS2BDVGmK2U0rCbKEKiDmh0ahzTq6oa60KjexP1oPQmxNuYwcUEu\nT6JZ9qe5HbhFm389Xw2KqPjyIdoeiTIBO7bk8eYrwjGN/ScOc6/qJAny1H8B4FhE\nkdUICowKjXPhczAHuwzeaz7AYOnEY6tpVdrlU2BiY0T9LM5AeCzPhqv8UR4XKNUk\nVlF8/TQFB9E0G7Hg2786q+fRjNZFbkpb5835OACg2VAQMRx6AQ7Qow1E/9qe64vj\n5P1I6azUV3CNX+1yUeW5eJe/NpB1sWZBPMnecGhCqVvdbrGjS/esKrBRhMEtlTxB\nka5cTQhIt+T6nMM4W3/d+3yU4e1Z+snNoctkUA1o8f60UbABqHWl8+MYfWo649CD\nYdXdCVhNjcqFN+8E6uKePDamjaHV2ZNQP6AJbVOiNtvTKwOmh2V+zqPX2P9oPH7U\nDkNvPsDfr9y6QncOzSj3UDbllVcbkcElvLWn5Af4icH+xLe7mp8=\n=PRHV\n-----END PGP SIGNATURE-----", "payload": "tree bc303a0c9cac3405bea3973e3ce075759b88c136\nparent 38b01d90657a355abf81b53cb3ee0b9a7dd88f98\nauthor Esteban K\u00fcber <esteban@kuber.com.ar> 1629398400 -0700\ncommitter Pietro Albini <pietro@pietroalbini.org> 1635682444 +0100\n\nLint against RTL unicode codepoints in literals and comments\n\nAddress CVE-2021-42574.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b134582a949062f9f3a8ba3def88b98a98df6a", "html_url": "https://github.com/rust-lang/rust/commit/c0b134582a949062f9f3a8ba3def88b98a98df6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0b134582a949062f9f3a8ba3def88b98a98df6a/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38b01d90657a355abf81b53cb3ee0b9a7dd88f98", "url": "https://api.github.com/repos/rust-lang/rust/commits/38b01d90657a355abf81b53cb3ee0b9a7dd88f98", "html_url": "https://github.com/rust-lang/rust/commit/38b01d90657a355abf81b53cb3ee0b9a7dd88f98"}], "stats": {"total": 545, "additions": 535, "deletions": 10}, "files": [{"sha": "43da32df5d9caf8565668f7b83ce4e088c60659b", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0b134582a949062f9f3a8ba3def88b98a98df6a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c0b134582a949062f9f3a8ba3def88b98a98df6a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c0b134582a949062f9f3a8ba3def88b98a98df6a", "patch": "@@ -4259,6 +4259,7 @@ dependencies = [\n  \"rustc_span\",\n  \"tracing\",\n  \"unicode-normalization\",\n+ \"unicode-width\",\n ]\n \n [[package]]"}, {"sha": "e16ff9741229148c75827914ede58af494849180", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=c0b134582a949062f9f3a8ba3def88b98a98df6a", "patch": "@@ -2063,8 +2063,26 @@ fn num_decimal_digits(num: usize) -> usize {\n     MAX_DIGITS\n }\n \n+// We replace some characters so the CLI output is always consistent and underlines aligned.\n+const OUTPUT_REPLACEMENTS: &[(char, &str)] = &[\n+    ('\\t', \"    \"),   // We do our own tab replacement\n+    ('\\u{202A}', \"\"), // The following unicode text flow control characters are inconsistently\n+    ('\\u{202B}', \"\"), // supported accross CLIs and can cause confusion due to the bytes on disk\n+    ('\\u{202D}', \"\"), // not corresponding to the visible source code, so we replace them always.\n+    ('\\u{202E}', \"\"),\n+    ('\\u{2066}', \"\"),\n+    ('\\u{2067}', \"\"),\n+    ('\\u{2068}', \"\"),\n+    ('\\u{202C}', \"\"),\n+    ('\\u{2069}', \"\"),\n+];\n+\n fn replace_tabs(str: &str) -> String {\n-    str.replace('\\t', \"    \")\n+    let mut s = str.to_string();\n+    for (c, replacement) in OUTPUT_REPLACEMENTS {\n+        s = s.replace(*c, replacement);\n+    }\n+    s\n }\n \n fn draw_col_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {"}, {"sha": "6fd0a5b95f9f6e053f41ffa1cbefef1f9c5d9529", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=c0b134582a949062f9f3a8ba3def88b98a98df6a", "patch": "@@ -16,6 +16,7 @@\n \n use self::TargetLint::*;\n \n+use crate::hidden_unicode_codepoints::UNICODE_TEXT_FLOW_CHARS;\n use crate::levels::{is_known_lint_tool, LintLevelsBuilder};\n use crate::passes::{EarlyLintPassObject, LateLintPassObject};\n use rustc_ast as ast;\n@@ -39,7 +40,7 @@ use rustc_session::lint::{BuiltinLintDiagnostics, ExternDepSpec};\n use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId};\n use rustc_session::Session;\n use rustc_span::lev_distance::find_best_match_for_name;\n-use rustc_span::{symbol::Symbol, MultiSpan, Span, DUMMY_SP};\n+use rustc_span::{symbol::Symbol, BytePos, MultiSpan, Span, DUMMY_SP};\n use rustc_target::abi;\n use tracing::debug;\n \n@@ -597,6 +598,42 @@ pub trait LintContext: Sized {\n             // Now, set up surrounding context.\n             let sess = self.sess();\n             match diagnostic {\n+                BuiltinLintDiagnostics::UnicodeTextFlow(span, content) => {\n+                    let spans: Vec<_> = content\n+                        .char_indices()\n+                        .filter_map(|(i, c)| {\n+                            UNICODE_TEXT_FLOW_CHARS.contains(&c).then(|| {\n+                                let lo = span.lo() + BytePos(2 + i as u32);\n+                                (c, span.with_lo(lo).with_hi(lo + BytePos(c.len_utf8() as u32)))\n+                            })\n+                        })\n+                        .collect();\n+                    let (an, s) = match spans.len() {\n+                        1 => (\"an \", \"\"),\n+                        _ => (\"\", \"s\"),\n+                    };\n+                    db.span_label(span, &format!(\n+                        \"this comment contains {}invisible unicode text flow control codepoint{}\",\n+                        an,\n+                        s,\n+                    ));\n+                    for (c, span) in &spans {\n+                        db.span_label(*span, format!(\"{:?}\", c));\n+                    }\n+                    db.note(\n+                        \"these kind of unicode codepoints change the way text flows on \\\n+                         applications that support them, but can cause confusion because they \\\n+                         change the order of characters on the screen\",\n+                    );\n+                    if !spans.is_empty() {\n+                        db.multipart_suggestion_with_style(\n+                            \"if their presence wasn't intentional, you can remove them\",\n+                            spans.into_iter().map(|(_, span)| (span, \"\".to_string())).collect(),\n+                            Applicability::MachineApplicable,\n+                            SuggestionStyle::HideCodeAlways,\n+                        );\n+                    }\n+                },\n                 BuiltinLintDiagnostics::Normal => (),\n                 BuiltinLintDiagnostics::BareTraitObject(span, is_global) => {\n                     let (sugg, app) = match sess.source_map().span_to_snippet(span) {"}, {"sha": "1bcdcb806fc43a2cab571e40643436d4acc4642c", "filename": "compiler/rustc_lint/src/hidden_unicode_codepoints.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs?ref=c0b134582a949062f9f3a8ba3def88b98a98df6a", "patch": "@@ -0,0 +1,161 @@\n+use crate::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_ast as ast;\n+use rustc_errors::{Applicability, SuggestionStyle};\n+use rustc_span::{BytePos, Span, Symbol};\n+\n+declare_lint! {\n+    /// The `text_direction_codepoint_in_literal` lint detects Unicode codepoints that change the\n+    /// visual representation of text on screen in a way that does not correspond to their on\n+    /// memory representation.\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The unicode characters `\\u{202A}`, `\\u{202B}`, `\\u{202D}`, `\\u{202E}`, `\\u{2066}`,\n+    /// `\\u{2067}`, `\\u{2068}`, `\\u{202C}` and `\\u{2069}` make the flow of text on screen change\n+    /// its direction on software that supports these codepoints. This makes the text \"abc\" display\n+    /// as \"cba\" on screen. By leveraging software that supports these, people can write specially\n+    /// crafted literals that make the surrounding code seem like it's performing one action, when\n+    /// in reality it is performing another. Because of this, we proactively lint against their\n+    /// presence to avoid surprises.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(text_direction_codepoint_in_literal)]\n+    /// fn main() {\n+    ///     println!(\"{:?}\", '\u202e');\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    pub TEXT_DIRECTION_CODEPOINT_IN_LITERAL,\n+    Deny,\n+    \"detect special Unicode codepoints that affect the visual representation of text on screen, \\\n+     changing the direction in which text flows\",\n+}\n+\n+declare_lint_pass!(HiddenUnicodeCodepoints => [TEXT_DIRECTION_CODEPOINT_IN_LITERAL]);\n+\n+crate const UNICODE_TEXT_FLOW_CHARS: &[char] = &[\n+    '\\u{202A}', '\\u{202B}', '\\u{202D}', '\\u{202E}', '\\u{2066}', '\\u{2067}', '\\u{2068}', '\\u{202C}',\n+    '\\u{2069}',\n+];\n+\n+impl HiddenUnicodeCodepoints {\n+    fn lint_text_direction_codepoint(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        text: Symbol,\n+        span: Span,\n+        padding: u32,\n+        point_at_inner_spans: bool,\n+        label: &str,\n+    ) {\n+        // Obtain the `Span`s for each of the forbidden chars.\n+        let spans: Vec<_> = text\n+            .as_str()\n+            .char_indices()\n+            .filter_map(|(i, c)| {\n+                UNICODE_TEXT_FLOW_CHARS.contains(&c).then(|| {\n+                    let lo = span.lo() + BytePos(i as u32 + padding);\n+                    (c, span.with_lo(lo).with_hi(lo + BytePos(c.len_utf8() as u32)))\n+                })\n+            })\n+            .collect();\n+\n+        cx.struct_span_lint(TEXT_DIRECTION_CODEPOINT_IN_LITERAL, span, |lint| {\n+            let mut err = lint.build(&format!(\n+                \"unicode codepoint changing visible direction of text present in {}\",\n+                label\n+            ));\n+            let (an, s) = match spans.len() {\n+                1 => (\"an \", \"\"),\n+                _ => (\"\", \"s\"),\n+            };\n+            err.span_label(\n+                span,\n+                &format!(\n+                    \"this {} contains {}invisible unicode text flow control codepoint{}\",\n+                    label, an, s,\n+                ),\n+            );\n+            if point_at_inner_spans {\n+                for (c, span) in &spans {\n+                    err.span_label(*span, format!(\"{:?}\", c));\n+                }\n+            }\n+            err.note(\n+                \"these kind of unicode codepoints change the way text flows on applications that \\\n+                 support them, but can cause confusion because they change the order of \\\n+                 characters on the screen\",\n+            );\n+            if point_at_inner_spans && !spans.is_empty() {\n+                err.multipart_suggestion_with_style(\n+                    \"if their presence wasn't intentional, you can remove them\",\n+                    spans.iter().map(|(_, span)| (*span, \"\".to_string())).collect(),\n+                    Applicability::MachineApplicable,\n+                    SuggestionStyle::HideCodeAlways,\n+                );\n+                err.multipart_suggestion(\n+                    \"if you want to keep them but make them visible in your source code, you can \\\n+                    escape them\",\n+                    spans\n+                        .into_iter()\n+                        .map(|(c, span)| {\n+                            let c = format!(\"{:?}\", c);\n+                            (span, c[1..c.len() - 1].to_string())\n+                        })\n+                        .collect(),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                // FIXME: in other suggestions we've reversed the inner spans of doc comments. We\n+                // should do the same here to provide the same good suggestions as we do for\n+                // literals above.\n+                err.note(\"if their presence wasn't intentional, you can remove them\");\n+                err.note(&format!(\n+                    \"if you want to keep them but make them visible in your source code, you can \\\n+                     escape them: {}\",\n+                    spans\n+                        .into_iter()\n+                        .map(|(c, _)| { format!(\"{:?}\", c) })\n+                        .collect::<Vec<String>>()\n+                        .join(\", \"),\n+                ));\n+            }\n+            err.emit();\n+        });\n+    }\n+}\n+impl EarlyLintPass for HiddenUnicodeCodepoints {\n+    fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n+        if let ast::AttrKind::DocComment(_, comment) = attr.kind {\n+            if comment.as_str().contains(UNICODE_TEXT_FLOW_CHARS) {\n+                self.lint_text_direction_codepoint(cx, comment, attr.span, 0, false, \"doc comment\");\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n+        // byte strings are already handled well enough by `EscapeError::NonAsciiCharInByteString`\n+        let (text, span, padding) = match &expr.kind {\n+            ast::ExprKind::Lit(ast::Lit { token, kind, span }) => {\n+                let text = token.symbol;\n+                if !text.as_str().contains(UNICODE_TEXT_FLOW_CHARS) {\n+                    return;\n+                }\n+                let padding = match kind {\n+                    // account for `\"` or `'`\n+                    ast::LitKind::Str(_, ast::StrStyle::Cooked) | ast::LitKind::Char(_) => 1,\n+                    // account for `r###\"`\n+                    ast::LitKind::Str(_, ast::StrStyle::Raw(val)) => *val as u32 + 2,\n+                    _ => return,\n+                };\n+                (text, span, padding)\n+            }\n+            _ => return,\n+        };\n+        self.lint_text_direction_codepoint(cx, text, *span, padding, true, \"literal\");\n+    }\n+}"}, {"sha": "d98d65385e533381f5a0c6c5896a2956203504e2", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=c0b134582a949062f9f3a8ba3def88b98a98df6a", "patch": "@@ -48,6 +48,7 @@ pub mod builtin;\n mod context;\n mod early;\n mod enum_intrinsics_non_enums;\n+pub mod hidden_unicode_codepoints;\n mod internal;\n mod late;\n mod levels;\n@@ -78,6 +79,7 @@ use rustc_span::Span;\n use array_into_iter::ArrayIntoIter;\n use builtin::*;\n use enum_intrinsics_non_enums::EnumIntrinsicsNonEnums;\n+use hidden_unicode_codepoints::*;\n use internal::*;\n use methods::*;\n use non_ascii_idents::*;\n@@ -129,6 +131,7 @@ macro_rules! early_lint_passes {\n                 DeprecatedAttr: DeprecatedAttr::new(),\n                 WhileTrue: WhileTrue,\n                 NonAsciiIdents: NonAsciiIdents,\n+                HiddenUnicodeCodepoints: HiddenUnicodeCodepoints,\n                 IncompleteFeatures: IncompleteFeatures,\n                 RedundantSemicolons: RedundantSemicolons,\n                 UnusedDocComment: UnusedDocComment,"}, {"sha": "1db9d3f65d4e4f5f90e39ed8030686ed27495c8a", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=c0b134582a949062f9f3a8ba3def88b98a98df6a", "patch": "@@ -3518,6 +3518,34 @@ declare_lint! {\n     @feature_gate = sym::non_exhaustive_omitted_patterns_lint;\n }\n \n+declare_lint! {\n+    /// The `text_direction_codepoint_in_comment` lint detects Unicode codepoints in comments that\n+    /// change the visual representation of text on screen in a way that does not correspond to\n+    /// their on memory representation.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(text_direction_codepoint_in_comment)]\n+    /// fn main() {\n+    ///     println!(\"{:?}\"); // '\u202e');\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Unicode allows changing the visual flow of text on screen in order to support scripts that\n+    /// are written right-to-left, but a specially crafted comment can make code that will be\n+    /// compiled appear to be part of a comment, depending on the software used to read the code.\n+    /// To avoid potential problems or confusion, such as in CVE-2021-42574, by default we deny\n+    /// their use.\n+    pub TEXT_DIRECTION_CODEPOINT_IN_COMMENT,\n+    Deny,\n+    \"invisible directionality-changing codepoints in comment\"\n+}\n+\n declare_lint! {\n     /// The `deref_into_dyn_supertrait` lint is output whenever there is a use of the\n     /// `Deref` implementation with a `dyn SuperTrait` type as `Output`."}, {"sha": "feac2a7cfa48a77a8b0c88c296f5f584023478ab", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=c0b134582a949062f9f3a8ba3def88b98a98df6a", "patch": "@@ -306,6 +306,7 @@ pub enum BuiltinLintDiagnostics {\n     TrailingMacro(bool, Ident),\n     BreakWithLabelAndLoop(Span),\n     NamedAsmLabel(String),\n+    UnicodeTextFlow(Span, String),\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "a823607ab0ec2191c86a3630fd2488d0c9198fb2", "filename": "compiler/rustc_parse/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_parse%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_parse%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2FCargo.toml?ref=c0b134582a949062f9f3a8ba3def88b98a98df6a", "patch": "@@ -18,3 +18,4 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_ast = { path = \"../rustc_ast\" }\n unicode-normalization = \"0.1.11\"\n+unicode-width = \"0.1.4\""}, {"sha": "8e90f73b44edda51c8ce00cb700e3b390d93eed4", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=c0b134582a949062f9f3a8ba3def88b98a98df6a", "patch": "@@ -4,7 +4,9 @@ use rustc_ast::tokenstream::{Spacing, TokenStream};\n use rustc_errors::{error_code, Applicability, DiagnosticBuilder, FatalError, PResult};\n use rustc_lexer::unescape::{self, Mode};\n use rustc_lexer::{Base, DocStyle, RawStrError};\n-use rustc_session::lint::builtin::RUST_2021_PREFIXES_INCOMPATIBLE_SYNTAX;\n+use rustc_session::lint::builtin::{\n+    TEXT_DIRECTION_CODEPOINT_IN_COMMENT, RUST_2021_PREFIXES_INCOMPATIBLE_SYNTAX,\n+};\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{sym, Symbol};\n@@ -129,14 +131,41 @@ impl<'a> StringReader<'a> {\n             .struct_span_fatal(self.mk_sp(from_pos, to_pos), &format!(\"{}: {}\", m, escaped_char(c)))\n     }\n \n+    /// Detect usages of Unicode codepoints changing the direction of the text on screen and loudly\n+    /// complain about it.\n+    fn lint_unicode_text_flow(&self, start: BytePos) {\n+        // Opening delimiter of the length 2 is not included into the comment text.\n+        let content_start = start + BytePos(2);\n+        let content = self.str_from(content_start);\n+        let span = self.mk_sp(start, self.pos);\n+        const UNICODE_TEXT_FLOW_CHARS: &[char] = &[\n+            '\\u{202A}', '\\u{202B}', '\\u{202D}', '\\u{202E}', '\\u{2066}', '\\u{2067}', '\\u{2068}',\n+            '\\u{202C}', '\\u{2069}',\n+        ];\n+        if content.contains(UNICODE_TEXT_FLOW_CHARS) {\n+            self.sess.buffer_lint_with_diagnostic(\n+                &TEXT_DIRECTION_CODEPOINT_IN_COMMENT,\n+                span,\n+                ast::CRATE_NODE_ID,\n+                \"unicode codepoint changing visible direction of text present in comment\",\n+                BuiltinLintDiagnostics::UnicodeTextFlow(span, content.to_string()),\n+            );\n+        }\n+    }\n+\n     /// Turns simple `rustc_lexer::TokenKind` enum into a rich\n     /// `rustc_ast::TokenKind`. This turns strings into interned\n     /// symbols and runs additional validation.\n     fn cook_lexer_token(&self, token: rustc_lexer::TokenKind, start: BytePos) -> Option<TokenKind> {\n         Some(match token {\n             rustc_lexer::TokenKind::LineComment { doc_style } => {\n                 // Skip non-doc comments\n-                let doc_style = doc_style?;\n+                let doc_style = if let Some(doc_style) = doc_style {\n+                    doc_style\n+                } else {\n+                    self.lint_unicode_text_flow(start);\n+                    return None;\n+                };\n \n                 // Opening delimiter of the length 3 is not included into the symbol.\n                 let content_start = start + BytePos(3);\n@@ -158,7 +187,12 @@ impl<'a> StringReader<'a> {\n                 }\n \n                 // Skip non-doc comments\n-                let doc_style = doc_style?;\n+                let doc_style = if let Some(doc_style) = doc_style {\n+                    doc_style\n+                } else {\n+                    self.lint_unicode_text_flow(start);\n+                    return None;\n+                };\n \n                 // Opening delimiter of the length 3 and closing delimiter of the length 2\n                 // are not included into the symbol."}, {"sha": "569f186a72766f45aed97f560400a3cc91c5f6e7", "filename": "compiler/rustc_parse/src/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b134582a949062f9f3a8ba3def88b98a98df6a/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs?ref=c0b134582a949062f9f3a8ba3def88b98a98df6a", "patch": "@@ -187,12 +187,17 @@ pub(crate) fn emit_unescape_error(\n             assert!(mode.is_bytes());\n             let (c, span) = last_char();\n             let mut err = handler.struct_span_err(span, \"non-ASCII character in byte constant\");\n-            err.span_label(span, \"byte constant must be ASCII\");\n+            let postfix = if unicode_width::UnicodeWidthChar::width(c).unwrap_or(1) == 0 {\n+                format!(\" but is {:?}\", c)\n+            } else {\n+                String::new()\n+            };\n+            err.span_label(span, &format!(\"byte constant must be ASCII{}\", postfix));\n             if (c as u32) <= 0xFF {\n                 err.span_suggestion(\n                     span,\n                     &format!(\n-                        \"if you meant to use the unicode code point for '{}', use a \\\\xHH escape\",\n+                        \"if you meant to use the unicode code point for {:?}, use a \\\\xHH escape\",\n                         c\n                     ),\n                     format!(\"\\\\x{:X}\", c as u32),\n@@ -206,7 +211,7 @@ pub(crate) fn emit_unescape_error(\n                 err.span_suggestion(\n                     span,\n                     &format!(\n-                        \"if you meant to use the UTF-8 encoding of '{}', use \\\\xHH escapes\",\n+                        \"if you meant to use the UTF-8 encoding of {:?}, use \\\\xHH escapes\",\n                         c\n                     ),\n                     utf8.as_bytes()\n@@ -220,10 +225,15 @@ pub(crate) fn emit_unescape_error(\n         }\n         EscapeError::NonAsciiCharInByteString => {\n             assert!(mode.is_bytes());\n-            let (_c, span) = last_char();\n+            let (c, span) = last_char();\n+            let postfix = if unicode_width::UnicodeWidthChar::width(c).unwrap_or(1) == 0 {\n+                format!(\" but is {:?}\", c)\n+            } else {\n+                String::new()\n+            };\n             handler\n                 .struct_span_err(span, \"raw byte string must be ASCII\")\n-                .span_label(span, \"must be ASCII\")\n+                .span_label(span, &format!(\"must be ASCII{}\", postfix))\n                 .emit();\n         }\n         EscapeError::OutOfRangeHexEscape => {"}, {"sha": "5af0b585a12755c2b1c46daf6f0bc5b0ad5fed2d", "filename": "src/test/ui/parser/unicode-control-codepoints.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c0b134582a949062f9f3a8ba3def88b98a98df6a/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b134582a949062f9f3a8ba3def88b98a98df6a/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.rs?ref=c0b134582a949062f9f3a8ba3def88b98a98df6a", "patch": "@@ -0,0 +1,39 @@\n+fn main() {\n+    // if access_level != \"us\u202be\u202ar\" { // Check if admin\n+    //~^ ERROR unicode codepoint changing visible direction of text present in comment\n+    println!(\"us\\u{202B}e\\u{202A}r\");\n+    println!(\"{:?}\", r#\"us\\u{202B}e\\u{202A}r\"#);\n+    println!(\"{:?}\", b\"us\\u{202B}e\\u{202A}r\");\n+    //~^ ERROR unicode escape in byte string\n+    //~| ERROR unicode escape in byte string\n+    println!(\"{:?}\", br##\"us\\u{202B}e\\u{202A}r\"##);\n+\n+    println!(\"{:?}\", \"/*\u202e } \u2066if isAdmin\u2069 \u2066 begin admins only \");\n+    //~^ ERROR unicode codepoint changing visible direction of text present in literal\n+\n+    println!(\"{:?}\", r##\"/*\u202e } \u2066if isAdmin\u2069 \u2066 begin admins only \"##);\n+    //~^ ERROR unicode codepoint changing visible direction of text present in literal\n+    println!(\"{:?}\", b\"/*\u202e } \u2066if isAdmin\u2069 \u2066 begin admins only \");\n+    //~^ ERROR non-ASCII character in byte constant\n+    //~| ERROR non-ASCII character in byte constant\n+    //~| ERROR non-ASCII character in byte constant\n+    //~| ERROR non-ASCII character in byte constant\n+    println!(\"{:?}\", br##\"/*\u202e } \u2066if isAdmin\u2069 \u2066 begin admins only \"##);\n+    //~^ ERROR raw byte string must be ASCII\n+    //~| ERROR raw byte string must be ASCII\n+    //~| ERROR raw byte string must be ASCII\n+    //~| ERROR raw byte string must be ASCII\n+    println!(\"{:?}\", '\u202e');\n+    //~^ ERROR unicode codepoint changing visible direction of text present in literal\n+}\n+\n+//\"/*\u202e } \u2066if isAdmin\u2069 \u2066 begin admins only */\"\n+//~^ ERROR unicode codepoint changing visible direction of text present in comment\n+\n+/**  '\u202e'); */fn foo() {}\n+//~^ ERROR unicode codepoint changing visible direction of text present in doc comment\n+\n+/**\n+ *\n+ *  '\u202e'); */fn bar() {}\n+//~^^^ ERROR unicode codepoint changing visible direction of text present in doc comment"}, {"sha": "71509fe41a84f78f9f8e2dd9cca95b04a17d4e98", "filename": "src/test/ui/parser/unicode-control-codepoints.stderr", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/c0b134582a949062f9f3a8ba3def88b98a98df6a/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b134582a949062f9f3a8ba3def88b98a98df6a/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funicode-control-codepoints.stderr?ref=c0b134582a949062f9f3a8ba3def88b98a98df6a", "patch": "@@ -0,0 +1,192 @@\n+error: unicode escape in byte string\n+  --> $DIR/unicode-control-codepoints.rs:6:26\n+   |\n+LL |     println!(\"{:?}\", b\"us\\u{202B}e\\u{202A}r\");\n+   |                          ^^^^^^^^ unicode escape in byte string\n+   |\n+   = help: unicode escape sequences cannot be used as a byte or in a byte string\n+\n+error: unicode escape in byte string\n+  --> $DIR/unicode-control-codepoints.rs:6:35\n+   |\n+LL |     println!(\"{:?}\", b\"us\\u{202B}e\\u{202A}r\");\n+   |                                   ^^^^^^^^ unicode escape in byte string\n+   |\n+   = help: unicode escape sequences cannot be used as a byte or in a byte string\n+\n+error: non-ASCII character in byte constant\n+  --> $DIR/unicode-control-codepoints.rs:16:26\n+   |\n+LL |     println!(\"{:?}\", b\"/* } if isAdmin  begin admins only \");\n+   |                          ^ byte constant must be ASCII but is '\\u{202e}'\n+   |\n+help: if you meant to use the UTF-8 encoding of '\\u{202e}', use \\xHH escapes\n+   |\n+LL |     println!(\"{:?}\", b\"/*\\xE2\\x80\\xAE } if isAdmin  begin admins only \");\n+   |                          ~~~~~~~~~~~~\n+\n+error: non-ASCII character in byte constant\n+  --> $DIR/unicode-control-codepoints.rs:16:30\n+   |\n+LL |     println!(\"{:?}\", b\"/* } if isAdmin  begin admins only \");\n+   |                             ^ byte constant must be ASCII but is '\\u{2066}'\n+   |\n+help: if you meant to use the UTF-8 encoding of '\\u{2066}', use \\xHH escapes\n+   |\n+LL |     println!(\"{:?}\", b\"/* } \\xE2\\x81\\xA6if isAdmin  begin admins only \");\n+   |                             ~~~~~~~~~~~~\n+\n+error: non-ASCII character in byte constant\n+  --> $DIR/unicode-control-codepoints.rs:16:41\n+   |\n+LL |     println!(\"{:?}\", b\"/* } if isAdmin  begin admins only \");\n+   |                                       ^ byte constant must be ASCII but is '\\u{2069}'\n+   |\n+help: if you meant to use the UTF-8 encoding of '\\u{2069}', use \\xHH escapes\n+   |\n+LL |     println!(\"{:?}\", b\"/* } if isAdmin\\xE2\\x81\\xA9  begin admins only \");\n+   |                                       ~~~~~~~~~~~~\n+\n+error: non-ASCII character in byte constant\n+  --> $DIR/unicode-control-codepoints.rs:16:43\n+   |\n+LL |     println!(\"{:?}\", b\"/* } if isAdmin  begin admins only \");\n+   |                                        ^ byte constant must be ASCII but is '\\u{2066}'\n+   |\n+help: if you meant to use the UTF-8 encoding of '\\u{2066}', use \\xHH escapes\n+   |\n+LL |     println!(\"{:?}\", b\"/* } if isAdmin \\xE2\\x81\\xA6 begin admins only \");\n+   |                                        ~~~~~~~~~~~~\n+\n+error: raw byte string must be ASCII\n+  --> $DIR/unicode-control-codepoints.rs:21:29\n+   |\n+LL |     println!(\"{:?}\", br##\"/* } if isAdmin  begin admins only \"##);\n+   |                             ^ must be ASCII but is '\\u{202e}'\n+\n+error: raw byte string must be ASCII\n+  --> $DIR/unicode-control-codepoints.rs:21:33\n+   |\n+LL |     println!(\"{:?}\", br##\"/* } if isAdmin  begin admins only \"##);\n+   |                                ^ must be ASCII but is '\\u{2066}'\n+\n+error: raw byte string must be ASCII\n+  --> $DIR/unicode-control-codepoints.rs:21:44\n+   |\n+LL |     println!(\"{:?}\", br##\"/* } if isAdmin  begin admins only \"##);\n+   |                                          ^ must be ASCII but is '\\u{2069}'\n+\n+error: raw byte string must be ASCII\n+  --> $DIR/unicode-control-codepoints.rs:21:46\n+   |\n+LL |     println!(\"{:?}\", br##\"/* } if isAdmin  begin admins only \"##);\n+   |                                           ^ must be ASCII but is '\\u{2066}'\n+\n+error: unicode codepoint changing visible direction of text present in comment\n+  --> $DIR/unicode-control-codepoints.rs:2:5\n+   |\n+LL |     // if access_level != \"user\" { // Check if admin\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^--^^^^^^^^^^^^^^^^^^^^^\n+   |     |                        ||\n+   |     |                        |'\\u{202a}'\n+   |     |                        '\\u{202b}'\n+   |     this comment contains invisible unicode text flow control codepoints\n+   |\n+   = note: `#[deny(text_direction_codepoint_in_comment)]` on by default\n+   = note: these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen\n+   = help: if their presence wasn't intentional, you can remove them\n+\n+error: unicode codepoint changing visible direction of text present in comment\n+  --> $DIR/unicode-control-codepoints.rs:30:1\n+   |\n+LL | //\"/* } if isAdmin  begin admins only */\"\n+   | ^^^^^-^^-^^^^^^^^^--^^^^^^^^^^^^^^^^^^^^^\n+   | |    |  |         ||\n+   | |    |  |         |'\\u{2066}'\n+   | |    |  |         '\\u{2069}'\n+   | |    |  '\\u{2066}'\n+   | |    '\\u{202e}'\n+   | this comment contains invisible unicode text flow control codepoints\n+   |\n+   = note: these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen\n+   = help: if their presence wasn't intentional, you can remove them\n+\n+error: unicode codepoint changing visible direction of text present in literal\n+  --> $DIR/unicode-control-codepoints.rs:11:22\n+   |\n+LL |     println!(\"{:?}\", \"/* } if isAdmin  begin admins only \");\n+   |                      ^^^-^^-^^^^^^^^^--^^^^^^^^^^^^^^^^^^^\n+   |                      |  |  |         ||\n+   |                      |  |  |         |'\\u{2066}'\n+   |                      |  |  |         '\\u{2069}'\n+   |                      |  |  '\\u{2066}'\n+   |                      |  '\\u{202e}'\n+   |                      this literal contains invisible unicode text flow control codepoints\n+   |\n+   = note: `#[deny(text_direction_codepoint_in_literal)]` on by default\n+   = note: these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen\n+   = help: if their presence wasn't intentional, you can remove them\n+help: if you want to keep them but make them visible in your source code, you can escape them\n+   |\n+LL |     println!(\"{:?}\", \"/*\\u{202e} } \\u{2066}if isAdmin\\u{2069} \\u{2066} begin admins only \");\n+   |                         ~~~~~~~~   ~~~~~~~~          ~~~~~~~~ ~~~~~~~~\n+\n+error: unicode codepoint changing visible direction of text present in literal\n+  --> $DIR/unicode-control-codepoints.rs:14:22\n+   |\n+LL |     println!(\"{:?}\", r##\"/* } if isAdmin  begin admins only \"##);\n+   |                      ^^^^^^-^^-^^^^^^^^^--^^^^^^^^^^^^^^^^^^^^^\n+   |                      |     |  |         ||\n+   |                      |     |  |         |'\\u{2066}'\n+   |                      |     |  |         '\\u{2069}'\n+   |                      |     |  '\\u{2066}'\n+   |                      |     '\\u{202e}'\n+   |                      this literal contains invisible unicode text flow control codepoints\n+   |\n+   = note: these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen\n+   = help: if their presence wasn't intentional, you can remove them\n+help: if you want to keep them but make them visible in your source code, you can escape them\n+   |\n+LL |     println!(\"{:?}\", r##\"/*\\u{202e} } \\u{2066}if isAdmin\\u{2069} \\u{2066} begin admins only \"##);\n+   |                            ~~~~~~~~   ~~~~~~~~          ~~~~~~~~ ~~~~~~~~\n+\n+error: unicode codepoint changing visible direction of text present in literal\n+  --> $DIR/unicode-control-codepoints.rs:26:22\n+   |\n+LL |     println!(\"{:?}\", '');\n+   |                      ^-\n+   |                      ||\n+   |                      |'\\u{202e}'\n+   |                      this literal contains an invisible unicode text flow control codepoint\n+   |\n+   = note: these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen\n+   = help: if their presence wasn't intentional, you can remove them\n+help: if you want to keep them but make them visible in your source code, you can escape them\n+   |\n+LL |     println!(\"{:?}\", '\\u{202e}');\n+   |                       ~~~~~~~~\n+\n+error: unicode codepoint changing visible direction of text present in doc comment\n+  --> $DIR/unicode-control-codepoints.rs:33:1\n+   |\n+LL | /**  ''); */fn foo() {}\n+   | ^^^^^^^^^^^^ this doc comment contains an invisible unicode text flow control codepoint\n+   |\n+   = note: these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen\n+   = note: if their presence wasn't intentional, you can remove them\n+   = note: if you want to keep them but make them visible in your source code, you can escape them: '\\u{202e}'\n+\n+error: unicode codepoint changing visible direction of text present in doc comment\n+  --> $DIR/unicode-control-codepoints.rs:36:1\n+   |\n+LL | / /**\n+LL | |  *\n+LL | |  *  ''); */fn bar() {}\n+   | |___________^ this doc comment contains an invisible unicode text flow control codepoint\n+   |\n+   = note: these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen\n+   = note: if their presence wasn't intentional, you can remove them\n+   = note: if you want to keep them but make them visible in your source code, you can escape them: '\\u{202e}'\n+\n+error: aborting due to 17 previous errors\n+"}]}