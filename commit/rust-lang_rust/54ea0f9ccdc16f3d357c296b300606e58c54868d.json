{"sha": "54ea0f9ccdc16f3d357c296b300606e58c54868d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZWEwZjljY2RjMTZmM2QzNTdjMjk2YjMwMDYwNmU1OGM1NDg2OGQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-10-28T00:21:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-28T00:21:18Z"}, "message": "Rollup merge of #78351 - RalfJung:validity-unsafe-cell, r=oli-obk\n\nMove \"mutable thing in const\" check from interning to validity\n\nThis moves the check for mutable things (such as `UnsafeCell` or `&mut`) in a`const` from interning to validity. That means we can give more targeted error messages (pointing out *where* the problem lies), and we can simplify interning a bit.\n\nAlso fix the interning mode used for promoteds in statics.\n\nr? @oli-obk", "tree": {"sha": "f2b4bb5b5fd27f04dcabbe68465daa90b42522c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2b4bb5b5fd27f04dcabbe68465daa90b42522c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54ea0f9ccdc16f3d357c296b300606e58c54868d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfmLl/CRBK7hj4Ov3rIwAAdHIIAAwHVkSeckpynMdHzRlb7p7G\nhK/it1iOKuRiPH4+cMXMTGXVCIBy0rM95PbydKDpMj5NCB+4xN9bv8C99uG5boM/\nQh7/LYFo187p01+w8IOzq5aCUbuviYL6L37f1vyIx5zhDi+Jo8erRAtjKDylaa5B\nVjz8xH6f2twFcU+J8t4neHbyrz2d7prxFX+djhIe2K49B0FdFdgBoJh9YZO2g+aY\nTrAG0n4nZcQmjZ87T6cIqLOdmy8CYcyQ3MfduzF2JyfSbLl4tH4GdKGuwlKQjn0H\nzfqP+qW+MluUzhs/Dh7PiWUCJPva8DLx9AFNxKf+iTpqM4UuCgB3Z+koSA6KXDc=\n=sCQM\n-----END PGP SIGNATURE-----\n", "payload": "tree f2b4bb5b5fd27f04dcabbe68465daa90b42522c2\nparent 86a4a381772a06ecf6c20384a1b32a49ea1574e0\nparent 744dfd8847e447edf7e612196d6eec665ce36c04\nauthor Dylan DPC <dylan.dpc@gmail.com> 1603844478 +0100\ncommitter GitHub <noreply@github.com> 1603844478 +0100\n\nRollup merge of #78351 - RalfJung:validity-unsafe-cell, r=oli-obk\n\nMove \"mutable thing in const\" check from interning to validity\n\nThis moves the check for mutable things (such as `UnsafeCell` or `&mut`) in a`const` from interning to validity. That means we can give more targeted error messages (pointing out *where* the problem lies), and we can simplify interning a bit.\n\nAlso fix the interning mode used for promoteds in statics.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54ea0f9ccdc16f3d357c296b300606e58c54868d", "html_url": "https://github.com/rust-lang/rust/commit/54ea0f9ccdc16f3d357c296b300606e58c54868d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54ea0f9ccdc16f3d357c296b300606e58c54868d/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86a4a381772a06ecf6c20384a1b32a49ea1574e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/86a4a381772a06ecf6c20384a1b32a49ea1574e0", "html_url": "https://github.com/rust-lang/rust/commit/86a4a381772a06ecf6c20384a1b32a49ea1574e0"}, {"sha": "744dfd8847e447edf7e612196d6eec665ce36c04", "url": "https://api.github.com/repos/rust-lang/rust/commits/744dfd8847e447edf7e612196d6eec665ce36c04", "html_url": "https://github.com/rust-lang/rust/commit/744dfd8847e447edf7e612196d6eec665ce36c04"}], "stats": {"total": 279, "additions": 135, "deletions": 144}, "files": [{"sha": "a753732d364396f81243f98ba8ec449383398333", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=54ea0f9ccdc16f3d357c296b300606e58c54868d", "patch": "@@ -210,16 +210,6 @@ pub struct Body<'tcx> {\n     /// We hold in this field all the constants we are not able to evaluate yet.\n     pub required_consts: Vec<Constant<'tcx>>,\n \n-    /// The user may be writing e.g. `&[(SOME_CELL, 42)][i].1` and this would get promoted, because\n-    /// we'd statically know that no thing with interior mutability will ever be available to the\n-    /// user without some serious unsafe code.  Now this means that our promoted is actually\n-    /// `&[(SOME_CELL, 42)]` and the MIR using it will do the `&promoted[i].1` projection because\n-    /// the index may be a runtime value. Such a promoted value is illegal because it has reachable\n-    /// interior mutability. This flag just makes this situation very obvious where the previous\n-    /// implementation without the flag hid this situation silently.\n-    /// FIXME(oli-obk): rewrite the promoted during promotion to eliminate the cell components.\n-    pub ignore_interior_mut_in_const_validation: bool,\n-\n     /// Does this body use generic parameters. This is used for the `ConstEvaluatable` check.\n     ///\n     /// Note that this does not actually mean that this body is not computable right now.\n@@ -276,7 +266,6 @@ impl<'tcx> Body<'tcx> {\n             var_debug_info,\n             span,\n             required_consts: Vec::new(),\n-            ignore_interior_mut_in_const_validation: false,\n             is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n         };\n@@ -306,7 +295,6 @@ impl<'tcx> Body<'tcx> {\n             required_consts: Vec::new(),\n             generator_kind: None,\n             var_debug_info: Vec::new(),\n-            ignore_interior_mut_in_const_validation: false,\n             is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n         };"}, {"sha": "7b9a4ec873d0a757d9794e2085717fd09978bd53", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=54ea0f9ccdc16f3d357c296b300606e58c54868d", "patch": "@@ -1,8 +1,8 @@\n use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr, MemoryExtra};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n-    intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, GlobalId, Immediate,\n-    InternKind, InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RefTracking, Scalar,\n+    intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n+    Immediate, InternKind, InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RefTracking, Scalar,\n     ScalarMaybeUninit, StackPopCleanup,\n };\n \n@@ -59,23 +59,15 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.run()?;\n \n     // Intern the result\n-    // FIXME: since the DefId of a promoted is the DefId of its owner, this\n-    // means that promoteds in statics are actually interned like statics!\n-    // However, this is also currently crucial because we promote mutable\n-    // non-empty slices in statics to extend their lifetime, and this\n-    // ensures that they are put into a mutable allocation.\n-    // For other kinds of promoteds in statics (like array initializers), this is rather silly.\n-    let intern_kind = match tcx.static_mutability(cid.instance.def_id()) {\n-        Some(m) => InternKind::Static(m),\n-        None if cid.promoted.is_some() => InternKind::Promoted,\n-        _ => InternKind::Constant,\n+    let intern_kind = if cid.promoted.is_some() {\n+        InternKind::Promoted\n+    } else {\n+        match tcx.static_mutability(cid.instance.def_id()) {\n+            Some(m) => InternKind::Static(m),\n+            None => InternKind::Constant,\n+        }\n     };\n-    intern_const_alloc_recursive(\n-        ecx,\n-        intern_kind,\n-        ret,\n-        body.ignore_interior_mut_in_const_validation,\n-    );\n+    intern_const_alloc_recursive(ecx, intern_kind, ret);\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)\n@@ -376,16 +368,23 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n             // Since evaluation had no errors, valiate the resulting constant:\n             let validation = try {\n                 // FIXME do not validate promoteds until a decision on\n-                // https://github.com/rust-lang/rust/issues/67465 is made\n+                // https://github.com/rust-lang/rust/issues/67465 and\n+                // https://github.com/rust-lang/rust/issues/67534 is made.\n+                // Promoteds can contain unexpected `UnsafeCell` and reference `static`s, but their\n+                // otherwise restricted form ensures that this is still sound. We just lose the\n+                // extra safety net of some of the dynamic checks. They can also contain invalid\n+                // values, but since we do not usually check intermediate results of a computation\n+                // for validity, it might be surprising to do that here.\n                 if cid.promoted.is_none() {\n                     let mut ref_tracking = RefTracking::new(mplace);\n+                    let mut inner = false;\n                     while let Some((mplace, path)) = ref_tracking.todo.pop() {\n-                        ecx.const_validate_operand(\n-                            mplace.into(),\n-                            path,\n-                            &mut ref_tracking,\n-                            /*may_ref_to_static*/ ecx.memory.extra.can_access_statics,\n-                        )?;\n+                        let mode = match tcx.static_mutability(cid.instance.def_id()) {\n+                            Some(_) => CtfeValidationMode::Regular, // a `static`\n+                            None => CtfeValidationMode::Const { inner },\n+                        };\n+                        ecx.const_validate_operand(mplace.into(), path, &mut ref_tracking, mode)?;\n+                        inner = true;\n                     }\n                 }\n             };"}, {"sha": "11a211ef7b3518a39c558e8417b924c4f5672b45", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=54ea0f9ccdc16f3d357c296b300606e58c54868d", "patch": "@@ -29,7 +29,7 @@ pub(crate) fn const_caller_location(\n     let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all(), false);\n \n     let loc_place = ecx.alloc_caller_location(file, line, col);\n-    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place, false);\n+    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place);\n     ConstValue::Scalar(loc_place.ptr)\n }\n "}, {"sha": "5e5c74a3723747f8ad6801a65c045ff9a695d14f", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 28, "deletions": 59, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=54ea0f9ccdc16f3d357c296b300606e58c54868d", "patch": "@@ -2,12 +2,23 @@\n //!\n //! After a const evaluation has computed a value, before we destroy the const evaluator's session\n //! memory, we need to extract all memory allocations to the global memory pool so they stay around.\n+//!\n+//! In principle, this is not very complicated: we recursively walk the final value, follow all the\n+//! pointers, and move all reachable allocations to the global `tcx` memory. The only complication\n+//! is picking the right mutability for the allocations in a `static` initializer: we want to make\n+//! as many allocations as possible immutable so LLVM can put them into read-only memory. At the\n+//! same time, we need to make memory that could be mutated by the program mutable to avoid\n+//! incorrect compilations. To achieve this, we do a type-based traversal of the final value,\n+//! tracking mutable and shared references and `UnsafeCell` to determine the current mutability.\n+//! (In principle, we could skip this type-based part for `const` and promoteds, as they need to be\n+//! always immutable. At least for `const` however we use this opportunity to reject any `const`\n+//! that contains allocations whose mutability we cannot identify.)\n \n use super::validity::RefTracking;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_middle::mir::interpret::InterpResult;\n-use rustc_middle::ty::{self, layout::TyAndLayout, query::TyCtxtAt, Ty};\n+use rustc_middle::ty::{self, layout::TyAndLayout, Ty};\n use rustc_target::abi::Size;\n \n use rustc_ast::Mutability;\n@@ -40,11 +51,6 @@ struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> {\n     /// This field stores whether we are *currently* inside an `UnsafeCell`. This can affect\n     /// the intern mode of references we encounter.\n     inside_unsafe_cell: bool,\n-\n-    /// This flag is to avoid triggering UnsafeCells are not allowed behind references in constants\n-    /// for promoteds.\n-    /// It's a copy of `mir::Body`'s ignore_interior_mut_in_const_validation field\n-    ignore_interior_mut_in_const: bool,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n@@ -53,22 +59,14 @@ enum InternMode {\n     /// this is *immutable*, and below mutable references inside an `UnsafeCell`, this\n     /// is *mutable*.\n     Static(hir::Mutability),\n-    /// The \"base value\" of a const, which can have `UnsafeCell` (as in `const FOO: Cell<i32>`),\n-    /// but that interior mutability is simply ignored.\n-    ConstBase,\n-    /// The \"inner values\" of a const with references, where `UnsafeCell` is an error.\n-    ConstInner,\n+    /// A `const`.\n+    Const,\n }\n \n /// Signalling data structure to ensure we don't recurse\n /// into the memory of other constants or statics\n struct IsStaticOrFn;\n \n-fn mutable_memory_in_const(tcx: TyCtxtAt<'_>, kind: &str) {\n-    // FIXME: show this in validation instead so we can point at where in the value the error is?\n-    tcx.sess.span_err(tcx.span, &format!(\"mutable memory ({}) is not allowed in constant\", kind));\n-}\n-\n /// Intern an allocation without looking at its children.\n /// `mode` is the mode of the environment where we found this pointer.\n /// `mutablity` is the mutability of the place to be interned; even if that says\n@@ -129,9 +127,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n         // See const_eval::machine::MemoryExtra::can_access_statics for why\n         // immutability is so important.\n \n-        // There are no sensible checks we can do here; grep for `mutable_memory_in_const` to\n-        // find the checks we are doing elsewhere to avoid even getting here for memory\n-        // that \"wants\" to be mutable.\n+        // Validation will ensure that there is no `UnsafeCell` on an immutable allocation.\n         alloc.mutability = Mutability::Not;\n     };\n     // link the alloc id to the actual allocation\n@@ -167,17 +163,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n         mplace: MPlaceTy<'tcx>,\n         fields: impl Iterator<Item = InterpResult<'tcx, Self::V>>,\n     ) -> InterpResult<'tcx> {\n+        // ZSTs cannot contain pointers, so we can skip them.\n+        if mplace.layout.is_zst() {\n+            return Ok(());\n+        }\n+\n         if let Some(def) = mplace.layout.ty.ty_adt_def() {\n             if Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n-                if self.mode == InternMode::ConstInner && !self.ignore_interior_mut_in_const {\n-                    // We do not actually make this memory mutable.  But in case the user\n-                    // *expected* it to be mutable, make sure we error.  This is just a\n-                    // sanity check to prevent users from accidentally exploiting the UB\n-                    // they caused.  It also helps us to find cases where const-checking\n-                    // failed to prevent an `UnsafeCell` (but as `ignore_interior_mut_in_const`\n-                    // shows that part is not airtight).\n-                    mutable_memory_in_const(self.ecx.tcx, \"`UnsafeCell`\");\n-                }\n                 // We are crossing over an `UnsafeCell`, we can mutate again. This means that\n                 // References we encounter inside here are interned as pointing to mutable\n                 // allocations.\n@@ -189,11 +181,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n             }\n         }\n \n-        // ZSTs cannot contain pointers, so we can skip them.\n-        if mplace.layout.is_zst() {\n-            return Ok(());\n-        }\n-\n         self.walk_aggregate(mplace, fields)\n     }\n \n@@ -213,7 +200,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                 if let Scalar::Ptr(vtable) = mplace.meta.unwrap_meta() {\n                     // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable.\n-                    self.intern_shallow(vtable.alloc_id, InternMode::ConstInner, None);\n+                    self.intern_shallow(vtable.alloc_id, InternMode::Const, None);\n                 } else {\n                     // Validation will error (with a better message) on an invalid vtable pointer.\n                     // Let validation show the error message, but make sure it *does* error.\n@@ -225,7 +212,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n             // Only recurse for allocation-backed pointers.\n             if let Scalar::Ptr(ptr) = mplace.ptr {\n                 // Compute the mode with which we intern this. Our goal here is to make as many\n-                // statics as we can immutable so they can be placed in const memory by LLVM.\n+                // statics as we can immutable so they can be placed in read-only memory by LLVM.\n                 let ref_mode = match self.mode {\n                     InternMode::Static(mutbl) => {\n                         // In statics, merge outer mutability with reference mutability and\n@@ -259,27 +246,11 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                             }\n                         }\n                     }\n-                    InternMode::ConstBase | InternMode::ConstInner => {\n-                        // Ignore `UnsafeCell`, everything is immutable.  Do some sanity checking\n-                        // for mutable references that we encounter -- they must all be ZST.\n-                        // This helps to prevent users from accidentally exploiting UB that they\n-                        // caused (by somehow getting a mutable reference in a `const`).\n-                        if ref_mutability == Mutability::Mut {\n-                            match referenced_ty.kind() {\n-                                ty::Array(_, n) if n.eval_usize(*tcx, self.ecx.param_env) == 0 => {}\n-                                ty::Slice(_)\n-                                    if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)?\n-                                        == 0 => {}\n-                                _ => mutable_memory_in_const(tcx, \"`&mut`\"),\n-                            }\n-                        } else {\n-                            // A shared reference. We cannot check `freeze` here due to references\n-                            // like `&dyn Trait` that are actually immutable.  We do check for\n-                            // concrete `UnsafeCell` when traversing the pointee though (if it is\n-                            // a new allocation, not yet interned).\n-                        }\n-                        // Go on with the \"inner\" rules.\n-                        InternMode::ConstInner\n+                    InternMode::Const => {\n+                        // Ignore `UnsafeCell`, everything is immutable.  Validity does some sanity\n+                        // checking for mutable references that we encounter -- they must all be\n+                        // ZST.\n+                        InternMode::Const\n                     }\n                 };\n                 match self.intern_shallow(ptr.alloc_id, ref_mode, Some(referenced_ty)) {\n@@ -318,7 +289,6 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &mut InterpCx<'mir, 'tcx, M>,\n     intern_kind: InternKind,\n     ret: MPlaceTy<'tcx>,\n-    ignore_interior_mut_in_const: bool,\n ) where\n     'tcx: 'mir,\n {\n@@ -327,7 +297,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n         InternKind::Static(mutbl) => InternMode::Static(mutbl),\n         // `Constant` includes array lengths.\n         // `Promoted` includes non-`Copy` array initializers and `rustc_args_required_const` arguments.\n-        InternKind::Constant | InternKind::Promoted => InternMode::ConstBase,\n+        InternKind::Constant | InternKind::Promoted => InternMode::Const,\n     };\n \n     // Type based interning.\n@@ -357,7 +327,6 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             ecx,\n             mode,\n             leftover_allocations,\n-            ignore_interior_mut_in_const,\n             inside_unsafe_cell: false,\n         }\n         .visit_value(mplace);"}, {"sha": "a29ef117ace831c8696ce74a1e54d7e8c9210e17", "filename": "compiler/rustc_mir/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs?ref=54ea0f9ccdc16f3d357c296b300606e58c54868d", "patch": "@@ -24,7 +24,7 @@ pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackP\n pub use self::memory::{AllocCheck, FnVal, Memory, MemoryKind};\n pub use self::operand::{ImmTy, Immediate, OpTy, Operand};\n pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n-pub use self::validity::RefTracking;\n+pub use self::validity::{CtfeValidationMode, RefTracking};\n pub use self::visitor::{MutValueVisitor, ValueVisitor};\n \n crate use self::intrinsics::eval_nullary_intrinsic;"}, {"sha": "f657c6c4538328fef0399b73b3de74ff5623c4d7", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 58, "deletions": 30, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=54ea0f9ccdc16f3d357c296b300606e58c54868d", "patch": "@@ -113,6 +113,17 @@ pub enum PathElem {\n     DynDowncast,\n }\n \n+/// Extra things to check for during validation of CTFE results.\n+pub enum CtfeValidationMode {\n+    /// Regular validation, nothing special happening.\n+    Regular,\n+    /// Validation of a `const`. `inner` says if this is an inner, indirect allocation (as opposed\n+    /// to the top-level const allocation).\n+    /// Being an inner allocation makes a difference because the top-level allocation of a `const`\n+    /// is copied for each use, but the inner allocations are implicitly shared.\n+    Const { inner: bool },\n+}\n+\n /// State for tracking recursive validation of references\n pub struct RefTracking<T, PATH = ()> {\n     pub seen: FxHashSet<T>,\n@@ -202,9 +213,9 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n     /// this stack discipline.\n     path: Vec<PathElem>,\n-    ref_tracking_for_consts:\n-        Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n-    may_ref_to_static: bool,\n+    ref_tracking: Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n+    /// `None` indicates this is not validating for CTFE (but for runtime).\n+    ctfe_mode: Option<CtfeValidationMode>,\n     ecx: &'rt InterpCx<'mir, 'tcx, M>,\n }\n \n@@ -418,27 +429,15 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 { \"a dangling {} (use-after-free)\", kind },\n         );\n         // Recursive checking\n-        if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n+        if let Some(ref mut ref_tracking) = self.ref_tracking {\n             if let Some(ptr) = ptr {\n                 // not a ZST\n                 // Skip validation entirely for some external statics\n                 let alloc_kind = self.ecx.tcx.get_global_alloc(ptr.alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n                     assert!(!self.ecx.tcx.is_thread_local_static(did));\n                     assert!(self.ecx.tcx.is_static(did));\n-                    if self.may_ref_to_static {\n-                        // We skip checking other statics. These statics must be sound by\n-                        // themselves, and the only way to get broken statics here is by using\n-                        // unsafe code.\n-                        // The reasons we don't check other statics is twofold. For one, in all\n-                        // sound cases, the static was already validated on its own, and second, we\n-                        // trigger cycle errors if we try to compute the value of the other static\n-                        // and that static refers back to us.\n-                        // We might miss const-invalid data,\n-                        // but things are still sound otherwise (in particular re: consts\n-                        // referring to statics).\n-                        return Ok(());\n-                    } else {\n+                    if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { .. })) {\n                         // See const_eval::machine::MemoryExtra::can_access_statics for why\n                         // this check is so important.\n                         // This check is reachable when the const just referenced the static,\n@@ -447,6 +446,17 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                             { \"a {} pointing to a static variable\", kind }\n                         );\n                     }\n+                    // We skip checking other statics. These statics must be sound by\n+                    // themselves, and the only way to get broken statics here is by using\n+                    // unsafe code.\n+                    // The reasons we don't check other statics is twofold. For one, in all\n+                    // sound cases, the static was already validated on its own, and second, we\n+                    // trigger cycle errors if we try to compute the value of the other static\n+                    // and that static refers back to us.\n+                    // We might miss const-invalid data,\n+                    // but things are still sound otherwise (in particular re: consts\n+                    // referring to statics).\n+                    return Ok(());\n                 }\n             }\n             // Proceed recursively even for ZST, no reason to skip them!\n@@ -504,7 +514,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let value = self.ecx.read_scalar(value)?;\n                 // NOTE: Keep this in sync with the array optimization for int/float\n                 // types below!\n-                if self.ref_tracking_for_consts.is_some() {\n+                if self.ctfe_mode.is_some() {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n                     let is_bits = value.check_init().map_or(false, |v| v.is_bits());\n                     if !is_bits {\n@@ -532,7 +542,17 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 }\n                 Ok(true)\n             }\n-            ty::Ref(..) => {\n+            ty::Ref(_, ty, mutbl) => {\n+                if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { .. }))\n+                    && *mutbl == hir::Mutability::Mut\n+                {\n+                    // A mutable reference inside a const? That does not seem right (except if it is\n+                    // a ZST).\n+                    let layout = self.ecx.layout_of(ty)?;\n+                    if !layout.is_zst() {\n+                        throw_validation_failure!(self.path, { \"mutable reference in a `const`\" });\n+                    }\n+                }\n                 self.check_safe_pointer(value, \"reference\")?;\n                 Ok(true)\n             }\n@@ -723,6 +743,15 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // Sanity check: `builtin_deref` does not know any pointers that are not primitive.\n         assert!(op.layout.ty.builtin_deref(true).is_none());\n \n+        // Special check preventing `UnsafeCell` in constants\n+        if let Some(def) = op.layout.ty.ty_adt_def() {\n+            if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true }))\n+                && Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type()\n+            {\n+                throw_validation_failure!(self.path, { \"`UnsafeCell` in a `const`\" });\n+            }\n+        }\n+\n         // Recursively walk the value at its type.\n         self.walk_value(op)?;\n \n@@ -814,7 +843,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     self.ecx,\n                     ptr,\n                     size,\n-                    /*allow_uninit_and_ptr*/ self.ref_tracking_for_consts.is_none(),\n+                    /*allow_uninit_and_ptr*/ self.ctfe_mode.is_none(),\n                 ) {\n                     // In the happy case, we needn't check anything else.\n                     Ok(()) => {}\n@@ -865,16 +894,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n-        ref_tracking_for_consts: Option<\n-            &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n-        >,\n-        may_ref_to_static: bool,\n+        ref_tracking: Option<&mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>>,\n+        ctfe_mode: Option<CtfeValidationMode>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"validate_operand_internal: {:?}, {:?}\", *op, op.layout.ty);\n \n         // Construct a visitor\n-        let mut visitor =\n-            ValidityVisitor { path, ref_tracking_for_consts, may_ref_to_static, ecx: self };\n+        let mut visitor = ValidityVisitor { path, ref_tracking, ctfe_mode, ecx: self };\n \n         // Try to cast to ptr *once* instead of all the time.\n         let op = self.force_op_ptr(op).unwrap_or(op);\n@@ -902,23 +928,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// `ref_tracking` is used to record references that we encounter so that they\n     /// can be checked recursively by an outside driving loop.\n     ///\n-    /// `may_ref_to_static` controls whether references are allowed to point to statics.\n+    /// `constant` controls whether this must satisfy the rules for constants:\n+    /// - no pointers to statics.\n+    /// - no `UnsafeCell` or non-ZST `&mut`.\n     #[inline(always)]\n     pub fn const_validate_operand(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n         ref_tracking: &mut RefTracking<MPlaceTy<'tcx, M::PointerTag>, Vec<PathElem>>,\n-        may_ref_to_static: bool,\n+        ctfe_mode: CtfeValidationMode,\n     ) -> InterpResult<'tcx> {\n-        self.validate_operand_internal(op, path, Some(ref_tracking), may_ref_to_static)\n+        self.validate_operand_internal(op, path, Some(ref_tracking), Some(ctfe_mode))\n     }\n \n     /// This function checks the data at `op` to be runtime-valid.\n     /// `op` is assumed to cover valid memory if it is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     #[inline(always)]\n     pub fn validate_operand(&self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n-        self.validate_operand_internal(op, vec![], None, false)\n+        self.validate_operand_internal(op, vec![], None, None)\n     }\n }"}, {"sha": "d47e549b7be371fb9078860a61b43262cad6751f", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=54ea0f9ccdc16f3d357c296b300606e58c54868d", "patch": "@@ -9,7 +9,6 @@ use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::mir::interpret::{InterpResult, Scalar};\n use rustc_middle::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n@@ -28,9 +27,10 @@ use rustc_trait_selection::traits;\n \n use crate::const_eval::ConstEvalErr;\n use crate::interpret::{\n-    self, compile_time_machine, truncate, AllocId, Allocation, ConstValue, Frame, ImmTy, Immediate,\n-    InterpCx, LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand,\n-    PlaceTy, Pointer, ScalarMaybeUninit, StackPopCleanup,\n+    self, compile_time_machine, truncate, AllocId, Allocation, ConstValue, CtfeValidationMode,\n+    Frame, ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemPlace, Memory,\n+    MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n+    StackPopCleanup,\n };\n use crate::transform::MirPass;\n \n@@ -805,8 +805,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             value,\n             vec![],\n             // FIXME: is ref tracking too expensive?\n+            // FIXME: what is the point of ref tracking if we do not even check the tracked refs?\n             &mut interpret::RefTracking::empty(),\n-            /*may_ref_to_static*/ true,\n+            CtfeValidationMode::Regular,\n         ) {\n             trace!(\"validation error, attempt failed: {:?}\", e);\n             return;"}, {"sha": "927aae82a36efab1c3cb9a66b4abd18548a453d0", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ea0f9ccdc16f3d357c296b300606e58c54868d/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=54ea0f9ccdc16f3d357c296b300606e58c54868d", "patch": "@@ -1170,7 +1170,7 @@ pub fn promote_candidates<'tcx>(\n         let mut scope = body.source_scopes[candidate.source_info(body).scope].clone();\n         scope.parent_scope = None;\n \n-        let mut promoted = Body::new(\n+        let promoted = Body::new(\n             body.source, // `promoted` gets filled in below\n             IndexVec::new(),\n             IndexVec::from_elem_n(scope, 1),\n@@ -1181,7 +1181,6 @@ pub fn promote_candidates<'tcx>(\n             body.span,\n             body.generator_kind,\n         );\n-        promoted.ignore_interior_mut_in_const_validation = true;\n \n         let promoter = Promoter {\n             promoted,"}, {"sha": "195414dbad9a2395ddce4654f5296c067ae418cb", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54ea0f9ccdc16f3d357c296b300606e58c54868d/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54ea0f9ccdc16f3d357c296b300606e58c54868d/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.rs?ref=54ea0f9ccdc16f3d357c296b300606e58c54868d", "patch": "@@ -13,7 +13,7 @@ unsafe impl Sync for Meh {}\n \n // the following will never be ok! no interior mut behind consts, because\n // all allocs interned here will be marked immutable.\n-const MUH: Meh = Meh { //~ ERROR: mutable memory (`UnsafeCell`) is not allowed in constant\n+const MUH: Meh = Meh { //~ ERROR: it is undefined behavior to use this value\n     x: &UnsafeCell::new(42),\n };\n \n@@ -24,11 +24,11 @@ unsafe impl Sync for Synced {}\n \n // Make sure we also catch this behind a type-erased `dyn Trait` reference.\n const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n-//~^ ERROR: mutable memory (`UnsafeCell`) is not allowed in constant\n+//~^ ERROR: it is undefined behavior to use this value\n \n // Make sure we also catch mutable references.\n const BLUNT: &mut i32 = &mut 42;\n-//~^ ERROR: mutable memory (`&mut`) is not allowed in constant\n+//~^ ERROR: it is undefined behavior to use this value\n \n fn main() {\n     unsafe {"}, {"sha": "0c206dd51aaabe2ea2f38fc7134285347fdd4279", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.stderr", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/54ea0f9ccdc16f3d357c296b300606e58c54868d/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/54ea0f9ccdc16f3d357c296b300606e58c54868d/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr?ref=54ea0f9ccdc16f3d357c296b300606e58c54868d", "patch": "@@ -1,22 +1,28 @@\n-error: mutable memory (`UnsafeCell`) is not allowed in constant\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/mutable_references_err.rs:16:1\n    |\n LL | / const MUH: Meh = Meh {\n LL | |     x: &UnsafeCell::new(42),\n LL | | };\n-   | |__^\n+   | |__^ type validation failed: encountered `UnsafeCell` in a `const` at .x.<deref>\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n-error: mutable memory (`UnsafeCell`) is not allowed in constant\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/mutable_references_err.rs:26:1\n    |\n LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered `UnsafeCell` in a `const` at .<deref>.<dyn-downcast>.x\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n-error: mutable memory (`&mut`) is not allowed in constant\n+error[E0080]: it is undefined behavior to use this value\n   --> $DIR/mutable_references_err.rs:30:1\n    |\n LL | const BLUNT: &mut i32 = &mut 42;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered mutable reference in a `const`\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n warning: skipping const checks\n    |\n@@ -38,3 +44,4 @@ LL | const BLUNT: &mut i32 = &mut 42;\n \n error: aborting due to 3 previous errors; 1 warning emitted\n \n+For more information about this error, try `rustc --explain E0080`."}]}