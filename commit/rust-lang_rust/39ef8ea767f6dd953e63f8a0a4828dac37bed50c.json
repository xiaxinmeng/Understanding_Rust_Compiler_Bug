{"sha": "39ef8ea767f6dd953e63f8a0a4828dac37bed50c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZWY4ZWE3NjdmNmRkOTUzZTYzZjhhMGE0ODI4ZGFjMzdiZWQ1MGM=", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-07-22T23:46:19Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-08-19T23:22:54Z"}, "message": "Refactor Markdown length-limited summary implementation\n\nThis commit refactors the implementation of\n`markdown_summary_with_limit()`, separating the logic of determining\nwhen the limit has been reached from the actual rendering process.\n\nThe main advantage of the new approach is that it guarantees that all\nHTML tags are closed, whereas the previous implementation could generate\ntags that were never closed. It also ensures that no empty tags are\ngenerated (e.g., `<em></em>`).\n\nThe new implementation consists of a general-purpose struct\n`HtmlWithLimit` that manages the length-limiting logic and a function\n`markdown_summary_with_limit()` that renders Markdown to HTML using the\nstruct.", "tree": {"sha": "6177de1c0c11c94cf949f638c4d087b377594b83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6177de1c0c11c94cf949f638c4d087b377594b83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39ef8ea767f6dd953e63f8a0a4828dac37bed50c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39ef8ea767f6dd953e63f8a0a4828dac37bed50c", "html_url": "https://github.com/rust-lang/rust/commit/39ef8ea767f6dd953e63f8a0a4828dac37bed50c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39ef8ea767f6dd953e63f8a0a4828dac37bed50c/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7960030d6915a771f5ab72c3897a7ed50c3ed4bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7960030d6915a771f5ab72c3897a7ed50c3ed4bd", "html_url": "https://github.com/rust-lang/rust/commit/7960030d6915a771f5ab72c3897a7ed50c3ed4bd"}], "stats": {"total": 168, "additions": 125, "deletions": 43}, "files": [{"sha": "42b94b511181d1bfa91a775581e9808bcdc5eb72", "filename": "src/librustdoc/html/length_limit.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/39ef8ea767f6dd953e63f8a0a4828dac37bed50c/src%2Flibrustdoc%2Fhtml%2Flength_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ef8ea767f6dd953e63f8a0a4828dac37bed50c/src%2Flibrustdoc%2Fhtml%2Flength_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flength_limit.rs?ref=39ef8ea767f6dd953e63f8a0a4828dac37bed50c", "patch": "@@ -0,0 +1,94 @@\n+//! See [`HtmlWithLimit`].\n+\n+use std::fmt::Write;\n+use std::ops::ControlFlow;\n+\n+use crate::html::escape::Escape;\n+\n+/// A buffer that allows generating HTML with a length limit.\n+///\n+/// This buffer ensures that:\n+///\n+/// * all tags are closed,\n+/// * only the most recently opened tag is closed,\n+/// * no tags are left empty (e.g., `<em></em>`) due to the length limit being reached,\n+/// * all text is escaped.\n+#[derive(Debug)]\n+pub(super) struct HtmlWithLimit {\n+    buf: String,\n+    len: usize,\n+    limit: usize,\n+    /// A list of tags that have been requested to be opened via [`Self::open_tag()`]\n+    /// but have not actually been pushed to `buf` yet. This ensures that tags are not\n+    /// left empty (e.g., `<em></em>`) due to the length limit being reached.\n+    queued_tags: Vec<&'static str>,\n+    /// A list of all tags that have been opened but not yet closed.\n+    unclosed_tags: Vec<&'static str>,\n+}\n+\n+impl HtmlWithLimit {\n+    /// Create a new buffer, with a limit of `length_limit`.\n+    pub(super) fn new(length_limit: usize) -> Self {\n+        Self {\n+            buf: String::new(),\n+            len: 0,\n+            limit: length_limit,\n+            unclosed_tags: Vec::new(),\n+            queued_tags: Vec::new(),\n+        }\n+    }\n+\n+    /// Finish using the buffer and get the written output.\n+    /// This function will close all unclosed tags for you.\n+    pub(super) fn finish(mut self) -> String {\n+        self.close_all_tags();\n+        self.buf\n+    }\n+\n+    /// Write some plain text to the buffer, escaping as needed.\n+    ///\n+    /// This function skips writing the text if the length limit was reached\n+    /// and returns [`ControlFlow::Break`].\n+    pub(super) fn push(&mut self, text: &str) -> ControlFlow<(), ()> {\n+        if self.len + text.len() > self.limit {\n+            return ControlFlow::BREAK;\n+        }\n+\n+        self.flush_queue();\n+        write!(self.buf, \"{}\", Escape(text)).unwrap();\n+        self.len += text.len();\n+\n+        ControlFlow::CONTINUE\n+    }\n+\n+    /// Open an HTML tag.\n+    pub(super) fn open_tag(&mut self, tag_name: &'static str) {\n+        self.queued_tags.push(tag_name);\n+    }\n+\n+    /// Close the most recently opened HTML tag.\n+    pub(super) fn close_tag(&mut self) {\n+        let tag_name = self.unclosed_tags.pop().unwrap();\n+        self.buf.push_str(\"</\");\n+        self.buf.push_str(tag_name);\n+        self.buf.push('>');\n+    }\n+\n+    /// Write all queued tags and add them to the `unclosed_tags` list.\n+    fn flush_queue(&mut self) {\n+        for tag_name in self.queued_tags.drain(..) {\n+            self.buf.push('<');\n+            self.buf.push_str(tag_name);\n+            self.buf.push('>');\n+\n+            self.unclosed_tags.push(tag_name);\n+        }\n+    }\n+\n+    /// Close all unclosed tags.\n+    fn close_all_tags(&mut self) {\n+        while !self.unclosed_tags.is_empty() {\n+            self.close_tag();\n+        }\n+    }\n+}"}, {"sha": "5a569c690e548a00ad8d67887277e7b9c7408ade", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 29, "deletions": 43, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/39ef8ea767f6dd953e63f8a0a4828dac37bed50c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ef8ea767f6dd953e63f8a0a4828dac37bed50c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=39ef8ea767f6dd953e63f8a0a4828dac37bed50c", "patch": "@@ -23,19 +23,21 @@ use rustc_hir::HirId;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::edition::Edition;\n use rustc_span::Span;\n+\n use std::borrow::Cow;\n use std::cell::RefCell;\n use std::collections::VecDeque;\n use std::default::Default;\n use std::fmt::Write;\n-use std::ops::Range;\n+use std::ops::{ControlFlow, Range};\n use std::str;\n \n use crate::clean::RenderedLink;\n use crate::doctest;\n use crate::html::escape::Escape;\n use crate::html::format::Buffer;\n use crate::html::highlight;\n+use crate::html::length_limit::HtmlWithLimit;\n use crate::html::toc::TocBuilder;\n \n use pulldown_cmark::{\n@@ -1081,15 +1083,6 @@ fn markdown_summary_with_limit(\n         return (String::new(), false);\n     }\n \n-    let mut s = String::with_capacity(md.len() * 3 / 2);\n-    let mut text_length = 0;\n-    let mut stopped_early = false;\n-\n-    fn push(s: &mut String, text_length: &mut usize, text: &str) {\n-        write!(s, \"{}\", Escape(text)).unwrap();\n-        *text_length += text.len();\n-    }\n-\n     let mut replacer = |broken_link: BrokenLink<'_>| {\n         if let Some(link) =\n             link_names.iter().find(|link| &*link.original_text == broken_link.reference)\n@@ -1101,56 +1094,49 @@ fn markdown_summary_with_limit(\n     };\n \n     let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut replacer));\n-    let p = LinkReplacer::new(p, link_names);\n+    let mut p = LinkReplacer::new(p, link_names);\n \n-    'outer: for event in p {\n+    // FIXME: capacity\n+    let mut buf = HtmlWithLimit::new(length_limit);\n+    let mut stopped_early = false;\n+    p.try_for_each(|event| {\n         match &event {\n             Event::Text(text) => {\n-                for word in text.split_inclusive(char::is_whitespace) {\n-                    if text_length + word.len() >= length_limit {\n-                        stopped_early = true;\n-                        break 'outer;\n-                    }\n-\n-                    push(&mut s, &mut text_length, word);\n+                let r =\n+                    text.split_inclusive(char::is_whitespace).try_for_each(|word| buf.push(word));\n+                if r.is_break() {\n+                    stopped_early = true;\n                 }\n+                return r;\n             }\n             Event::Code(code) => {\n-                if text_length + code.len() >= length_limit {\n+                buf.open_tag(\"code\");\n+                let r = buf.push(code);\n+                if r.is_break() {\n                     stopped_early = true;\n-                    break;\n+                } else {\n+                    buf.close_tag();\n                 }\n-\n-                s.push_str(\"<code>\");\n-                push(&mut s, &mut text_length, code);\n-                s.push_str(\"</code>\");\n+                return r;\n             }\n             Event::Start(tag) => match tag {\n-                Tag::Emphasis => s.push_str(\"<em>\"),\n-                Tag::Strong => s.push_str(\"<strong>\"),\n-                Tag::CodeBlock(..) => break,\n+                Tag::Emphasis => buf.open_tag(\"em\"),\n+                Tag::Strong => buf.open_tag(\"strong\"),\n+                Tag::CodeBlock(..) => return ControlFlow::BREAK,\n                 _ => {}\n             },\n             Event::End(tag) => match tag {\n-                Tag::Emphasis => s.push_str(\"</em>\"),\n-                Tag::Strong => s.push_str(\"</strong>\"),\n-                Tag::Paragraph => break,\n-                Tag::Heading(..) => break,\n+                Tag::Emphasis | Tag::Strong => buf.close_tag(),\n+                Tag::Paragraph | Tag::Heading(..) => return ControlFlow::BREAK,\n                 _ => {}\n             },\n-            Event::HardBreak | Event::SoftBreak => {\n-                if text_length + 1 >= length_limit {\n-                    stopped_early = true;\n-                    break;\n-                }\n-\n-                push(&mut s, &mut text_length, \" \");\n-            }\n+            Event::HardBreak | Event::SoftBreak => buf.push(\" \")?,\n             _ => {}\n-        }\n-    }\n+        };\n+        ControlFlow::CONTINUE\n+    });\n \n-    (s, stopped_early)\n+    (buf.finish(), stopped_early)\n }\n \n /// Renders a shortened first paragraph of the given Markdown as a subset of Markdown,"}, {"sha": "109b0a356db5ff26f352701edea20ba12f152462", "filename": "src/librustdoc/html/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39ef8ea767f6dd953e63f8a0a4828dac37bed50c/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ef8ea767f6dd953e63f8a0a4828dac37bed50c/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmod.rs?ref=39ef8ea767f6dd953e63f8a0a4828dac37bed50c", "patch": "@@ -2,6 +2,7 @@ crate mod escape;\n crate mod format;\n crate mod highlight;\n crate mod layout;\n+mod length_limit;\n // used by the error-index generator, so it needs to be public\n pub mod markdown;\n crate mod render;"}, {"sha": "ab94e0d568353aa4af3ed22a33f719a4f50110ae", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39ef8ea767f6dd953e63f8a0a4828dac37bed50c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ef8ea767f6dd953e63f8a0a4828dac37bed50c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=39ef8ea767f6dd953e63f8a0a4828dac37bed50c", "patch": "@@ -5,6 +5,7 @@\n #![feature(rustc_private)]\n #![feature(array_methods)]\n #![feature(box_patterns)]\n+#![feature(control_flow_enum)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(test)]"}]}