{"sha": "ab7ebb608a818f4437a2bec2ef42d9ee2048c86a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiN2ViYjYwOGE4MThmNDQzN2EyYmVjMmVmNDJkOWVlMjA0OGM4NmE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-17T00:47:05Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-17T00:48:32Z"}, "message": "rustc: Fix dominance issue when translating generic interior vectors", "tree": {"sha": "739cbb96ed653b8eb542a5edb12f3ab8130f75b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/739cbb96ed653b8eb542a5edb12f3ab8130f75b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab7ebb608a818f4437a2bec2ef42d9ee2048c86a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7ebb608a818f4437a2bec2ef42d9ee2048c86a", "html_url": "https://github.com/rust-lang/rust/commit/ab7ebb608a818f4437a2bec2ef42d9ee2048c86a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab7ebb608a818f4437a2bec2ef42d9ee2048c86a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a68a5c9b5ecd224acfc6c6cfa86745f3bca14309", "url": "https://api.github.com/repos/rust-lang/rust/commits/a68a5c9b5ecd224acfc6c6cfa86745f3bca14309", "html_url": "https://github.com/rust-lang/rust/commit/a68a5c9b5ecd224acfc6c6cfa86745f3bca14309"}], "stats": {"total": 85, "additions": 64, "deletions": 21}, "files": [{"sha": "12fa576438e952196f439d666d9b5bf999f9d448", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 64, "deletions": 21, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ab7ebb608a818f4437a2bec2ef42d9ee2048c86a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7ebb608a818f4437a2bec2ef42d9ee2048c86a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=ab7ebb608a818f4437a2bec2ef42d9ee2048c86a", "patch": "@@ -3538,25 +3538,66 @@ mod ivec {\n         post_copy_cx.build.Br(copy_loop_header_cx.llbb);\n         ret res(next_cx, C_nil());\n     }\n-    fn alloc(&@block_ctxt bcx, ty::t unit_ty, ValueRef llalen) -> ValueRef {\n+\n+    type alloc_result = rec(@block_ctxt bcx,\n+                            ValueRef llptr,\n+                            ValueRef llunitsz,\n+                            ValueRef llalen);\n+\n+    fn alloc(&@block_ctxt cx, ty::t unit_ty) -> alloc_result {\n+        auto dynamic = ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, unit_ty);\n+\n+        auto bcx;\n+        if (dynamic) {\n+            bcx = llallocas_block_ctxt(cx.fcx);\n+        } else {\n+            bcx = cx;\n+        }\n+\n+        auto llunitsz;\n+        auto rslt = size_of(bcx, unit_ty);\n+        bcx = rslt.bcx;\n+        llunitsz = rslt.val;\n+        if (dynamic) { bcx.fcx.llallocas = bcx.llbb; }\n+\n+        auto llalen = bcx.build.Mul(llunitsz,\n+                                    C_uint(abi::ivec_default_length));\n+\n+        auto llptr;\n         auto llunitty = type_of_or_i8(bcx, unit_ty);\n-        if (ty::type_has_dynamic_size(bcx.fcx.lcx.ccx.tcx, unit_ty)) {\n-            auto llarraysz =\n-                bcx.build.Add(llsize_of(T_opaque_ivec()), llalen);\n+        if (dynamic) {\n+            auto llarraysz = bcx.build.Add(llsize_of(T_opaque_ivec()),\n+                                           llalen);\n             auto llvecptr = array_alloca(bcx, T_i8(), llarraysz);\n-            ret bcx.build.PointerCast(llvecptr, T_ptr(T_opaque_ivec()));\n+            llptr = bcx.build.PointerCast(llvecptr, T_ptr(T_opaque_ivec()));\n+        } else {\n+            llptr = alloca(bcx, T_ivec(llunitty));\n         }\n-        ret alloca(bcx, T_ivec(llunitty));\n+\n+        auto bcx_result;\n+        if (dynamic) {\n+            bcx_result = cx;\n+        } else {\n+            bcx_result = bcx;\n+        }\n+\n+        ret rec(bcx=bcx_result,\n+                llptr=llptr,\n+                llunitsz=llunitsz,\n+                llalen=llalen);\n     }\n-    fn trans_add(&@block_ctxt cx, ty::t vec_ty, ValueRef lhs, ValueRef rhs) ->\n-       result {\n+\n+    fn trans_add(&@block_ctxt cx, ty::t vec_ty, ValueRef lhs, ValueRef rhs)\n+            -> result {\n         auto bcx = cx;\n         auto unit_ty = ty::sequence_element_type(bcx.fcx.lcx.ccx.tcx, vec_ty);\n-        auto rslt = size_of(bcx, unit_ty);\n-        auto unit_sz = rslt.val;\n-        auto llalen =\n-            bcx.build.Mul(unit_sz, C_uint(abi::ivec_default_length));\n-        auto llvecptr = alloc(bcx, unit_ty, llalen);\n+\n+        auto ares = alloc(bcx, unit_ty);\n+        bcx = ares.bcx;\n+        auto llvecptr = ares.llptr;\n+        auto unit_sz = ares.llunitsz;\n+        auto llalen = ares.llalen;\n+\n         auto llunitty = type_of_or_i8(bcx, unit_ty);\n         auto llheappartty = T_ivec_heap_part(llunitty);\n         auto lhs_len_and_data = get_len_and_data(bcx, lhs, unit_ty);\n@@ -3631,7 +3672,7 @@ mod ivec {\n                             heap_cx.build.InBoundsGEP(stub_ptr_heap,\n                                                       stub_a));\n         auto heap_sz = heap_cx.build.Add(llsize_of(llheappartty), lllen);\n-        rslt = trans_raw_malloc(heap_cx, T_ptr(llheappartty), heap_sz);\n+        auto rslt = trans_raw_malloc(heap_cx, T_ptr(llheappartty), heap_sz);\n         auto heap_part = rslt.val;\n         heap_cx = rslt.bcx;\n         heap_cx.build.Store(heap_part,\n@@ -5405,12 +5446,14 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann) ->\n         case (ty::ty_ivec(?mt)) { unit_ty = mt.ty; }\n         case (_) { bcx.fcx.lcx.ccx.sess.bug(\"non-ivec type in trans_ivec\"); }\n     }\n-    auto rslt = size_of(bcx, unit_ty);\n-    auto unit_sz = rslt.val;\n-    bcx = rslt.bcx;\n-    auto llalen = bcx.build.Mul(unit_sz, C_uint(abi::ivec_default_length));\n     auto llunitty = type_of_or_i8(bcx, unit_ty);\n-    auto llvecptr = ivec::alloc(bcx, unit_ty, llalen);\n+\n+    auto ares = ivec::alloc(bcx, unit_ty);\n+    bcx = ares.bcx;\n+    auto llvecptr = ares.llptr;\n+    auto unit_sz = ares.llunitsz;\n+    auto llalen = ares.llalen;\n+\n     auto lllen = bcx.build.Mul(C_uint(vec::len(args)), unit_sz);\n     // Allocate the vector pieces and store length and allocated length.\n \n@@ -5449,7 +5492,7 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann) ->\n             llfirsteltptr = C_null(T_ptr(llunitty));\n         } else {\n             auto llheapsz = bcx.build.Add(llsize_of(llheapty), lllen);\n-            rslt = trans_raw_malloc(bcx, T_ptr(llheapty), llheapsz);\n+            auto rslt = trans_raw_malloc(bcx, T_ptr(llheapty), llheapsz);\n             bcx = rslt.bcx;\n             auto llheapptr = rslt.val;\n             bcx.build.Store(llheapptr,\n@@ -5467,7 +5510,7 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann) ->\n \n     auto i = 0u;\n     for (@ast::expr e in args) {\n-        rslt = trans_expr(bcx, e);\n+        auto rslt = trans_expr(bcx, e);\n         bcx = rslt.bcx;\n         auto llsrc = rslt.val;\n         auto lleltptr;"}]}