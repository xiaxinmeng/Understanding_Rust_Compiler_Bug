{"sha": "0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmY2E2YzZhMDJkMDM0OTFlZTQ2ZWE1YzRiNjU2ZDExNGE3M2E1M2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-25T20:56:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-25T20:56:21Z"}, "message": "auto merge of #14391 : alexcrichton/rust/more-rustdoc-inline, r=huonw\n\nAs part of the libstd facade (cc #13851), rustdoc is taught to inline documentation across crate boundaries through the usage of a `pub use` statement. This is done to allow libstd to maintain the facade that it is a standalone library with a defined public interface (allowing us to shuffle around what's underneath it).\r\n\r\nA preview is available at http://people.mozilla.org/~acrichton/doc/std/index.html", "tree": {"sha": "0b483c1f24d5fdfdfc5ff3c6c95bc4cde4edb8ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b483c1f24d5fdfdfc5ff3c6c95bc4cde4edb8ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "html_url": "https://github.com/rust-lang/rust/commit/0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cf1527b91db3c605e44fe9b90fc46ecf1d04c4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf1527b91db3c605e44fe9b90fc46ecf1d04c4f", "html_url": "https://github.com/rust-lang/rust/commit/1cf1527b91db3c605e44fe9b90fc46ecf1d04c4f"}, {"sha": "3100bc5b82257820051774eb4aa0447b12f3616a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3100bc5b82257820051774eb4aa0447b12f3616a", "html_url": "https://github.com/rust-lang/rust/commit/3100bc5b82257820051774eb4aa0447b12f3616a"}], "stats": {"total": 911, "additions": 734, "deletions": 177}, "files": [{"sha": "1034c776ea6dd59137c305e66e84bc79f9e064fa", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "patch": "@@ -41,6 +41,31 @@ pub fn recalibrate() {\n # }\n ~~~\n \n+Documentation can also be controlled via the `doc` attribute on items. This is\n+implicitly done by the compiler when using the above form of doc comments\n+(converting the slash-based comments to `#[doc]` attributes).\n+\n+~~~\n+#[doc = \"\n+Calculates the factorial of a number.\n+\n+Given the input integer `n`, this function will calculate `n!` and return it.\n+\"]\n+pub fn factorial(n: int) -> int { if n < 2 {1} else {n * factorial(n)} }\n+# fn main() {}\n+~~~\n+\n+The `doc` attribute can also be used to control how rustdoc emits documentation\n+in some cases.\n+\n+```\n+// Rustdoc will inline documentation of a `pub use` into this crate when the\n+// `pub use` reaches across crates, but this behavior can also be disabled.\n+#[doc(no_inline)]\n+pub use std::option::Option;\n+# fn main() {}\n+```\n+\n Doc comments are markdown, and are currently parsed with the\n [sundown][sundown] library. rustdoc does not yet do any fanciness such as\n referencing other items inline, like javadoc's `@see`. One exception to this"}, {"sha": "c798118bbd0fa7d66275b7d33cb16f21ffb782a0", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "patch": "@@ -206,6 +206,9 @@ pub static tag_crate_triple: uint = 0x66;\n \n pub static tag_dylib_dependency_formats: uint = 0x67;\n \n+pub static tag_method_argument_names: uint = 0x8e;\n+pub static tag_method_argument_name: uint = 0x8f;\n+\n #[deriving(Clone, Show)]\n pub struct LinkMeta {\n     pub crateid: CrateId,"}, {"sha": "d407cc046807b650973bf726bea468ee8f50b720", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "patch": "@@ -306,3 +306,10 @@ pub fn get_missing_lang_items(cstore: &cstore::CStore, cnum: ast::CrateNum)\n     let cdata = cstore.get_crate_data(cnum);\n     decoder::get_missing_lang_items(&*cdata)\n }\n+\n+pub fn get_method_arg_names(cstore: &cstore::CStore, did: ast::DefId)\n+    -> Vec<String>\n+{\n+    let cdata = cstore.get_crate_data(did.krate);\n+    decoder::get_method_arg_names(&*cdata, did.node)\n+}"}, {"sha": "e8be05feae80630af665fd359c974c59d7543165", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "patch": "@@ -1309,3 +1309,18 @@ pub fn get_missing_lang_items(cdata: Cmd)\n     });\n     return result;\n }\n+\n+pub fn get_method_arg_names(cdata: Cmd, id: ast::NodeId) -> Vec<String> {\n+    let mut ret = Vec::new();\n+    let method_doc = lookup_item(id, cdata.data());\n+    match reader::maybe_get_doc(method_doc, tag_method_argument_names) {\n+        Some(args_doc) => {\n+            reader::tagged_docs(args_doc, tag_method_argument_name, |name_doc| {\n+                ret.push(name_doc.as_str_slice().to_strbuf());\n+                true\n+            });\n+        }\n+        None => {}\n+    }\n+    return ret;\n+}"}, {"sha": "443a8acfb0cc64d0dbfbe12093c9b96a166db873", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "patch": "@@ -536,6 +536,7 @@ fn encode_reexports(ecx: &EncodeContext,\n fn encode_info_for_mod(ecx: &EncodeContext,\n                        ebml_w: &mut Encoder,\n                        md: &Mod,\n+                       attrs: &[Attribute],\n                        id: NodeId,\n                        path: PathElems,\n                        name: Ident,\n@@ -584,6 +585,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         debug!(\"(encoding info for module) encoding reexports for {}\", id);\n         encode_reexports(ecx, ebml_w, id, path);\n     }\n+    encode_attributes(ebml_w, attrs);\n \n     ebml_w.end_tag();\n }\n@@ -774,11 +776,30 @@ fn encode_info_for_method(ecx: &EncodeContext,\n         } else {\n             encode_symbol(ecx, ebml_w, m.def_id.node);\n         }\n+        encode_method_argument_names(ebml_w, &*ast_method.decl);\n     }\n \n     ebml_w.end_tag();\n }\n \n+fn encode_method_argument_names(ebml_w: &mut Encoder,\n+                                decl: &ast::FnDecl) {\n+    ebml_w.start_tag(tag_method_argument_names);\n+    for arg in decl.inputs.iter() {\n+        ebml_w.start_tag(tag_method_argument_name);\n+        match arg.pat.node {\n+            ast::PatIdent(_, ref name, _) => {\n+                let name = name.segments.last().unwrap().identifier;\n+                let name = token::get_ident(name);\n+                ebml_w.writer.write(name.get().as_bytes());\n+            }\n+            _ => {}\n+        }\n+        ebml_w.end_tag();\n+    }\n+    ebml_w.end_tag();\n+}\n+\n fn encode_inlined_item(ecx: &EncodeContext,\n                        ebml_w: &mut Encoder,\n                        ii: InlinedItemRef) {\n@@ -895,7 +916,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n-      ItemFn(_, fn_style, _, ref generics, _) => {\n+      ItemFn(ref decl, fn_style, _, ref generics, _) => {\n         add_to_index(item, ebml_w, index);\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n@@ -911,13 +932,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             encode_symbol(ecx, ebml_w, item.id);\n         }\n         encode_visibility(ebml_w, vis);\n+        encode_method_argument_names(ebml_w, &**decl);\n         ebml_w.end_tag();\n       }\n       ItemMod(ref m) => {\n         add_to_index(item, ebml_w, index);\n         encode_info_for_mod(ecx,\n                             ebml_w,\n                             m,\n+                            item.attrs.as_slice(),\n                             item.id,\n                             path,\n                             item.ident,\n@@ -1317,6 +1340,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     encode_info_for_mod(ecx,\n                         ebml_w,\n                         &krate.module,\n+                        &[],\n                         CRATE_NODE_ID,\n                         ast_map::Values([].iter()).chain(None),\n                         syntax::parse::token::special_idents::invalid,"}, {"sha": "dd5fddca0db8a02da915808534507fab1766c2cf", "filename": "src/librustdoc/clean/inline.rs", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "patch": "@@ -0,0 +1,278 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Support for inlining external documentation into the current AST.\n+\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::attr::AttrMetaMethods;\n+\n+use rustc::metadata::csearch;\n+use rustc::metadata::decoder;\n+use rustc::middle::ty;\n+\n+use core;\n+use doctree;\n+use clean;\n+\n+use super::Clean;\n+\n+/// Attempt to inline the definition of a local node id into this AST.\n+///\n+/// This function will fetch the definition of the id specified, and if it is\n+/// from another crate it will attempt to inline the documentation from the\n+/// other crate into this crate.\n+///\n+/// This is primarily used for `pub use` statements which are, in general,\n+/// implementation details. Inlining the documentation should help provide a\n+/// better experience when reading the documentation in this use case.\n+///\n+/// The returned value is `None` if the `id` could not be inlined, and `Some`\n+/// of a vector of items if it was successfully expanded.\n+pub fn try_inline(id: ast::NodeId) -> Option<Vec<clean::Item>> {\n+    let cx = ::ctxtkey.get().unwrap();\n+    let tcx = match cx.maybe_typed {\n+        core::Typed(ref tycx) => tycx,\n+        core::NotTyped(_) => return None,\n+    };\n+    let def = match tcx.def_map.borrow().find(&id) {\n+        Some(def) => *def,\n+        None => return None,\n+    };\n+    let did = ast_util::def_id_of_def(def);\n+    if ast_util::is_local(did) { return None }\n+    try_inline_def(&**cx, tcx, def)\n+}\n+\n+fn try_inline_def(cx: &core::DocContext,\n+                  tcx: &ty::ctxt,\n+                  def: ast::Def) -> Option<Vec<clean::Item>> {\n+    let mut ret = Vec::new();\n+    let did = ast_util::def_id_of_def(def);\n+    let inner = match def {\n+        ast::DefTrait(did) => {\n+            record_extern_fqn(cx, did, clean::TypeTrait);\n+            clean::TraitItem(build_external_trait(tcx, did))\n+        }\n+        ast::DefFn(did, style) => {\n+            record_extern_fqn(cx, did, clean::TypeFunction);\n+            clean::FunctionItem(build_external_function(tcx, did, style))\n+        }\n+        ast::DefStruct(did) => {\n+            record_extern_fqn(cx, did, clean::TypeStruct);\n+            ret.extend(build_impls(tcx, did).move_iter());\n+            clean::StructItem(build_struct(tcx, did))\n+        }\n+        ast::DefTy(did) => {\n+            record_extern_fqn(cx, did, clean::TypeEnum);\n+            ret.extend(build_impls(tcx, did).move_iter());\n+            build_type(tcx, did)\n+        }\n+        // Assume that the enum type is reexported next to the variant, and\n+        // variants don't show up in documentation specially.\n+        ast::DefVariant(..) => return Some(Vec::new()),\n+        ast::DefMod(did) => {\n+            record_extern_fqn(cx, did, clean::TypeModule);\n+            clean::ModuleItem(build_module(cx, tcx, did))\n+        }\n+        _ => return None,\n+    };\n+    let fqn = csearch::get_item_path(tcx, did);\n+    ret.push(clean::Item {\n+        source: clean::Span::empty(),\n+        name: Some(fqn.last().unwrap().to_str().to_strbuf()),\n+        attrs: load_attrs(tcx, did),\n+        inner: inner,\n+        visibility: Some(ast::Public),\n+        def_id: did,\n+    });\n+    Some(ret)\n+}\n+\n+pub fn load_attrs(tcx: &ty::ctxt, did: ast::DefId) -> Vec<clean::Attribute> {\n+    let mut attrs = Vec::new();\n+    csearch::get_item_attrs(&tcx.sess.cstore, did, |v| {\n+        attrs.extend(v.move_iter().map(|mut a| {\n+            // FIXME this isn't quite always true, it's just true about 99% of\n+            //       the time when dealing with documentation. For example,\n+            //       this would treat doc comments of the form `#[doc = \"foo\"]`\n+            //       incorrectly.\n+            if a.name().get() == \"doc\" && a.value_str().is_some() {\n+                a.node.is_sugared_doc = true;\n+            }\n+            a.clean()\n+        }));\n+    });\n+    attrs\n+}\n+\n+/// Record an external fully qualified name in the external_paths cache.\n+///\n+/// These names are used later on by HTML rendering to generate things like\n+/// source links back to the original item.\n+pub fn record_extern_fqn(cx: &core::DocContext,\n+                         did: ast::DefId,\n+                         kind: clean::TypeKind) {\n+    match cx.maybe_typed {\n+        core::Typed(ref tcx) => {\n+            let fqn = csearch::get_item_path(tcx, did);\n+            let fqn = fqn.move_iter().map(|i| i.to_str().to_strbuf()).collect();\n+            cx.external_paths.borrow_mut().get_mut_ref().insert(did, (fqn, kind));\n+        }\n+        core::NotTyped(..) => {}\n+    }\n+}\n+\n+pub fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> clean::Trait {\n+    let def = ty::lookup_trait_def(tcx, did);\n+    let methods = ty::trait_methods(tcx, did);\n+    clean::Trait {\n+        generics: def.generics.clean(),\n+        methods: methods.iter().map(|i| i.clean()).collect(),\n+        parents: Vec::new(), // FIXME: this is likely wrong\n+    }\n+}\n+\n+fn build_external_function(tcx: &ty::ctxt,\n+                           did: ast::DefId,\n+                           style: ast::FnStyle) -> clean::Function {\n+    let t = ty::lookup_item_type(tcx, did);\n+    clean::Function {\n+        decl: match ty::get(t.ty).sty {\n+            ty::ty_bare_fn(ref f) => (did, &f.sig).clean(),\n+            _ => fail!(\"bad function\"),\n+        },\n+        generics: t.generics.clean(),\n+        fn_style: style,\n+    }\n+}\n+\n+fn build_struct(tcx: &ty::ctxt, did: ast::DefId) -> clean::Struct {\n+    use syntax::parse::token::special_idents::unnamed_field;\n+\n+    let t = ty::lookup_item_type(tcx, did);\n+    let fields = ty::lookup_struct_fields(tcx, did);\n+\n+    clean::Struct {\n+        struct_type: match fields.as_slice() {\n+            [] => doctree::Unit,\n+            [ref f] if f.name == unnamed_field.name => doctree::Newtype,\n+            [ref f, ..] if f.name == unnamed_field.name => doctree::Tuple,\n+            _ => doctree::Plain,\n+        },\n+        generics: t.generics.clean(),\n+        fields: fields.iter().map(|f| f.clean()).collect(),\n+        fields_stripped: false,\n+    }\n+}\n+\n+fn build_type(tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n+    let t = ty::lookup_item_type(tcx, did);\n+    match ty::get(t.ty).sty {\n+        ty::ty_enum(edid, _) => {\n+            return clean::EnumItem(clean::Enum {\n+                generics: t.generics.clean(),\n+                variants_stripped: false,\n+                variants: ty::enum_variants(tcx, edid).clean(),\n+            })\n+        }\n+        _ => {}\n+    }\n+\n+    clean::TypedefItem(clean::Typedef {\n+        type_: t.ty.clean(),\n+        generics: t.generics.clean(),\n+    })\n+}\n+\n+fn build_impls(tcx: &ty::ctxt,\n+               did: ast::DefId) -> Vec<clean::Item> {\n+    ty::populate_implementations_for_type_if_necessary(tcx, did);\n+    let mut impls = Vec::new();\n+\n+    match tcx.inherent_impls.borrow().find(&did) {\n+        None => {}\n+        Some(i) => {\n+            impls.extend(i.borrow().iter().map(|&did| { build_impl(tcx, did) }));\n+        }\n+    }\n+\n+    impls\n+}\n+\n+fn build_impl(tcx: &ty::ctxt, did: ast::DefId) -> clean::Item {\n+    let associated_trait = csearch::get_impl_trait(tcx, did);\n+    let attrs = load_attrs(tcx, did);\n+    let ty = ty::lookup_item_type(tcx, did);\n+    let methods = csearch::get_impl_methods(&tcx.sess.cstore, did).iter().map(|did| {\n+        let mut item = match ty::method(tcx, *did).clean() {\n+            clean::Provided(item) => item,\n+            clean::Required(item) => item,\n+        };\n+        item.inner = match item.inner.clone() {\n+            clean::TyMethodItem(clean::TyMethod {\n+                fn_style, decl, self_, generics\n+            }) => {\n+                clean::MethodItem(clean::Method {\n+                    fn_style: fn_style,\n+                    decl: decl,\n+                    self_: self_,\n+                    generics: generics,\n+                })\n+            }\n+            _ => fail!(\"not a tymethod\"),\n+        };\n+        item\n+    }).collect();\n+    clean::Item {\n+        inner: clean::ImplItem(clean::Impl {\n+            derived: clean::detect_derived(attrs.as_slice()),\n+            trait_: associated_trait.clean().map(|bound| {\n+                match bound {\n+                    clean::TraitBound(ty) => ty,\n+                    clean::RegionBound => unreachable!(),\n+                }\n+            }),\n+            for_: ty.ty.clean(),\n+            generics: ty.generics.clean(),\n+            methods: methods,\n+        }),\n+        source: clean::Span::empty(),\n+        name: None,\n+        attrs: attrs,\n+        visibility: Some(ast::Inherited),\n+        def_id: did,\n+    }\n+}\n+\n+fn build_module(cx: &core::DocContext, tcx: &ty::ctxt,\n+                did: ast::DefId) -> clean::Module {\n+    let mut items = Vec::new();\n+\n+    // FIXME: this doesn't handle reexports inside the module itself.\n+    //        Should they be handled?\n+    csearch::each_child_of_item(&tcx.sess.cstore, did, |def, _, _| {\n+        match def {\n+            decoder::DlDef(def) => {\n+                match try_inline_def(cx, tcx, def) {\n+                    Some(i) => items.extend(i.move_iter()),\n+                    None => {}\n+                }\n+            }\n+            decoder::DlImpl(did) => items.push(build_impl(tcx, did)),\n+            decoder::DlField => fail!(\"unimplemented field\"),\n+        }\n+    });\n+\n+    clean::Module {\n+        items: items,\n+        is_crate: false,\n+    }\n+}"}, {"sha": "f0f6842642534ed3e098c2590d43f32ff903c896", "filename": "src/librustdoc/clean/mod.rs", "status": "renamed", "additions": 201, "deletions": 63, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "patch": "@@ -15,7 +15,7 @@ use syntax;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::attr;\n-use syntax::attr::AttributeMethods;\n+use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use syntax::codemap::Pos;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n@@ -27,7 +27,7 @@ use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n use rustc::middle::ty;\n \n-use std::string::String;\n+use std::rc::Rc;\n \n use core;\n use doctree;\n@@ -37,6 +37,8 @@ use visit_ast;\n /// Increment this when the `Crate` and related structures change.\n pub static SCHEMA_VERSION: &'static str = \"0.8.2\";\n \n+mod inline;\n+\n pub trait Clean<T> {\n     fn clean(&self) -> T;\n }\n@@ -53,6 +55,12 @@ impl<T: Clean<U>, U> Clean<U> for @T {\n     }\n }\n \n+impl<T: Clean<U>, U> Clean<U> for Rc<T> {\n+    fn clean(&self) -> U {\n+        (**self).clean()\n+    }\n+}\n+\n impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n     fn clean(&self) -> Option<U> {\n         match self {\n@@ -250,7 +258,8 @@ impl Clean<Item> for doctree::Module {\n             self.statics.clean().move_iter().collect(),\n             self.traits.clean().move_iter().collect(),\n             self.impls.clean().move_iter().collect(),\n-            self.view_items.clean().move_iter().collect(),\n+            self.view_items.clean().move_iter()\n+                           .flat_map(|s| s.move_iter()).collect(),\n             self.macros.clean().move_iter().collect()\n         );\n \n@@ -336,6 +345,14 @@ impl attr::AttrMetaMethods for Attribute {\n         None\n     }\n }\n+impl<'a> attr::AttrMetaMethods for &'a Attribute {\n+    fn name(&self) -> InternedString { (**self).name() }\n+    fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [@ast::MetaItem]> { None }\n+    fn name_str_pair(&self) -> Option<(InternedString, InternedString)> {\n+        None\n+    }\n+}\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct TyParam {\n@@ -473,7 +490,7 @@ impl Clean<Option<Vec<TyParamBound>>> for ty::substs {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, Eq)]\n pub struct Lifetime(String);\n \n impl Lifetime {\n@@ -614,7 +631,7 @@ impl Clean<Item> for ast::TypeMethod {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable)]\n+#[deriving(Clone, Encodable, Decodable, Eq)]\n pub enum SelfTy {\n     SelfStatic,\n     SelfValue,\n@@ -707,18 +724,32 @@ impl Clean<FnDecl> for ast::FnDecl {\n     }\n }\n \n-impl Clean<FnDecl> for ty::FnSig {\n+impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n     fn clean(&self) -> FnDecl {\n+        let cx = super::ctxtkey.get().unwrap();\n+        let tcx = match cx.maybe_typed {\n+            core::Typed(ref tcx) => tcx,\n+            core::NotTyped(_) => unreachable!(),\n+        };\n+        let (did, sig) = *self;\n+        let mut names = if did.node != 0 {\n+            csearch::get_method_arg_names(&tcx.sess.cstore, did).move_iter()\n+        } else {\n+            Vec::new().move_iter()\n+        }.peekable();\n+        if names.peek().map(|s| s.as_slice()) == Some(\"self\") {\n+            let _ = names.next();\n+        }\n         FnDecl {\n-            output: self.output.clean(),\n+            output: sig.output.clean(),\n             cf: Return,\n-            attrs: Vec::new(), // FIXME: this is likely wrong\n+            attrs: Vec::new(),\n             inputs: Arguments {\n-                values: self.inputs.iter().map(|t| {\n+                values: sig.inputs.iter().map(|t| {\n                     Argument {\n                         type_: t.clean(),\n                         id: 0,\n-                        name: \"\".to_strbuf(), // FIXME: where are the names?\n+                        name: names.next().unwrap_or(\"\".to_strbuf()),\n                     }\n                 }).collect(),\n             },\n@@ -830,12 +861,8 @@ impl Clean<TraitMethod> for ty::Method {\n         let cx = super::ctxtkey.get().unwrap();\n         let tcx = match cx.maybe_typed {\n             core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => fail!(),\n+            core::NotTyped(_) => unreachable!(),\n         };\n-        let mut attrs = Vec::new();\n-        csearch::get_item_attrs(&tcx.sess.cstore, self.def_id, |v| {\n-            attrs.extend(v.move_iter().map(|i| i.clean()));\n-        });\n         let (self_, sig) = match self.explicit_self {\n             ast::SelfStatic => (ast::SelfStatic.clean(), self.fty.sig.clone()),\n             s => {\n@@ -857,20 +884,18 @@ impl Clean<TraitMethod> for ty::Method {\n                 (s, sig)\n             }\n         };\n+\n         m(Item {\n             name: Some(self.ident.clean()),\n             visibility: Some(ast::Inherited),\n             def_id: self.def_id,\n-            attrs: attrs,\n-            source: Span {\n-                filename: \"\".to_strbuf(),\n-                loline: 0, locol: 0, hiline: 0, hicol: 0,\n-            },\n+            attrs: inline::load_attrs(tcx, self.def_id),\n+            source: Span::empty(),\n             inner: TyMethodItem(TyMethod {\n                 fn_style: self.fty.fn_style,\n                 generics: self.generics.clean(),\n                 self_: self_,\n-                decl: sig.clean(),\n+                decl: (self.def_id, &sig).clean(),\n             })\n         })\n     }\n@@ -987,13 +1012,13 @@ impl Clean<Type> for ty::t {\n                 generics: Generics {\n                     lifetimes: Vec::new(), type_params: Vec::new()\n                 },\n-                decl: fty.sig.clean(),\n+                decl: (ast_util::local_def(0), &fty.sig).clean(),\n                 abi: fty.abi.to_str().to_strbuf(),\n             }),\n             ty::ty_closure(ref fty) => {\n                 let decl = box ClosureDecl {\n                     lifetimes: Vec::new(), // FIXME: this looks wrong...\n-                    decl: fty.sig.clean(),\n+                    decl: (ast_util::local_def(0), &fty.sig).clean(),\n                     onceness: fty.onceness,\n                     fn_style: fty.fn_style,\n                     bounds: fty.bounds.iter().map(|i| i.clean()).collect(),\n@@ -1009,7 +1034,7 @@ impl Clean<Type> for ty::t {\n                 let cx = super::ctxtkey.get().unwrap();\n                 let tcx = match cx.maybe_typed {\n                     core::Typed(ref tycx) => tycx,\n-                    core::NotTyped(_) => fail!(),\n+                    core::NotTyped(_) => unreachable!(),\n                 };\n                 let fqn = csearch::get_item_path(tcx, did);\n                 let fqn: Vec<String> = fqn.move_iter().map(|i| {\n@@ -1073,6 +1098,31 @@ impl Clean<Item> for ast::StructField {\n     }\n }\n \n+impl Clean<Item> for ty::field_ty {\n+    fn clean(&self) -> Item {\n+        use syntax::parse::token::special_idents::unnamed_field;\n+        let name = if self.name == unnamed_field.name {\n+            None\n+        } else {\n+            Some(self.name)\n+        };\n+        let cx = super::ctxtkey.get().unwrap();\n+        let tcx = match cx.maybe_typed {\n+            core::Typed(ref tycx) => tycx,\n+            core::NotTyped(_) => unreachable!(),\n+        };\n+        let ty = ty::lookup_item_type(tcx, self.id);\n+        Item {\n+            name: name.clean(),\n+            attrs: inline::load_attrs(tcx, self.id),\n+            source: Span::empty(),\n+            visibility: Some(self.vis),\n+            def_id: self.id,\n+            inner: StructFieldItem(TypedStructField(ty.ty.clean())),\n+        }\n+    }\n+}\n+\n pub type Visibility = ast::Visibility;\n \n impl Clean<Option<Visibility>> for ast::Visibility {\n@@ -1171,6 +1221,53 @@ impl Clean<Item> for doctree::Variant {\n     }\n }\n \n+impl Clean<Item> for ty::VariantInfo {\n+    fn clean(&self) -> Item {\n+        // use syntax::parse::token::special_idents::unnamed_field;\n+        let cx = super::ctxtkey.get().unwrap();\n+        let tcx = match cx.maybe_typed {\n+            core::Typed(ref tycx) => tycx,\n+            core::NotTyped(_) => fail!(\"tcx not present\"),\n+        };\n+        let kind = match self.arg_names.as_ref().map(|s| s.as_slice()) {\n+            None | Some([]) if self.args.len() == 0 => CLikeVariant,\n+            None | Some([]) => {\n+                TupleVariant(self.args.iter().map(|t| t.clean()).collect())\n+            }\n+            Some(s) => {\n+                StructVariant(VariantStruct {\n+                    struct_type: doctree::Plain,\n+                    fields_stripped: false,\n+                    fields: s.iter().zip(self.args.iter()).map(|(name, ty)| {\n+                        Item {\n+                            source: Span::empty(),\n+                            name: Some(name.clean()),\n+                            attrs: Vec::new(),\n+                            visibility: Some(ast::Public),\n+                            // FIXME: this is not accurate, we need an id for\n+                            //        the specific field but we're using the id\n+                            //        for the whole variant. Nothing currently\n+                            //        uses this so we should be good for now.\n+                            def_id: self.id,\n+                            inner: StructFieldItem(\n+                                TypedStructField(ty.clean())\n+                            )\n+                        }\n+                    }).collect()\n+                })\n+            }\n+        };\n+        Item {\n+            name: Some(self.name.clean()),\n+            attrs: inline::load_attrs(tcx, self.id),\n+            source: Span::empty(),\n+            visibility: Some(ast::Public),\n+            def_id: self.id,\n+            inner: VariantItem(Variant { kind: kind }),\n+        }\n+    }\n+}\n+\n #[deriving(Clone, Encodable, Decodable)]\n pub enum VariantKind {\n     CLikeVariant,\n@@ -1202,6 +1299,16 @@ pub struct Span {\n     pub hicol: uint,\n }\n \n+impl Span {\n+    fn empty() -> Span {\n+        Span {\n+            filename: \"\".to_strbuf(),\n+            loline: 0, locol: 0,\n+            hiline: 0, hicol: 0,\n+        }\n+    }\n+}\n+\n impl Clean<Span> for syntax::codemap::Span {\n     fn clean(&self) -> Span {\n         let ctxt = super::ctxtkey.get().unwrap();\n@@ -1273,6 +1380,12 @@ impl Clean<String> for ast::Ident {\n     }\n }\n \n+impl Clean<String> for ast::Name {\n+    fn clean(&self) -> String {\n+        token::get_name(*self).get().to_strbuf()\n+    }\n+}\n+\n #[deriving(Clone, Encodable, Decodable)]\n pub struct Typedef {\n     pub type_: Type,\n@@ -1345,7 +1458,7 @@ impl Clean<Item> for doctree::Static {\n     }\n }\n \n-#[deriving(Show, Clone, Encodable, Decodable)]\n+#[deriving(Show, Clone, Encodable, Decodable, Eq)]\n pub enum Mutability {\n     Mutable,\n     Immutable,\n@@ -1369,19 +1482,12 @@ pub struct Impl {\n     pub derived: bool,\n }\n \n+fn detect_derived<M: AttrMetaMethods>(attrs: &[M]) -> bool {\n+    attr::contains_name(attrs, \"automatically_derived\")\n+}\n+\n impl Clean<Item> for doctree::Impl {\n     fn clean(&self) -> Item {\n-        let mut derived = false;\n-        for attr in self.attrs.iter() {\n-            match attr.node.value.node {\n-                ast::MetaWord(ref s) => {\n-                    if s.get() == \"automatically_derived\" {\n-                        derived = true;\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n         Item {\n             name: None,\n             attrs: self.attrs.clean(),\n@@ -1393,7 +1499,7 @@ impl Clean<Item> for doctree::Impl {\n                 trait_: self.trait_.clean(),\n                 for_: self.for_.clean(),\n                 methods: self.methods.clean(),\n-                derived: derived,\n+                derived: detect_derived(self.attrs.as_slice()),\n             }),\n         }\n     }\n@@ -1404,18 +1510,63 @@ pub struct ViewItem {\n     pub inner: ViewItemInner,\n }\n \n-impl Clean<Item> for ast::ViewItem {\n-    fn clean(&self) -> Item {\n-        Item {\n-            name: None,\n-            attrs: self.attrs.clean().move_iter().collect(),\n-            source: self.span.clean(),\n-            def_id: ast_util::local_def(0),\n-            visibility: self.vis.clean(),\n-            inner: ViewItemItem(ViewItem {\n-                inner: self.node.clean()\n-            }),\n+impl Clean<Vec<Item>> for ast::ViewItem {\n+    fn clean(&self) -> Vec<Item> {\n+        // We consider inlining the documentation of `pub use` statments, but we\n+        // forcefully don't inline if this is not public or if the\n+        // #[doc(no_inline)] attribute is present.\n+        let denied = self.vis != ast::Public || self.attrs.iter().any(|a| {\n+            a.name().get() == \"doc\" && match a.meta_item_list() {\n+                Some(l) => attr::contains_name(l, \"no_inline\"),\n+                None => false,\n+            }\n+        });\n+        let convert = |node: &ast::ViewItem_| {\n+            Item {\n+                name: None,\n+                attrs: self.attrs.clean().move_iter().collect(),\n+                source: self.span.clean(),\n+                def_id: ast_util::local_def(0),\n+                visibility: self.vis.clean(),\n+                inner: ViewItemItem(ViewItem { inner: node.clean() }),\n+            }\n+        };\n+        let mut ret = Vec::new();\n+        match self.node {\n+            ast::ViewItemUse(ref path) if !denied => {\n+                match path.node {\n+                    ast::ViewPathGlob(..) => ret.push(convert(&self.node)),\n+                    ast::ViewPathList(ref a, ref list, ref b) => {\n+                        // Attempt to inline all reexported items, but be sure\n+                        // to keep any non-inlineable reexports so they can be\n+                        // listed in the documentation.\n+                        let remaining = list.iter().filter(|path| {\n+                            match inline::try_inline(path.node.id) {\n+                                Some(items) => {\n+                                    ret.extend(items.move_iter()); false\n+                                }\n+                                None => true,\n+                            }\n+                        }).map(|a| a.clone()).collect::<Vec<ast::PathListIdent>>();\n+                        if remaining.len() > 0 {\n+                            let path = ast::ViewPathList(a.clone(),\n+                                                         remaining,\n+                                                         b.clone());\n+                            let path = syntax::codemap::dummy_spanned(path);\n+                            ret.push(convert(&ast::ViewItemUse(@path)));\n+                        }\n+                    }\n+                    ast::ViewPathSimple(_, _, id) => {\n+                        match inline::try_inline(id) {\n+                            Some(items) => ret.extend(items.move_iter()),\n+                            None => ret.push(convert(&self.node)),\n+                        }\n+                    }\n+                }\n+            }\n+            ref n => ret.push(convert(n)),\n         }\n+        return ret;\n     }\n }\n \n@@ -1630,30 +1781,17 @@ fn register_def(cx: &core::DocContext, def: ast::Def) -> ast::DefId {\n         core::Typed(ref t) => t,\n         core::NotTyped(_) => return did\n     };\n-    let fqn = csearch::get_item_path(tcx, did);\n-    let fqn = fqn.move_iter().map(|i| i.to_str().to_strbuf()).collect();\n-    debug!(\"recording {} => {}\", did, fqn);\n-    cx.external_paths.borrow_mut().get_mut_ref().insert(did, (fqn, kind));\n+    inline::record_extern_fqn(cx, did, kind);\n     match kind {\n         TypeTrait => {\n-            let t = build_external_trait(tcx, did);\n+            let t = inline::build_external_trait(tcx, did);\n             cx.external_traits.borrow_mut().get_mut_ref().insert(did, t);\n         }\n         _ => {}\n     }\n     return did;\n }\n \n-fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> Trait {\n-    let def = csearch::get_trait_def(tcx, did);\n-    let methods = ty::trait_methods(tcx, did);\n-    Trait {\n-        generics: def.generics.clean(),\n-        methods: methods.iter().map(|i| i.clean()).collect(),\n-        parents: Vec::new(), // FIXME: this is likely wrong\n-    }\n-}\n-\n fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n     ImportSource {\n         path: path,", "previous_filename": "src/librustdoc/clean.rs"}, {"sha": "9043ffd10ba95da43bac03e0a2efa2c4e28ccc1e", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "patch": "@@ -99,7 +99,7 @@ impl fmt::Show for clean::TyParamBound {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::RegionBound => {\n-                f.write(\"::\".as_bytes())\n+                f.write(\"'static\".as_bytes())\n             }\n             clean::TraitBound(ref ty) => {\n                 write!(f, \"{}\", *ty)\n@@ -150,7 +150,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, p: &clean::Path,\n                  print_all: bool) -> fmt::Result {\n     path(w, p, print_all,\n         |cache, loc| {\n-            if ast_util::is_local(did) {\n+            if ast_util::is_local(did) || cache.paths.contains_key(&did) {\n                 Some((\"../\".repeat(loc.len())).to_strbuf())\n             } else {\n                 match *cache.extern_locations.get(&did.krate) {"}, {"sha": "f49b7f3e9890305daf71530384d89dee440ff27b", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "patch": "@@ -144,6 +144,8 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n     extern fn block(ob: *mut hoedown_buffer, text: *hoedown_buffer,\n                     lang: *hoedown_buffer, opaque: *mut libc::c_void) {\n         unsafe {\n+            if text.is_null() { return }\n+\n             let opaque = opaque as *mut hoedown_html_renderer_state;\n             let my_opaque: &MyOpaque = &*((*opaque).opaque as *MyOpaque);\n             slice::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {"}, {"sha": "d601d2ae957feb5563a7d1cdd828fce5d0f629cc", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 113, "deletions": 62, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "patch": "@@ -132,7 +132,7 @@ pub struct Cache {\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    pub impls: HashMap<ast::NodeId, Vec<(clean::Impl, Option<String>)>>,\n+    pub impls: HashMap<ast::DefId, Vec<(clean::Impl, Option<String>)>>,\n \n     /// Maintains a mapping of local crate node ids to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n@@ -141,6 +141,10 @@ pub struct Cache {\n     /// necessary.\n     pub paths: HashMap<ast::DefId, (Vec<String>, ItemType)>,\n \n+    /// Similar to `paths`, but only holds external paths. This is only used for\n+    /// generating explicit hyperlinks to other crates.\n+    pub external_paths: HashMap<ast::DefId, Vec<String>>,\n+\n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n     /// parent trait if no extra documentation is specified, and default methods\n@@ -157,9 +161,9 @@ pub struct Cache {\n \n     // Private fields only used when initially crawling a crate to build a cache\n \n-    stack: Vec<String> ,\n-    parent_stack: Vec<ast::NodeId> ,\n-    search_index: Vec<IndexItem> ,\n+    stack: Vec<String>,\n+    parent_stack: Vec<ast::DefId>,\n+    search_index: Vec<IndexItem>,\n     privmod: bool,\n     public_items: NodeSet,\n \n@@ -198,7 +202,7 @@ struct IndexItem {\n     name: String,\n     path: String,\n     desc: String,\n-    parent: Option<ast::NodeId>,\n+    parent: Option<ast::DefId>,\n }\n \n // TLS keys used to carry information around during rendering.\n@@ -249,7 +253,8 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     let analysis = ::analysiskey.get();\n     let public_items = analysis.as_ref().map(|a| a.public_items.clone());\n     let public_items = public_items.unwrap_or(NodeSet::new());\n-    let paths = analysis.as_ref().map(|a| {\n+    let paths: HashMap<ast::DefId, (Vec<String>, ItemType)> =\n+      analysis.as_ref().map(|a| {\n         let paths = a.external_paths.borrow_mut().take_unwrap();\n         paths.move_iter().map(|(k, (v, t))| {\n             (k, (v, match t {\n@@ -265,6 +270,8 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     }).unwrap_or(HashMap::new());\n     let mut cache = Cache {\n         impls: HashMap::new(),\n+        external_paths: paths.iter().map(|(&k, &(ref v, _))| (k, v.clone()))\n+                             .collect(),\n         paths: paths,\n         implementors: HashMap::new(),\n         stack: Vec::new(),\n@@ -302,7 +309,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n                         path: fqp.slice_to(fqp.len() - 1).connect(\"::\")\n                                                          .to_strbuf(),\n                         desc: shorter(item.doc_value()).to_strbuf(),\n-                        parent: Some(pid),\n+                        parent: Some(did),\n                     });\n                 },\n                 None => {}\n@@ -360,9 +367,8 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n \n         try!(write!(&mut w, r#\"],\"paths\":[\"#));\n \n-        for (i, &nodeid) in pathid_to_nodeid.iter().enumerate() {\n-            let def = ast_util::local_def(nodeid);\n-            let &(ref fqp, short) = cache.paths.find(&def).unwrap();\n+        for (i, &did) in pathid_to_nodeid.iter().enumerate() {\n+            let &(ref fqp, short) = cache.paths.find(&did).unwrap();\n             if i > 0 {\n                 try!(write!(&mut w, \",\"));\n             }\n@@ -497,13 +503,15 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n             seen: HashSet::new(),\n             cx: &mut cx,\n         };\n+        // skip all invalid spans\n+        folder.seen.insert(\"\".to_strbuf());\n         krate = folder.fold_crate(krate);\n     }\n \n     for &(n, ref e) in krate.externs.iter() {\n         cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n         let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n-        cache.paths.insert(did, (Vec::new(), item_type::Module));\n+        cache.paths.insert(did, (vec![e.name.to_strbuf()], item_type::Module));\n     }\n \n     // And finally render the whole crate's documentation\n@@ -730,14 +738,13 @@ impl DocFolder for Cache {\n                     clean::VariantItem(..) => {\n                         (Some(*self.parent_stack.last().unwrap()),\n                          Some(self.stack.slice_to(self.stack.len() - 1)))\n-\n                     }\n                     clean::MethodItem(..) => {\n                         if self.parent_stack.len() == 0 {\n                             (None, None)\n                         } else {\n                             let last = self.parent_stack.last().unwrap();\n-                            let did = ast_util::local_def(*last);\n+                            let did = *last;\n                             let path = match self.paths.find(&did) {\n                                 Some(&(_, item_type::Trait)) =>\n                                     Some(self.stack.slice_to(self.stack.len() - 1)),\n@@ -766,9 +773,11 @@ impl DocFolder for Cache {\n                         });\n                     }\n                     (Some(parent), None) if !self.privmod => {\n-                        // We have a parent, but we don't know where they're\n-                        // defined yet. Wait for later to index this item.\n-                        self.orphan_methods.push((parent, item.clone()))\n+                        if ast_util::is_local(parent) {\n+                            // We have a parent, but we don't know where they're\n+                            // defined yet. Wait for later to index this item.\n+                            self.orphan_methods.push((parent.node, item.clone()))\n+                        }\n                     }\n                     _ => {}\n                 }\n@@ -789,19 +798,18 @@ impl DocFolder for Cache {\n             clean::TypedefItem(..) | clean::TraitItem(..) |\n             clean::FunctionItem(..) | clean::ModuleItem(..) |\n             clean::ForeignFunctionItem(..) => {\n-                if ast_util::is_local(item.def_id) {\n-                    // Reexported items mean that the same id can show up twice\n-                    // in the rustdoc ast that we're looking at. We know,\n-                    // however, that a reexported item doesn't show up in the\n-                    // `public_items` map, so we can skip inserting into the\n-                    // paths map if there was already an entry present and we're\n-                    // not a public item.\n-                    let id = item.def_id.node;\n-                    if !self.paths.contains_key(&item.def_id) ||\n-                       self.public_items.contains(&id) {\n-                        self.paths.insert(item.def_id,\n-                                          (self.stack.clone(), shortty(&item)));\n-                    }\n+                // Reexported items mean that the same id can show up twice\n+                // in the rustdoc ast that we're looking at. We know,\n+                // however, that a reexported item doesn't show up in the\n+                // `public_items` map, so we can skip inserting into the\n+                // paths map if there was already an entry present and we're\n+                // not a public item.\n+                let id = item.def_id.node;\n+                if !self.paths.contains_key(&item.def_id) ||\n+                   !ast_util::is_local(item.def_id) ||\n+                   self.public_items.contains(&id) {\n+                    self.paths.insert(item.def_id,\n+                                      (self.stack.clone(), shortty(&item)));\n                 }\n             }\n             // link variants to their parent enum because pages aren't emitted\n@@ -817,20 +825,14 @@ impl DocFolder for Cache {\n         // Maintain the parent stack\n         let parent_pushed = match item.inner {\n             clean::TraitItem(..) | clean::EnumItem(..) | clean::StructItem(..) => {\n-                if ast_util::is_local(item.def_id) {\n-                    self.parent_stack.push(item.def_id.node);\n-                }\n+                self.parent_stack.push(item.def_id);\n                 true\n             }\n             clean::ImplItem(ref i) => {\n                 match i.for_ {\n                     clean::ResolvedPath{ did, .. } => {\n-                        if ast_util::is_local(did) {\n-                            self.parent_stack.push(did.node);\n-                            true\n-                        } else {\n-                            false\n-                        }\n+                        self.parent_stack.push(did);\n+                        true\n                     }\n                     _ => false\n                 }\n@@ -845,10 +847,8 @@ impl DocFolder for Cache {\n                 match item {\n                     clean::Item{ attrs, inner: clean::ImplItem(i), .. } => {\n                         match i.for_ {\n-                            clean::ResolvedPath { did, .. }\n-                                if ast_util::is_local(did) =>\n-                            {\n-                                let v = self.impls.find_or_insert_with(did.node, |_| {\n+                            clean::ResolvedPath { did, .. } => {\n+                                let v = self.impls.find_or_insert_with(did, |_| {\n                                     Vec::new()\n                                 });\n                                 // extract relevant documentation for this impl\n@@ -1041,23 +1041,62 @@ impl<'a> Item<'a> {\n         }\n     }\n \n-    fn link(&self) -> String {\n-        let mut path = Vec::new();\n-        clean_srcpath(self.item.source.filename.as_bytes(), |component| {\n-            path.push(component.to_owned());\n-        });\n-        let href = if self.item.source.loline == self.item.source.hiline {\n-            format_strbuf!(\"{}\", self.item.source.loline)\n+    /// Generate a url appropriate for an `href` attribute back to the source of\n+    /// this item.\n+    ///\n+    /// The url generated, when clicked, will redirect the browser back to the\n+    /// original source code.\n+    ///\n+    /// If `None` is returned, then a source link couldn't be generated. This\n+    /// may happen, for example, with externally inlined items where the source\n+    /// of their crate documentation isn't known.\n+    fn href(&self) -> Option<String> {\n+        // If this item is part of the local crate, then we're guaranteed to\n+        // know the span, so we plow forward and generate a proper url. The url\n+        // has anchors for the line numbers that we're linking to.\n+        if ast_util::is_local(self.item.def_id) {\n+            let mut path = Vec::new();\n+            clean_srcpath(self.item.source.filename.as_bytes(), |component| {\n+                path.push(component.to_owned());\n+            });\n+            let href = if self.item.source.loline == self.item.source.hiline {\n+                format!(\"{}\", self.item.source.loline)\n+            } else {\n+                format!(\"{}-{}\",\n+                        self.item.source.loline,\n+                        self.item.source.hiline)\n+            };\n+            Some(format!(\"{root}src/{krate}/{path}.html\\\\#{href}\",\n+                         root = self.cx.root_path,\n+                         krate = self.cx.layout.krate,\n+                         path = path.connect(\"/\"),\n+                         href = href))\n+\n+        // If this item is not part of the local crate, then things get a little\n+        // trickier. We don't actually know the span of the external item, but\n+        // we know that the documentation on the other end knows the span!\n+        //\n+        // In this case, we generate a link to the *documentation* for this type\n+        // in the original crate. There's an extra URL parameter which says that\n+        // we want to go somewhere else, and the JS on the destination page will\n+        // pick it up and instantly redirect the browser to the source code.\n+        //\n+        // If we don't know where the external documentation for this crate is\n+        // located, then we return `None`.\n         } else {\n-            format_strbuf!(\"{}-{}\",\n-                           self.item.source.loline,\n-                           self.item.source.hiline)\n-        };\n-        format_strbuf!(\"{root}src/{krate}/{path}.html\\\\#{href}\",\n-                       root = self.cx.root_path,\n-                       krate = self.cx.layout.krate,\n-                       path = path.connect(\"/\"),\n-                       href = href)\n+            let cache = cache_key.get().unwrap();\n+            let path = cache.external_paths.get(&self.item.def_id);\n+            let root = match *cache.extern_locations.get(&self.item.def_id.krate) {\n+                Remote(ref s) => s.to_strbuf(),\n+                Local => format!(\"{}/..\", self.cx.root_path),\n+                Unknown => return None,\n+            };\n+            Some(format!(\"{root}/{path}/{file}?gotosrc={goto}\",\n+                         root = root,\n+                         path = path.slice_to(path.len() - 1).connect(\"/\"),\n+                         file = item_path(self.item),\n+                         goto = self.item.def_id.node))\n+        }\n     }\n }\n \n@@ -1105,9 +1144,21 @@ impl<'a> fmt::Show for Item<'a> {\n         }\n \n         // Write `src` tag\n+        //\n+        // When this item is part of a `pub use` in a downstream crate, the\n+        // [src] link in the downstream documentation will actually come back to\n+        // this page, and this link will be auto-clicked. The `id` attribute is\n+        // used to find the link to auto-click.\n         if self.cx.include_sources {\n-            try!(write!(fmt, \"<a class='source' href='{}'>[src]</a>\",\n-                        self.link()));\n+            match self.href() {\n+                Some(l) => {\n+                    try!(write!(fmt,\n+                                \"<a class='source' id='src-{}' \\\n+                                    href='{}'>[src]</a>\",\n+                                self.item.def_id.node, l));\n+                }\n+                None => {}\n+            }\n         }\n         try!(write!(fmt, \"</h1>\\n\"));\n \n@@ -1266,7 +1317,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                         try!(write!(f, \"<code> = </code>\"));\n                         if s.contains(\"\\n\") {\n                             write!(f, \"<a href='{}'>[definition]</a>\",\n-                                   item.link())\n+                                   item.href())\n                         } else {\n                             write!(f, \"<code>{}</code>\", s.as_slice())\n                         }\n@@ -1672,7 +1723,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n }\n \n fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n-    match cache_key.get().unwrap().impls.find(&it.def_id.node) {\n+    match cache_key.get().unwrap().impls.find(&it.def_id) {\n         Some(v) => {\n             let mut non_trait = v.iter().filter(|p| {\n                 p.ref0().trait_.is_none()"}, {"sha": "2fb824653d3dbd4df42bbe7bf82d4939479f6278", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "patch": "@@ -675,4 +675,10 @@\n     if (window.pending_implementors) {\n         window.register_implementors(window.pending_implementors);\n     }\n+\n+    // See documentaiton in html/render.rs for what this is doing.\n+    var query = getQueryStringParams();\n+    if (query['gotosrc']) {\n+        window.location = $('#src-' + query['gotosrc']).attr('href');\n+    }\n }());"}, {"sha": "390f81642e6b2092cbb045a238a9b5e6fe2f37f5", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "patch": "@@ -152,7 +152,8 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::ImplItem(clean::Impl{\n                 for_: clean::ResolvedPath{ did, .. }, ..\n             }) => {\n-                if !self.exported_items.contains(&did.node) {\n+                if ast_util::is_local(did) &&\n+                   !self.exported_items.contains(&did.node) {\n                     return None;\n                 }\n             }"}, {"sha": "1786cc8062e214181d21224cf662403aba23e95c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "patch": "@@ -16,10 +16,10 @@\n //!\n //! ## Intrinsic types and operations\n //!\n-//! The [`ptr`](../core/ptr/index.html) and [`mem`](../core/mem/index.html)\n+//! The [`ptr`](ptr/index.html) and [`mem`](mem/index.html)\n //! modules deal with unsafe pointers and memory manipulation.\n-//! [`kinds`](../core/kinds/index.html) defines the special built-in traits,\n-//! and [`raw`](../core/raw/index.html) the runtime representation of Rust types.\n+//! [`kinds`](kinds/index.html) defines the special built-in traits,\n+//! and [`raw`](raw/index.html) the runtime representation of Rust types.\n //! These are some of the lowest-level building blocks in Rust.\n //!\n //! ## Math on primitive types and math traits\n@@ -31,11 +31,11 @@\n //!\n //! ## Pervasive types\n //!\n-//! The [`option`](option/index.html) and [`result`](../core/result/index.html)\n+//! The [`option`](option/index.html) and [`result`](result/index.html)\n //! modules define optional and error-handling types, `Option` and `Result`.\n-//! [`iter`](../core/iter/index.html) defines Rust's iterator protocol\n+//! [`iter`](iter/index.html) defines Rust's iterator protocol\n //! along with a wide variety of iterators.\n-//! [`Cell` and `RefCell`](../core/cell/index.html) are for creating types that\n+//! [`Cell` and `RefCell`](cell/index.html) are for creating types that\n //! manage their own mutability.\n //!\n //! ## Vectors, slices and strings"}, {"sha": "07aaeac64be1c811caa19284bc1e3add7e91d839", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 49, "deletions": 42, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fca6c6a02d03491ee46ea5c4b656d114a73a53b/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=0fca6c6a02d03491ee46ea5c4b656d114a73a53b", "patch": "@@ -38,55 +38,62 @@\n //! `drop`, `spawn`, and `channel`.\n \n // Reexported core operators\n-pub use kinds::{Copy, Send, Sized, Share};\n-pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n-pub use ops::{BitAnd, BitOr, BitXor};\n-pub use ops::{Drop, Deref, DerefMut};\n-pub use ops::{Shl, Shr, Index};\n-pub use option::{Option, Some, None};\n-pub use result::{Result, Ok, Err};\n+#[doc(no_inline)] pub use kinds::{Copy, Send, Sized, Share};\n+#[doc(no_inline)] pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n+#[doc(no_inline)] pub use ops::{BitAnd, BitOr, BitXor};\n+#[doc(no_inline)] pub use ops::{Drop, Deref, DerefMut};\n+#[doc(no_inline)] pub use ops::{Shl, Shr, Index};\n+#[doc(no_inline)] pub use option::{Option, Some, None};\n+#[doc(no_inline)] pub use result::{Result, Ok, Err};\n \n // Reexported functions\n-pub use from_str::from_str;\n-pub use iter::range;\n-pub use mem::drop;\n+#[doc(no_inline)] pub use from_str::from_str;\n+#[doc(no_inline)] pub use iter::range;\n+#[doc(no_inline)] pub use mem::drop;\n \n // Reexported types and traits\n \n-pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, IntoBytes};\n-pub use c_str::ToCStr;\n-pub use char::Char;\n-pub use clone::Clone;\n-pub use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater, Equiv};\n-pub use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n-pub use iter::{FromIterator, Extendable};\n-pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIterator};\n-pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n-pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n-pub use num::{Signed, Unsigned};\n-pub use num::{Primitive, Int, Float, FloatMath, ToPrimitive, FromPrimitive};\n-pub use option::Expect;\n-pub use owned::Box;\n-pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n-pub use ptr::RawPtr;\n-pub use io::{Buffer, Writer, Reader, Seek};\n-pub use str::{Str, StrVector, StrSlice, OwnedStr, IntoMaybeOwned};\n-pub use str::{StrAllocating};\n-pub use to_str::{ToStr, IntoStr};\n-pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n-pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n-pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n-pub use slice::{CloneableVector, ImmutableCloneableVector, MutableCloneableVector};\n-pub use slice::{ImmutableVector, MutableVector};\n-pub use slice::{ImmutableEqVector, ImmutableTotalOrdVector, MutableTotalOrdVector};\n-pub use slice::{Vector, VectorVector, OwnedVector, MutableVectorAllocating};\n-pub use string::String;\n-pub use vec::Vec;\n+#[doc(no_inline)] pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr};\n+#[doc(no_inline)] pub use ascii::IntoBytes;\n+#[doc(no_inline)] pub use c_str::ToCStr;\n+#[doc(no_inline)] pub use char::Char;\n+#[doc(no_inline)] pub use clone::Clone;\n+#[doc(no_inline)] pub use cmp::{Eq, Ord, TotalEq, TotalOrd};\n+#[doc(no_inline)] pub use cmp::{Ordering, Less, Equal, Greater, Equiv};\n+#[doc(no_inline)] pub use container::{Container, Mutable, Map, MutableMap};\n+#[doc(no_inline)] pub use container::{Set, MutableSet};\n+#[doc(no_inline)] pub use iter::{FromIterator, Extendable, ExactSize};\n+#[doc(no_inline)] pub use iter::{Iterator, DoubleEndedIterator};\n+#[doc(no_inline)] pub use iter::{RandomAccessIterator, CloneableIterator};\n+#[doc(no_inline)] pub use iter::{OrdIterator, MutableDoubleEndedIterator};\n+#[doc(no_inline)] pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n+#[doc(no_inline)] pub use num::{Signed, Unsigned, Primitive, Int, Float};\n+#[doc(no_inline)] pub use num::{FloatMath, ToPrimitive, FromPrimitive};\n+#[doc(no_inline)] pub use option::Expect;\n+#[doc(no_inline)] pub use owned::Box;\n+#[doc(no_inline)] pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n+#[doc(no_inline)] pub use ptr::RawPtr;\n+#[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek};\n+#[doc(no_inline)] pub use str::{Str, StrVector, StrSlice, OwnedStr};\n+#[doc(no_inline)] pub use str::{IntoMaybeOwned, StrAllocating};\n+#[doc(no_inline)] pub use to_str::{ToStr, IntoStr};\n+#[doc(no_inline)] pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n+#[doc(no_inline)] pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n+#[doc(no_inline)] pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n+#[doc(no_inline)] pub use slice::{CloneableVector, ImmutableCloneableVector};\n+#[doc(no_inline)] pub use slice::{MutableCloneableVector, MutableTotalOrdVector};\n+#[doc(no_inline)] pub use slice::{ImmutableVector, MutableVector};\n+#[doc(no_inline)] pub use slice::{ImmutableEqVector, ImmutableTotalOrdVector};\n+#[doc(no_inline)] pub use slice::{Vector, VectorVector, OwnedVector};\n+#[doc(no_inline)] pub use slice::MutableVectorAllocating;\n+#[doc(no_inline)] pub use string::String;\n+#[doc(no_inline)] pub use vec::Vec;\n \n // Reexported runtime types\n-pub use comm::{sync_channel, channel, SyncSender, Sender, Receiver};\n-pub use task::spawn;\n+#[doc(no_inline)] pub use comm::{sync_channel, channel};\n+#[doc(no_inline)] pub use comm::{SyncSender, Sender, Receiver};\n+#[doc(no_inline)] pub use task::spawn;\n \n // Reexported statics\n #[cfg(not(test))]\n-pub use gc::GC;\n+#[doc(no_inline)] pub use gc::GC;"}]}