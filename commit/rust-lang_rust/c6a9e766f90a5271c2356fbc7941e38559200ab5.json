{"sha": "c6a9e766f90a5271c2356fbc7941e38559200ab5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2YTllNzY2ZjkwYTUyNzFjMjM1NmZiYzc5NDFlMzg1NTkyMDBhYjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-10T12:26:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-10T12:26:44Z"}, "message": "Auto merge of #62339 - pnkfelix:issue-61188-use-visitor-for-structural-match-check, r=nikomatsakis\n\nuse visitor for #[structural_match] check\n\nThis changes the code so that we recur down the structure of a type of a const (rather than just inspecting at a shallow one or two levels) when we are looking to see if it has an ADT that did not derive `PartialEq` and `Eq`.\n\nFix #61188\n\nFix #62307\n\nCc #62336", "tree": {"sha": "f529f2030ea85e0ef147620a0888db767b404e21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f529f2030ea85e0ef147620a0888db767b404e21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6a9e766f90a5271c2356fbc7941e38559200ab5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6a9e766f90a5271c2356fbc7941e38559200ab5", "html_url": "https://github.com/rust-lang/rust/commit/c6a9e766f90a5271c2356fbc7941e38559200ab5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6a9e766f90a5271c2356fbc7941e38559200ab5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4e15655092d1bdae79619eb0ff2c3cb5468fc36", "html_url": "https://github.com/rust-lang/rust/commit/d4e15655092d1bdae79619eb0ff2c3cb5468fc36"}, {"sha": "b0b64ddcd171be6e460b2d7c1ada4f98a3cdb026", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0b64ddcd171be6e460b2d7c1ada4f98a3cdb026", "html_url": "https://github.com/rust-lang/rust/commit/b0b64ddcd171be6e460b2d7c1ada4f98a3cdb026"}], "stats": {"total": 692, "additions": 686, "deletions": 6}, "files": [{"sha": "9b4b97202d96de04a9b147c5e62c52b2b51ab43c", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -348,6 +348,12 @@ declare_lint! {\n     \"outlives requirements can be inferred\"\n }\n \n+declare_lint! {\n+    pub INDIRECT_STRUCTURAL_MATCH,\n+    Warn,\n+    \"pattern with const indirectly referencing non-`#[structural_match]` type\"\n+}\n+\n /// Some lints that are buffered from `libsyntax`. See `syntax::early_buffered_lints`.\n pub mod parser {\n     declare_lint! {"}, {"sha": "bdd48b34474981d9841faa1769d6749992f841a3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -326,6 +326,7 @@ language_item_table! {\n     UnpinTraitLangItem,          \"unpin\",              unpin_trait,             Target::Trait;\n     PinTypeLangItem,             \"pin\",                pin_type,                Target::Struct;\n \n+    // Don't be fooled by the naming here: this lang item denotes `PartialEq`, not `Eq`.\n     EqTraitLangItem,             \"eq\",                 eq_trait,                Target::Trait;\n     PartialOrdTraitLangItem,     \"partial_ord\",        partial_ord_trait,       Target::Trait;\n     OrdTraitLangItem,            \"ord\",                ord_trait,               Target::Trait;"}, {"sha": "82348e330f5b6d31a2facc1dc5901f48132b7ddd", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -429,6 +429,11 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(MUTABLE_BORROW_RESERVATION_CONFLICT),\n             reference: \"issue #59159 <https://github.com/rust-lang/rust/issues/59159>\",\n             edition: None,\n+        },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(INDIRECT_STRUCTURAL_MATCH),\n+            reference: \"issue #62411 <https://github.com/rust-lang/rust/issues/62411>\",\n+            edition: None,\n         }\n         ]);\n "}, {"sha": "32a8c5cd3bb28f92c35c613662c020e469715344", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -170,6 +170,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                     let mut patcx = PatternContext::new(self.tcx,\n                                                         self.param_env.and(self.identity_substs),\n                                                         self.tables);\n+                    patcx.include_lint_checks();\n                     let pattern = expand_pattern(cx, patcx.lower_pattern(&pat));\n                     if !patcx.errors.is_empty() {\n                         patcx.report_inlining_errors(pat.span);\n@@ -266,6 +267,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             let mut patcx = PatternContext::new(self.tcx,\n                                                 self.param_env.and(self.identity_substs),\n                                                 self.tables);\n+            patcx.include_lint_checks();\n             let pattern = patcx.lower_pattern(pat);\n             let pattern_ty = pattern.ty;\n             let pats: Matrix<'_, '_> = vec![smallvec!["}, {"sha": "1baeda41498ed0d50392d679e6dc886d501ef1a0", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 207, "deletions": 6, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -10,9 +10,11 @@ use crate::const_eval::const_variant_index;\n use crate::hair::util::UserAnnotatedTyHelpers;\n use crate::hair::constant::*;\n \n+use rustc::lint;\n use rustc::mir::{Field, BorrowKind, Mutability};\n use rustc::mir::{UserTypeProjection};\n use rustc::mir::interpret::{GlobalId, ConstValue, sign_extend, AllocId, Pointer};\n+use rustc::traits::{ObligationCause, PredicateObligation};\n use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, UserType, DefIdTree};\n use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations};\n use rustc::ty::subst::{SubstsRef, Kind};\n@@ -23,6 +25,7 @@ use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::hir::ptr::P;\n \n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::fx::FxHashSet;\n \n use std::cmp::Ordering;\n use std::fmt;\n@@ -332,6 +335,7 @@ pub struct PatternContext<'a, 'tcx> {\n     pub tables: &'a ty::TypeckTables<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n     pub errors: Vec<PatternError>,\n+    include_lint_checks: bool,\n }\n \n impl<'a, 'tcx> Pattern<'tcx> {\n@@ -363,10 +367,16 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             param_env: param_env_and_substs.param_env,\n             tables,\n             substs: param_env_and_substs.value,\n-            errors: vec![]\n+            errors: vec![],\n+            include_lint_checks: false,\n         }\n     }\n \n+    pub fn include_lint_checks(&mut self) -> &mut Self {\n+        self.include_lint_checks = true;\n+        self\n+    }\n+\n     pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n         // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n         // pattern has the type that results *after* dereferencing. For example, in this code:\n@@ -942,23 +952,94 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n     /// Converts an evaluated constant to a pattern (if possible).\n     /// This means aggregate values (like structs and enums) are converted\n-    /// to a pattern that matches the value (as if you'd compared via equality).\n+    /// to a pattern that matches the value (as if you'd compared via structural equality).\n     fn const_to_pat(\n         &self,\n         instance: ty::Instance<'tcx>,\n         cv: &'tcx ty::Const<'tcx>,\n         id: hir::HirId,\n         span: Span,\n     ) -> Pattern<'tcx> {\n+        // This method is just a warpper handling a validity check; the heavy lifting is\n+        // performed by the recursive const_to_pat_inner method, which is not meant to be\n+        // invoked except by this method.\n+        //\n+        // once indirect_structural_match is a full fledged error, this\n+        // level of indirection can be eliminated\n+\n         debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n-        let adt_subpattern = |i, variant_opt| {\n+        debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n+\n+        let mut saw_error = false;\n+        let inlined_const_as_pat = self.const_to_pat_inner(instance, cv, id, span, &mut saw_error);\n+\n+        if self.include_lint_checks && !saw_error {\n+            // If we were able to successfully convert the const to some pat, double-check\n+            // that the type of the const obeys `#[structural_match]` constraint.\n+            if let Some(adt_def) = search_for_adt_without_structural_match(self.tcx, cv.ty) {\n+\n+                let path = self.tcx.def_path_str(adt_def.did);\n+                let msg = format!(\n+                    \"to use a constant of type `{}` in a pattern, \\\n+                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                    path,\n+                    path,\n+                );\n+\n+                // before issuing lint, double-check there even *is* a\n+                // semantic PartialEq for us to dispatch to.\n+                //\n+                // (If there isn't, then we can safely issue a hard\n+                // error, because that's never worked, due to compiler\n+                // using PartialEq::eq in this scenario in the past.)\n+\n+                let ty_is_partial_eq: bool = {\n+                    let partial_eq_trait_id = self.tcx.lang_items().eq_trait().unwrap();\n+                    let obligation: PredicateObligation<'_> =\n+                        self.tcx.predicate_for_trait_def(self.param_env,\n+                                                         ObligationCause::misc(span, id),\n+                                                         partial_eq_trait_id,\n+                                                         0,\n+                                                         cv.ty,\n+                                                         &[]);\n+                    self.tcx\n+                        .infer_ctxt()\n+                        .enter(|infcx| infcx.predicate_may_hold(&obligation))\n+                };\n+\n+                if !ty_is_partial_eq {\n+                    // span_fatal avoids ICE from resolution of non-existent method (rare case).\n+                    self.tcx.sess.span_fatal(span, &msg);\n+                } else {\n+                    self.tcx.lint_hir(lint::builtin::INDIRECT_STRUCTURAL_MATCH, id, span, &msg);\n+                }\n+            }\n+        }\n+\n+        inlined_const_as_pat\n+    }\n+\n+    /// Recursive helper for `const_to_pat`; invoke that (instead of calling this directly).\n+    fn const_to_pat_inner(\n+        &self,\n+        instance: ty::Instance<'tcx>,\n+        cv: &'tcx ty::Const<'tcx>,\n+        id: hir::HirId,\n+        span: Span,\n+        // This tracks if we signal some hard error for a given const\n+        // value, so that we will not subsequently issue an irrelevant\n+        // lint for the same const value.\n+        saw_const_match_error: &mut bool,\n+    ) -> Pattern<'tcx> {\n+\n+        let mut adt_subpattern = |i, variant_opt| {\n             let field = Field::new(i);\n             let val = crate::const_eval::const_field(\n                 self.tcx, self.param_env, variant_opt, field, cv\n             );\n-            self.const_to_pat(instance, val, id, span)\n+            self.const_to_pat_inner(instance, val, id, span, saw_const_match_error)\n         };\n-        let adt_subpatterns = |n, variant_opt| {\n+        let mut adt_subpatterns = |n, variant_opt| {\n             (0..n).map(|i| {\n                 let field = Field::new(i);\n                 FieldPattern {\n@@ -967,7 +1048,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }).collect::<Vec<_>>()\n         };\n-        debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n+\n+\n         let kind = match cv.ty.sty {\n             ty::Float(_) => {\n                 self.tcx.lint_hir(\n@@ -982,9 +1064,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n+                *saw_const_match_error = true;\n                 self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n                 PatternKind::Wild\n             }\n+            // keep old code until future-compat upgraded to errors.\n             ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n                 let path = self.tcx.def_path_str(adt_def.did);\n                 let msg = format!(\n@@ -993,9 +1077,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     path,\n                     path,\n                 );\n+                *saw_const_match_error = true;\n                 self.tcx.sess.span_err(span, &msg);\n                 PatternKind::Wild\n             }\n+            // keep old code until future-compat upgraded to errors.\n             ty::Ref(_, ty::TyS { sty: ty::Adt(adt_def, _), .. }, _)\n             if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n                 // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n@@ -1007,6 +1093,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     path,\n                     path,\n                 );\n+                *saw_const_match_error = true;\n                 self.tcx.sess.span_err(span, &msg);\n                 PatternKind::Wild\n             }\n@@ -1058,6 +1145,120 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     }\n }\n \n+/// This method traverses the structure of `ty`, trying to find an\n+/// instance of an ADT (i.e. struct or enum) that was declared without\n+/// the `#[structural_match]` attribute.\n+///\n+/// The \"structure of a type\" includes all components that would be\n+/// considered when doing a pattern match on a constant of that\n+/// type.\n+///\n+///  * This means this method descends into fields of structs/enums,\n+///    and also descends into the inner type `T` of `&T` and `&mut T`\n+///\n+///  * The traversal doesn't dereference unsafe pointers (`*const T`,\n+///    `*mut T`), and it does not visit the type arguments of an\n+///    instantiated generic like `PhantomData<T>`.\n+///\n+/// The reason we do this search is Rust currently require all ADT's\n+/// reachable from a constant's type to be annotated with\n+/// `#[structural_match]`, an attribute which essentially says that\n+/// the implementation of `PartialEq::eq` behaves *equivalently* to a\n+/// comparison against the unfolded structure.\n+///\n+/// For more background on why Rust has this requirement, and issues\n+/// that arose when the requirement was not enforced completely, see\n+/// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n+fn search_for_adt_without_structural_match<'tcx>(tcx: TyCtxt<'tcx>,\n+                                                 ty: Ty<'tcx>)\n+                                                 -> Option<&'tcx AdtDef>\n+{\n+    // Import here (not mod level), because `TypeFoldable::fold_with`\n+    // conflicts with `PatternFoldable::fold_with`\n+    use crate::rustc::ty::fold::TypeVisitor;\n+    use crate::rustc::ty::TypeFoldable;\n+\n+    let mut search = Search { tcx, found: None, seen: FxHashSet::default() };\n+    ty.visit_with(&mut search);\n+    return search.found;\n+\n+    struct Search<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+\n+        // records the first ADT we find without `#[structural_match`\n+        found: Option<&'tcx AdtDef>,\n+\n+        // tracks ADT's previously encountered during search, so that\n+        // we will not recur on them again.\n+        seen: FxHashSet<&'tcx AdtDef>,\n+    }\n+\n+    impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n+        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+            debug!(\"Search visiting ty: {:?}\", ty);\n+\n+            let (adt_def, substs) = match ty.sty {\n+                ty::Adt(adt_def, substs) => (adt_def, substs),\n+                ty::RawPtr(..) => {\n+                    // `#[structural_match]` ignores substructure of\n+                    // `*const _`/`*mut _`, so skip super_visit_with\n+\n+                    // (But still tell caller to continue search.)\n+                    return false;\n+                }\n+                ty::Array(_, n) if n.assert_usize(self.tcx) == Some(0) => {\n+                    // rust-lang/rust#62336: ignore type of contents\n+                    // for empty array.\n+                    return false;\n+                }\n+                _ => {\n+                    ty.super_visit_with(self);\n+                    return false;\n+                }\n+            };\n+\n+            if !self.tcx.has_attr(adt_def.did, sym::structural_match) {\n+                self.found = Some(&adt_def);\n+                debug!(\"Search found adt_def: {:?}\", adt_def);\n+                return true // Halt visiting!\n+            }\n+\n+            if self.seen.contains(adt_def) {\n+                debug!(\"Search already seen adt_def: {:?}\", adt_def);\n+                // let caller continue its search\n+                return false;\n+            }\n+\n+            self.seen.insert(adt_def);\n+\n+            // `#[structural_match]` does not care about the\n+            // instantiation of the generics in an ADT (it\n+            // instead looks directly at its fields outside\n+            // this match), so we skip super_visit_with.\n+            //\n+            // (Must not recur on substs for `PhantomData<T>` cf\n+            // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n+            // want to skip substs when only uses of generic are\n+            // behind unsafe pointers `*const T`/`*mut T`.)\n+\n+            // even though we skip super_visit_with, we must recur on\n+            // fields of ADT.\n+            let tcx = self.tcx;\n+            for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n+                if field_ty.visit_with(self) {\n+                    // found an ADT without `#[structural_match]`; halt visiting!\n+                    assert!(self.found.is_some());\n+                    return true;\n+                }\n+            }\n+\n+            // Even though we do not want to recur on substs, we do\n+            // want our caller to continue its own search.\n+            false\n+        }\n+    }\n+}\n+\n impl UserAnnotatedTyHelpers<'tcx> for PatternContext<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx"}, {"sha": "42c6f24b36a0cfc9f090bda87b7f82256d9a7208", "filename": "src/test/ui/issues/issue-55511.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Fissues%2Fissue-55511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Fissues%2Fissue-55511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55511.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -14,6 +14,8 @@ fn main() {\n     //~^ ERROR `a` does not live long enough [E0597]\n     match b {\n         <() as Foo<'static>>::C => { }\n+        //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARN will become a hard error in a future release\n         _ => { }\n     }\n }"}, {"sha": "c0f702e4fab2332dea4da5df735ec0d79a0c83d1", "filename": "src/test/ui/issues/issue-55511.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Fissues%2Fissue-55511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Fissues%2Fissue-55511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55511.stderr?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -1,3 +1,13 @@\n+warning: to use a constant of type `std::cell::Cell` in a pattern, `std::cell::Cell` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/issue-55511.rs:16:9\n+   |\n+LL |         <() as Foo<'static>>::C => { }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[warn(indirect_structural_match)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n error[E0597]: `a` does not live long enough\n   --> $DIR/issue-55511.rs:13:28\n    |"}, {"sha": "b90a750cc16c4f66ff4042d94b0dac81108bf2e1", "filename": "src/test/ui/rfc1445/allow-hide-behind-direct-unsafe-ptr-embedded.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-direct-unsafe-ptr-embedded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-direct-unsafe-ptr-embedded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-direct-unsafe-ptr-embedded.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,24 @@\n+// Test explores how `#[structral_match]` behaves in tandem with\n+// `*const` and `*mut` pointers.\n+\n+// run-pass\n+\n+struct NoDerive(i32);\n+\n+// This impl makes NoDerive irreflexive\n+// (which doesn't matter here because `<*const T>::eq` won't recur on `T`).\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+\n+impl Eq for NoDerive { }\n+\n+#[derive(PartialEq, Eq)]\n+struct WrapEmbedded(*const NoDerive);\n+\n+const WRAP_UNSAFE_EMBEDDED: WrapEmbedded = WrapEmbedded(std::ptr::null());\n+\n+fn main() {\n+    match WRAP_UNSAFE_EMBEDDED {\n+        WRAP_UNSAFE_EMBEDDED => { println!(\"WRAP_UNSAFE_EMBEDDED correctly matched itself\"); }\n+        _ => { panic!(\"WRAP_UNSAFE_EMBEDDED did not match itself\"); }\n+    }\n+}"}, {"sha": "1076b9f25d89aa95eb86b3ee73190ff3bc9c7932", "filename": "src/test/ui/rfc1445/allow-hide-behind-direct-unsafe-ptr-param.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-direct-unsafe-ptr-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-direct-unsafe-ptr-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-direct-unsafe-ptr-param.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,24 @@\n+// Test explores how `#[structral_match]` behaves in tandem with\n+// `*const` and `*mut` pointers.\n+\n+// run-pass\n+\n+struct NoDerive(i32);\n+\n+// This impl makes NoDerive irreflexive\n+// (which doesn't matter here because `<*const T>::eq` won't recur on `T`).\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+\n+impl Eq for NoDerive { }\n+\n+#[derive(PartialEq, Eq)]\n+struct WrapParam<X>(*const X);\n+\n+const WRAP_UNSAFE_PARAM: WrapParam<NoDerive> = WrapParam(std::ptr::null());\n+\n+fn main() {\n+    match WRAP_UNSAFE_PARAM {\n+        WRAP_UNSAFE_PARAM => { println!(\"WRAP_UNSAFE_PARAM correctly matched itself\"); }\n+        _ => { panic!(\"WRAP_UNSAFE_PARAM did not match itself\"); }\n+    }\n+}"}, {"sha": "a4b832d377d6f3249ae097a13dd1a1758de065f4", "filename": "src/test/ui/rfc1445/allow-hide-behind-indirect-unsafe-ptr-embedded.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-indirect-unsafe-ptr-embedded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-indirect-unsafe-ptr-embedded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-indirect-unsafe-ptr-embedded.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,24 @@\n+// Test explores how `#[structral_match]` behaves in tandem with\n+// `*const` and `*mut` pointers.\n+\n+// run-pass\n+\n+struct NoDerive(i32);\n+\n+// This impl makes NoDerive irreflexive\n+// (which doesn't matter here because `<*const T>::eq` won't recur on `T`).\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+\n+impl Eq for NoDerive { }\n+\n+#[derive(PartialEq, Eq)]\n+struct WrapEmbedded(*const NoDerive);\n+\n+const WRAP_UNSAFE_EMBEDDED: & &WrapEmbedded = & &WrapEmbedded(std::ptr::null());\n+\n+fn main() {\n+    match WRAP_UNSAFE_EMBEDDED {\n+        WRAP_UNSAFE_EMBEDDED => { println!(\"WRAP_UNSAFE_EMBEDDED correctly matched itself\"); }\n+        _ => { panic!(\"WRAP_UNSAFE_EMBEDDED did not match itself\"); }\n+    }\n+}"}, {"sha": "47b70e2e9cc56b6e7f5049241a0da93d7d867869", "filename": "src/test/ui/rfc1445/allow-hide-behind-indirect-unsafe-ptr-param.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-indirect-unsafe-ptr-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-indirect-unsafe-ptr-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-indirect-unsafe-ptr-param.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,24 @@\n+// Test explores how `#[structral_match]` behaves in tandem with\n+// `*const` and `*mut` pointers.\n+\n+// run-pass\n+\n+struct NoDerive(i32);\n+\n+// This impl makes NoDerive irreflexive\n+// (which doesn't matter here because `<*const T>::eq` won't recur on `T`).\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+\n+impl Eq for NoDerive { }\n+\n+#[derive(PartialEq, Eq)]\n+struct WrapParam<X>(*const X);\n+\n+const WRAP_UNSAFE_PARAM: & &WrapParam<NoDerive> = & &WrapParam(std::ptr::null());\n+\n+fn main() {\n+    match WRAP_UNSAFE_PARAM {\n+        WRAP_UNSAFE_PARAM => { println!(\"WRAP_UNSAFE_PARAM correctly matched itself\"); }\n+        _ => { panic!(\"WRAP_UNSAFE_PARAM did not match itself\"); }\n+    }\n+}"}, {"sha": "b8949ae8b500f3c25e42fada39b78ad2ee50a542", "filename": "src/test/ui/rfc1445/cant-hide-behind-direct-struct-embedded.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,26 @@\n+// This is part of a set of tests exploring the different ways a\n+// `#[structural_match]` ADT might try to hold a\n+// non-`#[structural_match]` in hidden manner that lets matches\n+// through that we had intended to reject.\n+//\n+// See discussion on rust-lang/rust#62307 and rust-lang/rust#62339\n+\n+struct NoDerive(i32);\n+\n+// This impl makes NoDerive irreflexive.\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+\n+impl Eq for NoDerive { }\n+\n+#[derive(PartialEq, Eq)]\n+struct WrapInline(NoDerive);\n+\n+const WRAP_DIRECT_INLINE: WrapInline = WrapInline(NoDerive(0));\n+\n+fn main() {\n+    match WRAP_DIRECT_INLINE {\n+        WRAP_DIRECT_INLINE => { panic!(\"WRAP_DIRECT_INLINE matched itself\"); }\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        _ => { println!(\"WRAP_DIRECT_INLINE did not match itself\"); }\n+    }\n+}"}, {"sha": "c73a6cf1326b3e3a7401deec42407cebeeb144f8", "filename": "src/test/ui/rfc1445/cant-hide-behind-direct-struct-embedded.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.stderr?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,8 @@\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/cant-hide-behind-direct-struct-embedded.rs:22:9\n+   |\n+LL |         WRAP_DIRECT_INLINE => { panic!(\"WRAP_DIRECT_INLINE matched itself\"); }\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "a3a615ea748cb6790c87507a702ed505d9a38c1a", "filename": "src/test/ui/rfc1445/cant-hide-behind-direct-struct-param.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,26 @@\n+// This is part of a set of tests exploring the different ways a\n+// `#[structural_match]` ADT might try to hold a\n+// non-`#[structural_match]` in hidden manner that lets matches\n+// through that we had intended to reject.\n+//\n+// See discussion on rust-lang/rust#62307 and rust-lang/rust#62339\n+\n+struct NoDerive(i32);\n+\n+// This impl makes NoDerive irreflexive.\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+\n+impl Eq for NoDerive { }\n+\n+#[derive(PartialEq, Eq)]\n+struct WrapParam<T>(T);\n+\n+const WRAP_DIRECT_PARAM: WrapParam<NoDerive> = WrapParam(NoDerive(0));\n+\n+fn main() {\n+    match WRAP_DIRECT_PARAM {\n+        WRAP_DIRECT_PARAM => { panic!(\"WRAP_DIRECT_PARAM matched itself\"); }\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        _ => { println!(\"WRAP_DIRECT_PARAM did not match itself\"); }\n+    }\n+}"}, {"sha": "6fdf9db89b8dc4a74c007e6089bbe434394a39eb", "filename": "src/test/ui/rfc1445/cant-hide-behind-direct-struct-param.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.stderr?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,8 @@\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/cant-hide-behind-direct-struct-param.rs:22:9\n+   |\n+LL |         WRAP_DIRECT_PARAM => { panic!(\"WRAP_DIRECT_PARAM matched itself\"); }\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "b6d9c52b298b638427e417e6b7743268b259a4e0", "filename": "src/test/ui/rfc1445/cant-hide-behind-doubly-indirect-embedded.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-embedded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-embedded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-embedded.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,29 @@\n+// This is part of a set of tests exploring the different ways a\n+// `#[structural_match]` ADT might try to hold a\n+// non-`#[structural_match]` in hidden manner that lets matches\n+// through that we had intended to reject.\n+//\n+// See discussion on rust-lang/rust#62307 and rust-lang/rust#62339\n+\n+// run-pass\n+\n+struct NoDerive(i32);\n+\n+// This impl makes NoDerive irreflexive.\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+\n+impl Eq for NoDerive { }\n+\n+#[derive(PartialEq, Eq)]\n+struct WrapInline<'a>(&'a &'a NoDerive);\n+\n+const WRAP_DOUBLY_INDIRECT_INLINE: & &WrapInline = & &WrapInline(& & NoDerive(0));\n+\n+fn main() {\n+    match WRAP_DOUBLY_INDIRECT_INLINE {\n+        WRAP_DOUBLY_INDIRECT_INLINE => { panic!(\"WRAP_DOUBLY_INDIRECT_INLINE matched itself\"); }\n+        //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARN will become a hard error in a future release\n+        _ => { println!(\"WRAP_DOUBLY_INDIRECT_INLINE correctly did not match itself\"); }\n+    }\n+}"}, {"sha": "3de63f43ecbb623945fd27c30712924eb83d79c3", "filename": "src/test/ui/rfc1445/cant-hide-behind-doubly-indirect-embedded.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-embedded.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-embedded.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-embedded.stderr?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,10 @@\n+warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/cant-hide-behind-doubly-indirect-embedded.rs:24:9\n+   |\n+LL |         WRAP_DOUBLY_INDIRECT_INLINE => { panic!(\"WRAP_DOUBLY_INDIRECT_INLINE matched itself\"); }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[warn(indirect_structural_match)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+"}, {"sha": "804d336b3ea610b7198cfba7db2fbafcb83dbaae", "filename": "src/test/ui/rfc1445/cant-hide-behind-doubly-indirect-param.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-param.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,29 @@\n+// This is part of a set of tests exploring the different ways a\n+// `#[structural_match]` ADT might try to hold a\n+// non-`#[structural_match]` in hidden manner that lets matches\n+// through that we had intended to reject.\n+//\n+// See discussion on rust-lang/rust#62307 and rust-lang/rust#62339\n+\n+// run-pass\n+\n+struct NoDerive(i32);\n+\n+// This impl makes NoDerive irreflexive.\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+\n+impl Eq for NoDerive { }\n+\n+#[derive(PartialEq, Eq)]\n+struct WrapParam<'a, T>(&'a &'a T);\n+\n+const WRAP_DOUBLY_INDIRECT_PARAM: & &WrapParam<NoDerive> = & &WrapParam(& & NoDerive(0));\n+\n+fn main() {\n+    match WRAP_DOUBLY_INDIRECT_PARAM {\n+        WRAP_DOUBLY_INDIRECT_PARAM => { panic!(\"WRAP_DOUBLY_INDIRECT_PARAM matched itself\"); }\n+        //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARN will become a hard error in a future release\n+        _ => { println!(\"WRAP_DOUBLY_INDIRECT_PARAM correctly did not match itself\"); }\n+    }\n+}"}, {"sha": "ee4652d15328310c20be473dffb6b9dfa5bf5975", "filename": "src/test/ui/rfc1445/cant-hide-behind-doubly-indirect-param.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-param.stderr?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,10 @@\n+warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/cant-hide-behind-doubly-indirect-param.rs:24:9\n+   |\n+LL |         WRAP_DOUBLY_INDIRECT_PARAM => { panic!(\"WRAP_DOUBLY_INDIRECT_PARAM matched itself\"); }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[warn(indirect_structural_match)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+"}, {"sha": "85d2e65a9a08068daca183296ba26bafaf675d14", "filename": "src/test/ui/rfc1445/cant-hide-behind-indirect-struct-embedded.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-embedded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-embedded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-embedded.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,29 @@\n+// This is part of a set of tests exploring the different ways a\n+// `#[structural_match]` ADT might try to hold a\n+// non-`#[structural_match]` in hidden manner that lets matches\n+// through that we had intended to reject.\n+//\n+// See discussion on rust-lang/rust#62307 and rust-lang/rust#62339\n+\n+// run-pass\n+\n+struct NoDerive(i32);\n+\n+// This impl makes NoDerive irreflexive.\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+\n+impl Eq for NoDerive { }\n+\n+#[derive(PartialEq, Eq)]\n+struct WrapInline(NoDerive);\n+\n+const WRAP_INDIRECT_INLINE: & &WrapInline = & &WrapInline(NoDerive(0));\n+\n+fn main() {\n+    match WRAP_INDIRECT_INLINE {\n+        WRAP_INDIRECT_INLINE => { panic!(\"WRAP_INDIRECT_INLINE matched itself\"); }\n+        //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARN will become a hard error in a future release\n+        _ => { println!(\"WRAP_INDIRECT_INLINE did not match itself\"); }\n+    }\n+}"}, {"sha": "eb7468499316f9690cd439761cc110b4ae92c43e", "filename": "src/test/ui/rfc1445/cant-hide-behind-indirect-struct-embedded.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-embedded.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-embedded.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-embedded.stderr?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,10 @@\n+warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/cant-hide-behind-indirect-struct-embedded.rs:24:9\n+   |\n+LL |         WRAP_INDIRECT_INLINE => { panic!(\"WRAP_INDIRECT_INLINE matched itself\"); }\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[warn(indirect_structural_match)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+"}, {"sha": "849aa1477669773e0191f946819e91f457afe23f", "filename": "src/test/ui/rfc1445/cant-hide-behind-indirect-struct-param.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-param.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,29 @@\n+// This is part of a set of tests exploring the different ways a\n+// `#[structural_match]` ADT might try to hold a\n+// non-`#[structural_match]` in hidden manner that lets matches\n+// through that we had intended to reject.\n+//\n+// See discussion on rust-lang/rust#62307 and rust-lang/rust#62339\n+\n+// run-pass\n+\n+struct NoDerive(i32);\n+\n+// This impl makes NoDerive irreflexive.\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+\n+impl Eq for NoDerive { }\n+\n+#[derive(PartialEq, Eq)]\n+struct WrapParam<T>(T);\n+\n+const WRAP_INDIRECT_PARAM: & &WrapParam<NoDerive> = & &WrapParam(NoDerive(0));\n+\n+fn main() {\n+    match WRAP_INDIRECT_PARAM {\n+        WRAP_INDIRECT_PARAM => { panic!(\"WRAP_INDIRECT_PARAM matched itself\"); }\n+        //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARN will become a hard error in a future release\n+        _ => { println!(\"WRAP_INDIRECT_PARAM correctly did not match itself\"); }\n+    }\n+}"}, {"sha": "8a16556844454906bb3de9391b2fdc9b1f7de037", "filename": "src/test/ui/rfc1445/cant-hide-behind-indirect-struct-param.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-param.stderr?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,10 @@\n+warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/cant-hide-behind-indirect-struct-param.rs:24:9\n+   |\n+LL |         WRAP_INDIRECT_PARAM => { panic!(\"WRAP_INDIRECT_PARAM matched itself\"); }\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[warn(indirect_structural_match)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+"}, {"sha": "9a96628cac69077ec71a754999b74f2bb224bfbf", "filename": "src/test/ui/rfc1445/issue-61118-match-slice-forbidden-without-eq.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fissue-61118-match-slice-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fissue-61118-match-slice-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-61118-match-slice-forbidden-without-eq.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,19 @@\n+// Issue 61118 pointed out a case where we hit an ICE during code gen:\n+// the compiler assumed that `PartialEq` was always implemented on any\n+// use of a `const` item in a pattern context, but the pre-existing\n+// checking for the presence of `#[structural_match]` was too shallow\n+// (see rust-lang/rust#62307), and so we hit cases where we were\n+// trying to dispatch to `PartialEq` on types that did not implement\n+// that trait.\n+\n+struct B(i32);\n+\n+const A: &[B] = &[];\n+\n+pub fn main() {\n+    match &[][..] {\n+        A => (),\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        _ => (),\n+    }\n+}"}, {"sha": "e8141f6108c5e1904b7a5e7a14add808d35bac4d", "filename": "src/test/ui/rfc1445/issue-61118-match-slice-forbidden-without-eq.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fissue-61118-match-slice-forbidden-without-eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fissue-61118-match-slice-forbidden-without-eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-61118-match-slice-forbidden-without-eq.stderr?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,8 @@\n+error: to use a constant of type `B` in a pattern, `B` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/issue-61118-match-slice-forbidden-without-eq.rs:15:9\n+   |\n+LL |         A => (),\n+   |         ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "7646f7558a396f222973c52f7491930024472ca2", "filename": "src/test/ui/rfc1445/issue-62307-match-ref-ref-forbidden-without-eq.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,43 @@\n+// RFC 1445 introduced `#[structural_match]`; this attribute must\n+// appear on the `struct`/`enum` definition for any `const` used in a\n+// pattern.\n+//\n+// This is our (forever-unstable) way to mark a datatype as having a\n+// `PartialEq` implementation that is equivalent to recursion over its\n+// substructure. This avoids (at least in the short term) any need to\n+// resolve the question of what semantics is used for such matching.\n+// (See RFC 1445 for more details and discussion.)\n+\n+// Issue 62307 pointed out a case where the checking for\n+// `#[structural_match]` was too shallow.\n+\n+// run-pass\n+\n+#[derive(Debug)]\n+struct B(i32);\n+\n+// Overriding `PartialEq` to use this strange notion of \"equality\" exposes\n+// whether `match` is using structural-equality or method-dispatch\n+// under the hood, which is the antithesis of rust-lang/rfcs#1445\n+impl PartialEq for B {\n+    fn eq(&self, other: &B) -> bool { std::cmp::min(self.0, other.0) == 0 }\n+}\n+\n+fn main() {\n+    const RR_B0: & & B = & & B(0);\n+    const RR_B1: & & B = & & B(1);\n+\n+    match RR_B0 {\n+        RR_B1 => { println!(\"CLAIM RR0: {:?} matches {:?}\", RR_B1, RR_B0); }\n+        //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARN will become a hard error in a future release\n+        _ => { }\n+    }\n+\n+    match RR_B1 {\n+        RR_B1 => { println!(\"CLAIM RR1: {:?} matches {:?}\", RR_B1, RR_B1); }\n+        //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARN will become a hard error in a future release\n+        _ => { }\n+    }\n+}"}, {"sha": "ba0275f5f9f936e67ed86e31ad95b255ffd69fa2", "filename": "src/test/ui/rfc1445/issue-62307-match-ref-ref-forbidden-without-eq.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.stderr?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,19 @@\n+warning: to use a constant of type `B` in a pattern, `B` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/issue-62307-match-ref-ref-forbidden-without-eq.rs:31:9\n+   |\n+LL |         RR_B1 => { println!(\"CLAIM RR0: {:?} matches {:?}\", RR_B1, RR_B0); }\n+   |         ^^^^^\n+   |\n+   = note: #[warn(indirect_structural_match)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n+warning: to use a constant of type `B` in a pattern, `B` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/issue-62307-match-ref-ref-forbidden-without-eq.rs:38:9\n+   |\n+LL |         RR_B1 => { println!(\"CLAIM RR1: {:?} matches {:?}\", RR_B1, RR_B1); }\n+   |         ^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+"}, {"sha": "7ba0f3a9e8dd959df1bdd7a4fef29d23d0a7e6d1", "filename": "src/test/ui/rfc1445/match-empty-array-allowed-without-eq-issue-62336.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fmatch-empty-array-allowed-without-eq-issue-62336.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fmatch-empty-array-allowed-without-eq-issue-62336.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fmatch-empty-array-allowed-without-eq-issue-62336.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,17 @@\n+// Pre-existing behavior has been to reject patterns with consts\n+// denoting non-empty arrays of non-`Eq` types, but *accept* empty\n+// arrays of such types.\n+//\n+// See rust-lang/rust#62336.\n+\n+// run-pass\n+\n+#[derive(PartialEq, Debug)]\n+struct B(i32);\n+\n+fn main() {\n+    const FOO: [B; 0] = [];\n+    match [] {\n+        FOO => { }\n+    }\n+}"}, {"sha": "3d56fb05dc460ab3214b82424617ffc20fe4c94d", "filename": "src/test/ui/rfc1445/match-nonempty-array-forbidden-without-eq.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.rs?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,19 @@\n+// Issue 62307 pointed out a case where the checking for\n+// `#[structural_match]` was too shallow.\n+//\n+// Here we check similar behavior for non-empty arrays of types that\n+// do not derive `Eq`.\n+//\n+// (Current behavior for empty arrays differs and thus is not tested\n+// here; see rust-lang/rust#62336.)\n+\n+#[derive(PartialEq, Debug)]\n+struct B(i32);\n+\n+fn main() {\n+    const FOO: [B; 1] = [B(0)];\n+    match [B(1)] {\n+        FOO => { }\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    }\n+}"}, {"sha": "371f8a0aa1d7745e6e47ed08873335bbe4a1d9ed", "filename": "src/test/ui/rfc1445/match-nonempty-array-forbidden-without-eq.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6a9e766f90a5271c2356fbc7941e38559200ab5/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.stderr?ref=c6a9e766f90a5271c2356fbc7941e38559200ab5", "patch": "@@ -0,0 +1,8 @@\n+error: to use a constant of type `B` in a pattern, `B` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/match-nonempty-array-forbidden-without-eq.rs:16:9\n+   |\n+LL |         FOO => { }\n+   |         ^^^\n+\n+error: aborting due to previous error\n+"}]}