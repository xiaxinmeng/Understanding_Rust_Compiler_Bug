{"sha": "f35abae89281cd54073c7caefd1e7d55123e8b6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNWFiYWU4OTI4MWNkNTQwNzNjN2NhZWZkMWU3ZDU1MTIzZThiNmQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-31T20:18:46Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-31T20:19:00Z"}, "message": "std: getopts::match -> matches", "tree": {"sha": "7f8ef44a25d206d492256e21f7e1f4e8a3e13a69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f8ef44a25d206d492256e21f7e1f4e8a3e13a69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f35abae89281cd54073c7caefd1e7d55123e8b6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f35abae89281cd54073c7caefd1e7d55123e8b6d", "html_url": "https://github.com/rust-lang/rust/commit/f35abae89281cd54073c7caefd1e7d55123e8b6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f35abae89281cd54073c7caefd1e7d55123e8b6d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bf1943126a7174a9a02b5ea24cfc59eab3ec9f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bf1943126a7174a9a02b5ea24cfc59eab3ec9f7", "html_url": "https://github.com/rust-lang/rust/commit/0bf1943126a7174a9a02b5ea24cfc59eab3ec9f7"}], "stats": {"total": 70, "additions": 35, "deletions": 35}, "files": [{"sha": "86a75e653d8c3bb126f5b4f715212d98b85d8a03", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f35abae89281cd54073c7caefd1e7d55123e8b6d/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35abae89281cd54073c7caefd1e7d55123e8b6d/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=f35abae89281cd54073c7caefd1e7d55123e8b6d", "patch": "@@ -6,7 +6,7 @@\n  * along with a vector of actual arguments (not including argv[0]). You'll\n  * either get a failure code back, or a match. You'll have to verify whether\n  * the amount of 'free' arguments in the match is what you expect. Use opt_*\n- * accessors to get argument values out of the match object.\n+ * accessors to get argument values out of the matches object.\n  *\n  * Single-character options are expected to appear on the command line with a\n  * single preceding dash; multiple-character options are expected to be\n@@ -43,17 +43,17 @@\n  *             optflag(\"h\"),\n  *             optflag(\"help\")\n  *         ];\n- *         let match = alt getopts(vec::tail(args), opts) {\n+ *         let matches = alt getopts(vec::tail(args), opts) {\n  *             result::ok(m) { m }\n  *             result::err(f) { fail fail_str(f) }\n  *         };\n- *         if opt_present(match, \"h\") || opt_present(match, \"help\") {\n+ *         if opt_present(matches, \"h\") || opt_present(matches, \"help\") {\n  *             print_usage(program);\n  *             ret;\n  *         }\n- *         let output = opt_maybe_str(match, \"o\");\n- *         let input = if vec::is_not_empty(match.free) {\n- *             match.free[0]\n+ *         let output = opt_maybe_str(matches, \"o\");\n+ *         let input = if vec::is_not_empty(matches.free) {\n+ *             matches.free[0]\n  *         } else {\n  *             print_usage(program);\n  *             ret;\n@@ -72,7 +72,7 @@ export optflag;\n export optflagopt;\n export optmulti;\n export getopts;\n-export match;\n+export matches;\n export fail_;\n export fail_str;\n export opt_present;\n@@ -133,7 +133,7 @@ enum optval { val(~str), given, }\n  * The result of checking command line arguments. Contains a vector\n  * of matches and a vector of free strings.\n  */\n-type match = {opts: ~[opt], vals: ~[~[optval]], free: ~[~str]};\n+type matches = {opts: ~[opt], vals: ~[~[optval]], free: ~[~str]};\n \n fn is_arg(arg: ~str) -> bool {\n     ret str::len(arg) > 1u && arg[0] == '-' as u8;\n@@ -178,9 +178,9 @@ fn fail_str(f: fail_) -> ~str {\n \n /**\n  * The result of parsing a command line with a set of options\n- * (result::t<match, fail_>)\n+ * (result::t<matches, fail_>)\n  */\n-type result = result::result<match, fail_>;\n+type result = result::result<matches, fail_>;\n \n /**\n  * Parse command line arguments according to the provided options\n@@ -311,22 +311,22 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n     ret ok({opts: opts, vals: vec::from_mut(vals), free: free});\n }\n \n-fn opt_vals(m: match, nm: ~str) -> ~[optval] {\n+fn opt_vals(m: matches, nm: ~str) -> ~[optval] {\n     ret alt find_opt(m.opts, mkname(nm)) {\n           some(id) { m.vals[id] }\n           none { error!{\"No option '%s' defined\", nm}; fail }\n         };\n }\n \n-fn opt_val(m: match, nm: ~str) -> optval { ret opt_vals(m, nm)[0]; }\n+fn opt_val(m: matches, nm: ~str) -> optval { ret opt_vals(m, nm)[0]; }\n \n /// Returns true if an option was matched\n-fn opt_present(m: match, nm: ~str) -> bool {\n+fn opt_present(m: matches, nm: ~str) -> bool {\n     ret vec::len::<optval>(opt_vals(m, nm)) > 0u;\n }\n \n /// Returns true if any of several options were matched\n-fn opts_present(m: match, names: ~[~str]) -> bool {\n+fn opts_present(m: matches, names: ~[~str]) -> bool {\n     for vec::each(names) |nm| {\n         alt find_opt(m.opts, mkname(nm)) {\n           some(_) { ret true; }\n@@ -343,7 +343,7 @@ fn opts_present(m: match, names: ~[~str]) -> bool {\n  * Fails if the option was not matched or if the match did not take an\n  * argument\n  */\n-fn opt_str(m: match, nm: ~str) -> ~str {\n+fn opt_str(m: matches, nm: ~str) -> ~str {\n     ret alt opt_val(m, nm) { val(s) { s } _ { fail } };\n }\n \n@@ -353,7 +353,7 @@ fn opt_str(m: match, nm: ~str) -> ~str {\n  * Fails if the no option was provided from the given list, or if the no such\n  * option took an argument\n  */\n-fn opts_str(m: match, names: ~[~str]) -> ~str {\n+fn opts_str(m: matches, names: ~[~str]) -> ~str {\n     for vec::each(names) |nm| {\n         alt opt_val(m, nm) {\n           val(s) { ret s }\n@@ -370,7 +370,7 @@ fn opts_str(m: match, names: ~[~str]) -> ~str {\n  *\n  * Used when an option accepts multiple values.\n  */\n-fn opt_strs(m: match, nm: ~str) -> ~[~str] {\n+fn opt_strs(m: matches, nm: ~str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n     for vec::each(opt_vals(m, nm)) |v| {\n         alt v { val(s) { vec::push(acc, s); } _ { } }\n@@ -379,7 +379,7 @@ fn opt_strs(m: match, nm: ~str) -> ~[~str] {\n }\n \n /// Returns the string argument supplied to a matching option or none\n-fn opt_maybe_str(m: match, nm: ~str) -> option<~str> {\n+fn opt_maybe_str(m: matches, nm: ~str) -> option<~str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { ret none::<~str>; }\n     ret alt vals[0] { val(s) { some::<~str>(s) } _ { none::<~str> } };\n@@ -393,7 +393,7 @@ fn opt_maybe_str(m: match, nm: ~str) -> option<~str> {\n  * present but no argument was provided, and the argument if the option was\n  * present and an argument was provided.\n  */\n-fn opt_default(m: match, nm: ~str, def: ~str) -> option<~str> {\n+fn opt_default(m: matches, nm: ~str, def: ~str) -> option<~str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { ret none::<~str>; }\n     ret alt vals[0] { val(s) { some::<~str>(s) } _ { some::<~str>(def) } }\n@@ -872,33 +872,33 @@ mod tests {\n     fn test_multi() {\n         let args = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n         let opts = ~[optopt(~\"e\"), optopt(~\"encrypt\")];\n-        let match = alt getopts(args, opts) {\n+        let matches = alt getopts(args, opts) {\n           result::ok(m) { m }\n           result::err(f) { fail; }\n         };\n-        assert opts_present(match, ~[~\"e\"]);\n-        assert opts_present(match, ~[~\"encrypt\"]);\n-        assert opts_present(match, ~[~\"encrypt\", ~\"e\"]);\n-        assert opts_present(match, ~[~\"e\", ~\"encrypt\"]);\n-        assert !opts_present(match, ~[~\"thing\"]);\n-        assert !opts_present(match, ~[]);\n+        assert opts_present(matches, ~[~\"e\"]);\n+        assert opts_present(matches, ~[~\"encrypt\"]);\n+        assert opts_present(matches, ~[~\"encrypt\", ~\"e\"]);\n+        assert opts_present(matches, ~[~\"e\", ~\"encrypt\"]);\n+        assert !opts_present(matches, ~[~\"thing\"]);\n+        assert !opts_present(matches, ~[]);\n \n-        assert opts_str(match, ~[~\"e\"]) == ~\"foo\";\n-        assert opts_str(match, ~[~\"encrypt\"]) == ~\"foo\";\n-        assert opts_str(match, ~[~\"e\", ~\"encrypt\"]) == ~\"foo\";\n-        assert opts_str(match, ~[~\"encrypt\", ~\"e\"]) == ~\"foo\";\n+        assert opts_str(matches, ~[~\"e\"]) == ~\"foo\";\n+        assert opts_str(matches, ~[~\"encrypt\"]) == ~\"foo\";\n+        assert opts_str(matches, ~[~\"e\", ~\"encrypt\"]) == ~\"foo\";\n+        assert opts_str(matches, ~[~\"encrypt\", ~\"e\"]) == ~\"foo\";\n     }\n \n     #[test]\n     fn test_nospace() {\n         let args = ~[~\"-Lfoo\"];\n         let opts = ~[optmulti(~\"L\")];\n-        let match = alt getopts(args, opts) {\n+        let matches = alt getopts(args, opts) {\n           result::ok(m) { m }\n           result::err(f) { fail; }\n         };\n-        assert opts_present(match, ~[~\"L\"]);\n-        assert opts_str(match, ~[~\"L\"]) == ~\"foo\";\n+        assert opts_present(matches, ~[~\"L\"]);\n+        assert opts_str(matches, ~[~\"L\"]) == ~\"foo\";\n     }\n }\n "}, {"sha": "cdfa473c32fad49dedbb43c832a627659a041b9d", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f35abae89281cd54073c7caefd1e7d55123e8b6d/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35abae89281cd54073c7caefd1e7d55123e8b6d/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=f35abae89281cd54073c7caefd1e7d55123e8b6d", "patch": "@@ -408,7 +408,7 @@ fn host_triple() -> ~str {\n         };\n }\n \n-fn build_session_options(match: getopts::match,\n+fn build_session_options(match: getopts::matches,\n                          demitter: diagnostic::emitter) -> @session::options {\n     let crate_type = if opt_present(match, ~\"lib\") {\n         session::lib_crate"}, {"sha": "ebb21c4c7cf0c7905b34e0b032ea9173e93c05da", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f35abae89281cd54073c7caefd1e7d55123e8b6d/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35abae89281cd54073c7caefd1e7d55123e8b6d/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=f35abae89281cd54073c7caefd1e7d55123e8b6d", "patch": "@@ -119,7 +119,7 @@ fn parse_config_(\n \n fn config_from_opts(\n     input_crate: ~str,\n-    match: getopts::match,\n+    match: getopts::matches,\n     program_output: program_output\n ) -> result<config, ~str> {\n "}]}