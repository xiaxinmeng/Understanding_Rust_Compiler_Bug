{"sha": "a5657dbc43d84133bd95e5de178d68634973b1b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NjU3ZGJjNDNkODQxMzNiZDk1ZTVkZTE3OGQ2ODYzNDk3M2IxYjM=", "commit": {"author": {"name": "Markus Westerlind", "email": "markus.westerlind@imperva.com", "date": "2020-01-08T22:13:56Z"}, "committer": {"name": "Markus Westerlind", "email": "markus.westerlind@imperva.com", "date": "2020-01-08T22:20:19Z"}, "message": "perf: Avoid creating a SmallVec if nothing changes during a fold\n\nNot sure if this helps but in theory it should be less work than what\nthe current micro optimization does for `ty::Predicate` lists.\n\n(It would explain the overhead I am seeing from `perf`.)", "tree": {"sha": "cf9ea54d17d6109b06d9518a8944c38fd261c104", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf9ea54d17d6109b06d9518a8944c38fd261c104"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5657dbc43d84133bd95e5de178d68634973b1b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5657dbc43d84133bd95e5de178d68634973b1b3", "html_url": "https://github.com/rust-lang/rust/commit/a5657dbc43d84133bd95e5de178d68634973b1b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5657dbc43d84133bd95e5de178d68634973b1b3/comments", "author": {"login": "Marwes", "id": 957312, "node_id": "MDQ6VXNlcjk1NzMxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/957312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Marwes", "html_url": "https://github.com/Marwes", "followers_url": "https://api.github.com/users/Marwes/followers", "following_url": "https://api.github.com/users/Marwes/following{/other_user}", "gists_url": "https://api.github.com/users/Marwes/gists{/gist_id}", "starred_url": "https://api.github.com/users/Marwes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Marwes/subscriptions", "organizations_url": "https://api.github.com/users/Marwes/orgs", "repos_url": "https://api.github.com/users/Marwes/repos", "events_url": "https://api.github.com/users/Marwes/events{/privacy}", "received_events_url": "https://api.github.com/users/Marwes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Marwes", "id": 957312, "node_id": "MDQ6VXNlcjk1NzMxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/957312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Marwes", "html_url": "https://github.com/Marwes", "followers_url": "https://api.github.com/users/Marwes/followers", "following_url": "https://api.github.com/users/Marwes/following{/other_user}", "gists_url": "https://api.github.com/users/Marwes/gists{/gist_id}", "starred_url": "https://api.github.com/users/Marwes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Marwes/subscriptions", "organizations_url": "https://api.github.com/users/Marwes/orgs", "repos_url": "https://api.github.com/users/Marwes/repos", "events_url": "https://api.github.com/users/Marwes/events{/privacy}", "received_events_url": "https://api.github.com/users/Marwes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f48e576756cd0c360e5522974fc8d5867b439092", "url": "https://api.github.com/repos/rust-lang/rust/commits/f48e576756cd0c360e5522974fc8d5867b439092", "html_url": "https://github.com/rust-lang/rust/commit/f48e576756cd0c360e5522974fc8d5867b439092"}], "stats": {"total": 47, "additions": 30, "deletions": 17}, "files": [{"sha": "385c8eeb4b83c5230be1b2da68797ec212f42417", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a5657dbc43d84133bd95e5de178d68634973b1b3/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5657dbc43d84133bd95e5de178d68634973b1b3/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=a5657dbc43d84133bd95e5de178d68634973b1b3", "patch": "@@ -803,8 +803,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|p| p.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-        folder.tcx().intern_existential_predicates(&v)\n+        fold_list(*self, folder, |tcx, v| tcx.intern_existential_predicates(v))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n@@ -814,8 +813,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>>\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-        folder.tcx().intern_type_list(&v)\n+        fold_list(*self, folder, |tcx, v| tcx.intern_type_list(v))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n@@ -825,8 +823,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-        folder.tcx().intern_projs(&v)\n+        fold_list(*self, folder, |tcx, v| tcx.intern_projs(v))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n@@ -990,17 +987,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        // This code is hot enough that it's worth specializing for a list of\n-        // length 0. (No other length is common enough to be worth singling\n-        // out).\n-        if self.len() == 0 {\n-            self\n-        } else {\n-            // Don't bother interning if nothing changed, which is the common\n-            // case.\n-            let v = self.iter().map(|p| p.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-            if v[..] == self[..] { self } else { folder.tcx().intern_predicates(&v) }\n-        }\n+        fold_list(*self, folder, |tcx, v| tcx.intern_predicates(v))\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n@@ -1073,3 +1060,29 @@ impl<'tcx> TypeFoldable<'tcx> for InferConst<'tcx> {\n         false\n     }\n }\n+\n+fn fold_list<'tcx, F, T>(\n+    list: &'tcx ty::List<T>,\n+    folder: &mut F,\n+    intern: impl FnOnce(TyCtxt<'tcx>, &[T]) -> &'tcx ty::List<T>,\n+) -> &'tcx ty::List<T>\n+where\n+    F: TypeFolder<'tcx>,\n+    T: TypeFoldable<'tcx> + PartialEq + Copy,\n+{\n+    let mut iter = list.iter();\n+    // Look for the first element that changed\n+    if let Some((i, new_t)) = iter.by_ref().enumerate().find_map(|(i, t)| {\n+        let new_t = t.fold_with(folder);\n+        if new_t == *t { None } else { Some((i, new_t)) }\n+    }) {\n+        // An element changed, prepare to intern the resulting list\n+        let mut new_list = SmallVec::<[_; 8]>::with_capacity(list.len());\n+        new_list.copy_from_slice(&list[..i]);\n+        new_list.push(new_t);\n+        new_list.extend(iter.map(|t| t.fold_with(folder)));\n+        intern(folder.tcx(), &new_list)\n+    } else {\n+        list\n+    }\n+}"}]}