{"sha": "0807ad19ef0b7e1d56b040f79a3192c4229c2224", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MDdhZDE5ZWYwYjdlMWQ1NmIwNDBmNzlhMzE5MmM0MjI5YzIyMjQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-15T18:22:28Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-22T07:06:28Z"}, "message": "fix union field access and DST computations and dumping of places", "tree": {"sha": "fd296db6deabbf48ffd90b056549ee9e4b57b759", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd296db6deabbf48ffd90b056549ee9e4b57b759"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0807ad19ef0b7e1d56b040f79a3192c4229c2224", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0807ad19ef0b7e1d56b040f79a3192c4229c2224", "html_url": "https://github.com/rust-lang/rust/commit/0807ad19ef0b7e1d56b040f79a3192c4229c2224", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0807ad19ef0b7e1d56b040f79a3192c4229c2224/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "689c71193ac2bac0366c917f38f3a553f12ff895", "url": "https://api.github.com/repos/rust-lang/rust/commits/689c71193ac2bac0366c917f38f3a553f12ff895", "html_url": "https://github.com/rust-lang/rust/commit/689c71193ac2bac0366c917f38f3a553f12ff895"}], "stats": {"total": 60, "additions": 33, "deletions": 27}, "files": [{"sha": "06e015cc4e6842bad7dc032486a075def075509e", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0807ad19ef0b7e1d56b040f79a3192c4229c2224/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0807ad19ef0b7e1d56b040f79a3192c4229c2224/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=0807ad19ef0b7e1d56b040f79a3192c4229c2224", "patch": "@@ -465,36 +465,38 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     /// Return the size and alignment of the value at the given type.\n     /// Note that the value does not matter if the type is sized. For unsized types,\n     /// the value has to be a fat pointer, and we only care about the \"extra\" data in it.\n-    pub fn size_and_align_of_dst(\n+    pub fn size_and_align_of_val(\n         &self,\n         val: ValTy<'tcx>,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n-        if !val.layout.is_unsized() {\n-            Ok(val.layout.size_and_align())\n+        let pointee_ty = val.layout.ty.builtin_deref(true).unwrap().ty;\n+        let layout = self.layout_of(pointee_ty)?;\n+        if !layout.is_unsized() {\n+            Ok(layout.size_and_align())\n         } else {\n-            match val.layout.ty.sty {\n+            match layout.ty.sty {\n                 ty::TyAdt(..) | ty::TyTuple(..) => {\n                     // First get the size of all statically known fields.\n                     // Don't use type_of::sizing_type_of because that expects t to be sized,\n                     // and it also rounds up to alignment, which we want to avoid,\n                     // as the unsized field's alignment could be smaller.\n-                    assert!(!val.layout.ty.is_simd());\n-                    debug!(\"DST layout: {:?}\", val.layout);\n+                    assert!(!layout.ty.is_simd());\n+                    debug!(\"DST layout: {:?}\", layout);\n \n-                    let sized_size = val.layout.fields.offset(val.layout.fields.count() - 1);\n-                    let sized_align = val.layout.align;\n+                    let sized_size = layout.fields.offset(layout.fields.count() - 1);\n+                    let sized_align = layout.align;\n                     debug!(\n                         \"DST {} statically sized prefix size: {:?} align: {:?}\",\n-                        val.layout.ty,\n+                        layout.ty,\n                         sized_size,\n                         sized_align\n                     );\n \n                     // Recurse to get the size of the dynamically sized field (must be\n                     // the last field).\n-                    let field_layout = val.layout.field(self, val.layout.fields.count() - 1)?;\n+                    let field_layout = layout.field(self, layout.fields.count() - 1)?;\n                     let (unsized_size, unsized_align) =\n-                        self.size_and_align_of_dst(ValTy {\n+                        self.size_and_align_of_val(ValTy {\n                             value: val.value,\n                             layout: field_layout\n                         })?;\n@@ -533,12 +535,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 }\n \n                 ty::TySlice(_) | ty::TyStr => {\n-                    let (elem_size, align) = val.layout.field(self, 0)?.size_and_align();\n+                    let (elem_size, align) = layout.field(self, 0)?.size_and_align();\n                     let (_, len) = val.to_scalar_slice(self)?;\n                     Ok((elem_size * len, align))\n                 }\n \n-                _ => bug!(\"size_of_val::<{:?}>\", val.layout.ty),\n+                _ => bug!(\"size_of_val::<{:?}>\", layout.ty),\n             }\n         }\n     }\n@@ -963,10 +965,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 self.memory.dump_allocs(allocs);\n             }\n             Place::Ptr(mplace) => {\n-                let (ptr, align) = mplace.to_scalar_ptr_align();\n-                match ptr {\n+                match mplace.ptr {\n                     Scalar::Ptr(ptr) => {\n-                        trace!(\"by align({}) ref:\", align.abi());\n+                        trace!(\"by align({}) ref:\", mplace.align.abi());\n                         self.memory.dump_alloc(ptr.alloc_id);\n                     }\n                     ptr => trace!(\" integral by ref: {:?}\", ptr),"}, {"sha": "a9b85f318dce40f41759b03a4c344d4c765239fd", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0807ad19ef0b7e1d56b040f79a3192c4229c2224/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0807ad19ef0b7e1d56b040f79a3192c4229c2224/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=0807ad19ef0b7e1d56b040f79a3192c4229c2224", "patch": "@@ -7,7 +7,7 @@ use std::convert::TryFrom;\n \n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Align, LayoutOf, TyLayout, HasDataLayout};\n+use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n use rustc::mir::interpret::{\n@@ -275,22 +275,27 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 assert!(field < len, \"Tried to access element {} of array/slice with length {}\", field, len);\n                 stride * field\n             }\n-            _ => bug!(\"Unexpected layout for field access: {:#?}\", base.layout),\n+            layout::FieldPlacement::Union(count) => {\n+                assert!(field < count as u64, \"Tried to access field {} of union with {} fields\", field, count);\n+                // Offset is always 0\n+                Size::from_bytes(0)\n+            }\n         };\n         // the only way conversion can fail if is this is an array (otherwise we already panicked\n         // above). In that case, all fields are equal.\n         let field = base.layout.field(self, usize::try_from(field).unwrap_or(0))?;\n \n         // Adjust offset\n-        let offset = match base.extra {\n-            PlaceExtra::Vtable(tab) => {\n-                let (_, align) = self.size_and_align_of_dst(ValTy {\n-                    layout: base.layout,\n-                    value: Value::new_dyn_trait(base.ptr, tab),\n-                })?;\n-                offset.abi_align(align)\n-            }\n-            _ => offset,\n+        let offset = if field.is_unsized() {\n+            let vtable = match base.extra {\n+                PlaceExtra::Vtable(tab) => tab,\n+                _ => bug!(\"Unsized place with unsized field must come with vtable\"),\n+            };\n+            let (_, align) = self.read_size_and_align_from_vtable(vtable)?;\n+            offset.abi_align(align)\n+        } else {\n+            // No adjustment needed\n+            offset\n         };\n \n         let ptr = base.ptr.ptr_offset(offset, self)?;"}]}