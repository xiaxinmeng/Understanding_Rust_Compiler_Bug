{"sha": "6f682236c96f7f304ffda201ef80824765a50bd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNjgyMjM2Yzk2ZjdmMzA0ZmZkYTIwMWVmODA4MjQ3NjVhNTBiZDg=", "commit": {"author": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-07-31T14:46:23Z"}, "committer": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-08-02T17:09:37Z"}, "message": "Implement pointer casting.", "tree": {"sha": "5201a9afc0847bb2ebd9557acb1b2964bd02cd19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5201a9afc0847bb2ebd9557acb1b2964bd02cd19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f682236c96f7f304ffda201ef80824765a50bd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f682236c96f7f304ffda201ef80824765a50bd8", "html_url": "https://github.com/rust-lang/rust/commit/6f682236c96f7f304ffda201ef80824765a50bd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f682236c96f7f304ffda201ef80824765a50bd8/comments", "author": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7c3c45d685403e090d84956da9e4d1a82ca6666", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7c3c45d685403e090d84956da9e4d1a82ca6666", "html_url": "https://github.com/rust-lang/rust/commit/d7c3c45d685403e090d84956da9e4d1a82ca6666"}], "stats": {"total": 65, "additions": 49, "deletions": 16}, "files": [{"sha": "d594731b4dfce5870bc9358d0a5edf466f64fe60", "filename": "src/unsize.rs", "status": "modified", "additions": 48, "deletions": 15, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6f682236c96f7f304ffda201ef80824765a50bd8/src%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f682236c96f7f304ffda201ef80824765a50bd8/src%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsize.rs?ref=6f682236c96f7f304ffda201ef80824765a50bd8", "patch": "@@ -25,39 +25,73 @@ pub(crate) fn unsized_info<'tcx>(\n             .bcx\n             .ins()\n             .iconst(fx.pointer_type, len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64),\n-        (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n-            // For now, upcasts are limited to changes in marker\n-            // traits, and hence never actually require an actual\n-            // change to the vtable.\n-            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n+        (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+            let old_info =\n+                old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n+            if data_a.principal_def_id() == data_b.principal_def_id() {\n+                return old_info;\n+            }\n+            // trait upcasting coercion\n+\n+            // if both of the two `principal`s are `None`, this function would have returned early above.\n+            // and if one of the two `principal`s is `None`, typechecking would have rejected this case.\n+            let principal_a = data_a\n+                .principal()\n+                .expect(\"unsized_info: missing principal trait for trait upcasting coercion\");\n+            let principal_b = data_b\n+                .principal()\n+                .expect(\"unsized_info: missing principal trait for trait upcasting coercion\");\n+\n+            let vptr_entry_idx = fx.tcx.vtable_trait_upcasting_coercion_new_vptr_slot((\n+                principal_a.with_self_ty(fx.tcx, source),\n+                principal_b.with_self_ty(fx.tcx, source),\n+            ));\n+\n+            if let Some(entry_idx) = vptr_entry_idx {\n+                let entry_idx = u32::try_from(entry_idx).unwrap();\n+                let entry_offset = entry_idx * fx.pointer_type.bytes();\n+                let vptr_ptr = Pointer::new(old_info).offset_i64(fx, entry_offset.into()).load(\n+                    fx,\n+                    fx.pointer_type,\n+                    crate::vtable::vtable_memflags(),\n+                );\n+                vptr_ptr\n+            } else {\n+                old_info\n+            }\n         }\n         (_, &ty::Dynamic(ref data, ..)) => crate::vtable::get_vtable(fx, source, data.principal()),\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }\n \n-/// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n-fn unsize_thin_ptr<'tcx>(\n+/// Coerce `src` to `dst_ty`.\n+fn unsize_ptr<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     src: Value,\n     src_layout: TyAndLayout<'tcx>,\n     dst_layout: TyAndLayout<'tcx>,\n+    old_info: Option<Value>,\n ) -> (Value, Value) {\n     match (&src_layout.ty.kind(), &dst_layout.ty.kind()) {\n         (&ty::Ref(_, a, _), &ty::Ref(_, b, _))\n         | (&ty::Ref(_, a, _), &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n         | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(!fx.layout_of(a).is_unsized());\n-            (src, unsized_info(fx, a, b, None))\n+            (src, unsized_info(fx, a, b, old_info))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_layout.ty.boxed_ty(), dst_layout.ty.boxed_ty());\n             assert!(!fx.layout_of(a).is_unsized());\n-            (src, unsized_info(fx, a, b, None))\n+            (src, unsized_info(fx, a, b, old_info))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n+            if src_layout == dst_layout {\n+                return (src, old_info.unwrap());\n+            }\n+\n             let mut result = None;\n             for i in 0..src_layout.fields.count() {\n                 let src_f = src_layout.field(fx, i);\n@@ -71,11 +105,11 @@ fn unsize_thin_ptr<'tcx>(\n                 let dst_f = dst_layout.field(fx, i);\n                 assert_ne!(src_f.ty, dst_f.ty);\n                 assert_eq!(result, None);\n-                result = Some(unsize_thin_ptr(fx, src, src_f, dst_f));\n+                result = Some(unsize_ptr(fx, src, src_f, dst_f, old_info));\n             }\n             result.unwrap()\n         }\n-        _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n+        _ => bug!(\"unsize_ptr: called on bad types\"),\n     }\n }\n \n@@ -91,12 +125,11 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n     let mut coerce_ptr = || {\n         let (base, info) =\n             if fx.layout_of(src.layout().ty.builtin_deref(true).unwrap().ty).is_unsized() {\n-                // fat-ptr to fat-ptr unsize preserves the vtable\n-                // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n-                src.load_scalar_pair(fx)\n+                let (old_base, old_info) = src.load_scalar_pair(fx);\n+                unsize_ptr(fx, old_base, src.layout(), dst.layout(), Some(old_info))\n             } else {\n                 let base = src.load_scalar(fx);\n-                unsize_thin_ptr(fx, base, src.layout(), dst.layout())\n+                unsize_ptr(fx, base, src.layout(), dst.layout(), None)\n             };\n         dst.write_cvalue(fx, CValue::by_val_pair(base, info, dst.layout()));\n     };"}, {"sha": "1b31587430887e3931829a4c81f3c86e109e1b75", "filename": "src/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f682236c96f7f304ffda201ef80824765a50bd8/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f682236c96f7f304ffda201ef80824765a50bd8/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=6f682236c96f7f304ffda201ef80824765a50bd8", "patch": "@@ -5,7 +5,7 @@\n use crate::constant::data_id_for_alloc_id;\n use crate::prelude::*;\n \n-fn vtable_memflags() -> MemFlags {\n+pub(crate) fn vtable_memflags() -> MemFlags {\n     let mut flags = MemFlags::trusted(); // A vtable access is always aligned and will never trap.\n     flags.set_readonly(); // A vtable is always read-only.\n     flags"}]}