{"sha": "cbdba2b4c25ef884e05587b0fc2e4b21e0d302cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiZGJhMmI0YzI1ZWY4ODRlMDU1ODdiMGZjMmU0YjIxZTBkMzAyY2I=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-07-18T16:29:44Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-01T22:33:03Z"}, "message": "use wrapping_offset; fix logic error in nth", "tree": {"sha": "cffc1f9b159ee4045fa7d712074b63b115836eca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cffc1f9b159ee4045fa7d712074b63b115836eca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbdba2b4c25ef884e05587b0fc2e4b21e0d302cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbdba2b4c25ef884e05587b0fc2e4b21e0d302cb", "html_url": "https://github.com/rust-lang/rust/commit/cbdba2b4c25ef884e05587b0fc2e4b21e0d302cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbdba2b4c25ef884e05587b0fc2e4b21e0d302cb/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7d90d1a50b82e8812f90dcf53087ea9574200e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7d90d1a50b82e8812f90dcf53087ea9574200e1", "html_url": "https://github.com/rust-lang/rust/commit/c7d90d1a50b82e8812f90dcf53087ea9574200e1"}], "stats": {"total": 22, "additions": 12, "deletions": 10}, "files": [{"sha": "5250f1e432d3ae094c986f1a341db6ed03cedfd2", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cbdba2b4c25ef884e05587b0fc2e4b21e0d302cb/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbdba2b4c25ef884e05587b0fc2e4b21e0d302cb/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=cbdba2b4c25ef884e05587b0fc2e4b21e0d302cb", "patch": "@@ -546,7 +546,7 @@ impl<T> [T] {\n             assume(!ptr.is_null());\n \n             let end = if mem::size_of::<T>() == 0 {\n-                (ptr as usize).wrapping_add(self.len()) as *const _\n+                (ptr as *const u8).wrapping_offset(self.len() as isize) as *const T\n             } else {\n                 ptr.offset(self.len() as isize)\n             };\n@@ -578,7 +578,7 @@ impl<T> [T] {\n             assume(!ptr.is_null());\n \n             let end = if mem::size_of::<T>() == 0 {\n-                (ptr as usize).wrapping_add(self.len()) as *mut _\n+                (ptr as *mut u8).wrapping_offset(self.len() as isize) as *mut T\n             } else {\n                 ptr.offset(self.len() as isize)\n             };\n@@ -2354,7 +2354,7 @@ macro_rules! iterator {\n             unsafe fn post_inc_start(&mut self, offset: isize) -> * $raw_mut T {\n                 if mem::size_of::<T>() == 0 {\n                     // This is *reducing* the length.  `ptr` never changes with ZST.\n-                    self.end = (self.end as isize).wrapping_sub(offset) as * $raw_mut T;\n+                    self.end = (self.end as * $raw_mut u8).wrapping_offset(-offset) as * $raw_mut T;\n                     self.ptr\n                 } else {\n                     let old = self.ptr;\n@@ -2369,7 +2369,7 @@ macro_rules! iterator {\n             #[inline(always)]\n             unsafe fn pre_dec_end(&mut self, offset: isize) -> * $raw_mut T {\n                 if mem::size_of::<T>() == 0 {\n-                    self.end = (self.end as isize).wrapping_sub(offset) as * $raw_mut T;\n+                    self.end = (self.end as * $raw_mut u8).wrapping_offset(-offset) as * $raw_mut T;\n                     self.ptr\n                 } else {\n                     self.end = self.end.offset(-offset);\n@@ -2432,12 +2432,14 @@ macro_rules! iterator {\n             #[inline]\n             fn nth(&mut self, n: usize) -> Option<$elem> {\n                 if n >= self.len() {\n-                    // This iterator is now empty.  The way we encode the length of a non-ZST\n-                    // iterator, this works for both ZST and non-ZST.\n-                    // For a ZST we would usually do `self.end = self.ptr`, but since\n-                    // we will not give out an reference any more after this there is no\n-                    // way to observe the difference except for raw pointers.\n-                    self.ptr = self.end;\n+                    // This iterator is now empty.\n+                    if mem::size_of::<T>() == 0 {\n+                        // We have to do it this way as `ptr` may never be 0, but `end`\n+                        // could be (due to wrapping).\n+                        self.end = self.ptr;\n+                    } else {\n+                        self.ptr = self.end;\n+                    }\n                     return None;\n                 }\n                 // We are in bounds. `offset` does the right thing even for ZSTs."}]}