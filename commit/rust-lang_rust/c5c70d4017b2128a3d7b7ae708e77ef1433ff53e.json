{"sha": "c5c70d4017b2128a3d7b7ae708e77ef1433ff53e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YzcwZDQwMTdiMjEyOGEzZDdiN2FlNzA4ZTc3ZWYxNDMzZmY1M2U=", "commit": {"author": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2020-11-25T20:05:04Z"}, "committer": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2020-11-25T21:23:06Z"}, "message": "Fix docs formatting for `thir::pattern::_match`\n\nA list was being rendered all on one line and there were other\nformatting issues as well.", "tree": {"sha": "6a9b22e2c3b5745451e654fff73a73fb8948074a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a9b22e2c3b5745451e654fff73a73fb8948074a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5c70d4017b2128a3d7b7ae708e77ef1433ff53e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5c70d4017b2128a3d7b7ae708e77ef1433ff53e", "html_url": "https://github.com/rust-lang/rust/commit/c5c70d4017b2128a3d7b7ae708e77ef1433ff53e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5c70d4017b2128a3d7b7ae708e77ef1433ff53e/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c389ffeff814726dec325f0f2b0c99107df2673", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c389ffeff814726dec325f0f2b0c99107df2673", "html_url": "https://github.com/rust-lang/rust/commit/1c389ffeff814726dec325f0f2b0c99107df2673"}], "stats": {"total": 53, "additions": 31, "deletions": 22}, "files": [{"sha": "f299663f6793404cc6260fc0d9a76380e678b75d", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c5c70d4017b2128a3d7b7ae708e77ef1433ff53e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5c70d4017b2128a3d7b7ae708e77ef1433ff53e/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=c5c70d4017b2128a3d7b7ae708e77ef1433ff53e", "patch": "@@ -1,21 +1,25 @@\n //! Note: tests specific to this file can be found in:\n-//!     - ui/pattern/usefulness\n-//!     - ui/or-patterns\n-//!     - ui/consts/const_in_pattern\n-//!     - ui/rfc-2008-non-exhaustive\n-//!     - ui/half-open-range-patterns\n-//!     - probably many others\n+//!\n+//!   - `ui/pattern/usefulness`\n+//!   - `ui/or-patterns`\n+//!   - `ui/consts/const_in_pattern`\n+//!   - `ui/rfc-2008-non-exhaustive`\n+//!   - `ui/half-open-range-patterns`\n+//!   - probably many others\n+//!\n //! I (Nadrieril) prefer to put new tests in `ui/pattern/usefulness` unless there's a specific\n-//! reason not to, for example if they depend on a particular feature like or_patterns.\n+//! reason not to, for example if they depend on a particular feature like `or_patterns`.\n+//!\n+//! -----\n //!\n //! This file includes the logic for exhaustiveness and usefulness checking for\n //! pattern-matching. Specifically, given a list of patterns for a type, we can\n //! tell whether:\n //! (a) the patterns cover every possible constructor for the type (exhaustiveness)\n //! (b) each pattern is necessary (usefulness)\n //!\n-//! The algorithm implemented here is a modified version of the one described in:\n-//! <http://moscova.inria.fr/~maranget/papers/warn/index.html>\n+//! The algorithm implemented here is a modified version of the one described in\n+//! [this paper](http://moscova.inria.fr/~maranget/papers/warn/index.html).\n //! However, to save future implementors from reading the original paper, we\n //! summarise the algorithm here to hopefully save time and be a little clearer\n //! (without being so rigorous).\n@@ -131,18 +135,22 @@\n //!\n //!    This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n //!    on top of the stack, and we have four cases:\n-//!         1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n-//!              push onto the stack the arguments of this constructor, and return the result:\n-//!                 r_1, .., r_a, p_2, .., p_n\n-//!         1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n-//!              return nothing.\n+//!\n+//!      1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n+//!           push onto the stack the arguments of this constructor, and return the result:\n+//!              `r_1, .., r_a, p_2, .., p_n`\n+//!\n+//!      1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n+//!           return nothing.\n+//!\n //!         1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n //!              arguments (its arity), and return the resulting stack:\n-//!                 _, .., _, p_2, .., p_n\n+//!                 `_, .., _, p_2, .., p_n`\n+//!\n //!         1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n //!              stack:\n-//!                 S(c, (r_1, p_2, .., p_n))\n-//!                 S(c, (r_2, p_2, .., p_n))\n+//!                 - `S(c, (r_1, p_2, .., p_n))`\n+//!                 - `S(c, (r_2, p_2, .., p_n))`\n //!\n //! 2. We can pop a wildcard off the top of the stack. This is called `S(_, p)`, where `p` is\n //!    a pattern-stack. Note: the paper calls this `D(p)`.\n@@ -157,8 +165,8 @@\n //!                 p_2, .., p_n\n //!         2.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n //!           stack.\n-//!                 S(_, (r_1, p_2, .., p_n))\n-//!                 S(_, (r_2, p_2, .., p_n))\n+//!                 - `S(_, (r_1, p_2, .., p_n))`\n+//!                 - `S(_, (r_2, p_2, .., p_n))`\n //!\n //! Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n //! exhaustive integer matching rules, so they're written here for posterity.\n@@ -198,7 +206,7 @@\n //! ]\n //! ```\n //!\n-//! and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n+//! and `p` is `[Some(false), 0]`, then we don't care about row 2 since we know `p` only\n //! matches values that row 2 doesn't. For row 1 however, we need to dig into the\n //! arguments of `Some` to know whether some new value is covered. So we compute\n //! `U([[true, _]], [false, 0])`.\n@@ -222,7 +230,7 @@\n //! ]\n //! ```\n //!\n-//! and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n+//! and `p` is `[_, false, _]`, the `Some` constructor doesn't appear in `P`. So if we\n //! only had row 2, we'd know that `p` is useful. However row 1 starts with a\n //! wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n //!\n@@ -243,7 +251,7 @@\n //! ]\n //! ```\n //!\n-//! and `p` is [_, false], both `None` and `Some` constructors appear in the first\n+//! and `p` is `[_, false]`, both `None` and `Some` constructors appear in the first\n //! components of `P`. We will therefore try popping both constructors in turn: we\n //! compute `U([[true, _]], [_, false])` for the `Some` constructor, and `U([[false]],\n //! [false])` for the `None` constructor. The first case returns true, so we know that\n@@ -294,6 +302,7 @@\n //!     + If some constructors are missing from the matrix, it turns out we don't need to do\n //!       anything special (because we know none of the integers are actually wildcards: i.e., we\n //!       can't span wildcards using ranges).\n+\n use self::Constructor::*;\n use self::SliceKind::*;\n use self::Usefulness::*;"}]}