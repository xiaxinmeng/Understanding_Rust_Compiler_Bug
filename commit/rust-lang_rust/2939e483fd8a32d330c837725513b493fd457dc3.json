{"sha": "2939e483fd8a32d330c837725513b493fd457dc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5MzllNDgzZmQ4YTMyZDMzMGM4Mzc3MjU1MTNiNDkzZmQ0NTdkYzM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-14T00:52:55Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-18T20:23:34Z"}, "message": "Extend the implicator so it produces general obligations and also so\nthat it produces \"outlives\" relations for associated types. Add\nseveral tests relating to #22246.", "tree": {"sha": "2ef40b4ce7711ff68e3c140ea65bfc4dd1a984a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ef40b4ce7711ff68e3c140ea65bfc4dd1a984a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2939e483fd8a32d330c837725513b493fd457dc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2939e483fd8a32d330c837725513b493fd457dc3", "html_url": "https://github.com/rust-lang/rust/commit/2939e483fd8a32d330c837725513b493fd457dc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2939e483fd8a32d330c837725513b493fd457dc3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5511add74205d8547f98959b01e5053be2395723", "url": "https://api.github.com/repos/rust-lang/rust/commits/5511add74205d8547f98959b01e5053be2395723", "html_url": "https://github.com/rust-lang/rust/commit/5511add74205d8547f98959b01e5053be2395723"}], "stats": {"total": 659, "additions": 527, "deletions": 132}, "files": [{"sha": "235f3f994c65e40aa79c901e4f5a8cd4e7067126", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2939e483fd8a32d330c837725513b493fd457dc3/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939e483fd8a32d330c837725513b493fd457dc3/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=2939e483fd8a32d330c837725513b493fd457dc3", "patch": "@@ -212,7 +212,7 @@ impl<K:UnifyKey> UnificationTable<K> {\n     }\n }\n \n-impl<K> sv::SnapshotVecDelegate for Delegate<K> {\n+impl<K:UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n     type Value = VarValue<K>;\n     type Undo = ();\n "}, {"sha": "d0f5aa8cf003b5e36f8996913723cbb6cfeaffeb", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2939e483fd8a32d330c837725513b493fd457dc3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939e483fd8a32d330c837725513b493fd457dc3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=2939e483fd8a32d330c837725513b493fd457dc3", "patch": "@@ -16,7 +16,6 @@ use borrowck::gather_loans::move_error::{MoveError, MoveErrorCollector};\n use borrowck::move_data::*;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Typer;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::middle::ty;\n use rustc::util::ppaux::Repr;"}, {"sha": "da5c847a04607e7cc79fc8e3de8e01726906d578", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2939e483fd8a32d330c837725513b493fd457dc3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939e483fd8a32d330c837725513b493fd457dc3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=2939e483fd8a32d330c837725513b493fd457dc3", "patch": "@@ -10,7 +10,6 @@\n \n use borrowck::BorrowckCtxt;\n use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Typer;\n use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n use rustc::middle::ty;\n use rustc::util::ppaux::UserString;"}, {"sha": "da25719baaa4ab3f06e67dec3adfcb5420b94465", "filename": "src/librustc_typeck/check/implicator.rs", "status": "modified", "additions": 160, "deletions": 98, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/2939e483fd8a32d330c837725513b493fd457dc3/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939e483fd8a32d330c837725513b493fd457dc3/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs?ref=2939e483fd8a32d330c837725513b493fd457dc3", "patch": "@@ -11,49 +11,73 @@\n // #![warn(deprecated_mode)]\n \n use astconv::object_region_bounds;\n-use middle::infer::GenericKind;\n-use middle::subst::{ParamSpace, Subst, Substs};\n-use middle::ty::{self, Ty};\n-use middle::ty_fold::{TypeFolder};\n+use middle::infer::{InferCtxt, GenericKind};\n+use middle::subst::{Substs};\n+use middle::traits;\n+use middle::ty::{self, ToPolyTraitRef, Ty};\n+use middle::ty_fold::{TypeFoldable, TypeFolder};\n \n+use std::rc::Rc;\n use syntax::ast;\n+use syntax::codemap::Span;\n \n+use util::common::ErrorReported;\n use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types.\n \n pub enum Implication<'tcx> {\n     RegionSubRegion(Option<Ty<'tcx>>, ty::Region, ty::Region),\n     RegionSubGeneric(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n+    Predicate(ast::DefId, ty::Predicate<'tcx>),\n }\n \n struct Implicator<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>,\n+    infcx: &'a InferCtxt<'a,'tcx>,\n+    closure_typer: &'a (ty::ClosureTyper<'tcx>+'a),\n+    body_id: ast::NodeId,\n     stack: Vec<(ty::Region, Option<Ty<'tcx>>)>,\n+    span: Span,\n     out: Vec<Implication<'tcx>>,\n }\n \n /// This routine computes the well-formedness constraints that must hold for the type `ty` to\n /// appear in a context with lifetime `outer_region`\n-pub fn implications<'tcx>(\n-    tcx: &ty::ctxt<'tcx>,\n+pub fn implications<'a,'tcx>(\n+    infcx: &'a InferCtxt<'a,'tcx>,\n+    closure_typer: &ty::ClosureTyper<'tcx>,\n+    body_id: ast::NodeId,\n     ty: Ty<'tcx>,\n-    outer_region: ty::Region)\n+    outer_region: ty::Region,\n+    span: Span)\n     -> Vec<Implication<'tcx>>\n {\n+    debug!(\"implications(body_id={}, ty={}, outer_region={})\",\n+           body_id,\n+           ty.repr(closure_typer.tcx()),\n+           outer_region.repr(closure_typer.tcx()));\n+\n     let mut stack = Vec::new();\n     stack.push((outer_region, None));\n-    let mut wf = Implicator { tcx: tcx,\n-                      stack: stack,\n-                      out: Vec::new() };\n+    let mut wf = Implicator { closure_typer: closure_typer,\n+                              infcx: infcx,\n+                              body_id: body_id,\n+                              span: span,\n+                              stack: stack,\n+                              out: Vec::new() };\n     wf.accumulate_from_ty(ty);\n+    debug!(\"implications: out={}\", wf.out.repr(closure_typer.tcx()));\n     wf.out\n }\n \n impl<'a, 'tcx> Implicator<'a, 'tcx> {\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n     fn accumulate_from_ty(&mut self, ty: Ty<'tcx>) {\n         debug!(\"accumulate_from_ty(ty={})\",\n-               ty.repr(self.tcx));\n+               ty.repr(self.tcx()));\n \n         match ty.sty {\n             ty::ty_bool |\n@@ -94,13 +118,13 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n \n             ty::ty_trait(ref t) => {\n                 let required_region_bounds =\n-                    object_region_bounds(self.tcx, &t.principal, t.bounds.builtin_bounds);\n+                    object_region_bounds(self.tcx(), &t.principal, t.bounds.builtin_bounds);\n                 self.accumulate_from_object_ty(ty, t.bounds.region_bound, required_region_bounds)\n             }\n \n             ty::ty_enum(def_id, substs) |\n             ty::ty_struct(def_id, substs) => {\n-                let item_scheme = ty::lookup_item_type(self.tcx, def_id);\n+                let item_scheme = ty::lookup_item_type(self.tcx(), def_id);\n                 self.accumulate_from_adt(ty, def_id, &item_scheme.generics, substs)\n             }\n \n@@ -139,9 +163,9 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n             }\n \n             ty::ty_open(_) => {\n-                self.tcx.sess.bug(\n+                self.tcx().sess.bug(\n                     &format!(\"Unexpected type encountered while doing wf check: {}\",\n-                            ty.repr(self.tcx))[]);\n+                            ty.repr(self.tcx()))[]);\n             }\n         }\n     }\n@@ -225,103 +249,113 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     fn accumulate_from_adt(&mut self,\n                            ty: Ty<'tcx>,\n                            def_id: ast::DefId,\n-                           generics: &ty::Generics<'tcx>,\n+                           _generics: &ty::Generics<'tcx>,\n                            substs: &Substs<'tcx>)\n     {\n-        // The generic declarations from the type, appropriately\n-        // substituted for the actual substitutions.\n-        let generics = generics.subst(self.tcx, substs);\n-\n-        // Variance of each type/region parameter.\n-        let variances = ty::item_variances(self.tcx, def_id);\n-\n-        for &space in &ParamSpace::all() {\n-            let region_params = substs.regions().get_slice(space);\n-            let region_variances = variances.regions.get_slice(space);\n-            let region_param_defs = generics.regions.get_slice(space);\n-            assert_eq!(region_params.len(), region_variances.len());\n-            for (&region_param, (&region_variance, region_param_def)) in\n-                region_params.iter().zip(\n-                    region_variances.iter().zip(\n-                        region_param_defs.iter()))\n-            {\n-                match region_variance {\n-                    ty::Covariant | ty::Bivariant => {\n-                        // Ignore covariant or bivariant region\n-                        // parameters.  To understand why, consider a\n-                        // struct `Foo<'a>`. If `Foo` contains any\n-                        // references with lifetime `'a`, then `'a` must\n-                        // be at least contravariant (and possibly\n-                        // invariant). The only way to have a covariant\n-                        // result is if `Foo` contains only a field with a\n-                        // type like `fn() -> &'a T`; i.e., a bare\n-                        // function that can produce a reference of\n-                        // lifetime `'a`. In this case, there is no\n-                        // *actual data* with lifetime `'a` that is\n-                        // reachable. (Presumably this bare function is\n-                        // really returning static data.)\n-                    }\n-\n-                    ty::Contravariant | ty::Invariant => {\n-                        // If the parameter is contravariant or\n-                        // invariant, there may indeed be reachable\n-                        // data with this lifetime. See other case for\n-                        // more details.\n-                        self.push_region_constraint_from_top(region_param);\n+        let predicates =\n+            ty::lookup_predicates(self.tcx(), def_id).instantiate(self.tcx(), substs);\n+        let predicates = match self.fully_normalize(&predicates) {\n+            Ok(predicates) => predicates,\n+            Err(ErrorReported) => { return; }\n+        };\n+\n+        for predicate in predicates.predicates.as_slice() {\n+            match *predicate {\n+                ty::Predicate::Trait(ref data) => {\n+                    self.accumulate_from_assoc_types_transitive(data);\n+                }\n+                ty::Predicate::Equate(..) => { }\n+                ty::Predicate::Projection(..) => { }\n+                ty::Predicate::RegionOutlives(ref data) => {\n+                    match ty::no_late_bound_regions(self.tcx(), data) {\n+                        None => { }\n+                        Some(ty::OutlivesPredicate(r_a, r_b)) => {\n+                            self.push_sub_region_constraint(Some(ty), r_b, r_a);\n+                        }\n                     }\n                 }\n-\n-                for &region_bound in &region_param_def.bounds {\n-                    // The type declared a constraint like\n-                    //\n-                    //     'b : 'a\n-                    //\n-                    // which means that `'a <= 'b` (after\n-                    // substitution).  So take the region we\n-                    // substituted for `'a` (`region_bound`) and make\n-                    // it a subregion of the region we substituted\n-                    // `'b` (`region_param`).\n-                    self.push_sub_region_constraint(\n-                        Some(ty), region_bound, region_param);\n+                ty::Predicate::TypeOutlives(ref data) => {\n+                    match ty::no_late_bound_regions(self.tcx(), data) {\n+                        None => { }\n+                        Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                            self.stack.push((r_b, Some(ty)));\n+                            self.accumulate_from_ty(ty_a);\n+                            self.stack.pop().unwrap();\n+                        }\n+                    }\n                 }\n             }\n+        }\n \n-            let types = substs.types.get_slice(space);\n-            let type_variances = variances.types.get_slice(space);\n-            let type_param_defs = generics.types.get_slice(space);\n-            assert_eq!(types.len(), type_variances.len());\n-            for (&type_param_ty, (&variance, type_param_def)) in\n-                types.iter().zip(\n-                    type_variances.iter().zip(\n-                        type_param_defs.iter()))\n-            {\n-                debug!(\"type_param_ty={} variance={}\",\n-                       type_param_ty.repr(self.tcx),\n-                       variance.repr(self.tcx));\n-\n-                match variance {\n-                    ty::Contravariant | ty::Bivariant => {\n-                        // As above, except that in this it is a\n-                        // *contravariant* reference that indices that no\n-                        // actual data of type T is reachable.\n-                    }\n+        let obligations = predicates.predicates\n+                                    .into_iter()\n+                                    .map(|pred| Implication::Predicate(def_id, pred));\n+        self.out.extend(obligations);\n \n-                    ty::Covariant | ty::Invariant => {\n-                        self.accumulate_from_ty(type_param_ty);\n-                    }\n+        let variances = ty::item_variances(self.tcx(), def_id);\n+\n+        for (&region, &variance) in substs.regions().iter().zip(variances.regions.iter()) {\n+            match variance {\n+                ty::Contravariant | ty::Invariant => {\n+                    // If any data with this lifetime is reachable\n+                    // within, it must be at least contravariant.\n+                    self.push_region_constraint_from_top(region)\n                 }\n+                ty::Covariant | ty::Bivariant => { }\n+            }\n+        }\n \n-                // Inspect bounds on this type parameter for any\n-                // region bounds.\n-                for &r in &type_param_def.bounds.region_bounds {\n-                    self.stack.push((r, Some(ty)));\n-                    self.accumulate_from_ty(type_param_ty);\n-                    self.stack.pop().unwrap();\n+        for (&ty, &variance) in substs.types.iter().zip(variances.types.iter()) {\n+            match variance {\n+                ty::Covariant | ty::Invariant => {\n+                    // If any data of this type is reachable within,\n+                    // it must be at least covariant.\n+                    self.accumulate_from_ty(ty);\n                 }\n+                ty::Contravariant | ty::Bivariant => { }\n             }\n         }\n     }\n \n+    /// Given that there is a requirement that `Foo<X> : 'a`, where\n+    /// `Foo` is declared like `struct Foo<T> where T : SomeTrait`,\n+    /// this code finds all the associated types defined in\n+    /// `SomeTrait` (and supertraits) and adds a requirement that `<X\n+    /// as SomeTrait>::N : 'a` (where `N` is some associated type\n+    /// defined in `SomeTrait`). This rule only applies to\n+    /// trait-bounds that are not higher-ranked, because we cannot\n+    /// project out of a HRTB. This rule helps code using associated\n+    /// types to compile, see Issue #22246 for an example.\n+    fn accumulate_from_assoc_types_transitive(&mut self,\n+                                              data: &ty::PolyTraitPredicate<'tcx>)\n+    {\n+        for poly_trait_ref in traits::supertraits(self.tcx(), data.to_poly_trait_ref()) {\n+            match ty::no_late_bound_regions(self.tcx(), &poly_trait_ref) {\n+                Some(trait_ref) => { self.accumulate_from_assoc_types(trait_ref); }\n+                None => { }\n+            }\n+        }\n+    }\n+\n+    fn accumulate_from_assoc_types(&mut self,\n+                                   trait_ref: Rc<ty::TraitRef<'tcx>>)\n+    {\n+        let trait_def_id = trait_ref.def_id;\n+        let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+        let assoc_type_projections: Vec<_> =\n+            trait_def.associated_type_names\n+                     .iter()\n+                     .map(|&name| ty::mk_projection(self.tcx(), trait_ref.clone(), name))\n+                     .collect();\n+        let tys = match self.fully_normalize(&assoc_type_projections) {\n+            Ok(tys) => { tys }\n+            Err(ErrorReported) => { return; }\n+        };\n+        for ty in tys {\n+            self.accumulate_from_ty(ty);\n+        }\n+    }\n+\n     fn accumulate_from_object_ty(&mut self,\n                                  ty: Ty<'tcx>,\n                                  region_bound: ty::Region,\n@@ -373,6 +407,28 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n             self.out.push(Implication::RegionSubRegion(Some(ty), r_d, r_c));\n         }\n     }\n+\n+    fn fully_normalize<T>(&self, value: &T) -> Result<T,ErrorReported>\n+        where T : TypeFoldable<'tcx> + ty::HasProjectionTypes + Clone + Repr<'tcx>\n+    {\n+        let value =\n+            traits::fully_normalize(self.infcx,\n+                                    self.closure_typer,\n+                                    traits::ObligationCause::misc(self.span, self.body_id),\n+                                    value);\n+        match value {\n+            Ok(value) => Ok(value),\n+            Err(errors) => {\n+                // I don't like reporting these errors here, but I\n+                // don't know where else to report them just now. And\n+                // I don't really expect errors to arise here\n+                // frequently. I guess the best option would be to\n+                // propagate them out.\n+                traits::report_fulfillment_errors(self.infcx, &errors);\n+                Err(ErrorReported)\n+            }\n+        }\n+    }\n }\n \n impl<'tcx> Repr<'tcx> for Implication<'tcx> {\n@@ -389,6 +445,12 @@ impl<'tcx> Repr<'tcx> for Implication<'tcx> {\n                         r.repr(tcx),\n                         p.repr(tcx))\n             }\n+\n+            Implication::Predicate(ref def_id, ref p) => {\n+                format!(\"Predicate({}, {})\",\n+                        def_id.repr(tcx),\n+                        p.repr(tcx))\n+            }\n         }\n     }\n }"}, {"sha": "3c2888e227803cead4903225fd156d7729fa58fe", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2939e483fd8a32d330c837725513b493fd457dc3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939e483fd8a32d330c837725513b493fd457dc3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2939e483fd8a32d330c837725513b493fd457dc3", "patch": "@@ -481,7 +481,8 @@ pub fn check_item_types(ccx: &CrateCtxt) {\n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            decl: &'tcx ast::FnDecl,\n                            body: &'tcx ast::Block,\n-                           id: ast::NodeId,\n+                           fn_id: ast::NodeId,\n+                           fn_span: Span,\n                            raw_fty: Ty<'tcx>,\n                            param_env: ty::ParameterEnvironment<'a, 'tcx>)\n {\n@@ -499,13 +500,13 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let fn_sig =\n                 inh.normalize_associated_types_in(&inh.param_env, body.span, body.id, &fn_sig);\n \n-            let fcx = check_fn(ccx, fn_ty.unsafety, id, &fn_sig,\n-                               decl, id, body, &inh);\n+            let fcx = check_fn(ccx, fn_ty.unsafety, fn_id, &fn_sig,\n+                               decl, fn_id, body, &inh);\n \n             vtable::select_all_fcx_obligations_and_apply_defaults(&fcx);\n-            upvar::closure_analyze_fn(&fcx, id, decl, body);\n+            upvar::closure_analyze_fn(&fcx, fn_id, decl, body);\n             vtable::select_all_fcx_obligations_or_error(&fcx);\n-            regionck::regionck_fn(&fcx, id, decl, body);\n+            regionck::regionck_fn(&fcx, fn_id, fn_span, decl, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n@@ -718,7 +719,7 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n       ast::ItemFn(ref decl, _, _, _, ref body) => {\n         let fn_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n         let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n-        check_bare_fn(ccx, &**decl, &**body, it.id, fn_pty.ty, param_env);\n+        check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n       }\n       ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n         debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n@@ -865,6 +866,7 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                   &*method.pe_fn_decl(),\n                   &*method.pe_body(),\n                   method.id,\n+                  method.span,\n                   fty,\n                   param_env);\n }"}, {"sha": "4e5550a2106a98aa64cc38dfc118e1e97af829b8", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 49, "deletions": 19, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2939e483fd8a32d330c837725513b493fd457dc3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939e483fd8a32d330c837725513b493fd457dc3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=2939e483fd8a32d330c837725513b493fd457dc3", "patch": "@@ -97,6 +97,7 @@ use middle::infer::{self, GenericKind};\n use middle::pat_util;\n use util::ppaux::{ty_to_string, Repr};\n \n+use std::mem;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n use syntax::visit;\n@@ -128,18 +129,18 @@ pub fn regionck_item(fcx: &FnCtxt, item: &ast::Item) {\n     rcx.resolve_regions_and_report_errors();\n }\n \n-pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, decl: &ast::FnDecl, blk: &ast::Block) {\n-    debug!(\"regionck_fn(id={})\", id);\n-    let mut rcx = Rcx::new(fcx, RepeatingScope(blk.id), blk.id, Subject(id));\n+pub fn regionck_fn(fcx: &FnCtxt,\n+                   fn_id: ast::NodeId,\n+                   fn_span: Span,\n+                   decl: &ast::FnDecl,\n+                   blk: &ast::Block) {\n+    debug!(\"regionck_fn(id={})\", fn_id);\n+    let mut rcx = Rcx::new(fcx, RepeatingScope(blk.id), blk.id, Subject(fn_id));\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n-        rcx.visit_fn_body(id, decl, blk, blk.span); // TODO suboptimal span\n+        rcx.visit_fn_body(fn_id, decl, blk, fn_span);\n     }\n \n-    // Region checking a fn can introduce new trait obligations,\n-    // particularly around closure bounds.\n-    vtable::select_all_fcx_obligations_or_error(fcx);\n-\n     rcx.resolve_regions_and_report_errors();\n }\n \n@@ -167,6 +168,9 @@ pub struct Rcx<'a, 'tcx: 'a> {\n \n     region_bound_pairs: Vec<(ty::Region, GenericKind<'tcx>)>,\n \n+    // id of innermost fn body id\n+    body_id: ast::NodeId,\n+\n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n \n@@ -195,10 +199,12 @@ pub enum SubjectNode { Subject(ast::NodeId), None }\n impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     pub fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n                initial_repeating_scope: RepeatingScope,\n+               initial_body_id: ast::NodeId,\n                subject: SubjectNode) -> Rcx<'a, 'tcx> {\n         let RepeatingScope(initial_repeating_scope) = initial_repeating_scope;\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n+              body_id: initial_body_id,\n               subject: subject,\n               region_bound_pairs: Vec::new()\n         }\n@@ -208,6 +214,10 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         self.fcx.ccx.tcx\n     }\n \n+    fn set_body_id(&mut self, body_id: ast::NodeId) -> ast::NodeId {\n+        mem::replace(&mut self.body_id, body_id)\n+    }\n+\n     fn set_repeating_scope(&mut self, scope: ast::NodeId) -> ast::NodeId {\n         mem::replace(&mut self.repeating_scope, scope)\n     }\n@@ -267,9 +277,11 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     fn visit_fn_body(&mut self,\n                      id: ast::NodeId,\n                      fn_decl: &ast::FnDecl,\n-                     body: &ast::Block)\n+                     body: &ast::Block,\n+                     span: Span)\n     {\n         // When we enter a function, we can derive\n+        debug!(\"visit_fn_body(id={})\", id);\n \n         let fn_sig_map = self.fcx.inh.fn_sig_map.borrow();\n         let fn_sig = match fn_sig_map.get(&id) {\n@@ -281,17 +293,24 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         };\n \n         let len = self.region_bound_pairs.len();\n-        self.relate_free_regions(&fn_sig[], body.id);\n+        let old_body_id = self.set_body_id(body.id);\n+        self.relate_free_regions(&fn_sig[], body.id, span);\n         link_fn_args(self, CodeExtent::from_node_id(body.id), &fn_decl.inputs[]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n         self.region_bound_pairs.truncate(len);\n+        self.set_body_id(old_body_id);\n     }\n \n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n     {\n         debug!(\"visit_region_obligations: node_id={}\", node_id);\n \n+        // region checking can introduce new pending obligations\n+        // which, when processed, might generate new region\n+        // obligations. So make sure we process those.\n+        vtable::select_all_fcx_obligations_or_error(self.fcx);\n+\n         // Make a copy of the region obligations vec because we'll need\n         // to be able to borrow the fulfillment-cx below when projecting.\n         let region_obligations =\n@@ -324,7 +343,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     /// Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n     fn relate_free_regions(&mut self,\n                            fn_sig_tys: &[Ty<'tcx>],\n-                           body_id: ast::NodeId) {\n+                           body_id: ast::NodeId,\n+                           span: Span) {\n         debug!(\"relate_free_regions >>\");\n         let tcx = self.tcx();\n \n@@ -333,18 +353,19 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             debug!(\"relate_free_regions(t={})\", ty.repr(tcx));\n             let body_scope = CodeExtent::from_node_id(body_id);\n             let body_scope = ty::ReScope(body_scope);\n-            let implications = implicator::implications(tcx, ty, body_scope);\n+            let implications = implicator::implications(self.fcx.infcx(), self.fcx, body_id,\n+                                                        ty, body_scope, span);\n             for implication in implications {\n                 debug!(\"implication: {}\", implication.repr(tcx));\n                 match implication {\n                     implicator::Implication::RegionSubRegion(_,\n-                                              ty::ReFree(free_a),\n-                                              ty::ReFree(free_b)) => {\n+                                                             ty::ReFree(free_a),\n+                                                             ty::ReFree(free_b)) => {\n                         tcx.region_maps.relate_free_regions(free_a, free_b);\n                     }\n                     implicator::Implication::RegionSubRegion(_,\n-                                              ty::ReFree(free_a),\n-                                              ty::ReInfer(ty::ReVar(vid_b))) => {\n+                                                             ty::ReFree(free_a),\n+                                                             ty::ReInfer(ty::ReVar(vid_b))) => {\n                         self.fcx.inh.infcx.add_given(free_a, vid_b);\n                     }\n                     implicator::Implication::RegionSubRegion(..) => {\n@@ -364,6 +385,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n                         self.region_bound_pairs.push((r_a, generic_b.clone()));\n                     }\n+                    implicator::Implication::Predicate(..) => { }\n                 }\n             }\n         }\n@@ -394,8 +416,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Rcx<'a, 'tcx> {\n     // regions, until regionck, as described in #3238.\n \n     fn visit_fn(&mut self, _fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n-                b: &'v ast::Block, _s: Span, id: ast::NodeId) {\n-        self.visit_fn_body(id, fd, b)\n+                b: &'v ast::Block, span: Span, id: ast::NodeId) {\n+        self.visit_fn_body(id, fd, b, span)\n     }\n \n     fn visit_item(&mut self, i: &ast::Item) { visit_item(self, i); }\n@@ -1475,7 +1497,8 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n            ty.repr(rcx.tcx()),\n            region.repr(rcx.tcx()));\n \n-    let implications = implicator::implications(rcx.tcx(), ty, region);\n+    let implications = implicator::implications(rcx.fcx.infcx(), rcx.fcx, rcx.body_id,\n+                                                ty, region, origin.span());\n     for implication in implications {\n         debug!(\"implication: {}\", implication.repr(rcx.tcx()));\n         match implication {\n@@ -1493,6 +1516,13 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n                 generic_must_outlive(rcx, o1, r_a, generic_b);\n             }\n+            implicator::Implication::Predicate(def_id, predicate) => {\n+                let cause = traits::ObligationCause::new(origin.span(),\n+                                                         rcx.body_id,\n+                                                         traits::ItemObligation(def_id));\n+                let obligation = traits::Obligation::new(cause, predicate);\n+                rcx.fcx.register_predicate(obligation);\n+            }\n         }\n     }\n }"}, {"sha": "d124282d391281c65137ec6c2a1cccad466a3ecc", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2939e483fd8a32d330c837725513b493fd457dc3/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939e483fd8a32d330c837725513b493fd457dc3/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=2939e483fd8a32d330c837725513b493fd457dc3", "patch": "@@ -97,14 +97,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 self.check_item_type(item);\n             }\n             ast::ItemStruct(ref struct_def, _) => {\n-                self.check_type_defn(item, |fcx| {\n-                    vec![struct_variant(fcx, &**struct_def)]\n-                });\n+                self.check_type_defn(item, |fcx| vec![struct_variant(fcx, &**struct_def)]);\n             }\n             ast::ItemEnum(ref enum_def, _) => {\n-                self.check_type_defn(item, |fcx| {\n-                    enum_variants(fcx, enum_def)\n-                });\n+                self.check_type_defn(item, |fcx| enum_variants(fcx, enum_def));\n             }\n             ast::ItemTrait(..) => {\n                 let trait_predicates ="}, {"sha": "fa26c9c54c8f4c2a6450a8ba435f8e4f8cf64b94", "filename": "src/test/compile-fail/regions-assoc-type-in-supertrait-outlives-container.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2939e483fd8a32d330c837725513b493fd457dc3/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939e483fd8a32d330c837725513b493fd457dc3/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs?ref=2939e483fd8a32d330c837725513b493fd457dc3", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are imposing the requirement that every associated\n+// type of a bound that appears in the where clause on a struct must\n+// outlive the location in which the type appears, even when the\n+// associted type is in a supertype. Issue #22246.\n+\n+#![allow(dead_code)]\n+\n+use std::mem::transmute;\n+use std::ops::Deref;\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub trait TheTrait {\n+    type TheAssocType;\n+\n+    fn dummy(&self) { }\n+}\n+\n+pub trait TheSubTrait : TheTrait {\n+}\n+\n+pub struct TheType<'b> {\n+    m: [fn(&'b()); 0]\n+}\n+\n+impl<'b> TheTrait for TheType<'b> {\n+    type TheAssocType = &'b ();\n+}\n+\n+impl<'b> TheSubTrait for TheType<'b> {\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub struct WithAssoc<T:TheSubTrait> {\n+    m: [T; 0]\n+}\n+\n+fn with_assoc<'a,'b>() {\n+    // For this type to be valid, the rules require that all\n+    // associated types of traits that appear in `WithAssoc` must\n+    // outlive 'a. In this case, that means TheType<'b>::TheAssocType,\n+    // which is &'b (), must outlive 'a.\n+\n+    let _: &'a WithAssoc<TheType<'b>> = loop { }; //~ ERROR cannot infer\n+}\n+\n+fn main() {\n+}"}, {"sha": "5e02aae672d3554b11665793b03385ae28cb5219", "filename": "src/test/compile-fail/regions-assoc-type-outlives-container-hrtb.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2939e483fd8a32d330c837725513b493fd457dc3/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939e483fd8a32d330c837725513b493fd457dc3/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-hrtb.rs?ref=2939e483fd8a32d330c837725513b493fd457dc3", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that structs with higher-ranked where clauses don't generate\n+// \"outlives\" requirements. Issue #22246.\n+\n+#![allow(dead_code)]\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub trait TheTrait<'b> {\n+    type TheAssocType;\n+\n+    fn dummy(&'b self) { }\n+}\n+\n+pub struct TheType<'b> {\n+    m: [fn(&'b()); 0]\n+}\n+\n+impl<'a,'b> TheTrait<'a> for TheType<'b> {\n+    type TheAssocType = &'b ();\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub struct WithHrAssoc<T>\n+    where for<'a> T : TheTrait<'a>\n+{\n+    m: [T; 0]\n+}\n+\n+fn with_assoc<'a,'b>() {\n+    // We get no error here because the where clause has a higher-ranked assoc type,\n+    // which could not be projected from.\n+\n+    let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub trait TheSubTrait : for<'a> TheTrait<'a> {\n+}\n+\n+impl<'b> TheSubTrait for TheType<'b> { }\n+\n+pub struct WithHrAssocSub<T>\n+    where T : TheSubTrait\n+{\n+    m: [T; 0]\n+}\n+\n+fn with_assoc_sub<'a,'b>() {\n+    // Same here, because although the where clause is not HR, it\n+    // extends a trait in a HR way.\n+\n+    let _: &'a WithHrAssocSub<TheType<'b>> = loop { };\n+}\n+\n+#[rustc_error]\n+fn main() { //~ ERROR compilation successful\n+}"}, {"sha": "6ee65fbdf919bb97ac37c44d9ae93fd520d1bccc", "filename": "src/test/compile-fail/regions-assoc-type-outlives-container-wc.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2939e483fd8a32d330c837725513b493fd457dc3/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-wc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939e483fd8a32d330c837725513b493fd457dc3/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-wc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-wc.rs?ref=2939e483fd8a32d330c837725513b493fd457dc3", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are imposing the requirement that every associated\n+// type of a bound that appears in the where clause on a struct must\n+// outlive the location in which the type appears, even when the\n+// constraint is in a where clause not a bound. Issue #22246.\n+\n+#![allow(dead_code)]\n+\n+use std::mem::transmute;\n+use std::ops::Deref;\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub trait TheTrait {\n+    type TheAssocType;\n+\n+    fn dummy(&self) { }\n+}\n+\n+pub struct TheType<'b> {\n+    m: [fn(&'b()); 0]\n+}\n+\n+impl<'b> TheTrait for TheType<'b> {\n+    type TheAssocType = &'b ();\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub struct WithAssoc<T> where T : TheTrait {\n+    m: [T; 0]\n+}\n+\n+fn with_assoc<'a,'b>() {\n+    // For this type to be valid, the rules require that all\n+    // associated types of traits that appear in `WithAssoc` must\n+    // outlive 'a. In this case, that means TheType<'b>::TheAssocType,\n+    // which is &'b (), must outlive 'a.\n+\n+    let _: &'a WithAssoc<TheType<'b>> = loop { }; //~ ERROR cannot infer\n+}\n+\n+fn main() {\n+}"}, {"sha": "49a0726fa3b7be3acca1abefcf42f53c29ec2966", "filename": "src/test/compile-fail/regions-assoc-type-outlives-container.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2939e483fd8a32d330c837725513b493fd457dc3/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939e483fd8a32d330c837725513b493fd457dc3/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container.rs?ref=2939e483fd8a32d330c837725513b493fd457dc3", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are imposing the requirement that every associated\n+// type of a bound that appears in the where clause on a struct must\n+// outlive the location in which the type appears. Issue #22246.\n+\n+#![allow(dead_code)]\n+\n+use std::mem::transmute;\n+use std::ops::Deref;\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub trait TheTrait {\n+    type TheAssocType;\n+\n+    fn dummy(&self) { }\n+}\n+\n+pub struct TheType<'b> {\n+    m: [fn(&'b()); 0]\n+}\n+\n+impl<'b> TheTrait for TheType<'b> {\n+    type TheAssocType = &'b ();\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub struct WithAssoc<T:TheTrait> {\n+    m: [T; 0]\n+}\n+\n+pub struct WithoutAssoc<T> {\n+    m: [T; 0]\n+}\n+\n+fn with_assoc<'a,'b>() {\n+    // For this type to be valid, the rules require that all\n+    // associated types of traits that appear in `WithAssoc` must\n+    // outlive 'a. In this case, that means TheType<'b>::TheAssocType,\n+    // which is &'b (), must outlive 'a.\n+\n+    let _: &'a WithAssoc<TheType<'b>> = loop { }; //~ ERROR cannot infer\n+}\n+\n+fn with_assoc1<'a,'b>() where 'b : 'a {\n+    // For this type to be valid, the rules require that all\n+    // associated types of traits that appear in `WithAssoc` must\n+    // outlive 'a. In this case, that means TheType<'b>::TheAssocType,\n+    // which is &'b (), must outlive 'a, so 'b : 'a must hold, and\n+    // that is in the where clauses, so we're fine.\n+\n+    let _: &'a WithAssoc<TheType<'b>> = loop { };\n+}\n+\n+fn without_assoc<'a,'b>() {\n+    // Here there are no associated types and the `'b` appearing in\n+    // `TheType<'b>` is purely covariant, so there is no requirement\n+    // that `'b:'a` holds.\n+\n+    let _: &'a WithoutAssoc<TheType<'b>> = loop { };\n+}\n+\n+fn call_with_assoc<'a,'b>() {\n+    // As `with_assoc`, but just checking that we impose the same rule\n+    // on the value supplied for the type argument, even when there is\n+    // no data.\n+\n+    call::<&'a WithAssoc<TheType<'b>>>();\n+    //~^ ERROR cannot infer\n+}\n+\n+fn call_without_assoc<'a,'b>() {\n+    // As `without_assoc`, but in a distinct scenario.\n+\n+    call::<&'a WithoutAssoc<TheType<'b>>>();\n+}\n+\n+fn call<T>() { }\n+\n+fn main() {\n+}"}, {"sha": "f5c34d6b34e9d8761be05546615cb4056c9ab21e", "filename": "src/test/run-pass/regions-issue-22246.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2939e483fd8a32d330c837725513b493fd457dc3/src%2Ftest%2Frun-pass%2Fregions-issue-22246.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2939e483fd8a32d330c837725513b493fd457dc3/src%2Ftest%2Frun-pass%2Fregions-issue-22246.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-issue-22246.rs?ref=2939e483fd8a32d330c837725513b493fd457dc3", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #22246 -- we should be able to deduce\n+// that `&'a B::Owned` implies that `B::Owned : 'a`.\n+\n+#![allow(dead_code)]\n+\n+use std::ops::Deref;\n+\n+pub trait ToOwned {\n+    type Owned: Borrow<Self>;\n+    fn to_owned(&self) -> Self::Owned;\n+}\n+\n+pub trait Borrow<Borrowed> {\n+    fn borrow(&self) -> &Borrowed;\n+}\n+\n+pub struct Foo<B:ToOwned> {\n+    owned: B::Owned\n+}\n+\n+fn foo<B:ToOwned>(this: &Foo<B>) -> &B {\n+    this.owned.borrow()\n+}\n+\n+fn main() { }"}]}