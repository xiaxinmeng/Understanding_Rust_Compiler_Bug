{"sha": "d365ec5c7d28ddf2907e722221c72228233843a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNjVlYzVjN2QyOGRkZjI5MDdlNzIyMjIxYzcyMjI4MjMzODQzYTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-15T14:39:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-15T22:30:10Z"}, "message": "kill old serialization code", "tree": {"sha": "dc4e6f85701559d1bcce4576bc43fd919e6f337b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc4e6f85701559d1bcce4576bc43fd919e6f337b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d365ec5c7d28ddf2907e722221c72228233843a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d365ec5c7d28ddf2907e722221c72228233843a7", "html_url": "https://github.com/rust-lang/rust/commit/d365ec5c7d28ddf2907e722221c72228233843a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d365ec5c7d28ddf2907e722221c72228233843a7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dca3393fa6459da14151b22f403b3f3b8dada55", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dca3393fa6459da14151b22f403b3f3b8dada55", "html_url": "https://github.com/rust-lang/rust/commit/3dca3393fa6459da14151b22f403b3f3b8dada55"}], "stats": {"total": 9871, "additions": 1, "deletions": 9870}, "files": [{"sha": "3318264253fe4fc46b2d116ca3ff0897c08d04c7", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d365ec5c7d28ddf2907e722221c72228233843a7/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/d365ec5c7d28ddf2907e722221c72228233843a7/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=d365ec5c7d28ddf2907e722221c72228233843a7", "patch": "@@ -414,12 +414,7 @@ FUZZ := $(HBIN3_H_$(CFG_HOST_TRIPLE))/fuzzer$(X)\n CARGO := $(HBIN3_H_$(CFG_HOST_TRIPLE))/cargo$(X)\n RUSTDOC := $(HBIN3_H_$(CFG_HOST_TRIPLE))/rustdoc$(X)\n \n-all: rustc $(GENERATED) docs $(FUZZ) $(CARGO) $(RUSTDOC) serializer\n-\n-serializer: $(HBIN1_H_$(CFG_HOST_TRIPLE))/serializer$(X) \\\n-            $(SREQ1_T_$(CFG_HOST_TRIPLE)_H_$(CFG_HOST_TRIPLE))\n-# ^^ Note: we use HBIN1 because that is built by the snapshot compiler\n-#    and sometimes we need the serializer to build the later stages.\n+all: rustc $(GENERATED) docs $(FUZZ) $(CARGO) $(RUSTDOC)\n \n endif\n "}, {"sha": "6b7810de73b3c388259544ba953904905410287e", "filename": "mk/tools.mk", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d365ec5c7d28ddf2907e722221c72228233843a7/mk%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d365ec5c7d28ddf2907e722221c72228233843a7/mk%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftools.mk?ref=d365ec5c7d28ddf2907e722221c72228233843a7", "patch": "@@ -16,11 +16,6 @@ CARGO_INPUTS := $(wildcard $(S)src/cargo/*rs)\n RUSTDOC_CRATE := $(S)src/rustdoc/rustdoc.rc\n RUSTDOC_INPUTS := $(wildcard $(S)src/rustdoc/*.rs)\n \n-# Serializer, generates serialization code\n-# (Should eventually move into a compiler ext)\n-SERIALIZER_CRATE := $(S)src/serializer/serializer.rc\n-SERIALIZER_INPUTS := $(wildcard $(S)src/serializer/*.rs)\n-\n # FIXME: These are only built for the host arch. Eventually we'll\n # have tools that need to built for other targets.\n define TOOLS_STAGE_N\n@@ -88,21 +83,6 @@ $$(HBIN$(2)_H_$(4))/rustdoc$$(X):\t\t\t\t\\\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n-$$(TBIN$(1)_T_$(4)_H_$(3))/serializer$$(X):\t\t\t\\\n-\t\t$$(SERIALIZER_CRATE) $$(SERIALIZER_INPUTS)\t\\\n-\t\t$$(TSREQ$(1)_T_$(4)_H_$(3))\t\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_CORELIB)\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_STDLIB)\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$$(CFG_LIBRUSTC)\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) -o $$@ $$<\n-\n-$$(HBIN$(2)_H_$(4))/serializer$$(X):\t\t\t\t\\\n-\t\t$$(TBIN$(1)_T_$(4)_H_$(3))/serializer$$(X)\t\\\n-\t\t$$(HSREQ$(2)_H_$(4))\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n endef\n \n $(foreach host,$(CFG_TARGET_TRIPLES),\t\t\t\t\\"}, {"sha": "50105ca78d160f3b1a085711ecb7f088608da619", "filename": "src/etc/gen-astencode", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Fetc%2Fgen-astencode", "raw_url": "https://github.com/rust-lang/rust/raw/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Fetc%2Fgen-astencode", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgen-astencode?ref=3dca3393fa6459da14151b22f403b3f3b8dada55", "patch": "@@ -1,74 +0,0 @@\n-#!/bin/sh\n-\n-function msg {\n-        echo \"\"\n-        echo \"\"\n-        echo \"****************************************\"\n-        echo \"* Processing errors encountered        *\"\n-        echo \"*                                      *\"\n-        echo \"* Dummy versions of the AST encoder    *\"\n-        echo \"* have been left in astencode_gen.rs.  *\"\n-        echo \"* Fix the compilation errors and rerun *\"\n-        echo \"* this script to generate the real     *\"\n-        echo \"* versions.                            *\"\n-        echo \"****************************************\"\n-}\n-\n-M=src/rustc/metadata\n-GEN_TYPES=\"syntax::ast::item syntax::ast::def middle::typeck::method_origin \\\n-           middle::freevars::freevar_entry syntax::ast::def_id\n-           syntax::ast::inlined_item middle::last_use::is_last_use\"\n-\n-BUILD_DIR=$1\n-if test $BUILD_DIR == \"\"; then\n-    BUILD_DIR=\".\"\n-fi\n-\n-# Find serializer tool:\n-for S in $BUILD_DIR/*/stage1/bin/serializer; do\n-\n-    echo \"Generating src/rustc/metadata/astencode_gen.rs\"\n-\n-    # First, generate dummy fns so that the compiler can type\n-    # everything.\n-    echo \"// TEMPORARY DEFINITIONS: re-run gen-astencode\" \\\n-        > $M/astencode_gen.rs\n-    for T in $GEN_TYPES; do\n-      echo \"fn serialize_${T//::/_}<S>(_s: S, _v: $T) {}\" \\\n-          >> $M/astencode_gen.rs\n-      echo \"fn deserialize_${T//::/_}<S>(_s: S) -> $T { fail; }\" \\\n-          >> $M/astencode_gen.rs\n-    done\n-\n-    # Find rustc and serializer:\n-    D=$(dirname \"$S\")\n-    R=\"${D}/../../stage0/bin/rustc\"\n-    if [ ! -x \"$R\" ]; then\n-        echo \"rustc not found or not executable at path '$R'\"\n-        msg\n-        exit 1\n-    fi\n-\n-    if [ ! -x \"$S\" ]; then\n-        echo \"serializer excutable not found; try 'make serializer'\"\n-        msg\n-        exit 1\n-    fi\n-\n-    # Generate the real code into a temporary file.\n-    if ! \"$S\" src/rustc/rustc.rc $GEN_TYPES > tmp.$$.rs\n-    then\n-        msg\n-        rm tmp.$$.rs\n-        exit 1\n-    fi\n-\n-    # Copy over into the final destination and clean up.\n-    \"$R\" --pretty normal tmp.$$.rs > $M/astencode_gen.rs\n-    # rm -f tmp.$$.rs\n-    exit 0\n-done\n-\n-# If we made it this far, must not have found any\n-# serializer:\n-echo \"serializer tool not found.\""}, {"sha": "9292490ff6bedb1d3760e18202b73d23fc909726", "filename": "src/rustc/metadata/astencode_gen.rs", "status": "removed", "additions": 0, "deletions": 9189, "changes": 9189, "blob_url": "https://github.com/rust-lang/rust/blob/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Frustc%2Fmetadata%2Fastencode_gen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Frustc%2Fmetadata%2Fastencode_gen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode_gen.rs?ref=3dca3393fa6459da14151b22f403b3f3b8dada55"}, {"sha": "05e073155e7bfffad6e4999fa9f5bbfe9de4f09f", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d365ec5c7d28ddf2907e722221c72228233843a7/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d365ec5c7d28ddf2907e722221c72228233843a7/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=d365ec5c7d28ddf2907e722221c72228233843a7", "patch": "@@ -126,7 +126,6 @@ mod metadata {\n     mod tyencode;\n     mod tydecode;\n     mod astencode;\n-    mod astencode_gen;\n     mod encoder;\n     mod decoder;\n     mod creader;"}, {"sha": "ba3a8467b9da07257d15c1393c6c5ede54ba1688", "filename": "src/serializer/serializer.rc", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Fserializer%2Fserializer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Fserializer%2Fserializer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fserializer%2Fserializer.rc?ref=3dca3393fa6459da14151b22f403b3f3b8dada55", "patch": "@@ -1,17 +0,0 @@\n-// -*- rust -*-\n-\n-// serializer --- Rust metadata encoder/decoder generator.\n-//\n-// This tool is not intended to generate usable modules (just yet),\n-// though perhaps it will be beefed up.  But it can do a lot of the\n-// grunt work for you.\n-\n-#[link(name = \"serializer\",\n-       vers = \"0.1\",\n-       uuid = \"9ff87a04-8fed-4295-9ff8-f99bb802650b\",\n-       url = \"http://rust-lang.org/doc/serializer\")];\n-\n-#[crate_type = \"bin\"];\n-\n-use std;\n-use rustc;"}, {"sha": "ca2b5f54150e056aaf39a0512d51ce4537e46bbe", "filename": "src/serializer/serializer.rs", "status": "removed", "additions": 0, "deletions": 523, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Fserializer%2Fserializer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Fserializer%2Fserializer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fserializer%2Fserializer.rs?ref=3dca3393fa6459da14151b22f403b3f3b8dada55", "patch": "@@ -1,523 +0,0 @@\n-import rustc::driver::{driver,session};\n-import rustc::syntax::{ast, codemap};\n-import rustc::syntax::parse::parser;\n-import rustc::driver::diagnostic;\n-import rustc::syntax::print::pprust;\n-import rustc::syntax::codemap::span;\n-import rustc::middle::ty;\n-import rustc::middle::ast_map;\n-import rustc::util::ppaux;\n-import std::map::{hashmap, map, int_hash};\n-import std::getopts;\n-import io::writer_util;\n-import driver::build_session_options;\n-import driver::build_session;\n-import driver::build_configuration;\n-\n-type parse_result = {\n-    crate: @ast::crate,\n-    tcx: ty::ctxt,\n-    roots: [str]\n-};\n-\n-fn parse(argv: [str]) -> parse_result {\n-    let argv = argv;\n-    let argv0 = vec::shift(argv);\n-    let match = result::get(getopts::getopts(argv, driver::opts()));\n-    let sessopts = build_session_options(match, diagnostic::emit);\n-    let sess = build_session(sessopts, \"\", diagnostic::emit);\n-    let (ifile, roots) = {\n-        let free = match.free;\n-        if check vec::is_not_empty(free) {\n-            let t = vec::tail(free);\n-            (free[0], t)\n-        } else {\n-            fail \"No input filename given.\";\n-        }\n-    };\n-    let cfg = build_configuration(sess, argv0, ifile);\n-    alt driver::compile_upto(sess, cfg, ifile, driver::cu_typeck, none) {\n-      {crate, tcx: some(tcx)} { {crate:crate, tcx:tcx, roots:roots} }\n-      _ { fail \"no type context\"; }\n-    }\n-}\n-\n-type ast_expr = str;\n-type ast_stmt = str;\n-type ast_blk = str;\n-type ast_pat = str;\n-type ast_ty = str;\n-type ast_item = str;\n-\n-type tp_map = hashmap<ast::node_id, ty::t>;\n-\n-type serialize_ctx = {\n-    crate: @ast::crate,\n-    tcx: ty::ctxt,\n-\n-    serialize_tyfns: hashmap<ty::t, str>,\n-    deserialize_tyfns: hashmap<ty::t, str>,\n-    mutable item_fns: [ast_item],\n-    mutable constants: [str]\n-\n-    // needed for #ast:\n-    // opts: @{cfg: ast::crate_cfg},\n-    // psess: parser::parse_sess\n-};\n-\n-fn item_has_name(&&item: @ast::item, &&name: str) -> bool {\n-    item.ident == name\n-}\n-\n-fn lookup(_mod: ast::_mod, idx: uint, names: [str]) -> @ast::item {\n-    let name = names[idx];\n-    alt vec::find(_mod.items, bind item_has_name(_, name)) {\n-      none { fail #fmt[\"cannot resolve name %s at index %u\", name, idx]; }\n-      some(item) if idx == vec::len(names) - 1u { item }\n-      some(item) {\n-        alt item.node {\n-          ast::item_mod(_m) { lookup(_m, idx + 1u, names) }\n-          _ { fail #fmt[\"name %s at index %u not a module\", name, idx]; }\n-        }\n-      }\n-    }\n-}\n-\n-impl serialize_ctx for serialize_ctx {\n-    fn add_item(item: ast_item) {\n-        self.item_fns += [item];\n-    }\n-\n-    fn tp_map(ty_params: [ast::ty_param], tps: [ty::t]) -> tp_map {\n-        assert vec::len(tps) == vec::len(ty_params);\n-        let tps_map = int_hash();\n-        vec::iter2(ty_params, tps) {|tp_def,tp_val|\n-            tps_map.insert(tp_def.id, tp_val);\n-        }\n-        ret tps_map;\n-    }\n-\n-    fn ident(base_path: ast_map::path, id: str) -> str {\n-        #fmt[\"%s_%s\", ast_map::path_to_str_with_sep(base_path, \"_\"), id]\n-    }\n-\n-    fn instantiate(id: ast::def_id, args: [ty::t]) -> ty::t {\n-        let {bounds, ty} = ty::lookup_item_type(self.tcx, id);\n-\n-        // typeck should guarantee this\n-        assert vec::len(*bounds) == vec::len(args);\n-\n-        ret if vec::len(args) == 0u {\n-            ty\n-        } else {\n-            ty::substitute_type_params(self.tcx, args, ty)\n-        };\n-    }\n-\n-    fn memoize(map: hashmap<ty::t, str>, base_name: str,\n-               ty0: ty::t, mk_fn: fn(str)) -> str {\n-        // check for existing function\n-        alt map.find(ty0) {\n-          some(name) { ret name; }\n-          none { /* fallthrough */ }\n-        }\n-\n-        // define the name and insert into the hashtable\n-        // in case of recursive calls:\n-        let id = map.size();\n-        let name = #fmt[\"%s_%u\", base_name, id];\n-        map.insert(ty0, name);\n-        mk_fn(name);\n-        ret name;\n-    }\n-\n-    fn exec_named_item_fn(name: str, f: fn(ty::t) -> str) -> str {\n-        let names = str::split_str(name, \"::\");\n-        let item = lookup(self.crate.node.module, 0u, names);\n-        let def_id = {crate: ast::local_crate, node: item.id};\n-        let item_ty = self.instantiate(def_id, []);\n-        f(item_ty)\n-    }\n-}\n-\n-impl serialize_methods for serialize_ctx {\n-    // fn session() -> parser::parse_sess { self.psess }\n-\n-    fn mk_serialize_named_item_fn(name: str) -> str {\n-        self.exec_named_item_fn(name) {|item_ty|\n-            let fname = self.mk_serialize_ty_fn(item_ty);\n-\n-            let ty_str = ppaux::ty_to_str(self.tcx, item_ty);\n-            check str::is_not_empty(\"::\");\n-            let namep = str::replace(name, \"::\", \"_\");\n-            let item = #fmt[\"fn serialize_%s\\\n-                                 <S:std::serialization::serializer>\\n\\\n-                                 (s: S, v: %s) {\\n\\\n-                                   %s(s, v);\\n\\\n-                                 }\", namep, ty_str, fname];\n-            self.add_item(item);\n-\n-            fname\n-        }\n-    }\n-\n-    fn blk(stmts: [ast_stmt]) -> ast_blk {\n-        if vec::is_empty(stmts) {\n-            \"\"\n-        } else {\n-            \"{\" + str::connect(stmts, \";\") + \"}\"\n-        }\n-    }\n-\n-    fn blk_expr(stmts: [ast_stmt]) -> ast_expr {\n-        self.blk(stmts)\n-    }\n-\n-    // Generates a function to serialize the given type.\n-    // Returns an AST fragment that names this function.\n-    fn serialize_ty(ty0: ty::t, v: ast_expr) -> ast_expr {\n-        let fname = self.mk_serialize_ty_fn(ty0);\n-        let ty0_str = ppaux::ty_to_str(self.tcx, ty0);\n-        #fmt[\"/*%s*/ %s(s, %s)\", ty0_str, fname, v]\n-    }\n-\n-    fn mk_serialize_ty_fn(ty0: ty::t) -> str {\n-        self.memoize(self.serialize_tyfns, \"serialize\", ty0) {|name|\n-            self.mk_serialize_ty_fn0(ty0, name)\n-        }\n-    }\n-\n-    fn mk_serialize_ty_fn0(ty0: ty::t, name: str) {\n-        let ty0_str = ppaux::ty_to_str(self.tcx, ty0);\n-        let v = \"v\";\n-\n-        let body_node = alt ty::get(ty0).struct {\n-          ty::ty_nil | ty::ty_bot { \"()\" }\n-\n-          ty::ty_int(ast::ty_i)   { #fmt[\"\\ns.emit_int(%s)\\n\", v] }\n-          ty::ty_int(ast::ty_i64) { #fmt[\"\\ns.emit_i64(%s)\\n\", v] }\n-          ty::ty_int(ast::ty_i32) { #fmt[\"\\ns.emit_i32(%s)\\n\", v] }\n-          ty::ty_int(ast::ty_i16) { #fmt[\"\\ns.emit_i16(%s)\\n\", v] }\n-          ty::ty_int(ast::ty_i8)  { #fmt[\"\\ns.emit_i8(%s)\\n\", v]  }\n-\n-          ty::ty_int(ast::ty_char) { #fmt[\"\\ns.emit_i8(%s as i8)\\n\", v] }\n-\n-          ty::ty_uint(ast::ty_u)   { #fmt[\"\\ns.emit_uint(%s)\\n\", v] }\n-          ty::ty_uint(ast::ty_u64) { #fmt[\"\\ns.emit_u64(%s)\\n\", v] }\n-          ty::ty_uint(ast::ty_u32) { #fmt[\"\\ns.emit_u32(%s)\\n\", v] }\n-          ty::ty_uint(ast::ty_u16) { #fmt[\"\\ns.emit_u16(%s)\\n\", v] }\n-          ty::ty_uint(ast::ty_u8)  { #fmt[\"\\ns.emit_u8(%s)\\n\", v]  }\n-\n-          ty::ty_float(ast::ty_f64) { #fmt[\"\\ns.emit_f64(%s)\\n\", v] }\n-          ty::ty_float(ast::ty_f32) { #fmt[\"\\ns.emit_f32(%s)\\n\", v] }\n-          ty::ty_float(ast::ty_f)   { #fmt[\"\\ns.emit_float(%s)\\n\", v] }\n-\n-          ty::ty_bool { #fmt[\"\\ns.emit_bool(%s)\\n\", v] }\n-\n-          ty::ty_str { #fmt[\"\\ns.emit_str(%s)\\n\", v] }\n-\n-          ty::ty_enum(def_id, tps) { self.serialize_enum(v, def_id, tps) }\n-          ty::ty_box(mt) {\n-            let s = self.serialize_ty(mt.ty, #fmt[\"\\n*%s\\n\", v]);\n-            #fmt[\"\\ns.emit_box({||%s})\\n\", s]\n-          }\n-          ty::ty_uniq(mt) {\n-            let s = self.serialize_ty(mt.ty, #fmt[\"\\n*%s\\n\", v]);\n-            #fmt[\"\\ns.emit_uniq({||%s})\\n\", s]\n-          }\n-          ty::ty_vec(mt) {\n-            let selem = self.serialize_ty(mt.ty, \"e\");\n-            #fmt[\"\\ns.emit_vec(vec::len(v), {||\\n\\\n-                    vec::iteri(v, {|i, e|\\n\\\n-                      s.emit_vec_elt(i, {||\\n\\\n-                          %s\\n\\\n-                  })})})\\n\", selem]\n-          }\n-          ty::ty_class(_, _) {\n-            fail \"TODO--implement class\";\n-          }\n-          ty::ty_rec(fields) {\n-            let stmts = vec::from_fn(vec::len(fields)) {|i|\n-                let field = fields[i];\n-                let f_name = field.ident;\n-                let f_ty = field.mt.ty;\n-                let efld = self.serialize_ty(f_ty, #fmt[\"\\n%s.%s\\n\", v, f_name]);\n-                #fmt[\"\\ns.emit_rec_field(\\\"%s\\\", %uu, {||%s})\\n\",\n-                     f_name, i, efld]\n-            };\n-            #fmt[\"\\ns.emit_rec({||%s})\\n\", self.blk_expr(stmts)]\n-          }\n-          ty::ty_tup(tys) {\n-            let (pat, stmts) = self.serialize_arm(\"\", \"emit_tup_elt\", tys);\n-            #fmt[\"s.emit_tup(%uu, {|| alt %s { \\\n-                    %s %s \\\n-                  }})\", vec::len(tys), v, pat, self.blk_expr(stmts)]\n-          }\n-          ty::ty_constr(t, _) {\n-            self.serialize_ty(t, v)\n-          }\n-          ty::ty_ptr(_) |\n-          ty::ty_rptr(_,_) |\n-          ty::ty_fn(_) |\n-          ty::ty_iface(_, _) |\n-          ty::ty_res(_, _, _) |\n-          ty::ty_var(_) | ty::ty_param(_, _) |\n-          ty::ty_self(_) | ty::ty_type | ty::ty_send_type |\n-          ty::ty_opaque_closure_ptr(_) | ty::ty_opaque_box {\n-            fail #fmt[\"Unhandled type %s\", ty0_str]\n-          }\n-        };\n-\n-        let item = #fmt[\"/*%s*/ fn %s\\n\\\n-                         <S:std::serialization::serializer>\\n\\\n-                            (s: S,\\n\\\n-                            v: %s) {\\n\\\n-                             %s;\\n\\\n-                         }\", ty0_str, name, ty0_str, body_node];\n-        self.add_item(item);\n-    }\n-\n-    fn serialize_enum(v: ast_expr,\n-                      id: ast::def_id,\n-                      tps: [ty::t]) -> ast_expr {\n-        let variants = ty::substd_enum_variants(self.tcx, id, tps);\n-\n-        let idx = 0u;\n-        let arms = vec::map(variants) {|variant|\n-            let item_path = ty::item_path(self.tcx, variant.id);\n-            let v_path = ast_map::path_to_str(item_path);\n-            let n_args = vec::len(variant.args);\n-            let (v_pat, stmts) = {\n-                if n_args == 0u {\n-                    (v_path, [])\n-                } else {\n-                    self.serialize_arm(v_path, \"emit_enum_variant_arg\",\n-                                       variant.args)\n-                }\n-            };\n-\n-            let v_id = idx;\n-            idx += 1u;\n-\n-            #fmt[\"%s {\\n\\\n-                    s.emit_enum_variant(\\\"%s\\\", %uu, %uu, {||\\n\\\n-                      %s\\n\\\n-                    })\\n\\\n-                  }\", v_pat, v_path, v_id, n_args, self.blk(stmts)]\n-        };\n-\n-        let enum_name = ast_map::path_to_str(ty::item_path(self.tcx, id));\n-        #fmt[\"\\ns.emit_enum(\\\"%s\\\", {||\\n\\\n-                alt %s {\\n\\\n-                  %s\\n\\\n-                }\\n\\\n-              })\\n\", enum_name, v, str::connect(arms, \"\\n\")]\n-    }\n-\n-    fn serialize_arm(v_path: str, emit_fn: str, args: [ty::t])\n-        -> (ast_pat, [ast_stmt]) {\n-        let n_args = vec::len(args);\n-        let arg_nms = vec::from_fn(n_args) {|i| #fmt[\"v%u\", i] };\n-        let v_pat =\n-            #fmt[\"\\n%s(%s)\\n\", v_path, str::connect(arg_nms, \",\")];\n-        let stmts = vec::from_fn(n_args) {|i|\n-            let arg_ty = args[i];\n-            let serialize_expr =\n-                self.serialize_ty(arg_ty, arg_nms[i]);\n-            #fmt[\"\\ns.%s(%uu, {||\\n%s\\n})\\n\", emit_fn, i, serialize_expr]\n-        };\n-        (v_pat, stmts)\n-    }\n-}\n-\n-impl deserialize_methods for serialize_ctx {\n-    fn mk_deserialize_named_item_fn(name: str) -> str {\n-        self.exec_named_item_fn(name) {|item_ty|\n-            let fname = self.mk_deserialize_ty_fn(item_ty);\n-\n-            let ty_str = ppaux::ty_to_str(self.tcx, item_ty);\n-            check str::is_not_empty(\"::\");\n-            let namep = str::replace(name, \"::\", \"_\");\n-            let item = #fmt[\"fn deserialize_%s\\\n-                                 <S:std::serialization::deserializer>\\n\\\n-                                 (s: S) -> %s {\\n\\\n-                                   %s(s)\\\n-                                 }\", namep, ty_str, fname];\n-            self.add_item(item);\n-\n-            fname\n-        }\n-    }\n-\n-    // Generates a function to serialize the given type.\n-    // Returns an AST fragment that names this function.\n-    fn deserialize_ty(ty0: ty::t) -> ast_expr {\n-        let fname = self.mk_deserialize_ty_fn(ty0);\n-        let ty0_str = ppaux::ty_to_str(self.tcx, ty0);\n-        #fmt[\"\\n/*%s*/ %s(s)\\n\", ty0_str, fname]\n-    }\n-\n-    fn mk_deserialize_ty_fn(ty0: ty::t) -> str {\n-        self.memoize(self.deserialize_tyfns, \"deserialize\", ty0) {|name|\n-            self.mk_deserialize_ty_fn0(ty0, name)\n-        }\n-    }\n-\n-    fn mk_deserialize_ty_fn0(ty0: ty::t, name: str) {\n-        let ty0_str = ppaux::ty_to_str(self.tcx, ty0);\n-        let body_node = alt ty::get(ty0).struct {\n-          ty::ty_nil | ty::ty_bot { \"()\" }\n-\n-          ty::ty_int(ast::ty_i)   { #fmt[\"s.read_int()\"] }\n-          ty::ty_int(ast::ty_i64) { #fmt[\"s.read_i64()\"] }\n-          ty::ty_int(ast::ty_i32) { #fmt[\"s.read_i32()\"] }\n-          ty::ty_int(ast::ty_i16) { #fmt[\"s.read_i16()\"] }\n-          ty::ty_int(ast::ty_i8)  { #fmt[\"s.read_i8()\"]  }\n-\n-          ty::ty_int(ast::ty_char) { #fmt[\"s.read_char()\"] }\n-\n-          ty::ty_uint(ast::ty_u)   { #fmt[\"s.read_uint()\"] }\n-          ty::ty_uint(ast::ty_u64) { #fmt[\"s.read_u64()\"] }\n-          ty::ty_uint(ast::ty_u32) { #fmt[\"s.read_u32()\"] }\n-          ty::ty_uint(ast::ty_u16) { #fmt[\"s.read_u16()\"] }\n-          ty::ty_uint(ast::ty_u8)  { #fmt[\"s.read_u8()\"]  }\n-\n-          ty::ty_float(ast::ty_f64) { #fmt[\"s.read_f64()\"] }\n-          ty::ty_float(ast::ty_f32) { #fmt[\"s.read_f32()\"] }\n-          ty::ty_float(ast::ty_f)   { #fmt[\"s.read_float()\"] }\n-\n-          ty::ty_bool { #fmt[\"s.read_bool()\"] }\n-\n-          ty::ty_str { #fmt[\"s.read_str()\"] }\n-\n-          ty::ty_enum(def_id, tps) { self.deserialize_enum(def_id, tps) }\n-          ty::ty_box(mt) {\n-            let s = self.deserialize_ty(mt.ty);\n-            #fmt[\"\\ns.read_box({||@%s})\\n\", s]\n-          }\n-          ty::ty_uniq(mt) {\n-            let s = self.deserialize_ty(mt.ty);\n-            #fmt[\"\\ns.read_uniq({||~%s})\\n\", s]\n-          }\n-          ty::ty_vec(mt) {\n-            let selem = self.deserialize_ty(mt.ty);\n-            #fmt[\"s.read_vec({|len|\\n\\\n-                    vec::from_fn(len, {|i|\\n\\\n-                      s.read_vec_elt(i, {||\\n\\\n-                        %s\\n\\\n-                  })})})\", selem]\n-          }\n-          ty::ty_class(_, _) {\n-            fail \"TODO--implement class\";\n-          }\n-          ty::ty_rec(fields) {\n-            let i = 0u;\n-            let flds = vec::map(fields) {|field|\n-                let f_name = field.ident;\n-                let f_ty = field.mt.ty;\n-                let rfld = self.deserialize_ty(f_ty);\n-                let idx = i;\n-                i += 1u;\n-                #fmt[\"\\n%s: s.read_rec_field(\\\"%s\\\", %uu, {||\\n%s\\n})\\n\",\n-                     f_name, f_name, idx, rfld]\n-            };\n-            #fmt[\"\\ns.read_rec({||{\\n%s\\n}})\\n\", str::connect(flds, \",\")]\n-          }\n-          ty::ty_tup(tys) {\n-            let rexpr = self.deserialize_arm(\"\", \"read_tup_elt\", tys);\n-            #fmt[\"\\ns.read_tup(%uu, {||\\n%s\\n})\\n\", vec::len(tys), rexpr]\n-          }\n-          ty::ty_constr(t, _) {\n-            self.deserialize_ty(t)\n-          }\n-          ty::ty_ptr(_) |\n-          ty::ty_rptr(_,_) |\n-          ty::ty_fn(_) |\n-          ty::ty_iface(_, _) |\n-          ty::ty_res(_, _, _) |\n-          ty::ty_var(_) | ty::ty_param(_, _) |\n-          ty::ty_self(_) | ty::ty_type | ty::ty_send_type |\n-          ty::ty_opaque_closure_ptr(_) | ty::ty_opaque_box {\n-            fail #fmt[\"Unhandled type %s\", ty0_str]\n-          }\n-        };\n-\n-        let item = #fmt[\"/*%s*/\\n\\\n-                         fn %s\\n\\\n-                         <S:std::serialization::deserializer>(s: S)\\n\\\n-                         -> %s {\\n\\\n-                             %s\\n\\\n-                         }\", ty0_str, name, ty0_str, body_node];\n-        self.add_item(item);\n-    }\n-\n-    fn deserialize_enum(id: ast::def_id,\n-                        tps: [ty::t]) -> ast_expr {\n-        let variants = ty::substd_enum_variants(self.tcx, id, tps);\n-\n-        let arms = vec::from_fn(vec::len(variants)) {|v_id|\n-            let variant = variants[v_id];\n-            let item_path = ty::item_path(self.tcx, variant.id);\n-            let v_path = ast_map::path_to_str(item_path);\n-            let n_args = vec::len(variant.args);\n-            let rexpr = {\n-                if n_args == 0u {\n-                    #fmt[\"\\n%s\\n\", v_path]\n-                } else {\n-                    self.deserialize_arm(v_path, \"read_enum_variant_arg\",\n-                                         variant.args)\n-                }\n-            };\n-\n-            #fmt[\"\\n%uu { %s }\\n\", v_id, rexpr]\n-        };\n-\n-        let enum_name = ast_map::path_to_str(ty::item_path(self.tcx, id));\n-        #fmt[\"s.read_enum(\\\"%s\\\", {||\\n\\\n-                s.read_enum_variant({|v_id|\\n\\\n-                  alt check v_id {\\n\\\n-                    %s\\n\\\n-                  }\\n\\\n-                })})\", enum_name, str::connect(arms, \"\\n\")]\n-    }\n-\n-    fn deserialize_arm(v_path: str, read_fn: str, args: [ty::t])\n-        -> ast_expr {\n-        let exprs = vec::from_fn(vec::len(args)) {|i|\n-            let rexpr = self.deserialize_ty(args[i]);\n-            #fmt[\"\\ns.%s(%uu, {||%s})\\n\", read_fn, i, rexpr]\n-        };\n-        #fmt[\"\\n%s(%s)\\n\", v_path, str::connect(exprs, \",\")]\n-    }\n-}\n-\n-fn main(argv: [str]) {\n-    let {crate, tcx, roots} = parse(argv);\n-    let sctx: serialize_ctx = {\n-        // let cm = codemap::new_codemap();\n-        // let handler = diagnostic::mk_handler(option::none);\n-        // let psess: parser::parse_sess = @{\n-        //     cm: cm,\n-        //     mutable next_id: 1,\n-        //     span_diagnostic: diagnostic::mk_span_handler(handler, cm),\n-        //     mutable chpos: 0u,\n-        //     mutable byte_pos: 0u\n-        // };\n-        {crate: crate,\n-         tcx: tcx,\n-         serialize_tyfns: ty::new_ty_hash::<str>(),\n-         deserialize_tyfns: ty::new_ty_hash::<str>(),\n-         mutable item_fns: [],\n-         mutable constants: []}\n-    };\n-\n-    vec::iter(roots) {|root|\n-        sctx.mk_serialize_named_item_fn(root);\n-        sctx.mk_deserialize_named_item_fn(root);\n-    }\n-\n-    let stdout = io::stdout();\n-    vec::iter(copy sctx.item_fns) {|item|\n-        stdout.write_str(#fmt[\"%s\\n\", item])\n-    }\n-}"}, {"sha": "b1d255f49397d4027cc3c14db9f6a31e938e483b", "filename": "src/serializer/stest.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Fserializer%2Fstest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca3393fa6459da14151b22f403b3f3b8dada55/src%2Fserializer%2Fstest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fserializer%2Fstest.rs?ref=3dca3393fa6459da14151b22f403b3f3b8dada55", "patch": "@@ -1,40 +0,0 @@\n-// Testing types for the serializer.  This should be made more formal.\n-\n-enum test1 {\n-    t1_a(int), t1_b(str)\n-}\n-\n-type test2 = {\n-    f: int, g: str\n-};\n-\n-enum test3 {\n-    t3_a, t3_b\n-}\n-\n-enum test4 {\n-    t4_a(test1), t4_b(test2), t4_c(@test2), t4_d(@test4)\n-}\n-\n-type spanned<A> = {\n-    node: A,\n-    span: { lo: uint, hi: uint }\n-};\n-\n-type test5 = {\n-    s1: spanned<test4>,\n-    s2: spanned<uint>\n-};\n-\n-type test6 = option<int>;\n-\n-mod test7 {\n-    enum testa {\n-    }\n-\n-    enum testb {\n-        t4_a(@testa), t4_b(@testb)\n-    }\n-}\n-\n-fn main() {}\n\\ No newline at end of file"}]}