{"sha": "351a5fd2b40c2be90f94fe2580903e93353b95ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1MWE1ZmQyYjQwYzJiZTkwZjk0ZmUyNTgwOTAzZTkzMzUzYjk1ZWU=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-06-27T20:10:47Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-06-28T05:10:43Z"}, "message": "added unit and standalone test for 15221, extra debugging output", "tree": {"sha": "cfc95b2777ecde0f29b6517490c11b34658a129a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfc95b2777ecde0f29b6517490c11b34658a129a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/351a5fd2b40c2be90f94fe2580903e93353b95ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/351a5fd2b40c2be90f94fe2580903e93353b95ee", "html_url": "https://github.com/rust-lang/rust/commit/351a5fd2b40c2be90f94fe2580903e93353b95ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/351a5fd2b40c2be90f94fe2580903e93353b95ee/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e100d26d1d779b4759f3f754b03a35755cb89b84", "url": "https://api.github.com/repos/rust-lang/rust/commits/e100d26d1d779b4759f3f754b03a35755cb89b84", "html_url": "https://github.com/rust-lang/rust/commit/e100d26d1d779b4759f3f754b03a35755cb89b84"}], "stats": {"total": 53, "additions": 48, "deletions": 5}, "files": [{"sha": "0a8ec5bc40eabf2b07cc4ebd2f4119a613d67c16", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/351a5fd2b40c2be90f94fe2580903e93353b95ee/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/351a5fd2b40c2be90f94fe2580903e93353b95ee/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=351a5fd2b40c2be90f94fe2580903e93353b95ee", "patch": "@@ -54,7 +54,6 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n                     }\n                     let extname = pth.segments.get(0).identifier;\n                     let extnamestr = token::get_ident(extname);\n-                    // leaving explicit deref here to highlight unbox op:\n                     let marked_after = match fld.extsbox.find(&extname.name) {\n                         None => {\n                             fld.cx.span_err(\n@@ -1294,6 +1293,19 @@ mod test {\n             0)\n     }\n \n+    // FIXME #15221, somehow pats aren't getting labeled correctly?\n+    // should expand into\n+    // fn main(){let g1_1 = 13; g1_1}}\n+    #[test] fn pat_expand_issue_15221(){\n+        run_renaming_test(\n+            &(\"macro_rules! inner ( ($e:pat ) => ($e))\n+              macro_rules! outer ( ($e:pat ) => (inner!($e)))\n+              fn main() { let outer!(g) = 13; g;}\",\n+              vec!(vec!(0)),\n+              true),\n+            0)\n+    }\n+\n     // create a really evil test case where a $x appears inside a binding of $x\n     // but *shouldnt* bind because it was inserted by a different macro....\n     // can't write this test case until we have macro-generating macros.\n@@ -1343,9 +1355,13 @@ mod test {\n                                                            .ctxt,\n                                                      invalid_name);\n                     if !(varref_name==binding_name) {\n+                        let varref_idents : Vec<ast::Ident>\n+                            = varref.segments.iter().map(|s|\n+                                                         s.identifier)\n+                            .collect();\n                         println!(\"uh oh, should match but doesn't:\");\n-                        println!(\"varref #{:?}: {:?}\",idx, varref);\n-                        println!(\"binding #{:?}: {:?}\", binding_idx, *bindings.get(binding_idx));\n+                        println!(\"varref #{}: {}\",idx, varref_idents);\n+                        println!(\"binding #{}: {}\", binding_idx, *bindings.get(binding_idx));\n                         mtwt::with_sctable(|x| mtwt::display_sctable(x));\n                     }\n                     assert_eq!(varref_name,binding_name);\n@@ -1360,19 +1376,23 @@ mod test {\n                             == binding_name);\n                     // temp debugging:\n                     if fail {\n+                        let varref_idents : Vec<ast::Ident>\n+                            = varref.segments.iter().map(|s|\n+                                                         s.identifier)\n+                            .collect();\n                         println!(\"failure on test {}\",test_idx);\n                         println!(\"text of test case: \\\"{}\\\"\", teststr);\n                         println!(\"\");\n                         println!(\"uh oh, matches but shouldn't:\");\n-                        println!(\"varref: {:?}\",varref);\n+                        println!(\"varref: {}\",varref_idents);\n                         // good lord, you can't make a path with 0 segments, can you?\n                         let string = token::get_ident(varref.segments\n                                                             .get(0)\n                                                             .identifier);\n                         println!(\"varref's first segment's uint: {}, and string: \\\"{}\\\"\",\n                                  varref.segments.get(0).identifier.name,\n                                  string.get());\n-                        println!(\"binding: {:?}\", *bindings.get(binding_idx));\n+                        println!(\"binding: {}\", *bindings.get(binding_idx));\n                         mtwt::with_sctable(|x| mtwt::display_sctable(x));\n                     }\n                     assert!(!fail);\n@@ -1442,5 +1462,6 @@ foo_module!()\n         assert_eq!(idents, strs_to_idents(vec!(\"a\",\"b\",\"None\",\"i\",\"i\",\"z\",\"y\")));\n     }\n \n+    //\n \n }"}, {"sha": "e74ba9b85ee06643090a8983ac807d911735253d", "filename": "src/test/run-pass/issue-15221.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/351a5fd2b40c2be90f94fe2580903e93353b95ee/src%2Ftest%2Frun-pass%2Fissue-15221.rs", "raw_url": "https://github.com/rust-lang/rust/raw/351a5fd2b40c2be90f94fe2580903e93353b95ee/src%2Ftest%2Frun-pass%2Fissue-15221.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15221.rs?ref=351a5fd2b40c2be90f94fe2580903e93353b95ee", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(macro_rules)]\n+\n+macro_rules! inner_bind (\n+    ( $p:pat, $id:ident) => ({let $p = 13; $id}))\n+\n+macro_rules! outer_bind (\n+    ($p:pat, $id:ident ) => (inner_bind!($p, $id)))\n+\n+fn main() {\n+    outer_bind!(g1,g1);\n+}\n+"}]}