{"sha": "521d91c6be76367d966df419677dd187f799b116", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMWQ5MWM2YmU3NjM2N2Q5NjZkZjQxOTY3N2RkMTg3Zjc5OWIxMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-14T20:59:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-14T20:59:09Z"}, "message": "Auto merge of #49008 - kennytm:rollup, r=kennytm\n\nRollup of 12 pull requests\n\n- Successful merges: #48765, #48831, #48840, #48964, #48970, #48971, #48981, #48988, #48991, #48966, #48993, #48874\n- Failed merges:", "tree": {"sha": "e920a8cdae1d44869edf61ad9fa00358755700f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e920a8cdae1d44869edf61ad9fa00358755700f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/521d91c6be76367d966df419677dd187f799b116", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/521d91c6be76367d966df419677dd187f799b116", "html_url": "https://github.com/rust-lang/rust/commit/521d91c6be76367d966df419677dd187f799b116", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/521d91c6be76367d966df419677dd187f799b116/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e96e54d3d4973b5ac847ad53aaa2598cfc58be64", "url": "https://api.github.com/repos/rust-lang/rust/commits/e96e54d3d4973b5ac847ad53aaa2598cfc58be64", "html_url": "https://github.com/rust-lang/rust/commit/e96e54d3d4973b5ac847ad53aaa2598cfc58be64"}, {"sha": "beab2e6608810ab43312f61fe226f187d017416d", "url": "https://api.github.com/repos/rust-lang/rust/commits/beab2e6608810ab43312f61fe226f187d017416d", "html_url": "https://github.com/rust-lang/rust/commit/beab2e6608810ab43312f61fe226f187d017416d"}], "stats": {"total": 812, "additions": 266, "deletions": 546}, "files": [{"sha": "cc7b15812ec34f2da7bb3fe7fad09665a9e14136", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -19,15 +19,19 @@ running `rustdoc --test foo.rs` will extract this example, and then run it as a\n Please note that by default, if no language is set for the block code, `rustdoc`\n assumes it is `Rust` code. So the following:\n \n+``````markdown\n ```rust\n let x = 5;\n ```\n+``````\n \n is strictly equivalent to:\n \n+``````markdown\n ```\n let x = 5;\n ```\n+``````\n \n There's some subtlety though! Read on for more details.\n "}, {"sha": "13db6d5d659c991cf9348d641e8d195b6ff4be3d", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 134, "deletions": 2, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -1379,27 +1379,159 @@ impl<'a> Formatter<'a> {\n         }\n     }\n \n-    /// Optionally specified integer width that the output should be\n+    /// Optionally specified integer width that the output should be.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if let Some(width) = formatter.width() {\n+    ///             // If we received a width, we use it\n+    ///             write!(formatter, \"{:width$}\", &format!(\"Foo({})\", self.0), width = width)\n+    ///         } else {\n+    ///             // Otherwise we do nothing special\n+    ///             write!(formatter, \"Foo({})\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:10}\", Foo(23)), \"Foo(23)   \");\n+    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn width(&self) -> Option<usize> { self.width }\n \n-    /// Optionally specified precision for numeric types\n+    /// Optionally specified precision for numeric types.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(f32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if let Some(precision) = formatter.precision() {\n+    ///             // If we received a precision, we use it.\n+    ///             write!(formatter, \"Foo({1:.*})\", precision, self.0)\n+    ///         } else {\n+    ///             // Otherwise we default to 2.\n+    ///             write!(formatter, \"Foo({:.2})\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:.4}\", Foo(23.2)), \"Foo(23.2000)\");\n+    /// assert_eq!(&format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn precision(&self) -> Option<usize> { self.precision }\n \n     /// Determines if the `+` flag was specified.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if formatter.sign_plus() {\n+    ///             write!(formatter,\n+    ///                    \"Foo({}{})\",\n+    ///                    if self.0 < 0 { '-' } else { '+' },\n+    ///                    self.0)\n+    ///         } else {\n+    ///             write!(formatter, \"Foo({})\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:+}\", Foo(23)), \"Foo(+23)\");\n+    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_plus(&self) -> bool { self.flags & (1 << FlagV1::SignPlus as u32) != 0 }\n \n     /// Determines if the `-` flag was specified.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if formatter.sign_minus() {\n+    ///             // You want a minus sign? Have one!\n+    ///             write!(formatter, \"-Foo({})\", self.0)\n+    ///         } else {\n+    ///             write!(formatter, \"Foo({})\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:-}\", Foo(23)), \"-Foo(23)\");\n+    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_minus(&self) -> bool { self.flags & (1 << FlagV1::SignMinus as u32) != 0 }\n \n     /// Determines if the `#` flag was specified.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         if formatter.alternate() {\n+    ///             write!(formatter, \"Foo({})\", self.0)\n+    ///         } else {\n+    ///             write!(formatter, \"{}\", self.0)\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:#}\", Foo(23)), \"Foo(23)\");\n+    /// assert_eq!(&format!(\"{}\", Foo(23)), \"23\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn alternate(&self) -> bool { self.flags & (1 << FlagV1::Alternate as u32) != 0 }\n \n     /// Determines if the `0` flag was specified.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(i32);\n+    ///\n+    /// impl fmt::Display for Foo {\n+    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///         assert!(formatter.sign_aware_zero_pad());\n+    ///         assert_eq!(formatter.width(), Some(4));\n+    ///         // We ignore the formatter's options.\n+    ///         write!(formatter, \"{}\", self.0)\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(&format!(\"{:04}\", Foo(23)), \"23\");\n+    /// ```\n     #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n     pub fn sign_aware_zero_pad(&self) -> bool {\n         self.flags & (1 << FlagV1::SignAwareZeroPad as u32) != 0"}, {"sha": "f77275926eba37477648a5dd8a7bca8d94868173", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -13,6 +13,7 @@ use dep_graph::{DepGraph, DepKind, DepNodeIndex};\n use hir::def_id::{LOCAL_CRATE, CrateNum};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::svh::Svh;\n+use ich::Fingerprint;\n use middle::cstore::CrateStore;\n use session::CrateDisambiguator;\n use std::iter::repeat;\n@@ -121,21 +122,24 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         collector\n     }\n \n-    pub(super) fn finalize_and_compute_crate_hash(self,\n+    pub(super) fn finalize_and_compute_crate_hash(mut self,\n                                                   crate_disambiguator: CrateDisambiguator,\n                                                   cstore: &dyn CrateStore,\n                                                   codemap: &CodeMap,\n                                                   commandline_args_hash: u64)\n                                                   -> (Vec<MapEntry<'hir>>, Svh) {\n-        let mut node_hashes: Vec<_> = self\n+        self\n             .hir_body_nodes\n-            .iter()\n-            .map(|&(def_path_hash, dep_node_index)| {\n-                (def_path_hash, self.dep_graph.fingerprint_of(dep_node_index))\n-            })\n-            .collect();\n+            .sort_unstable_by(|&(ref d1, _), &(ref d2, _)| d1.cmp(d2));\n \n-        node_hashes.sort_unstable_by(|&(ref d1, _), &(ref d2, _)| d1.cmp(d2));\n+        let node_hashes = self\n+            .hir_body_nodes\n+            .iter()\n+            .fold(Fingerprint::ZERO, |fingerprint , &(def_path_hash, dep_node_index)| {\n+                fingerprint.combine(\n+                    def_path_hash.0.combine(self.dep_graph.fingerprint_of(dep_node_index))\n+                )\n+            });\n \n         let mut upstream_crates: Vec<_> = cstore.crates_untracked().iter().map(|&cnum| {\n             let name = cstore.crate_name_untracked(cnum).as_str();"}, {"sha": "736d7f8a1396b8c0a71b44a58ebf71384794fb68", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -1641,7 +1641,7 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n         opt::multi_s(\n             \"\",\n             \"remap-path-prefix\",\n-            \"remap source names in output\",\n+            \"Remap source names in all output (compiler messages and output files)\",\n             \"FROM=TO\",\n         ),\n     ]);"}, {"sha": "cffd1daed99f28bc7a5a0adf560d052b98cda8b3", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -25,7 +25,7 @@ pub fn target() -> TargetResult {\n         linker_flavor: LinkerFlavor::Gcc,\n         options: TargetOptions {\n             cpu: \"mips32r2\".to_string(),\n-            features: \"+mips32r2\".to_string(),\n+            features: \"+mips32r2,+fpxx,+nooddspreg\".to_string(),\n             max_atomic_width: Some(32),\n \n             // see #36994"}, {"sha": "555855b8f815ddea8dc971a62fc2a54f60b60896", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -25,8 +25,8 @@ pub fn target() -> TargetResult {\n         linker_flavor: LinkerFlavor::Gcc,\n \n         options: TargetOptions {\n-            cpu: \"mips32\".to_string(),\n-            features: \"+mips32\".to_string(),\n+            cpu: \"mips32r2\".to_string(),\n+            features: \"+mips32r2,+fpxx,+nooddspreg\".to_string(),\n             max_atomic_width: Some(32),\n \n             // see #36994"}, {"sha": "6bef2fe2ea717eb0cbb88452c17179d1de62bfed", "filename": "src/librustc_back/target/mipsel_unknown_linux_musl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -13,8 +13,8 @@ use target::{Target, TargetResult};\n \n pub fn target() -> TargetResult {\n     let mut base = super::linux_musl_base::opts();\n-    base.cpu = \"mips32\".to_string();\n-    base.features = \"+mips32,+soft-float\".to_string();\n+    base.cpu = \"mips32r2\".to_string();\n+    base.features = \"+mips32r2,+soft-float\".to_string();\n     base.max_atomic_width = Some(32);\n     // see #36994\n     base.exe_allocation_crate = None;"}, {"sha": "a5dbdd111835976abf0112af111da65a48dd7a08", "filename": "src/librustc_back/target/mipsel_unknown_linux_uclibc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -25,8 +25,8 @@ pub fn target() -> TargetResult {\n         linker_flavor: LinkerFlavor::Gcc,\n \n         options: TargetOptions {\n-            cpu: \"mips32\".to_string(),\n-            features: \"+mips32,+soft-float\".to_string(),\n+            cpu: \"mips32r2\".to_string(),\n+            features: \"+mips32r2,+soft-float\".to_string(),\n             max_atomic_width: Some(32),\n \n             // see #36994"}, {"sha": "7ab6a2691488ed148aa388b2478470ef7a1d89ff", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -224,70 +224,6 @@ impl<T: Idx> IdxSet<T> {\n             _pd: PhantomData,\n         }\n     }\n-\n-    /// Calls `f` on each index value held in this set, up to the\n-    /// bound `max_bits` on the size of universe of indexes.\n-    pub fn each_bit<F>(&self, max_bits: usize, f: F) where F: FnMut(T) {\n-        each_bit(self, max_bits, f)\n-    }\n-\n-    /// Removes all elements from this set.\n-    pub fn reset_to_empty(&mut self) {\n-        for word in self.words_mut() { *word = 0; }\n-    }\n-\n-    pub fn elems(&self, universe_size: usize) -> Elems<T> {\n-        Elems { i: 0, set: self, universe_size: universe_size }\n-    }\n-}\n-\n-pub struct Elems<'a, T: Idx> { i: usize, set: &'a IdxSet<T>, universe_size: usize }\n-\n-impl<'a, T: Idx> Iterator for Elems<'a, T> {\n-    type Item = T;\n-    fn next(&mut self) -> Option<T> {\n-        if self.i >= self.universe_size { return None; }\n-        let mut i = self.i;\n-        loop {\n-            if i >= self.universe_size {\n-                self.i = i; // (mark iteration as complete.)\n-                return None;\n-            }\n-            if self.set.contains(&T::new(i)) {\n-                self.i = i + 1; // (next element to start at.)\n-                return Some(T::new(i));\n-            }\n-            i = i + 1;\n-        }\n-    }\n-}\n-\n-fn each_bit<T: Idx, F>(words: &IdxSet<T>, max_bits: usize, mut f: F) where F: FnMut(T) {\n-    let usize_bits: usize = mem::size_of::<usize>() * 8;\n-\n-    for (word_index, &word) in words.words().iter().enumerate() {\n-        if word != 0 {\n-            let base_index = word_index * usize_bits;\n-            for offset in 0..usize_bits {\n-                let bit = 1 << offset;\n-                if (word & bit) != 0 {\n-                    // NB: we round up the total number of bits\n-                    // that we store in any given bit set so that\n-                    // it is an even multiple of usize::BITS. This\n-                    // means that there may be some stray bits at\n-                    // the end that do not correspond to any\n-                    // actual value; that's why we first check\n-                    // that we are in range of bits_per_block.\n-                    let bit_index = base_index + offset as usize;\n-                    if bit_index >= max_bits {\n-                        return;\n-                    } else {\n-                        f(Idx::new(bit_index));\n-                    }\n-                }\n-            }\n-        }\n-    }\n }\n \n pub struct Iter<'a, T: Idx> {"}, {"sha": "5a1983bfec64f16a8160f70c19da08fd3b70a35b", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -1147,6 +1147,15 @@ fn usage(verbose: bool, include_unstable_options: bool) {\n              verbose_help);\n }\n \n+fn print_wall_help() {\n+    println!(\"\n+The flag `-Wall` does not exist in `rustc`. Most useful lints are enabled by\n+default. Use `rustc -W help` to see all available lints. It's more common to put\n+warning settings in the crate root using `#![warn(LINT_NAME)]` instead of using\n+the command line flag directly.\n+\");\n+}\n+\n fn describe_lints(sess: &Session, lint_store: &lint::LintStore, loaded_plugins: bool) {\n     println!(\"\n Available lint options:\n@@ -1391,6 +1400,13 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n         return None;\n     }\n \n+    // Handle the special case of -Wall.\n+    let wall = matches.opt_strs(\"W\");\n+    if wall.iter().any(|x| *x == \"all\") {\n+        print_wall_help();\n+        return None;\n+    }\n+\n     // Don't handle -W help here, because we might first load plugins.\n     let r = matches.opt_strs(\"Z\");\n     if r.iter().any(|x| *x == \"help\") {\n@@ -1468,6 +1484,12 @@ fn extra_compiler_flags() -> Option<(Vec<String>, bool)> {\n         args.push(arg.to_string_lossy().to_string());\n     }\n \n+    // Avoid printing help because of empty args. This can suggest the compiler\n+    // itself is not the program root (consider RLS).\n+    if args.len() < 2 {\n+        return None;\n+    }\n+\n     let matches = if let Some(matches) = handle_options(&args) {\n         matches\n     } else {"}, {"sha": "6e1a798910dc6d6e16dd5f14cddea6454334cd8d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -530,7 +530,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                     // Look for any active borrows to locals\n                     let domain = flow_state.borrows.operator();\n                     let data = domain.borrows();\n-                    flow_state.borrows.with_elems_outgoing(|borrows| {\n+                    flow_state.borrows.with_iter_outgoing(|borrows| {\n                         for i in borrows {\n                             let borrow = &data[i.borrow_index()];\n                             self.check_for_local_borrow(borrow, span);\n@@ -546,7 +546,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // so this \"extra check\" serves as a kind of backup.\n                 let domain = flow_state.borrows.operator();\n                 let data = domain.borrows();\n-                flow_state.borrows.with_elems_outgoing(|borrows| {\n+                flow_state.borrows.with_iter_outgoing(|borrows| {\n                     for i in borrows {\n                         let borrow = &data[i.borrow_index()];\n                         let context = ContextKind::StorageDead.new(loc);\n@@ -1292,7 +1292,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             place\n         );\n \n-        for i in flow_state.ever_inits.elems_incoming() {\n+        for i in flow_state.ever_inits.iter_incoming() {\n             let init = self.move_data.inits[i];\n             let init_place = &self.move_data.move_paths[init.path].place;\n             if self.places_conflict(&init_place, place, Deep) {\n@@ -2129,8 +2129,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // check for loan restricting path P being used. Accounts for\n         // borrows of P, P.a.b, etc.\n-        let mut elems_incoming = flow_state.borrows.elems_incoming();\n-        while let Some(i) = elems_incoming.next() {\n+        let mut iter_incoming = flow_state.borrows.iter_incoming();\n+        while let Some(i) = iter_incoming.next() {\n             let borrowed = &data[i.borrow_index()];\n \n             if self.places_conflict(&borrowed.borrowed_place, place, access) {"}, {"sha": "0fbb54e8e0a089abb88178c82b1b9b3cf4b58343", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -12,7 +12,7 @@\n //! locations.\n \n use rustc::mir::{BasicBlock, Location};\n-use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n+use rustc_data_structures::indexed_set::{IdxSetBuf, Iter};\n use rustc_data_structures::indexed_vec::Idx;\n \n use dataflow::{BitDenotation, BlockSets, DataflowResults};\n@@ -81,8 +81,7 @@ where\n     where\n         F: FnMut(BD::Idx),\n     {\n-        self.curr_state\n-            .each_bit(self.base_results.operator().bits_per_block(), f)\n+        self.curr_state.iter().for_each(f)\n     }\n \n     /// Iterate over each `gen` bit in the current effect (invoke\n@@ -92,8 +91,7 @@ where\n     where\n         F: FnMut(BD::Idx),\n     {\n-        self.stmt_gen\n-            .each_bit(self.base_results.operator().bits_per_block(), f)\n+        self.stmt_gen.iter().for_each(f)\n     }\n \n     pub fn new(results: DataflowResults<BD>) -> Self {\n@@ -119,23 +117,21 @@ where\n     }\n \n     /// Returns an iterator over the elements present in the current state.\n-    pub fn elems_incoming(&self) -> iter::Peekable<indexed_set::Elems<BD::Idx>> {\n-        let univ = self.base_results.sets().bits_per_block();\n-        self.curr_state.elems(univ).peekable()\n+    pub fn iter_incoming(&self) -> iter::Peekable<Iter<BD::Idx>> {\n+        self.curr_state.iter().peekable()\n     }\n \n     /// Creates a clone of the current state and applies the local\n     /// effects to the clone (leaving the state of self intact).\n     /// Invokes `f` with an iterator over the resulting state.\n-    pub fn with_elems_outgoing<F>(&self, f: F)\n+    pub fn with_iter_outgoing<F>(&self, f: F)\n     where\n-        F: FnOnce(indexed_set::Elems<BD::Idx>),\n+        F: FnOnce(Iter<BD::Idx>),\n     {\n         let mut curr_state = self.curr_state.clone();\n         curr_state.union(&self.stmt_gen);\n         curr_state.subtract(&self.stmt_kill);\n-        let univ = self.base_results.sets().bits_per_block();\n-        f(curr_state.elems(univ));\n+        f(curr_state.iter());\n     }\n }\n \n@@ -147,8 +143,8 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n     }\n \n     fn reconstruct_statement_effect(&mut self, loc: Location) {\n-        self.stmt_gen.reset_to_empty();\n-        self.stmt_kill.reset_to_empty();\n+        self.stmt_gen.clear();\n+        self.stmt_kill.clear();\n         {\n             let mut sets = BlockSets {\n                 on_entry: &mut self.curr_state,\n@@ -172,8 +168,8 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n     }\n \n     fn reconstruct_terminator_effect(&mut self, loc: Location) {\n-        self.stmt_gen.reset_to_empty();\n-        self.stmt_kill.reset_to_empty();\n+        self.stmt_gen.clear();\n+        self.stmt_kill.clear();\n         {\n             let mut sets = BlockSets {\n                 on_entry: &mut self.curr_state,"}, {"sha": "74e41ef9c93ee31183973870459c0c3a035e252b", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -444,8 +444,7 @@ pub struct DataflowState<O: BitDenotation>\n impl<O: BitDenotation> DataflowState<O> {\n     pub fn each_bit<F>(&self, words: &IdxSet<O::Idx>, f: F) where F: FnMut(O::Idx)\n     {\n-        let bits_per_block = self.operator.bits_per_block();\n-        words.each_bit(bits_per_block, f)\n+        words.iter().for_each(f)\n     }\n \n     pub(crate) fn interpret_set<'c, P>(&self,"}, {"sha": "a5649e98baa76c6f03f0cd8f3d296cbfff37d97d", "filename": "src/librustc_trans/back/command.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_trans%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_trans%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fcommand.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -132,6 +132,13 @@ impl Command {\n             return false\n         }\n \n+        // Right now LLD doesn't support the `@` syntax of passing an argument\n+        // through files, so regardless of the platform we try to go to the OS\n+        // on this one.\n+        if let Program::Lld(..) = self.program {\n+            return false\n+        }\n+\n         // Ok so on Windows to spawn a process is 32,768 characters in its\n         // command line [1]. Unfortunately we don't actually have access to that\n         // as it's calculated just before spawning. Instead we perform a"}, {"sha": "bdda7741221f5e288567361807010c1f01b720a6", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -827,11 +827,14 @@ fn exec_linker(sess: &Session, cmd: &mut Command, tmpdir: &Path)\n     if !cmd.very_likely_to_exceed_some_spawn_limit() {\n         match cmd.command().stdout(Stdio::piped()).stderr(Stdio::piped()).spawn() {\n             Ok(child) => return child.wait_with_output(),\n-            Err(ref e) if command_line_too_big(e) => {}\n+            Err(ref e) if command_line_too_big(e) => {\n+                info!(\"command line to linker was too big: {}\", e);\n+            }\n             Err(e) => return Err(e)\n         }\n     }\n \n+    info!(\"falling back to passing arguments to linker via an @-file\");\n     let mut cmd2 = cmd.clone();\n     let mut args = String::new();\n     for arg in cmd2.take_args() {\n@@ -856,6 +859,7 @@ fn exec_linker(sess: &Session, cmd: &mut Command, tmpdir: &Path)\n     };\n     fs::write(&file, &bytes)?;\n     cmd2.arg(format!(\"@{}\", file.display()));\n+    info!(\"invoking linker {:?}\", cmd2);\n     return cmd2.output();\n \n     #[cfg(unix)]"}, {"sha": "afe32f3f66933560915451c20b5700d2dd80c607", "filename": "src/librustc_trans/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -104,7 +104,7 @@ const POWERPC_WHITELIST: &'static [&'static str] = &[\"altivec\",\n                                                      \"power8-vector\", \"power9-vector\",\n                                                      \"vsx\"];\n \n-const MIPS_WHITELIST: &'static [&'static str] = &[\"msa\"];\n+const MIPS_WHITELIST: &'static [&'static str] = &[\"fp64\", \"msa\"];\n \n pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n     let arch = if sess.target.target.arch == \"x86_64\" {"}, {"sha": "f00597cb27f0caaf71da6d1c5b265fe912d9561f", "filename": "src/librustc_typeck/README.md", "status": "modified", "additions": 4, "deletions": 47, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_typeck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_typeck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FREADME.md?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -1,48 +1,5 @@\n-NB: This crate is part of the Rust compiler. For an overview of the\n-compiler as a whole, see\n-[the README.md file found in `librustc`](../librustc/README.md).\n+For high-level intro to how type checking works in rustc, see the\n+[type checking] chapter of the [rustc guide].\n \n-The `rustc_typeck` crate contains the source for \"type collection\" and\n-\"type checking\", as well as a few other bits of related functionality.\n-(It draws heavily on the [type inferencing][infer] and\n-[trait solving][traits] code found in librustc.)\n-\n-[infer]: ../librustc/infer/README.md\n-[traits]: ../librustc/traits/README.md\n-\n-## Type collection\n-\n-Type \"collection\" is the process of converting the types found in the\n-HIR (`hir::Ty`), which represent the syntactic things that the user\n-wrote, into the **internal representation** used by the compiler\n-(`Ty<'tcx>`) -- we also do similar conversions for where-clauses and\n-other bits of the function signature.\n-\n-To try and get a sense for the difference, consider this function:\n-\n-```rust\n-struct Foo { }\n-fn foo(x: Foo, y: self::Foo) { .. }\n-//        ^^^     ^^^^^^^^^\n-```\n-\n-Those two parameters `x` and `y` each have the same type: but they\n-will have distinct `hir::Ty` nodes. Those nodes will have different\n-spans, and of course they encode the path somewhat differently. But\n-once they are \"collected\" into `Ty<'tcx>` nodes, they will be\n-represented by the exact same internal type.\n-\n-Collection is defined as a bundle of queries (e.g., `type_of`) for\n-computing information about the various functions, traits, and other\n-items in the crate being compiled. Note that each of these queries is\n-concerned with *interprocedural* things -- for example, for a function\n-definition, collection will figure out the type and signature of the\n-function, but it will not visit the *body* of the function in any way,\n-nor examine type annotations on local variables (that's the job of\n-type *checking*).\n-\n-For more details, see the `collect` module.\n-\n-## Type checking\n-\n-TODO\n+[type checking]: https://rust-lang-nursery.github.io/rustc-guide/type-checking.html\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/"}, {"sha": "b5d317d602538f2cf83cfed10e18680e35c417c1", "filename": "src/librustc_typeck/check/method/README.md", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e96e54d3d4973b5ac847ad53aaa2598cfc58be64/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e96e54d3d4973b5ac847ad53aaa2598cfc58be64/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2FREADME.md?ref=e96e54d3d4973b5ac847ad53aaa2598cfc58be64", "patch": "@@ -1,111 +0,0 @@\n-# Method lookup\n-\n-Method lookup can be rather complex due to the interaction of a number\n-of factors, such as self types, autoderef, trait lookup, etc. This\n-file provides an overview of the process. More detailed notes are in\n-the code itself, naturally.\n-\n-One way to think of method lookup is that we convert an expression of\n-the form:\n-\n-    receiver.method(...)\n-\n-into a more explicit UFCS form:\n-\n-    Trait::method(ADJ(receiver), ...) // for a trait call\n-    ReceiverType::method(ADJ(receiver), ...) // for an inherent method call\n-\n-Here `ADJ` is some kind of adjustment, which is typically a series of\n-autoderefs and then possibly an autoref (e.g., `&**receiver`). However\n-we sometimes do other adjustments and coercions along the way, in\n-particular unsizing (e.g., converting from `[T; n]` to `[T]`).\n-\n-## The Two Phases\n-\n-Method lookup is divided into two major phases: probing (`probe.rs`)\n-and confirmation (`confirm.rs`). The probe phase is when we decide\n-what method to call and how to adjust the receiver. The confirmation\n-phase \"applies\" this selection, updating the side-tables, unifying\n-type variables, and otherwise doing side-effectful things.\n-\n-One reason for this division is to be more amenable to caching.  The\n-probe phase produces a \"pick\" (`probe::Pick`), which is designed to be\n-cacheable across method-call sites. Therefore, it does not include\n-inference variables or other information.\n-\n-## Probe phase\n-\n-The probe phase (`probe.rs`) decides what method is being called and\n-how to adjust the receiver.\n-\n-### Steps\n-\n-The first thing that the probe phase does is to create a series of\n-*steps*. This is done by progressively dereferencing the receiver type\n-until it cannot be deref'd anymore, as well as applying an optional\n-\"unsize\" step. So if the receiver has type `Rc<Box<[T; 3]>>`, this\n-might yield:\n-\n-    Rc<Box<[T; 3]>>\n-    Box<[T; 3]>\n-    [T; 3]\n-    [T]\n-\n-### Candidate assembly\n-\n-We then search along those steps to create a list of *candidates*. A\n-`Candidate` is a method item that might plausibly be the method being\n-invoked. For each candidate, we'll derive a \"transformed self type\"\n-that takes into account explicit self.\n-\n-Candidates are grouped into two kinds, inherent and extension.\n-\n-**Inherent candidates** are those that are derived from the\n-type of the receiver itself.  So, if you have a receiver of some\n-nominal type `Foo` (e.g., a struct), any methods defined within an\n-impl like `impl Foo` are inherent methods.  Nothing needs to be\n-imported to use an inherent method, they are associated with the type\n-itself (note that inherent impls can only be defined in the same\n-module as the type itself).\n-\n-FIXME: Inherent candidates are not always derived from impls.  If you\n-have a trait object, such as a value of type `Box<ToString>`, then the\n-trait methods (`to_string()`, in this case) are inherently associated\n-with it. Another case is type parameters, in which case the methods of\n-their bounds are inherent. However, this part of the rules is subject\n-to change: when DST's \"impl Trait for Trait\" is complete, trait object\n-dispatch could be subsumed into trait matching, and the type parameter\n-behavior should be reconsidered in light of where clauses.\n-\n-**Extension candidates** are derived from imported traits.  If I have\n-the trait `ToString` imported, and I call `to_string()` on a value of\n-type `T`, then we will go off to find out whether there is an impl of\n-`ToString` for `T`.  These kinds of method calls are called \"extension\n-methods\".  They can be defined in any module, not only the one that\n-defined `T`.  Furthermore, you must import the trait to call such a\n-method.\n-\n-So, let's continue our example. Imagine that we were calling a method\n-`foo` with the receiver `Rc<Box<[T; 3]>>` and there is a trait `Foo`\n-that defines it with `&self` for the type `Rc<U>` as well as a method\n-on the type `Box` that defines `Foo` but with `&mut self`. Then we\n-might have two candidates:\n-\n-    &Rc<Box<[T; 3]>> from the impl of `Foo` for `Rc<U>` where `U=Box<T; 3]>\n-    &mut Box<[T; 3]>> from the inherent impl on `Box<U>` where `U=[T; 3]`\n-\n-### Candidate search\n-\n-Finally, to actually pick the method, we will search down the steps,\n-trying to match the receiver type against the candidate types. At\n-each step, we also consider an auto-ref and auto-mut-ref to see whether\n-that makes any of the candidates match. We pick the first step where\n-we find a match.\n-\n-In the case of our example, the first step is `Rc<Box<[T; 3]>>`,\n-which does not itself match any candidate. But when we autoref it, we\n-get the type `&Rc<Box<[T; 3]>>` which does match. We would then\n-recursively consider all where-clauses that appear on the impl: if\n-those match (or we cannot rule out that they do), then this is the\n-method we would pick. Otherwise, we would continue down the series of\n-steps."}, {"sha": "1664f46464d15ad2bd3673a19810d3d15b62baef", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Method lookup: the secret sauce of Rust. See `README.md`.\n+//! Method lookup: the secret sauce of Rust. See the [rustc guide] chapter.\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/method-lookup.html\n \n use check::FnCtxt;\n use hir::def::Def;"}, {"sha": "64d3389b34af7ed83b9e115414aba552689276d1", "filename": "src/librustc_typeck/variance/README.md", "status": "removed", "additions": 0, "deletions": 276, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/e96e54d3d4973b5ac847ad53aaa2598cfc58be64/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e96e54d3d4973b5ac847ad53aaa2598cfc58be64/src%2Flibrustc_typeck%2Fvariance%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2FREADME.md?ref=e96e54d3d4973b5ac847ad53aaa2598cfc58be64", "patch": "@@ -1,276 +0,0 @@\n-## Variance of type and lifetime parameters\n-\n-This file infers the variance of type and lifetime parameters. The\n-algorithm is taken from Section 4 of the paper \"Taming the Wildcards:\n-Combining Definition- and Use-Site Variance\" published in PLDI'11 and\n-written by Altidor et al., and hereafter referred to as The Paper.\n-\n-This inference is explicitly designed *not* to consider the uses of\n-types within code. To determine the variance of type parameters\n-defined on type `X`, we only consider the definition of the type `X`\n-and the definitions of any types it references.\n-\n-We only infer variance for type parameters found on *data types*\n-like structs and enums. In these cases, there is fairly straightforward\n-explanation for what variance means. The variance of the type\n-or lifetime parameters defines whether `T<A>` is a subtype of `T<B>`\n-(resp. `T<'a>` and `T<'b>`) based on the relationship of `A` and `B`\n-(resp. `'a` and `'b`).\n-\n-We do not infer variance for type parameters found on traits, fns,\n-or impls. Variance on trait parameters can make indeed make sense\n-(and we used to compute it) but it is actually rather subtle in\n-meaning and not that useful in practice, so we removed it. See the\n-addendum for some details. Variances on fn/impl parameters, otoh,\n-doesn't make sense because these parameters are instantiated and\n-then forgotten, they don't persist in types or compiled\n-byproducts.\n-\n-### The algorithm\n-\n-The basic idea is quite straightforward. We iterate over the types\n-defined and, for each use of a type parameter X, accumulate a\n-constraint indicating that the variance of X must be valid for the\n-variance of that use site. We then iteratively refine the variance of\n-X until all constraints are met. There is *always* a sol'n, because at\n-the limit we can declare all type parameters to be invariant and all\n-constraints will be satisfied.\n-\n-As a simple example, consider:\n-\n-    enum Option<A> { Some(A), None }\n-    enum OptionalFn<B> { Some(|B|), None }\n-    enum OptionalMap<C> { Some(|C| -> C), None }\n-\n-Here, we will generate the constraints:\n-\n-    1. V(A) <= +\n-    2. V(B) <= -\n-    3. V(C) <= +\n-    4. V(C) <= -\n-\n-These indicate that (1) the variance of A must be at most covariant;\n-(2) the variance of B must be at most contravariant; and (3, 4) the\n-variance of C must be at most covariant *and* contravariant. All of these\n-results are based on a variance lattice defined as follows:\n-\n-       *      Top (bivariant)\n-    -     +\n-       o      Bottom (invariant)\n-\n-Based on this lattice, the solution `V(A)=+`, `V(B)=-`, `V(C)=o` is the\n-optimal solution. Note that there is always a naive solution which\n-just declares all variables to be invariant.\n-\n-You may be wondering why fixed-point iteration is required. The reason\n-is that the variance of a use site may itself be a function of the\n-variance of other type parameters. In full generality, our constraints\n-take the form:\n-\n-    V(X) <= Term\n-    Term := + | - | * | o | V(X) | Term x Term\n-\n-Here the notation `V(X)` indicates the variance of a type/region\n-parameter `X` with respect to its defining class. `Term x Term`\n-represents the \"variance transform\" as defined in the paper:\n-\n->  If the variance of a type variable `X` in type expression `E` is `V2`\n-  and the definition-site variance of the [corresponding] type parameter\n-  of a class `C` is `V1`, then the variance of `X` in the type expression\n-  `C<E>` is `V3 = V1.xform(V2)`.\n-\n-### Constraints\n-\n-If I have a struct or enum with where clauses:\n-\n-    struct Foo<T:Bar> { ... }\n-\n-you might wonder whether the variance of `T` with respect to `Bar`\n-affects the variance `T` with respect to `Foo`. I claim no.  The\n-reason: assume that `T` is invariant w/r/t `Bar` but covariant w/r/t\n-`Foo`. And then we have a `Foo<X>` that is upcast to `Foo<Y>`, where\n-`X <: Y`. However, while `X : Bar`, `Y : Bar` does not hold.  In that\n-case, the upcast will be illegal, but not because of a variance\n-failure, but rather because the target type `Foo<Y>` is itself just\n-not well-formed. Basically we get to assume well-formedness of all\n-types involved before considering variance.\n-\n-#### Dependency graph management\n-\n-Because variance is a whole-crate inference, its dependency graph\n-can become quite muddled if we are not careful. To resolve this, we refactor\n-into two queries:\n-\n-- `crate_variances` computes the variance for all items in the current crate.\n-- `variances_of` accesses the variance for an individual reading; it\n-  works by requesting `crate_variances` and extracting the relevant data.\n-\n-If you limit yourself to reading `variances_of`, your code will only\n-depend then on the inference inferred for that particular item.\n-\n-Ultimately, this setup relies on the red-green algorithm.\n-In particular, every variance query ultimately depends on -- effectively --\n-all type definitions in the entire crate (through `crate_variances`),\n-but since most changes will not result in a change\n-to the actual results from variance inference,\n-the `variances_of` query will wind up being considered green after it is re-evaluated.\n-\n-### Addendum: Variance on traits\n-\n-As mentioned above, we used to permit variance on traits. This was\n-computed based on the appearance of trait type parameters in\n-method signatures and was used to represent the compatibility of\n-vtables in trait objects (and also \"virtual\" vtables or dictionary\n-in trait bounds). One complication was that variance for\n-associated types is less obvious, since they can be projected out\n-and put to myriad uses, so it's not clear when it is safe to allow\n-`X<A>::Bar` to vary (or indeed just what that means). Moreover (as\n-covered below) all inputs on any trait with an associated type had\n-to be invariant, limiting the applicability. Finally, the\n-annotations (`MarkerTrait`, `PhantomFn`) needed to ensure that all\n-trait type parameters had a variance were confusing and annoying\n-for little benefit.\n-\n-Just for historical reference,I am going to preserve some text indicating\n-how one could interpret variance and trait matching.\n-\n-#### Variance and object types\n-\n-Just as with structs and enums, we can decide the subtyping\n-relationship between two object types `&Trait<A>` and `&Trait<B>`\n-based on the relationship of `A` and `B`. Note that for object\n-types we ignore the `Self` type parameter -- it is unknown, and\n-the nature of dynamic dispatch ensures that we will always call a\n-function that is expected the appropriate `Self` type. However, we\n-must be careful with the other type parameters, or else we could\n-end up calling a function that is expecting one type but provided\n-another.\n-\n-To see what I mean, consider a trait like so:\n-\n-    trait ConvertTo<A> {\n-        fn convertTo(&self) -> A;\n-    }\n-\n-Intuitively, If we had one object `O=&ConvertTo<Object>` and another\n-`S=&ConvertTo<String>`, then `S <: O` because `String <: Object`\n-(presuming Java-like \"string\" and \"object\" types, my go to examples\n-for subtyping). The actual algorithm would be to compare the\n-(explicit) type parameters pairwise respecting their variance: here,\n-the type parameter A is covariant (it appears only in a return\n-position), and hence we require that `String <: Object`.\n-\n-You'll note though that we did not consider the binding for the\n-(implicit) `Self` type parameter: in fact, it is unknown, so that's\n-good. The reason we can ignore that parameter is precisely because we\n-don't need to know its value until a call occurs, and at that time (as\n-you said) the dynamic nature of virtual dispatch means the code we run\n-will be correct for whatever value `Self` happens to be bound to for\n-the particular object whose method we called. `Self` is thus different\n-from `A`, because the caller requires that `A` be known in order to\n-know the return type of the method `convertTo()`. (As an aside, we\n-have rules preventing methods where `Self` appears outside of the\n-receiver position from being called via an object.)\n-\n-#### Trait variance and vtable resolution\n-\n-But traits aren't only used with objects. They're also used when\n-deciding whether a given impl satisfies a given trait bound. To set the\n-scene here, imagine I had a function:\n-\n-    fn convertAll<A,T:ConvertTo<A>>(v: &[T]) {\n-        ...\n-    }\n-\n-Now imagine that I have an implementation of `ConvertTo` for `Object`:\n-\n-    impl ConvertTo<i32> for Object { ... }\n-\n-And I want to call `convertAll` on an array of strings. Suppose\n-further that for whatever reason I specifically supply the value of\n-`String` for the type parameter `T`:\n-\n-    let mut vector = vec![\"string\", ...];\n-    convertAll::<i32, String>(vector);\n-\n-Is this legal? To put another way, can we apply the `impl` for\n-`Object` to the type `String`? The answer is yes, but to see why\n-we have to expand out what will happen:\n-\n-- `convertAll` will create a pointer to one of the entries in the\n-  vector, which will have type `&String`\n-- It will then call the impl of `convertTo()` that is intended\n-  for use with objects. This has the type:\n-\n-      fn(self: &Object) -> i32\n-\n-  It is ok to provide a value for `self` of type `&String` because\n-  `&String <: &Object`.\n-\n-OK, so intuitively we want this to be legal, so let's bring this back\n-to variance and see whether we are computing the correct result. We\n-must first figure out how to phrase the question \"is an impl for\n-`Object,i32` usable where an impl for `String,i32` is expected?\"\n-\n-Maybe it's helpful to think of a dictionary-passing implementation of\n-type classes. In that case, `convertAll()` takes an implicit parameter\n-representing the impl. In short, we *have* an impl of type:\n-\n-    V_O = ConvertTo<i32> for Object\n-\n-and the function prototype expects an impl of type:\n-\n-    V_S = ConvertTo<i32> for String\n-\n-As with any argument, this is legal if the type of the value given\n-(`V_O`) is a subtype of the type expected (`V_S`). So is `V_O <: V_S`?\n-The answer will depend on the variance of the various parameters. In\n-this case, because the `Self` parameter is contravariant and `A` is\n-covariant, it means that:\n-\n-    V_O <: V_S iff\n-        i32 <: i32\n-        String <: Object\n-\n-These conditions are satisfied and so we are happy.\n-\n-#### Variance and associated types\n-\n-Traits with associated types -- or at minimum projection\n-expressions -- must be invariant with respect to all of their\n-inputs. To see why this makes sense, consider what subtyping for a\n-trait reference means:\n-\n-    <T as Trait> <: <U as Trait>\n-\n-means that if I know that `T as Trait`, I also know that `U as\n-Trait`. Moreover, if you think of it as dictionary passing style,\n-it means that a dictionary for `<T as Trait>` is safe to use where\n-a dictionary for `<U as Trait>` is expected.\n-\n-The problem is that when you can project types out from `<T as\n-Trait>`, the relationship to types projected out of `<U as Trait>`\n-is completely unknown unless `T==U` (see #21726 for more\n-details). Making `Trait` invariant ensures that this is true.\n-\n-Another related reason is that if we didn't make traits with\n-associated types invariant, then projection is no longer a\n-function with a single result. Consider:\n-\n-```\n-trait Identity { type Out; fn foo(&self); }\n-impl<T> Identity for T { type Out = T; ... }\n-```\n-\n-Now if I have `<&'static () as Identity>::Out`, this can be\n-validly derived as `&'a ()` for any `'a`:\n-\n-    <&'a () as Identity> <: <&'static () as Identity>\n-    if &'static () < : &'a ()   -- Identity is contravariant in Self\n-    if 'static : 'a             -- Subtyping rules for relations\n-\n-This change otoh means that `<'static () as Identity>::Out` is\n-always `&'static ()` (which might then be upcast to `'a ()`,\n-separately). This was helpful in solving #21750.\n-\n-"}, {"sha": "fd2b964103a3026a3c957b8f05f58b2e52ca6a58", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Module for inferring the variance of type and lifetime\n-//! parameters. See README.md for details.\n+//! Module for inferring the variance of type and lifetime parameters. See the [rustc guide]\n+//! chapter for more info.\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/variance.html\n \n use arena;\n use rustc::hir;"}, {"sha": "b9ab00130b3c3c984f671d98958dd163575b69dd", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -87,7 +87,10 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n         lang_items: lang_items(tcx),\n     };\n \n-    // See README.md for a discussion on dep-graph management.\n+    // See the following for a discussion on dep-graph management.\n+    //\n+    // - https://rust-lang-nursery.github.io/rustc-guide/query.html\n+    // - https://rust-lang-nursery.github.io/rustc-guide/variance.html\n     tcx.hir.krate().visit_all_item_likes(&mut terms_cx);\n \n     terms_cx"}, {"sha": "c8571e4cf9181f22c1f9c757a66c1778b3ca772c", "filename": "src/librustdoc/html/static/storage.js", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstorage.js?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -44,8 +44,12 @@ function switchTheme(styleElem, mainStyleElem, newTheme) {\n     var fullBasicCss = \"rustdoc\" + resourcesSuffix + \".css\";\n     var fullNewTheme = newTheme + resourcesSuffix + \".css\";\n     var newHref = mainStyleElem.href.replace(fullBasicCss, fullNewTheme);\n-    var found = false;\n \n+    if (styleElem.href === newHref) {\n+        return;\n+    }\n+\n+    var found = false;\n     if (savedHref.length === 0) {\n         onEach(document.getElementsByTagName(\"link\"), function(el) {\n             savedHref.push(el.href);"}, {"sha": "71d92c3702e63dcb42313e25dcf46d0e3b7fdbfa", "filename": "src/test/ui/nll/issue-48070.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/521d91c6be76367d966df419677dd187f799b116/src%2Ftest%2Fui%2Fnll%2Fissue-48070.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d91c6be76367d966df419677dd187f799b116/src%2Ftest%2Fui%2Fnll%2Fissue-48070.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-48070.rs?ref=521d91c6be76367d966df419677dd187f799b116", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-pass\n+// revisions: lxl nll\n+\n+#![cfg_attr(nll, feature(nll))]\n+\n+struct Foo {\n+    x: u32\n+}\n+\n+impl Foo {\n+    fn twiddle(&mut self) -> &mut Self { self }\n+    fn twaddle(&mut self) -> &mut Self { self }\n+    fn emit(&mut self) {\n+        self.x += 1;\n+    }\n+}\n+\n+fn main() {\n+    let mut foo = Foo { x: 0 };\n+    match 22 {\n+        22 => &mut foo,\n+        44 => foo.twiddle(),\n+        _ => foo.twaddle(),\n+    }.emit();\n+}"}]}