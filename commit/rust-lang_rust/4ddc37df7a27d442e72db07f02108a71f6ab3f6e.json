{"sha": "4ddc37df7a27d442e72db07f02108a71f6ab3f6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkZGMzN2RmN2EyN2Q0NDJlNzJkYjA3ZjAyMTA4YTcxZjZhYjNmNmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-06T09:51:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-06T09:51:32Z"}, "message": "Auto merge of #1031 - RalfJung:ptr-offset, r=RalfJung\n\nRefactor ptr_offset_inbounds\n\nI finally found a way to write this using basically just `check_ptr_access` while handling all cases (integers and pointers, offset 0 or not) correctly. This changes behavior for NULL ptrs, but I think the change is for the better.\n\nDepends on https://github.com/rust-lang/rust/pull/66081.", "tree": {"sha": "a755369e52bc922057791dc812ba8594b0421650", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a755369e52bc922057791dc812ba8594b0421650"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ddc37df7a27d442e72db07f02108a71f6ab3f6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ddc37df7a27d442e72db07f02108a71f6ab3f6e", "html_url": "https://github.com/rust-lang/rust/commit/4ddc37df7a27d442e72db07f02108a71f6ab3f6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ddc37df7a27d442e72db07f02108a71f6ab3f6e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61fd7e30937fa878547f30af2b94bbdcdb003a99", "url": "https://api.github.com/repos/rust-lang/rust/commits/61fd7e30937fa878547f30af2b94bbdcdb003a99", "html_url": "https://github.com/rust-lang/rust/commit/61fd7e30937fa878547f30af2b94bbdcdb003a99"}, {"sha": "8b0c14f9f6ada1f042b3a734308bb60bdf4ac65e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b0c14f9f6ada1f042b3a734308bb60bdf4ac65e", "html_url": "https://github.com/rust-lang/rust/commit/8b0c14f9f6ada1f042b3a734308bb60bdf4ac65e"}], "stats": {"total": 63, "additions": 28, "deletions": 35}, "files": [{"sha": "6b17a5dbeb5ef5a497729c51e6cb4b864f066d63", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ddc37df7a27d442e72db07f02108a71f6ab3f6e/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/4ddc37df7a27d442e72db07f02108a71f6ab3f6e/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=4ddc37df7a27d442e72db07f02108a71f6ab3f6e", "patch": "@@ -1 +1 @@\n-3a1b3b30c6cdd674049b144a3ced7b711de962b2\n+e4931eaaa3d95189b30e90d3af9f0db17c41bbb0"}, {"sha": "2a90d3e12f4c0f41c51c0f4a837051aed579333e", "filename": "src/operator.rs", "status": "modified", "additions": 20, "deletions": 34, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4ddc37df7a27d442e72db07f02108a71f6ab3f6e/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ddc37df7a27d442e72db07f02108a71f6ab3f6e/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=4ddc37df7a27d442e72db07f02108a71f6ab3f6e", "patch": "@@ -1,16 +1,11 @@\n use std::convert::TryFrom;\n \n-use rustc::ty::{Ty, layout::LayoutOf};\n+use rustc::ty::{Ty, layout::{Size, LayoutOf}};\n use rustc::mir;\n \n use crate::*;\n \n pub trait EvalContextExt<'tcx> {\n-    fn pointer_inbounds(\n-        &self,\n-        ptr: Pointer<Tag>\n-    ) -> InterpResult<'tcx>;\n-\n     fn binary_ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n@@ -33,13 +28,6 @@ pub trait EvalContextExt<'tcx> {\n }\n \n impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n-    /// Test if the pointer is in-bounds of a live allocation.\n-    #[inline]\n-    fn pointer_inbounds(&self, ptr: Pointer<Tag>) -> InterpResult<'tcx> {\n-        let (size, _align) = self.memory.get_size_and_align(ptr.alloc_id, AllocCheck::Live)?;\n-        ptr.check_inbounds_alloc(size, CheckInAllocMsg::InboundsTest)\n-    }\n-\n     fn binary_ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n@@ -110,9 +98,8 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n     }\n \n     /// Raises an error if the offset moves the pointer outside of its allocation.\n-    /// We consider ZSTs their own huge allocation that doesn't overlap with anything (and nothing\n-    /// moves in there because the size is 0). We also consider the NULL pointer its own separate\n-    /// allocation, and all the remaining integers pointers their own allocation.\n+    /// For integers, we consider each of them their own tiny allocation of size 0,\n+    /// so offset-by-0 is okay for them -- except for NULL, which we rule out entirely.\n     fn pointer_offset_inbounds(\n         &self,\n         ptr: Scalar<Tag>,\n@@ -123,25 +110,24 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         let offset = offset\n             .checked_mul(pointee_size)\n             .ok_or_else(|| err_panic!(Overflow(mir::BinOp::Mul)))?;\n-        // Now let's see what kind of pointer this is.\n-        let ptr = if offset == 0 {\n-            match ptr {\n-                Scalar::Ptr(ptr) => ptr,\n-                Scalar::Raw { .. } => {\n-                    // Offset 0 on an integer. We accept that, pretending there is\n-                    // a little zero-sized allocation here.\n-                    return Ok(ptr);\n-                }\n-            }\n+        // We do this first, to rule out overflows.\n+        let offset_ptr = ptr.ptr_signed_offset(offset, self)?;\n+        // What we need to check is that starting at `min(ptr, offset_ptr)`,\n+        // we could do an access of size `abs(offset)`. Alignment does not matter.\n+        let (min_ptr, abs_offset) = if offset >= 0 {\n+            (ptr, u64::try_from(offset).unwrap())\n         } else {\n-            // Offset > 0. We *require* a pointer.\n-            self.force_ptr(ptr)?\n+            // Negative offset.\n+            // If the negation overflows, the result will be negative so the try_from will fail.\n+            (offset_ptr, u64::try_from(-offset).unwrap())\n         };\n-        // Both old and new pointer must be in-bounds of a *live* allocation.\n-        // (Of the same allocation, but that part is trivial with our representation.)\n-        self.pointer_inbounds(ptr)?;\n-        let ptr = ptr.signed_offset(offset, self)?;\n-        self.pointer_inbounds(ptr)?;\n-        Ok(Scalar::Ptr(ptr))\n+        self.memory.check_ptr_access_align(\n+            min_ptr,\n+            Size::from_bytes(abs_offset),\n+            None,\n+            CheckInAllocMsg::InboundsTest,\n+        )?;\n+        // That's it!\n+        Ok(offset_ptr)\n     }\n }"}, {"sha": "96a9fb8402f689f2007cbe344fe33ae4c7b567d2", "filename": "tests/compile-fail/ptr_offset_0_plus_0.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4ddc37df7a27d442e72db07f02108a71f6ab3f6e/tests%2Fcompile-fail%2Fptr_offset_0_plus_0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ddc37df7a27d442e72db07f02108a71f6ab3f6e/tests%2Fcompile-fail%2Fptr_offset_0_plus_0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_offset_0_plus_0.rs?ref=4ddc37df7a27d442e72db07f02108a71f6ab3f6e", "patch": "@@ -0,0 +1,7 @@\n+// error-pattern: invalid use of NULL pointer\n+\n+fn main() {\n+    let x = 0 as *mut i32;\n+    let _x = x.wrapping_offset(8); // ok, this has no inbounds tag\n+    let _x = unsafe { x.offset(0) }; // UB despite offset 0, NULL is never inbounds\n+}"}]}