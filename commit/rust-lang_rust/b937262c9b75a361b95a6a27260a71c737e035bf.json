{"sha": "b937262c9b75a361b95a6a27260a71c737e035bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MzcyNjJjOWI3NWEzNjFiOTVhNmEyNzI2MGE3MWM3MzdlMDM1YmY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-21T15:30:10Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-21T15:30:10Z"}, "message": "Module map implementation", "tree": {"sha": "1838794f32d43a8c45c478b9f24bd74d257edd43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1838794f32d43a8c45c478b9f24bd74d257edd43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b937262c9b75a361b95a6a27260a71c737e035bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b937262c9b75a361b95a6a27260a71c737e035bf", "html_url": "https://github.com/rust-lang/rust/commit/b937262c9b75a361b95a6a27260a71c737e035bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b937262c9b75a361b95a6a27260a71c737e035bf/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d8be265849c55912467961e09af657176472dcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d8be265849c55912467961e09af657176472dcb", "html_url": "https://github.com/rust-lang/rust/commit/4d8be265849c55912467961e09af657176472dcb"}], "stats": {"total": 294, "additions": 247, "deletions": 47}, "files": [{"sha": "d01144627ff6b4a7ba321137110dab15d456f6f3", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 84, "deletions": 40, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/b937262c9b75a361b95a6a27260a71c737e035bf/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b937262c9b75a361b95a6a27260a71c737e035bf/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=b937262c9b75a361b95a6a27260a71c737e035bf", "patch": "@@ -10,16 +10,18 @@ extern crate fst;\n extern crate rayon;\n \n mod symbol_index;\n+mod module_map;\n \n use once_cell::sync::OnceCell;\n use rayon::prelude::*;\n \n use std::{\n     fmt,\n-    path::{Path, PathBuf},\n+    mem,\n+    path::{Path},\n     sync::{\n         Arc,\n-        atomic::{AtomicUsize, Ordering::SeqCst},\n+        atomic::{AtomicBool, Ordering::SeqCst},\n     },\n     collections::hash_map::HashMap,\n     time::Instant,\n@@ -32,7 +34,10 @@ use libsyntax2::{\n };\n use libeditor::{LineIndex, FileSymbol, find_node};\n \n-use self::symbol_index::FileSymbols;\n+use self::{\n+    symbol_index::FileSymbols,\n+    module_map::ModuleMap,\n+};\n pub use self::symbol_index::Query;\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n@@ -42,11 +47,12 @@ pub type FileResolver = dyn Fn(FileId, &Path) -> Option<FileId> + Send + Sync;\n \n #[derive(Debug)]\n pub struct WorldState {\n+    updates: Vec<FileId>,\n     data: Arc<WorldData>\n }\n \n-#[derive(Clone)]\n pub struct World {\n+    needs_reindex: AtomicBool,\n     file_resolver: Arc<FileResolver>,\n     data: Arc<WorldData>,\n }\n@@ -57,18 +63,48 @@ impl fmt::Debug for World {\n     }\n }\n \n+impl Clone for World {\n+    fn clone(&self) -> World {\n+        World {\n+            needs_reindex: AtomicBool::new(self.needs_reindex.load(SeqCst)),\n+            file_resolver: Arc::clone(&self.file_resolver),\n+            data: Arc::clone(&self.data),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct FileId(pub u32);\n \n impl WorldState {\n     pub fn new() -> WorldState {\n         WorldState {\n-            data: Arc::new(WorldData::default())\n+            updates: Vec::new(),\n+            data: Arc::new(WorldData::default()),\n         }\n     }\n \n-    pub fn snapshot(&self, file_resolver: impl Fn(FileId, &Path) -> Option<FileId> + 'static + Send + Sync) -> World {\n+    pub fn snapshot(\n+        &mut self,\n+        file_resolver: impl Fn(FileId, &Path) -> Option<FileId> + 'static + Send + Sync,\n+    ) -> World {\n+        let needs_reindex = self.updates.len() >= INDEXING_THRESHOLD;\n+        if !self.updates.is_empty() {\n+            let updates = mem::replace(&mut self.updates, Vec::new());\n+            let data = self.data_mut();\n+            for file_id in updates {\n+                let syntax = data.file_map\n+                    .get(&file_id)\n+                    .map(|it| it.syntax());\n+                data.module_map.update_file(\n+                    file_id,\n+                    syntax,\n+                    &file_resolver,\n+                );\n+            }\n+        }\n         World {\n+            needs_reindex: AtomicBool::new(needs_reindex),\n             file_resolver: Arc::new(file_resolver),\n             data: self.data.clone()\n         }\n@@ -79,28 +115,28 @@ impl WorldState {\n     }\n \n     pub fn change_files(&mut self, changes: impl Iterator<Item=(FileId, Option<String>)>) {\n-        let data = self.data_mut();\n-        let mut cnt = 0;\n-        for (id, text) in changes {\n-            cnt += 1;\n-            data.file_map.remove(&id);\n-            if let Some(text) = text {\n-                let file_data = FileData::new(text);\n-                data.file_map.insert(id, Arc::new(file_data));\n-            } else {\n-                data.file_map.remove(&id);\n+        let mut updates = Vec::new();\n+        {\n+            let data = self.data_mut();\n+            for (file_id, text) in changes {\n+                data.file_map.remove(&file_id);\n+                if let Some(text) = text {\n+                    let file_data = FileData::new(text);\n+                    data.file_map.insert(file_id, Arc::new(file_data));\n+                } else {\n+                    data.file_map.remove(&file_id);\n+                }\n+                updates.push(file_id);\n             }\n         }\n-        *data.unindexed.get_mut() += cnt;\n+        self.updates.extend(updates)\n     }\n \n     fn data_mut(&mut self) -> &mut WorldData {\n         if Arc::get_mut(&mut self.data).is_none() {\n             self.data = Arc::new(WorldData {\n-                unindexed: AtomicUsize::new(\n-                    self.data.unindexed.load(SeqCst)\n-                ),\n                 file_map: self.data.file_map.clone(),\n+                module_map: self.data.module_map.clone(),\n             });\n         }\n         Arc::get_mut(&mut self.data).unwrap()\n@@ -131,6 +167,24 @@ impl World {\n             .collect()\n     }\n \n+    pub fn parent_module(&self, id: FileId) -> Vec<(FileId, FileSymbol)> {\n+        let module_map = &self.data.module_map;\n+        let id = module_map.file2module(id);\n+        module_map\n+            .parent_modules(id)\n+            .into_iter()\n+            .map(|(id, m)| {\n+                let id = module_map.module2file(id);\n+                let sym = FileSymbol {\n+                    name: m.name().unwrap().text(),\n+                    node_range: m.syntax().range(),\n+                    kind: MODULE,\n+                };\n+                (id, sym)\n+            })\n+            .collect()\n+    }\n+\n     pub fn approximately_resolve_symbol(\n         &self,\n         id: FileId,\n@@ -178,32 +232,22 @@ impl World {\n             Some(name) => name.text(),\n             None => return Vec::new(),\n         };\n-        let paths = &[\n-            PathBuf::from(format!(\"../{}.rs\", name)),\n-            PathBuf::from(format!(\"../{}/mod.rs\", name)),\n-        ];\n-        paths.iter()\n-            .filter_map(|path| self.resolve_relative_path(id, path))\n+        let module_map = &self.data.module_map;\n+        let id = module_map.file2module(id);\n+        module_map\n+            .child_module_by_name(id, name.as_str())\n+            .into_iter()\n+            .map(|id| module_map.module2file(id))\n             .collect()\n     }\n \n-    fn resolve_relative_path(&self, id: FileId, path: &Path) -> Option<FileId> {\n-        (self.file_resolver)(id, path)\n-    }\n-\n     fn reindex(&self) {\n-        let data = &*self.data;\n-        let unindexed = data.unindexed.load(SeqCst);\n-        if unindexed < INDEXING_THRESHOLD {\n-            return;\n-        }\n-        if unindexed == data.unindexed.compare_and_swap(unindexed, 0, SeqCst) {\n+        if self.needs_reindex.compare_and_swap(false, true, SeqCst) {\n             let now = Instant::now();\n+            let data = &*self.data;\n             data.file_map\n                 .par_iter()\n-                .for_each(|(_, data)| {\n-                    data.symbols();\n-                });\n+                .for_each(|(_, data)| drop(data.symbols()));\n             info!(\"parallel indexing took {:?}\", now.elapsed());\n         }\n     }\n@@ -218,8 +262,8 @@ impl World {\n \n #[derive(Default, Debug)]\n struct WorldData {\n-    unindexed: AtomicUsize,\n     file_map: HashMap<FileId, Arc<FileData>>,\n+    module_map: ModuleMap,\n }\n \n #[derive(Debug)]"}, {"sha": "9b4c778b6155a06181ff145008fa5b4e2f15d4b1", "filename": "crates/libanalysis/src/module_map.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/b937262c9b75a361b95a6a27260a71c737e035bf/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b937262c9b75a361b95a6a27260a71c737e035bf/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs?ref=b937262c9b75a361b95a6a27260a71c737e035bf", "patch": "@@ -0,0 +1,117 @@\n+use std::{\n+    path::{PathBuf},\n+};\n+\n+use libsyntax2::{\n+    ast::{self, AstNode, NameOwner},\n+    SyntaxNode, ParsedFile, SmolStr,\n+};\n+use {FileId, FileResolver};\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub struct ModuleId(FileId);\n+\n+#[derive(Clone, Debug, Default)]\n+pub struct ModuleMap {\n+    links: Vec<Link>,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct Link {\n+    owner: ModuleId,\n+    syntax: SyntaxNode,\n+    points_to: Vec<ModuleId>,\n+}\n+\n+impl ModuleMap {\n+    pub fn update_file(\n+        &mut self,\n+        file_id: FileId,\n+        syntax: Option<&ParsedFile>,\n+        file_resolver: &FileResolver,\n+    ) {\n+        let mod_id = ModuleId(file_id);\n+        self.links.retain(|link| link.owner != mod_id);\n+        match syntax {\n+            None => {\n+                for link in self.links.iter_mut() {\n+                    link.points_to.retain(|&x| x != mod_id);\n+                }\n+            }\n+            Some(syntax) => {\n+                self.links.extend(\n+                    syntax.ast().modules().filter_map(|it| {\n+                        Link::new(mod_id, it)\n+                    })\n+                )\n+            }\n+        }\n+        self.links.iter_mut().for_each(|link| {\n+            link.resolve(file_resolver)\n+        })\n+    }\n+\n+    pub fn module2file(&self, m: ModuleId) -> FileId {\n+        m.0\n+    }\n+\n+    pub fn file2module(&self, file_id: FileId) -> ModuleId {\n+        ModuleId(file_id)\n+    }\n+\n+    pub fn child_module_by_name(&self, parent_mod: ModuleId, child_mod: &str) -> Vec<ModuleId> {\n+        self.links\n+            .iter()\n+            .filter(|link| link.owner == parent_mod)\n+            .filter(|link| link.name() == child_mod)\n+            .filter_map(|it| it.points_to.first())\n+            .map(|&it| it)\n+            .collect()\n+    }\n+\n+    pub fn parent_modules<'a>(&'a self, m: ModuleId) -> impl Iterator<Item=(ModuleId, ast::Module<'a>)> + 'a {\n+        self.links\n+            .iter()\n+            .filter(move |link| link.points_to.iter().any(|&it| it == m))\n+            .map(|link| {\n+                (link.owner, link.ast())\n+            })\n+    }\n+}\n+\n+impl Link {\n+    fn new(owner: ModuleId, module: ast::Module) -> Option<Link> {\n+        if module.name().is_none() {\n+            return None;\n+        }\n+        let link = Link {\n+            owner,\n+            syntax: module.syntax().owned(),\n+            points_to: Vec::new(),\n+        };\n+        Some(link)\n+    }\n+\n+    fn name(&self) -> SmolStr {\n+        self.ast().name()\n+            .unwrap()\n+            .text()\n+    }\n+\n+    fn ast(&self) -> ast::Module {\n+        ast::Module::cast(self.syntax.borrowed())\n+            .unwrap()\n+    }\n+\n+    fn resolve(&mut self, file_resolver: &FileResolver) {\n+        let name = self.name();\n+        let paths = &[\n+            PathBuf::from(format!(\"../{}.rs\", name)),\n+            PathBuf::from(format!(\"../{}/mod.rs\", name)),\n+        ];\n+        self.points_to = paths.iter()\n+            .filter_map(|path| file_resolver(self.owner.0, path))\n+            .map(ModuleId)\n+            .collect();\n+    }\n+}"}, {"sha": "931ab418381968c0d32cc638a00d948ace26ea15", "filename": "crates/libanalysis/tests/tests.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b937262c9b75a361b95a6a27260a71c737e035bf/crates%2Flibanalysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b937262c9b75a361b95a6a27260a71c737e035bf/crates%2Flibanalysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Ftests%2Ftests.rs?ref=b937262c9b75a361b95a6a27260a71c737e035bf", "patch": "@@ -43,3 +43,24 @@ fn test_resolve_module() {\n         &symbols,\n     );\n }\n+\n+#[test]\n+fn test_resolve_parent_module() {\n+    let mut world = WorldState::new();\n+    world.change_file(FileId(1), Some(\"mod foo;\".to_string()));\n+    world.change_file(FileId(2), Some(\"\".to_string()));\n+\n+    let snap = world.snapshot(|id, path| {\n+        assert_eq!(id, FileId(1));\n+        if path == PathBuf::from(\"../foo/mod.rs\") {\n+            return None;\n+        }\n+        assert_eq!(path, PathBuf::from(\"../foo.rs\"));\n+        Some(FileId(2))\n+    });\n+    let symbols = snap.parent_module(FileId(2));\n+    assert_eq_dbg(\n+        r#\"[(FileId(1), FileSymbol { name: \"foo\", node_range: [0; 8), kind: MODULE })]\"#,\n+        &symbols,\n+    );\n+}"}, {"sha": "610b5198c9c7112ec4cb3de31fc13554aed69725", "filename": "crates/libsyntax2/src/ast/generated.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b937262c9b75a361b95a6a27260a71c737e035bf/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b937262c9b75a361b95a6a27260a71c737e035bf/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs?ref=b937262c9b75a361b95a6a27260a71c737e035bf", "patch": "@@ -127,6 +127,12 @@ impl<'a> File<'a> {\n             .children()\n             .filter_map(FnDef::cast)\n     }\n+\n+    pub fn modules(self) -> impl Iterator<Item = Module<'a>> + 'a {\n+        self.syntax()\n+            .children()\n+            .filter_map(Module::cast)\n+    }\n }\n \n // FnDef\n@@ -239,7 +245,13 @@ impl<'a> AstNode<'a> for Module<'a> {\n \n impl<'a> ast::NameOwner<'a> for Module<'a> {}\n impl<'a> ast::AttrsOwner<'a> for Module<'a> {}\n-impl<'a> Module<'a> {}\n+impl<'a> Module<'a> {\n+    pub fn modules(self) -> impl Iterator<Item = Module<'a>> + 'a {\n+        self.syntax()\n+            .children()\n+            .filter_map(Module::cast)\n+    }\n+}\n \n // Name\n #[derive(Debug, Clone, Copy)]"}, {"sha": "8e644d3c446dde8099d84477ca685e12ab4328e7", "filename": "crates/libsyntax2/src/grammar.ron", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b937262c9b75a361b95a6a27260a71c737e035bf/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/b937262c9b75a361b95a6a27260a71c737e035bf/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron?ref=b937262c9b75a361b95a6a27260a71c737e035bf", "patch": "@@ -218,7 +218,8 @@ Grammar(\n     ast: {\n         \"File\": (\n             collections: [\n-                [\"functions\", \"FnDef\"]\n+                [\"functions\", \"FnDef\"],\n+                [\"modules\", \"Module\"],\n             ]\n         ),\n         \"FnDef\": ( traits: [\"NameOwner\", \"AttrsOwner\"] ),\n@@ -231,7 +232,12 @@ Grammar(\n         \"NamedField\": ( traits: [\"NameOwner\", \"AttrsOwner\"] ),\n         \"EnumDef\": ( traits: [\"NameOwner\", \"AttrsOwner\"] ),\n         \"TraitDef\": ( traits: [\"NameOwner\", \"AttrsOwner\"] ),\n-        \"Module\": ( traits: [\"NameOwner\", \"AttrsOwner\"] ),\n+        \"Module\": (\n+            traits: [\"NameOwner\", \"AttrsOwner\"],\n+            collections: [\n+                [\"modules\", \"Module\"]\n+            ]\n+        ),\n         \"ConstDef\": ( traits: [\"NameOwner\", \"AttrsOwner\"] ),\n         \"StaticDef\": ( traits: [\"NameOwner\", \"AttrsOwner\"] ),\n         \"TypeDef\": ( traits: [\"NameOwner\", \"AttrsOwner\"] ),"}, {"sha": "12a903dac5876a9162d942d3acb36e82722ca29c", "filename": "crates/server/src/main_loop/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b937262c9b75a361b95a6a27260a71c737e035bf/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b937262c9b75a361b95a6a27260a71c737e035bf/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs?ref=b937262c9b75a361b95a6a27260a71c737e035bf", "patch": "@@ -94,7 +94,7 @@ pub(super) fn main_loop(\n             Event::Msg(msg) => {\n                 match msg {\n                     RawMsg::Request(req) => {\n-                        if !on_request(io, &state, pool, &task_sender, req)? {\n+                        if !on_request(io, &mut state, pool, &task_sender, req)? {\n                             return Ok(());\n                         }\n                     }\n@@ -114,7 +114,7 @@ pub(super) fn main_loop(\n \n fn on_request(\n     io: &mut Io,\n-    world: &ServerWorldState,\n+    world: &mut ServerWorldState,\n     pool: &ThreadPool,\n     sender: &Sender<Task>,\n     req: RawRequest,\n@@ -252,7 +252,7 @@ fn on_notification(\n fn handle_request_on_threadpool<R: req::ClientRequest>(\n     req: &mut Option<RawRequest>,\n     pool: &ThreadPool,\n-    world: &ServerWorldState,\n+    world: &mut ServerWorldState,\n     sender: &Sender<Task>,\n     f: fn(ServerWorld, R::Params) -> Result<R::Result>,\n ) -> Result<()>"}, {"sha": "9850822cde77732f9588260cf6f1363dc4f124c3", "filename": "crates/server/src/server_world.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b937262c9b75a361b95a6a27260a71c737e035bf/crates%2Fserver%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b937262c9b75a361b95a6a27260a71c737e035bf/crates%2Fserver%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fserver_world.rs?ref=b937262c9b75a361b95a6a27260a71c737e035bf", "patch": "@@ -86,7 +86,7 @@ impl ServerWorldState {\n         Ok(())\n     }\n \n-    pub fn snapshot(&self) -> ServerWorld {\n+    pub fn snapshot(&mut self) -> ServerWorld {\n         let pm = self.path_map.clone();\n         ServerWorld {\n             analysis: self.analysis.snapshot(move |id, path| {"}]}