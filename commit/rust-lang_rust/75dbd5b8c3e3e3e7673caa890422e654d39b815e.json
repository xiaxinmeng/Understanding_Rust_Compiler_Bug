{"sha": "75dbd5b8c3e3e3e7673caa890422e654d39b815e", "node_id": "C_kwDOAAsO6NoAKDc1ZGJkNWI4YzNlM2UzZTc2NzNjYWE4OTA0MjJlNjU0ZDM5YjgxNWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-16T02:05:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-16T02:05:30Z"}, "message": "Auto merge of #102931 - camsteffen:inline-overlapping-impls, r=cjgillot\n\nMake `overlapping_impls` not generic\n\nTrying to win back perf from #101632.", "tree": {"sha": "f47e4a51d5a1594ec1a20e96dfd47ff9d73669ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f47e4a51d5a1594ec1a20e96dfd47ff9d73669ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75dbd5b8c3e3e3e7673caa890422e654d39b815e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75dbd5b8c3e3e3e7673caa890422e654d39b815e", "html_url": "https://github.com/rust-lang/rust/commit/75dbd5b8c3e3e3e7673caa890422e654d39b815e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75dbd5b8c3e3e3e7673caa890422e654d39b815e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddc7fd983736bef0e610e02f5ef08955ecd562bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc7fd983736bef0e610e02f5ef08955ecd562bb", "html_url": "https://github.com/rust-lang/rust/commit/ddc7fd983736bef0e610e02f5ef08955ecd562bb"}, {"sha": "c4068c76a863a07bfe0555699a65eec54abf6337", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4068c76a863a07bfe0555699a65eec54abf6337", "html_url": "https://github.com/rust-lang/rust/commit/c4068c76a863a07bfe0555699a65eec54abf6337"}], "stats": {"total": 81, "additions": 34, "deletions": 47}, "files": [{"sha": "130eb8005b069214e045f9ea40e7b8ca6c567434", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/75dbd5b8c3e3e3e7673caa890422e654d39b815e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75dbd5b8c3e3e3e7673caa890422e654d39b815e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=75dbd5b8c3e3e3e7673caa890422e654d39b815e", "patch": "@@ -148,12 +148,11 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n             // inherent impls without warning.\n             SkipLeakCheck::Yes,\n             overlap_mode,\n-            |overlap| {\n-                self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id, overlap);\n-                false\n-            },\n-            || true,\n-        );\n+        )\n+        .map_or(true, |overlap| {\n+            self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id, overlap);\n+            false\n+        });\n     }\n \n     fn check_item(&mut self, id: hir::ItemId) {"}, {"sha": "8aab75490a81b6b5b4e09e8a4741bd5ad0cb5262", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/75dbd5b8c3e3e3e7673caa890422e654d39b815e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75dbd5b8c3e3e3e7673caa890422e654d39b815e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=75dbd5b8c3e3e3e7673caa890422e654d39b815e", "patch": "@@ -60,23 +60,17 @@ pub fn add_placeholder_note(err: &mut Diagnostic) {\n     );\n }\n \n-/// If there are types that satisfy both impls, invokes `on_overlap`\n+/// If there are types that satisfy both impls, returns `Some`\n /// with a suitably-freshened `ImplHeader` with those types\n-/// substituted. Otherwise, invokes `no_overlap`.\n-#[instrument(skip(tcx, skip_leak_check, on_overlap, no_overlap), level = \"debug\")]\n-pub fn overlapping_impls<F1, F2, R>(\n+/// substituted. Otherwise, returns `None`.\n+#[instrument(skip(tcx, skip_leak_check), level = \"debug\")]\n+pub fn overlapping_impls(\n     tcx: TyCtxt<'_>,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     skip_leak_check: SkipLeakCheck,\n     overlap_mode: OverlapMode,\n-    on_overlap: F1,\n-    no_overlap: F2,\n-) -> R\n-where\n-    F1: FnOnce(OverlapResult<'_>) -> R,\n-    F2: FnOnce() -> R,\n-{\n+) -> Option<OverlapResult<'_>> {\n     // Before doing expensive operations like entering an inference context, do\n     // a quick check via fast_reject to tell if the impl headers could possibly\n     // unify.\n@@ -97,15 +91,15 @@ where\n     if !may_overlap {\n         // Some types involved are definitely different, so the impls couldn't possibly overlap.\n         debug!(\"overlapping_impls: fast_reject early-exit\");\n-        return no_overlap();\n+        return None;\n     }\n \n     let infcx = tcx.infer_ctxt().build();\n     let selcx = &mut SelectionContext::intercrate(&infcx);\n     let overlaps =\n         overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).is_some();\n     if !overlaps {\n-        return no_overlap();\n+        return None;\n     }\n \n     // In the case where we detect an error, run the check again, but\n@@ -114,7 +108,7 @@ where\n     let infcx = tcx.infer_ctxt().build();\n     let selcx = &mut SelectionContext::intercrate(&infcx);\n     selcx.enable_tracking_intercrate_ambiguity_causes();\n-    on_overlap(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).unwrap())\n+    Some(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).unwrap())\n }\n \n fn with_fresh_ty_vars<'cx, 'tcx>("}, {"sha": "63f89a33e8adc1765add4151f38441faca41e9a0", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/75dbd5b8c3e3e3e7673caa890422e654d39b815e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75dbd5b8c3e3e3e7673caa890422e654d39b815e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=75dbd5b8c3e3e3e7673caa890422e654d39b815e", "patch": "@@ -137,9 +137,8 @@ impl ChildrenExt<'_> for Children {\n                     impl_def_id,\n                     traits::SkipLeakCheck::default(),\n                     overlap_mode,\n-                    |_| true,\n-                    || false,\n-                );\n+                )\n+                .is_some();\n \n                 let error = create_overlap_error(overlap);\n \n@@ -162,34 +161,29 @@ impl ChildrenExt<'_> for Children {\n                 impl_def_id,\n                 traits::SkipLeakCheck::Yes,\n                 overlap_mode,\n-                |overlap| {\n-                    if let Some(overlap_kind) =\n-                        tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling)\n-                    {\n-                        match overlap_kind {\n-                            ty::ImplOverlapKind::Permitted { marker: _ } => {}\n-                            ty::ImplOverlapKind::Issue33140 => {\n-                                *last_lint_mut = Some(FutureCompatOverlapError {\n-                                    error: create_overlap_error(overlap),\n-                                    kind: FutureCompatOverlapErrorKind::Issue33140,\n-                                });\n-                            }\n+            )\n+            .map_or(Ok((false, false)), |overlap| {\n+                if let Some(overlap_kind) =\n+                    tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling)\n+                {\n+                    match overlap_kind {\n+                        ty::ImplOverlapKind::Permitted { marker: _ } => {}\n+                        ty::ImplOverlapKind::Issue33140 => {\n+                            *last_lint_mut = Some(FutureCompatOverlapError {\n+                                error: create_overlap_error(overlap),\n+                                kind: FutureCompatOverlapErrorKind::Issue33140,\n+                            });\n                         }\n-\n-                        return Ok((false, false));\n                     }\n \n-                    let le = tcx.specializes((impl_def_id, possible_sibling));\n-                    let ge = tcx.specializes((possible_sibling, impl_def_id));\n+                    return Ok((false, false));\n+                }\n \n-                    if le == ge {\n-                        report_overlap_error(overlap, last_lint_mut)\n-                    } else {\n-                        Ok((le, ge))\n-                    }\n-                },\n-                || Ok((false, false)),\n-            )?;\n+                let le = tcx.specializes((impl_def_id, possible_sibling));\n+                let ge = tcx.specializes((possible_sibling, impl_def_id));\n+\n+                if le == ge { report_overlap_error(overlap, last_lint_mut) } else { Ok((le, ge)) }\n+            })?;\n \n             if le && !ge {\n                 debug!("}]}