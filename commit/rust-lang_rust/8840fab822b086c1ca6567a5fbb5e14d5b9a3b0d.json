{"sha": "8840fab822b086c1ca6567a5fbb5e14d5b9a3b0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NDBmYWI4MjJiMDg2YzFjYTY1NjdhNWZiYjVlMTRkNWI5YTNiMGQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-12T06:15:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-12T19:14:07Z"}, "message": "Remove unused functions from std::vec", "tree": {"sha": "6fd7c2fa7bafea15b6eee0d212b3e4599d7d0117", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fd7c2fa7bafea15b6eee0d212b3e4599d7d0117"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8840fab822b086c1ca6567a5fbb5e14d5b9a3b0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8840fab822b086c1ca6567a5fbb5e14d5b9a3b0d", "html_url": "https://github.com/rust-lang/rust/commit/8840fab822b086c1ca6567a5fbb5e14d5b9a3b0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8840fab822b086c1ca6567a5fbb5e14d5b9a3b0d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "784884cc077270e9f53afc2849326ddb52b4e51c", "url": "https://api.github.com/repos/rust-lang/rust/commits/784884cc077270e9f53afc2849326ddb52b4e51c", "html_url": "https://github.com/rust-lang/rust/commit/784884cc077270e9f53afc2849326ddb52b4e51c"}], "stats": {"total": 316, "additions": 0, "deletions": 316}, "files": [{"sha": "e2323fad2debf4104a71dd72be02f4496a07b3a5", "filename": "src/lib/vec.rs", "status": "modified", "additions": 0, "deletions": 316, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/8840fab822b086c1ca6567a5fbb5e14d5b9a3b0d/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8840fab822b086c1ca6567a5fbb5e14d5b9a3b0d/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=8840fab822b086c1ca6567a5fbb5e14d5b9a3b0d", "patch": "@@ -9,8 +9,6 @@ export len;\n \n type vbuf = rustrt::vbuf;\n \n-type operator2[T, U, V] = fn(&T, &U) -> V ;\n-\n type array[T] = vec[mutable? T];\n \n native \"rust\" mod rustrt {\n@@ -37,324 +35,10 @@ native \"rust\" mod rustrt {\n     fn unsafe_vec_to_mut[T](v: vec[T]) -> vec[mutable T];\n }\n \n-fn alloc[T](n_elts: uint) -> vec[T] {\n-    ret rustrt::vec_alloc[vec[T], T](n_elts);\n-}\n-\n-fn alloc_mut[T](n_elts: uint) -> vec[mutable T] {\n-    ret rustrt::vec_alloc_mut[vec[mutable T], T](n_elts);\n-}\n-\n-fn refcount[T](v: array[T]) -> uint {\n-    let r = rustrt::refcount[T](v);\n-    if r == dbg::const_refcount { ret r; } else { ret r - 1u; }\n-}\n-\n-fn vec_from_vbuf[T](v: vbuf, n_elts: uint) -> vec[T] {\n-    ret rustrt::vec_from_vbuf[T](v, n_elts);\n-}\n-\n-\n-// FIXME: Remove me; this is a botch to get around rustboot's bad typechecker.\n-fn empty[T]() -> vec[T] { ret alloc[T](0u); }\n-\n-\n-// FIXME: Remove me; this is a botch to get around rustboot's bad typechecker.\n-fn empty_mut[T]() -> vec[mutable T] { ret alloc_mut[T](0u); }\n-\n-type init_op[T] = fn(uint) -> T ;\n-\n-fn init_fn[@T](op: &init_op[T], n_elts: uint) -> vec[T] {\n-    let v: vec[T] = alloc[T](n_elts);\n-    let i: uint = 0u;\n-    while i < n_elts { v += [op(i)]; i += 1u; }\n-    ret v;\n-}\n-\n-fn init_fn_mut[@T](op: &init_op[T], n_elts: uint) -> vec[mutable T] {\n-    let v: vec[mutable T] = alloc_mut[T](n_elts);\n-    let i: uint = 0u;\n-    while i < n_elts { v += [mutable op(i)]; i += 1u; }\n-    ret v;\n-}\n-\n-// init_elt: creates and returns a vector of length n_elts, filled with\n-// that many copies of element t.\n-fn init_elt[@T](t: &T, n_elts: uint) -> vec[T] {\n-    /**\n-     * FIXME (issue #81): should be:\n-     *\n-     * fn elt_op[T](&T x, uint i) -> T { ret x; }\n-     * let init_op[T] inner = bind elt_op[T](t, _);\n-     * ret init_fn[T](inner, n_elts);\n-     */\n-\n-    let v: vec[T] = alloc[T](n_elts);\n-    let i: uint = n_elts;\n-    while i > 0u { i -= 1u; v += [t]; }\n-    ret v;\n-}\n-\n-fn init_elt_mut[@T](t: &T, n_elts: uint) -> vec[mutable T] {\n-    let v: vec[mutable T] = alloc_mut[T](n_elts);\n-    let i: uint = n_elts;\n-    while i > 0u { i -= 1u; v += [mutable t]; }\n-    ret v;\n-}\n-\n fn buf[T](v: array[T]) -> vbuf { ret rustrt::vec_buf[T](v, 0u); }\n \n fn len[T](v: array[T]) -> uint { ret rustrt::vec_len[T](v); }\n \n-fn len_set[T](v: array[T], n: uint) { rustrt::vec_len_set[T](v, n); }\n-\n-fn buf_off[T](v: array[T], offset: uint) -> vbuf {\n-    assert (offset < len[T](v));\n-    ret rustrt::vec_buf[T](v, offset);\n-}\n-\n-fn print_debug_info[T](v: array[T]) { rustrt::vec_print_debug_info[T](v); }\n-\n-// FIXME: typestate precondition (list is non-empty)\n-// Returns the last element of v.\n-fn last[@T](v: array[T]) -> option::t[T] {\n-    let l = len[T](v);\n-    if l == 0u { ret none[T]; }\n-    ret some[T](v.(l - 1u));\n-}\n-\n-\n-// Returns elements from [start..end) from v.\n-fn slice[@T](v: array[T], start: uint, end: uint) -> vec[T] {\n-    assert (start <= end);\n-    assert (end <= len[T](v));\n-    let result = alloc[T](end - start);\n-    let i: uint = start;\n-    while i < end { result += [v.(i)]; i += 1u; }\n-    ret result;\n-}\n-\n-\n-// FIXME: Should go away eventually.\n-fn slice_mut[@T](v: array[T], start: uint, end: uint) -> vec[mutable T] {\n-    assert (start <= end);\n-    assert (end <= len[T](v));\n-    let result = alloc_mut[T](end - start);\n-    let i: uint = start;\n-    while i < end { result += [mutable v.(i)]; i += 1u; }\n-    ret result;\n-}\n-\n-fn shift[@T](v: &mutable array[T]) -> T {\n-    let ln = len[T](v);\n-    assert (ln > 0u);\n-    let e = v.(0);\n-    v = slice[T](v, 1u, ln);\n-    ret e;\n-}\n-\n-fn pop[@T](v: &mutable array[T]) -> T {\n-    let ln = len[T](v);\n-    assert (ln > 0u);\n-    ln -= 1u;\n-    let e = v.(ln);\n-    v = slice[T](v, 0u, ln);\n-    ret e;\n-}\n-\n-fn top[@T](v: &array[T]) -> T {\n-    let ln = len[T](v);\n-    assert (ln > 0u);\n-    ret v.(ln - 1u);\n-}\n-\n-fn push[@T](v: &mutable array[T], t: &T) { v += [t]; }\n-\n-fn unshift[@T](v: &mutable array[T], t: &T) {\n-    let rs = alloc[T](len[T](v) + 1u);\n-    rs += [t];\n-    rs += v;\n-    v = rs;\n-}\n-\n-fn grow[@T](v: &mutable array[T], n: uint, initval: &T) {\n-    let i: uint = n;\n-    while i > 0u { i -= 1u; v += [initval]; }\n-}\n-\n-fn grow_set[@T](v: &mutable vec[mutable T], index: uint, initval: &T,\n-               val: &T) {\n-    let length = vec::len(v);\n-    if index >= length { grow(v, index - length + 1u, initval); }\n-    v.(index) = val;\n-}\n-\n-fn grow_init_fn[@T](v: &mutable array[T], n: uint, init_fn: fn() -> T ) {\n-    let i: uint = n;\n-    while i > 0u { i -= 1u; v += [init_fn()]; }\n-}\n-\n-fn grow_init_fn_set[@T](v: &mutable array[T], index: uint, init_fn: fn() -> T,\n-                       val: &T) {\n-    let length = vec::len(v);\n-    if index >= length { grow_init_fn(v, index - length + 1u, init_fn); }\n-    v.(index) = val;\n-}\n-\n-fn map[@T, @U](f: &fn(&T) -> U , v: &vec[T]) -> vec[U] {\n-    let rs: vec[U] = alloc[U](len[T](v));\n-    for ve: T  in v { rs += [f(ve)]; }\n-    ret rs;\n-}\n-\n-fn filter_map[@T, @U](f: &fn(&T) -> option::t[U] , v: &vec[T]) -> vec[U] {\n-    let rs: vec[U] = [];\n-    for ve: T  in v { alt f(ve) { some(elt) { rs += [elt]; } none. { } } }\n-    ret rs;\n-}\n-\n-fn map2[@T, @U, @V](f: &operator2[T, U, V], v0: &vec[T], v1: &vec[U])\n-    -> vec[V] {\n-    let v0_len = len[T](v0);\n-    if v0_len != len[U](v1) { fail; }\n-    let u: vec[V] = alloc[V](v0_len);\n-    let i = 0u;\n-    while i < v0_len { u += [f({ v0.(i) }, { v1.(i) })]; i += 1u; }\n-    ret u;\n-}\n-\n-fn find[@T](f: fn(&T) -> bool , v: &vec[T]) -> option::t[T] {\n-    for elt: T  in v { if f(elt) { ret some[T](elt); } }\n-    ret none[T];\n-}\n-\n-fn position[@T](x: &T, v: &array[T]) -> option::t[uint] {\n-    let i: uint = 0u;\n-    while i < len(v) { if x == v.(i) { ret some[uint](i); } i += 1u; }\n-    ret none[uint];\n-}\n-\n-fn position_pred[T](f: fn(&T) -> bool , v: &vec[T]) -> option::t[uint] {\n-    let i: uint = 0u;\n-    while i < len(v) { if f(v.(i)) { ret some[uint](i); } i += 1u; }\n-    ret none[uint];\n-}\n-\n-fn member[T](x: &T, v: &array[T]) -> bool {\n-    for elt: T in v { if x == elt { ret true; } }\n-    ret false;\n-}\n-\n-fn count[T](x: &T, v: &array[T]) -> uint {\n-    let cnt = 0u;\n-    for elt: T  in v { if x == elt { cnt += 1u; } }\n-    ret cnt;\n-}\n-\n-fn foldl[@T, @U](p: fn(&U, &T) -> U , z: &U, v: &vec[T]) -> U {\n-    let sz = len[T](v);\n-    if sz == 0u {\n-        ret z;\n-    } else {\n-        let rest = slice[T](v, 1u, sz);\n-        ret p(foldl[T, U](p, z, rest), v.(0));\n-    }\n-}\n-\n-fn unzip[@T, @U](v: &vec[{_0: T, _1: U}]) -> {_0: vec[T], _1: vec[U]} {\n-    let sz = len(v);\n-    if sz == 0u {\n-        ret {_0: alloc[T](0u), _1: alloc[U](0u)};\n-    } else {\n-        let rest = slice(v, 1u, sz);\n-        let tl = unzip[T, U](rest);\n-        let a = [v.(0)._0];\n-        let b = [v.(0)._1];\n-        ret {_0: a + tl._0, _1: b + tl._1};\n-    }\n-}\n-\n-\n-// FIXME make the lengths being equal a constraint\n-fn zip[@T, @U](v: &vec[T], u: &vec[U]) -> vec[{_0: T, _1: U}] {\n-    let sz = len(v);\n-    assert (sz == len(u));\n-    if sz == 0u {\n-        ret alloc(0u);\n-    } else {\n-        let rest = zip(slice(v, 1u, sz), slice(u, 1u, sz));\n-        push(rest, {_0: v.(0), _1: u.(0)});\n-        ret rest;\n-    }\n-}\n-\n-fn or(v: &vec[bool]) -> bool {\n-    let f = orb;\n-    ret foldl[bool, bool](f, false, v);\n-}\n-\n-fn any[T](f: &fn(&T) -> bool , v: &vec[T]) -> bool {\n-    for t: T  in v { if f(t) { ret true; } }\n-    ret false;\n-}\n-fn all[T](f: &fn(&T) -> bool , v: &vec[T]) -> bool {\n-    for t: T  in v { if !f(t) { ret false; } }\n-    ret true;\n-}\n-\n-fn clone[@T](v: &vec[T]) -> vec[T] { ret slice[T](v, 0u, len[T](v)); }\n-\n-fn plus_option[@T](v: &mutable vec[T], o: &option::t[T]) {\n-    alt o { none. { } some(x) { v += [x]; } }\n-}\n-\n-fn cat_options[@T](v: &vec[option::t[T]]) -> vec[T] {\n-    let rs: vec[T] = [];\n-    for o: option::t[T]  in v { alt o { none. { } some(t) { rs += [t]; } } }\n-    ret rs;\n-}\n-\n-\n-// TODO: Remove in favor of built-in \"freeze\" operation when it's implemented.\n-fn freeze[@T](v: vec[mutable T]) -> vec[T] {\n-    let result: vec[T] = [];\n-    for elem: T  in v { result += [elem]; }\n-    ret result;\n-}\n-\n-\n-// Swaps two elements in a vector\n-fn swap[@T](v: &vec[mutable T], a: uint, b: uint) {\n-    let t: T = v.(a);\n-    v.(a) = v.(b);\n-    v.(b) = t;\n-}\n-\n-\n-// In place vector reversal\n-fn reverse[@T](v: &vec[mutable T]) {\n-    let i: uint = 0u;\n-    let ln = len[T](v);\n-    while i < ln / 2u { swap(v, i, ln - i - 1u); i += 1u; }\n-}\n-\n-\n-// Functional vector reversal. Returns a reversed copy of v.\n-fn reversed[@T](v: vec[T]) -> vec[T] {\n-    let rs: vec[T] = [];\n-    let i = len[T](v);\n-    if i == 0u { ret rs; } else { i -= 1u; }\n-    while i != 0u { push[T](rs, v.(i)); i -= 1u; }\n-    push[T](rs, v.(0));\n-    ret rs;\n-}\n-\n-\n-/// Truncates the vector to length `new_len`.\n-/// FIXME: This relies on a typechecker bug (covariance vs. invariance).\n-fn truncate[@T](v: &mutable vec[mutable? T], new_len: uint) {\n-    v = slice[T](v, 0u, new_len);\n-}\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}]}