{"sha": "dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "node_id": "C_kwDOAAsO6NoAKGRkOGVjOWM4OGQ0ZDg3OTg2Y2JmMjA4M2MzOThhYjZjNTJkYzNmODA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-13T13:47:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-13T13:47:53Z"}, "message": "Auto merge of #107586 - SparrowLii:parallel-query, r=cjgillot\n\nIntroduce `DynSend` and `DynSync` auto trait for parallel compiler\n\npart of parallel-rustc #101566\n\nThis PR introduces `DynSend / DynSync` trait and `FromDyn / IntoDyn` structure in rustc_data_structure::marker. `FromDyn` can dynamically check data structures for thread safety when switching to parallel environments (such as calling `par_for_each_in`). This happens only when `-Z threads > 1` so it doesn't affect single-threaded mode's compile efficiency.\n\nr? `@cjgillot`", "tree": {"sha": "22ad92e8e8006bb13148563bd267e6a09b552a88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22ad92e8e8006bb13148563bd267e6a09b552a88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "html_url": "https://github.com/rust-lang/rust/commit/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebf2b375e16b3b1422d48892d235d83a1b451802", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebf2b375e16b3b1422d48892d235d83a1b451802", "html_url": "https://github.com/rust-lang/rust/commit/ebf2b375e16b3b1422d48892d235d83a1b451802"}, {"sha": "d7e3e5bede187d113fa01c4d8b8c16a2bd4f721c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7e3e5bede187d113fa01c4d8b8c16a2bd4f721c", "html_url": "https://github.com/rust-lang/rust/commit/d7e3e5bede187d113fa01c4d8b8c16a2bd4f721c"}], "stats": {"total": 661, "additions": 554, "deletions": 107}, "files": [{"sha": "2560182e645d546abb96eae17685b21e968f55ba", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -3306,6 +3306,7 @@ dependencies = [\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n+ \"rustc_arena\",\n  \"rustc_graphviz\",\n  \"rustc_index\",\n  \"rustc_macros\","}, {"sha": "3f0b1627afa56a1614a6862b475ad01b83dc117d", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -48,14 +48,15 @@ pub enum TokenTree {\n     Delimited(DelimSpan, Delimiter, TokenStream),\n }\n \n-// Ensure all fields of `TokenTree` is `Send` and `Sync`.\n+// Ensure all fields of `TokenTree` are `DynSend` and `DynSync`.\n #[cfg(parallel_compiler)]\n fn _dummy()\n where\n-    Token: Send + Sync,\n-    DelimSpan: Send + Sync,\n-    Delimiter: Send + Sync,\n-    TokenStream: Send + Sync,\n+    Token: sync::DynSend + sync::DynSync,\n+    Spacing: sync::DynSend + sync::DynSync,\n+    DelimSpan: sync::DynSend + sync::DynSync,\n+    Delimiter: sync::DynSend + sync::DynSync,\n+    TokenStream: sync::DynSend + sync::DynSync,\n {\n }\n \n@@ -118,7 +119,7 @@ where\n     }\n }\n \n-pub trait ToAttrTokenStream: sync::Send + sync::Sync {\n+pub trait ToAttrTokenStream: sync::DynSend + sync::DynSync {\n     fn to_attr_token_stream(&self) -> AttrTokenStream;\n }\n "}, {"sha": "1805c6fabdff9a4ccedb92f00c17b36b065754a5", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -17,10 +17,7 @@ use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n-\n-use rustc_data_structures::sync::par_iter;\n-#[cfg(parallel_compiler)]\n-use rustc_data_structures::sync::ParallelIterator;\n+use rustc_data_structures::sync::par_map;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n@@ -689,7 +686,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // This likely is a temporary measure. Once we don't have to support the\n     // non-parallel compiler anymore, we can compile CGUs end-to-end in\n     // parallel and get rid of the complicated scheduling logic.\n-    let mut pre_compiled_cgus = if cfg!(parallel_compiler) {\n+    let mut pre_compiled_cgus = if tcx.sess.threads() > 1 {\n         tcx.sess.time(\"compile_first_CGU_batch\", || {\n             // Try to find one CGU to compile per thread.\n             let cgus: Vec<_> = cgu_reuse\n@@ -702,12 +699,10 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             // Compile the found CGUs in parallel.\n             let start_time = Instant::now();\n \n-            let pre_compiled_cgus = par_iter(cgus)\n-                .map(|(i, _)| {\n-                    let module = backend.compile_codegen_unit(tcx, codegen_units[i].name());\n-                    (i, module)\n-                })\n-                .collect();\n+            let pre_compiled_cgus = par_map(cgus, |(i, _)| {\n+                let module = backend.compile_codegen_unit(tcx, codegen_units[i].name());\n+                (i, module)\n+            });\n \n             total_codegen_time += start_time.elapsed();\n "}, {"sha": "684598eebe6ebb16c967ea29de487c5813303a84", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -22,6 +22,7 @@ use rustc_target::spec::Target;\n \n pub use rustc_data_structures::sync::MetadataRef;\n \n+use rustc_data_structures::sync::{DynSend, DynSync};\n use std::any::Any;\n \n pub trait BackendTypes {\n@@ -117,7 +118,9 @@ pub trait CodegenBackend {\n     ) -> Result<(), ErrorGuaranteed>;\n }\n \n-pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Send + Sync {\n+pub trait ExtraBackendMethods:\n+    CodegenBackend + WriteBackendMethods + Sized + Send + Sync + DynSend + DynSync\n+{\n     fn codegen_allocator<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "78f73d193e380f71938affdb41fbee4ed8f52979", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -16,6 +16,7 @@ libc = \"0.2\"\n measureme = \"10.0.0\"\n rustc-rayon-core = { version = \"0.5.0\", optional = true }\n rustc-rayon = { version = \"0.5.0\", optional = true }\n+rustc_arena = { path = \"../rustc_arena\" }\n rustc_graphviz = { path = \"../rustc_graphviz\" }\n rustc-hash = \"1.1.0\"\n rustc_index = { path = \"../rustc_index\", package = \"rustc_index\" }"}, {"sha": "5b9b0e106d254c807a5209653756b2f04c4deda6", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -26,6 +26,7 @@\n #![feature(test)]\n #![feature(thread_id_value)]\n #![feature(vec_into_raw_parts)]\n+#![feature(allocator_api)]\n #![feature(get_mut_unchecked)]\n #![feature(lint_reasons)]\n #![feature(unwrap_infallible)]\n@@ -77,6 +78,7 @@ pub mod sorted_map;\n pub mod stable_hasher;\n mod atomic_ref;\n pub mod fingerprint;\n+pub mod marker;\n pub mod profiling;\n pub mod sharded;\n pub mod stack;"}, {"sha": "f8c06f9a8145e6507d3b9c552d43d2e806140b93", "filename": "compiler/rustc_data_structures/src/marker.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_data_structures%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_data_structures%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmarker.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -0,0 +1,257 @@\n+cfg_if!(\n+    if #[cfg(not(parallel_compiler))] {\n+        pub auto trait DynSend {}\n+        pub auto trait DynSync {}\n+\n+        impl<T> DynSend for T {}\n+        impl<T> DynSync for T {}\n+    } else {\n+        #[rustc_on_unimplemented(\n+            message = \"`{Self}` doesn't implement `DynSend`. \\\n+            Add it to `rustc_data_structures::marker` or use `IntoDynSyncSend` if it's already `Send`\"\n+        )]\n+        // This is an auto trait for types which can be sent across threads if `sync::is_dyn_thread_safe()`\n+        // is true. These types can be wrapped in a `FromDyn` to get a `Send` type. Wrapping a\n+        // `Send` type in `IntoDynSyncSend` will create a `DynSend` type.\n+        pub unsafe auto trait DynSend {}\n+\n+        #[rustc_on_unimplemented(\n+            message = \"`{Self}` doesn't implement `DynSync`. \\\n+            Add it to `rustc_data_structures::marker` or use `IntoDynSyncSend` if it's already `Sync`\"\n+        )]\n+        // This is an auto trait for types which can be shared across threads if `sync::is_dyn_thread_safe()`\n+        // is true. These types can be wrapped in a `FromDyn` to get a `Sync` type. Wrapping a\n+        // `Sync` type in `IntoDynSyncSend` will create a `DynSync` type.\n+        pub unsafe auto trait DynSync {}\n+\n+        // Same with `Sync` and `Send`.\n+        unsafe impl<T: DynSync + ?Sized> DynSend for &T {}\n+\n+        macro_rules! impls_dyn_send_neg {\n+            ($([$t1: ty $(where $($generics1: tt)*)?])*) => {\n+                $(impl$(<$($generics1)*>)? !DynSend for $t1 {})*\n+            };\n+        }\n+\n+        // Consistent with `std`\n+        impls_dyn_send_neg!(\n+            [std::env::Args]\n+            [std::env::ArgsOs]\n+            [*const T where T: ?Sized]\n+            [*mut T where T: ?Sized]\n+            [std::ptr::NonNull<T> where T: ?Sized]\n+            [std::rc::Rc<T> where T: ?Sized]\n+            [std::rc::Weak<T> where T: ?Sized]\n+            [std::sync::MutexGuard<'_, T> where T: ?Sized]\n+            [std::sync::RwLockReadGuard<'_, T> where T: ?Sized]\n+            [std::sync::RwLockWriteGuard<'_, T> where T: ?Sized]\n+            [std::io::StdoutLock<'_>]\n+            [std::io::StderrLock<'_>]\n+        );\n+        cfg_if!(\n+            // Consistent with `std`\n+            // `os_imp::Env` is `!Send` in these platforms\n+            if #[cfg(any(unix, target_os = \"hermit\", target_os = \"wasi\", target_os = \"solid_asp3\"))] {\n+                impl !DynSend for std::env::VarsOs {}\n+            }\n+        );\n+\n+        macro_rules! already_send {\n+            ($([$ty: ty])*) => {\n+                $(unsafe impl DynSend for $ty where $ty: Send {})*\n+            };\n+        }\n+\n+        // These structures are already `Send`.\n+        already_send!(\n+            [std::backtrace::Backtrace]\n+            [std::io::Stdout]\n+            [std::io::Stderr]\n+            [std::io::Error]\n+            [std::fs::File]\n+            [rustc_arena::DroplessArena]\n+            [crate::memmap::Mmap]\n+            [crate::profiling::SelfProfiler]\n+            [crate::owned_slice::OwnedSlice]\n+        );\n+\n+        macro_rules! impl_dyn_send {\n+            ($($($attr: meta)* [$ty: ty where $($generics2: tt)*])*) => {\n+                $(unsafe impl<$($generics2)*> DynSend for $ty {})*\n+            };\n+        }\n+\n+        impl_dyn_send!(\n+            [std::sync::atomic::AtomicPtr<T> where T]\n+            [std::sync::Mutex<T> where T: ?Sized+ DynSend]\n+            [std::sync::mpsc::Sender<T> where T: DynSend]\n+            [std::sync::Arc<T> where T: ?Sized + DynSync + DynSend]\n+            [std::sync::LazyLock<T, F> where T: DynSend, F: DynSend]\n+            [std::collections::HashSet<K, S> where K: DynSend, S: DynSend]\n+            [std::collections::HashMap<K, V, S> where K: DynSend, V: DynSend, S: DynSend]\n+            [std::collections::BTreeMap<K, V, A> where K: DynSend, V: DynSend, A: std::alloc::Allocator + Clone + DynSend]\n+            [Vec<T, A> where T: DynSend, A: std::alloc::Allocator + DynSend]\n+            [Box<T, A> where T: ?Sized + DynSend, A: std::alloc::Allocator + DynSend]\n+            [crate::sync::Lock<T> where T: DynSend]\n+            [crate::sync::RwLock<T> where T: DynSend]\n+            [crate::tagged_ptr::CopyTaggedPtr<P, T, CP> where P: Send + crate::tagged_ptr::Pointer, T: Send + crate::tagged_ptr::Tag, const CP: bool]\n+            [rustc_arena::TypedArena<T> where T: DynSend]\n+            [indexmap::IndexSet<V, S> where V: DynSend, S: DynSend]\n+            [indexmap::IndexMap<K, V, S> where K: DynSend, V: DynSend, S: DynSend]\n+            [thin_vec::ThinVec<T> where T: DynSend]\n+            [smallvec::SmallVec<A> where A: smallvec::Array + DynSend]\n+        );\n+\n+        macro_rules! impls_dyn_sync_neg {\n+            ($([$t1: ty $(where $($generics1: tt)*)?])*) => {\n+                $(impl$(<$($generics1)*>)? !DynSync for $t1 {})*\n+            };\n+        }\n+\n+        // Consistent with `std`\n+        impls_dyn_sync_neg!(\n+            [std::env::Args]\n+            [std::env::ArgsOs]\n+            [*const T where T: ?Sized]\n+            [*mut T where T: ?Sized]\n+            [std::cell::Cell<T> where T: ?Sized]\n+            [std::cell::RefCell<T> where T: ?Sized]\n+            [std::cell::UnsafeCell<T> where T: ?Sized]\n+            [std::ptr::NonNull<T> where T: ?Sized]\n+            [std::rc::Rc<T> where T: ?Sized]\n+            [std::rc::Weak<T> where T: ?Sized]\n+            [std::cell::OnceCell<T> where T]\n+            [std::sync::mpsc::Receiver<T> where T]\n+            [std::sync::mpsc::Sender<T> where T]\n+        );\n+        cfg_if!(\n+            // Consistent with `std`\n+            // `os_imp::Env` is `!Sync` in these platforms\n+            if #[cfg(any(unix, target_os = \"hermit\", target_os = \"wasi\", target_os = \"solid_asp3\"))] {\n+                impl !DynSync for std::env::VarsOs {}\n+            }\n+        );\n+\n+        macro_rules! already_sync {\n+            ($([$ty: ty])*) => {\n+                $(unsafe impl DynSync for $ty where $ty: Sync {})*\n+            };\n+        }\n+\n+        // These structures are already `Sync`.\n+        already_sync!(\n+            [std::sync::atomic::AtomicBool]\n+            [std::sync::atomic::AtomicUsize]\n+            [std::sync::atomic::AtomicU8]\n+            [std::sync::atomic::AtomicU32]\n+            [std::sync::atomic::AtomicU64]\n+            [std::backtrace::Backtrace]\n+            [std::io::Error]\n+            [std::fs::File]\n+            [jobserver_crate::Client]\n+            [crate::memmap::Mmap]\n+            [crate::profiling::SelfProfiler]\n+            [crate::owned_slice::OwnedSlice]\n+        );\n+\n+        macro_rules! impl_dyn_sync {\n+            ($($($attr: meta)* [$ty: ty where $($generics2: tt)*])*) => {\n+                $(unsafe impl<$($generics2)*> DynSync for $ty {})*\n+            };\n+        }\n+\n+        impl_dyn_sync!(\n+            [std::sync::atomic::AtomicPtr<T> where T]\n+            [std::sync::OnceLock<T> where T: DynSend + DynSync]\n+            [std::sync::Mutex<T> where T: ?Sized + DynSend]\n+            [std::sync::Arc<T> where T: ?Sized + DynSync + DynSend]\n+            [std::sync::LazyLock<T, F> where T: DynSend + DynSync, F: DynSend]\n+            [std::collections::HashSet<K, S> where K: DynSync, S: DynSync]\n+            [std::collections::HashMap<K, V, S> where K: DynSync, V: DynSync, S: DynSync]\n+            [std::collections::BTreeMap<K, V, A> where K: DynSync, V: DynSync, A: std::alloc::Allocator + Clone + DynSync]\n+            [Vec<T, A> where T: DynSync, A: std::alloc::Allocator + DynSync]\n+            [Box<T, A> where T: ?Sized + DynSync, A: std::alloc::Allocator + DynSync]\n+            [crate::sync::Lock<T> where T: DynSend]\n+            [crate::sync::RwLock<T> where T: DynSend + DynSync]\n+            [crate::sync::OneThread<T> where T]\n+            [crate::sync::WorkerLocal<T> where T: DynSend]\n+            [crate::intern::Interned<'a, T> where 'a, T: DynSync]\n+            [crate::tagged_ptr::CopyTaggedPtr<P, T, CP> where P: Sync + crate::tagged_ptr::Pointer, T: Sync + crate::tagged_ptr::Tag, const CP: bool]\n+            [parking_lot::lock_api::Mutex<R, T> where R: DynSync, T: ?Sized + DynSend]\n+            [parking_lot::lock_api::RwLock<R, T> where R: DynSync, T: ?Sized + DynSend + DynSync]\n+            [indexmap::IndexSet<V, S> where V: DynSync, S: DynSync]\n+            [indexmap::IndexMap<K, V, S> where K: DynSync, V: DynSync, S: DynSync]\n+            [smallvec::SmallVec<A> where A: smallvec::Array + DynSync]\n+            [thin_vec::ThinVec<T> where T: DynSync]\n+        );\n+    }\n+);\n+\n+pub fn assert_dyn_sync<T: ?Sized + DynSync>() {}\n+pub fn assert_dyn_send<T: ?Sized + DynSend>() {}\n+pub fn assert_dyn_send_val<T: ?Sized + DynSend>(_t: &T) {}\n+pub fn assert_dyn_send_sync_val<T: ?Sized + DynSync + DynSend>(_t: &T) {}\n+\n+#[derive(Copy, Clone)]\n+pub struct FromDyn<T>(T);\n+\n+impl<T> FromDyn<T> {\n+    #[inline(always)]\n+    pub fn from(val: T) -> Self {\n+        // Check that `sync::is_dyn_thread_safe()` is true on creation so we can\n+        // implement `Send` and `Sync` for this structure when `T`\n+        // implements `DynSend` and `DynSync` respectively.\n+        #[cfg(parallel_compiler)]\n+        assert!(crate::sync::is_dyn_thread_safe());\n+        FromDyn(val)\n+    }\n+\n+    #[inline(always)]\n+    pub fn into_inner(self) -> T {\n+        self.0\n+    }\n+}\n+\n+// `FromDyn` is `Send` if `T` is `DynSend`, since it ensures that sync::is_dyn_thread_safe() is true.\n+#[cfg(parallel_compiler)]\n+unsafe impl<T: DynSend> Send for FromDyn<T> {}\n+\n+// `FromDyn` is `Sync` if `T` is `DynSync`, since it ensures that sync::is_dyn_thread_safe() is true.\n+#[cfg(parallel_compiler)]\n+unsafe impl<T: DynSync> Sync for FromDyn<T> {}\n+\n+impl<T> std::ops::Deref for FromDyn<T> {\n+    type Target = T;\n+\n+    #[inline(always)]\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+// A wrapper to convert a struct that is already a `Send` or `Sync` into\n+// an instance of `DynSend` and `DynSync`, since the compiler cannot infer\n+// it automatically in some cases. (e.g. Box<dyn Send / Sync>)\n+#[derive(Copy, Clone)]\n+pub struct IntoDynSyncSend<T: ?Sized>(pub T);\n+\n+#[cfg(parallel_compiler)]\n+unsafe impl<T: ?Sized + Send> DynSend for IntoDynSyncSend<T> {}\n+#[cfg(parallel_compiler)]\n+unsafe impl<T: ?Sized + Sync> DynSync for IntoDynSyncSend<T> {}\n+\n+impl<T> std::ops::Deref for IntoDynSyncSend<T> {\n+    type Target = T;\n+\n+    #[inline(always)]\n+    fn deref(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n+impl<T> std::ops::DerefMut for IntoDynSyncSend<T> {\n+    #[inline(always)]\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut self.0\n+    }\n+}"}, {"sha": "e151b8c2de04e6aff81c0df365eb495fec9e8c06", "filename": "compiler/rustc_data_structures/src/owned_slice/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -69,6 +69,6 @@ fn drop_drops() {\n \n #[test]\n fn send_sync() {\n-    crate::sync::assert_send::<OwnedSlice>();\n-    crate::sync::assert_sync::<OwnedSlice>();\n+    crate::sync::assert_dyn_send::<OwnedSlice>();\n+    crate::sync::assert_dyn_sync::<OwnedSlice>();\n }"}, {"sha": "8a778866a77e242b5689a3934185de396b6957ee", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 203, "deletions": 35, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -39,6 +39,7 @@\n //!\n //! [^2] `MTLockRef` is a typedef.\n \n+pub use crate::marker::*;\n use crate::owned_slice::OwnedSlice;\n use std::collections::HashMap;\n use std::hash::{BuildHasher, Hash};\n@@ -55,6 +56,42 @@ pub use vec::{AppendOnlyIndexVec, AppendOnlyVec};\n \n mod vec;\n \n+mod mode {\n+    use super::Ordering;\n+    use std::sync::atomic::AtomicU8;\n+\n+    const UNINITIALIZED: u8 = 0;\n+    const DYN_NOT_THREAD_SAFE: u8 = 1;\n+    const DYN_THREAD_SAFE: u8 = 2;\n+\n+    static DYN_THREAD_SAFE_MODE: AtomicU8 = AtomicU8::new(UNINITIALIZED);\n+\n+    // Whether thread safety is enabled (due to running under multiple threads).\n+    #[inline]\n+    pub fn is_dyn_thread_safe() -> bool {\n+        match DYN_THREAD_SAFE_MODE.load(Ordering::Relaxed) {\n+            DYN_NOT_THREAD_SAFE => false,\n+            DYN_THREAD_SAFE => true,\n+            _ => panic!(\"uninitialized dyn_thread_safe mode!\"),\n+        }\n+    }\n+\n+    // Only set by the `-Z threads` compile option\n+    pub fn set_dyn_thread_safe_mode(mode: bool) {\n+        let set: u8 = if mode { DYN_THREAD_SAFE } else { DYN_NOT_THREAD_SAFE };\n+        let previous = DYN_THREAD_SAFE_MODE.compare_exchange(\n+            UNINITIALIZED,\n+            set,\n+            Ordering::Relaxed,\n+            Ordering::Relaxed,\n+        );\n+\n+        // Check that the mode was either uninitialized or was already set to the requested mode.\n+        assert!(previous.is_ok() || previous == Err(set));\n+    }\n+}\n+\n+pub use mode::{is_dyn_thread_safe, set_dyn_thread_safe_mode};\n cfg_if! {\n     if #[cfg(not(parallel_compiler))] {\n         pub unsafe auto trait Send {}\n@@ -149,7 +186,7 @@ cfg_if! {\n \n         #[macro_export]\n         macro_rules! parallel {\n-            ($($blocks:tt),*) => {\n+            ($($blocks:block),*) => {\n                 // We catch panics here ensuring that all the blocks execute.\n                 // This makes behavior consistent with the parallel compiler.\n                 let mut panic = None;\n@@ -168,12 +205,6 @@ cfg_if! {\n             }\n         }\n \n-        pub use Iterator as ParallelIterator;\n-\n-        pub fn par_iter<T: IntoIterator>(t: T) -> T::IntoIter {\n-            t.into_iter()\n-        }\n-\n         pub fn par_for_each_in<T: IntoIterator>(t: T, mut for_each: impl FnMut(T::Item) + Sync + Send) {\n             // We catch panics here ensuring that all the loop iterations execute.\n             // This makes behavior consistent with the parallel compiler.\n@@ -190,6 +221,29 @@ cfg_if! {\n             }\n         }\n \n+        pub fn par_map<T: IntoIterator, R, C: FromIterator<R>>(\n+            t: T,\n+            mut map: impl FnMut(<<T as IntoIterator>::IntoIter as Iterator>::Item) -> R,\n+        ) -> C {\n+            // We catch panics here ensuring that all the loop iterations execute.\n+            let mut panic = None;\n+            let r = t.into_iter().filter_map(|i| {\n+                match catch_unwind(AssertUnwindSafe(|| map(i))) {\n+                    Ok(r) => Some(r),\n+                    Err(p) => {\n+                        if panic.is_none() {\n+                            panic = Some(p);\n+                        }\n+                        None\n+                    }\n+                }\n+            }).collect();\n+            if let Some(panic) = panic {\n+                resume_unwind(panic);\n+            }\n+            r\n+        }\n+\n         pub type MetadataRef = OwnedSlice;\n \n         pub use std::rc::Rc as Lrc;\n@@ -302,46 +356,165 @@ cfg_if! {\n         use parking_lot::RwLock as InnerRwLock;\n \n         use std::thread;\n-        pub use rayon::{join, scope};\n+\n+        #[inline]\n+        pub fn join<A, B, RA: DynSend, RB: DynSend>(oper_a: A, oper_b: B) -> (RA, RB)\n+        where\n+            A: FnOnce() -> RA + DynSend,\n+            B: FnOnce() -> RB + DynSend,\n+        {\n+            if mode::is_dyn_thread_safe() {\n+                let oper_a = FromDyn::from(oper_a);\n+                let oper_b = FromDyn::from(oper_b);\n+                let (a, b) = rayon::join(move || FromDyn::from(oper_a.into_inner()()), move || FromDyn::from(oper_b.into_inner()()));\n+                (a.into_inner(), b.into_inner())\n+            } else {\n+                (oper_a(), oper_b())\n+            }\n+        }\n+\n+        // This function only works when `mode::is_dyn_thread_safe()`.\n+        pub fn scope<'scope, OP, R>(op: OP) -> R\n+        where\n+            OP: FnOnce(&rayon::Scope<'scope>) -> R + DynSend,\n+            R: DynSend,\n+        {\n+            let op = FromDyn::from(op);\n+            rayon::scope(|s| FromDyn::from(op.into_inner()(s))).into_inner()\n+        }\n \n         /// Runs a list of blocks in parallel. The first block is executed immediately on\n         /// the current thread. Use that for the longest running block.\n         #[macro_export]\n         macro_rules! parallel {\n-            (impl $fblock:tt [$($c:tt,)*] [$block:tt $(, $rest:tt)*]) => {\n+            (impl $fblock:block [$($c:expr,)*] [$block:expr $(, $rest:expr)*]) => {\n                 parallel!(impl $fblock [$block, $($c,)*] [$($rest),*])\n             };\n-            (impl $fblock:tt [$($blocks:tt,)*] []) => {\n+            (impl $fblock:block [$($blocks:expr,)*] []) => {\n                 ::rustc_data_structures::sync::scope(|s| {\n+                    $(let block = rustc_data_structures::sync::FromDyn::from(|| $blocks);\n+                    s.spawn(move |_| block.into_inner()());)*\n+                    (|| $fblock)();\n+                });\n+            };\n+            ($fblock:block, $($blocks:block),*) => {\n+                if rustc_data_structures::sync::is_dyn_thread_safe() {\n+                    // Reverse the order of the later blocks since Rayon executes them in reverse order\n+                    // when using a single thread. This ensures the execution order matches that\n+                    // of a single threaded rustc.\n+                    parallel!(impl $fblock [] [$($blocks),*]);\n+                } else {\n+                    // We catch panics here ensuring that all the blocks execute.\n+                    // This makes behavior consistent with the parallel compiler.\n+                    let mut panic = None;\n+                    if let Err(p) = ::std::panic::catch_unwind(\n+                        ::std::panic::AssertUnwindSafe(|| $fblock)\n+                    ) {\n+                        if panic.is_none() {\n+                            panic = Some(p);\n+                        }\n+                    }\n                     $(\n-                        s.spawn(|_| $blocks);\n+                        if let Err(p) = ::std::panic::catch_unwind(\n+                            ::std::panic::AssertUnwindSafe(|| $blocks)\n+                        ) {\n+                            if panic.is_none() {\n+                                panic = Some(p);\n+                            }\n+                        }\n                     )*\n-                    $fblock;\n-                })\n-            };\n-            ($fblock:tt, $($blocks:tt),*) => {\n-                // Reverse the order of the later blocks since Rayon executes them in reverse order\n-                // when using a single thread. This ensures the execution order matches that\n-                // of a single threaded rustc\n-                parallel!(impl $fblock [] [$($blocks),*]);\n+                    if let Some(panic) = panic {\n+                        ::std::panic::resume_unwind(panic);\n+                    }\n+                }\n             };\n         }\n \n-        pub use rayon::iter::ParallelIterator;\n-        use rayon::iter::IntoParallelIterator;\n+        use rayon::iter::{FromParallelIterator, IntoParallelIterator, ParallelIterator};\n+\n+        pub fn par_for_each_in<I, T: IntoIterator<Item = I> + IntoParallelIterator<Item = I>>(\n+            t: T,\n+            for_each: impl Fn(I) + DynSync + DynSend\n+        ) {\n+            if mode::is_dyn_thread_safe() {\n+                let for_each = FromDyn::from(for_each);\n+                let panic: Lock<Option<_>> = Lock::new(None);\n+                t.into_par_iter().for_each(|i| if let Err(p) = catch_unwind(AssertUnwindSafe(|| for_each(i))) {\n+                    let mut l = panic.lock();\n+                    if l.is_none() {\n+                        *l = Some(p)\n+                    }\n+                });\n \n-        pub fn par_iter<T: IntoParallelIterator>(t: T) -> T::Iter {\n-            t.into_par_iter()\n+                if let Some(panic) = panic.into_inner() {\n+                    resume_unwind(panic);\n+                }\n+            } else {\n+                // We catch panics here ensuring that all the loop iterations execute.\n+                // This makes behavior consistent with the parallel compiler.\n+                let mut panic = None;\n+                t.into_iter().for_each(|i| {\n+                    if let Err(p) = catch_unwind(AssertUnwindSafe(|| for_each(i))) {\n+                        if panic.is_none() {\n+                            panic = Some(p);\n+                        }\n+                    }\n+                });\n+                if let Some(panic) = panic {\n+                    resume_unwind(panic);\n+                }\n+            }\n         }\n \n-        pub fn par_for_each_in<T: IntoParallelIterator>(\n+        pub fn par_map<\n+            I,\n+            T: IntoIterator<Item = I> + IntoParallelIterator<Item = I>,\n+            R: std::marker::Send,\n+            C: FromIterator<R> + FromParallelIterator<R>\n+        >(\n             t: T,\n-            for_each: impl Fn(T::Item) + Sync + Send,\n-        ) {\n-            let ps: Vec<_> = t.into_par_iter().map(|i| catch_unwind(AssertUnwindSafe(|| for_each(i)))).collect();\n-            ps.into_iter().for_each(|p| if let Err(panic) = p {\n-                resume_unwind(panic)\n-            });\n+            map: impl Fn(I) -> R + DynSync + DynSend\n+        ) -> C {\n+            if mode::is_dyn_thread_safe() {\n+                let panic: Lock<Option<_>> = Lock::new(None);\n+                let map = FromDyn::from(map);\n+                // We catch panics here ensuring that all the loop iterations execute.\n+                let r = t.into_par_iter().filter_map(|i| {\n+                    match catch_unwind(AssertUnwindSafe(|| map(i))) {\n+                        Ok(r) => Some(r),\n+                        Err(p) => {\n+                            let mut l = panic.lock();\n+                            if l.is_none() {\n+                                *l = Some(p);\n+                            }\n+                            None\n+                        },\n+                    }\n+                }).collect();\n+\n+                if let Some(panic) = panic.into_inner() {\n+                    resume_unwind(panic);\n+                }\n+                r\n+            } else {\n+                // We catch panics here ensuring that all the loop iterations execute.\n+                let mut panic = None;\n+                let r = t.into_iter().filter_map(|i| {\n+                    match catch_unwind(AssertUnwindSafe(|| map(i))) {\n+                        Ok(r) => Some(r),\n+                        Err(p) => {\n+                            if panic.is_none() {\n+                                panic = Some(p);\n+                            }\n+                            None\n+                        }\n+                    }\n+                }).collect();\n+                if let Some(panic) = panic {\n+                    resume_unwind(panic);\n+                }\n+                r\n+            }\n         }\n \n         pub type MetadataRef = OwnedSlice;\n@@ -352,11 +525,6 @@ cfg_if! {\n     }\n }\n \n-pub fn assert_sync<T: ?Sized + Sync>() {}\n-pub fn assert_send<T: ?Sized + Send>() {}\n-pub fn assert_send_val<T: ?Sized + Send>(_t: &T) {}\n-pub fn assert_send_sync_val<T: ?Sized + Sync + Send>(_t: &T) {}\n-\n #[derive(Default)]\n #[cfg_attr(parallel_compiler, repr(align(64)))]\n pub struct CacheAligned<T>(pub T);"}, {"sha": "80a9dfd251a796ccdcc48a74badb54420062b3bc", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -256,6 +256,9 @@ fn run_compiler(\n \n     let sopts = config::build_session_options(&matches);\n \n+    // Set parallel mode before thread pool creation, which will create `Lock`s.\n+    interface::set_thread_safe_mode(&sopts.unstable_opts);\n+\n     if let Some(ref code) = matches.opt_str(\"explain\") {\n         handle_explain(diagnostics_registry(), code, sopts.error_format);\n         return Ok(());"}, {"sha": "0accb4ab96f59a5e4440736693949202a53313dc", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -11,7 +11,7 @@ extern crate tracing;\n use fluent_bundle::FluentResource;\n use fluent_syntax::parser::ParserError;\n use icu_provider_adapters::fallback::{LocaleFallbackProvider, LocaleFallbacker};\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{IntoDynSyncSend, Lrc};\n use rustc_fluent_macro::fluent_messages;\n use rustc_macros::{Decodable, Encodable};\n use rustc_span::Span;\n@@ -37,16 +37,17 @@ pub use unic_langid::{langid, LanguageIdentifier};\n \n fluent_messages! { \"../messages.ftl\" }\n \n-pub type FluentBundle = fluent_bundle::bundle::FluentBundle<FluentResource, IntlLangMemoizer>;\n+pub type FluentBundle =\n+    IntoDynSyncSend<fluent_bundle::bundle::FluentBundle<FluentResource, IntlLangMemoizer>>;\n \n-#[cfg(parallel_compiler)]\n+#[cfg(not(parallel_compiler))]\n fn new_bundle(locales: Vec<LanguageIdentifier>) -> FluentBundle {\n-    FluentBundle::new_concurrent(locales)\n+    IntoDynSyncSend(fluent_bundle::bundle::FluentBundle::new(locales))\n }\n \n-#[cfg(not(parallel_compiler))]\n+#[cfg(parallel_compiler)]\n fn new_bundle(locales: Vec<LanguageIdentifier>) -> FluentBundle {\n-    FluentBundle::new(locales)\n+    IntoDynSyncSend(fluent_bundle::bundle::FluentBundle::new_concurrent(locales))\n }\n \n #[derive(Debug)]"}, {"sha": "22c41f7b93f8a59e4eac5830d59949245b83fb71", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -32,7 +32,7 @@ use emitter::{is_case_difference, Emitter, EmitterWriter};\n use registry::Registry;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::stable_hasher::{Hash128, StableHasher};\n-use rustc_data_structures::sync::{self, Lock, Lrc};\n+use rustc_data_structures::sync::{self, IntoDynSyncSend, Lock, Lrc};\n use rustc_data_structures::AtomicRef;\n pub use rustc_error_messages::{\n     fallback_fluent_bundle, fluent_bundle, DelayDm, DiagnosticMessage, FluentBundle,\n@@ -409,7 +409,7 @@ struct HandlerInner {\n     err_count: usize,\n     warn_count: usize,\n     deduplicated_err_count: usize,\n-    emitter: Box<dyn Emitter + sync::Send>,\n+    emitter: IntoDynSyncSend<Box<dyn Emitter + sync::Send>>,\n     delayed_span_bugs: Vec<DelayedDiagnostic>,\n     delayed_good_path_bugs: Vec<DelayedDiagnostic>,\n     /// This flag indicates that an expected diagnostic was emitted and suppressed.\n@@ -605,7 +605,7 @@ impl Handler {\n                 warn_count: 0,\n                 deduplicated_err_count: 0,\n                 deduplicated_warn_count: 0,\n-                emitter,\n+                emitter: IntoDynSyncSend(emitter),\n                 delayed_span_bugs: Vec::new(),\n                 delayed_good_path_bugs: Vec::new(),\n                 suppressed_expected_diag: false,"}, {"sha": "0e729b716803f033b92594f920e241c26b6a6b3d", "filename": "compiler/rustc_errors/src/tests.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_errors%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_errors%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftests.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -2,7 +2,7 @@ use crate::error::{TranslateError, TranslateErrorKind};\n use crate::fluent_bundle::*;\n use crate::translation::Translate;\n use crate::FluentBundle;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{IntoDynSyncSend, Lrc};\n use rustc_error_messages::fluent_bundle::resolver::errors::{ReferenceKind, ResolverError};\n use rustc_error_messages::langid;\n use rustc_error_messages::DiagnosticMessage;\n@@ -27,10 +27,14 @@ fn make_dummy(ftl: &'static str) -> Dummy {\n     let langid_en = langid!(\"en-US\");\n \n     #[cfg(parallel_compiler)]\n-    let mut bundle = FluentBundle::new_concurrent(vec![langid_en]);\n+    let mut bundle: FluentBundle =\n+        IntoDynSyncSend(crate::fluent_bundle::bundle::FluentBundle::new_concurrent(vec![\n+            langid_en,\n+        ]));\n \n     #[cfg(not(parallel_compiler))]\n-    let mut bundle = FluentBundle::new(vec![langid_en]);\n+    let mut bundle: FluentBundle =\n+        IntoDynSyncSend(crate::fluent_bundle::bundle::FluentBundle::new(vec![langid_en]));\n \n     bundle.add_resource(resource).expect(\"Failed to add FTL resources to the bundle.\");\n "}, {"sha": "e03576c55f43687f41f9cc8f4127ec5e1f07a4e5", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -653,29 +653,29 @@ pub enum SyntaxExtensionKind {\n     /// A token-based function-like macro.\n     Bang(\n         /// An expander with signature TokenStream -> TokenStream.\n-        Box<dyn BangProcMacro + sync::Sync + sync::Send>,\n+        Box<dyn BangProcMacro + sync::DynSync + sync::DynSend>,\n     ),\n \n     /// An AST-based function-like macro.\n     LegacyBang(\n         /// An expander with signature TokenStream -> AST.\n-        Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n+        Box<dyn TTMacroExpander + sync::DynSync + sync::DynSend>,\n     ),\n \n     /// A token-based attribute macro.\n     Attr(\n         /// An expander with signature (TokenStream, TokenStream) -> TokenStream.\n         /// The first TokenSteam is the attribute itself, the second is the annotated item.\n         /// The produced TokenSteam replaces the input TokenSteam.\n-        Box<dyn AttrProcMacro + sync::Sync + sync::Send>,\n+        Box<dyn AttrProcMacro + sync::DynSync + sync::DynSend>,\n     ),\n \n     /// An AST-based attribute macro.\n     LegacyAttr(\n         /// An expander with signature (AST, AST) -> AST.\n         /// The first AST fragment is the attribute itself, the second is the annotated item.\n         /// The produced AST fragment replaces the input AST fragment.\n-        Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n+        Box<dyn MultiItemModifier + sync::DynSync + sync::DynSend>,\n     ),\n \n     /// A trivial attribute \"macro\" that does nothing,\n@@ -692,14 +692,14 @@ pub enum SyntaxExtensionKind {\n         /// is handled identically to `LegacyDerive`. It should be migrated to\n         /// a token-based representation like `Bang` and `Attr`, instead of\n         /// using `MultiItemModifier`.\n-        Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n+        Box<dyn MultiItemModifier + sync::DynSync + sync::DynSend>,\n     ),\n \n     /// An AST-based derive macro.\n     LegacyDerive(\n         /// An expander with signature AST -> AST.\n         /// The produced AST fragment is appended to the input AST fragment.\n-        Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n+        Box<dyn MultiItemModifier + sync::DynSync + sync::DynSend>,\n     ),\n }\n "}, {"sha": "3af3012649da6ed0d52d4d204cdbd94959debe94", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -60,6 +60,11 @@ impl Compiler {\n     }\n }\n \n+#[allow(rustc::bad_opt_access)]\n+pub fn set_thread_safe_mode(sopts: &config::UnstableOptions) {\n+    rustc_data_structures::sync::set_dyn_thread_safe_mode(sopts.threads > 1);\n+}\n+\n /// Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`.\n pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String>)> {\n     rustc_span::create_default_session_if_not_set_then(move |_| {"}, {"sha": "1d0c43e95e0859e1d5c2a33cb7137608e5a67094", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -49,9 +49,9 @@ use std::cell::Cell;\n use std::iter;\n use std::slice;\n \n-type EarlyLintPassFactory = dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync;\n+type EarlyLintPassFactory = dyn Fn() -> EarlyLintPassObject + sync::DynSend + sync::DynSync;\n type LateLintPassFactory =\n-    dyn for<'tcx> Fn(TyCtxt<'tcx>) -> LateLintPassObject<'tcx> + sync::Send + sync::Sync;\n+    dyn for<'tcx> Fn(TyCtxt<'tcx>) -> LateLintPassObject<'tcx> + sync::DynSend + sync::DynSync;\n \n /// Information about the registered lints.\n ///\n@@ -169,7 +169,7 @@ impl LintStore {\n \n     pub fn register_early_pass(\n         &mut self,\n-        pass: impl Fn() -> EarlyLintPassObject + 'static + sync::Send + sync::Sync,\n+        pass: impl Fn() -> EarlyLintPassObject + 'static + sync::DynSend + sync::DynSync,\n     ) {\n         self.early_passes.push(Box::new(pass));\n     }\n@@ -182,7 +182,7 @@ impl LintStore {\n     /// * See [rust-clippy#5518](https://github.com/rust-lang/rust-clippy/pull/5518)\n     pub fn register_pre_expansion_pass(\n         &mut self,\n-        pass: impl Fn() -> EarlyLintPassObject + 'static + sync::Send + sync::Sync,\n+        pass: impl Fn() -> EarlyLintPassObject + 'static + sync::DynSend + sync::DynSync,\n     ) {\n         self.pre_expansion_passes.push(Box::new(pass));\n     }\n@@ -191,8 +191,8 @@ impl LintStore {\n         &mut self,\n         pass: impl for<'tcx> Fn(TyCtxt<'tcx>) -> LateLintPassObject<'tcx>\n         + 'static\n-        + sync::Send\n-        + sync::Sync,\n+        + sync::DynSend\n+        + sync::DynSync,\n     ) {\n         self.late_passes.push(Box::new(pass));\n     }\n@@ -201,8 +201,8 @@ impl LintStore {\n         &mut self,\n         pass: impl for<'tcx> Fn(TyCtxt<'tcx>) -> LateLintPassObject<'tcx>\n         + 'static\n-        + sync::Send\n-        + sync::Sync,\n+        + sync::DynSend\n+        + sync::DynSync,\n     ) {\n         self.late_module_passes.push(Box::new(pass));\n     }"}, {"sha": "c9781a72704f412832de20e4542e1fad3951abad", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -16,7 +16,7 @@\n \n use crate::{passes::LateLintPassObject, LateContext, LateLintPass, LintStore};\n use rustc_ast as ast;\n-use rustc_data_structures::sync::join;\n+use rustc_data_structures::sync::{join, DynSend};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit as hir_visit;\n@@ -429,7 +429,7 @@ fn late_lint_crate_inner<'tcx, T: LateLintPass<'tcx>>(\n /// Performs lint checking on a crate.\n pub fn check_crate<'tcx, T: LateLintPass<'tcx> + 'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    builtin_lints: impl FnOnce() -> T + Send,\n+    builtin_lints: impl FnOnce() -> T + Send + DynSend,\n ) {\n     join(\n         || {"}, {"sha": "8a643b35f1555859851b6db998c958301c20015e", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -8,7 +8,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::memmap::{Mmap, MmapMut};\n use rustc_data_structures::stable_hasher::{Hash128, HashStable, StableHasher};\n-use rustc_data_structures::sync::{join, par_iter, Lrc, ParallelIterator};\n+use rustc_data_structures::sync::{join, par_for_each_in, Lrc};\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n@@ -2131,7 +2131,7 @@ fn prefetch_mir(tcx: TyCtxt<'_>) {\n         return;\n     }\n \n-    par_iter(tcx.mir_keys(())).for_each(|&def_id| {\n+    par_for_each_in(tcx.mir_keys(()), |&def_id| {\n         let (encode_const, encode_opt) = should_encode_mir(tcx, def_id);\n \n         if encode_const {"}, {"sha": "5bf0938d518695502deb8a52a2fe6e7555d4725c", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -5,7 +5,7 @@ use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n+use rustc_data_structures::sync::{par_for_each_in, DynSend, DynSync};\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n@@ -150,11 +150,6 @@ impl<'hir> Map<'hir> {\n         self.tcx.hir_module_items(module).items()\n     }\n \n-    #[inline]\n-    pub fn par_for_each_item(self, f: impl Fn(ItemId) + Sync + Send) {\n-        par_for_each_in(&self.tcx.hir_crate_items(()).items[..], |id| f(*id));\n-    }\n-\n     pub fn def_key(self, def_id: LocalDefId) -> DefKey {\n         // Accessing the DefKey is ok, since it is part of DefPathHash.\n         self.tcx.definitions_untracked().def_key(def_id)\n@@ -502,7 +497,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn par_body_owners(self, f: impl Fn(LocalDefId) + Sync + Send) {\n+    pub fn par_body_owners(self, f: impl Fn(LocalDefId) + DynSend + DynSync) {\n         par_for_each_in(&self.tcx.hir_crate_items(()).body_owners[..], |&def_id| f(def_id));\n     }\n \n@@ -640,7 +635,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn par_for_each_module(self, f: impl Fn(LocalDefId) + Sync + Send) {\n+    pub fn par_for_each_module(self, f: impl Fn(LocalDefId) + DynSend + DynSync) {\n         let crate_items = self.tcx.hir_crate_items(());\n         par_for_each_in(&crate_items.submodules[..], |module| f(module.def_id))\n     }"}, {"sha": "a867a13e061eae04a73c25c3ee4247e415354e73", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -9,7 +9,7 @@ pub mod place;\n use crate::ty::query::Providers;\n use crate::ty::{EarlyBinder, ImplSubject, TyCtxt};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n+use rustc_data_structures::sync::{par_for_each_in, DynSend, DynSync};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::*;\n use rustc_query_system::ich::StableHashingContext;\n@@ -77,19 +77,19 @@ impl ModuleItems {\n         self.owners().map(|id| id.def_id)\n     }\n \n-    pub fn par_items(&self, f: impl Fn(ItemId) + Send + Sync) {\n+    pub fn par_items(&self, f: impl Fn(ItemId) + DynSend + DynSync) {\n         par_for_each_in(&self.items[..], |&id| f(id))\n     }\n \n-    pub fn par_trait_items(&self, f: impl Fn(TraitItemId) + Send + Sync) {\n+    pub fn par_trait_items(&self, f: impl Fn(TraitItemId) + DynSend + DynSync) {\n         par_for_each_in(&self.trait_items[..], |&id| f(id))\n     }\n \n-    pub fn par_impl_items(&self, f: impl Fn(ImplItemId) + Send + Sync) {\n+    pub fn par_impl_items(&self, f: impl Fn(ImplItemId) + DynSend + DynSync) {\n         par_for_each_in(&self.impl_items[..], |&id| f(id))\n     }\n \n-    pub fn par_foreign_items(&self, f: impl Fn(ForeignItemId) + Send + Sync) {\n+    pub fn par_foreign_items(&self, f: impl Fn(ForeignItemId) + DynSend + DynSync) {\n         par_for_each_in(&self.foreign_items[..], |&id| f(id))\n     }\n }"}, {"sha": "2ecd014acdfbca32fd36d67c793816af73d70069", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -496,7 +496,7 @@ pub struct GlobalCtxt<'tcx> {\n     ///\n     /// FIXME(Centril): consider `dyn LintStoreMarker` once\n     /// we can upcast to `Any` for some additional type safety.\n-    pub lint_store: Lrc<dyn Any + sync::Sync + sync::Send>,\n+    pub lint_store: Lrc<dyn Any + sync::DynSync + sync::DynSend>,\n \n     pub dep_graph: DepGraph,\n \n@@ -648,7 +648,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_global_ctxt(\n         s: &'tcx Session,\n-        lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n+        lint_store: Lrc<dyn Any + sync::DynSend + sync::DynSync>,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         hir_arena: &'tcx WorkerLocal<hir::Arena<'tcx>>,\n         untracked: Untracked,"}, {"sha": "bf9806f64069ff51ef0c903be885fa00134d0a36", "filename": "compiler/rustc_middle/src/ty/context/tls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -94,8 +94,8 @@ where\n         f(None)\n     } else {\n         // We could get an `ImplicitCtxt` pointer from another thread.\n-        // Ensure that `ImplicitCtxt` is `Sync`.\n-        sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n+        // Ensure that `ImplicitCtxt` is `DynSync`.\n+        sync::assert_dyn_sync::<ImplicitCtxt<'_, '_>>();\n \n         unsafe { f(Some(downcast(context))) }\n     }"}, {"sha": "71911a5a61877845bf793e522e39f18193dccec7", "filename": "compiler/rustc_middle/src/ty/list.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flist.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -199,6 +199,12 @@ impl<'a, T: Copy> IntoIterator for &'a List<T> {\n \n unsafe impl<T: Sync> Sync for List<T> {}\n \n+// We need this since `List` uses extern type `OpaqueListContents`.\n+#[cfg(parallel_compiler)]\n+use rustc_data_structures::sync::DynSync;\n+#[cfg(parallel_compiler)]\n+unsafe impl<T: DynSync> DynSync for List<T> {}\n+\n // Safety:\n // Layouts of `Equivalent<T>` and `List<T>` are the same, modulo opaque tail,\n // thus aligns of `Equivalent<T>` and `List<T>` must be the same."}, {"sha": "8089d81cc22c916aa177e9b3e52e4c6fedc22d0e", "filename": "compiler/rustc_session/src/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcstore.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -207,7 +207,7 @@ pub trait MetadataLoader: std::fmt::Debug {\n     fn get_dylib_metadata(&self, target: &Target, filename: &Path) -> Result<MetadataRef, String>;\n }\n \n-pub type MetadataLoaderDyn = dyn MetadataLoader + Send + Sync;\n+pub type MetadataLoaderDyn = dyn MetadataLoader + Send + Sync + sync::DynSend + sync::DynSync;\n \n /// A store of Rust crates, through which their metadata can be accessed.\n ///\n@@ -252,7 +252,7 @@ pub trait CrateStore: std::fmt::Debug {\n     fn import_source_files(&self, sess: &Session, cnum: CrateNum);\n }\n \n-pub type CrateStoreDyn = dyn CrateStore + sync::Sync + sync::Send;\n+pub type CrateStoreDyn = dyn CrateStore + sync::DynSync + sync::DynSend;\n \n pub struct Untracked {\n     pub cstore: RwLock<Box<CrateStoreDyn>>,"}, {"sha": "8238a16969d9baa90b3f5ea54fef4efb47abd2f8", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -14,7 +14,9 @@ pub use crate::*;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{Hash128, Hash64, StableHasher};\n-use rustc_data_structures::sync::{AtomicU32, Lrc, MappedReadGuard, ReadGuard, RwLock};\n+use rustc_data_structures::sync::{\n+    AtomicU32, IntoDynSyncSend, Lrc, MappedReadGuard, ReadGuard, RwLock,\n+};\n use std::cmp;\n use std::hash::Hash;\n use std::path::{self, Path, PathBuf};\n@@ -176,7 +178,7 @@ pub struct SourceMap {\n     used_address_space: AtomicU32,\n \n     files: RwLock<SourceMapFiles>,\n-    file_loader: Box<dyn FileLoader + Sync + Send>,\n+    file_loader: IntoDynSyncSend<Box<dyn FileLoader + Sync + Send>>,\n     // This is used to apply the file path remapping as specified via\n     // `--remap-path-prefix` to all `SourceFile`s allocated within this `SourceMap`.\n     path_mapping: FilePathMapping,\n@@ -202,7 +204,7 @@ impl SourceMap {\n         SourceMap {\n             used_address_space: AtomicU32::new(0),\n             files: Default::default(),\n-            file_loader,\n+            file_loader: IntoDynSyncSend(file_loader),\n             path_mapping,\n             hash_kind,\n         }"}, {"sha": "5460bce21a512f3ba5b61279accaf1f7165fd654", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=dd8ec9c88d4d87986cbf2083c398ab6c52dc3f80", "patch": "@@ -739,6 +739,9 @@ fn main_args(at_args: &[String]) -> MainResult {\n         }\n     };\n \n+    // Set parallel mode before error handler creation, which will create `Lock`s.\n+    interface::set_thread_safe_mode(&options.unstable_opts);\n+\n     let diag = core::new_handler(\n         options.error_format,\n         None,"}]}