{"sha": "6557f4b2693af38910a9469a5a038f6a116419b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NTdmNGIyNjkzYWYzODkxMGE5NDY5YTVhMDM4ZjZhMTE2NDE5YjI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2015-04-02T16:14:53Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2015-04-16T02:48:09Z"}, "message": "syntax: Rename deriving/cmp/* to match their current names", "tree": {"sha": "f7418f091e8d50767283842b4b5161a2d9573929", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7418f091e8d50767283842b4b5161a2d9573929"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6557f4b2693af38910a9469a5a038f6a116419b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6557f4b2693af38910a9469a5a038f6a116419b2", "html_url": "https://github.com/rust-lang/rust/commit/6557f4b2693af38910a9469a5a038f6a116419b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6557f4b2693af38910a9469a5a038f6a116419b2/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "html_url": "https://github.com/rust-lang/rust/commit/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed"}], "stats": {"total": 830, "additions": 415, "deletions": 415}, "files": [{"sha": "6418450685e39d88a3857afa74739d0e576e12aa", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 30, "deletions": 56, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6557f4b2693af38910a9469a5a038f6a116419b2/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6557f4b2693af38910a9469a5a038f6a116419b2/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=6557f4b2693af38910a9469a5a038f6a116419b2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr, self};\n+use ast::{MetaItem, Item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -24,70 +24,44 @@ pub fn expand_deriving_eq<F>(cx: &mut ExtCtxt,\n                              push: F) where\n     F: FnOnce(P<Item>),\n {\n-    // structures are equal if all fields are equal, and non equal, if\n-    // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_fold(\n-            true,  // use foldl\n-            |cx, span, subexpr, self_f, other_fs| {\n-                let other_f = match other_fs {\n-                    [ref o_f] => o_f,\n-                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n-                };\n-\n-                let eq = cx.expr_binary(span, ast::BiEq, self_f, other_f.clone());\n-\n-                cx.expr_binary(span, ast::BiAnd, subexpr, eq)\n-            },\n-            cx.expr_bool(span, true),\n-            Box::new(|cx, span, _, _| cx.expr_bool(span, false)),\n-            cx, span, substr)\n-    }\n-    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_fold(\n-            true,  // use foldl\n-            |cx, span, subexpr, self_f, other_fs| {\n-                let other_f = match other_fs {\n-                    [ref o_f] => o_f,\n-                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n-                };\n-\n-                let eq = cx.expr_binary(span, ast::BiNe, self_f, other_f.clone());\n-\n-                cx.expr_binary(span, ast::BiOr, subexpr, eq)\n-            },\n-            cx.expr_bool(span, false),\n-            Box::new(|cx, span, _, _| cx.expr_bool(span, true)),\n-            cx, span, substr)\n+    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n+        cs_same_method(|cx, span, exprs| {\n+            // create `a.<method>(); b.<method>(); c.<method>(); ...`\n+            // (where method is `assert_receiver_is_total_eq`)\n+            let stmts = exprs.into_iter().map(|e| cx.stmt_expr(e)).collect();\n+            let block = cx.block(span, stmts, None);\n+            cx.expr_block(block)\n+        },\n+                       Box::new(|cx, sp, _, _| {\n+                           cx.span_bug(sp, \"non matching enums in derive(Eq)?\") }),\n+                       cx,\n+                       span,\n+                       substr)\n     }\n \n-    macro_rules! md {\n-        ($name:expr, $f:ident) => { {\n-            let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-            let attrs = vec!(cx.attribute(span, inline));\n+    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let hidden = cx.meta_word(span, InternedString::new(\"hidden\"));\n+    let doc = cx.meta_list(span, InternedString::new(\"doc\"), vec!(hidden));\n+    let attrs = vec!(cx.attribute(span, inline),\n+                     cx.attribute(span, doc));\n+    let trait_def = TraitDef {\n+        span: span,\n+        attributes: Vec::new(),\n+        path: path_std!(cx, core::cmp::Eq),\n+        additional_bounds: Vec::new(),\n+        generics: LifetimeBounds::empty(),\n+        methods: vec!(\n             MethodDef {\n-                name: $name,\n+                name: \"assert_receiver_is_total_eq\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(borrowed_self()),\n-                ret_ty: Literal(path_local!(bool)),\n+                args: vec!(),\n+                ret_ty: nil_ty(),\n                 attributes: attrs,\n                 combine_substructure: combine_substructure(Box::new(|a, b, c| {\n-                    $f(a, b, c)\n+                    cs_total_eq_assert(a, b, c)\n                 }))\n             }\n-        } }\n-    }\n-\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: Vec::new(),\n-        path: path_std!(cx, core::cmp::PartialEq),\n-        additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n-        methods: vec!(\n-            md!(\"eq\", cs_eq),\n-            md!(\"ne\", cs_ne)\n         ),\n         associated_types: Vec::new(),\n     };"}, {"sha": "1de955856e712c208d5375574ccf3e7de76096c4", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 44, "deletions": 140, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/6557f4b2693af38910a9469a5a038f6a116419b2/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6557f4b2693af38910a9469a5a038f6a116419b2/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=6557f4b2693af38910a9469a5a038f6a116419b2", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::OrderingOp::*;\n-\n use ast;\n use ast::{MetaItem, Item, Expr};\n use codemap::Span;\n@@ -20,114 +18,72 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_ord<F>(cx: &mut ExtCtxt,\n-                              span: Span,\n-                              mitem: &MetaItem,\n-                              item: &Item,\n-                              push: F) where\n+pub fn expand_deriving_totalord<F>(cx: &mut ExtCtxt,\n+                                   span: Span,\n+                                   mitem: &MetaItem,\n+                                   item: &Item,\n+                                   push: F) where\n     F: FnOnce(P<Item>),\n {\n-    macro_rules! md {\n-        ($name:expr, $op:expr, $equal:expr) => { {\n-            let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-            let attrs = vec!(cx.attribute(span, inline));\n+    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let attrs = vec!(cx.attribute(span, inline));\n+    let trait_def = TraitDef {\n+        span: span,\n+        attributes: Vec::new(),\n+        path: path_std!(cx, core::cmp::Ord),\n+        additional_bounds: Vec::new(),\n+        generics: LifetimeBounds::empty(),\n+        methods: vec!(\n             MethodDef {\n-                name: $name,\n+                name: \"cmp\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: vec!(borrowed_self()),\n-                ret_ty: Literal(path_local!(bool)),\n+                ret_ty: Literal(path_std!(cx, core::cmp::Ordering)),\n                 attributes: attrs,\n-                combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n-                    cs_op($op, $equal, cx, span, substr)\n-                }))\n+                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n+                    cs_cmp(a, b, c)\n+                })),\n             }\n-        } }\n-    }\n-\n-    let ordering_ty = Literal(path_std!(cx, core::cmp::Ordering));\n-    let ret_ty = Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n-                                    None,\n-                                    vec![box ordering_ty],\n-                                    true));\n-\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let attrs = vec!(cx.attribute(span, inline));\n-\n-    let partial_cmp_def = MethodDef {\n-        name: \"partial_cmp\",\n-        generics: LifetimeBounds::empty(),\n-        explicit_self: borrowed_explicit_self(),\n-        args: vec![borrowed_self()],\n-        ret_ty: ret_ty,\n-        attributes: attrs,\n-        combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n-            cs_partial_cmp(cx, span, substr)\n-        }))\n-    };\n-\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: vec![],\n-        path: path_std!(cx, core::cmp::PartialOrd),\n-        additional_bounds: vec![],\n-        generics: LifetimeBounds::empty(),\n-        methods: vec![\n-            partial_cmp_def,\n-            md!(\"lt\", true, false),\n-            md!(\"le\", true, true),\n-            md!(\"gt\", false, false),\n-            md!(\"ge\", false, true)\n-        ],\n+        ),\n         associated_types: Vec::new(),\n     };\n+\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-#[derive(Copy, Clone)]\n-pub enum OrderingOp {\n-    PartialCmpOp, LtOp, LeOp, GtOp, GeOp,\n-}\n \n-pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n-                               span: Span,\n-                               op: OrderingOp,\n-                               self_arg_tags: &[ast::Ident]) -> P<ast::Expr> {\n+pub fn ordering_collapsed(cx: &mut ExtCtxt,\n+                          span: Span,\n+                          self_arg_tags: &[ast::Ident]) -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n-    let op_str = match op {\n-        PartialCmpOp => \"partial_cmp\",\n-        LtOp => \"lt\", LeOp => \"le\",\n-        GtOp => \"gt\", GeOp => \"ge\",\n-    };\n-    cx.expr_method_call(span, lft, cx.ident_of(op_str), vec![rgt])\n+    cx.expr_method_call(span, lft, cx.ident_of(\"cmp\"), vec![rgt])\n }\n \n-pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n+pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> P<Expr> {\n     let test_id = cx.ident_of(\"__test\");\n-    let ordering = cx.path_global(span,\n-                                  vec!(cx.ident_of_std(\"core\"),\n-                                       cx.ident_of(\"cmp\"),\n-                                       cx.ident_of(\"Ordering\"),\n-                                       cx.ident_of(\"Equal\")));\n-    let ordering = cx.expr_path(ordering);\n-    let equals_expr = cx.expr_some(span, ordering);\n+    let equals_path = cx.path_global(span,\n+                                     vec!(cx.ident_of_std(\"core\"),\n+                                          cx.ident_of(\"cmp\"),\n+                                          cx.ident_of(\"Ordering\"),\n+                                          cx.ident_of(\"Equal\")));\n \n-    let partial_cmp_path = vec![\n+    let cmp_path = vec![\n         cx.ident_of_std(\"core\"),\n         cx.ident_of(\"cmp\"),\n-        cx.ident_of(\"PartialOrd\"),\n-        cx.ident_of(\"partial_cmp\"),\n+        cx.ident_of(\"Ord\"),\n+        cx.ident_of(\"cmp\"),\n     ];\n \n     /*\n     Builds:\n \n-    let __test = ::std::cmp::PartialOrd::partial_cmp(&self_field1, &other_field1);\n-    if __test == ::std::option::Option::Some(::std::cmp::Ordering::Equal) {\n-        let __test = ::std::cmp::PartialOrd::partial_cmp(&self_field2, &other_field2);\n-        if __test == ::std::option::Option::Some(::std::cmp::Ordering::Equal) {\n+    let __test = ::std::cmp::Ord::cmp(&self_field1, &other_field1);\n+    if other == ::std::cmp::Ordering::Equal {\n+        let __test = ::std::cmp::Ord::cmp(&self_field2, &other_field2);\n+        if __test == ::std::cmp::Ordering::Equal {\n             ...\n         } else {\n             __test\n@@ -144,7 +100,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n         false,\n         |cx, span, old, self_f, other_fs| {\n             // let __test = new;\n-            // if __test == Some(::std::cmp::Ordering::Equal) {\n+            // if __test == ::std::cmp::Ordering::Equal {\n             //    old\n             // } else {\n             //    __test\n@@ -161,77 +117,25 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n                     cx.expr_addr_of(span, other_f.clone()),\n                 ];\n \n-                cx.expr_call_global(span, partial_cmp_path.clone(), args)\n+                cx.expr_call_global(span, cmp_path.clone(), args)\n             };\n \n             let assign = cx.stmt_let(span, false, test_id, new);\n \n             let cond = cx.expr_binary(span, ast::BiEq,\n                                       cx.expr_ident(span, test_id),\n-                                      equals_expr.clone());\n+                                      cx.expr_path(equals_path.clone()));\n             let if_ = cx.expr_if(span,\n                                  cond,\n                                  old, Some(cx.expr_ident(span, test_id)));\n             cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n         },\n-        equals_expr.clone(),\n+        cx.expr_path(equals_path.clone()),\n         Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n             if self_args.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+                cx.span_bug(span, \"not exactly 2 arguments in `derives(Ord)`\")\n             } else {\n-                some_ordering_collapsed(cx, span, PartialCmpOp, tag_tuple)\n-            }\n-        }),\n-        cx, span, substr)\n-}\n-\n-/// Strict inequality.\n-fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt,\n-         span: Span, substr: &Substructure) -> P<Expr> {\n-    let op = if less {ast::BiLt} else {ast::BiGt};\n-    cs_fold(\n-        false, // need foldr,\n-        |cx, span, subexpr, self_f, other_fs| {\n-            /*\n-            build up a series of chain ||'s and &&'s from the inside\n-            out (hence foldr) to get lexical ordering, i.e. for op ==\n-            `ast::lt`\n-\n-            ```\n-            self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n-                (self.f2 < other.f2 || (!(other.f2 < self.f2) &&\n-                    (false)\n-                ))\n-            )\n-            ```\n-\n-            The optimiser should remove the redundancy. We explicitly\n-            get use the binops to avoid auto-deref dereferencing too many\n-            layers of pointers, if the type includes pointers.\n-            */\n-            let other_f = match other_fs {\n-                [ref o_f] => o_f,\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n-            };\n-\n-            let cmp = cx.expr_binary(span, op, self_f.clone(), other_f.clone());\n-\n-            let not_cmp = cx.expr_unary(span, ast::UnNot,\n-                                        cx.expr_binary(span, op, other_f.clone(), self_f));\n-\n-            let and = cx.expr_binary(span, ast::BiAnd, not_cmp, subexpr);\n-            cx.expr_binary(span, ast::BiOr, cmp, and)\n-        },\n-        cx.expr_bool(span, equal),\n-        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n-            if self_args.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n-            } else {\n-                let op = match (less, equal) {\n-                    (true,  true) => LeOp, (true,  false) => LtOp,\n-                    (false, true) => GeOp, (false, false) => GtOp,\n-                };\n-                some_ordering_collapsed(cx, span, op, tag_tuple)\n+                ordering_collapsed(cx, span, tag_tuple)\n             }\n         }),\n         cx, span, substr)"}, {"sha": "db53ea63e539ada9c8cb55c92fb62f586817d70e", "filename": "src/libsyntax/ext/deriving/cmp/partial_eq.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6557f4b2693af38910a9469a5a038f6a116419b2/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6557f4b2693af38910a9469a5a038f6a116419b2/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=6557f4b2693af38910a9469a5a038f6a116419b2", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast::{MetaItem, Item, Expr, self};\n+use codemap::Span;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::deriving::generic::*;\n+use ext::deriving::generic::ty::*;\n+use parse::token::InternedString;\n+use ptr::P;\n+\n+pub fn expand_deriving_partial_eq<F>(cx: &mut ExtCtxt,\n+                                     span: Span,\n+                                     mitem: &MetaItem,\n+                                     item: &Item,\n+                                     push: F) where\n+    F: FnOnce(P<Item>),\n+{\n+    // structures are equal if all fields are equal, and non equal, if\n+    // any fields are not equal or if the enum variants are different\n+    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n+        cs_fold(\n+            true,  // use foldl\n+            |cx, span, subexpr, self_f, other_fs| {\n+                let other_f = match other_fs {\n+                    [ref o_f] => o_f,\n+                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n+                };\n+\n+                let eq = cx.expr_binary(span, ast::BiEq, self_f, other_f.clone());\n+\n+                cx.expr_binary(span, ast::BiAnd, subexpr, eq)\n+            },\n+            cx.expr_bool(span, true),\n+            Box::new(|cx, span, _, _| cx.expr_bool(span, false)),\n+            cx, span, substr)\n+    }\n+    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n+        cs_fold(\n+            true,  // use foldl\n+            |cx, span, subexpr, self_f, other_fs| {\n+                let other_f = match other_fs {\n+                    [ref o_f] => o_f,\n+                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n+                };\n+\n+                let eq = cx.expr_binary(span, ast::BiNe, self_f, other_f.clone());\n+\n+                cx.expr_binary(span, ast::BiOr, subexpr, eq)\n+            },\n+            cx.expr_bool(span, false),\n+            Box::new(|cx, span, _, _| cx.expr_bool(span, true)),\n+            cx, span, substr)\n+    }\n+\n+    macro_rules! md {\n+        ($name:expr, $f:ident) => { {\n+            let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+            let attrs = vec!(cx.attribute(span, inline));\n+            MethodDef {\n+                name: $name,\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: borrowed_explicit_self(),\n+                args: vec!(borrowed_self()),\n+                ret_ty: Literal(path_local!(bool)),\n+                attributes: attrs,\n+                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n+                    $f(a, b, c)\n+                }))\n+            }\n+        } }\n+    }\n+\n+    let trait_def = TraitDef {\n+        span: span,\n+        attributes: Vec::new(),\n+        path: path_std!(cx, core::cmp::PartialEq),\n+        additional_bounds: Vec::new(),\n+        generics: LifetimeBounds::empty(),\n+        methods: vec!(\n+            md!(\"eq\", cs_eq),\n+            md!(\"ne\", cs_ne)\n+        ),\n+        associated_types: Vec::new(),\n+    };\n+    trait_def.expand(cx, mitem, item, push)\n+}"}, {"sha": "4e162d82bbf13738b535352b75f4a60e9f6fcfa2", "filename": "src/libsyntax/ext/deriving/cmp/partial_ord.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/6557f4b2693af38910a9469a5a038f6a116419b2/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6557f4b2693af38910a9469a5a038f6a116419b2/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=6557f4b2693af38910a9469a5a038f6a116419b2", "patch": "@@ -0,0 +1,238 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::OrderingOp::*;\n+\n+use ast;\n+use ast::{MetaItem, Item, Expr};\n+use codemap::Span;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::deriving::generic::*;\n+use ext::deriving::generic::ty::*;\n+use parse::token::InternedString;\n+use ptr::P;\n+\n+pub fn expand_deriving_partial_ord<F>(cx: &mut ExtCtxt,\n+                                      span: Span,\n+                                      mitem: &MetaItem,\n+                                      item: &Item,\n+                                      push: F) where\n+    F: FnOnce(P<Item>),\n+{\n+    macro_rules! md {\n+        ($name:expr, $op:expr, $equal:expr) => { {\n+            let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+            let attrs = vec!(cx.attribute(span, inline));\n+            MethodDef {\n+                name: $name,\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: borrowed_explicit_self(),\n+                args: vec!(borrowed_self()),\n+                ret_ty: Literal(path_local!(bool)),\n+                attributes: attrs,\n+                combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n+                    cs_op($op, $equal, cx, span, substr)\n+                }))\n+            }\n+        } }\n+    }\n+\n+    let ordering_ty = Literal(path_std!(cx, core::cmp::Ordering));\n+    let ret_ty = Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n+                                    None,\n+                                    vec![box ordering_ty],\n+                                    true));\n+\n+    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let attrs = vec!(cx.attribute(span, inline));\n+\n+    let partial_cmp_def = MethodDef {\n+        name: \"partial_cmp\",\n+        generics: LifetimeBounds::empty(),\n+        explicit_self: borrowed_explicit_self(),\n+        args: vec![borrowed_self()],\n+        ret_ty: ret_ty,\n+        attributes: attrs,\n+        combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n+            cs_partial_cmp(cx, span, substr)\n+        }))\n+    };\n+\n+    let trait_def = TraitDef {\n+        span: span,\n+        attributes: vec![],\n+        path: path_std!(cx, core::cmp::PartialOrd),\n+        additional_bounds: vec![],\n+        generics: LifetimeBounds::empty(),\n+        methods: vec![\n+            partial_cmp_def,\n+            md!(\"lt\", true, false),\n+            md!(\"le\", true, true),\n+            md!(\"gt\", false, false),\n+            md!(\"ge\", false, true)\n+        ],\n+        associated_types: Vec::new(),\n+    };\n+    trait_def.expand(cx, mitem, item, push)\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum OrderingOp {\n+    PartialCmpOp, LtOp, LeOp, GtOp, GeOp,\n+}\n+\n+pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n+                               span: Span,\n+                               op: OrderingOp,\n+                               self_arg_tags: &[ast::Ident]) -> P<ast::Expr> {\n+    let lft = cx.expr_ident(span, self_arg_tags[0]);\n+    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n+    let op_str = match op {\n+        PartialCmpOp => \"partial_cmp\",\n+        LtOp => \"lt\", LeOp => \"le\",\n+        GtOp => \"gt\", GeOp => \"ge\",\n+    };\n+    cx.expr_method_call(span, lft, cx.ident_of(op_str), vec![rgt])\n+}\n+\n+pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n+              substr: &Substructure) -> P<Expr> {\n+    let test_id = cx.ident_of(\"__test\");\n+    let ordering = cx.path_global(span,\n+                                  vec!(cx.ident_of_std(\"core\"),\n+                                       cx.ident_of(\"cmp\"),\n+                                       cx.ident_of(\"Ordering\"),\n+                                       cx.ident_of(\"Equal\")));\n+    let ordering = cx.expr_path(ordering);\n+    let equals_expr = cx.expr_some(span, ordering);\n+\n+    let partial_cmp_path = vec![\n+        cx.ident_of_std(\"core\"),\n+        cx.ident_of(\"cmp\"),\n+        cx.ident_of(\"PartialOrd\"),\n+        cx.ident_of(\"partial_cmp\"),\n+    ];\n+\n+    /*\n+    Builds:\n+\n+    let __test = ::std::cmp::PartialOrd::partial_cmp(&self_field1, &other_field1);\n+    if __test == ::std::option::Option::Some(::std::cmp::Ordering::Equal) {\n+        let __test = ::std::cmp::PartialOrd::partial_cmp(&self_field2, &other_field2);\n+        if __test == ::std::option::Option::Some(::std::cmp::Ordering::Equal) {\n+            ...\n+        } else {\n+            __test\n+        }\n+    } else {\n+        __test\n+    }\n+\n+    FIXME #6449: These `if`s could/should be `match`es.\n+    */\n+    cs_fold(\n+        // foldr nests the if-elses correctly, leaving the first field\n+        // as the outermost one, and the last as the innermost.\n+        false,\n+        |cx, span, old, self_f, other_fs| {\n+            // let __test = new;\n+            // if __test == Some(::std::cmp::Ordering::Equal) {\n+            //    old\n+            // } else {\n+            //    __test\n+            // }\n+\n+            let new = {\n+                let other_f = match other_fs {\n+                    [ref o_f] => o_f,\n+                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n+                };\n+\n+                let args = vec![\n+                    cx.expr_addr_of(span, self_f),\n+                    cx.expr_addr_of(span, other_f.clone()),\n+                ];\n+\n+                cx.expr_call_global(span, partial_cmp_path.clone(), args)\n+            };\n+\n+            let assign = cx.stmt_let(span, false, test_id, new);\n+\n+            let cond = cx.expr_binary(span, ast::BiEq,\n+                                      cx.expr_ident(span, test_id),\n+                                      equals_expr.clone());\n+            let if_ = cx.expr_if(span,\n+                                 cond,\n+                                 old, Some(cx.expr_ident(span, test_id)));\n+            cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n+        },\n+        equals_expr.clone(),\n+        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n+            if self_args.len() != 2 {\n+                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+            } else {\n+                some_ordering_collapsed(cx, span, PartialCmpOp, tag_tuple)\n+            }\n+        }),\n+        cx, span, substr)\n+}\n+\n+/// Strict inequality.\n+fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt,\n+         span: Span, substr: &Substructure) -> P<Expr> {\n+    let op = if less {ast::BiLt} else {ast::BiGt};\n+    cs_fold(\n+        false, // need foldr,\n+        |cx, span, subexpr, self_f, other_fs| {\n+            /*\n+            build up a series of chain ||'s and &&'s from the inside\n+            out (hence foldr) to get lexical ordering, i.e. for op ==\n+            `ast::lt`\n+\n+            ```\n+            self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n+                (self.f2 < other.f2 || (!(other.f2 < self.f2) &&\n+                    (false)\n+                ))\n+            )\n+            ```\n+\n+            The optimiser should remove the redundancy. We explicitly\n+            get use the binops to avoid auto-deref dereferencing too many\n+            layers of pointers, if the type includes pointers.\n+            */\n+            let other_f = match other_fs {\n+                [ref o_f] => o_f,\n+                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+            };\n+\n+            let cmp = cx.expr_binary(span, op, self_f.clone(), other_f.clone());\n+\n+            let not_cmp = cx.expr_unary(span, ast::UnNot,\n+                                        cx.expr_binary(span, op, other_f.clone(), self_f));\n+\n+            let and = cx.expr_binary(span, ast::BiAnd, not_cmp, subexpr);\n+            cx.expr_binary(span, ast::BiOr, cmp, and)\n+        },\n+        cx.expr_bool(span, equal),\n+        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n+            if self_args.len() != 2 {\n+                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+            } else {\n+                let op = match (less, equal) {\n+                    (true,  true) => LeOp, (true,  false) => LtOp,\n+                    (false, true) => GeOp, (false, false) => GtOp,\n+                };\n+                some_ordering_collapsed(cx, span, op, tag_tuple)\n+            }\n+        }),\n+        cx, span, substr)\n+}"}, {"sha": "83164d242e8fbd730fdcc9784bc4a4bb104403f0", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -1,69 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ast::{MetaItem, Item, Expr};\n-use codemap::Span;\n-use ext::base::ExtCtxt;\n-use ext::build::AstBuilder;\n-use ext::deriving::generic::*;\n-use ext::deriving::generic::ty::*;\n-use parse::token::InternedString;\n-use ptr::P;\n-\n-pub fn expand_deriving_totaleq<F>(cx: &mut ExtCtxt,\n-                                  span: Span,\n-                                  mitem: &MetaItem,\n-                                  item: &Item,\n-                                  push: F) where\n-    F: FnOnce(P<Item>),\n-{\n-    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_same_method(|cx, span, exprs| {\n-            // create `a.<method>(); b.<method>(); c.<method>(); ...`\n-            // (where method is `assert_receiver_is_total_eq`)\n-            let stmts = exprs.into_iter().map(|e| cx.stmt_expr(e)).collect();\n-            let block = cx.block(span, stmts, None);\n-            cx.expr_block(block)\n-        },\n-                       Box::new(|cx, sp, _, _| {\n-                           cx.span_bug(sp, \"non matching enums in derive(Eq)?\") }),\n-                       cx,\n-                       span,\n-                       substr)\n-    }\n-\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let hidden = cx.meta_word(span, InternedString::new(\"hidden\"));\n-    let doc = cx.meta_list(span, InternedString::new(\"doc\"), vec!(hidden));\n-    let attrs = vec!(cx.attribute(span, inline),\n-                     cx.attribute(span, doc));\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: Vec::new(),\n-        path: path_std!(cx, core::cmp::Eq),\n-        additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n-        methods: vec!(\n-            MethodDef {\n-                name: \"assert_receiver_is_total_eq\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: vec!(),\n-                ret_ty: nil_ty(),\n-                attributes: attrs,\n-                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n-                    cs_total_eq_assert(a, b, c)\n-                }))\n-            }\n-        ),\n-        associated_types: Vec::new(),\n-    };\n-    trait_def.expand(cx, mitem, item, push)\n-}"}, {"sha": "1de955856e712c208d5375574ccf3e7de76096c4", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf0548b5caaa389a5b29813132d2cf4c8b0f1ed/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=abf0548b5caaa389a5b29813132d2cf4c8b0f1ed", "patch": "@@ -1,142 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ast;\n-use ast::{MetaItem, Item, Expr};\n-use codemap::Span;\n-use ext::base::ExtCtxt;\n-use ext::build::AstBuilder;\n-use ext::deriving::generic::*;\n-use ext::deriving::generic::ty::*;\n-use parse::token::InternedString;\n-use ptr::P;\n-\n-pub fn expand_deriving_totalord<F>(cx: &mut ExtCtxt,\n-                                   span: Span,\n-                                   mitem: &MetaItem,\n-                                   item: &Item,\n-                                   push: F) where\n-    F: FnOnce(P<Item>),\n-{\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let attrs = vec!(cx.attribute(span, inline));\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: Vec::new(),\n-        path: path_std!(cx, core::cmp::Ord),\n-        additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n-        methods: vec!(\n-            MethodDef {\n-                name: \"cmp\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: vec!(borrowed_self()),\n-                ret_ty: Literal(path_std!(cx, core::cmp::Ordering)),\n-                attributes: attrs,\n-                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n-                    cs_cmp(a, b, c)\n-                })),\n-            }\n-        ),\n-        associated_types: Vec::new(),\n-    };\n-\n-    trait_def.expand(cx, mitem, item, push)\n-}\n-\n-\n-pub fn ordering_collapsed(cx: &mut ExtCtxt,\n-                          span: Span,\n-                          self_arg_tags: &[ast::Ident]) -> P<ast::Expr> {\n-    let lft = cx.expr_ident(span, self_arg_tags[0]);\n-    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n-    cx.expr_method_call(span, lft, cx.ident_of(\"cmp\"), vec![rgt])\n-}\n-\n-pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n-              substr: &Substructure) -> P<Expr> {\n-    let test_id = cx.ident_of(\"__test\");\n-    let equals_path = cx.path_global(span,\n-                                     vec!(cx.ident_of_std(\"core\"),\n-                                          cx.ident_of(\"cmp\"),\n-                                          cx.ident_of(\"Ordering\"),\n-                                          cx.ident_of(\"Equal\")));\n-\n-    let cmp_path = vec![\n-        cx.ident_of_std(\"core\"),\n-        cx.ident_of(\"cmp\"),\n-        cx.ident_of(\"Ord\"),\n-        cx.ident_of(\"cmp\"),\n-    ];\n-\n-    /*\n-    Builds:\n-\n-    let __test = ::std::cmp::Ord::cmp(&self_field1, &other_field1);\n-    if other == ::std::cmp::Ordering::Equal {\n-        let __test = ::std::cmp::Ord::cmp(&self_field2, &other_field2);\n-        if __test == ::std::cmp::Ordering::Equal {\n-            ...\n-        } else {\n-            __test\n-        }\n-    } else {\n-        __test\n-    }\n-\n-    FIXME #6449: These `if`s could/should be `match`es.\n-    */\n-    cs_fold(\n-        // foldr nests the if-elses correctly, leaving the first field\n-        // as the outermost one, and the last as the innermost.\n-        false,\n-        |cx, span, old, self_f, other_fs| {\n-            // let __test = new;\n-            // if __test == ::std::cmp::Ordering::Equal {\n-            //    old\n-            // } else {\n-            //    __test\n-            // }\n-\n-            let new = {\n-                let other_f = match other_fs {\n-                    [ref o_f] => o_f,\n-                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-                };\n-\n-                let args = vec![\n-                    cx.expr_addr_of(span, self_f),\n-                    cx.expr_addr_of(span, other_f.clone()),\n-                ];\n-\n-                cx.expr_call_global(span, cmp_path.clone(), args)\n-            };\n-\n-            let assign = cx.stmt_let(span, false, test_id, new);\n-\n-            let cond = cx.expr_binary(span, ast::BiEq,\n-                                      cx.expr_ident(span, test_id),\n-                                      cx.expr_path(equals_path.clone()));\n-            let if_ = cx.expr_if(span,\n-                                 cond,\n-                                 old, Some(cx.expr_ident(span, test_id)));\n-            cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n-        },\n-        cx.expr_path(equals_path.clone()),\n-        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n-            if self_args.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derives(Ord)`\")\n-            } else {\n-                ordering_collapsed(cx, span, tag_tuple)\n-            }\n-        }),\n-        cx, span, substr)\n-}"}, {"sha": "f3327a4ef5f9cdf67340b9627f16455112aca6ed", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6557f4b2693af38910a9469a5a038f6a116419b2/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6557f4b2693af38910a9469a5a038f6a116419b2/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=6557f4b2693af38910a9469a5a038f6a116419b2", "patch": "@@ -65,14 +65,14 @@ pub mod show;\n pub mod default;\n pub mod primitive;\n \n+#[path=\"cmp/partial_eq.rs\"]\n+pub mod partial_eq;\n #[path=\"cmp/eq.rs\"]\n pub mod eq;\n-#[path=\"cmp/totaleq.rs\"]\n-pub mod totaleq;\n+#[path=\"cmp/partial_ord.rs\"]\n+pub mod partial_ord;\n #[path=\"cmp/ord.rs\"]\n pub mod ord;\n-#[path=\"cmp/totalord.rs\"]\n-pub mod totalord;\n \n \n pub mod generic;\n@@ -162,10 +162,10 @@ derive_traits! {\n \n     \"RustcDecodable\" => decodable::expand_deriving_rustc_decodable,\n \n-    \"PartialEq\" => eq::expand_deriving_eq,\n-    \"Eq\" => totaleq::expand_deriving_totaleq,\n-    \"PartialOrd\" => ord::expand_deriving_ord,\n-    \"Ord\" => totalord::expand_deriving_totalord,\n+    \"PartialEq\" => partial_eq::expand_deriving_partial_eq,\n+    \"Eq\" => eq::expand_deriving_eq,\n+    \"PartialOrd\" => partial_ord::expand_deriving_partial_ord,\n+    \"Ord\" => ord::expand_deriving_ord,\n \n     \"Debug\" => show::expand_deriving_show,\n "}]}