{"sha": "8674efdb7c9d263caef8d282086a4243eae8df20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NzRlZmRiN2M5ZDI2M2NhZWY4ZDI4MjA4NmE0MjQzZWFlOGRmMjA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-29T00:30:01Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-02T09:33:55Z"}, "message": "parser: move restrictions re. `self` to `ast_validation`.", "tree": {"sha": "3dd62df510860da588ea8020fff68cae396733ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dd62df510860da588ea8020fff68cae396733ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8674efdb7c9d263caef8d282086a4243eae8df20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8674efdb7c9d263caef8d282086a4243eae8df20", "html_url": "https://github.com/rust-lang/rust/commit/8674efdb7c9d263caef8d282086a4243eae8df20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8674efdb7c9d263caef8d282086a4243eae8df20/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdd41ea5fc37d1ba879fd52743bde35fde4a89df", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdd41ea5fc37d1ba879fd52743bde35fde4a89df", "html_url": "https://github.com/rust-lang/rust/commit/cdd41ea5fc37d1ba879fd52743bde35fde4a89df"}], "stats": {"total": 482, "additions": 426, "deletions": 56}, "files": [{"sha": "f37f93c0254bde5bf685dd4f0c9fba3b139664dc", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=8674efdb7c9d263caef8d282086a4243eae8df20", "patch": "@@ -23,6 +23,12 @@ use syntax::print::pprust;\n use syntax::visit::{self, Visitor};\n use syntax::walk_list;\n \n+/// Is `self` allowed semantically as the first parameter in an `FnDecl`?\n+enum SelfSemantic {\n+    Yes,\n+    No,\n+}\n+\n /// A syntactic context that disallows certain kinds of bounds (e.g., `?Trait` or `?const Trait`).\n #[derive(Clone, Copy)]\n enum BoundContext {\n@@ -302,7 +308,13 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn check_fn_decl(&self, fn_decl: &FnDecl) {\n+    fn check_fn_decl(&self, fn_decl: &FnDecl, self_semantic: SelfSemantic) {\n+        self.check_decl_cvaradic_pos(fn_decl);\n+        self.check_decl_attrs(fn_decl);\n+        self.check_decl_self_param(fn_decl, self_semantic);\n+    }\n+\n+    fn check_decl_cvaradic_pos(&self, fn_decl: &FnDecl) {\n         match &*fn_decl.inputs {\n             [Param { ty, span, .. }] => {\n                 if let TyKind::CVarArgs = ty.kind {\n@@ -324,7 +336,9 @@ impl<'a> AstValidator<'a> {\n             }\n             _ => {}\n         }\n+    }\n \n+    fn check_decl_attrs(&self, fn_decl: &FnDecl) {\n         fn_decl\n             .inputs\n             .iter()\n@@ -352,6 +366,21 @@ impl<'a> AstValidator<'a> {\n             });\n     }\n \n+    fn check_decl_self_param(&self, fn_decl: &FnDecl, self_semantic: SelfSemantic) {\n+        if let (SelfSemantic::No, [param, ..]) = (self_semantic, &*fn_decl.inputs) {\n+            if param.is_self() {\n+                self.err_handler()\n+                    .struct_span_err(\n+                        param.span,\n+                        \"`self` parameter only allowed in associated `fn`s\",\n+                    )\n+                    .span_label(param.span, \"not semantically valid as function parameter\")\n+                    .note(\"associated `fn`s are those in `impl` or `trait` definitions\")\n+                    .emit();\n+            }\n+        }\n+    }\n+\n     fn check_defaultness(&self, span: Span, defaultness: Defaultness) {\n         if let Defaultness::Default = defaultness {\n             self.err_handler()\n@@ -504,7 +533,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_expr(&mut self, expr: &'a Expr) {\n         match &expr.kind {\n             ExprKind::Closure(_, _, _, fn_decl, _, _) => {\n-                self.check_fn_decl(fn_decl);\n+                self.check_fn_decl(fn_decl, SelfSemantic::No);\n             }\n             ExprKind::InlineAsm(..) if !self.session.target.target.options.allow_asm => {\n                 struct_span_err!(\n@@ -524,7 +553,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_ty(&mut self, ty: &'a Ty) {\n         match ty.kind {\n             TyKind::BareFn(ref bfty) => {\n-                self.check_fn_decl(&bfty.decl);\n+                self.check_fn_decl(&bfty.decl, SelfSemantic::No);\n                 Self::check_decl_no_pat(&bfty.decl, |span, _| {\n                     struct_span_err!(\n                         self.session,\n@@ -685,7 +714,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Fn(ref sig, ref generics, _) => {\n                 self.visit_fn_header(&sig.header);\n-                self.check_fn_decl(&sig.decl);\n+                self.check_fn_decl(&sig.decl, SelfSemantic::No);\n                 // We currently do not permit const generics in `const fn`, as\n                 // this is tantamount to allowing compile-time dependent typing.\n                 if sig.header.constness.node == Constness::Const {\n@@ -793,7 +822,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_foreign_item(&mut self, fi: &'a ForeignItem) {\n         match fi.kind {\n             ForeignItemKind::Fn(ref decl, _) => {\n-                self.check_fn_decl(decl);\n+                self.check_fn_decl(decl, SelfSemantic::No);\n                 Self::check_decl_no_pat(decl, |span, _| {\n                     struct_span_err!(\n                         self.session,\n@@ -987,9 +1016,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             AssocItemKind::Const(_, body) => {\n                 self.check_impl_item_provided(ii.span, body, \"constant\", \" = <expr>;\");\n             }\n-            AssocItemKind::Fn(sig, body) => {\n+            AssocItemKind::Fn(_, body) => {\n                 self.check_impl_item_provided(ii.span, body, \"function\", \" { <body> }\");\n-                self.check_fn_decl(&sig.decl);\n             }\n             AssocItemKind::TyAlias(bounds, body) => {\n                 self.check_impl_item_provided(ii.span, body, \"type\", \" = <type>;\");\n@@ -1005,7 +1033,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         self.check_defaultness(ti.span, ti.defaultness);\n \n         if let AssocItemKind::Fn(sig, block) = &ti.kind {\n-            self.check_fn_decl(&sig.decl);\n             self.check_trait_fn_not_async(ti.span, sig.header.asyncness.node);\n             self.check_trait_fn_not_const(sig.header.constness);\n             if block.is_none() {\n@@ -1035,6 +1062,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n     fn visit_assoc_item(&mut self, item: &'a AssocItem) {\n         if let AssocItemKind::Fn(sig, _) = &item.kind {\n+            self.check_fn_decl(&sig.decl, SelfSemantic::Yes);\n             self.check_c_varadic_type(&sig.decl);\n         }\n         visit::walk_assoc_item(self, item);"}, {"sha": "09f393a81abad8b2b9f0a9f4c865924bed22b102", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=8674efdb7c9d263caef8d282086a4243eae8df20", "patch": "@@ -1336,8 +1336,8 @@ impl<'a> Parser<'a> {\n         err: &mut DiagnosticBuilder<'_>,\n         pat: P<ast::Pat>,\n         require_name: bool,\n-        is_self_allowed: bool,\n-        is_trait_item: bool,\n+        is_self_semantic: bool,\n+        in_assoc_item: bool,\n     ) -> Option<Ident> {\n         // If we find a pattern followed by an identifier, it could be an (incorrect)\n         // C-style parameter declaration.\n@@ -1357,13 +1357,13 @@ impl<'a> Parser<'a> {\n             return Some(ident);\n         } else if let PatKind::Ident(_, ident, _) = pat.kind {\n             if require_name\n-                && (is_trait_item\n+                && (in_assoc_item\n                     || self.token == token::Comma\n                     || self.token == token::Lt\n                     || self.token == token::CloseDelim(token::Paren))\n             {\n                 // `fn foo(a, b) {}`, `fn foo(a<x>, b<y>) {}` or `fn foo(usize, usize) {}`\n-                if is_self_allowed {\n+                if is_self_semantic {\n                     err.span_suggestion(\n                         pat.span,\n                         \"if this is a `self` type, give it a parameter name\",\n@@ -1423,12 +1423,12 @@ impl<'a> Parser<'a> {\n     pub(super) fn recover_bad_self_param(\n         &mut self,\n         mut param: ast::Param,\n-        is_trait_item: bool,\n+        in_assoc_item: bool,\n     ) -> PResult<'a, ast::Param> {\n         let sp = param.pat.span;\n         param.ty.kind = TyKind::Err;\n         let mut err = self.struct_span_err(sp, \"unexpected `self` parameter in function\");\n-        if is_trait_item {\n+        if in_assoc_item {\n             err.span_label(sp, \"must be the first associated function parameter\");\n         } else {\n             err.span_label(sp, \"not valid as function parameter\");"}, {"sha": "0ff595f444413862ba173c2b5c4c091106a8ad9d", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=8674efdb7c9d263caef8d282086a4243eae8df20", "patch": "@@ -1715,8 +1715,9 @@ impl<'a> Parser<'a> {\n \n /// The parsing configuration used to parse a parameter list (see `parse_fn_params`).\n pub(super) struct ParamCfg {\n-    /// Is `self` is allowed as the first parameter?\n-    pub is_self_allowed: bool,\n+    /// Is `self` is *semantically* allowed as the first parameter?\n+    /// This is only used for diagnostics.\n+    pub in_assoc_item: bool,\n     /// `is_name_required` decides if, per-parameter,\n     /// the parameter must have a pattern or just a type.\n     pub is_name_required: fn(&token::Token) -> bool,\n@@ -1732,8 +1733,8 @@ impl<'a> Parser<'a> {\n         attrs: Vec<Attribute>,\n         header: FnHeader,\n     ) -> PResult<'a, Option<P<Item>>> {\n-        let (ident, decl, generics) =\n-            self.parse_fn_sig(ParamCfg { is_self_allowed: false, is_name_required: |_| true })?;\n+        let cfg = ParamCfg { in_assoc_item: false, is_name_required: |_| true };\n+        let (ident, decl, generics) = self.parse_fn_sig(&cfg)?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n         let kind = ItemKind::Fn(FnSig { decl, header }, generics, body);\n         self.mk_item_with_info(attrs, lo, vis, (ident, kind, Some(inner_attrs)))\n@@ -1747,20 +1748,13 @@ impl<'a> Parser<'a> {\n         attrs: Vec<Attribute>,\n         extern_sp: Span,\n     ) -> PResult<'a, P<ForeignItem>> {\n+        let cfg = ParamCfg { in_assoc_item: false, is_name_required: |_| true };\n         self.expect_keyword(kw::Fn)?;\n-        let (ident, decl, generics) =\n-            self.parse_fn_sig(ParamCfg { is_self_allowed: false, is_name_required: |_| true })?;\n+        let (ident, decl, generics) = self.parse_fn_sig(&cfg)?;\n         let span = lo.to(self.token.span);\n         self.parse_semi_or_incorrect_foreign_fn_body(&ident, extern_sp)?;\n-        Ok(P(ast::ForeignItem {\n-            ident,\n-            attrs,\n-            kind: ForeignItemKind::Fn(decl, generics),\n-            id: DUMMY_NODE_ID,\n-            span,\n-            vis,\n-            tokens: None,\n-        }))\n+        let kind = ForeignItemKind::Fn(decl, generics);\n+        Ok(P(ast::ForeignItem { ident, attrs, kind, id: DUMMY_NODE_ID, span, vis, tokens: None }))\n     }\n \n     fn parse_assoc_fn(\n@@ -1769,9 +1763,9 @@ impl<'a> Parser<'a> {\n         attrs: &mut Vec<Attribute>,\n         is_name_required: fn(&token::Token) -> bool,\n     ) -> PResult<'a, (Ident, AssocItemKind, Generics)> {\n+        let cfg = ParamCfg { in_assoc_item: true, is_name_required };\n         let header = self.parse_fn_front_matter()?;\n-        let (ident, decl, generics) =\n-            self.parse_fn_sig(ParamCfg { is_self_allowed: true, is_name_required })?;\n+        let (ident, decl, generics) = self.parse_fn_sig(&cfg)?;\n         let sig = FnSig { header, decl };\n         let body = self.parse_assoc_fn_body(at_end, attrs)?;\n         Ok((ident, AssocItemKind::Fn(sig, body), generics))\n@@ -1847,7 +1841,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse the \"signature\", including the identifier, parameters, and generics of a function.\n-    fn parse_fn_sig(&mut self, cfg: ParamCfg) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n+    fn parse_fn_sig(&mut self, cfg: &ParamCfg) -> PResult<'a, (Ident, P<FnDecl>, Generics)> {\n         let ident = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n         let decl = self.parse_fn_decl(cfg, true)?;\n@@ -1858,7 +1852,7 @@ impl<'a> Parser<'a> {\n     /// Parses the parameter list and result type of a function declaration.\n     pub(super) fn parse_fn_decl(\n         &mut self,\n-        cfg: ParamCfg,\n+        cfg: &ParamCfg,\n         ret_allow_plus: bool,\n     ) -> PResult<'a, P<FnDecl>> {\n         Ok(P(FnDecl {\n@@ -1868,11 +1862,11 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses the parameter list of a function, including the `(` and `)` delimiters.\n-    fn parse_fn_params(&mut self, mut cfg: ParamCfg) -> PResult<'a, Vec<Param>> {\n-        let is_trait_item = cfg.is_self_allowed;\n-        // Parse the arguments, starting out with `self` being possibly allowed...\n+    fn parse_fn_params(&mut self, cfg: &ParamCfg) -> PResult<'a, Vec<Param>> {\n+        let mut first_param = true;\n+        // Parse the arguments, starting out with `self` being allowed...\n         let (mut params, _) = self.parse_paren_comma_seq(|p| {\n-            let param = p.parse_param_general(&cfg, is_trait_item).or_else(|mut e| {\n+            let param = p.parse_param_general(&cfg, first_param).or_else(|mut e| {\n                 e.emit();\n                 let lo = p.prev_span;\n                 // Skip every token until next possible arg or end.\n@@ -1881,28 +1875,28 @@ impl<'a> Parser<'a> {\n                 Ok(dummy_arg(Ident::new(kw::Invalid, lo.to(p.prev_span))))\n             });\n             // ...now that we've parsed the first argument, `self` is no longer allowed.\n-            cfg.is_self_allowed = false;\n+            first_param = false;\n             param\n         })?;\n         // Replace duplicated recovered params with `_` pattern to avoid unnecessary errors.\n         self.deduplicate_recovered_params_names(&mut params);\n         Ok(params)\n     }\n \n-    /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n-    /// error.\n-    /// This version of parse param doesn't necessarily require identifier names.\n-    fn parse_param_general(&mut self, cfg: &ParamCfg, is_trait_item: bool) -> PResult<'a, Param> {\n+    /// Parses a single function parameter.\n+    ///\n+    /// - `self` is syntactically allowed when `first_param` holds.\n+    fn parse_param_general(&mut self, cfg: &ParamCfg, first_param: bool) -> PResult<'a, Param> {\n         let lo = self.token.span;\n         let attrs = self.parse_outer_attributes()?;\n \n         // Possibly parse `self`. Recover if we parsed it and it wasn't allowed here.\n         if let Some(mut param) = self.parse_self_param()? {\n             param.attrs = attrs.into();\n-            return if cfg.is_self_allowed {\n+            return if first_param {\n                 Ok(param)\n             } else {\n-                self.recover_bad_self_param(param, is_trait_item)\n+                self.recover_bad_self_param(param, cfg.in_assoc_item)\n             };\n         }\n \n@@ -1919,8 +1913,8 @@ impl<'a> Parser<'a> {\n                     &mut err,\n                     pat,\n                     is_name_required,\n-                    cfg.is_self_allowed,\n-                    is_trait_item,\n+                    first_param && cfg.in_assoc_item,\n+                    cfg.in_assoc_item,\n                 ) {\n                     err.emit();\n                     Ok(dummy_arg(ident))\n@@ -1975,8 +1969,6 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Returns the parsed optional self parameter and whether a self shortcut was used.\n-    ///\n-    /// See `parse_self_param_with_attrs` to collect attributes.\n     fn parse_self_param(&mut self) -> PResult<'a, Option<Param>> {\n         // Extract an identifier *after* having confirmed that the token is one.\n         let expect_self_ident = |this: &mut Self| {"}, {"sha": "51367a37ad70ac2a623a3498c840b72713ad480f", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=8674efdb7c9d263caef8d282086a4243eae8df20", "patch": "@@ -288,8 +288,8 @@ impl<'a> Parser<'a> {\n         let unsafety = self.parse_unsafety();\n         let ext = self.parse_extern()?;\n         self.expect_keyword(kw::Fn)?;\n-        let cfg = ParamCfg { is_self_allowed: false, is_name_required: |_| false };\n-        let decl = self.parse_fn_decl(cfg, false)?;\n+        let cfg = ParamCfg { in_assoc_item: false, is_name_required: |_| false };\n+        let decl = self.parse_fn_decl(&cfg, false)?;\n         Ok(TyKind::BareFn(P(BareFnTy { ext, unsafety, generic_params, decl })))\n     }\n "}, {"sha": "8c92b7bc7c4b0d4180c9295b85663661603fbb4b", "filename": "src/test/ui/invalid-self-argument/bare-fn-start.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs?ref=8674efdb7c9d263caef8d282086a4243eae8df20", "patch": "@@ -1,6 +1,6 @@\n fn a(&self) { }\n-//~^ ERROR unexpected `self` parameter in function\n-//~| NOTE not valid as function parameter\n-//~| NOTE `self` is only valid as the first parameter of an associated function\n+//~^ ERROR `self` parameter only allowed in associated `fn`s\n+//~| NOTE not semantically valid as function parameter\n+//~| NOTE associated `fn`s are those in `impl` or `trait` definitions\n \n fn main() { }"}, {"sha": "59120a60a6df13a917a800d4e0d1ded4974fa0dd", "filename": "src/test/ui/invalid-self-argument/bare-fn-start.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr?ref=8674efdb7c9d263caef8d282086a4243eae8df20", "patch": "@@ -1,10 +1,10 @@\n-error: unexpected `self` parameter in function\n+error: `self` parameter only allowed in associated `fn`s\n   --> $DIR/bare-fn-start.rs:1:6\n    |\n LL | fn a(&self) { }\n-   |      ^^^^^ not valid as function parameter\n+   |      ^^^^^ not semantically valid as function parameter\n    |\n-   = note: `self` is only valid as the first parameter of an associated function\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n \n error: aborting due to previous error\n "}, {"sha": "773cf922b4da917d0ac91cabe885f40e055672bf", "filename": "src/test/ui/parser/self-param-semantic-fail.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Ftest%2Fui%2Fparser%2Fself-param-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Ftest%2Fui%2Fparser%2Fself-param-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fself-param-semantic-fail.rs?ref=8674efdb7c9d263caef8d282086a4243eae8df20", "patch": "@@ -0,0 +1,64 @@\n+// This test ensures that `self` is semantically rejected\n+// in contexts with `FnDecl` but outside of associated `fn`s.\n+// FIXME(Centril): For now closures are an exception.\n+\n+fn main() {}\n+\n+fn free() {\n+    fn f1(self) {}\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    fn f2(mut self) {}\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    fn f3(&self) {}\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    fn f4(&mut self) {}\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    fn f5<'a>(&'a self) {}\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    fn f6<'a>(&'a mut self) {}\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    fn f7(self: u8) {}\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    fn f8(mut self: u8) {}\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+}\n+\n+extern {\n+    fn f1(self);\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    fn f2(mut self);\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    //~| ERROR patterns aren't allowed in\n+    fn f3(&self);\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    fn f4(&mut self);\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    fn f5<'a>(&'a self);\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    fn f6<'a>(&'a mut self);\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    fn f7(self: u8);\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    fn f8(mut self: u8);\n+    //~^ ERROR `self` parameter only allowed in associated `fn`s\n+    //~| ERROR patterns aren't allowed in\n+}\n+\n+type X1 = fn(self);\n+//~^ ERROR `self` parameter only allowed in associated `fn`s\n+type X2 = fn(mut self);\n+//~^ ERROR `self` parameter only allowed in associated `fn`s\n+//~| ERROR patterns aren't allowed in\n+type X3 = fn(&self);\n+//~^ ERROR `self` parameter only allowed in associated `fn`s\n+type X4 = fn(&mut self);\n+//~^ ERROR `self` parameter only allowed in associated `fn`s\n+type X5 = for<'a> fn(&'a self);\n+//~^ ERROR `self` parameter only allowed in associated `fn`s\n+type X6 = for<'a> fn(&'a mut self);\n+//~^ ERROR `self` parameter only allowed in associated `fn`s\n+type X7 = fn(self: u8);\n+//~^ ERROR `self` parameter only allowed in associated `fn`s\n+type X8 = fn(mut self: u8);\n+//~^ ERROR `self` parameter only allowed in associated `fn`s\n+//~| ERROR patterns aren't allowed in"}, {"sha": "b45e4a5d26f16e1e179a410c95839b207224340a", "filename": "src/test/ui/parser/self-param-semantic-fail.stderr", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Ftest%2Fui%2Fparser%2Fself-param-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Ftest%2Fui%2Fparser%2Fself-param-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fself-param-semantic-fail.stderr?ref=8674efdb7c9d263caef8d282086a4243eae8df20", "patch": "@@ -0,0 +1,220 @@\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:8:11\n+   |\n+LL |     fn f1(self) {}\n+   |           ^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:10:11\n+   |\n+LL |     fn f2(mut self) {}\n+   |           ^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:12:11\n+   |\n+LL |     fn f3(&self) {}\n+   |           ^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:14:11\n+   |\n+LL |     fn f4(&mut self) {}\n+   |           ^^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:16:15\n+   |\n+LL |     fn f5<'a>(&'a self) {}\n+   |               ^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:18:15\n+   |\n+LL |     fn f6<'a>(&'a mut self) {}\n+   |               ^^^^^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:20:11\n+   |\n+LL |     fn f7(self: u8) {}\n+   |           ^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:22:11\n+   |\n+LL |     fn f8(mut self: u8) {}\n+   |           ^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:27:11\n+   |\n+LL |     fn f1(self);\n+   |           ^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:29:11\n+   |\n+LL |     fn f2(mut self);\n+   |           ^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error[E0130]: patterns aren't allowed in foreign function declarations\n+  --> $DIR/self-param-semantic-fail.rs:29:11\n+   |\n+LL |     fn f2(mut self);\n+   |           ^^^^^^^^ pattern not allowed in foreign function\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:32:11\n+   |\n+LL |     fn f3(&self);\n+   |           ^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:34:11\n+   |\n+LL |     fn f4(&mut self);\n+   |           ^^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:36:15\n+   |\n+LL |     fn f5<'a>(&'a self);\n+   |               ^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:38:15\n+   |\n+LL |     fn f6<'a>(&'a mut self);\n+   |               ^^^^^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:40:11\n+   |\n+LL |     fn f7(self: u8);\n+   |           ^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:42:11\n+   |\n+LL |     fn f8(mut self: u8);\n+   |           ^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error[E0130]: patterns aren't allowed in foreign function declarations\n+  --> $DIR/self-param-semantic-fail.rs:42:11\n+   |\n+LL |     fn f8(mut self: u8);\n+   |           ^^^^^^^^ pattern not allowed in foreign function\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:47:14\n+   |\n+LL | type X1 = fn(self);\n+   |              ^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:49:14\n+   |\n+LL | type X2 = fn(mut self);\n+   |              ^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error[E0561]: patterns aren't allowed in function pointer types\n+  --> $DIR/self-param-semantic-fail.rs:49:14\n+   |\n+LL | type X2 = fn(mut self);\n+   |              ^^^^^^^^\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:52:14\n+   |\n+LL | type X3 = fn(&self);\n+   |              ^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:54:14\n+   |\n+LL | type X4 = fn(&mut self);\n+   |              ^^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:56:22\n+   |\n+LL | type X5 = for<'a> fn(&'a self);\n+   |                      ^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:58:22\n+   |\n+LL | type X6 = for<'a> fn(&'a mut self);\n+   |                      ^^^^^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:60:14\n+   |\n+LL | type X7 = fn(self: u8);\n+   |              ^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error: `self` parameter only allowed in associated `fn`s\n+  --> $DIR/self-param-semantic-fail.rs:62:14\n+   |\n+LL | type X8 = fn(mut self: u8);\n+   |              ^^^^^^^^ not semantically valid as function parameter\n+   |\n+   = note: associated `fn`s are those in `impl` or `trait` definitions\n+\n+error[E0561]: patterns aren't allowed in function pointer types\n+  --> $DIR/self-param-semantic-fail.rs:62:14\n+   |\n+LL | type X8 = fn(mut self: u8);\n+   |              ^^^^^^^^\n+\n+error: aborting due to 28 previous errors\n+\n+Some errors have detailed explanations: E0130, E0561.\n+For more information about an error, try `rustc --explain E0130`."}, {"sha": "9e215e6cdd4b79e38ad85e77838d624133ed9f1f", "filename": "src/test/ui/parser/self-param-syntactic-pass.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Ftest%2Fui%2Fparser%2Fself-param-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8674efdb7c9d263caef8d282086a4243eae8df20/src%2Ftest%2Fui%2Fparser%2Fself-param-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fself-param-syntactic-pass.rs?ref=8674efdb7c9d263caef8d282086a4243eae8df20", "patch": "@@ -0,0 +1,66 @@\n+// This test ensures that `self` is syntactically accepted in all places an `FnDecl` is parsed.\n+// FIXME(Centril): For now closures are an exception.\n+\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+fn free() {\n+    fn f(self) {}\n+    fn f(mut self) {}\n+    fn f(&self) {}\n+    fn f(&mut self) {}\n+    fn f(&'a self) {}\n+    fn f(&'a mut self) {}\n+    fn f(self: u8) {}\n+    fn f(mut self: u8) {}\n+}\n+\n+#[cfg(FALSE)]\n+extern {\n+    fn f(self);\n+    fn f(mut self);\n+    fn f(&self);\n+    fn f(&mut self);\n+    fn f(&'a self);\n+    fn f(&'a mut self);\n+    fn f(self: u8);\n+    fn f(mut self: u8);\n+}\n+\n+#[cfg(FALSE)]\n+trait X {\n+    fn f(self) {}\n+    fn f(mut self) {}\n+    fn f(&self) {}\n+    fn f(&mut self) {}\n+    fn f(&'a self) {}\n+    fn f(&'a mut self) {}\n+    fn f(self: u8) {}\n+    fn f(mut self: u8) {}\n+}\n+\n+#[cfg(FALSE)]\n+impl X for Y {\n+    fn f(self) {}\n+    fn f(mut self) {}\n+    fn f(&self) {}\n+    fn f(&mut self) {}\n+    fn f(&'a self) {}\n+    fn f(&'a mut self) {}\n+    fn f(self: u8) {}\n+    fn f(mut self: u8) {}\n+}\n+\n+#[cfg(FALSE)]\n+impl X for Y {\n+    type X = fn(self);\n+    type X = fn(mut self);\n+    type X = fn(&self);\n+    type X = fn(&mut self);\n+    type X = fn(&'a self);\n+    type X = fn(&'a mut self);\n+    type X = fn(self: u8);\n+    type X = fn(mut self: u8);\n+}"}]}