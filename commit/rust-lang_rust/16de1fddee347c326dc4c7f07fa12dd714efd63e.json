{"sha": "16de1fddee347c326dc4c7f07fa12dd714efd63e", "node_id": "C_kwDOAAsO6NoAKDE2ZGUxZmRkZWUzNDdjMzI2ZGM0YzdmMDdmYTEyZGQ3MTRlZmQ2M2U", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-09-25T07:32:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-25T07:32:07Z"}, "message": "Rollup merge of #102016 - lcnr:given-OutlivesEnvironment, r=jackh726\n\nimplied_bounds: deal with inference vars\n\nfixes #101951\n\nwhile computing implied bounds for `<<T as ConstructionFirm>::Builder as BuilderFn<'_>>::Output` normalization replaces a projection with an inference var (adding a `Projection` obligation). Until we prove that obligation, this inference var remains unknown, which caused us to miss an implied bound necessary to prove that the unnormalized projection from the trait method signature is wf.\n\nr? types", "tree": {"sha": "9736b7badb57e18321b6961783e52e13d916beb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9736b7badb57e18321b6961783e52e13d916beb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16de1fddee347c326dc4c7f07fa12dd714efd63e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjMAP3CRBK7hj4Ov3rIwAAQYMIADknaqDXY+t/uX0tJ/cs/MFh\nI0IpGyZUvlGnKfpbJw+BhDsQ2iZ+sLGWxbruLjdkzm3WlO4sx5UF7R6FYm3mjEON\no9/pxTqpRUfVbOWhqMKIzuQ3O99WXJrd2775hod6uoVz4wF7RI5c60BEKSsTZyDu\nGZQHhTX1XfpkC4xt541tgGEekOkjeoFTItL3it0PyXLImQGUSI0oS2mJPWFjO4+T\ng6OUSFbEo48olyU+FfLtMnEOl+B1cZ25MvcoPhlJIIuIHN52hA1B8q876triISk1\nvQ0zKSrsKND0DGto29pszCGvdvJu0CqSYWPCzP0OxfPWNzoZUcsednsNKMw2ELY=\n=IEAQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 9736b7badb57e18321b6961783e52e13d916beb3\nparent e20fabb0d04cb25fe3159d58920856533f1b5cf0\nparent 72a21027f5bee367bd9ccbeecc2528986f85d90b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1664091127 +0200\ncommitter GitHub <noreply@github.com> 1664091127 +0200\n\nRollup merge of #102016 - lcnr:given-OutlivesEnvironment, r=jackh726\n\nimplied_bounds: deal with inference vars\n\nfixes #101951\n\nwhile computing implied bounds for `<<T as ConstructionFirm>::Builder as BuilderFn<'_>>::Output` normalization replaces a projection with an inference var (adding a `Projection` obligation). Until we prove that obligation, this inference var remains unknown, which caused us to miss an implied bound necessary to prove that the unnormalized projection from the trait method signature is wf.\n\nr? types\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16de1fddee347c326dc4c7f07fa12dd714efd63e", "html_url": "https://github.com/rust-lang/rust/commit/16de1fddee347c326dc4c7f07fa12dd714efd63e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16de1fddee347c326dc4c7f07fa12dd714efd63e/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e20fabb0d04cb25fe3159d58920856533f1b5cf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e20fabb0d04cb25fe3159d58920856533f1b5cf0", "html_url": "https://github.com/rust-lang/rust/commit/e20fabb0d04cb25fe3159d58920856533f1b5cf0"}, {"sha": "72a21027f5bee367bd9ccbeecc2528986f85d90b", "url": "https://api.github.com/repos/rust-lang/rust/commits/72a21027f5bee367bd9ccbeecc2528986f85d90b", "html_url": "https://github.com/rust-lang/rust/commit/72a21027f5bee367bd9ccbeecc2528986f85d90b"}], "stats": {"total": 125, "additions": 91, "deletions": 34}, "files": [{"sha": "9922b156ebf96d0c5765f6d192a4e0be058c580a", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16de1fddee347c326dc4c7f07fa12dd714efd63e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16de1fddee347c326dc4c7f07fa12dd714efd63e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=16de1fddee347c326dc4c7f07fa12dd714efd63e", "patch": "@@ -53,6 +53,7 @@ pub struct OutlivesEnvironment<'tcx> {\n }\n \n /// Builder of OutlivesEnvironment.\n+#[derive(Debug)]\n struct OutlivesEnvironmentBuilder<'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n     region_relation: TransitiveRelationBuilder<Region<'tcx>>,\n@@ -109,6 +110,7 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n \n impl<'a, 'tcx> OutlivesEnvironmentBuilder<'tcx> {\n     #[inline]\n+    #[instrument(level = \"debug\")]\n     fn build(self) -> OutlivesEnvironment<'tcx> {\n         OutlivesEnvironment {\n             param_env: self.param_env,"}, {"sha": "3008dfcadde9e3c7eccd56081bd06a34b7f36ee1", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16de1fddee347c326dc4c7f07fa12dd714efd63e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16de1fddee347c326dc4c7f07fa12dd714efd63e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=16de1fddee347c326dc4c7f07fa12dd714efd63e", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'cx, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'cx, 'tcx> {\n     ///   Note that this may cause outlives obligations to be injected\n     ///   into the inference context with this body-id.\n     /// - `ty`, the type that we are supposed to assume is WF.\n-    #[instrument(level = \"debug\", skip(self, param_env, body_id))]\n+    #[instrument(level = \"debug\", skip(self, param_env, body_id), ret)]\n     fn implied_outlives_bounds(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -71,6 +71,7 @@ impl<'a, 'cx, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'cx, 'tcx> {\n         let TypeOpOutput { output, constraints, .. } = result;\n \n         if let Some(constraints) = constraints {\n+            debug!(?constraints);\n             // Instantiation may have produced new inference variables and constraints on those\n             // variables. Process these constraints.\n             let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(self.tcx);"}, {"sha": "691b79f10533dd813579d7a9afa72c76b647ce00", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/16de1fddee347c326dc4c7f07fa12dd714efd63e/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16de1fddee347c326dc4c7f07fa12dd714efd63e/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=16de1fddee347c326dc4c7f07fa12dd714efd63e", "patch": "@@ -49,7 +49,8 @@ fn compute_implied_outlives_bounds<'tcx>(\n     let mut checked_wf_args = rustc_data_structures::fx::FxHashSet::default();\n     let mut wf_args = vec![ty.into()];\n \n-    let mut implied_bounds = vec![];\n+    let mut outlives_bounds: Vec<ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>> =\n+        vec![];\n \n     let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(tcx);\n \n@@ -65,41 +66,28 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // than the ultimate set. (Note: normally there won't be\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n+        //\n+        // FIXME(@lcnr): It's not really \"always fine\", having fewer implied\n+        // bounds can be backward incompatible, e.g. #101951 was caused by\n+        // us not dealing with inference vars in `TypeOutlives` predicates.\n         let obligations = wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, 0, arg, DUMMY_SP)\n             .unwrap_or_default();\n \n-        // N.B., all of these predicates *ought* to be easily proven\n-        // true. In fact, their correctness is (mostly) implied by\n-        // other parts of the program. However, in #42552, we had\n-        // an annoying scenario where:\n-        //\n-        // - Some `T::Foo` gets normalized, resulting in a\n-        //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n-        //   (not sure why it couldn't immediately get\n-        //   solved). This result of `_1` got cached.\n-        // - These obligations were dropped on the floor here,\n-        //   rather than being registered.\n-        // - Then later we would get a request to normalize\n-        //   `T::Foo` which would result in `_1` being used from\n-        //   the cache, but hence without the `T: Trait<Foo=_1>`\n-        //   constraint. As a result, `_1` never gets resolved,\n-        //   and we get an ICE (in dropck).\n-        //\n-        // Therefore, we register any predicates involving\n-        // inference variables. We restrict ourselves to those\n-        // involving inference variables both for efficiency and\n-        // to avoids duplicate errors that otherwise show up.\n+        // While these predicates should all be implied by other parts of\n+        // the program, they are still relevant as they may constrain\n+        // inference variables, which is necessary to add the correct\n+        // implied bounds in some cases, mostly when dealing with projections.\n         fulfill_cx.register_predicate_obligations(\n             infcx,\n             obligations.iter().filter(|o| o.predicate.has_infer_types_or_consts()).cloned(),\n         );\n \n         // From the full set of obligations, just filter down to the\n         // region relationships.\n-        implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n+        outlives_bounds.extend(obligations.into_iter().filter_map(|obligation| {\n             assert!(!obligation.has_escaping_bound_vars());\n             match obligation.predicate.kind().no_bound_vars() {\n-                None => vec![],\n+                None => None,\n                 Some(pred) => match pred {\n                     ty::PredicateKind::Trait(..)\n                     | ty::PredicateKind::Subtype(..)\n@@ -109,21 +97,18 @@ fn compute_implied_outlives_bounds<'tcx>(\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n-                    | ty::PredicateKind::TypeWellFormedFromEnv(..) => vec![],\n+                    | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n                     ty::PredicateKind::WellFormed(arg) => {\n                         wf_args.push(arg);\n-                        vec![]\n+                        None\n                     }\n \n                     ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n-                        vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n+                        Some(ty::OutlivesPredicate(r_a.into(), r_b))\n                     }\n \n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                        let ty_a = infcx.resolve_vars_if_possible(ty_a);\n-                        let mut components = smallvec![];\n-                        push_outlives_components(tcx, ty_a, &mut components);\n-                        implied_bounds_from_components(r_b, components)\n+                        Some(ty::OutlivesPredicate(ty_a.into(), r_b))\n                     }\n                 },\n             }\n@@ -133,9 +118,27 @@ fn compute_implied_outlives_bounds<'tcx>(\n     // Ensure that those obligations that we had to solve\n     // get solved *here*.\n     match fulfill_cx.select_all_or_error(infcx).as_slice() {\n-        [] => Ok(implied_bounds),\n-        _ => Err(NoSolution),\n+        [] => (),\n+        _ => return Err(NoSolution),\n     }\n+\n+    // We lazily compute the outlives components as\n+    // `select_all_or_error` constrains inference variables.\n+    let implied_bounds = outlives_bounds\n+        .into_iter()\n+        .flat_map(|ty::OutlivesPredicate(a, r_b)| match a.unpack() {\n+            ty::GenericArgKind::Lifetime(r_a) => vec![OutlivesBound::RegionSubRegion(r_b, r_a)],\n+            ty::GenericArgKind::Type(ty_a) => {\n+                let ty_a = infcx.resolve_vars_if_possible(ty_a);\n+                let mut components = smallvec![];\n+                push_outlives_components(tcx, ty_a, &mut components);\n+                implied_bounds_from_components(r_b, components)\n+            }\n+            ty::GenericArgKind::Const(_) => unreachable!(),\n+        })\n+        .collect();\n+\n+    Ok(implied_bounds)\n }\n \n /// When we have an implied bound that `T: 'a`, we can further break"}, {"sha": "ae98a8f6209debdb2321e7ab594ee5955db6705c", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16de1fddee347c326dc4c7f07fa12dd714efd63e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16de1fddee347c326dc4c7f07fa12dd714efd63e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=16de1fddee347c326dc4c7f07fa12dd714efd63e", "patch": "@@ -140,6 +140,7 @@ pub(crate) fn compare_impl_method<'tcx>(\n ///\n /// Finally we register each of these predicates as an obligation and check that\n /// they hold.\n+#[instrument(level = \"debug\", skip(tcx, impl_m_span, impl_trait_ref))]\n fn compare_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &AssocItem,"}, {"sha": "108fef8a15fb313bf9c698e84e43b85ee0aab48b", "filename": "src/test/ui/implied-bounds/issue-101951.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/16de1fddee347c326dc4c7f07fa12dd714efd63e/src%2Ftest%2Fui%2Fimplied-bounds%2Fissue-101951.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16de1fddee347c326dc4c7f07fa12dd714efd63e/src%2Ftest%2Fui%2Fimplied-bounds%2Fissue-101951.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimplied-bounds%2Fissue-101951.rs?ref=16de1fddee347c326dc4c7f07fa12dd714efd63e", "patch": "@@ -0,0 +1,50 @@\n+// Taken directly from that issue.\n+//\n+// This test detected that we didn't correctly resolve\n+// inference variables when computing implied bounds.\n+//\n+// check-pass\n+pub trait BuilderFn<'a> {\n+    type Output;\n+}\n+\n+impl<'a, F, Out> BuilderFn<'a> for F\n+where\n+    F: FnOnce(&'a mut ()) -> Out,\n+{\n+    type Output = Out;\n+}\n+\n+pub trait ConstructionFirm {\n+    type Builder: for<'a> BuilderFn<'a>;\n+}\n+\n+pub trait Campus<T>\n+where\n+    T: ConstructionFirm,\n+{\n+    fn add_building(\n+        &mut self,\n+        building: &mut <<T as ConstructionFirm>::Builder as BuilderFn<'_>>::Output,\n+    );\n+}\n+\n+struct ArchitectsInc {}\n+\n+impl ConstructionFirm for ArchitectsInc {\n+    type Builder = fn(&mut ()) -> PrettyCondo<'_>;\n+}\n+\n+struct PrettyCondo<'a> {\n+    _marker: &'a mut (),\n+}\n+\n+struct CondoEstate {}\n+\n+impl Campus<ArchitectsInc> for CondoEstate {\n+    fn add_building(&mut self, _building: &mut PrettyCondo<'_>) {\n+        todo!()\n+    }\n+}\n+\n+fn main() {}"}]}