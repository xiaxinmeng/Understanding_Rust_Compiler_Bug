{"sha": "292ab399b339154e77fef54efe8b975654259733", "node_id": "C_kwDOAAsO6NoAKDI5MmFiMzk5YjMzOTE1NGU3N2ZlZjU0ZWZlOGI5NzU2NTQyNTk3MzM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-17T04:57:17Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-21T02:35:11Z"}, "message": "Point at struct field if possible", "tree": {"sha": "b59da25340b4b1bf50c8082e0295b331f70c1264", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b59da25340b4b1bf50c8082e0295b331f70c1264"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/292ab399b339154e77fef54efe8b975654259733", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/292ab399b339154e77fef54efe8b975654259733", "html_url": "https://github.com/rust-lang/rust/commit/292ab399b339154e77fef54efe8b975654259733", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/292ab399b339154e77fef54efe8b975654259733/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0c6603c79280c34aeba14fea1a5cd3d0e8275eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0c6603c79280c34aeba14fea1a5cd3d0e8275eb", "html_url": "https://github.com/rust-lang/rust/commit/c0c6603c79280c34aeba14fea1a5cd3d0e8275eb"}], "stats": {"total": 330, "additions": 194, "deletions": 136}, "files": [{"sha": "15938b3c9b9cd1fc2621aaa72ee0ae5f06eb25f4", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 176, "deletions": 118, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/292ab399b339154e77fef54efe8b975654259733/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292ab399b339154e77fef54efe8b975654259733/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=292ab399b339154e77fef54efe8b975654259733", "patch": "@@ -1680,48 +1680,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::PredicateKind::Projection(pred) => pred.projection_ty.substs,\n             _ => ty::List::empty(),\n         };\n-        let mut param_to_point_at = predicate_substs.types().find_map(|ty| {\n-            ty.walk().find_map(|arg| {\n-                if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                    && let ty::Param(param_ty) = ty.kind()\n-                    // Look for a param ty that is local to this method/fn\n-                    // and not inherited from an impl, for example.\n-                    && self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) == def_id\n-                {\n-                    Some(arg)\n-                } else {\n-                    None\n-                }\n-            })\n-        });\n-        let mut fallback_param_to_point_at = predicate_substs.types().find_map(|ty| {\n-            ty.walk().find_map(|arg| {\n-                if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                    && let ty::Param(param_ty) = ty.kind()\n-                    && self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) != def_id\n-                    && param_ty.name != rustc_span::symbol::kw::SelfUpper\n-                {\n-                    Some(arg)\n-                } else {\n-                    None\n-                }\n+\n+        let find_param_matching = |matches: &dyn Fn(&ty::ParamTy) -> bool| {\n+            predicate_substs.types().find_map(|ty| {\n+                ty.walk().find_map(|arg| {\n+                    if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                        && let ty::Param(param_ty) = ty.kind()\n+                        && matches(param_ty)\n+                    {\n+                        Some(arg)\n+                    } else {\n+                        None\n+                    }\n+                })\n             })\n+        };\n+\n+        // Prefer generics that are local to the fn item, since these are likely\n+        // to be the cause of the unsatisfied predicaete.\n+        let mut param_to_point_at = find_param_matching(&|param_ty| {\n+            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) == def_id\n         });\n-        let mut self_param_to_point_at = predicate_substs.types().find_map(|ty| {\n-            ty.walk().find_map(|arg| {\n-                if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                    && let ty::Param(param_ty) = ty.kind()\n-                    && param_ty.name == rustc_span::symbol::kw::SelfUpper\n-                {\n-                    Some(arg)\n-                } else {\n-                    None\n-                }\n-            })\n+        // Fall back to generic that isn't local to the fn item. This will come\n+        // from a trait or impl, for example.\n+        let mut fallback_param_to_point_at = find_param_matching(&|param_ty| {\n+            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) != def_id\n+                && param_ty.name != rustc_span::symbol::kw::SelfUpper\n         });\n-\n-        // Also skip over ambiguity errors, which have their own machinery\n-        // to print a relevant error.\n+        // Finally, the `Self` parameter is possibly the reason that the predicate\n+        // is unsatisfied. This is less likely to be true for methods, because the\n+        // method probe means that we already kinda check that the predicates due\n+        // to the `Self` type are true.\n+        let mut self_param_to_point_at =\n+            find_param_matching(&|param_ty| param_ty.name == rustc_span::symbol::kw::SelfUpper);\n+\n+        // For ambiguity errors, we actually want to look for a parameter that is\n+        // the source of the inference type left over in this predicate.\n         if let traits::FulfillmentErrorCode::CodeAmbiguity = error.code {\n             fallback_param_to_point_at = None;\n             self_param_to_point_at = None;\n@@ -1737,99 +1731,101 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     = hir.get(hir.get_parent_node(*hir_id))\n                     && callee.hir_id == *hir_id\n                 {\n-                    if let Some(param_to_point_at) = param_to_point_at\n-                        && self.point_at_args_if_possible(error, def_id, param_to_point_at, *call_hir_id, callee.span, args) {\n-                        return true;\n-                    }\n-\n-                    if let Some(fallback_param_to_point_at) = fallback_param_to_point_at\n-                        && self.point_at_args_if_possible(error, def_id, fallback_param_to_point_at, *call_hir_id, callee.span, args)\n-                    {\n-                        return true;\n-                    }\n-\n-                    if let Some(self_param_to_point_at) = self_param_to_point_at\n-                        && self.point_at_args_if_possible(error, def_id, self_param_to_point_at, *call_hir_id, callee.span, args)\n-                    {\n-                        return true;\n-                    }\n-\n-                    if let hir::QPath::Resolved(_, path) = qpath\n-                        && let Some(param_to_point_at) = param_to_point_at\n-                        && let Some(segment) = path.segments.last()\n-                        && self.point_at_generics_if_possible(error, def_id, param_to_point_at, segment)\n-                    {\n-                        return true;\n+                    for param in [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at] {\n+                        if let Some(param) = param\n+                            && self.point_at_arg_if_possible(error, def_id, param, *call_hir_id, callee.span, args)\n+                        {\n+                            return true;\n+                        }\n                     }\n \n-                    if let hir::QPath::TypeRelative(_, segment) = qpath\n-                        && let Some(param_to_point_at) = param_to_point_at\n-                        && self.point_at_generics_if_possible(error, def_id, param_to_point_at, segment)\n+                    // Notably, we only point to params that are local to the\n+                    // item we're checking, since those are the ones we are able\n+                    // to look in the hir::PathSegment for. Everything else\n+                    // would require a deeper search into the qpath than I think\n+                    // is worthwhile.\n+                    if let Some(param_to_point_at) = param_to_point_at\n+                        && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n                     {\n                         return true;\n                     }\n                 }\n             }\n-            hir::Node::Expr(hir::Expr { kind: hir::ExprKind::MethodCall(segment, args, ..), .. }) => {\n-                if let Some(param_to_point_at) = param_to_point_at\n-                    && self.point_at_args_if_possible(error, def_id, param_to_point_at, hir_id, segment.ident.span, args)\n+            hir::Node::Expr(hir::Expr {\n+                kind: hir::ExprKind::MethodCall(segment, args, ..),\n+                ..\n+            }) => {\n+                for param in [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n                 {\n-                    return true;\n+                    if let Some(param) = param\n+                        && self.point_at_arg_if_possible(error, def_id, param, hir_id, segment.ident.span, args)\n+                    {\n+                        return true;\n+                    }\n                 }\n \n-                if let Some(fallback_param_to_point_at) = fallback_param_to_point_at\n-                    && self.point_at_args_if_possible(error, def_id, fallback_param_to_point_at, hir_id, segment.ident.span, args)\n+                if let Some(param_to_point_at) = param_to_point_at\n+                    && self.point_at_generic_if_possible(error, def_id, param_to_point_at, segment)\n                 {\n                     return true;\n                 }\n-\n-                if let Some(self_param_to_point_at) = self_param_to_point_at\n-                    && self.point_at_args_if_possible(error, def_id, self_param_to_point_at, hir_id, segment.ident.span, args)\n+            }\n+            hir::Node::Expr(hir::Expr {\n+                kind: hir::ExprKind::Struct(qpath, fields, ..), ..\n+            }) => {\n+                if let Res::Def(DefKind::Struct | DefKind::Variant, variant_def_id) =\n+                    self.typeck_results.borrow().qpath_res(qpath, hir_id)\n                 {\n-                    return true;\n+                    for param in\n+                        [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n+                    {\n+                        if let Some(param) = param\n+                            && self.point_at_field_if_possible(error, def_id, param, variant_def_id, fields)\n+                        {\n+                            return true;\n+                        }\n+                    }\n                 }\n \n                 if let Some(param_to_point_at) = param_to_point_at\n-                    && self.point_at_generics_if_possible(error, def_id, param_to_point_at, segment)\n+                    && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n                 {\n                     return true;\n                 }\n             }\n-            hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Struct(..), .. }) => {\n-                // fixme\n-            }\n             _ => {}\n         }\n \n         false\n     }\n \n-    fn find_ambiguous_parameter_in<T: TypeVisitable<'tcx>>(\n+    fn point_at_path_if_possible(\n         &self,\n-        item_def_id: DefId,\n-        t: T,\n-    ) -> Option<ty::GenericArg<'tcx>> {\n-        struct FindAmbiguousParameter<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, DefId);\n-        impl<'tcx> TypeVisitor<'tcx> for FindAmbiguousParameter<'_, 'tcx> {\n-            type BreakTy = ty::GenericArg<'tcx>;\n-            fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n-                if let Some(origin) = self.0.type_var_origin(ty)\n-                    && let TypeVariableOriginKind::TypeParameterDefinition(_, Some(def_id))\n-                        = origin.kind\n-                    && let generics = self.0.tcx.generics_of(self.1)\n-                    && let Some(index) = generics.param_def_id_to_index(self.0.tcx, def_id)\n-                    && let Some(subst) = ty::InternalSubsts::identity_for_item(self.0.tcx, self.1).get(index as usize)\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        def_id: DefId,\n+        param: ty::GenericArg<'tcx>,\n+        qpath: &QPath<'tcx>,\n+    ) -> bool {\n+        match qpath {\n+            hir::QPath::Resolved(_, path) => {\n+                if let Some(segment) = path.segments.last()\n+                    && self.point_at_generic_if_possible(error, def_id, param, segment)\n                 {\n-                    ControlFlow::Break(*subst)\n-                } else {\n-                    ty.super_visit_with(self)\n+                    return true;\n                 }\n             }\n+            hir::QPath::TypeRelative(_, segment) => {\n+                if self.point_at_generic_if_possible(error, def_id, param, segment) {\n+                    return true;\n+                }\n+            }\n+            _ => {}\n         }\n-        t.visit_with(&mut FindAmbiguousParameter(self, item_def_id)).break_value()\n+\n+        false\n     }\n \n-    fn point_at_args_if_possible(\n+    fn point_at_arg_if_possible(\n         &self,\n         error: &mut traits::FulfillmentError<'tcx>,\n         def_id: DefId,\n@@ -1843,25 +1839,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .inputs()\n             .iter()\n             .enumerate()\n-            .filter(|(_, ty)| {\n-                let mut walk = ty.walk();\n-                while let Some(arg) = walk.next() {\n-                    if arg == param_to_point_at {\n-                        return true;\n-                    } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                        && let ty::Projection(..) = ty.kind()\n-                    {\n-                        // This logic may seem a bit strange, but typically when\n-                        // we have a projection type in a function signature, the\n-                        // argument that's being passed into that signature is\n-                        // not actually constraining that projection in a meaningful\n-                        // way. So we skip it, and see improvements in some UI tests\n-                        // due to it.\n-                        walk.skip_current_subtree();\n-                    }\n-                }\n-                false\n-            })\n+            .filter(|(_, ty)| find_param_in_ty(ty, param_to_point_at))\n             .collect();\n \n         if let [(idx, _)] = args_referencing_param.as_slice()\n@@ -1886,7 +1864,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn point_at_generics_if_possible(\n+    fn point_at_field_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        def_id: DefId,\n+        param_to_point_at: ty::GenericArg<'tcx>,\n+        variant_def_id: DefId,\n+        expr_fields: &[hir::ExprField<'tcx>],\n+    ) -> bool {\n+        let def = self.tcx.adt_def(def_id);\n+        let identity_substs = ty::InternalSubsts::identity_for_item(self.tcx, def_id);\n+        let fields_referencing_param: Vec<_> = def\n+            .variant_with_id(variant_def_id)\n+            .fields\n+            .iter()\n+            .filter(|field| {\n+                let field_ty = field.ty(self.tcx, identity_substs);\n+                match find_param_in_ty(field_ty, param_to_point_at) {\n+                    Ok(value) => value,\n+                    Err(value) => return value,\n+                }\n+            })\n+            .collect();\n+        if let [field] = fields_referencing_param.as_slice() {\n+            for expr_field in expr_fields {\n+                if self.tcx.adjust_ident(expr_field.ident, variant_def_id) == field.ident(self.tcx)\n+                {\n+                    error.obligation.cause.span = expr_field.span;\n+                }\n+            }\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn point_at_generic_if_possible(\n         &self,\n         error: &mut traits::FulfillmentError<'tcx>,\n         def_id: DefId,\n@@ -1912,6 +1925,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         true\n     }\n \n+    fn find_ambiguous_parameter_in<T: TypeVisitable<'tcx>>(\n+        &self,\n+        item_def_id: DefId,\n+        t: T,\n+    ) -> Option<ty::GenericArg<'tcx>> {\n+        struct FindAmbiguousParameter<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, DefId);\n+        impl<'tcx> TypeVisitor<'tcx> for FindAmbiguousParameter<'_, 'tcx> {\n+            type BreakTy = ty::GenericArg<'tcx>;\n+            fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n+                if let Some(origin) = self.0.type_var_origin(ty)\n+                    && let TypeVariableOriginKind::TypeParameterDefinition(_, Some(def_id))\n+                        = origin.kind\n+                    && let generics = self.0.tcx.generics_of(self.1)\n+                    && let Some(index) = generics.param_def_id_to_index(self.0.tcx, def_id)\n+                    && let Some(subst) = ty::InternalSubsts::identity_for_item(self.0.tcx, self.1).get(index as usize)\n+                {\n+                    ControlFlow::Break(*subst)\n+                } else {\n+                    ty.super_visit_with(self)\n+                }\n+            }\n+        }\n+        t.visit_with(&mut FindAmbiguousParameter(self, item_def_id)).break_value()\n+    }\n+\n     fn label_fn_like(\n         &self,\n         err: &mut Diagnostic,\n@@ -2053,3 +2091,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n+\n+fn find_param_in_ty(ty: Ty, param_to_point_at: ty::GenericArg) -> bool {\n+    let mut walk = ty.walk();\n+    while let Some(arg) = walk.next() {\n+        if arg == param_to_point_at {\n+        return true;\n+    } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+        && let ty::Projection(..) = ty.kind()\n+    {\n+        // This logic may seem a bit strange, but typically when\n+        // we have a projection type in a function signature, the\n+        // argument that's being passed into that signature is\n+        // not actually constraining that projection's substs in\n+        // a meaningful way. So we skip it, and see improvements\n+        // in some UI tests.\n+        walk.skip_current_subtree();\n+    }\n+    }\n+    false\n+}"}, {"sha": "eeeefcfb7dd15cd846411f5dd6c8307174cd42ae", "filename": "src/test/ui/chalkify/type_wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs?ref=292ab399b339154e77fef54efe8b975654259733", "patch": "@@ -15,8 +15,8 @@ fn main() {\n        x: 5,\n     };\n \n-    let s = S { //~ ERROR the trait bound `{float}: Foo` is not satisfied\n-        x: 5.0,\n+    let s = S {\n+        x: 5.0, //~ ERROR the trait bound `{float}: Foo` is not satisfied\n     };\n \n     let s = S {"}, {"sha": "28314928a3c2649f55e5fcdc6dbee8d4a70972ed", "filename": "src/test/ui/chalkify/type_wf.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.stderr?ref=292ab399b339154e77fef54efe8b975654259733", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `{float}: Foo` is not satisfied\n-  --> $DIR/type_wf.rs:18:13\n+  --> $DIR/type_wf.rs:19:9\n    |\n-LL |     let s = S {\n-   |             ^ the trait `Foo` is not implemented for `{float}`\n+LL |         x: 5.0,\n+   |         ^^^^^^ the trait `Foo` is not implemented for `{float}`\n    |\n    = help: the trait `Foo` is implemented for `i32`\n note: required by a bound in `S`"}, {"sha": "aaea91ce0cbae15aac806d8e64ab459fbd531233", "filename": "src/test/ui/range/range-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Frange%2Frange-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Frange%2Frange-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange%2Frange-1.stderr?ref=292ab399b339154e77fef54efe8b975654259733", "patch": "@@ -27,7 +27,7 @@ error[E0277]: the size for values of type `[{integer}]` cannot be known at compi\n   --> $DIR/range-1.rs:14:17\n    |\n LL |     let range = *arr..;\n-   |                 ^^^^^^ doesn't have a size known at compile-time\n+   |                 ^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `[{integer}]`\n note: required by a bound in `RangeFrom`"}, {"sha": "60ba343bb0a5c272216fd7fded1024239e86918d", "filename": "src/test/ui/traits/bound/on-structs-and-enums-locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fon-structs-and-enums-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fon-structs-and-enums-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fon-structs-and-enums-locals.rs?ref=292ab399b339154e77fef54efe8b975654259733", "patch": "@@ -8,8 +8,8 @@ struct Foo<T:Trait> {\n \n fn main() {\n     let foo = Foo {\n-    //~^ ERROR E0277\n         x: 3\n+    //~^ ERROR E0277\n     };\n \n     let baz: Foo<usize> = loop { };"}, {"sha": "4abff9fb0495a308c2a22770c6179a117ce9aba2", "filename": "src/test/ui/traits/bound/on-structs-and-enums-locals.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fon-structs-and-enums-locals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fon-structs-and-enums-locals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fon-structs-and-enums-locals.stderr?ref=292ab399b339154e77fef54efe8b975654259733", "patch": "@@ -11,10 +11,10 @@ LL | struct Foo<T:Trait> {\n    |              ^^^^^ required by this bound in `Foo`\n \n error[E0277]: the trait bound `{integer}: Trait` is not satisfied\n-  --> $DIR/on-structs-and-enums-locals.rs:10:15\n+  --> $DIR/on-structs-and-enums-locals.rs:11:9\n    |\n-LL |     let foo = Foo {\n-   |               ^^^ the trait `Trait` is not implemented for `{integer}`\n+LL |         x: 3\n+   |         ^^^^ the trait `Trait` is not implemented for `{integer}`\n    |\n note: required by a bound in `Foo`\n   --> $DIR/on-structs-and-enums-locals.rs:5:14"}, {"sha": "5ef35b513e0fb532e160ca65aab7b7e349573021", "filename": "src/test/ui/traits/bound/on-structs-and-enums-xc1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fon-structs-and-enums-xc1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fon-structs-and-enums-xc1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fon-structs-and-enums-xc1.rs?ref=292ab399b339154e77fef54efe8b975654259733", "patch": "@@ -6,8 +6,8 @@ use on_structs_and_enums_xc::{Bar, Foo, Trait};\n \n fn main() {\n     let foo = Foo {\n-    //~^ ERROR E0277\n         x: 3\n+    //~^ ERROR E0277\n     };\n     let bar: Bar<f64> = return;\n     //~^ ERROR E0277"}, {"sha": "dd0de44f3b1196335dba4bbfbc932e16b1834c86", "filename": "src/test/ui/traits/bound/on-structs-and-enums-xc1.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fon-structs-and-enums-xc1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fon-structs-and-enums-xc1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fon-structs-and-enums-xc1.stderr?ref=292ab399b339154e77fef54efe8b975654259733", "patch": "@@ -11,10 +11,10 @@ LL | pub enum Bar<T:Trait> {\n    |                ^^^^^ required by this bound in `Bar`\n \n error[E0277]: the trait bound `{integer}: Trait` is not satisfied\n-  --> $DIR/on-structs-and-enums-xc1.rs:8:15\n+  --> $DIR/on-structs-and-enums-xc1.rs:9:9\n    |\n-LL |     let foo = Foo {\n-   |               ^^^ the trait `Trait` is not implemented for `{integer}`\n+LL |         x: 3\n+   |         ^^^^ the trait `Trait` is not implemented for `{integer}`\n    |\n note: required by a bound in `Foo`\n   --> $DIR/auxiliary/on_structs_and_enums_xc.rs:5:18"}, {"sha": "037022a91fcd07053546f6c35ba907eccc728ed1", "filename": "src/test/ui/union/union-generic.mirunsafeck.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Funion%2Funion-generic.mirunsafeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Funion%2Funion-generic.mirunsafeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-generic.mirunsafeck.stderr?ref=292ab399b339154e77fef54efe8b975654259733", "patch": "@@ -11,10 +11,10 @@ LL | union U<T: Copy> {\n    |            ^^^^ required by this bound in `U`\n \n error[E0277]: the trait bound `Rc<u32>: Copy` is not satisfied\n-  --> $DIR/union-generic.rs:13:13\n+  --> $DIR/union-generic.rs:13:17\n    |\n LL |     let u = U::<Rc<u32>> { a: Default::default() };\n-   |             ^^^^^^^^^^^^ the trait `Copy` is not implemented for `Rc<u32>`\n+   |                 ^^^^^^^ the trait `Copy` is not implemented for `Rc<u32>`\n    |\n note: required by a bound in `U`\n   --> $DIR/union-generic.rs:6:12"}, {"sha": "037022a91fcd07053546f6c35ba907eccc728ed1", "filename": "src/test/ui/union/union-generic.thirunsafeck.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Funion%2Funion-generic.thirunsafeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/292ab399b339154e77fef54efe8b975654259733/src%2Ftest%2Fui%2Funion%2Funion-generic.thirunsafeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-generic.thirunsafeck.stderr?ref=292ab399b339154e77fef54efe8b975654259733", "patch": "@@ -11,10 +11,10 @@ LL | union U<T: Copy> {\n    |            ^^^^ required by this bound in `U`\n \n error[E0277]: the trait bound `Rc<u32>: Copy` is not satisfied\n-  --> $DIR/union-generic.rs:13:13\n+  --> $DIR/union-generic.rs:13:17\n    |\n LL |     let u = U::<Rc<u32>> { a: Default::default() };\n-   |             ^^^^^^^^^^^^ the trait `Copy` is not implemented for `Rc<u32>`\n+   |                 ^^^^^^^ the trait `Copy` is not implemented for `Rc<u32>`\n    |\n note: required by a bound in `U`\n   --> $DIR/union-generic.rs:6:12"}]}