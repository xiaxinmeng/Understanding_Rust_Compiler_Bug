{"sha": "86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ZjJiMjlkMmZmMzM4NjIyNjRlMmU2ZGZkYzdjYzIwYWQwNTRhZDE=", "commit": {"author": {"name": "Daniel Smith", "email": "daniel.smith@datadoghq.com", "date": "2020-10-19T16:06:43Z"}, "committer": {"name": "Daniel Smith", "email": "daniel.smith@datadoghq.com", "date": "2020-10-21T15:04:26Z"}, "message": "Merge lints into one pass", "tree": {"sha": "1af67316439cf43bd0cf37f0470721412792cfbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1af67316439cf43bd0cf37f0470721412792cfbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1", "html_url": "https://github.com/rust-lang/rust/commit/86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1/comments", "author": null, "committer": null, "parents": [{"sha": "d8c6bce4407b1c99ed961f75a093ffe767818069", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8c6bce4407b1c99ed961f75a093ffe767818069", "html_url": "https://github.com/rust-lang/rust/commit/d8c6bce4407b1c99ed961f75a093ffe767818069"}], "stats": {"total": 72, "additions": 24, "deletions": 48}, "files": [{"sha": "fcebb54c6c217840d3b5a2b7faa8f1249dc72a29", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 23, "deletions": 46, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1", "patch": "@@ -49,48 +49,6 @@ declare_clippy_lint! {\n     \"Inside an async function, holding a MutexGuard while calling await\"\n }\n \n-declare_lint_pass!(AwaitHoldingLock => [AWAIT_HOLDING_LOCK]);\n-\n-impl LateLintPass<'_> for AwaitHoldingLock {\n-    fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n-        use AsyncGeneratorKind::{Block, Closure, Fn};\n-        if let Some(GeneratorKind::Async(Block | Closure | Fn)) = body.generator_kind {\n-            let body_id = BodyId {\n-                hir_id: body.value.hir_id,\n-            };\n-            let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n-            let typeck_results = cx.tcx.typeck(def_id);\n-            check_interior_types_lock(cx, &typeck_results.generator_interior_types, body.value.span);\n-        }\n-    }\n-}\n-\n-fn check_interior_types_lock(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n-    for ty_cause in ty_causes {\n-        if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n-            if is_mutex_guard(cx, adt.did) {\n-                span_lint_and_note(\n-                    cx,\n-                    AWAIT_HOLDING_LOCK,\n-                    ty_cause.span,\n-                    \"this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\",\n-                    ty_cause.scope_span.or(Some(span)),\n-                    \"these are all the await points this lock is held through\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn is_mutex_guard(cx: &LateContext<'_>, def_id: DefId) -> bool {\n-    match_def_path(cx, def_id, &paths::MUTEX_GUARD)\n-        || match_def_path(cx, def_id, &paths::RWLOCK_READ_GUARD)\n-        || match_def_path(cx, def_id, &paths::RWLOCK_WRITE_GUARD)\n-        || match_def_path(cx, def_id, &paths::PARKING_LOT_MUTEX_GUARD)\n-        || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_READ_GUARD)\n-        || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_WRITE_GUARD)\n-}\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for calls to await while holding a\n     /// `RefCell` `Ref` or `RefMut`.\n@@ -130,9 +88,9 @@ declare_clippy_lint! {\n     \"Inside an async function, holding a RefCell ref while calling await\"\n }\n \n-declare_lint_pass!(AwaitHoldingRefCellRef => [AWAIT_HOLDING_REFCELL_REF]);\n+declare_lint_pass!(AwaitHolding => [AWAIT_HOLDING_LOCK, AWAIT_HOLDING_REFCELL_REF]);\n \n-impl LateLintPass<'_> for AwaitHoldingRefCellRef {\n+impl LateLintPass<'_> for AwaitHolding {\n     fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n         use AsyncGeneratorKind::{Block, Closure, Fn};\n         if let Some(GeneratorKind::Async(Block | Closure | Fn)) = body.generator_kind {\n@@ -141,14 +99,24 @@ impl LateLintPass<'_> for AwaitHoldingRefCellRef {\n             };\n             let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n             let typeck_results = cx.tcx.typeck(def_id);\n-            check_interior_types_refcell(cx, &typeck_results.generator_interior_types, body.value.span);\n+            check_interior_types(cx, &typeck_results.generator_interior_types, body.value.span);\n         }\n     }\n }\n \n-fn check_interior_types_refcell(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n+fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n     for ty_cause in ty_causes {\n         if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n+            if is_mutex_guard(cx, adt.did) {\n+                span_lint_and_note(\n+                    cx,\n+                    AWAIT_HOLDING_LOCK,\n+                    ty_cause.span,\n+                    \"this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\",\n+                    ty_cause.scope_span.or(Some(span)),\n+                    \"these are all the await points this lock is held through\",\n+                );\n+            }\n             if is_refcell_ref(cx, adt.did) {\n                 span_lint_and_note(\n                         cx,\n@@ -163,6 +131,15 @@ fn check_interior_types_refcell(cx: &LateContext<'_>, ty_causes: &[GeneratorInte\n     }\n }\n \n+fn is_mutex_guard(cx: &LateContext<'_>, def_id: DefId) -> bool {\n+    match_def_path(cx, def_id, &paths::MUTEX_GUARD)\n+        || match_def_path(cx, def_id, &paths::RWLOCK_READ_GUARD)\n+        || match_def_path(cx, def_id, &paths::RWLOCK_WRITE_GUARD)\n+        || match_def_path(cx, def_id, &paths::PARKING_LOT_MUTEX_GUARD)\n+        || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_READ_GUARD)\n+        || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_WRITE_GUARD)\n+}\n+\n fn is_refcell_ref(cx: &LateContext<'_>, def_id: DefId) -> bool {\n     match_def_path(cx, def_id, &paths::REFCELL_REF) || match_def_path(cx, def_id, &paths::REFCELL_REFMUT)\n }"}, {"sha": "6d00e313ce1b07d2f0e973422095bbf59cfc452e", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=86f2b29d2ff33862264e2e6dfdc7cc20ad054ad1", "patch": "@@ -906,8 +906,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     ]);\n     // end register lints, do not remove this comment, it\u2019s used in `update_lints`\n \n-    store.register_late_pass(|| box await_holding_invalid::AwaitHoldingLock);\n-    store.register_late_pass(|| box await_holding_invalid::AwaitHoldingRefCellRef);\n+    store.register_late_pass(|| box await_holding_invalid::AwaitHolding);\n     store.register_late_pass(|| box serde_api::SerdeAPI);\n     store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n     store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());"}]}