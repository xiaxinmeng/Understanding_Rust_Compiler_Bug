{"sha": "ba2a77b4506ca29105ebd7e257bb2328c2b2b1b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMmE3N2I0NTA2Y2EyOTEwNWViZDdlMjU3YmIyMzI4YzJiMmIxYjM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-06T02:21:06Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-06T20:46:16Z"}, "message": "stabilisation", "tree": {"sha": "d62ec93983aae1a46e729275545511bf0fbee00f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d62ec93983aae1a46e729275545511bf0fbee00f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba2a77b4506ca29105ebd7e257bb2328c2b2b1b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba2a77b4506ca29105ebd7e257bb2328c2b2b1b3", "html_url": "https://github.com/rust-lang/rust/commit/ba2a77b4506ca29105ebd7e257bb2328c2b2b1b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba2a77b4506ca29105ebd7e257bb2328c2b2b1b3/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "503709708c72401dbe091ed5c7e0494efabe0669", "url": "https://api.github.com/repos/rust-lang/rust/commits/503709708c72401dbe091ed5c7e0494efabe0669", "html_url": "https://github.com/rust-lang/rust/commit/503709708c72401dbe091ed5c7e0494efabe0669"}], "stats": {"total": 16, "additions": 16, "deletions": 0}, "files": [{"sha": "45b80593c3cd562eec57ece65dbd5a97169f2b50", "filename": "src/libcore/markers.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ba2a77b4506ca29105ebd7e257bb2328c2b2b1b3/src%2Flibcore%2Fmarkers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba2a77b4506ca29105ebd7e257bb2328c2b2b1b3/src%2Flibcore%2Fmarkers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarkers.rs?ref=ba2a77b4506ca29105ebd7e257bb2328c2b2b1b3", "patch": "@@ -29,18 +29,21 @@ use clone::Clone;\n \n \n /// Types able to be transferred across task boundaries.\n+#[unstable = \"will be overhauled with new lifetime rules; see RFC 458\"]\n #[lang=\"send\"]\n pub unsafe trait Send: 'static {\n     // empty.\n }\n \n /// Types with a constant size known at compile-time.\n+#[stable]\n #[lang=\"sized\"]\n pub trait Sized {\n     // Empty.\n }\n \n /// Types that can be copied by simply copying bits (i.e. `memcpy`).\n+#[stable]\n #[lang=\"copy\"]\n pub trait Copy {\n     // Empty.\n@@ -91,6 +94,7 @@ pub trait Copy {\n /// around the value(s) which can be mutated when behind a `&`\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal).\n+#[unstable = \"will be overhauled with new lifetime rules; see RFC 458\"]\n #[lang=\"sync\"]\n pub unsafe trait Sync {\n     // Empty\n@@ -134,6 +138,7 @@ pub unsafe trait Sync {\n /// `S<T>` is a subtype of `S<U>` if `T` is a subtype of `U`\n /// (for example, `S<&'static int>` is a subtype of `S<&'a int>`\n /// for some lifetime `'a`, but not the other way around).\n+#[unstable = \"likely to change with new variance strategy\"]\n #[lang=\"covariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub struct CovariantType<Sized? T>;\n@@ -182,6 +187,7 @@ impl<Sized? T> Clone for CovariantType<T> {\n /// subtype of `S<U>` if `U` is a subtype of `T`; given that the\n /// function requires arguments of type `T`, it must also accept\n /// arguments of type `U`, hence such a conversion is safe.\n+#[unstable = \"likely to change with new variance strategy\"]\n #[lang=\"contravariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub struct ContravariantType<T: ?Sized>;\n@@ -212,11 +218,14 @@ impl<T: ?Sized> Clone for ContravariantType<T> {\n /// The type system would infer that `value` is only read here and\n /// never written, but in fact `Cell` uses unsafe code to achieve\n /// interior mutability.\n+#[unstable = \"likely to change with new variance strategy\"]\n #[lang=\"invariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub struct InvariantType<T: ?Sized>;\n \n+#[unstable = \"likely to change with new variance strategy\"]\n impl<T: ?Sized> Copy for InvariantType<T> {}\n+#[unstable = \"likely to change with new variance strategy\"]\n impl<T: ?Sized> Clone for InvariantType<T> {\n     fn clone(&self) -> InvariantType<T> { *self }\n }\n@@ -237,6 +246,7 @@ impl<T: ?Sized> Clone for InvariantType<T> {\n ///\n /// For more information about variance, refer to this Wikipedia\n /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+#[unstable = \"likely to change with new variance strategy\"]\n #[lang=\"covariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct CovariantLifetime<'a>;\n@@ -253,6 +263,7 @@ pub struct CovariantLifetime<'a>;\n ///\n /// For more information about variance, refer to this Wikipedia\n /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n+#[unstable = \"likely to change with new variance strategy\"]\n #[lang=\"contravariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct ContravariantLifetime<'a>;\n@@ -264,6 +275,7 @@ pub struct ContravariantLifetime<'a>;\n /// pointer that is actually a pointer into memory with lifetime `'a`,\n /// and this pointer is itself stored in an inherently mutable\n /// location (such as a `Cell`).\n+#[unstable = \"likely to change with new variance strategy\"]\n #[lang=\"invariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct InvariantLifetime<'a>;\n@@ -272,13 +284,15 @@ pub struct InvariantLifetime<'a>;\n /// be safely sent between tasks, even if it is owned. This is\n /// typically embedded in other types, such as `Gc`, to ensure that\n /// their instances remain thread-local.\n+#[unstable = \"likely to change with new variance strategy\"]\n #[lang=\"no_send_bound\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct NoSend;\n \n /// A type which is considered \"not POD\", meaning that it is not\n /// implicitly copyable. This is typically embedded in other types to\n /// ensure that they are never copied, even if they lack a destructor.\n+#[unstable = \"likely to change with new variance strategy\"]\n #[lang=\"no_copy_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n #[allow(missing_copy_implementations)]\n@@ -287,12 +301,14 @@ pub struct NoCopy;\n /// A type which is considered \"not sync\", meaning that\n /// its contents are not threadsafe, hence they cannot be\n /// shared between tasks.\n+#[unstable = \"likely to change with new variance strategy\"]\n #[lang=\"no_sync_bound\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct NoSync;\n \n /// A type which is considered managed by the GC. This is typically\n /// embedded in other types.\n+#[unstable = \"likely to change with new variance strategy\"]\n #[lang=\"managed_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n #[allow(missing_copy_implementations)]"}]}