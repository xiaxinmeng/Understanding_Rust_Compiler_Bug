{"sha": "2be4cc040211a85b17f21e813ff62351ae4de642", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiZTRjYzA0MDIxMWE4NWIxN2YyMWU4MTNmZjYyMzUxYWU0ZGU2NDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-01T18:14:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-01T18:14:13Z"}, "message": "Auto merge of #45538 - nikomatsakis:nll-liveness, r=pnkfelix\n\nenable non-lexical lifetimes in the MIR borrow checker\n\nThis PR, joint work with @spastorino, fills out the NLL infrastructure and integrates it with the borrow checker. **Don't get too excited:** it includes still a number of hacks (the subtyping code is particularly hacky). However, it *does* kinda' work. =)\n\nThe final commit demonstrates this by including a test that -- with both the AST borrowck and MIR borrowck -- reports an error by default. But if you pass `-Znll`, you only get an error from the AST borrowck, demonstrating that the integration succeeds:\n\n```\nstruct MyStruct {\n    field: String\n}\n\nfn main() {\n    let mut my_struct = MyStruct { field: format!(\"Hello\") };\n\n    let value = &my_struct.field;\n    if value.is_empty() {\n        my_struct.field.push_str(\"Hello, world!\");\n        //~^ ERROR cannot borrow (Ast)\n    }\n}\n```", "tree": {"sha": "00ff995722d49a7636784ddf73efea763ac349b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00ff995722d49a7636784ddf73efea763ac349b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2be4cc040211a85b17f21e813ff62351ae4de642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2be4cc040211a85b17f21e813ff62351ae4de642", "html_url": "https://github.com/rust-lang/rust/commit/2be4cc040211a85b17f21e813ff62351ae4de642", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2be4cc040211a85b17f21e813ff62351ae4de642/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14", "html_url": "https://github.com/rust-lang/rust/commit/a3f990dc08437ecf63f5e15e8ec6acb9cbedbc14"}, {"sha": "aae3e74e70e3b21d00142ca9175e9d806d09a2bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/aae3e74e70e3b21d00142ca9175e9d806d09a2bf", "html_url": "https://github.com/rust-lang/rust/commit/aae3e74e70e3b21d00142ca9175e9d806d09a2bf"}], "stats": {"total": 2724, "additions": 2102, "deletions": 622}, "files": [{"sha": "e725592ff99e6877ee3ac2662c6aaf10e77bfb2c", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -158,7 +158,7 @@ pub struct BlockRemainder {\n \n newtype_index!(FirstStatementIndex\n     {\n-        DEBUG_NAME = \"\",\n+        DEBUG_FORMAT = \"{}\",\n         MAX = SCOPE_DATA_REMAINDER_MAX,\n     });\n "}, {"sha": "c4a33bb07cdf21d4fd067dfbb17872d04d1f642a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -417,7 +417,7 @@ pub enum BorrowKind {\n \n newtype_index!(Local\n     {\n-        DEBUG_NAME = \"_\",\n+        DEBUG_FORMAT = \"_{}\",\n         const RETURN_POINTER = 0,\n     });\n \n@@ -553,7 +553,7 @@ pub struct UpvarDecl {\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlock\n \n-newtype_index!(BasicBlock { DEBUG_NAME = \"bb\" });\n+newtype_index!(BasicBlock { DEBUG_FORMAT = \"bb{}\" });\n \n ///////////////////////////////////////////////////////////////////////////\n // BasicBlockData and Terminator\n@@ -1135,7 +1135,7 @@ pub type LvalueProjection<'tcx> = Projection<'tcx, Lvalue<'tcx>, Local, Ty<'tcx>\n /// and the index is a local.\n pub type LvalueElem<'tcx> = ProjectionElem<'tcx, Local, Ty<'tcx>>;\n \n-newtype_index!(Field { DEBUG_NAME = \"field\" });\n+newtype_index!(Field { DEBUG_FORMAT = \"field[{}]\" });\n \n impl<'tcx> Lvalue<'tcx> {\n     pub fn field(self, f: Field, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n@@ -1202,7 +1202,7 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n \n newtype_index!(VisibilityScope\n     {\n-        DEBUG_NAME = \"scope\",\n+        DEBUG_FORMAT = \"scope[{}]\",\n         const ARGUMENT_VISIBILITY_SCOPE = 0,\n     });\n \n@@ -1529,7 +1529,7 @@ pub struct Constant<'tcx> {\n     pub literal: Literal<'tcx>,\n }\n \n-newtype_index!(Promoted { DEBUG_NAME = \"promoted\" });\n+newtype_index!(Promoted { DEBUG_FORMAT = \"promoted[{}]\" });\n \n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n@@ -1637,6 +1637,14 @@ impl fmt::Debug for Location {\n }\n \n impl Location {\n+    /// Returns the location immediately after this one within the enclosing block.\n+    ///\n+    /// Note that if this location represents a terminator, then the\n+    /// resulting location would be out of bounds and invalid.\n+    pub fn successor_within_block(&self) -> Location {\n+        Location { block: self.block, statement_index: self.statement_index + 1 }\n+    }\n+\n     pub fn dominates(&self, other: &Location, dominators: &Dominators<BasicBlock>) -> bool {\n         if self.block == other.block {\n             self.statement_index <= other.statement_index"}, {"sha": "6c90a5f38d02765180719f7192720c8fbe34f87f", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -39,13 +39,13 @@ pub enum MirSource {\n     GeneratorDrop(NodeId),\n }\n \n-impl<'a, 'tcx> MirSource {\n-    pub fn from_local_def_id(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> MirSource {\n+impl<'a, 'gcx, 'tcx> MirSource {\n+    pub fn from_local_def_id(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> MirSource {\n         let id = tcx.hir.as_local_node_id(def_id).expect(\"mir source requires local def-id\");\n         Self::from_node(tcx, id)\n     }\n \n-    pub fn from_node(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: NodeId) -> MirSource {\n+    pub fn from_node(tcx: TyCtxt<'a, 'gcx, 'tcx>, id: NodeId) -> MirSource {\n         use hir::*;\n \n         // Handle constants in enum discriminants, types, and repeat expressions."}, {"sha": "149999e0eee0f4f2f9b09737ea348f7b93ee7b62", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -218,6 +218,43 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f))\n     }\n+\n+    pub fn for_each_free_region<T,F>(self,\n+                                     value: &T,\n+                                     callback: F)\n+        where F: FnMut(ty::Region<'tcx>),\n+              T: TypeFoldable<'tcx>,\n+    {\n+        value.visit_with(&mut RegionVisitor { current_depth: 0, callback });\n+\n+        struct RegionVisitor<F> {\n+            current_depth: u32,\n+            callback: F,\n+        }\n+\n+        impl<'tcx, F> TypeVisitor<'tcx> for RegionVisitor<F>\n+            where F : FnMut(ty::Region<'tcx>)\n+        {\n+            fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n+                self.current_depth += 1;\n+                t.skip_binder().visit_with(self);\n+                self.current_depth -= 1;\n+\n+                false // keep visiting\n+            }\n+\n+            fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+                match *r {\n+                    ty::ReLateBound(debruijn, _) if debruijn.depth < self.current_depth => {\n+                        /* ignore bound regions */\n+                    }\n+                    _ => (self.callback)(r),\n+                }\n+\n+                false // keep visiting\n+            }\n+        }\n+    }\n }\n \n /// Folds over the substructure of a type, visiting its component"}, {"sha": "908737669c5cb37b989f6e9a18daf1319eb1c431", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -484,7 +484,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             // 3. Where does old loan expire.\n \n             let previous_end_span =\n-                old_loan.kill_scope.span(self.tcx(), &self.bccx.region_scope_tree).end_point();\n+                Some(old_loan.kill_scope.span(self.tcx(), &self.bccx.region_scope_tree)\n+                     .end_point());\n \n             let mut err = match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) =>"}, {"sha": "c5ffb0033999556819070439d453e09c287d7ac7", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -53,11 +53,19 @@ pub struct IdxSet<T: Idx> {\n }\n \n impl<T: Idx> fmt::Debug for IdxSetBuf<T> {\n-    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result { self.bits.fmt(w) }\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        w.debug_list()\n+         .entries(self.iter())\n+         .finish()\n+    }\n }\n \n impl<T: Idx> fmt::Debug for IdxSet<T> {\n-    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result { self.bits.fmt(w) }\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        w.debug_list()\n+         .entries(self.iter())\n+         .finish()\n+    }\n }\n \n impl<T: Idx> IdxSetBuf<T> {"}, {"sha": "0660cd96a4a34ee6be812e7e11637d23ca67f103", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -47,22 +47,22 @@ macro_rules! newtype_index {\n         newtype_index!(\n             @type[$name]\n             @max[::std::u32::MAX]\n-            @debug_name[unsafe {::std::intrinsics::type_name::<$name>() }]);\n+            @debug_format[\"{}\"]);\n     );\n \n     // Define any constants\n     ($name:ident { $($tokens:tt)+ }) => (\n         newtype_index!(\n             @type[$name]\n             @max[::std::u32::MAX]\n-            @debug_name[unsafe {::std::intrinsics::type_name::<$name>() }]\n+            @debug_format[\"{}\"]\n             $($tokens)+);\n     );\n \n     // ---- private rules ----\n \n     // Base case, user-defined constants (if any) have already been defined\n-    (@type[$type:ident] @max[$max:expr] @debug_name[$debug_name:expr]) => (\n+    (@type[$type:ident] @max[$max:expr] @debug_format[$debug_format:expr]) => (\n         #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord,\n             RustcEncodable, RustcDecodable)]\n         pub struct $type(pub u32);\n@@ -79,40 +79,43 @@ macro_rules! newtype_index {\n \n         impl ::std::fmt::Debug for $type {\n             fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n-                write!(fmt, \"{}{}\", $debug_name, self.0)\n+                write!(fmt, $debug_format, self.0)\n             }\n         }\n     );\n \n     // Rewrite final without comma to one that includes comma\n-    (@type[$type:ident] @max[$max:expr] @debug_name[$debug_name:expr]\n+    (@type[$type:ident] @max[$max:expr] @debug_format[$debug_format:expr]\n             $name:ident = $constant:expr) => (\n-        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $name = $constant,);\n+        newtype_index!(@type[$type] @max[$max] @debug_format[$debug_format] $name = $constant,);\n     );\n \n     // Rewrite final const without comma to one that includes comma\n-    (@type[$type:ident] @max[$_max:expr] @debug_name[$debug_name:expr]\n+    (@type[$type:ident] @max[$_max:expr] @debug_format[$debug_format:expr]\n             const $name:ident = $constant:expr) => (\n-        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] const $name = $constant,);\n+        newtype_index!(@type[$type]\n+                       @max[$max]\n+                       @debug_format[$debug_format]\n+                       const $name = $constant,);\n     );\n \n     // Replace existing default for max\n-    (@type[$type:ident] @max[$_max:expr] @debug_name[$debug_name:expr]\n+    (@type[$type:ident] @max[$_max:expr] @debug_format[$debug_format:expr]\n             MAX = $max:expr, $($tokens:tt)*) => (\n-        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $($tokens)*);\n+        newtype_index!(@type[$type] @max[$max] @debug_format[$debug_format] $($tokens)*);\n     );\n \n-    // Replace existing default for debug_name\n-    (@type[$type:ident] @max[$max:expr] @debug_name[$_debug_name:expr]\n-            DEBUG_NAME = $debug_name:expr, $($tokens:tt)*) => (\n-        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $($tokens)*);\n+    // Replace existing default for debug_format\n+    (@type[$type:ident] @max[$max:expr] @debug_format[$_debug_format:expr]\n+            DEBUG_FORMAT = $debug_format:expr, $($tokens:tt)*) => (\n+        newtype_index!(@type[$type] @max[$max] @debug_format[$debug_format] $($tokens)*);\n     );\n \n     // Assign a user-defined constant (as final param)\n-    (@type[$type:ident] @max[$max:expr] @debug_name[$debug_name:expr]\n+    (@type[$type:ident] @max[$max:expr] @debug_format[$debug_format:expr]\n             const $name:ident = $constant:expr, $($tokens:tt)*) => (\n         pub const $name: $type = $type($constant);\n-        newtype_index!(@type[$type] @max[$max] @debug_name[$debug_name] $($tokens)*);\n+        newtype_index!(@type[$type] @max[$max] @debug_format[$debug_format] $($tokens)*);\n     );\n }\n "}, {"sha": "855362cf645d2122fb7eee94a7d26245a5510ae9", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -1007,7 +1007,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     passes.push_pass(MIR_VALIDATED, mir::transform::qualify_consts::QualifyAndPromoteConstants);\n     passes.push_pass(MIR_VALIDATED, mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));\n-    passes.push_pass(MIR_VALIDATED, mir::transform::nll::NLL);\n \n     // borrowck runs between MIR_VALIDATED and MIR_OPTIMIZED.\n "}, {"sha": "819f67a39e931c88fa121d15d7ad2412bf451cc2", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 139, "deletions": 111, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -17,7 +17,8 @@ use rustc::ty::maps::Providers;\n use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Lvalue, Local};\n use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n use rustc::mir::{Statement, StatementKind, Terminator, TerminatorKind};\n-use rustc::mir::transform::{MirSource};\n+use rustc::mir::transform::MirSource;\n+use transform::nll;\n \n use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n use rustc_data_structures::indexed_vec::{Idx};\n@@ -46,93 +47,120 @@ pub fn provide(providers: &mut Providers) {\n }\n \n fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n-    let mir = tcx.mir_validated(def_id);\n+    let input_mir = tcx.mir_validated(def_id);\n     let src = MirSource::from_local_def_id(tcx, def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.node_path_str(src.item_id()));\n \n-    let mir: &Mir<'tcx> = &mir.borrow();\n-    if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.sess.opts.debugging_opts.borrowck_mir {\n+    if {\n+        !tcx.has_attr(def_id, \"rustc_mir_borrowck\") &&\n+            !tcx.sess.opts.debugging_opts.borrowck_mir &&\n+            !tcx.sess.opts.debugging_opts.nll\n+    } {\n         return;\n     }\n \n-    let id = src.item_id();\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let input_mir: &Mir = &input_mir.borrow();\n+        do_mir_borrowck(&infcx, input_mir, def_id, src);\n+    });\n+    debug!(\"mir_borrowck done\");\n+}\n+\n+fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                   input_mir: &Mir<'gcx>,\n+                                   def_id: DefId,\n+                                   src: MirSource)\n+{\n+    let tcx = infcx.tcx;\n     let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);\n-    tcx.infer_ctxt().enter(|_infcx| {\n-\n-        let move_data = match MoveData::gather_moves(mir, tcx, param_env) {\n-            Ok(move_data) => move_data,\n-            Err((move_data, move_errors)) => {\n-                for move_error in move_errors {\n-                    let (span, kind): (Span, IllegalMoveOriginKind) = match move_error {\n-                        MoveError::UnionMove { .. } =>\n-                            unimplemented!(\"dont know how to report union move errors yet.\"),\n-                        MoveError::IllegalMove { cannot_move_out_of: o } => (o.span, o.kind),\n-                    };\n-                    let origin = Origin::Mir;\n-                    let mut err = match kind {\n-                        IllegalMoveOriginKind::Static =>\n-                            tcx.cannot_move_out_of(span, \"static item\", origin),\n-                        IllegalMoveOriginKind::BorrowedContent =>\n-                            tcx.cannot_move_out_of(span, \"borrowed_content\", origin),\n-                        IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } =>\n-                            tcx.cannot_move_out_of_interior_of_drop(span, ty, origin),\n-                        IllegalMoveOriginKind::InteriorOfSlice { elem_ty: ty, is_index } =>\n-                            tcx.cannot_move_out_of_interior_noncopy(span, ty, is_index, origin),\n-                        IllegalMoveOriginKind::InteriorOfArray { elem_ty: ty, is_index } =>\n-                            tcx.cannot_move_out_of_interior_noncopy(span, ty, is_index, origin),\n-                    };\n-                    err.emit();\n-                }\n-                move_data\n+\n+    let id = src.item_id();\n+\n+    let move_data: MoveData<'tcx> = match MoveData::gather_moves(input_mir, tcx, param_env) {\n+        Ok(move_data) => move_data,\n+        Err((move_data, move_errors)) => {\n+            for move_error in move_errors {\n+                let (span, kind): (Span, IllegalMoveOriginKind) = match move_error {\n+                    MoveError::UnionMove { .. } =>\n+                        unimplemented!(\"dont know how to report union move errors yet.\"),\n+                    MoveError::IllegalMove { cannot_move_out_of: o } => (o.span, o.kind),\n+                };\n+                let origin = Origin::Mir;\n+                let mut err = match kind {\n+                    IllegalMoveOriginKind::Static =>\n+                        tcx.cannot_move_out_of(span, \"static item\", origin),\n+                    IllegalMoveOriginKind::BorrowedContent =>\n+                        tcx.cannot_move_out_of(span, \"borrowed_content\", origin),\n+                    IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } =>\n+                        tcx.cannot_move_out_of_interior_of_drop(span, ty, origin),\n+                    IllegalMoveOriginKind::InteriorOfSlice { elem_ty: ty, is_index } =>\n+                        tcx.cannot_move_out_of_interior_noncopy(span, ty, is_index, origin),\n+                    IllegalMoveOriginKind::InteriorOfArray { elem_ty: ty, is_index } =>\n+                        tcx.cannot_move_out_of_interior_noncopy(span, ty, is_index, origin),\n+                };\n+                err.emit();\n             }\n-        };\n-        let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n-        let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n-        let flow_borrows = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                                       Borrows::new(tcx, mir),\n-                                       |bd, i| bd.location(i));\n-        let flow_inits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                                     MaybeInitializedLvals::new(tcx, mir, &mdpe),\n-                                     |bd, i| &bd.move_data().move_paths[i]);\n-        let flow_uninits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                                       MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n-                                       |bd, i| &bd.move_data().move_paths[i]);\n-\n-        let mut mbcx = MirBorrowckCtxt {\n-            tcx: tcx,\n-            mir: mir,\n-            node_id: id,\n-            move_data: &mdpe.move_data,\n-            param_env: param_env,\n-            fake_infer_ctxt: &_infcx,\n-        };\n+            move_data\n+        }\n+    };\n \n-        let mut state = InProgress::new(flow_borrows,\n-                                        flow_inits,\n-                                        flow_uninits);\n+    // Make our own copy of the MIR. This copy will be modified (in place) to\n+    // contain non-lexical lifetimes. It will have a lifetime tied\n+    // to the inference context.\n+    let mut mir: Mir<'tcx> = input_mir.clone();\n+    let mir = &mut mir;\n+\n+    // If we are in non-lexical mode, compute the non-lexical lifetimes.\n+    let opt_regioncx = if !tcx.sess.opts.debugging_opts.nll {\n+        None\n+    } else {\n+        Some(nll::compute_regions(infcx, src, mir))\n+    };\n \n-        mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n-    });\n+    let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n+    let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+    let flow_borrows = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                   Borrows::new(tcx, mir, opt_regioncx.as_ref()),\n+                                   |bd, i| bd.location(i));\n+    let flow_inits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                 MaybeInitializedLvals::new(tcx, mir, &mdpe),\n+                                 |bd, i| &bd.move_data().move_paths[i]);\n+    let flow_uninits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                   MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n+                                   |bd, i| &bd.move_data().move_paths[i]);\n+\n+    let mut mbcx = MirBorrowckCtxt {\n+        tcx: tcx,\n+        mir: mir,\n+        node_id: id,\n+        move_data: &mdpe.move_data,\n+        param_env: param_env,\n+        fake_infer_ctxt: &infcx,\n+    };\n \n-    debug!(\"mir_borrowck done\");\n+    let mut state = InProgress::new(flow_borrows,\n+                                    flow_inits,\n+                                    flow_uninits);\n+\n+    mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n }\n \n #[allow(dead_code)]\n pub struct MirBorrowckCtxt<'c, 'b, 'a: 'b+'c, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-    mir: &'b Mir<'gcx>,\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &'b Mir<'tcx>,\n     node_id: ast::NodeId,\n-    move_data: &'b MoveData<'gcx>,\n+    move_data: &'b MoveData<'tcx>,\n     param_env: ParamEnv<'tcx>,\n     fake_infer_ctxt: &'c InferCtxt<'c, 'gcx, 'tcx>,\n }\n \n // (forced to be `pub` due to its use as an associated type below.)\n-pub struct InProgress<'b, 'tcx: 'b> {\n-    borrows: FlowInProgress<Borrows<'b, 'tcx>>,\n-    inits: FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>,\n-    uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>,\n+pub struct InProgress<'b, 'gcx: 'tcx, 'tcx: 'b> {\n+    borrows: FlowInProgress<Borrows<'b, 'gcx, 'tcx>>,\n+    inits: FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n+    uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n }\n \n struct FlowInProgress<BD> where BD: BitDenotation {\n@@ -147,12 +175,12 @@ struct FlowInProgress<BD> where BD: BitDenotation {\n // 2. loans made in overlapping scopes do not conflict\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves do not affect things loaned out in any way\n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'tcx>\n     for MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n {\n-    type FlowState = InProgress<'b, 'gcx>;\n+    type FlowState = InProgress<'b, 'gcx, 'tcx>;\n \n-    fn mir(&self) -> &'b Mir<'gcx> { self.mir }\n+    fn mir(&self) -> &'b Mir<'tcx> { self.mir }\n \n     fn reset_to_entry_of(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n         flow_state.each_flow(|b| b.reset_to_entry_of(bb),\n@@ -193,7 +221,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n \n     fn visit_statement_entry(&mut self,\n                              location: Location,\n-                             stmt: &Statement<'gcx>,\n+                             stmt: &Statement<'tcx>,\n                              flow_state: &Self::FlowState) {\n         let summary = flow_state.summary();\n         debug!(\"MirBorrowckCtxt::process_statement({:?}, {:?}): {}\", location, stmt, summary);\n@@ -261,7 +289,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n \n     fn visit_terminator_entry(&mut self,\n                               location: Location,\n-                              term: &Terminator<'gcx>,\n+                              term: &Terminator<'tcx>,\n                               flow_state: &Self::FlowState) {\n         let loc = location;\n         let summary = flow_state.summary();\n@@ -405,9 +433,9 @@ enum WriteKind {\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn access_lvalue(&mut self,\n                      context: Context,\n-                     lvalue_span: (&Lvalue<'gcx>, Span),\n+                     lvalue_span: (&Lvalue<'tcx>, Span),\n                      kind: (ShallowOrDeep, ReadOrWrite),\n-                     flow_state: &InProgress<'b, 'gcx>) {\n+                     flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         // FIXME: also need to check permissions (e.g. reject mut\n         // borrow of immutable ref, moves through non-`Box`-ref)\n         let (sd, rw) = kind;\n@@ -425,8 +453,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                                     context, lvalue_span, borrow),\n                             ReadKind::Borrow(bk) => {\n                                 let end_issued_loan_span =\n-                                    flow_state.borrows.base_results.operator().region_span(\n-                                        &borrow.region).end_point();\n+                                    flow_state.borrows.base_results.operator().opt_region_end_span(\n+                                        &borrow.region);\n                                 this.report_conflicting_borrow(\n                                     context, common_prefix, lvalue_span, bk,\n                                     &borrow, end_issued_loan_span)\n@@ -438,8 +466,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                         match kind {\n                             WriteKind::MutableBorrow(bk) => {\n                                 let end_issued_loan_span =\n-                                    flow_state.borrows.base_results.operator().region_span(\n-                                        &borrow.region).end_point();\n+                                    flow_state.borrows.base_results.operator().opt_region_end_span(\n+                                        &borrow.region);\n                                 this.report_conflicting_borrow(\n                                     context, common_prefix, lvalue_span, bk,\n                                     &borrow, end_issued_loan_span)\n@@ -460,10 +488,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn mutate_lvalue(&mut self,\n                      context: Context,\n-                     lvalue_span: (&Lvalue<'gcx>, Span),\n+                     lvalue_span: (&Lvalue<'tcx>, Span),\n                      kind: ShallowOrDeep,\n                      mode: MutateMode,\n-                     flow_state: &InProgress<'b, 'gcx>) {\n+                     flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n         match mode {\n             MutateMode::WriteAndRead => {\n@@ -482,9 +510,9 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn consume_rvalue(&mut self,\n                       context: Context,\n-                      (rvalue, span): (&Rvalue<'gcx>, Span),\n+                      (rvalue, span): (&Rvalue<'tcx>, Span),\n                       _location: Location,\n-                      flow_state: &InProgress<'b, 'gcx>) {\n+                      flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         match *rvalue {\n             Rvalue::Ref(_/*rgn*/, bk, ref lvalue) => {\n                 let access_kind = match bk {\n@@ -540,8 +568,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn consume_operand(&mut self,\n                        context: Context,\n                        consume_via_drop: ConsumeKind,\n-                       (operand, span): (&Operand<'gcx>, Span),\n-                       flow_state: &InProgress<'b, 'gcx>) {\n+                       (operand, span): (&Operand<'tcx>, Span),\n+                       flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         match *operand {\n             Operand::Consume(ref lvalue) => {\n                 self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state)\n@@ -553,8 +581,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn consume_lvalue(&mut self,\n                       context: Context,\n                       consume_via_drop: ConsumeKind,\n-                      lvalue_span: (&Lvalue<'gcx>, Span),\n-                      flow_state: &InProgress<'b, 'gcx>) {\n+                      lvalue_span: (&Lvalue<'tcx>, Span),\n+                      flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         let lvalue = lvalue_span.0;\n         let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n         let moves_by_default =\n@@ -584,8 +612,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn check_if_reassignment_to_immutable_state(&mut self,\n                                                 context: Context,\n-                                                (lvalue, span): (&Lvalue<'gcx>, Span),\n-                                                flow_state: &InProgress<'b, 'gcx>) {\n+                                                (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                                flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         let move_data = self.move_data;\n \n         // determine if this path has a non-mut owner (and thus needs checking).\n@@ -635,8 +663,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn check_if_path_is_moved(&mut self,\n                               context: Context,\n                               desired_action: &str,\n-                              lvalue_span: (&Lvalue<'gcx>, Span),\n-                              flow_state: &InProgress<'b, 'gcx>) {\n+                              lvalue_span: (&Lvalue<'tcx>, Span),\n+                              flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         // FIXME: analogous code in check_loans first maps `lvalue` to\n         // its base_path ... but is that what we want here?\n         let lvalue = self.base_path(lvalue_span.0);\n@@ -725,7 +753,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     /// An Err result includes a tag indicated why the search failed.\n     /// Currenly this can only occur if the lvalue is built off of a\n     /// static variable, as we do not track those in the MoveData.\n-    fn move_path_closest_to(&mut self, lvalue: &Lvalue<'gcx>)\n+    fn move_path_closest_to(&mut self, lvalue: &Lvalue<'tcx>)\n                             -> Result<MovePathIndex, NoMovePathFound>\n     {\n         let mut last_prefix = lvalue;\n@@ -743,7 +771,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     }\n \n     fn move_path_for_lvalue(&mut self,\n-                            lvalue: &Lvalue<'gcx>)\n+                            lvalue: &Lvalue<'tcx>)\n                             -> Option<MovePathIndex>\n     {\n         // If returns None, then there is no move path corresponding\n@@ -758,8 +786,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn check_if_assigned_path_is_moved(&mut self,\n                                        context: Context,\n-                                       (lvalue, span): (&Lvalue<'gcx>, Span),\n-                                       flow_state: &InProgress<'b, 'gcx>) {\n+                                       (lvalue, span): (&Lvalue<'tcx>, Span),\n+                                       flow_state: &InProgress<'b, 'gcx, 'tcx>) {\n         // recur down lvalue; dispatch to check_if_path_is_moved when necessary\n         let mut lvalue = lvalue;\n         loop {\n@@ -827,10 +855,10 @@ enum NoMovePathFound {\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn each_borrow_involving_path<F>(&mut self,\n                                      _context: Context,\n-                                     access_lvalue: (ShallowOrDeep, &Lvalue<'gcx>),\n-                                     flow_state: &InProgress<'b, 'gcx>,\n+                                     access_lvalue: (ShallowOrDeep, &Lvalue<'tcx>),\n+                                     flow_state: &InProgress<'b, 'gcx, 'tcx>,\n                                      mut op: F)\n-        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'gcx>, &Lvalue) -> Control\n+        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>, &Lvalue) -> Control\n     {\n         let (access, lvalue) = access_lvalue;\n \n@@ -928,9 +956,9 @@ mod prefixes {\n     }\n \n \n-    pub(super) struct Prefixes<'c, 'tcx: 'c> {\n+    pub(super) struct Prefixes<'c, 'gcx: 'tcx, 'tcx: 'c> {\n         mir: &'c Mir<'tcx>,\n-        tcx: TyCtxt<'c, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'c, 'gcx, 'tcx>,\n         kind: PrefixSet,\n         next: Option<&'c Lvalue<'tcx>>,\n     }\n@@ -951,15 +979,15 @@ mod prefixes {\n         /// (inclusive) from longest to smallest, potentially\n         /// terminating the iteration early based on `kind`.\n         pub(super) fn prefixes<'d>(&self,\n-                                   lvalue: &'d Lvalue<'gcx>,\n+                                   lvalue: &'d Lvalue<'tcx>,\n                                    kind: PrefixSet)\n-                                   -> Prefixes<'d, 'gcx> where 'b: 'd\n+                                   -> Prefixes<'d, 'gcx, 'tcx> where 'b: 'd\n         {\n             Prefixes { next: Some(lvalue), kind, mir: self.mir, tcx: self.tcx }\n         }\n     }\n \n-    impl<'c, 'tcx> Iterator for Prefixes<'c, 'tcx> {\n+    impl<'c, 'gcx, 'tcx> Iterator for Prefixes<'c, 'gcx, 'tcx> {\n         type Item = &'c Lvalue<'tcx>;\n         fn next(&mut self) -> Option<Self::Item> {\n             let mut cursor = match self.next {\n@@ -1101,7 +1129,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                                  (lvalue, span): (&Lvalue, Span),\n                                  gen_borrow_kind: BorrowKind,\n                                  issued_borrow: &BorrowData,\n-                                 end_issued_loan_span: Span) {\n+                                 end_issued_loan_span: Option<Span>) {\n         use self::prefixes::IsPrefixOf;\n \n         assert!(common_prefix.is_prefix_of(lvalue));\n@@ -1315,7 +1343,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     // moves out of a Box. They should be removed when/if we stop\n     // treating Box specially (e.g. when/if DerefMove is added...)\n \n-    fn base_path<'d>(&self, lvalue: &'d Lvalue<'gcx>) -> &'d Lvalue<'gcx> {\n+    fn base_path<'d>(&self, lvalue: &'d Lvalue<'tcx>) -> &'d Lvalue<'tcx> {\n         //! Returns the base of the leftmost (deepest) dereference of an\n         //! Box in `lvalue`. If there is no dereference of an Box\n         //! in `lvalue`, then it just returns `lvalue` itself.\n@@ -1364,10 +1392,10 @@ impl ContextKind {\n     fn new(self, loc: Location) -> Context { Context { kind: self, loc: loc } }\n }\n \n-impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n-    pub(super) fn new(borrows: DataflowResults<Borrows<'b, 'tcx>>,\n-                      inits: DataflowResults<MaybeInitializedLvals<'b, 'tcx>>,\n-                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>)\n+impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n+    pub(super) fn new(borrows: DataflowResults<Borrows<'b, 'gcx, 'tcx>>,\n+                      inits: DataflowResults<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n+                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>)\n                       -> Self {\n         InProgress {\n             borrows: FlowInProgress::new(borrows),\n@@ -1380,9 +1408,9 @@ impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n                              mut xform_borrows: XB,\n                              mut xform_inits: XI,\n                              mut xform_uninits: XU) where\n-        XB: FnMut(&mut FlowInProgress<Borrows<'b, 'tcx>>),\n-        XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>),\n-        XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>),\n+        XB: FnMut(&mut FlowInProgress<Borrows<'b, 'gcx, 'tcx>>),\n+        XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>),\n+        XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>),\n     {\n         xform_borrows(&mut self.borrows);\n         xform_inits(&mut self.inits);\n@@ -1438,7 +1466,7 @@ impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n     }\n }\n \n-impl<'b, 'tcx> FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>> {\n+impl<'b, 'gcx, 'tcx> FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>> {\n     fn has_any_child_of(&self, mpi: MovePathIndex) -> Option<MovePathIndex> {\n         let move_data = self.base_results.operator().move_data();\n "}, {"sha": "77496c7b8f218b922e9991ea3cc540cf8034c311", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -240,10 +240,10 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n-pub fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             closure_expr_id: ast::NodeId,\n-                             body_id: hir::BodyId)\n-                             -> Ty<'tcx> {\n+pub fn closure_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                       closure_expr_id: ast::NodeId,\n+                                       body_id: hir::BodyId)\n+                                       -> Ty<'tcx> {\n     let closure_expr_hir_id = tcx.hir.node_to_hir_id(closure_expr_id);\n     let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_hir_id);\n "}, {"sha": "e35bd34c40bd0ce6a1b3012dfcb4be2c3aef16da", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -58,9 +58,9 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n /// is no need to maintain separate drop flags to track such state.\n ///\n /// FIXME: we have to do something for moving slice patterns.\n-fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                      mir: &Mir<'tcx>,\n-                                                      lv: &mir::Lvalue<'tcx>) -> bool {\n+fn lvalue_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                            mir: &Mir<'tcx>,\n+                                                            lv: &mir::Lvalue<'tcx>) -> bool {\n     let ty = lv.ty(mir, tcx).to_ty(tcx);\n     match ty.sty {\n         ty::TyArray(..) | ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n@@ -79,8 +79,8 @@ fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n     }\n }\n \n-pub(crate) fn on_lookup_result_bits<'a, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn on_lookup_result_bits<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     move_data: &MoveData<'tcx>,\n     lookup_result: LookupResult,\n@@ -97,16 +97,16 @@ pub(crate) fn on_lookup_result_bits<'a, 'tcx, F>(\n     }\n }\n \n-pub(crate) fn on_all_children_bits<'a, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     move_data: &MoveData<'tcx>,\n     move_path_index: MovePathIndex,\n     mut each_child: F)\n     where F: FnMut(MovePathIndex)\n {\n-    fn is_terminal_path<'a, 'tcx>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn is_terminal_path<'a, 'gcx, 'tcx>(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n         move_data: &MoveData<'tcx>,\n         path: MovePathIndex) -> bool\n@@ -115,8 +115,8 @@ pub(crate) fn on_all_children_bits<'a, 'tcx, F>(\n             tcx, mir, &move_data.move_paths[path].lvalue)\n     }\n \n-    fn on_all_children_bits<'a, 'tcx, F>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n         move_data: &MoveData<'tcx>,\n         move_path_index: MovePathIndex,\n@@ -138,10 +138,10 @@ pub(crate) fn on_all_children_bits<'a, 'tcx, F>(\n     on_all_children_bits(tcx, mir, move_data, move_path_index, &mut each_child);\n }\n \n-pub(crate) fn on_all_drop_children_bits<'a, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn on_all_drop_children_bits<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    ctxt: &MoveDataParamEnv<'tcx>,\n+    ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     path: MovePathIndex,\n     mut each_child: F)\n     where F: FnMut(MovePathIndex)\n@@ -151,18 +151,20 @@ pub(crate) fn on_all_drop_children_bits<'a, 'tcx, F>(\n         let ty = lvalue.ty(mir, tcx).to_ty(tcx);\n         debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, lvalue, ty);\n \n-        if ty.needs_drop(tcx, ctxt.param_env) {\n+        let gcx = tcx.global_tcx();\n+        let erased_ty = gcx.lift(&tcx.erase_regions(&ty)).unwrap();\n+        if erased_ty.needs_drop(gcx, ctxt.param_env) {\n             each_child(child);\n         } else {\n             debug!(\"on_all_drop_children_bits - skipping\")\n         }\n     })\n }\n \n-pub(crate) fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn drop_flag_effects_for_function_entry<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    ctxt: &MoveDataParamEnv<'tcx>,\n+    ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     mut callback: F)\n     where F: FnMut(MovePathIndex, DropFlagState)\n {\n@@ -176,10 +178,10 @@ pub(crate) fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n     }\n }\n \n-pub(crate) fn drop_flag_effects_for_location<'a, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn drop_flag_effects_for_location<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    ctxt: &MoveDataParamEnv<'tcx>,\n+    ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     loc: Location,\n     mut callback: F)\n     where F: FnMut(MovePathIndex, DropFlagState)\n@@ -196,7 +198,9 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'tcx, F>(\n         // don't move out of non-Copy things\n         let lvalue = &move_data.move_paths[path].lvalue;\n         let ty = lvalue.ty(mir, tcx).to_ty(tcx);\n-        if !ty.moves_by_default(tcx, param_env, DUMMY_SP) {\n+        let gcx = tcx.global_tcx();\n+        let erased_ty = gcx.lift(&tcx.erase_regions(&ty)).unwrap();\n+        if !erased_ty.moves_by_default(gcx, param_env, DUMMY_SP) {\n             continue;\n         }\n "}, {"sha": "17aa8c054181e4a904a0ca7566cbccf9633a243f", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -21,6 +21,8 @@ use rustc_data_structures::indexed_vec::{IndexVec};\n \n use dataflow::{BitDenotation, BlockSets, DataflowOperator};\n pub use dataflow::indexes::BorrowIndex;\n+use transform::nll::region_infer::RegionInferenceContext;\n+use transform::nll::ToRegionIndex;\n \n use syntax_pos::Span;\n \n@@ -29,13 +31,14 @@ use std::fmt;\n // `Borrows` maps each dataflow bit to an `Rvalue::Ref`, which can be\n // uniquely identified in the MIR by the `Location` of the assigment\n // statement in which it appears on the right hand side.\n-pub struct Borrows<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     borrows: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n     location_map: FxHashMap<Location, BorrowIndex>,\n     region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n     region_span_map: FxHashMap<RegionKind, Span>,\n+    nonlexical_regioncx: Option<&'a RegionInferenceContext>,\n }\n \n // temporarily allow some dead fields: `kind` and `region` will be\n@@ -63,8 +66,11 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Borrows<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+               mir: &'a Mir<'tcx>,\n+               nonlexical_regioncx: Option<&'a RegionInferenceContext>)\n+               -> Self {\n         let mut visitor = GatherBorrows { idx_vec: IndexVec::new(),\n                                           location_map: FxHashMap(),\n                                           region_map: FxHashMap(),\n@@ -75,7 +81,8 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n                          borrows: visitor.idx_vec,\n                          location_map: visitor.location_map,\n                          region_map: visitor.region_map,\n-                         region_span_map: visitor.region_span_map};\n+                         region_span_map: visitor.region_span_map,\n+                         nonlexical_regioncx };\n \n         struct GatherBorrows<'tcx> {\n             idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n@@ -116,14 +123,34 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         &self.borrows[idx].location\n     }\n \n-    pub fn region_span(&self, region: &Region) -> Span {\n+    /// Returns the span for the \"end point\" given region. This will\n+    /// return `None` if NLL is enabled, since that concept has no\n+    /// meaning there.  Otherwise, it should return some.\n+    pub fn opt_region_end_span(&self, region: &Region) -> Option<Span> {\n         let opt_span = self.region_span_map.get(region);\n-        assert!(opt_span.is_some(), \"end region not found for {:?}\", region);\n-        *opt_span.unwrap()\n+        assert!(self.nonlexical_regioncx.is_some() ||\n+                opt_span.is_some(), \"end region not found for {:?}\", region);\n+        opt_span.map(|s| s.end_point())\n+    }\n+\n+    /// Add all borrows to the kill set, if those borrows are out of scope at `location`.\n+    fn kill_loans_out_of_scope_at_location(&self,\n+                                           sets: &mut BlockSets<BorrowIndex>,\n+                                           location: Location) {\n+        if let Some(regioncx) = self.nonlexical_regioncx {\n+            for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n+                let borrow_region = regioncx.region_value(borrow_data.region.to_region_index());\n+                if !borrow_region.may_contain(location) && location != borrow_data.location {\n+                    debug!(\"kill_loans_out_of_scope_at_location: kill{:?} \\\n+                           location={:?} borrow_data={:?}\", borrow_index, location, borrow_data);\n+                    sets.kill(&borrow_index);\n+                }\n+            }\n+        }\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation for Borrows<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n     type Idx = BorrowIndex;\n     fn name() -> &'static str { \"borrows\" }\n     fn bits_per_block(&self) -> usize {\n@@ -146,6 +173,7 @@ impl<'a, 'tcx> BitDenotation for Borrows<'a, 'tcx> {\n         match stmt.kind {\n             mir::StatementKind::EndRegion(region_scope) => {\n                 if let Some(borrow_indexes) = self.region_map.get(&ReScope(region_scope)) {\n+                    assert!(self.nonlexical_regioncx.is_none());\n                     for idx in borrow_indexes { sets.kill(&idx); }\n                 } else {\n                     // (if there is no entry, then there are no borrows to be tracked)\n@@ -172,11 +200,14 @@ impl<'a, 'tcx> BitDenotation for Borrows<'a, 'tcx> {\n             mir::StatementKind::Nop => {}\n \n         }\n+\n+        self.kill_loans_out_of_scope_at_location(sets, location);\n     }\n+\n     fn terminator_effect(&self,\n-                         _sets: &mut BlockSets<BorrowIndex>,\n-                         _location: Location) {\n-        // no terminators start nor end region scopes.\n+                         sets: &mut BlockSets<BorrowIndex>,\n+                         location: Location) {\n+        self.kill_loans_out_of_scope_at_location(sets, location);\n     }\n \n     fn propagate_call_return(&self,\n@@ -188,14 +219,14 @@ impl<'a, 'tcx> BitDenotation for Borrows<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitwiseOperator for Borrows<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for Borrows<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 | pred2 // union effects of preds when computing borrows\n     }\n }\n \n-impl<'a, 'tcx> DataflowOperator for Borrows<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> DataflowOperator for Borrows<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = no Rvalue::Refs are active by default"}, {"sha": "af99706be811d21770f975921ebc29affe62337e", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -69,23 +69,23 @@ pub(super) mod borrows;\n /// Similarly, at a given `drop` statement, the set-intersection\n /// between this data and `MaybeUninitializedLvals` yields the set of\n /// l-values that would require a dynamic drop-flag at that statement.\n-pub struct MaybeInitializedLvals<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct MaybeInitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n-    mdpe: &'a MoveDataParamEnv<'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx: 'a> MaybeInitializedLvals<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx: 'tcx, 'tcx> MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'tcx>)\n+               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n         MaybeInitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'tcx: 'a> HasMoveData<'tcx> for MaybeInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n@@ -124,23 +124,23 @@ impl<'a, 'tcx: 'a> HasMoveData<'tcx> for MaybeInitializedLvals<'a, 'tcx> {\n /// Similarly, at a given `drop` statement, the set-intersection\n /// between this data and `MaybeInitializedLvals` yields the set of\n /// l-values that would require a dynamic drop-flag at that statement.\n-pub struct MaybeUninitializedLvals<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct MaybeUninitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n-    mdpe: &'a MoveDataParamEnv<'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx: 'a> MaybeUninitializedLvals<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx> MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'tcx>)\n+               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n         MaybeUninitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'tcx: 'a> HasMoveData<'tcx> for MaybeUninitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n@@ -185,27 +185,27 @@ impl<'a, 'tcx: 'a> HasMoveData<'tcx> for MaybeUninitializedLvals<'a, 'tcx> {\n /// Similarly, at a given `drop` statement, the set-difference between\n /// this data and `MaybeInitializedLvals` yields the set of l-values\n /// that would require a dynamic drop-flag at that statement.\n-pub struct DefinitelyInitializedLvals<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct DefinitelyInitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n-    mdpe: &'a MoveDataParamEnv<'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx: 'a> DefinitelyInitializedLvals<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx: 'a> DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'tcx>)\n+               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n         DefinitelyInitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n-impl<'a, 'tcx> MaybeInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -216,7 +216,7 @@ impl<'a, 'tcx> MaybeInitializedLvals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MaybeUninitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -227,7 +227,7 @@ impl<'a, 'tcx> MaybeUninitializedLvals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> DefinitelyInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -238,7 +238,7 @@ impl<'a, 'tcx> DefinitelyInitializedLvals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"maybe_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -290,7 +290,7 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"maybe_uninit\" }\n     fn bits_per_block(&self) -> usize {\n@@ -345,7 +345,7 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"definite_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -399,21 +399,21 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 | pred2 // \"maybe\" means we union effects of both preds\n     }\n }\n \n-impl<'a, 'tcx> BitwiseOperator for MaybeUninitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 | pred2 // \"maybe\" means we union effects of both preds\n     }\n }\n \n-impl<'a, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 & pred2 // \"definitely\" means we intersect effects of both preds\n@@ -430,21 +430,21 @@ impl<'a, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n // propagating, or you start at all-ones and then use Intersect as\n // your merge when propagating.\n \n-impl<'a, 'tcx> DataflowOperator for MaybeInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> DataflowOperator for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = uninitialized\n     }\n }\n \n-impl<'a, 'tcx> DataflowOperator for MaybeUninitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> DataflowOperator for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = initialized (start_block_effect counters this at outset)\n     }\n }\n \n-impl<'a, 'tcx> DataflowOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> DataflowOperator for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         true // bottom = initialized (start_block_effect counters this at outset)"}, {"sha": "d27a4e7e9d9c3fe98070d89f86977d19c2982680", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -91,19 +91,19 @@ pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option\n     return None;\n }\n \n-pub struct MoveDataParamEnv<'tcx> {\n+pub struct MoveDataParamEnv<'gcx, 'tcx> {\n     pub(crate) move_data: MoveData<'tcx>,\n-    pub(crate) param_env: ty::ParamEnv<'tcx>,\n+    pub(crate) param_env: ty::ParamEnv<'gcx>,\n }\n \n-pub(crate) fn do_dataflow<'a, 'tcx, BD, P>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                mir: &Mir<'tcx>,\n-                                node_id: ast::NodeId,\n-                                attributes: &[ast::Attribute],\n-                                dead_unwinds: &IdxSet<BasicBlock>,\n-                                bd: BD,\n-                                p: P)\n-                                -> DataflowResults<BD>\n+pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                 mir: &Mir<'tcx>,\n+                                                 node_id: ast::NodeId,\n+                                                 attributes: &[ast::Attribute],\n+                                                 dead_unwinds: &IdxSet<BasicBlock>,\n+                                                 bd: BD,\n+                                                 p: P)\n+                                                 -> DataflowResults<BD>\n     where BD: BitDenotation,\n           P: Fn(&BD, BD::Idx) -> &fmt::Debug\n {\n@@ -612,9 +612,9 @@ pub trait BitDenotation: DataflowOperator {\n                              dest_lval: &mir::Lvalue);\n }\n \n-impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n+impl<'a, 'gcx, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n {\n-    pub fn new(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn new(_tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n                dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n                denotation: D) -> Self {"}, {"sha": "8f473d035ee1df128f32e39ca72246248d94adf4", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -25,18 +25,18 @@ use super::{LocationMap, MoveData, MovePath, MovePathLookup, MovePathIndex, Move\n use super::{MoveError};\n use super::IllegalMoveOriginKind::*;\n \n-struct MoveDataBuilder<'a, 'tcx: 'a> {\n+struct MoveDataBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'gcx>,\n     data: MoveData<'tcx>,\n     errors: Vec<MoveError<'tcx>>,\n }\n \n-impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n     fn new(mir: &'a Mir<'tcx>,\n-           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-           param_env: ty::ParamEnv<'tcx>)\n+           tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+           param_env: ty::ParamEnv<'gcx>)\n            -> Self {\n         let mut move_paths = IndexVec::new();\n         let mut path_map = IndexVec::new();\n@@ -86,7 +86,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n+impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n     /// This creates a MovePath for a given lvalue, returning an `MovePathError`\n     /// if that lvalue can't be moved from.\n     ///\n@@ -175,7 +175,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n     fn finalize(self) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<MoveError<'tcx>>)> {\n         debug!(\"{}\", {\n             debug!(\"moves for {:?}:\", self.mir.span);\n@@ -197,11 +197,11 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     }\n }\n \n-pub(super) fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n-                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     param_env: ty::ParamEnv<'tcx>)\n-                                     -> Result<MoveData<'tcx>,\n-                                               (MoveData<'tcx>, Vec<MoveError<'tcx>>)> {\n+pub(super) fn gather_moves<'a, 'gcx, 'tcx>(mir: &Mir<'tcx>,\n+                                           tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                           param_env: ty::ParamEnv<'gcx>)\n+                                           -> Result<MoveData<'tcx>,\n+                                                     (MoveData<'tcx>, Vec<MoveError<'tcx>>)> {\n     let mut builder = MoveDataBuilder::new(mir, tcx, param_env);\n \n     for (bb, block) in mir.basic_blocks().iter_enumerated() {\n@@ -220,7 +220,7 @@ pub(super) fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,\n     builder.finalize()\n }\n \n-impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n     fn gather_statement(&mut self, loc: Location, stmt: &Statement<'tcx>) {\n         debug!(\"gather_statement({:?}, {:?})\", loc, stmt);\n         (Gatherer { builder: self, loc }).gather_statement(stmt);\n@@ -232,12 +232,12 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     }\n }\n \n-struct Gatherer<'b, 'a: 'b, 'tcx: 'a> {\n-    builder: &'b mut MoveDataBuilder<'a, 'tcx>,\n+struct Gatherer<'b, 'a: 'b, 'gcx: 'tcx, 'tcx: 'a> {\n+    builder: &'b mut MoveDataBuilder<'a, 'gcx, 'tcx>,\n     loc: Location,\n }\n \n-impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n+impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n     fn gather_statement(&mut self, stmt: &Statement<'tcx>) {\n         match stmt.kind {\n             StatementKind::Assign(ref lval, ref rval) => {\n@@ -352,8 +352,10 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n         debug!(\"gather_move({:?}, {:?})\", self.loc, lval);\n \n         let tcx = self.builder.tcx;\n+        let gcx = tcx.global_tcx();\n         let lv_ty = lval.ty(self.builder.mir, tcx).to_ty(tcx);\n-        if !lv_ty.moves_by_default(tcx, self.builder.param_env, DUMMY_SP) {\n+        let erased_ty = gcx.lift(&tcx.erase_regions(&lv_ty)).unwrap();\n+        if !erased_ty.moves_by_default(gcx, self.builder.param_env, DUMMY_SP) {\n             debug!(\"gather_move({:?}, {:?}) - {:?} is Copy. skipping\", self.loc, lval, lv_ty);\n             return\n         }"}, {"sha": "5bfecd01aaa822c809175a865355d2fa56628daf", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -256,10 +256,10 @@ impl<'tcx> MoveError<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MoveData<'tcx> {\n+impl<'a, 'gcx, 'tcx> MoveData<'tcx> {\n     pub fn gather_moves(mir: &Mir<'tcx>,\n-                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        param_env: ty::ParamEnv<'tcx>)\n+                        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                        param_env: ty::ParamEnv<'gcx>)\n                         -> Result<Self, (Self, Vec<MoveError<'tcx>>)> {\n         builder::gather_moves(mir, tcx, param_env)\n     }"}, {"sha": "b72823dff2bdc7f834d3c40c8bce2e34d46baf69", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -18,13 +18,14 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n-#![feature(core_intrinsics)]\n #![feature(i128_type)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(placement_in_syntax)]\n #![feature(collection_placement)]\n #![feature(nonzero)]\n+#![feature(underscore_lifetimes)]\n \n #[macro_use]\n extern crate bitflags;"}, {"sha": "94da1f31a96b2a3a50f866141bd29d9dbc4d026f", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -83,7 +83,7 @@ fn find_dead_unwinds<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     id: ast::NodeId,\n-    env: &MoveDataParamEnv<'tcx>)\n+    env: &MoveDataParamEnv<'tcx, 'tcx>)\n     -> IdxSetBuf<BasicBlock>\n {\n     debug!(\"find_dead_unwinds({:?})\", mir.span);\n@@ -146,7 +146,7 @@ impl InitializationData {\n     fn apply_location<'a,'tcx>(&mut self,\n                                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                mir: &Mir<'tcx>,\n-                               env: &MoveDataParamEnv<'tcx>,\n+                               env: &MoveDataParamEnv<'tcx, 'tcx>,\n                                loc: Location)\n     {\n         drop_flag_effects_for_location(tcx, mir, env, loc, |path, df| {\n@@ -280,9 +280,9 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n-    env: &'a MoveDataParamEnv<'tcx>,\n-    flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n-    flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>,\n+    env: &'a MoveDataParamEnv<'tcx, 'tcx>,\n+    flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx, 'tcx>>,\n+    flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx, 'tcx>>,\n     drop_flags: FxHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n }"}, {"sha": "52a50333f4577d0d9d6ad1cf663b16f676a7bc96", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -68,7 +68,7 @@ use rustc::mir::visit::{LvalueContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, GeneratorInterior};\n use rustc::ty::subst::{Kind, Substs};\n use util::dump_mir;\n-use util::liveness;\n+use util::liveness::{self, LivenessMode};\n use rustc_const_math::ConstInt;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n@@ -348,7 +348,10 @@ fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ignored.visit_mir(mir);\n \n     let mut set = liveness::LocalSet::new_empty(mir.local_decls.len());\n-    let liveness = liveness::liveness_of_locals(mir);\n+    let liveness = liveness::liveness_of_locals(mir, LivenessMode {\n+        include_regular_use: true,\n+        include_drops: true,\n+    });\n     liveness::dump_mir(tcx, \"generator_liveness\", source, mir, &liveness);\n \n     let mut storage_liveness_map = HashMap::new();"}, {"sha": "a7570c610d8d34a1b07f0f6e897bd9f1d2c6612f", "filename": "src/librustc_mir/transform/nll/constraint_generation.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,269 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::mir::{BasicBlock, BorrowKind, Location, Lvalue, Mir, Rvalue, Statement, StatementKind};\n+use rustc::mir::transform::MirSource;\n+use rustc::mir::visit::Visitor;\n+use rustc::mir::Lvalue::Projection;\n+use rustc::mir::{LvalueProjection, ProjectionElem};\n+use rustc::infer::InferCtxt;\n+use rustc::traits::{self, ObligationCause};\n+use rustc::ty::{self, Ty};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::util::common::ErrorReported;\n+use rustc_data_structures::fx::FxHashSet;\n+use syntax::codemap::DUMMY_SP;\n+\n+use super::subtype;\n+use super::LivenessResults;\n+use super::ToRegionIndex;\n+use super::region_infer::RegionInferenceContext;\n+\n+pub(super) fn generate_constraints<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    regioncx: &mut RegionInferenceContext,\n+    mir: &Mir<'tcx>,\n+    mir_source: MirSource,\n+    liveness: &LivenessResults,\n+) {\n+    ConstraintGeneration {\n+        infcx,\n+        regioncx,\n+        mir,\n+        liveness,\n+        mir_source,\n+    }.add_constraints();\n+}\n+\n+struct ConstraintGeneration<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    regioncx: &'cx mut RegionInferenceContext,\n+    mir: &'cx Mir<'tcx>,\n+    liveness: &'cx LivenessResults,\n+    mir_source: MirSource,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n+    fn add_constraints(&mut self) {\n+        self.add_liveness_constraints();\n+        self.add_borrow_constraints();\n+    }\n+\n+    /// Liveness constraints:\n+    ///\n+    /// > If a variable V is live at point P, then all regions R in the type of V\n+    /// > must include the point P.\n+    fn add_liveness_constraints(&mut self) {\n+        debug!(\"add_liveness_constraints()\");\n+        for bb in self.mir.basic_blocks().indices() {\n+            debug!(\"add_liveness_constraints: bb={:?}\", bb);\n+\n+            self.liveness\n+                .regular\n+                .simulate_block(self.mir, bb, |location, live_locals| {\n+                    for live_local in live_locals.iter() {\n+                        let live_local_ty = self.mir.local_decls[live_local].ty;\n+                        self.add_regular_live_constraint(live_local_ty, location);\n+                    }\n+                });\n+\n+            self.liveness\n+                .drop\n+                .simulate_block(self.mir, bb, |location, live_locals| {\n+                    for live_local in live_locals.iter() {\n+                        let live_local_ty = self.mir.local_decls[live_local].ty;\n+                        self.add_drop_live_constraint(live_local_ty, location);\n+                    }\n+                });\n+        }\n+    }\n+\n+    /// Some variable with type `live_ty` is \"regular live\" at\n+    /// `location` -- i.e., it may be used later. This means that all\n+    /// regions appearing in the type `live_ty` must be live at\n+    /// `location`.\n+    fn add_regular_live_constraint<T>(&mut self, live_ty: T, location: Location)\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"add_regular_live_constraint(live_ty={:?}, location={:?})\",\n+            live_ty,\n+            location\n+        );\n+\n+        self.infcx\n+            .tcx\n+            .for_each_free_region(&live_ty, |live_region| {\n+                let vid = live_region.to_region_index();\n+                self.regioncx.add_live_point(vid, location);\n+            });\n+    }\n+\n+    /// Some variable with type `live_ty` is \"drop live\" at `location`\n+    /// -- i.e., it may be dropped later. This means that *some* of\n+    /// the regions in its type must be live at `location`. The\n+    /// precise set will depend on the dropck constraints, and in\n+    /// particular this takes `#[may_dangle]` into account.\n+    fn add_drop_live_constraint(&mut self, dropped_ty: Ty<'tcx>, location: Location) {\n+        debug!(\n+            \"add_drop_live_constraint(dropped_ty={:?}, location={:?})\",\n+            dropped_ty,\n+            location\n+        );\n+\n+        let tcx = self.infcx.tcx;\n+        let mut types = vec![(dropped_ty, 0)];\n+        let mut known = FxHashSet();\n+        while let Some((ty, depth)) = types.pop() {\n+            let span = DUMMY_SP; // FIXME\n+            let result = match tcx.dtorck_constraint_for_ty(span, dropped_ty, depth, ty) {\n+                Ok(result) => result,\n+                Err(ErrorReported) => {\n+                    continue;\n+                }\n+            };\n+\n+            let ty::DtorckConstraint {\n+                outlives,\n+                dtorck_types,\n+            } = result;\n+\n+            // All things in the `outlives` array may be touched by\n+            // the destructor and must be live at this point.\n+            for outlive in outlives {\n+                if let Some(ty) = outlive.as_type() {\n+                    self.add_regular_live_constraint(ty, location);\n+                } else if let Some(r) = outlive.as_region() {\n+                    self.add_regular_live_constraint(r, location);\n+                } else {\n+                    bug!()\n+                }\n+            }\n+\n+            // However, there may also be some types that\n+            // `dtorck_constraint_for_ty` could not resolve (e.g.,\n+            // associated types and parameters). We need to normalize\n+            // associated types here and possibly recursively process.\n+            let def_id = tcx.hir.local_def_id(self.mir_source.item_id());\n+            let param_env = self.infcx.tcx.param_env(def_id);\n+            for ty in dtorck_types {\n+                // FIXME -- I think that this may disregard some region obligations\n+                // or something. Do we care? -nmatsakis\n+                let cause = ObligationCause::dummy();\n+                match traits::fully_normalize(self.infcx, cause, param_env, &ty) {\n+                    Ok(ty) => match ty.sty {\n+                        ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n+                            self.add_regular_live_constraint(ty, location);\n+                        }\n+\n+                        _ => if known.insert(ty) {\n+                            types.push((ty, depth + 1));\n+                        },\n+                    },\n+\n+                    Err(errors) => {\n+                        self.infcx.report_fulfillment_errors(&errors, None);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn add_borrow_constraints(&mut self) {\n+        self.visit_mir(self.mir);\n+    }\n+\n+    fn add_borrow_constraint(\n+        &mut self,\n+        location: Location,\n+        destination_lv: &Lvalue<'tcx>,\n+        borrow_region: ty::Region<'tcx>,\n+        _borrow_kind: BorrowKind,\n+        _borrowed_lv: &Lvalue<'tcx>,\n+    ) {\n+        let tcx = self.infcx.tcx;\n+        let destination_ty = destination_lv.ty(self.mir, tcx).to_ty(tcx);\n+\n+        let destination_region = match destination_ty.sty {\n+            ty::TyRef(r, _) => r,\n+            _ => bug!()\n+        };\n+\n+        self.regioncx.add_outlives(borrow_region.to_region_index(),\n+                                   destination_region.to_region_index(),\n+                                   location.successor_within_block());\n+    }\n+\n+    fn add_reborrow_constraint(\n+        &mut self,\n+        location: Location,\n+        borrow_region: ty::Region<'tcx>,\n+        borrowed_lv: &Lvalue<'tcx>,\n+    ) {\n+        if let Projection(ref proj) = *borrowed_lv {\n+            let LvalueProjection { ref base, ref elem } = **proj;\n+\n+            if let ProjectionElem::Deref = *elem {\n+                let tcx = self.infcx.tcx;\n+                let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n+                let base_sty = &base_ty.sty;\n+\n+                if let ty::TyRef(base_region, ty::TypeAndMut{ ty: _, mutbl }) = *base_sty {\n+                    match mutbl {\n+                        hir::Mutability::MutImmutable => { },\n+\n+                        hir::Mutability::MutMutable => {\n+                            self.add_reborrow_constraint(location, borrow_region, base);\n+                        },\n+                    }\n+\n+                    self.regioncx.add_outlives(base_region.to_region_index(),\n+                                               borrow_region.to_region_index(),\n+                                               location.successor_within_block());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cx, 'gcx, 'tcx> {\n+    fn visit_statement(&mut self,\n+                       block: BasicBlock,\n+                       statement: &Statement<'tcx>,\n+                       location: Location) {\n+\n+        debug!(\"visit_statement(statement={:?}, location={:?})\", statement, location);\n+\n+        // Look for a statement like:\n+        //\n+        //     D = & L\n+        //\n+        // where D is the path to which we are assigning, and\n+        // L is the path that is borrowed.\n+        if let StatementKind::Assign(ref destination_lv, ref rv) = statement.kind {\n+            if let Rvalue::Ref(region, bk, ref borrowed_lv) = *rv {\n+                self.add_borrow_constraint(location, destination_lv, region, bk, borrowed_lv);\n+                self.add_reborrow_constraint(location, region, borrowed_lv);\n+            }\n+\n+            let tcx = self.infcx.tcx;\n+            let destination_ty = destination_lv.ty(self.mir, tcx).to_ty(tcx);\n+            let rv_ty = rv.ty(self.mir, tcx);\n+\n+            for (a, b) in subtype::outlives_pairs(tcx, rv_ty, destination_ty) {\n+                self.regioncx.add_outlives(a, b, location.successor_within_block());\n+            }\n+        }\n+\n+        self.super_statement(block, statement, location);\n+    }\n+}"}, {"sha": "d4938dc40bf25689463cedc6c22541944c29adb3", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 174, "deletions": 145, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -8,169 +8,150 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::infer::InferenceContext;\n-use rustc::ty::TypeFoldable;\n-use rustc::ty::subst::{Kind, Substs};\n-use rustc::ty::{Ty, TyCtxt, ClosureSubsts, RegionVid, RegionKind};\n-use rustc::mir::{Mir, Location, Rvalue, BasicBlock, Statement, StatementKind};\n-use rustc::mir::visit::{MutVisitor, Lookup};\n-use rustc::mir::transform::{MirPass, MirSource};\n-use rustc::infer::{self as rustc_infer, InferCtxt};\n-use rustc::util::nodemap::FxHashSet;\n-use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n-use syntax_pos::DUMMY_SP;\n-use std::collections::HashMap;\n+use rustc::ty::{self, RegionKind};\n+use rustc::mir::{Location, Mir};\n+use rustc::mir::transform::MirSource;\n+use rustc::infer::InferCtxt;\n+use rustc::util::nodemap::FxHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n+use std::collections::BTreeSet;\n use std::fmt;\n+use util::liveness::{self, LivenessMode, LivenessResult, LocalSet};\n \n use util as mir_util;\n use self::mir_util::PassWhere;\n \n-mod infer;\n-\n-#[allow(dead_code)]\n-struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    lookup_map: HashMap<RegionVid, Lookup>,\n-    regions: IndexVec<RegionIndex, Region>,\n-    #[allow(dead_code)]\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+mod constraint_generation;\n+mod subtype;\n+\n+pub(crate) mod region_infer;\n+use self::region_infer::RegionInferenceContext;\n+\n+mod renumber;\n+\n+/// Computes the (non-lexical) regions from the input MIR.\n+///\n+/// This may result in errors being reported.\n+pub fn compute_regions<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    source: MirSource,\n+    mir: &mut Mir<'tcx>,\n+) -> RegionInferenceContext {\n+    // Replace all regions with fresh inference variables.\n+    let num_region_variables = renumber::renumber_mir(infcx, mir);\n+\n+    // Compute what is live where.\n+    let liveness = &LivenessResults {\n+        regular: liveness::liveness_of_locals(\n+            &mir,\n+            LivenessMode {\n+                include_regular_use: true,\n+                include_drops: false,\n+            },\n+        ),\n+\n+        drop: liveness::liveness_of_locals(\n+            &mir,\n+            LivenessMode {\n+                include_regular_use: false,\n+                include_drops: true,\n+            },\n+        ),\n+    };\n+\n+    // Create the region inference context, generate the constraints,\n+    // and then solve them.\n+    let mut regioncx = RegionInferenceContext::new(num_region_variables);\n+    constraint_generation::generate_constraints(infcx, &mut regioncx, &mir, source, liveness);\n+    let errors = regioncx.solve(infcx, &mir);\n+\n+    assert!(errors.is_empty(), \"FIXME: report region inference failures\");\n+\n+    // Dump MIR results into a file, if that is enabled. This let us\n+    // write unit-tests.\n+    dump_mir_results(infcx, liveness, source, &mir, &regioncx);\n+\n+    regioncx\n }\n \n-impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        NLLVisitor {\n-            infcx,\n-            lookup_map: HashMap::new(),\n-            regions: IndexVec::new(),\n-        }\n-    }\n-\n-    pub fn into_results(self) -> (HashMap<RegionVid, Lookup>, IndexVec<RegionIndex, Region>) {\n-        (self.lookup_map, self.regions)\n-    }\n-\n-    fn renumber_regions<T>(&mut self, value: &T) -> T where T: TypeFoldable<'tcx> {\n-        self.infcx.tcx.fold_regions(value, &mut false, |_region, _depth| {\n-            self.regions.push(Region::default());\n-            self.infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n-        })\n-    }\n-\n-    fn store_region(&mut self, region: &RegionKind, lookup: Lookup) {\n-        if let RegionKind::ReVar(rid) = *region {\n-            self.lookup_map.entry(rid).or_insert(lookup);\n-        }\n-    }\n-\n-    fn store_ty_regions(&mut self, ty: &Ty<'tcx>, lookup: Lookup) {\n-        for region in ty.regions() {\n-            self.store_region(region, lookup);\n-        }\n-    }\n-\n-    fn store_kind_regions(&mut self, kind: &'tcx Kind, lookup: Lookup) {\n-        if let Some(ty) = kind.as_type() {\n-            self.store_ty_regions(&ty, lookup);\n-        } else if let Some(region) = kind.as_region() {\n-            self.store_region(region, lookup);\n-        }\n-    }\n+struct LivenessResults {\n+    regular: LivenessResult,\n+    drop: LivenessResult,\n }\n \n-impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n-    fn visit_ty(&mut self, ty: &mut Ty<'tcx>, lookup: Lookup) {\n-        let old_ty = *ty;\n-        *ty = self.renumber_regions(&old_ty);\n-        self.store_ty_regions(ty, lookup);\n-    }\n-\n-    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, location: Location) {\n-        *substs = self.renumber_regions(&{*substs});\n-        let lookup = Lookup::Loc(location);\n-        for kind in *substs {\n-            self.store_kind_regions(kind, lookup);\n-        }\n+fn dump_mir_results<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    liveness: &LivenessResults,\n+    source: MirSource,\n+    mir: &Mir<'tcx>,\n+    regioncx: &RegionInferenceContext,\n+) {\n+    if !mir_util::dump_enabled(infcx.tcx, \"nll\", source) {\n+        return;\n     }\n \n-    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n-        match *rvalue {\n-            Rvalue::Ref(ref mut r, _, _) => {\n-                let old_r = *r;\n-                *r = self.renumber_regions(&old_r);\n-                let lookup = Lookup::Loc(location);\n-                self.store_region(r, lookup);\n-            }\n-            Rvalue::Use(..) |\n-            Rvalue::Repeat(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::Cast(..) |\n-            Rvalue::BinaryOp(..) |\n-            Rvalue::CheckedBinaryOp(..) |\n-            Rvalue::UnaryOp(..) |\n-            Rvalue::Discriminant(..) |\n-            Rvalue::NullaryOp(..) |\n-            Rvalue::Aggregate(..) => {\n-                // These variants don't contain regions.\n+    let regular_liveness_per_location: FxHashMap<_, _> = mir.basic_blocks()\n+        .indices()\n+        .flat_map(|bb| {\n+            let mut results = vec![];\n+            liveness\n+                .regular\n+                .simulate_block(&mir, bb, |location, local_set| {\n+                    results.push((location, local_set.clone()));\n+                });\n+            results\n+        })\n+        .collect();\n+\n+    let drop_liveness_per_location: FxHashMap<_, _> = mir.basic_blocks()\n+        .indices()\n+        .flat_map(|bb| {\n+            let mut results = vec![];\n+            liveness\n+                .drop\n+                .simulate_block(&mir, bb, |location, local_set| {\n+                    results.push((location, local_set.clone()));\n+                });\n+            results\n+        })\n+        .collect();\n+\n+    mir_util::dump_mir(infcx.tcx, None, \"nll\", &0, source, mir, |pass_where, out| {\n+        match pass_where {\n+            // Before the CFG, dump out the values for each region variable.\n+            PassWhere::BeforeCFG => for region in regioncx.regions() {\n+                writeln!(\n+                    out,\n+                    \"| {:?}: {:?}\",\n+                    region,\n+                    regioncx.region_value(region)\n+                )?;\n+            },\n+\n+            // Before each basic block, dump out the values\n+            // that are live on entry to the basic block.\n+            PassWhere::BeforeBlock(bb) => {\n+                let s = live_variable_set(&liveness.regular.ins[bb], &liveness.drop.ins[bb]);\n+                writeln!(out, \"    | Live variables on entry to {:?}: {}\", bb, s)?;\n             }\n-        }\n-        self.super_rvalue(rvalue, location);\n-    }\n \n-    fn visit_closure_substs(&mut self,\n-                            substs: &mut ClosureSubsts<'tcx>,\n-                            location: Location) {\n-        *substs = self.renumber_regions(substs);\n-        let lookup = Lookup::Loc(location);\n-        for kind in substs.substs {\n-            self.store_kind_regions(kind, lookup);\n-        }\n-    }\n-\n-    fn visit_statement(&mut self,\n-                       block: BasicBlock,\n-                       statement: &mut Statement<'tcx>,\n-                       location: Location) {\n-        if let StatementKind::EndRegion(_) = statement.kind {\n-            statement.kind = StatementKind::Nop;\n-        }\n-        self.super_statement(block, statement, location);\n-    }\n-}\n-\n-// MIR Pass for non-lexical lifetimes\n-pub struct NLL;\n+            PassWhere::InCFG(location) => {\n+                let s = live_variable_set(\n+                    &regular_liveness_per_location[&location],\n+                    &drop_liveness_per_location[&location],\n+                );\n+                writeln!(out, \"            | Live variables at {:?}: {}\", location, s)?;\n+            }\n \n-impl MirPass for NLL {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          source: MirSource,\n-                          mir: &mut Mir<'tcx>) {\n-        if !tcx.sess.opts.debugging_opts.nll {\n-            return;\n+            PassWhere::AfterCFG => {}\n         }\n-\n-        tcx.infer_ctxt().enter(|infcx| {\n-            // Clone mir so we can mutate it without disturbing the rest of the compiler\n-            let mut renumbered_mir = mir.clone();\n-            let mut visitor = NLLVisitor::new(&infcx);\n-            visitor.visit_mir(&mut renumbered_mir);\n-            mir_util::dump_mir(tcx, None, \"nll\", &0, source, mir, |pass_where, out| {\n-                if let PassWhere::BeforeCFG = pass_where {\n-                    for (index, value) in visitor.regions.iter_enumerated() {\n-                        writeln!(out, \"// R{:03}: {:?}\", index.0, value)?;\n-                    }\n-                }\n-                Ok(())\n-            });\n-            let (_lookup_map, regions) = visitor.into_results();\n-            let mut inference_context = InferenceContext::new(regions);\n-            inference_context.solve(&infcx, &renumbered_mir);\n-        })\n-    }\n+        Ok(())\n+    });\n }\n \n #[derive(Clone, Default, PartialEq, Eq)]\n pub struct Region {\n-    points: FxHashSet<Location>,\n+    points: BTreeSet<Location>,\n }\n \n impl fmt::Debug for Region {\n@@ -189,4 +170,52 @@ impl Region {\n     }\n }\n \n-newtype_index!(RegionIndex);\n+newtype_index!(RegionIndex {\n+    DEBUG_FORMAT = \"'_#{}r\",\n+});\n+\n+/// Right now, we piggy back on the `ReVar` to store our NLL inference\n+/// regions. These are indexed with `RegionIndex`. This method will\n+/// assert that the region is a `ReVar` and convert the internal index\n+/// into a `RegionIndex`. This is reasonable because in our MIR we\n+/// replace all free regions with inference variables.\n+pub trait ToRegionIndex {\n+    fn to_region_index(&self) -> RegionIndex;\n+}\n+\n+impl ToRegionIndex for RegionKind {\n+    fn to_region_index(&self) -> RegionIndex {\n+        if let &ty::ReVar(vid) = self {\n+            RegionIndex::new(vid.index as usize)\n+        } else {\n+            bug!(\"region is not an ReVar: {:?}\", self)\n+        }\n+    }\n+}\n+\n+fn live_variable_set(regular: &LocalSet, drops: &LocalSet) -> String {\n+    // sort and deduplicate:\n+    let all_locals: BTreeSet<_> = regular.iter().chain(drops.iter()).collect();\n+\n+    // construct a string with each local, including `(drop)` if it is\n+    // only dropped, versus a regular use.\n+    let mut string = String::new();\n+    for local in all_locals {\n+        string.push_str(&format!(\"{:?}\", local));\n+\n+        if !regular.contains(&local) {\n+            assert!(drops.contains(&local));\n+            string.push_str(\" (drop)\");\n+        }\n+\n+        string.push_str(\", \");\n+    }\n+\n+    let len = if string.is_empty() {\n+        0\n+    } else {\n+        string.len() - 2\n+    };\n+\n+    format!(\"[{}]\", &string[..len])\n+}"}, {"sha": "c23d73e784ae9d04b4325e244feab9f66d95b5ef", "filename": "src/librustc_mir/transform/nll/region_infer.rs", "status": "renamed", "additions": 64, "deletions": 48, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -12,63 +12,80 @@ use super::{Region, RegionIndex};\n use std::mem;\n use rustc::infer::InferCtxt;\n use rustc::mir::{Location, Mir};\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashSet;\n \n-pub struct InferenceContext {\n-    definitions: IndexVec<RegionIndex, VarDefinition>,\n-    constraints: IndexVec<ConstraintIndex, Constraint>,\n-    errors: IndexVec<InferenceErrorIndex, InferenceError>,\n+pub struct RegionInferenceContext {\n+    /// Contains the definition for every region variable.  Region\n+    /// variables are identified by their index (`RegionIndex`). The\n+    /// definition contains information about where the region came\n+    /// from as well as its final inferred value.\n+    definitions: IndexVec<RegionIndex, RegionDefinition>,\n+\n+    /// The constraints we have accumulated and used during solving.\n+    constraints: Vec<Constraint>,\n+\n+    /// List of errors we have accumulated as we add constraints.\n+    /// After solving is done, this is replaced with an empty vector.\n+    errors: Vec<InferenceError>,\n }\n \n pub struct InferenceError {\n     pub constraint_point: Location,\n     pub name: (), // FIXME(nashenas88) RegionName\n }\n \n-newtype_index!(InferenceErrorIndex);\n-\n-struct VarDefinition {\n+#[derive(Default)]\n+struct RegionDefinition {\n     name: (), // FIXME(nashenas88) RegionName\n     value: Region,\n     capped: bool,\n }\n \n-impl VarDefinition {\n-    pub fn new(value: Region) -> Self {\n-        Self {\n-            name: (),\n-            value,\n-            capped: false,\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct Constraint {\n     sub: RegionIndex,\n     sup: RegionIndex,\n     point: Location,\n }\n \n-newtype_index!(ConstraintIndex);\n-\n-impl InferenceContext {\n-    pub fn new(values: IndexVec<RegionIndex, Region>) -> Self {\n+impl RegionInferenceContext {\n+    pub fn new(num_region_variables: usize) -> Self {\n         Self {\n-            definitions: values.into_iter().map(VarDefinition::new).collect(),\n-            constraints: IndexVec::new(),\n-            errors: IndexVec::new(),\n+            definitions: (0..num_region_variables)\n+                .map(|_| RegionDefinition::default())\n+                .collect(),\n+            constraints: Vec::new(),\n+            errors: Vec::new(),\n         }\n     }\n \n+\n+    /// Returns an iterator over all the region indices.\n+    pub fn regions(&self) -> impl Iterator<Item = RegionIndex> {\n+        self.definitions.indices()\n+    }\n+\n+    /// Returns the inferred value for the region `r`.\n+    ///\n+    /// Until `solve()` executes, this value is not particularly meaningful.\n+    pub fn region_value(&self, r: RegionIndex) -> &Region {\n+        &self.definitions[r].value\n+    }\n+\n+    /// Flags a region as being \"capped\" -- this means that if its\n+    /// value is required to grow as a result of some constraint\n+    /// (e.g., `add_live_point` or `add_outlives`), that indicates an\n+    /// error. This is used for the regions representing named\n+    /// lifetime parameters on a function: they get initialized to\n+    /// their complete value, and then \"capped\" so that they can no\n+    /// longer grow.\n     #[allow(dead_code)]\n-    pub fn cap_var(&mut self, v: RegionIndex) {\n+    pub(super) fn cap_var(&mut self, v: RegionIndex) {\n         self.definitions[v].capped = true;\n     }\n \n-    #[allow(dead_code)]\n-    pub fn add_live_point(&mut self, v: RegionIndex, point: Location) {\n+    pub(super) fn add_live_point(&mut self, v: RegionIndex, point: Location) {\n         debug!(\"add_live_point({:?}, {:?})\", v, point);\n         let definition = &mut self.definitions[v];\n         if definition.value.add_point(point) {\n@@ -81,22 +98,17 @@ impl InferenceContext {\n         }\n     }\n \n-    #[allow(dead_code)]\n-    pub fn add_outlives(&mut self, sup: RegionIndex, sub: RegionIndex, point: Location) {\n+    pub(super) fn add_outlives(&mut self, sup: RegionIndex, sub: RegionIndex, point: Location) {\n         debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n         self.constraints.push(Constraint { sup, sub, point });\n     }\n \n-    #[allow(dead_code)]\n-    pub fn region(&self, v: RegionIndex) -> &Region {\n-        &self.definitions[v].value\n-    }\n-\n-    pub fn solve<'a, 'gcx, 'tcx>(\n+    /// Perform region inference.\n+    pub(super) fn solve<'a, 'gcx, 'tcx>(\n         &mut self,\n         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n         mir: &'a Mir<'tcx>,\n-    ) -> IndexVec<InferenceErrorIndex, InferenceError>\n+    ) -> Vec<InferenceError>\n     where\n         'gcx: 'tcx + 'a,\n         'tcx: 'a,\n@@ -139,13 +151,12 @@ impl InferenceContext {\n             debug!(\"\\n\");\n         }\n \n-        mem::replace(&mut self.errors, IndexVec::new())\n+        mem::replace(&mut self.errors, Vec::new())\n     }\n }\n \n struct Dfs<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> {\n-    #[allow(dead_code)]\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    #[allow(dead_code)] infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n }\n \n@@ -183,17 +194,22 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> Dfs<'a, 'gcx, 'tcx> {\n \n             let block_data = &self.mir[p.block];\n             let successor_points = if p.statement_index < block_data.statements.len() {\n-                vec![Location {\n-                    statement_index: p.statement_index + 1,\n-                    ..p\n-                }]\n+                vec![\n+                    Location {\n+                        statement_index: p.statement_index + 1,\n+                        ..p\n+                    },\n+                ]\n             } else {\n-                block_data.terminator()\n+                block_data\n+                    .terminator()\n                     .successors()\n                     .iter()\n-                    .map(|&basic_block| Location {\n-                        statement_index: 0,\n-                        block: basic_block,\n+                    .map(|&basic_block| {\n+                        Location {\n+                            statement_index: 0,\n+                            block: basic_block,\n+                        }\n                     })\n                     .collect::<Vec<_>>()\n             };", "previous_filename": "src/librustc_mir/transform/nll/infer.rs"}, {"sha": "589179c2066854ef05e451a6967acb333eec0454", "filename": "src/librustc_mir/transform/nll/renumber.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Frenumber.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,132 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::TypeFoldable;\n+use rustc::ty::subst::{Kind, Substs};\n+use rustc::ty::{Ty, ClosureSubsts, RegionVid, RegionKind};\n+use rustc::mir::{Mir, Location, Rvalue, BasicBlock, Statement, StatementKind};\n+use rustc::mir::visit::{MutVisitor, Lookup};\n+use rustc::infer::{self as rustc_infer, InferCtxt};\n+use syntax_pos::DUMMY_SP;\n+use std::collections::HashMap;\n+\n+/// Replaces all free regions appearing in the MIR with fresh\n+/// inference variables, returning the number of variables created.\n+pub fn renumber_mir<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                    mir: &mut Mir<'tcx>)\n+                                    -> usize\n+{\n+    let mut visitor = NLLVisitor::new(infcx);\n+    visitor.visit_mir(mir);\n+    visitor.num_region_variables\n+}\n+\n+struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    lookup_map: HashMap<RegionVid, Lookup>,\n+    num_region_variables: usize,\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        NLLVisitor {\n+            infcx,\n+            lookup_map: HashMap::new(),\n+            num_region_variables: 0\n+        }\n+    }\n+\n+    fn renumber_regions<T>(&mut self, value: &T) -> T where T: TypeFoldable<'tcx> {\n+        self.infcx.tcx.fold_regions(value, &mut false, |_region, _depth| {\n+            self.num_region_variables += 1;\n+            self.infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n+        })\n+    }\n+\n+    fn store_region(&mut self, region: &RegionKind, lookup: Lookup) {\n+        if let RegionKind::ReVar(rid) = *region {\n+            self.lookup_map.entry(rid).or_insert(lookup);\n+        }\n+    }\n+\n+    fn store_ty_regions(&mut self, ty: &Ty<'tcx>, lookup: Lookup) {\n+        for region in ty.regions() {\n+            self.store_region(region, lookup);\n+        }\n+    }\n+\n+    fn store_kind_regions(&mut self, kind: &'tcx Kind, lookup: Lookup) {\n+        if let Some(ty) = kind.as_type() {\n+            self.store_ty_regions(&ty, lookup);\n+        } else if let Some(region) = kind.as_region() {\n+            self.store_region(region, lookup);\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n+    fn visit_ty(&mut self, ty: &mut Ty<'tcx>, lookup: Lookup) {\n+        let old_ty = *ty;\n+        *ty = self.renumber_regions(&old_ty);\n+        self.store_ty_regions(ty, lookup);\n+    }\n+\n+    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, location: Location) {\n+        *substs = self.renumber_regions(&{*substs});\n+        let lookup = Lookup::Loc(location);\n+        for kind in *substs {\n+            self.store_kind_regions(kind, lookup);\n+        }\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n+        match *rvalue {\n+            Rvalue::Ref(ref mut r, _, _) => {\n+                let old_r = *r;\n+                *r = self.renumber_regions(&old_r);\n+                let lookup = Lookup::Loc(location);\n+                self.store_region(r, lookup);\n+            }\n+            Rvalue::Use(..) |\n+            Rvalue::Repeat(..) |\n+            Rvalue::Len(..) |\n+            Rvalue::Cast(..) |\n+            Rvalue::BinaryOp(..) |\n+            Rvalue::CheckedBinaryOp(..) |\n+            Rvalue::UnaryOp(..) |\n+            Rvalue::Discriminant(..) |\n+            Rvalue::NullaryOp(..) |\n+            Rvalue::Aggregate(..) => {\n+                // These variants don't contain regions.\n+            }\n+        }\n+        self.super_rvalue(rvalue, location);\n+    }\n+\n+    fn visit_closure_substs(&mut self,\n+                            substs: &mut ClosureSubsts<'tcx>,\n+                            location: Location) {\n+        *substs = self.renumber_regions(substs);\n+        let lookup = Lookup::Loc(location);\n+        for kind in substs.substs {\n+            self.store_kind_regions(kind, lookup);\n+        }\n+    }\n+\n+    fn visit_statement(&mut self,\n+                       block: BasicBlock,\n+                       statement: &mut Statement<'tcx>,\n+                       location: Location) {\n+        if let StatementKind::EndRegion(_) = statement.kind {\n+            statement.kind = StatementKind::Nop;\n+        }\n+        self.super_statement(block, statement, location);\n+    }\n+}"}, {"sha": "953fc0eb733c2187159a690fde5025f9b7dfe5c7", "filename": "src/librustc_mir/transform/nll/subtype.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fsubtype.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::RegionIndex;\n+use transform::nll::ToRegionIndex;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+\n+pub fn outlives_pairs<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                      a: Ty<'tcx>,\n+                      b: Ty<'tcx>)\n+                      -> Vec<(RegionIndex, RegionIndex)>\n+{\n+    let mut subtype = Subtype::new(tcx);\n+    match subtype.relate(&a, &b) {\n+        Ok(_) => subtype.outlives_pairs,\n+\n+        Err(_) => bug!(\"Fail to relate a = {:?} and b = {:?}\", a, b)\n+    }\n+}\n+\n+struct Subtype<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    outlives_pairs: Vec<(RegionIndex, RegionIndex)>,\n+    ambient_variance: ty::Variance,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Subtype<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Subtype<'a, 'gcx, 'tcx> {\n+        Subtype {\n+            tcx,\n+            outlives_pairs: vec![],\n+            ambient_variance: ty::Covariant,\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Subtype<'a, 'gcx, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Subtype\" }\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.tcx }\n+    fn a_is_expected(&self) -> bool { true } // irrelevant\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             variance: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n+    {\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.ambient_variance.xform(variance);\n+\n+        let result = self.relate(a, b);\n+        self.ambient_variance = old_ambient_variance;\n+        result\n+    }\n+\n+    fn tys(&mut self, t: Ty<'tcx>, t2: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        relate::super_relate_tys(self, t, t2)\n+    }\n+\n+    fn regions(&mut self, r_a: ty::Region<'tcx>, r_b: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        let a = r_a.to_region_index();\n+        let b = r_b.to_region_index();\n+\n+        match self.ambient_variance {\n+            ty::Covariant => {\n+                self.outlives_pairs.push((b, a));\n+            },\n+\n+            ty::Invariant => {\n+                self.outlives_pairs.push((a, b));\n+                self.outlives_pairs.push((b, a));\n+            },\n+\n+            ty::Contravariant => {\n+                self.outlives_pairs.push((a, b));\n+            },\n+\n+            ty::Bivariant => {},\n+        }\n+\n+        Ok(r_a)\n+    }\n+\n+    fn binders<T>(&mut self, _a: &ty::Binder<T>, _b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'tcx>\n+    {\n+        unimplemented!();\n+    }\n+}"}, {"sha": "a4a7699abda59ace31aeaba96bb50adc9dbb3868", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -93,7 +93,7 @@ pub trait BorrowckErrors {\n                                       opt_via: &str,\n                                       old_loan_span: Span,\n                                       old_opt_via: &str,\n-                                      old_load_end_span:Span,\n+                                      old_load_end_span: Option<Span>,\n                                       o: Origin)\n                                       -> DiagnosticBuilder\n     {\n@@ -106,13 +106,17 @@ pub trait BorrowckErrors {\n             err.span_label(new_loan_span,\n                            format!(\"mutable borrow starts here in previous \\\n                                     iteration of loop{}\", opt_via));\n-            err.span_label(old_load_end_span, \"mutable borrow ends here\");\n+            if let Some(old_load_end_span) = old_load_end_span {\n+                err.span_label(old_load_end_span, \"mutable borrow ends here\");\n+            }\n         } else {\n             err.span_label(old_loan_span,\n                            format!(\"first mutable borrow occurs here{}\", old_opt_via));\n             err.span_label(new_loan_span,\n                            format!(\"second mutable borrow occurs here{}\", opt_via));\n-            err.span_label(old_load_end_span, \"first borrow ends here\");\n+            if let Some(old_load_end_span) = old_load_end_span {\n+                err.span_label(old_load_end_span, \"first borrow ends here\");\n+            }\n         }\n         err\n     }\n@@ -121,7 +125,7 @@ pub trait BorrowckErrors {\n                                               new_loan_span: Span,\n                                               desc: &str,\n                                               old_loan_span: Span,\n-                                              old_load_end_span: Span,\n+                                              old_load_end_span: Option<Span>,\n                                               o: Origin)\n                                               -> DiagnosticBuilder\n     {\n@@ -134,9 +138,11 @@ pub trait BorrowckErrors {\n         err.span_label(\n             new_loan_span,\n             \"second closure is constructed here\");\n-        err.span_label(\n-            old_load_end_span,\n-            \"borrow from first closure ends here\");\n+        if let Some(old_load_end_span) = old_load_end_span {\n+            err.span_label(\n+                old_load_end_span,\n+                \"borrow from first closure ends here\");\n+        }\n         err\n     }\n \n@@ -147,7 +153,7 @@ pub trait BorrowckErrors {\n                                              old_loan_span: Span,\n                                              noun_old: &str,\n                                              old_opt_via: &str,\n-                                             previous_end_span: Span,\n+                                             previous_end_span: Option<Span>,\n                                              o: Origin)\n                                              -> DiagnosticBuilder\n     {\n@@ -158,7 +164,9 @@ pub trait BorrowckErrors {\n                        format!(\"closure construction occurs here{}\", opt_via));\n         err.span_label(old_loan_span,\n                        format!(\"borrow occurs here{}\", old_opt_via));\n-        err.span_label(previous_end_span, \"borrow ends here\");\n+        if let Some(previous_end_span) = previous_end_span {\n+            err.span_label(previous_end_span, \"borrow ends here\");\n+        }\n         err\n     }\n \n@@ -169,7 +177,7 @@ pub trait BorrowckErrors {\n                                                  kind_new: &str,\n                                                  old_loan_span: Span,\n                                                  old_opt_via: &str,\n-                                                 previous_end_span: Span,\n+                                                 previous_end_span: Option<Span>,\n                                                  o: Origin)\n                                                  -> DiagnosticBuilder\n     {\n@@ -181,7 +189,9 @@ pub trait BorrowckErrors {\n                        format!(\"borrow occurs here{}\", opt_via));\n         err.span_label(old_loan_span,\n                        format!(\"closure construction occurs here{}\", old_opt_via));\n-        err.span_label(previous_end_span, \"borrow from closure ends here\");\n+        if let Some(previous_end_span) = previous_end_span {\n+            err.span_label(previous_end_span, \"borrow from closure ends here\");\n+        }\n         err\n     }\n \n@@ -194,7 +204,7 @@ pub trait BorrowckErrors {\n                                         noun_old: &str,\n                                         kind_old: &str,\n                                         msg_old: &str,\n-                                        old_load_end_span: Span,\n+                                        old_load_end_span: Option<Span>,\n                                         o: Origin)\n                                         -> DiagnosticBuilder\n     {\n@@ -203,7 +213,9 @@ pub trait BorrowckErrors {\n                          desc_new, msg_new, kind_new, noun_old, kind_old, msg_old, OGN=o);\n         err.span_label(span, format!(\"{} borrow occurs here{}\", kind_new, msg_new));\n         err.span_label(old_span, format!(\"{} borrow occurs here{}\", kind_old, msg_old));\n-        err.span_label(old_load_end_span, format!(\"{} borrow ends here\", kind_old));\n+        if let Some(old_load_end_span) = old_load_end_span {\n+            err.span_label(old_load_end_span, format!(\"{} borrow ends here\", kind_old));\n+        }\n         err\n     }\n \n@@ -429,7 +441,7 @@ pub trait BorrowckErrors {\n     }\n }\n \n-impl<'b, 'tcx, 'gcx> BorrowckErrors for TyCtxt<'b, 'tcx, 'gcx> {\n+impl<'b, 'gcx, 'tcx> BorrowckErrors for TyCtxt<'b, 'gcx, 'tcx> {\n     fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n                                                          sp: S,\n                                                          msg: &str,"}, {"sha": "a38d317b823b234959a6cf96b37734b082b66947", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -21,10 +21,10 @@ use rustc_data_structures::indexed_vec::Idx;\n use super::pretty::dump_mir_def_ids;\n \n /// Write a graphviz DOT graph of a list of MIRs.\n-pub fn write_mir_graphviz<'a, 'tcx, W>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       single: Option<DefId>,\n-                                       w: &mut W)\n-                                       -> io::Result<()>\n+pub fn write_mir_graphviz<'tcx, W>(tcx: TyCtxt<'_, '_, 'tcx>,\n+                                   single: Option<DefId>,\n+                                   w: &mut W)\n+                                   -> io::Result<()>\n     where W: Write\n {\n     for def_id in dump_mir_def_ids(tcx, single) {\n@@ -36,10 +36,10 @@ pub fn write_mir_graphviz<'a, 'tcx, W>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// Write a graphviz DOT graph of the MIR.\n-pub fn write_mir_fn_graphviz<'a, 'tcx, W>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        nodeid: NodeId,\n-                                        mir: &Mir,\n-                                        w: &mut W) -> io::Result<()>\n+pub fn write_mir_fn_graphviz<'tcx, W>(tcx: TyCtxt<'_, '_, 'tcx>,\n+                                      nodeid: NodeId,\n+                                      mir: &Mir,\n+                                      w: &mut W) -> io::Result<()>\n     where W: Write\n {\n     writeln!(w, \"digraph Mir_{} {{\", nodeid)?;\n@@ -137,11 +137,11 @@ fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result\n /// Write the graphviz DOT label for the overall graph. This is essentially a block of text that\n /// will appear below the graph, showing the type of the `fn` this MIR represents and the types of\n /// all the variables and temporaries.\n-fn write_graph_label<'a, 'tcx, W: Write>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                         nid: NodeId,\n-                                         mir: &Mir,\n-                                         w: &mut W)\n-                                         -> io::Result<()> {\n+fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                               nid: NodeId,\n+                                               mir: &Mir,\n+                                               w: &mut W)\n+                                               -> io::Result<()> {\n     write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.node_path_str(nid)))?;\n \n     // fn argument types."}, {"sha": "7658e49ea5ebd26666019a557de03ddb0c67acd8", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 279, "deletions": 107, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -35,48 +35,235 @@\n \n use rustc::mir::*;\n use rustc::mir::visit::{LvalueContext, Visitor};\n-use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::indexed_set::IdxSetBuf;\n-use util::pretty::{write_basic_block, dump_enabled, write_mir_intro};\n+use util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n use rustc::mir::transform::MirSource;\n use rustc::ty::item_path;\n-use std::path::{PathBuf, Path};\n+use std::path::{Path, PathBuf};\n use std::fs;\n use rustc::ty::TyCtxt;\n use std::io::{self, Write};\n \n pub type LocalSet = IdxSetBuf<Local>;\n \n+/// This gives the result of the liveness analysis at the boundary of\n+/// basic blocks. You can use `simulate_block` to obtain the\n+/// intra-block results.\n+pub struct LivenessResult {\n+    /// Liveness mode in use when these results were computed.\n+    pub mode: LivenessMode,\n+\n+    /// Live variables on entry to each basic block.\n+    pub ins: IndexVec<BasicBlock, LocalSet>,\n+\n+    /// Live variables on exit to each basic block. This is equal to\n+    /// the union of the `ins` for each successor.\n+    pub outs: IndexVec<BasicBlock, LocalSet>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct LivenessMode {\n+    /// If true, then we will consider \"regular uses\" of a variable to be live.\n+    /// For example, if the user writes `foo(x)`, then this is a regular use of\n+    /// the variable `x`.\n+    pub include_regular_use: bool,\n+\n+    /// If true, then we will consider (implicit) drops of a variable\n+    /// to be live.  For example, if the user writes `{ let x =\n+    /// vec![...]; .. }`, then the drop at the end of the block is an\n+    /// implicit drop.\n+    ///\n+    /// NB. Despite its name, a call like `::std::mem::drop(x)` is\n+    /// **not** considered a drop for this purposes, but rather a\n+    /// regular use.\n+    pub include_drops: bool,\n+}\n+\n+/// Compute which local variables are live within the given function\n+/// `mir`. The liveness mode `mode` determines what sorts of uses are\n+/// considered to make a variable live (e.g., do drops count?).\n+pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>, mode: LivenessMode) -> LivenessResult {\n+    let locals = mir.local_decls.len();\n+    let def_use: IndexVec<_, _> = mir.basic_blocks()\n+        .iter()\n+        .map(|b| block(mode, b, locals))\n+        .collect();\n+\n+    let mut ins: IndexVec<_, _> = mir.basic_blocks()\n+        .indices()\n+        .map(|_| LocalSet::new_empty(locals))\n+        .collect();\n+    let mut outs = ins.clone();\n+\n+    let mut changed = true;\n+    let mut bits = LocalSet::new_empty(locals);\n+    while changed {\n+        changed = false;\n+\n+        for b in mir.basic_blocks().indices().rev() {\n+            // outs[b] = \u222a {ins of successors}\n+            bits.clear();\n+            for &successor in mir.basic_blocks()[b].terminator().successors().into_iter() {\n+                bits.union(&ins[successor]);\n+            }\n+            outs[b].clone_from(&bits);\n+\n+            // bits = use \u222a (bits - def)\n+            def_use[b].apply(&mut bits);\n+\n+            // update bits on entry and flag if they have changed\n+            if ins[b] != bits {\n+                ins[b].clone_from(&bits);\n+                changed = true;\n+            }\n+        }\n+    }\n+\n+    LivenessResult { mode, ins, outs }\n+}\n+\n+impl LivenessResult {\n+    /// Walks backwards through the statements/terminator in the given\n+    /// basic block `block`.  At each point within `block`, invokes\n+    /// the callback `op` with the current location and the set of\n+    /// variables that are live on entry to that location.\n+    pub fn simulate_block<'tcx, OP>(&self, mir: &Mir<'tcx>, block: BasicBlock, mut callback: OP)\n+    where\n+        OP: FnMut(Location, &LocalSet),\n+    {\n+        let data = &mir[block];\n+\n+        // Get a copy of the bits on exit from the block.\n+        let mut bits = self.outs[block].clone();\n+\n+        // Start with the maximal statement index -- i.e., right before\n+        // the terminator executes.\n+        let mut statement_index = data.statements.len();\n+\n+        // Compute liveness right before terminator and invoke callback.\n+        let terminator_location = Location {\n+            block,\n+            statement_index,\n+        };\n+        let terminator_defs_uses = self.defs_uses(mir, terminator_location, &data.terminator);\n+        terminator_defs_uses.apply(&mut bits);\n+        callback(terminator_location, &bits);\n+\n+        // Compute liveness before each statement (in rev order) and invoke callback.\n+        for statement in data.statements.iter().rev() {\n+            statement_index -= 1;\n+            let statement_location = Location {\n+                block,\n+                statement_index,\n+            };\n+            let statement_defs_uses = self.defs_uses(mir, statement_location, statement);\n+            statement_defs_uses.apply(&mut bits);\n+            callback(statement_location, &bits);\n+        }\n+\n+        assert_eq!(bits, self.ins[block]);\n+    }\n+\n+    fn defs_uses<'tcx, V>(&self, mir: &Mir<'tcx>, location: Location, thing: &V) -> DefsUses\n+    where\n+        V: MirVisitable<'tcx>,\n+    {\n+        let locals = mir.local_decls.len();\n+        let mut visitor = DefsUsesVisitor {\n+            mode: self.mode,\n+            defs_uses: DefsUses {\n+                defs: LocalSet::new_empty(locals),\n+                uses: LocalSet::new_empty(locals),\n+            },\n+        };\n+\n+        // Visit the various parts of the basic block in reverse. If we go\n+        // forward, the logic in `add_def` and `add_use` would be wrong.\n+        thing.apply(location, &mut visitor);\n+\n+        visitor.defs_uses\n+    }\n+}\n+\n+struct DefsUsesVisitor {\n+    mode: LivenessMode,\n+    defs_uses: DefsUses,\n+}\n+\n #[derive(Eq, PartialEq, Clone)]\n-struct BlockInfo {\n+struct DefsUses {\n     defs: LocalSet,\n     uses: LocalSet,\n }\n \n-struct BlockInfoVisitor {\n-    pre_defs: LocalSet,\n-    defs: LocalSet,\n-    uses: LocalSet,\n+impl DefsUses {\n+    fn apply(&self, bits: &mut LocalSet) -> bool {\n+        bits.subtract(&self.defs) | bits.union(&self.uses)\n+    }\n+\n+    fn add_def(&mut self, index: Local) {\n+        // If it was used already in the block, remove that use\n+        // now that we found a definition.\n+        //\n+        // Example:\n+        //\n+        //     // Defs = {X}, Uses = {}\n+        //     X = 5\n+        //     // Defs = {}, Uses = {X}\n+        //     use(X)\n+        self.uses.remove(&index);\n+        self.defs.add(&index);\n+    }\n+\n+    fn add_use(&mut self, index: Local) {\n+        // Inverse of above.\n+        //\n+        // Example:\n+        //\n+        //     // Defs = {}, Uses = {X}\n+        //     use(X)\n+        //     // Defs = {X}, Uses = {}\n+        //     X = 5\n+        //     // Defs = {}, Uses = {X}\n+        //     use(X)\n+        self.defs.remove(&index);\n+        self.uses.add(&index);\n+    }\n }\n \n-impl<'tcx> Visitor<'tcx> for BlockInfoVisitor {\n-    fn visit_local(&mut self,\n-                   &local: &Local,\n-                   context: LvalueContext<'tcx>,\n-                   _: Location) {\n+impl<'tcx> Visitor<'tcx> for DefsUsesVisitor {\n+    fn visit_local(&mut self, &local: &Local, context: LvalueContext<'tcx>, _: Location) {\n         match context {\n+            ///////////////////////////////////////////////////////////////////////////\n+            // DEFS\n+\n             LvalueContext::Store |\n \n-            // We let Call defined the result in both the success and unwind cases.\n-            // This may not be right.\n+            // We let Call define the result in both the success and\n+            // unwind cases. This is not really correct, however it\n+            // does not seem to be observable due to the way that we\n+            // generate MIR. See the test case\n+            // `mir-opt/nll/liveness-call-subtlety.rs`. To do things\n+            // properly, we would apply the def in call only to the\n+            // input from the success path and not the unwind\n+            // path. -nmatsakis\n             LvalueContext::Call |\n \n             // Storage live and storage dead aren't proper defines, but we can ignore\n             // values that come before them.\n             LvalueContext::StorageLive |\n             LvalueContext::StorageDead => {\n-                self.defs.add(&local);\n+                self.defs_uses.add_def(local);\n             }\n+\n+            ///////////////////////////////////////////////////////////////////////////\n+            // REGULAR USES\n+            //\n+            // These are uses that occur *outside* of a drop. For the\n+            // purposes of NLL, these are special in that **all** the\n+            // lifetimes appearing in the variable must be live for each regular use.\n+\n             LvalueContext::Projection(..) |\n \n             // Borrows only consider their local used at the point of the borrow.\n@@ -87,124 +274,108 @@ impl<'tcx> Visitor<'tcx> for BlockInfoVisitor {\n \n             LvalueContext::Inspect |\n             LvalueContext::Consume |\n-            LvalueContext::Validate |\n+            LvalueContext::Validate => {\n+                if self.mode.include_regular_use {\n+                    self.defs_uses.add_use(local);\n+                }\n+            }\n+\n+            ///////////////////////////////////////////////////////////////////////////\n+            // DROP USES\n+            //\n+            // These are uses that occur in a DROP (a MIR drop, not a\n+            // call to `std::mem::drop()`). For the purposes of NLL,\n+            // uses in drop are special because `#[may_dangle]`\n+            // attributes can affect whether lifetimes must be live.\n \n-            // We consider drops to always be uses of locals.\n-            // Drop eloboration should be run before this analysis otherwise\n-            // the results might be too pessimistic.\n             LvalueContext::Drop => {\n-                // Ignore uses which are already defined in this block\n-                if !self.pre_defs.contains(&local) {\n-                    self.uses.add(&local);\n+                if self.mode.include_drops {\n+                    self.defs_uses.add_use(local);\n                 }\n             }\n         }\n     }\n }\n \n-fn block<'tcx>(b: &BasicBlockData<'tcx>, locals: usize) -> BlockInfo {\n-    let mut visitor = BlockInfoVisitor {\n-        pre_defs: LocalSet::new_empty(locals),\n-        defs: LocalSet::new_empty(locals),\n-        uses: LocalSet::new_empty(locals),\n+fn block<'tcx>(mode: LivenessMode, b: &BasicBlockData<'tcx>, locals: usize) -> DefsUses {\n+    let mut visitor = DefsUsesVisitor {\n+        mode,\n+        defs_uses: DefsUses {\n+            defs: LocalSet::new_empty(locals),\n+            uses: LocalSet::new_empty(locals),\n+        },\n     };\n \n-    let dummy_location = Location { block: BasicBlock::new(0), statement_index: 0 };\n+    let dummy_location = Location {\n+        block: BasicBlock::new(0),\n+        statement_index: 0,\n+    };\n \n-    for statement in &b.statements {\n+    // Visit the various parts of the basic block in reverse. If we go\n+    // forward, the logic in `add_def` and `add_use` would be wrong.\n+    visitor.visit_terminator(BasicBlock::new(0), b.terminator(), dummy_location);\n+    for statement in b.statements.iter().rev() {\n         visitor.visit_statement(BasicBlock::new(0), statement, dummy_location);\n-        visitor.pre_defs.union(&visitor.defs);\n     }\n-    visitor.visit_terminator(BasicBlock::new(0), b.terminator(), dummy_location);\n \n-    BlockInfo {\n-        defs: visitor.defs,\n-        uses: visitor.uses,\n-    }\n+    visitor.defs_uses\n }\n \n-// This gives the result of the liveness analysis at the boundary of basic blocks\n-pub struct LivenessResult {\n-    pub ins: IndexVec<BasicBlock, LocalSet>,\n-    pub outs: IndexVec<BasicBlock, LocalSet>,\n+trait MirVisitable<'tcx> {\n+    fn apply<V>(&self, location: Location, visitor: &mut V)\n+    where\n+        V: Visitor<'tcx>;\n }\n \n-pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>) -> LivenessResult {\n-    let locals = mir.local_decls.len();\n-    let def_use: IndexVec<_, _> = mir.basic_blocks().iter().map(|b| {\n-        block(b, locals)\n-    }).collect();\n-\n-    let copy = |from: &IndexVec<BasicBlock, LocalSet>, to: &mut IndexVec<BasicBlock, LocalSet>| {\n-        for (i, set) in to.iter_enumerated_mut() {\n-            set.clone_from(&from[i]);\n-        }\n-    };\n-\n-    let mut ins: IndexVec<_, _> = mir.basic_blocks()\n-        .indices()\n-        .map(|_| LocalSet::new_empty(locals)).collect();\n-    let mut outs = ins.clone();\n-\n-    let mut ins_ = ins.clone();\n-    let mut outs_ = outs.clone();\n-\n-    loop {\n-        copy(&ins, &mut ins_);\n-        copy(&outs, &mut outs_);\n-\n-        for b in mir.basic_blocks().indices().rev() {\n-            // out = \u222a {ins of successors}\n-            outs[b].clear();\n-            for &successor in mir.basic_blocks()[b].terminator().successors().into_iter() {\n-                outs[b].union(&ins[successor]);\n-            }\n-\n-            // in = use \u222a (out - def)\n-            ins[b].clone_from(&outs[b]);\n-            ins[b].subtract(&def_use[b].defs);\n-            ins[b].union(&def_use[b].uses);\n-        }\n-\n-        if ins_ == ins && outs_ == outs {\n-            break;\n-        }\n+impl<'tcx> MirVisitable<'tcx> for Statement<'tcx> {\n+    fn apply<V>(&self, location: Location, visitor: &mut V)\n+    where\n+        V: Visitor<'tcx>,\n+    {\n+        visitor.visit_statement(location.block, self, location)\n     }\n+}\n \n-    LivenessResult {\n-        ins,\n-        outs,\n+impl<'tcx> MirVisitable<'tcx> for Option<Terminator<'tcx>> {\n+    fn apply<V>(&self, location: Location, visitor: &mut V)\n+    where\n+        V: Visitor<'tcx>,\n+    {\n+        visitor.visit_terminator(location.block, self.as_ref().unwrap(), location)\n     }\n }\n \n-pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          pass_name: &str,\n-                          source: MirSource,\n-                          mir: &Mir<'tcx>,\n-                          result: &LivenessResult) {\n+pub fn dump_mir<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pass_name: &str,\n+    source: MirSource,\n+    mir: &Mir<'tcx>,\n+    result: &LivenessResult,\n+) {\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n     }\n-    let node_path = item_path::with_forced_impl_filename_line(|| { // see notes on #41697 below\n+    let node_path = item_path::with_forced_impl_filename_line(|| {\n+        // see notes on #41697 below\n         tcx.item_path_str(tcx.hir.local_def_id(source.item_id()))\n     });\n-    dump_matched_mir_node(tcx, pass_name, &node_path,\n-                          source, mir, result);\n+    dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, result);\n }\n \n-fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   pass_name: &str,\n-                                   node_path: &str,\n-                                   source: MirSource,\n-                                   mir: &Mir<'tcx>,\n-                                   result: &LivenessResult) {\n+fn dump_matched_mir_node<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pass_name: &str,\n+    node_path: &str,\n+    source: MirSource,\n+    mir: &Mir<'tcx>,\n+    result: &LivenessResult,\n+) {\n     let mut file_path = PathBuf::new();\n     if let Some(ref file_dir) = tcx.sess.opts.debugging_opts.dump_mir_dir {\n         let p = Path::new(file_dir);\n         file_path.push(p);\n     };\n-    let file_name = format!(\"rustc.node{}{}-liveness.mir\",\n-                            source.item_id(), pass_name);\n+    let file_name = format!(\"rustc.node{}{}-liveness.mir\", source.item_id(), pass_name);\n     file_path.push(&file_name);\n     let _ = fs::File::create(&file_path).and_then(|mut file| {\n         writeln!(file, \"// MIR local liveness analysis for `{}`\", node_path)?;\n@@ -216,16 +387,18 @@ fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n }\n \n-pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              src: MirSource,\n-                              mir: &Mir<'tcx>,\n-                              w: &mut Write,\n-                              result: &LivenessResult)\n-                              -> io::Result<()> {\n+pub fn write_mir_fn<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    src: MirSource,\n+    mir: &Mir<'tcx>,\n+    w: &mut Write,\n+    result: &LivenessResult,\n+) -> io::Result<()> {\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n         let print = |w: &mut Write, prefix, result: &IndexVec<BasicBlock, LocalSet>| {\n-            let live: Vec<String> = mir.local_decls.indices()\n+            let live: Vec<String> = mir.local_decls\n+                .indices()\n                 .filter(|i| result[block].contains(i))\n                 .map(|i| format!(\"{:?}\", i))\n                 .collect();\n@@ -242,4 +415,3 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     writeln!(w, \"}}\")?;\n     Ok(())\n }\n-"}, {"sha": "1d924175b2167dca4fd27ca849a2322b00f42059", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -56,13 +56,13 @@ pub enum PassWhere {\n /// - `substring1&substring2,...` -- `&`-separated list of substrings\n ///   that can appear in the pass-name or the `item_path_str` for the given\n ///   node-id. If any one of the substrings match, the data is dumped out.\n-pub fn dump_mir<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             pass_num: Option<(MirSuite, MirPassIndex)>,\n-                             pass_name: &str,\n-                             disambiguator: &Display,\n-                             source: MirSource,\n-                             mir: &Mir<'tcx>,\n-                             extra_data: F)\n+pub fn dump_mir<'a, 'gcx, 'tcx, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                   pass_num: Option<(MirSuite, MirPassIndex)>,\n+                                   pass_name: &str,\n+                                   disambiguator: &Display,\n+                                   source: MirSource,\n+                                   mir: &Mir<'tcx>,\n+                                   extra_data: F)\n where\n     F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n {\n@@ -77,10 +77,10 @@ where\n                           disambiguator, source, mir, extra_data);\n }\n \n-pub fn dump_enabled<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              pass_name: &str,\n-                              source: MirSource)\n-                              -> bool {\n+pub fn dump_enabled<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                    pass_name: &str,\n+                                    source: MirSource)\n+                                    -> bool {\n     let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n         None => return false,\n         Some(ref filters) => filters,\n@@ -101,14 +101,14 @@ pub fn dump_enabled<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // `item_path_str()` would otherwise trigger `type_of`, and this can\n // run while we are already attempting to evaluate `type_of`.\n \n-fn dump_matched_mir_node<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      pass_num: Option<(MirSuite, MirPassIndex)>,\n-                                      pass_name: &str,\n-                                      node_path: &str,\n-                                      disambiguator: &Display,\n-                                      source: MirSource,\n-                                      mir: &Mir<'tcx>,\n-                                      mut extra_data: F)\n+fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                            pass_num: Option<(MirSuite, MirPassIndex)>,\n+                                            pass_name: &str,\n+                                            node_path: &str,\n+                                            disambiguator: &Display,\n+                                            source: MirSource,\n+                                            mir: &Mir<'tcx>,\n+                                            mut extra_data: F)\n where\n     F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n {\n@@ -161,10 +161,10 @@ where\n }\n \n /// Write out a human-readable textual representation for the given MIR.\n-pub fn write_mir_pretty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  single: Option<DefId>,\n-                                  w: &mut Write)\n-                                  -> io::Result<()>\n+pub fn write_mir_pretty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                        single: Option<DefId>,\n+                                        w: &mut Write)\n+                                        -> io::Result<()>\n {\n     writeln!(w, \"// WARNING: This output format is intended for human consumers only\")?;\n     writeln!(w, \"// and is subject to change without notice. Knock yourself out.\")?;\n@@ -192,12 +192,12 @@ pub fn write_mir_pretty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Ok(())\n }\n \n-pub fn write_mir_fn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 src: MirSource,\n-                                 mir: &Mir<'tcx>,\n-                                 extra_data: &mut F,\n-                                 w: &mut Write)\n-                                 -> io::Result<()>\n+pub fn write_mir_fn<'a, 'gcx, 'tcx, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                       src: MirSource,\n+                                       mir: &Mir<'tcx>,\n+                                       extra_data: &mut F,\n+                                       w: &mut Write)\n+                                       -> io::Result<()>\n where\n     F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n {\n@@ -321,11 +321,11 @@ fn write_scope_tree(tcx: TyCtxt,\n \n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-pub fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             src: MirSource,\n-                             mir: &Mir,\n-                             w: &mut Write)\n-                             -> io::Result<()> {\n+pub fn write_mir_intro<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                       src: MirSource,\n+                                       mir: &Mir,\n+                                       w: &mut Write)\n+                                       -> io::Result<()> {\n     write_mir_sig(tcx, src, mir, w)?;\n     writeln!(w, \" {{\")?;\n "}, {"sha": "c02977f22ea4b3c500f58c1ed95355a7829edb98", "filename": "src/test/compile-fail/nll/loan_ends_mid_block_pair.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fcompile-fail%2Fnll%2Floan_ends_mid_block_pair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fcompile-fail%2Fnll%2Floan_ends_mid_block_pair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Floan_ends_mid_block_pair.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// compile-flags:-Zborrowck-mir -Znll\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+\n+\n+fn main() {\n+}\n+\n+fn nll_fail() {\n+    let mut data = ('a', 'b', 'c');\n+    let c = &mut data.0;\n+    capitalize(c);\n+    data.0 = 'e';\n+    //~^ ERROR (Ast) [E0506]\n+    //~| ERROR (Mir) [E0506]\n+    data.0 = 'f';\n+    //~^ ERROR (Ast) [E0506]\n+    //~| ERROR (Mir) [E0506]\n+    data.0 = 'g';\n+    //~^ ERROR (Ast) [E0506]\n+    //~| ERROR (Mir) [E0506]\n+    capitalize(c);\n+}\n+\n+fn nll_ok() {\n+    let mut data = ('a', 'b', 'c');\n+    let c = &mut data.0;\n+    capitalize(c);\n+    data.0 = 'e';\n+    //~^ ERROR (Ast) [E0506]\n+    data.0 = 'f';\n+    //~^ ERROR (Ast) [E0506]\n+    data.0 = 'g';\n+    //~^ ERROR (Ast) [E0506]\n+}\n+\n+fn capitalize(_: &mut char) {\n+}"}, {"sha": "5e3a003b54eb03a9ee9a0e1642e26dbaa23ebd3a", "filename": "src/test/compile-fail/nll/loan_ends_mid_block_vec.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fcompile-fail%2Fnll%2Floan_ends_mid_block_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fcompile-fail%2Fnll%2Floan_ends_mid_block_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Floan_ends_mid_block_vec.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// compile-flags:-Zborrowck-mir -Znll\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+\n+fn main() {\n+}\n+\n+fn nll_fail() {\n+    let mut data = vec!['a', 'b', 'c'];\n+    let slice = &mut data;\n+    capitalize(slice);\n+    data.push('d');\n+    //~^ ERROR (Ast) [E0499]\n+    //~| ERROR (Mir) [E0499]\n+    data.push('e');\n+    //~^ ERROR (Ast) [E0499]\n+    //~| ERROR (Mir) [E0499]\n+    data.push('f');\n+    //~^ ERROR (Ast) [E0499]\n+    //~| ERROR (Mir) [E0499]\n+    capitalize(slice);\n+}\n+\n+fn nll_ok() {\n+    let mut data = vec!['a', 'b', 'c'];\n+    let slice = &mut data;\n+    capitalize(slice);\n+    data.push('d');\n+    //~^ ERROR (Ast) [E0499]\n+    data.push('e');\n+    //~^ ERROR (Ast) [E0499]\n+    data.push('f');\n+    //~^ ERROR (Ast) [E0499]\n+}\n+\n+fn capitalize(_: &mut [char]) {\n+}"}, {"sha": "bec56982c57a19787dfac06ec894198624ae271f", "filename": "src/test/compile-fail/nll/region-ends-after-if-condition.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fcompile-fail%2Fnll%2Fregion-ends-after-if-condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fcompile-fail%2Fnll%2Fregion-ends-after-if-condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Fregion-ends-after-if-condition.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for liveness constraints: the region (`R1`) that appears\n+// in the type of `p` includes the points after `&v[0]` up to (but not\n+// including) the call to `use_x`. The `else` branch is not included.\n+\n+// compile-flags:-Zborrowck-mir -Znll\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+\n+struct MyStruct {\n+    field: String\n+}\n+\n+fn foo1() {\n+    let mut my_struct = MyStruct { field: format!(\"Hello\") };\n+\n+    let value = &my_struct.field;\n+    if value.is_empty() {\n+        my_struct.field.push_str(\"Hello, world!\");\n+        //~^ ERROR (Ast) [E0502]\n+    }\n+}\n+\n+fn foo2() {\n+    let mut my_struct = MyStruct { field: format!(\"Hello\") };\n+\n+    let value = &my_struct.field;\n+    if value.is_empty() {\n+        my_struct.field.push_str(\"Hello, world!\");\n+        //~^ ERROR (Ast) [E0502]\n+        //~| ERROR (Mir) [E0502]\n+    }\n+    drop(value);\n+}\n+\n+fn main() { }"}, {"sha": "6b287fd22720135bf20a3ec937cb0dde0dfea534", "filename": "src/test/compile-fail/nll/return_from_loop.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fcompile-fail%2Fnll%2Freturn_from_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fcompile-fail%2Fnll%2Freturn_from_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Freturn_from_loop.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for liveness constraints: the region (`R1`) that appears\n+// in the type of `p` includes the points after `&v[0]` up to (but not\n+// including) the call to `use_x`. The `else` branch is not included.\n+\n+// compile-flags:-Zborrowck-mir -Znll\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+\n+struct MyStruct {\n+    field: String\n+}\n+\n+fn main() {\n+}\n+\n+fn nll_fail() {\n+    let mut my_struct = MyStruct { field: format!(\"Hello\") };\n+\n+    let value = &mut my_struct.field;\n+    loop {\n+        my_struct.field.push_str(\"Hello, world!\");\n+        //~^ ERROR (Ast) [E0499]\n+        //~| ERROR (Mir) [E0499]\n+        value.len();\n+        return;\n+    }\n+}\n+\n+fn nll_ok() {\n+    let mut my_struct = MyStruct { field: format!(\"Hello\") };\n+\n+    let value = &mut my_struct.field;\n+    loop {\n+        my_struct.field.push_str(\"Hello, world!\");\n+        //~^ ERROR (Ast) [E0499]\n+        return;\n+    }\n+}"}, {"sha": "61dc1d206596178964190166a64b53fb4445401a", "filename": "src/test/mir-opt/end_region_destruction_extents_1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -133,11 +133,11 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n //         StorageLive(_3);\n //         StorageLive(_4);\n //         StorageLive(_5);\n-//         _5 = promoted1;\n+//         _5 = promoted[1];\n //         _4 = &'12ds (*_5);\n //         StorageLive(_7);\n //         StorageLive(_8);\n-//         _8 = promoted0;\n+//         _8 = promoted[0];\n //         _7 = &'10s (*_8);\n //         _3 = D1<'12ds, '10s>::{{constructor}}(_4, _7);\n //         EndRegion('10s);"}, {"sha": "873431505f544fb34a57cbf96a6b27b774358ea6", "filename": "src/test/mir-opt/nll/liveness-call-subtlety.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-call-subtlety.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll\n+\n+fn can_panic() -> Box<usize> {\n+    Box::new(44)\n+}\n+\n+fn main() {\n+    let mut x = Box::new(22);\n+    x = can_panic();\n+}\n+\n+// Check that:\n+// - `_1` is the variable corresponding to `x`\n+// and\n+// - `_1` is live when `can_panic` is called (because it may be dropped)\n+//\n+// END RUST SOURCE\n+// START rustc.node12.nll.0.mir\n+//    | Live variables on entry to bb0: []\n+//    bb0: {\n+//            | Live variables at bb0[0]: []\n+//        StorageLive(_1);\n+//            | Live variables at bb0[1]: []\n+//        StorageLive(_2);\n+//            | Live variables at bb0[2]: []\n+//        _2 = const 22usize;\n+//            | Live variables at bb0[3]: [_2]\n+//        _1 = const <std::boxed::Box<T>>::new(_2) -> bb1;\n+//    }\n+// END rustc.node12.nll.0.mir\n+// START rustc.node12.nll.0.mir\n+//    | Live variables on entry to bb1: [_1 (drop)]\n+//    bb1: {\n+//            | Live variables at bb1[0]: [_1 (drop)]\n+//        StorageDead(_2);\n+//            | Live variables at bb1[1]: [_1 (drop)]\n+//        StorageLive(_3);\n+//            | Live variables at bb1[2]: [_1 (drop)]\n+//        _3 = const can_panic() -> [return: bb2, unwind: bb4];\n+//    }\n+// END rustc.node12.nll.0.mir"}, {"sha": "96fd29dfe2fd9eb0ac3be46b68b9c391dc71a510", "filename": "src/test/mir-opt/nll/liveness-drop-intra-block.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-drop-intra-block.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll\n+\n+#![allow(warnings)]\n+\n+fn use_x(_: usize) -> bool { true }\n+\n+fn main() {\n+    let mut x = 22;\n+    loop {\n+        // Key point: `x` not live on entry to this basic block.\n+        x = 55;\n+        if use_x(x) { break; }\n+    }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node12.nll.0.mir\n+//    | Live variables on entry to bb1: []\n+//    bb1: {\n+//            | Live variables at bb1[0]: []\n+//        _1 = const 55usize;\n+//            | Live variables at bb1[1]: [_1]\n+//        StorageLive(_3);\n+//            | Live variables at bb1[2]: [_1]\n+//        StorageLive(_4);\n+//            | Live variables at bb1[3]: [_1]\n+//        _4 = _1;\n+//            | Live variables at bb1[4]: [_4]\n+//        _3 = const use_x(_4) -> bb2;\n+//    }\n+// END rustc.node12.nll.0.mir"}, {"sha": "c557763c004bff84db7f7ea38752d93e36714e39", "filename": "src/test/mir-opt/nll/liveness-interblock.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fliveness-interblock.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll\n+\n+fn cond() -> bool { false }\n+\n+fn make_live(_: usize) { }\n+\n+fn make_dead() { }\n+\n+fn main() {\n+    let x = 5;\n+\n+    if cond() {\n+        make_live(x);\n+    } else {\n+        // x should be dead on entry to this block\n+        make_dead();\n+    }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node18.nll.0.mir\n+//     | Live variables on entry to bb2: [_1]\n+//     bb2: {\n+//             | Live variables at bb2[0]: [_1]\n+//         StorageLive(_4);\n+//             | Live variables at bb2[1]: [_1]\n+//         _4 = _1;\n+//             | Live variables at bb2[2]: [_4]\n+//         _3 = const make_live(_4) -> bb4;\n+//     }\n+// END rustc.node18.nll.0.mir\n+// START rustc.node18.nll.0.mir\n+//     | Live variables on entry to bb3: []\n+//     bb3: {\n+//             | Live variables at bb3[0]: []\n+//         _5 = const make_dead() -> bb5;\n+//     }\n+// END rustc.node18.nll.0.mir\n+\n+"}, {"sha": "60a4da430b96e5fce16d96359ea8ea40ce8c4077", "filename": "src/test/mir-opt/nll/reborrow-basic.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for reborrow constraints: the region (`R5`) that appears\n+// in the type of `r_a` must outlive the region (`R7`) that appears in\n+// the type of `r_b`\n+\n+// compile-flags:-Znll -Zverbose\n+//                     ^^^^^^^^^ force compiler to dump more region information\n+\n+#![allow(warnings)]\n+\n+fn use_x(_: &mut i32) -> bool { true }\n+\n+fn main() {\n+    let mut foo: i32     = 22;\n+    let r_a: &mut i32 = &mut foo;\n+    let r_b: &mut i32 = &mut *r_a;\n+    use_x(r_b);\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node13.nll.0.mir\n+// | '_#5r: {bb0[6], bb0[7], bb0[8], bb0[9], bb0[10], bb0[11], bb0[12], bb0[13], bb0[14]}\n+// ...\n+// | '_#7r: {bb0[11], bb0[12], bb0[13], bb0[14]}\n+// END rustc.node13.nll.0.mir\n+// START rustc.node13.nll.0.mir\n+// let _2: &'_#5r mut i32;\n+// ...\n+// let _4: &'_#7r mut i32;\n+// END rustc.node13.nll.0.mir"}, {"sha": "7792f0a36f318df3c1b29091a9b2c4201c2edcfa", "filename": "src/test/mir-opt/nll/region-liveness-basic.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for liveness constraints: the region (`R1`) that appears\n+// in the type of `p` includes the points after `&v[0]` up to (but not\n+// including) the call to `use_x`. The `else` branch is not included.\n+\n+// compile-flags:-Znll -Zverbose\n+//                     ^^^^^^^^^ force compiler to dump more region information\n+\n+#![allow(warnings)]\n+\n+fn use_x(_: usize) -> bool { true }\n+\n+fn main() {\n+    let mut v = [1, 2, 3];\n+    let p = &v[0];\n+    if true {\n+        use_x(*p);\n+    } else {\n+        use_x(22);\n+    }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node12.nll.0.mir\n+// | '_#0r: {bb1[1], bb2[0], bb2[1]}\n+// | '_#1r: {bb1[1], bb2[0], bb2[1]}\n+// ...\n+//             let _2: &'_#1r usize;\n+// END rustc.node12.nll.0.mir\n+// START rustc.node12.nll.0.mir\n+//    bb1: {\n+//            | Live variables at bb1[0]: [_1, _3]\n+//        _2 = &'_#0r _1[_3];\n+//            | Live variables at bb1[1]: [_2]\n+//        switchInt(const true) -> [0u8: bb3, otherwise: bb2];\n+//    }\n+// END rustc.node12.nll.0.mir\n+// START rustc.node12.nll.0.mir\n+//    bb2: {\n+//            | Live variables at bb2[0]: [_2]\n+//        StorageLive(_7);\n+//            | Live variables at bb2[1]: [_2]\n+//        _7 = (*_2);\n+//            | Live variables at bb2[2]: [_7]\n+//        _6 = const use_x(_7) -> bb4;\n+//    }\n+// END rustc.node12.nll.0.mir"}, {"sha": "4f4bb596e5f8fa3ded771b7598a5ff5ed82a0989", "filename": "src/test/mir-opt/nll/region-liveness-drop-may-dangle.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for liveness constraints: the region (`R1`) that appears\n+// in the type of `p` includes the points after `&v[0]` up to (but not\n+// including) the call to `use_x`. The `else` branch is not included.\n+\n+// compile-flags:-Znll -Zverbose\n+//                     ^^^^^^^^^ force compiler to dump more region information\n+\n+#![allow(warnings)]\n+#![feature(dropck_eyepatch)]\n+#![feature(generic_param_attrs)]\n+\n+fn use_x(_: usize) -> bool { true }\n+\n+fn main() {\n+    let mut v = [1, 2, 3];\n+    let p: Wrap<& /* R4 */ usize> = Wrap { value: &v[0] };\n+    if true {\n+        use_x(*p.value);\n+    } else {\n+        use_x(22);\n+    }\n+\n+    // `p` will get dropped here. However, because of the\n+    // `#[may_dangle]` attribute, we do not need to consider R4 live.\n+}\n+\n+struct Wrap<T> {\n+    value: T\n+}\n+\n+unsafe impl<#[may_dangle] T> Drop for Wrap<T> {\n+    fn drop(&mut self) { }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node12.nll.0.mir\n+// | '_#4r: {bb1[3], bb1[4], bb1[5], bb2[0], bb2[1]}\n+// END rustc.node12.nll.0.mir"}, {"sha": "0ddb745b61fd7c9212c41bf0be7e606c2be0812d", "filename": "src/test/mir-opt/nll/region-liveness-drop-no-may-dangle.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for liveness constraints: the region (`R1`) that appears\n+// in the type of `p` includes the points after `&v[0]` up to (but not\n+// including) the call to `use_x`. The `else` branch is not included.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Znll -Zverbose\n+//                     ^^^^^^^^^ force compiler to dump more region information\n+\n+#![allow(warnings)]\n+\n+fn use_x(_: usize) -> bool { true }\n+\n+fn main() {\n+    let mut v = [1, 2, 3];\n+    let p: Wrap<& /* R1 */ usize> = Wrap { value: &v[0] };\n+    if true {\n+        use_x(*p.value);\n+    } else {\n+        use_x(22);\n+    }\n+\n+    // `p` will get dropped here. Because the `#[may_dangle]`\n+    // attribute is not present on `Wrap`, we must conservatively\n+    // assume that the dtor may access the `value` field, and hence we\n+    // must consider R1 to be live.\n+}\n+\n+struct Wrap<T> {\n+    value: T\n+}\n+\n+// Look ma, no `#[may_dangle]` attribute here.\n+impl<T> Drop for Wrap<T> {\n+    fn drop(&mut self) { }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node12.nll.0.mir\n+// | '_#4r: {bb1[3], bb1[4], bb1[5], bb2[0], bb2[1], bb2[2], bb3[0], bb3[1], bb3[2], bb4[0], bb4[1], bb4[2], bb6[0], bb7[0], bb7[1], bb7[2], bb8[0]}\n+// END rustc.node12.nll.0.mir"}, {"sha": "664298b937483a7777d9c40f6bd3d6543a45dda5", "filename": "src/test/mir-opt/nll/region-liveness-two-disjoint-uses.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test for the subregion constraints. In this case, the region R3 on\n+// `p` includes two disjoint regions of the control-flow graph. The\n+// borrows in `&v[0]` and `&v[1]` each (in theory) have to outlive R3,\n+// but only at a particular point, and hence they wind up including\n+// distinct regions.\n+\n+// compile-flags:-Znll -Zverbose\n+//                     ^^^^^^^^^ force compiler to dump more region information\n+\n+#![allow(warnings)]\n+\n+fn use_x(_: usize) -> bool { true }\n+\n+fn main() {\n+    let mut v = [1, 2, 3];\n+    let mut p = &v[0];\n+    if true {\n+        use_x(*p);\n+    } else {\n+        use_x(22);\n+    }\n+\n+    p = &v[1];\n+    use_x(*p);\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node12.nll.0.mir\n+// | '_#0r: {bb1[1], bb2[0], bb2[1]}\n+// ...\n+// | '_#2r: {bb7[2], bb7[3], bb7[4]}\n+// | '_#3r: {bb1[1], bb2[0], bb2[1], bb7[2], bb7[3], bb7[4]}\n+// ...\n+// let mut _2: &'_#3r usize;\n+// ...\n+// _2 = &'_#0r _1[_3];\n+// ...\n+// _2 = &'_#2r (*_11);\n+// END rustc.node12.nll.0.mir"}, {"sha": "4ae891f5b70eb91004e4d3ce78249a1c74219535", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic test for liveness constraints: the region (`R1`) that appears\n+// in the type of `p` includes the points after `&v[0]` up to (but not\n+// including) the call to `use_x`. The `else` branch is not included.\n+\n+// compile-flags:-Znll -Zverbose\n+//                     ^^^^^^^^^ force compiler to dump more region information\n+\n+#![allow(warnings)]\n+\n+fn use_x(_: usize) -> bool { true }\n+\n+fn main() {\n+    let mut v = [1, 2, 3];\n+    let p = &v[0];\n+    let q = p;\n+    if true {\n+        use_x(*q);\n+    } else {\n+        use_x(22);\n+    }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node12.nll.0.mir\n+// | '_#0r: {bb1[1], bb1[2], bb1[3], bb1[4], bb1[5], bb1[6], bb2[0], bb2[1]}\n+// | '_#1r: {bb1[1], bb1[2], bb1[3], bb1[4], bb1[5], bb1[6], bb2[0], bb2[1]}\n+// | '_#2r: {bb1[5], bb1[6], bb2[0], bb2[1]}\n+// END rustc.node12.nll.0.mir\n+// START rustc.node12.nll.0.mir\n+// let _2: &'_#1r usize;\n+// ...\n+// let _6: &'_#2r usize;\n+// ...\n+// _2 = &'_#0r _1[_3];\n+// ...\n+// _7 = _2;\n+// ...\n+// _6 = _7;\n+// END rustc.node12.nll.0.mir"}, {"sha": "f8628158aff46c093353abb417f0373331721988", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be4cc040211a85b17f21e813ff62351ae4de642/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=2be4cc040211a85b17f21e813ff62351ae4de642", "patch": "@@ -1404,6 +1404,7 @@ actual:\\n\\\n                     \"-Zdump-mir-exclude-pass-number\"]);\n \n                 let mir_dump_dir = self.get_mir_dump_dir();\n+                let _ = fs::remove_dir_all(&mir_dump_dir);\n                 create_dir_all(mir_dump_dir.as_path()).unwrap();\n                 let mut dir_opt = \"-Zdump-mir-dir=\".to_string();\n                 dir_opt.push_str(mir_dump_dir.to_str().unwrap());\n@@ -2367,12 +2368,10 @@ actual:\\n\\\n     }\n \n     fn get_mir_dump_dir(&self) -> PathBuf {\n-        let mut mir_dump_dir = PathBuf::from(self.config.build_base\n-                                                    .as_path()\n-                                                    .to_str()\n-                                                    .unwrap());\n+        let mut mir_dump_dir = PathBuf::from(self.config.build_base.as_path());\n         debug!(\"input_file: {:?}\", self.testpaths.file);\n-        mir_dump_dir.push(self.testpaths.file.file_stem().unwrap().to_str().unwrap());\n+        mir_dump_dir.push(&self.testpaths.relative_dir);\n+        mir_dump_dir.push(self.testpaths.file.file_stem().unwrap());\n         mir_dump_dir\n     }\n "}]}