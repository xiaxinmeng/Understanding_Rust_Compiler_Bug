{"sha": "90afc0765e5e536af6307b63e1655a38df06e235", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwYWZjMDc2NWU1ZTUzNmFmNjMwN2I2M2UxNjU1YTM4ZGYwNmUyMzU=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-01-23T00:23:37Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-01-23T03:20:18Z"}, "message": "Use a `ParamEnvAnd<Predicate>` for caching in `ObligationForest`\n\nPreviously, we used a plain `Predicate` to cache results (e.g. successes\nand failures) in ObligationForest. However, fulfillment depends on the\nprecise `ParamEnv` used, so this is unsound in general.\n\nThis commit changes the impl of `ForestObligation` for\n`PendingPredicateObligation` to use `ParamEnvAnd<Predicate>` instead of\n`Predicate` for the associated type. The associated type and method are\nrenamed from 'predicate' to 'cache_key' to reflect the fact that type is\nno longer just a predicate.", "tree": {"sha": "95edd24b57381a4113c04a5fd747d52dadd97076", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95edd24b57381a4113c04a5fd747d52dadd97076"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90afc0765e5e536af6307b63e1655a38df06e235", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl4pEPIACgkQtAh+UQ6Y\nsWRpdRAAlZWnH9nJMd90cRni9KIdPPovq8ds3X7txkwxqeI6NQZ89/p4eTxsGSuX\ndjTJrh3H6hZeFRKP/BV+LZal5NUOvOwWfrDil/LoPWTyh0rs1jSvPQ+JA5wrP4bK\n9sA+KATgcVrnD6ybbl2S4wnUOqieiGzfNf+XW1WjgmJV49vvxYOdf7v6zSPwnyEH\nq6p165oGttn+j4CngGaMIne4Sh29wuCFnH+xJuUyCppzAGercnmuD9zSYpnwmWIZ\nVQhAjghBF6uVnPk7W9CAPUF+doRAOBy235q685eM3ZUF3FwHAt3NaXWDkUYQnVM+\nOS+bOY7A+qo7FsgzMeyVrQ7rOyA/Q8g69bjvX8c7E9O5wofkI17ESUvAn1IWgZGp\nn+mf6CIvtXSgc9SRv1R8pt/j1EgCzen/T0SJCbdLX/SVf6Ct9lLYFpa3LYJvCqbG\nZAMlznujuxOOlJocRxQNh8hpS7HHB7gOk8Uqdw0D5llTOAeCuWARDPFx9NMSR0JU\nVaqYAQIaBvH0rHzyvejotxOQ+zI763H8DfHSwchFOiSj78Fh453NAE9WknNLsFxn\nsMne40bzlC8HvR6RRQwnSRX6xoRm6R06sYjavv8jh47ufOffMGwU9n9luTEuHwcv\nhiANcphtTICabR6lNXdGQIC4kbkzc3QS5R256oLISLo5zEqWBiM=\n=q/Ce\n-----END PGP SIGNATURE-----", "payload": "tree 95edd24b57381a4113c04a5fd747d52dadd97076\nparent d1e594f4029c6ac8feb7c2acf9f9e04c1b9c493c\nauthor Aaron Hill <aa1ronham@gmail.com> 1579739017 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1579749618 -0500\n\nUse a `ParamEnvAnd<Predicate>` for caching in `ObligationForest`\n\nPreviously, we used a plain `Predicate` to cache results (e.g. successes\nand failures) in ObligationForest. However, fulfillment depends on the\nprecise `ParamEnv` used, so this is unsound in general.\n\nThis commit changes the impl of `ForestObligation` for\n`PendingPredicateObligation` to use `ParamEnvAnd<Predicate>` instead of\n`Predicate` for the associated type. The associated type and method are\nrenamed from 'predicate' to 'cache_key' to reflect the fact that type is\nno longer just a predicate.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90afc0765e5e536af6307b63e1655a38df06e235", "html_url": "https://github.com/rust-lang/rust/commit/90afc0765e5e536af6307b63e1655a38df06e235", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90afc0765e5e536af6307b63e1655a38df06e235/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1e594f4029c6ac8feb7c2acf9f9e04c1b9c493c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1e594f4029c6ac8feb7c2acf9f9e04c1b9c493c", "html_url": "https://github.com/rust-lang/rust/commit/d1e594f4029c6ac8feb7c2acf9f9e04c1b9c493c"}], "stats": {"total": 44, "additions": 26, "deletions": 18}, "files": [{"sha": "07352a3f9478a0c3723394f929925f7891bfa872", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/90afc0765e5e536af6307b63e1655a38df06e235/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90afc0765e5e536af6307b63e1655a38df06e235/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=90afc0765e5e536af6307b63e1655a38df06e235", "patch": "@@ -18,10 +18,13 @@ use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation};\n \n impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n-    type Predicate = ty::Predicate<'tcx>;\n+    /// Note that we include both the `ParamEnv` and the `Predicate`,\n+    /// as the `ParamEnv` can influence whether fulfillment succeeds\n+    /// or fails.\n+    type CacheKey = ty::ParamEnvAnd<'tcx, ty::Predicate<'tcx>>;\n \n-    fn as_predicate(&self) -> &Self::Predicate {\n-        &self.obligation.predicate\n+    fn as_cache_key(&self) -> Self::CacheKey {\n+        self.obligation.param_env.and(self.obligation.predicate)\n     }\n }\n "}, {"sha": "96ee72d187b34d5930b5f48cb18a4af9b63a14c8", "filename": "src/librustc_data_structures/obligation_forest/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90afc0765e5e536af6307b63e1655a38df06e235/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90afc0765e5e536af6307b63e1655a38df06e235/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs?ref=90afc0765e5e536af6307b63e1655a38df06e235", "patch": "@@ -51,7 +51,7 @@ impl<'a, O: ForestObligation + 'a> dot::Labeller<'a> for &'a ObligationForest<O>\n \n     fn node_label(&self, index: &Self::Node) -> dot::LabelText<'_> {\n         let node = &self.nodes[*index];\n-        let label = format!(\"{:?} ({:?})\", node.obligation.as_predicate(), node.state.get());\n+        let label = format!(\"{:?} ({:?})\", node.obligation.as_cache_key(), node.state.get());\n \n         dot::LabelText::LabelStr(label.into())\n     }"}, {"sha": "500ce5c71f37a35e6e43fafdc2c2da3e427ce77d", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/90afc0765e5e536af6307b63e1655a38df06e235/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90afc0765e5e536af6307b63e1655a38df06e235/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=90afc0765e5e536af6307b63e1655a38df06e235", "patch": "@@ -86,9 +86,13 @@ mod graphviz;\n mod tests;\n \n pub trait ForestObligation: Clone + Debug {\n-    type Predicate: Clone + hash::Hash + Eq + Debug;\n+    type CacheKey: Clone + hash::Hash + Eq + Debug;\n \n-    fn as_predicate(&self) -> &Self::Predicate;\n+    /// Converts this `ForestObligation` suitable for use as a cache key.\n+    /// If two distinct `ForestObligations`s return the same cache key,\n+    /// then it must be sound to use the result of processing one obligation\n+    /// (e.g. success for error) for the other obligation\n+    fn as_cache_key(&self) -> Self::CacheKey;\n }\n \n pub trait ObligationProcessor {\n@@ -138,12 +142,12 @@ pub struct ObligationForest<O: ForestObligation> {\n     nodes: Vec<Node<O>>,\n \n     /// A cache of predicates that have been successfully completed.\n-    done_cache: FxHashSet<O::Predicate>,\n+    done_cache: FxHashSet<O::CacheKey>,\n \n     /// A cache of the nodes in `nodes`, indexed by predicate. Unfortunately,\n     /// its contents are not guaranteed to match those of `nodes`. See the\n     /// comments in `process_obligation` for details.\n-    active_cache: FxHashMap<O::Predicate, usize>,\n+    active_cache: FxHashMap<O::CacheKey, usize>,\n \n     /// A vector reused in compress(), to avoid allocating new vectors.\n     node_rewrites: RefCell<Vec<usize>>,\n@@ -157,7 +161,7 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// See [this][details] for details.\n     ///\n     /// [details]: https://github.com/rust-lang/rust/pull/53255#issuecomment-421184780\n-    error_cache: FxHashMap<ObligationTreeId, FxHashSet<O::Predicate>>,\n+    error_cache: FxHashMap<ObligationTreeId, FxHashSet<O::CacheKey>>,\n }\n \n #[derive(Debug)]\n@@ -305,11 +309,12 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     // Returns Err(()) if we already know this obligation failed.\n     fn register_obligation_at(&mut self, obligation: O, parent: Option<usize>) -> Result<(), ()> {\n-        if self.done_cache.contains(obligation.as_predicate()) {\n+        if self.done_cache.contains(&obligation.as_cache_key()) {\n+            debug!(\"register_obligation_at: ignoring already done obligation: {:?}\", obligation);\n             return Ok(());\n         }\n \n-        match self.active_cache.entry(obligation.as_predicate().clone()) {\n+        match self.active_cache.entry(obligation.as_cache_key().clone()) {\n             Entry::Occupied(o) => {\n                 let node = &mut self.nodes[*o.get()];\n                 if let Some(parent_index) = parent {\n@@ -333,7 +338,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     && self\n                         .error_cache\n                         .get(&obligation_tree_id)\n-                        .map(|errors| errors.contains(obligation.as_predicate()))\n+                        .map(|errors| errors.contains(&obligation.as_cache_key()))\n                         .unwrap_or(false);\n \n                 if already_failed {\n@@ -380,7 +385,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.error_cache\n             .entry(node.obligation_tree_id)\n             .or_default()\n-            .insert(node.obligation.as_predicate().clone());\n+            .insert(node.obligation.as_cache_key().clone());\n     }\n \n     /// Performs a pass through the obligation list. This must\n@@ -618,11 +623,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     // `self.nodes`. See the comment in `process_obligation`\n                     // for more details.\n                     if let Some((predicate, _)) =\n-                        self.active_cache.remove_entry(node.obligation.as_predicate())\n+                        self.active_cache.remove_entry(&node.obligation.as_cache_key())\n                     {\n                         self.done_cache.insert(predicate);\n                     } else {\n-                        self.done_cache.insert(node.obligation.as_predicate().clone());\n+                        self.done_cache.insert(node.obligation.as_cache_key().clone());\n                     }\n                     if do_completed == DoCompleted::Yes {\n                         // Extract the success stories.\n@@ -635,7 +640,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     // We *intentionally* remove the node from the cache at this point. Otherwise\n                     // tests must come up with a different type on every type error they\n                     // check against.\n-                    self.active_cache.remove(node.obligation.as_predicate());\n+                    self.active_cache.remove(&node.obligation.as_cache_key());\n                     self.insert_into_error_cache(index);\n                     node_rewrites[index] = orig_nodes_len;\n                     dead_nodes += 1;"}, {"sha": "01652465eea2cc7a554134354ab6b29b0fdd7d82", "filename": "src/librustc_data_structures/obligation_forest/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90afc0765e5e536af6307b63e1655a38df06e235/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90afc0765e5e536af6307b63e1655a38df06e235/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs?ref=90afc0765e5e536af6307b63e1655a38df06e235", "patch": "@@ -4,9 +4,9 @@ use std::fmt;\n use std::marker::PhantomData;\n \n impl<'a> super::ForestObligation for &'a str {\n-    type Predicate = &'a str;\n+    type CacheKey = &'a str;\n \n-    fn as_predicate(&self) -> &Self::Predicate {\n+    fn as_cache_key(&self) -> Self::CacheKey {\n         self\n     }\n }"}]}