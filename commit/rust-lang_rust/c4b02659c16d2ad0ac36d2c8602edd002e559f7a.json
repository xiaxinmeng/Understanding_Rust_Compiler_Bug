{"sha": "c4b02659c16d2ad0ac36d2c8602edd002e559f7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0YjAyNjU5YzE2ZDJhZDBhYzM2ZDJjODYwMmVkZDAwMmU1NTlmN2E=", "commit": {"author": {"name": "Mohsen Zohrevandi", "email": "mohsen.zohrevandi@fortanix.com", "date": "2020-06-12T00:44:21Z"}, "committer": {"name": "Mohsen Zohrevandi", "email": "mohsen.zohrevandi@fortanix.com", "date": "2020-06-12T18:26:19Z"}, "message": "Enable some timeouts in SGX platform\n\nThis would partially resolve\nhttps://github.com/fortanix/rust-sgx/issues/31", "tree": {"sha": "1c77a511d6df7e61e02ab2aec7b343f30d1b72fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c77a511d6df7e61e02ab2aec7b343f30d1b72fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4b02659c16d2ad0ac36d2c8602edd002e559f7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4b02659c16d2ad0ac36d2c8602edd002e559f7a", "html_url": "https://github.com/rust-lang/rust/commit/c4b02659c16d2ad0ac36d2c8602edd002e559f7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/comments", "author": {"login": "mzohreva", "id": 1142455, "node_id": "MDQ6VXNlcjExNDI0NTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1142455?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mzohreva", "html_url": "https://github.com/mzohreva", "followers_url": "https://api.github.com/users/mzohreva/followers", "following_url": "https://api.github.com/users/mzohreva/following{/other_user}", "gists_url": "https://api.github.com/users/mzohreva/gists{/gist_id}", "starred_url": "https://api.github.com/users/mzohreva/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mzohreva/subscriptions", "organizations_url": "https://api.github.com/users/mzohreva/orgs", "repos_url": "https://api.github.com/users/mzohreva/repos", "events_url": "https://api.github.com/users/mzohreva/events{/privacy}", "received_events_url": "https://api.github.com/users/mzohreva/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mzohreva", "id": 1142455, "node_id": "MDQ6VXNlcjExNDI0NTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1142455?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mzohreva", "html_url": "https://github.com/mzohreva", "followers_url": "https://api.github.com/users/mzohreva/followers", "following_url": "https://api.github.com/users/mzohreva/following{/other_user}", "gists_url": "https://api.github.com/users/mzohreva/gists{/gist_id}", "starred_url": "https://api.github.com/users/mzohreva/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mzohreva/subscriptions", "organizations_url": "https://api.github.com/users/mzohreva/orgs", "repos_url": "https://api.github.com/users/mzohreva/repos", "events_url": "https://api.github.com/users/mzohreva/events{/privacy}", "received_events_url": "https://api.github.com/users/mzohreva/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50c0192c64241d723066add22c53d472e2b9cba9", "url": "https://api.github.com/repos/rust-lang/rust/commits/50c0192c64241d723066add22c53d472e2b9cba9", "html_url": "https://github.com/rust-lang/rust/commit/50c0192c64241d723066add22c53d472e2b9cba9"}], "stats": {"total": 210, "additions": 179, "deletions": 31}, "files": [{"sha": "6778ab9dcde4a4f60711a8fbeefa3dc22fc52f19", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=c4b02659c16d2ad0ac36d2c8602edd002e559f7a", "patch": "@@ -695,7 +695,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_wait() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());\n@@ -715,7 +714,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_while_wait() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());\n@@ -740,7 +738,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_while_wake() {\n         let pair = Arc::new((Mutex::new(false), Condvar::new()));\n         let pair_copy = pair.clone();\n@@ -764,7 +761,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_wake() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());"}, {"sha": "db765bde5438e1e7b89e1b7a0fd89eff341afd20", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=c4b02659c16d2ad0ac36d2c8602edd002e559f7a", "patch": "@@ -2088,7 +2088,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn oneshot_single_thread_recv_timeout() {\n         let (tx, rx) = channel();\n         tx.send(()).unwrap();\n@@ -2099,7 +2098,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_two_threads() {\n         let (tx, rx) = channel();\n         let stress = stress_factor() + 100;\n@@ -2130,7 +2128,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn recv_timeout_upgrade() {\n         let (tx, rx) = channel::<()>();\n         let timeout = Duration::from_millis(1);\n@@ -2142,7 +2139,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_shared() {\n         let (tx, rx) = channel();\n         let stress = stress_factor() + 100;\n@@ -2173,7 +2169,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn very_long_recv_timeout_wont_panic() {\n         let (tx, rx) = channel::<()>();\n         let join_handle =\n@@ -2196,7 +2191,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn shared_recv_timeout() {\n         let (tx, rx) = channel();\n         let total = 5;\n@@ -2426,7 +2420,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn recv_timeout() {\n         let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Err(RecvTimeoutError::Timeout));\n@@ -2518,7 +2511,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_two_threads() {\n         let (tx, rx) = sync_channel::<i32>(0);\n \n@@ -2544,7 +2536,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_shared() {\n         const AMT: u32 = 1000;\n         const NTHREADS: u32 = 8;"}, {"sha": "b223da9d7e4a2b1cba914155bc4c36bf6e0274b9", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=c4b02659c16d2ad0ac36d2c8602edd002e559f7a", "patch": "@@ -1,5 +1,6 @@\n use crate::cmp;\n use crate::io::{Error as IoError, IoSlice, IoSliceMut, Result as IoResult};\n+use crate::sys::rand::rdrand64;\n use crate::time::Duration;\n \n pub(crate) mod alloc;\n@@ -149,7 +150,28 @@ pub fn exit(panic: bool) -> ! {\n \n /// Usercall `wait`. See the ABI documentation for more information.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-pub fn wait(event_mask: u64, timeout: u64) -> IoResult<u64> {\n+pub fn wait(event_mask: u64, mut timeout: u64) -> IoResult<u64> {\n+    if timeout != WAIT_NO && timeout != WAIT_INDEFINITE {\n+        // We don't want people to rely on accuracy of timeouts to make\n+        // security decisions in an SGX enclave. That's why we add a random\n+        // amount not exceeding +/- 10% to the timeout value to discourage\n+        // people from relying on accuracy of timeouts while providing a way\n+        // to make things work in other cases. Note that in the SGX threat\n+        // model the enclave runner which is serving the wait usercall is not\n+        // trusted to ensure accurate timeouts.\n+        let base = cmp::max(1, timeout / 10) * 2 + 1;\n+        let zero = base / 2;\n+        match rdrand64() % base {\n+            jitter if jitter > zero => {\n+                timeout = timeout.checked_add(jitter - zero).unwrap_or(timeout)\n+            }\n+            jitter if jitter < zero => {\n+                timeout = timeout.checked_sub(zero - jitter).unwrap_or(timeout)\n+            }\n+            _ => {}\n+        };\n+        timeout = cmp::min(u64::MAX - 1, cmp::max(1, timeout));\n+    }\n     unsafe { raw::wait(event_mask, timeout).from_sgx_result() }\n }\n "}, {"sha": "ed6dbcf497147f68834e71a85bdad2165fc50f6c", "filename": "src/libstd/sys/sgx/condvar.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs?ref=c4b02659c16d2ad0ac36d2c8602edd002e559f7a", "patch": "@@ -31,8 +31,10 @@ impl Condvar {\n         mutex.lock()\n     }\n \n-    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n-        rtabort!(\"timeout not supported in SGX\");\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        let success = WaitQueue::wait_timeout(&self.inner, dur, || mutex.unlock());\n+        mutex.lock();\n+        success\n     }\n \n     #[inline]"}, {"sha": "dff9d3b1f07eaa4f8bd5ceec73cce26b26d855c6", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=c4b02659c16d2ad0ac36d2c8602edd002e559f7a", "patch": "@@ -110,6 +110,42 @@ pub fn decode_error_kind(code: i32) -> ErrorKind {\n     }\n }\n \n+// This function makes an effort to sleep at least as long as `duration`.\n+// Note that in general there is no guarantee about accuracy of time and\n+// timeouts in SGX model. The enclave runner serving usercalls may lie about\n+// current time and/or ignore timeout values.\n+//\n+// FIXME: note these caveats in documentation of all public types that use this\n+// function in their execution path.\n+pub fn wait_timeout_sgx(event_mask: u64, duration: crate::time::Duration) {\n+    use self::abi::usercalls;\n+    use crate::cmp;\n+    use crate::io::ErrorKind;\n+    use crate::time::Instant;\n+\n+    let start = Instant::now();\n+    let mut remaining = duration;\n+    loop {\n+        let timeout = cmp::min((u64::MAX - 1) as u128, remaining.as_nanos()) as u64;\n+        match usercalls::wait(event_mask, timeout) {\n+            Ok(eventset) => {\n+                if event_mask != 0 {\n+                    rtassert!(eventset & event_mask == event_mask);\n+                    return;\n+                }\n+                rtabort!(\"expected usercalls::wait() to return Err, found Ok.\");\n+            }\n+            Err(e) => {\n+                rtassert!(e.kind() == ErrorKind::TimedOut || e.kind() == ErrorKind::WouldBlock)\n+            }\n+        }\n+        remaining = match duration.checked_sub(start.elapsed()) {\n+            Some(remaining) => remaining,\n+            None => break,\n+        }\n+    }\n+}\n+\n // This enum is used as the storage for a bunch of types which can't actually\n // exist.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n@@ -137,8 +173,8 @@ pub extern \"C\" fn __rust_abort() {\n     abort_internal();\n }\n \n-pub fn hashmap_random_keys() -> (u64, u64) {\n-    fn rdrand64() -> u64 {\n+pub mod rand {\n+    pub fn rdrand64() -> u64 {\n         unsafe {\n             let mut ret: u64 = 0;\n             for _ in 0..10 {\n@@ -149,7 +185,10 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n             rtabort!(\"Failed to obtain random data\");\n         }\n     }\n-    (rdrand64(), rdrand64())\n+}\n+\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    (self::rand::rdrand64(), self::rand::rdrand64())\n }\n \n pub use crate::sys_common::{AsInner, FromInner, IntoInner};"}, {"sha": "8ff0f1fde91c2116ff6880ca4093b3177814756a", "filename": "src/libstd/sys/sgx/thread.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs?ref=c4b02659c16d2ad0ac36d2c8602edd002e559f7a", "patch": "@@ -1,6 +1,8 @@\n #![cfg_attr(test, allow(dead_code))] // why is this necessary?\n+\n use crate::ffi::CStr;\n use crate::io;\n+use crate::sys::wait_timeout_sgx;\n use crate::time::Duration;\n \n use super::abi::usercalls;\n@@ -73,8 +75,8 @@ impl Thread {\n         // FIXME: could store this pointer in TLS somewhere\n     }\n \n-    pub fn sleep(_dur: Duration) {\n-        rtabort!(\"can't sleep\"); // FIXME\n+    pub fn sleep(dur: Duration) {\n+        wait_timeout_sgx(0, dur);\n     }\n \n     pub fn join(self) {"}, {"sha": "71d1c22cd6191140e8682dabb6482209bcf2612b", "filename": "src/libstd/sys/sgx/waitqueue.rs", "status": "modified", "additions": 106, "deletions": 7, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs?ref=c4b02659c16d2ad0ac36d2c8602edd002e559f7a", "patch": "@@ -1,4 +1,3 @@\n-use crate::num::NonZeroUsize;\n /// A simple queue implementation for synchronization primitives.\n ///\n /// This queue is used to implement condition variable and mutexes.\n@@ -10,7 +9,10 @@ use crate::num::NonZeroUsize;\n /// Since userspace may send spurious wake-ups, the wakeup event state is\n /// recorded in the enclave. The wakeup event state is protected by a spinlock.\n /// The queue and associated wait state are stored in a `WaitVariable`.\n+use crate::num::NonZeroUsize;\n use crate::ops::{Deref, DerefMut};\n+use crate::sys::wait_timeout_sgx;\n+use crate::time::Duration;\n \n use super::abi::thread;\n use super::abi::usercalls;\n@@ -158,6 +160,37 @@ impl WaitQueue {\n         }\n     }\n \n+    /// Adds the calling thread to the `WaitVariable`'s wait queue, then wait\n+    /// until a wakeup event or timeout. If event was observed, returns true.\n+    /// If not, it will remove the calling thread from the wait queue.\n+    pub fn wait_timeout<T, F: FnOnce()>(\n+        lock: &SpinMutex<WaitVariable<T>>,\n+        timeout: Duration,\n+        before_wait: F,\n+    ) -> bool {\n+        // very unsafe: check requirements of UnsafeList::push\n+        unsafe {\n+            let mut entry = UnsafeListEntry::new(SpinMutex::new(WaitEntry {\n+                tcs: thread::current(),\n+                wake: false,\n+            }));\n+            let entry_lock = lock.lock().queue.inner.push(&mut entry);\n+            before_wait();\n+            // don't panic, this would invalidate `entry` during unwinding\n+            wait_timeout_sgx(EV_UNPARK, timeout);\n+            // acquire the wait queue's lock first to avoid deadlock.\n+            let mut guard = lock.lock();\n+            let entry_guard = entry_lock.lock();\n+            let success = entry_guard.wake;\n+            if !success {\n+                // nobody is waking us up, so remove the entry from the wait queue.\n+                drop(entry_guard);\n+                guard.queue.inner.remove(&mut entry);\n+            }\n+            success\n+        }\n+    }\n+\n     /// Either find the next waiter on the wait queue, or return the mutex\n     /// guard unchanged.\n     ///\n@@ -325,6 +358,31 @@ mod unsafe_list {\n                 Some((*first.as_ptr()).value.as_ref().unwrap())\n             }\n         }\n+\n+        /// Removes an entry from the list.\n+        ///\n+        /// # Safety\n+        ///\n+        /// The caller must ensure that entry has been pushed prior to this\n+        /// call and has not moved since push.\n+        pub unsafe fn remove(&mut self, entry: &mut UnsafeListEntry<T>) {\n+            rtassert!(!self.is_empty());\n+            // BEFORE:\n+            //     /----\\ next ---> /-----\\ next ---> /----\\\n+            // ... |prev|           |entry|           |next| ...\n+            //     \\----/ <--- prev \\-----/ <--- prev \\----/\n+            //\n+            // AFTER:\n+            //     /----\\ next ---> /----\\\n+            // ... |prev|           |next| ...\n+            //     \\----/ <--- prev \\----/\n+            let mut prev = entry.prev;\n+            let mut next = entry.next;\n+            prev.as_mut().next = next;\n+            next.as_mut().prev = prev;\n+            entry.next = NonNull::dangling();\n+            entry.prev = NonNull::dangling();\n+        }\n     }\n \n     #[cfg(test)]\n@@ -354,6 +412,51 @@ mod unsafe_list {\n             }\n         }\n \n+        #[test]\n+        fn push_remove() {\n+            unsafe {\n+                let mut node = UnsafeListEntry::new(1234);\n+                let mut list = UnsafeList::new();\n+                assert_eq!(list.push(&mut node), &1234);\n+                list.remove(&mut node);\n+                assert_empty(&mut list);\n+            }\n+        }\n+\n+        #[test]\n+        fn push_remove_pop() {\n+            unsafe {\n+                let mut node1 = UnsafeListEntry::new(11);\n+                let mut node2 = UnsafeListEntry::new(12);\n+                let mut node3 = UnsafeListEntry::new(13);\n+                let mut node4 = UnsafeListEntry::new(14);\n+                let mut node5 = UnsafeListEntry::new(15);\n+                let mut list = UnsafeList::new();\n+                assert_eq!(list.push(&mut node1), &11);\n+                assert_eq!(list.push(&mut node2), &12);\n+                assert_eq!(list.push(&mut node3), &13);\n+                assert_eq!(list.push(&mut node4), &14);\n+                assert_eq!(list.push(&mut node5), &15);\n+\n+                list.remove(&mut node1);\n+                assert_eq!(list.pop().unwrap(), &12);\n+                list.remove(&mut node3);\n+                assert_eq!(list.pop().unwrap(), &14);\n+                list.remove(&mut node5);\n+                assert_empty(&mut list);\n+\n+                assert_eq!(list.push(&mut node1), &11);\n+                assert_eq!(list.pop().unwrap(), &11);\n+                assert_empty(&mut list);\n+\n+                assert_eq!(list.push(&mut node3), &13);\n+                assert_eq!(list.push(&mut node4), &14);\n+                list.remove(&mut node3);\n+                list.remove(&mut node4);\n+                assert_empty(&mut list);\n+            }\n+        }\n+\n         #[test]\n         fn complex_pushes_pops() {\n             unsafe {\n@@ -474,7 +577,7 @@ mod spin_mutex {\n         use super::*;\n         use crate::sync::Arc;\n         use crate::thread;\n-        use crate::time::{Duration, SystemTime};\n+        use crate::time::Duration;\n \n         #[test]\n         fn sleep() {\n@@ -485,11 +588,7 @@ mod spin_mutex {\n                 *mutex2.lock() = 1;\n             });\n \n-            // \"sleep\" for 50ms\n-            // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n-            let start = SystemTime::now();\n-            let max = Duration::from_millis(50);\n-            while start.elapsed().unwrap() < max {}\n+            thread::sleep(Duration::from_millis(50));\n \n             assert_eq!(*guard, 0);\n             drop(guard);"}, {"sha": "9bcb89d81443db96319d8fbb06b3740cf1166de4", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4b02659c16d2ad0ac36d2c8602edd002e559f7a/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=c4b02659c16d2ad0ac36d2c8602edd002e559f7a", "patch": "@@ -1743,15 +1743,13 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn test_park_timeout_unpark_not_called() {\n         for _ in 0..10 {\n             thread::park_timeout(Duration::from_millis(10));\n         }\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn test_park_timeout_unpark_called_other_thread() {\n         for _ in 0..10 {\n             let th = thread::current();\n@@ -1766,7 +1764,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn sleep_ms_smoke() {\n         thread::sleep(Duration::from_millis(2));\n     }"}]}