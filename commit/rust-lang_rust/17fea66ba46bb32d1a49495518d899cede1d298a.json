{"sha": "17fea66ba46bb32d1a49495518d899cede1d298a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3ZmVhNjZiYTQ2YmIzMmQxYTQ5NDk1NTE4ZDg5OWNlZGUxZDI5OGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-04T15:38:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-04T15:38:10Z"}, "message": "Auto merge of #48913 - Mark-Simulacrum:rustbuild-test, r=alexcrichton\n\nAdd tests to rustbuild\n\nIn order to run tests, we cfg out various parts of rustbuild. Generally\nspeaking, these are filesystem and process-spawning operations. Then, rustbuild\nis run \"as normal\" and the various steps that where run are retrieved from the\ncache and checked against the expected results.\n\nNote that this means that the current implementation primarily tests \"what\" we\nbuild, but doesn't actually test that what we build *will* build. In other\nwords, it doesn't do any form of dependency verification for any crate. This is\npossible to implement, but is considered future work.\n\nThis implementation strives to cfg out as little code as possible; it also does\nnot currently test anywhere near all of rustbuild. The current tests are also\nnot checked for \"correctness,\" rather, they simply represent what we do as of\nthis commit, which may be wrong.\n\nTest cases are drawn from the old implementation of rustbuild, though the\nexpected results may vary.\n\nr? @alexcrichton", "tree": {"sha": "53b6b618b54b8d795f4f612339df31bf6626da98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53b6b618b54b8d795f4f612339df31bf6626da98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17fea66ba46bb32d1a49495518d899cede1d298a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17fea66ba46bb32d1a49495518d899cede1d298a", "html_url": "https://github.com/rust-lang/rust/commit/17fea66ba46bb32d1a49495518d899cede1d298a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17fea66ba46bb32d1a49495518d899cede1d298a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5758c2dd14fd29caf7c7bb2123eb6b23443b9233", "url": "https://api.github.com/repos/rust-lang/rust/commits/5758c2dd14fd29caf7c7bb2123eb6b23443b9233", "html_url": "https://github.com/rust-lang/rust/commit/5758c2dd14fd29caf7c7bb2123eb6b23443b9233"}, {"sha": "184d3bca6cc1ac2023bbd723223d1a9bd4d4380b", "url": "https://api.github.com/repos/rust-lang/rust/commits/184d3bca6cc1ac2023bbd723223d1a9bd4d4380b", "html_url": "https://github.com/rust-lang/rust/commit/184d3bca6cc1ac2023bbd723223d1a9bd4d4380b"}], "stats": {"total": 1681, "additions": 1211, "deletions": 470}, "files": [{"sha": "5b918a063b07c80a8a3791c71fb3e0e0e6cc20a0", "filename": "src/Cargo.lock", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -124,6 +124,8 @@ dependencies = [\n  \"lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"petgraph 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"pretty_assertions 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -528,6 +530,11 @@ name = \"diff\"\n version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"difference\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"dlmalloc\"\n version = \"0.0.0\"\n@@ -635,6 +642,11 @@ version = \"0.1.0\"\n name = \"find_impls\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"fixedbitset\"\n+version = \"0.1.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"flate2\"\n version = \"1.0.1\"\n@@ -1162,6 +1174,11 @@ dependencies = [\n  \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"ordermap\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"owning_ref\"\n version = \"0.3.3\"\n@@ -1228,11 +1245,29 @@ dependencies = [\n  \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"petgraph\"\n+version = \"0.4.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"fixedbitset 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ordermap 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"pkg-config\"\n version = \"0.3.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"pretty_assertions\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"proc-macro2\"\n version = \"0.2.3\"\n@@ -2683,6 +2718,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum curl-sys 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f46e49c7125131f5afaded06944d6888b55cbdf8eba05dae73c954019b907961\"\n \"checksum derive-new 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6fcb923bab47a948f1b01cec2f758fdebba95c9ebc255458654b2b88efe59d71\"\n \"checksum diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3c2b69f912779fbb121ceb775d74d51e915af17aaebc38d28a592843a2dd0a3a\"\n+\"checksum difference 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n \"checksum dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09c3753c3db574d215cba4ea76018483895d7bff25a31b49ba45db21c48e50ab\"\n \"checksum either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3be565ca5c557d7f59e7cfcf1844f9e3033650c929c6566f511e8005f205c1d0\"\n \"checksum ena 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f8b449f3b18c89d2dbe40548d2ee4fa58ea0a08b761992da6ecb9788e4688834\"\n@@ -2693,6 +2729,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum failure 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"934799b6c1de475a012a02dab0ace1ace43789ee4b99bcfbf1a2e3e8ced5de82\"\n \"checksum failure_derive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c7cdda555bb90c9bb67a3b670a0f42de8e73f5981524123ad8578aafec8ddb8b\"\n \"checksum filetime 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"714653f3e34871534de23771ac7b26e999651a0a228f47beb324dfdf1dd4b10f\"\n+\"checksum fixedbitset 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n \"checksum flate2 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9fac2277e84e5e858483756647a9d0aa8d9a2b7cba517fd84325a0aaa69a0909\"\n \"checksum fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3\"\n \"checksum foreign-types 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1\"\n@@ -2748,13 +2785,16 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum openssl 0.10.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1636c9f1d78af9cbcc50e523bfff4a30274108aad5e86761afd4d31e4e184fa7\"\n \"checksum openssl-probe 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"77af24da69f9d9341038eba93a073b1fdaaa1b788221b00a69bce9e762cb32de\"\n \"checksum openssl-sys 0.9.27 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d6fdc5c4a02e69ce65046f1763a0181107038e02176233acb0b3351d7cc588f9\"\n+\"checksum ordermap 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a86ed3f5f244b372d6b1a00b72ef7f8876d0bc6a78a4c9985c53614041512063\"\n \"checksum owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdf84f41639e037b484f93433aa3897863b561ed65c6e59c7073d7c561710f37\"\n \"checksum parking_lot 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9fd9d732f2de194336fb02fe11f9eed13d9e76f13f4315b4d88a14ca411750cd\"\n \"checksum parking_lot_core 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"538ef00b7317875071d5e00f603f24d16f0b474c1a5fc0ccb8b454ca72eafa79\"\n \"checksum percent-encoding 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"31010dd2e1ac33d5b46a5b413495239882813e0369f8ed8a5e266f173602f831\"\n \"checksum pest 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0fce5d8b5cc33983fc74f78ad552b5522ab41442c4ca91606e4236eb4b5ceefc\"\n \"checksum pest_derive 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab94faafeb93f4c5e3ce81ca0e5a779529a602ad5d09ae6d21996bfb8b6a52bf\"\n+\"checksum petgraph 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8b30dc85588cd02b9b76f5e386535db546d21dc68506cff2abebee0b6445e8e4\"\n \"checksum pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a8b4c6b8165cd1a1cd4b9b120978131389f64bdaf456435caa41e630edba903\"\n+\"checksum pretty_assertions 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a029430f0d744bc3d15dd474d591bed2402b645d024583082b9f63bb936dac6\"\n \"checksum proc-macro2 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cd07deb3c6d1d9ff827999c7f9b04cdfd66b1b17ae508e14fe47b620f2282ae0\"\n \"checksum proc-macro2 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388d7ea47318c5ccdeb9ba6312cee7d3f65dd2804be8580a170fce410d50b786\"\n \"checksum pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d6fdf85cda6cadfae5428a54661d431330b312bc767ddbc57adbedc24da66e32\""}, {"sha": "2f9c4e148a6bad72cc2c5be24ad9ae0a976122ea", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -42,3 +42,7 @@ serde_json = \"1.0.2\"\n toml = \"0.4\"\n lazy_static = \"0.2\"\n time = \"0.1\"\n+petgraph = \"0.4.12\"\n+\n+[dev-dependencies]\n+pretty_assertions = \"0.5\""}, {"sha": "cf54591f25cd576cd62fa204f939a95bfec1d40e", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -314,7 +314,7 @@ def __init__(self):\n         self.build_dir = os.path.join(os.getcwd(), \"build\")\n         self.clean = False\n         self.config_toml = ''\n-        self.rust_root = os.path.abspath(os.path.join(__file__, '../../..'))\n+        self.rust_root = ''\n         self.use_locked_deps = ''\n         self.use_vendored_sources = ''\n         self.verbose = False\n@@ -710,6 +710,7 @@ def bootstrap(help_triggered):\n     parser = argparse.ArgumentParser(description='Build rust')\n     parser.add_argument('--config')\n     parser.add_argument('--build')\n+    parser.add_argument('--src')\n     parser.add_argument('--clean', action='store_true')\n     parser.add_argument('-v', '--verbose', action='count', default=0)\n \n@@ -718,6 +719,7 @@ def bootstrap(help_triggered):\n \n     # Configure initial bootstrap\n     build = RustBuild()\n+    build.rust_root = args.src or os.path.abspath(os.path.join(__file__, '../../..'))\n     build.verbose = args.verbose\n     build.clean = args.clean\n \n@@ -788,6 +790,7 @@ def bootstrap(help_triggered):\n     env[\"SRC\"] = build.rust_root\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     env[\"BOOTSTRAP_PYTHON\"] = sys.executable\n+    env[\"BUILD_DIR\"] = build.build_dir\n     run(args, env=env, verbose=build.verbose)\n \n "}, {"sha": "3f5ec4933d02b23d31469b3ea022b46fb1f0b323", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 536, "deletions": 10, "changes": 546, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -19,6 +19,7 @@ use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{Instant, Duration};\n+use std::collections::HashMap;\n \n use compile;\n use install;\n@@ -35,13 +36,20 @@ use native;\n \n pub use Compiler;\n \n+use petgraph::Graph;\n+use petgraph::graph::NodeIndex;\n+\n pub struct Builder<'a> {\n     pub build: &'a Build,\n     pub top_stage: u32,\n     pub kind: Kind,\n     cache: Cache,\n     stack: RefCell<Vec<Box<Any>>>,\n     time_spent_on_dependencies: Cell<Duration>,\n+    pub paths: Vec<PathBuf>,\n+    graph_nodes: RefCell<HashMap<String, NodeIndex>>,\n+    graph: RefCell<Graph<String, bool>>,\n+    parent: Cell<Option<NodeIndex>>,\n }\n \n impl<'a> Deref for Builder<'a> {\n@@ -351,6 +359,10 @@ impl<'a> Builder<'a> {\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n             time_spent_on_dependencies: Cell::new(Duration::new(0, 0)),\n+            paths: vec![],\n+            graph_nodes: RefCell::new(HashMap::new()),\n+            graph: RefCell::new(Graph::new()),\n+            parent: Cell::new(None),\n         };\n \n         let builder = &builder;\n@@ -367,7 +379,7 @@ impl<'a> Builder<'a> {\n         Some(help)\n     }\n \n-    pub fn run(build: &Build) {\n+    pub fn new(build: &Build) -> Builder {\n         let (kind, paths) = match build.config.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n             Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n@@ -379,33 +391,40 @@ impl<'a> Builder<'a> {\n             Subcommand::Clean { .. } => panic!(),\n         };\n \n-        if let Some(path) = paths.get(0) {\n-            if path == Path::new(\"nonexistent/path/to/trigger/cargo/metadata\") {\n-                return;\n-            }\n-        }\n-\n         let builder = Builder {\n             build,\n             top_stage: build.config.stage.unwrap_or(2),\n             kind,\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n             time_spent_on_dependencies: Cell::new(Duration::new(0, 0)),\n+            paths: paths.to_owned(),\n+            graph_nodes: RefCell::new(HashMap::new()),\n+            graph: RefCell::new(Graph::new()),\n+            parent: Cell::new(None),\n         };\n \n         if kind == Kind::Dist {\n-            assert!(!build.config.test_miri, \"Do not distribute with miri enabled.\\n\\\n+            assert!(!builder.config.test_miri, \"Do not distribute with miri enabled.\\n\\\n                 The distributed libraries would include all MIR (increasing binary size).\n                 The distributed MIR would include validation statements.\");\n         }\n \n-        StepDescription::run(&Builder::get_step_descriptions(builder.kind), &builder, paths);\n+        builder\n+    }\n+\n+    pub fn execute_cli(&self) -> Graph<String, bool> {\n+        self.run_step_descriptions(&Builder::get_step_descriptions(self.kind), &self.paths);\n+        self.graph.borrow().clone()\n     }\n \n     pub fn default_doc(&self, paths: Option<&[PathBuf]>) {\n         let paths = paths.unwrap_or(&[]);\n-        StepDescription::run(&Builder::get_step_descriptions(Kind::Doc), self, paths);\n+        self.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), paths);\n+    }\n+\n+    fn run_step_descriptions(&self, v: &[StepDescription], paths: &[PathBuf]) {\n+        StepDescription::run(v, self, paths);\n     }\n \n     /// Obtain a compiler at a given stage and for a given host. Explicitly does\n@@ -828,12 +847,37 @@ impl<'a> Builder<'a> {\n             if let Some(out) = self.cache.get(&step) {\n                 self.build.verbose(&format!(\"{}c {:?}\", \"  \".repeat(stack.len()), step));\n \n+                {\n+                    let mut graph = self.graph.borrow_mut();\n+                    let parent = self.parent.get();\n+                    let us = *self.graph_nodes.borrow_mut()\n+                        .entry(format!(\"{:?}\", step))\n+                        .or_insert_with(|| graph.add_node(format!(\"{:?}\", step)));\n+                    if let Some(parent) = parent {\n+                        graph.add_edge(parent, us, false);\n+                    }\n+                }\n+\n                 return out;\n             }\n             self.build.verbose(&format!(\"{}> {:?}\", \"  \".repeat(stack.len()), step));\n             stack.push(Box::new(step.clone()));\n         }\n \n+        let prev_parent = self.parent.get();\n+\n+        {\n+            let mut graph = self.graph.borrow_mut();\n+            let parent = self.parent.get();\n+            let us = *self.graph_nodes.borrow_mut()\n+                .entry(format!(\"{:?}\", step))\n+                .or_insert_with(|| graph.add_node(format!(\"{:?}\", step)));\n+            self.parent.set(Some(us));\n+            if let Some(parent) = parent {\n+                graph.add_edge(parent, us, true);\n+            }\n+        }\n+\n         let (out, dur) = {\n             let start = Instant::now();\n             let zero = Duration::new(0, 0);\n@@ -844,6 +888,8 @@ impl<'a> Builder<'a> {\n             (out, dur - deps)\n         };\n \n+        self.parent.set(prev_parent);\n+\n         if self.build.config.print_step_timings && dur > Duration::from_millis(100) {\n             println!(\"[TIMING] {:?} -- {}.{:03}\",\n                      step,\n@@ -861,3 +907,483 @@ impl<'a> Builder<'a> {\n         out\n     }\n }\n+\n+#[cfg(test)]\n+mod __test {\n+    use config::Config;\n+    use std::thread;\n+    use super::*;\n+\n+    fn configure(host: &[&str], target: &[&str]) -> Config {\n+        let mut config = Config::default_opts();\n+        // don't save toolstates\n+        config.save_toolstates = None;\n+        config.run_host_only = true;\n+        config.dry_run = true;\n+        // try to avoid spurious failures in dist where we create/delete each others file\n+        let dir = config.out.join(\"tmp-rustbuild-tests\")\n+            .join(&thread::current().name().unwrap_or(\"unknown\").replace(\":\", \"-\"));\n+        t!(fs::create_dir_all(&dir));\n+        config.out = dir;\n+        config.build = INTERNER.intern_str(\"A\");\n+        config.hosts = vec![config.build].clone().into_iter()\n+            .chain(host.iter().map(|s| INTERNER.intern_str(s))).collect::<Vec<_>>();\n+        config.targets = config.hosts.clone().into_iter()\n+            .chain(target.iter().map(|s| INTERNER.intern_str(s))).collect::<Vec<_>>();\n+        config\n+    }\n+\n+    fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n+        v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n+    }\n+\n+    #[test]\n+    fn dist_baseline() {\n+        let build = Build::new(configure(&[], &[]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_targets() {\n+        let build = Build::new(configure(&[], &[\"B\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_targets_and_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+            dist::Docs { stage: 2, host: c },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+            dist::Mingw { host: c },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_target_flag() {\n+        let mut config = configure(&[\"B\"], &[\"C\"]);\n+        config.run_host_only = false; // as-if --target=C was passed\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+            dist::Docs { stage: 2, host: c },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+            dist::Mingw { host: c },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n+    }\n+\n+    #[test]\n+    fn dist_with_same_targets_and_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n+            dist::Docs { stage: 2, host: a },\n+            dist::Docs { stage: 2, host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n+            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(first(builder.cache.all::<compile::Std>()), &[\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<compile::Assemble>()), &[\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 0 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 2 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 2 },\n+            },\n+        ]);\n+    }\n+\n+    #[test]\n+    fn build_default() {\n+        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert!(!builder.cache.all::<compile::Std>().is_empty());\n+        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+        assert_eq!(first(builder.cache.all::<compile::Rustc>()), &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+        ]);\n+\n+        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]);\n+    }\n+\n+    #[test]\n+    fn build_with_target_flag() {\n+        let mut config = configure(&[\"B\"], &[\"C\"]);\n+        config.run_host_only = false;\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert!(!builder.cache.all::<compile::Std>().is_empty());\n+        assert_eq!(first(builder.cache.all::<compile::Assemble>()), &[\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 0 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 2 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 2 },\n+            },\n+        ]);\n+        assert_eq!(first(builder.cache.all::<compile::Rustc>()), &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]);\n+\n+        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]);\n+    }\n+}"}, {"sha": "d81c6bc28e52705f06c463ad55b0b137eb7fa2e6", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -21,6 +21,7 @@ use std::mem;\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::sync::Mutex;\n+use std::cmp::{PartialOrd, Ord, Ordering};\n \n use builder::Step;\n \n@@ -154,6 +155,19 @@ impl AsRef<OsStr> for Interned<String> {\n     }\n }\n \n+impl PartialOrd<Interned<String>> for Interned<String> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        let l = INTERNER.strs.lock().unwrap();\n+        l.get(*self).partial_cmp(l.get(*other))\n+    }\n+}\n+\n+impl Ord for Interned<String> {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        let l = INTERNER.strs.lock().unwrap();\n+        l.get(*self).cmp(l.get(*other))\n+    }\n+}\n \n struct TyIntern<T> {\n     items: Vec<T>,\n@@ -264,4 +278,16 @@ impl Cache {\n                         .expect(\"invalid type mapped\");\n         stepcache.get(step).cloned()\n     }\n+\n+    #[cfg(test)]\n+    pub fn all<S: Ord + Copy + Step>(&mut self) -> Vec<(S, S::Output)> {\n+        let cache = self.0.get_mut();\n+        let type_id = TypeId::of::<S>();\n+        let mut v = cache.remove(&type_id)\n+            .map(|b| b.downcast::<HashMap<S, S::Output>>().expect(\"correct type\"))\n+            .map(|m| m.into_iter().collect::<Vec<_>>())\n+            .unwrap_or_default();\n+        v.sort_by_key(|&(a, _)| a);\n+        v\n+    }\n }"}, {"sha": "a39fad67ebea4ac967bffe828dd8d39c7375b624", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -53,7 +53,7 @@ impl Step for Std {\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &libstd_stamp(build, compiler, target));\n     }\n }\n \n@@ -102,7 +102,7 @@ impl Step for Rustc {\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&libdir, &librustc_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &librustc_stamp(build, compiler, target));\n     }\n }\n \n@@ -143,7 +143,7 @@ impl Step for Test {\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n-        add_to_sysroot(&libdir, &libtest_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &libtest_stamp(build, compiler, target));\n     }\n }\n "}, {"sha": "da57881202d17af8b09a92210d2edb3eb1c82ef5", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 57, "deletions": 43, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -30,15 +30,15 @@ use build_helper::{output, mtime, up_to_date};\n use filetime::FileTime;\n use serde_json;\n \n-use util::{exe, libdir, is_dylib, copy, read_stamp_file, CiEnv};\n+use util::{exe, libdir, is_dylib, CiEnv};\n use {Build, Compiler, Mode};\n use native;\n use tool;\n \n use cache::{INTERNER, Interned};\n use builder::{Step, RunConfig, ShouldRun, Builder};\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Std {\n     pub target: Interned<String>,\n     pub compiler: Compiler,\n@@ -77,7 +77,7 @@ impl Step for Std {\n                 compiler: from,\n                 target,\n             });\n-            println!(\"Uplifting stage1 std ({} -> {})\", from.host, target);\n+            builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", from.host, target));\n \n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the musl startup objects.\n@@ -105,8 +105,8 @@ impl Step for Std {\n         std_cargo(builder, &compiler, target, &mut cargo);\n \n         let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n-        println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target);\n+        build.info(&format!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n+                &compiler.host, target));\n         run_cargo(build,\n                   &mut cargo,\n                   &libstd_stamp(build, compiler, target),\n@@ -130,7 +130,7 @@ fn copy_musl_third_party_objects(build: &Build,\n                                  target: Interned<String>,\n                                  into: &Path) {\n     for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-        copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n+        build.copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n     }\n }\n \n@@ -213,20 +213,20 @@ impl Step for StdLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        println!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n+        build.info(&format!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n                 target_compiler.stage,\n                 compiler.stage,\n                 &compiler.host,\n                 target_compiler.host,\n-                target);\n+                target));\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n-        add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n+        add_to_sysroot(&build, &libdir, &libstd_stamp(build, compiler, target));\n \n         if build.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n             // The sanitizers are only built in stage1 or above, so the dylibs will\n             // be missing in stage0 and causes panic. See the `std()` function above\n             // for reason why the sanitizers are not built in stage0.\n-            copy_apple_sanitizer_dylibs(&build.native_dir(target), \"osx\", &libdir);\n+            copy_apple_sanitizer_dylibs(&build, &build.native_dir(target), \"osx\", &libdir);\n         }\n \n         builder.ensure(tool::CleanTools {\n@@ -237,15 +237,15 @@ impl Step for StdLink {\n     }\n }\n \n-fn copy_apple_sanitizer_dylibs(native_dir: &Path, platform: &str, into: &Path) {\n+fn copy_apple_sanitizer_dylibs(build: &Build, native_dir: &Path, platform: &str, into: &Path) {\n     for &sanitizer in &[\"asan\", \"tsan\"] {\n         let filename = format!(\"libclang_rt.{}_{}_dynamic.dylib\", sanitizer, platform);\n         let mut src_path = native_dir.join(sanitizer);\n         src_path.push(\"build\");\n         src_path.push(\"lib\");\n         src_path.push(\"darwin\");\n         src_path.push(&filename);\n-        copy(&src_path, &into.join(filename));\n+        build.copy(&src_path, &into.join(filename));\n     }\n }\n \n@@ -301,23 +301,23 @@ impl Step for StartupObjects {\n                             .arg(src_file));\n             }\n \n-            copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n+            build.copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n         }\n \n         for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n             let src = compiler_file(build,\n                                     build.cc(target),\n                                     target,\n                                     obj);\n-            copy(&src, &sysroot_dir.join(obj));\n+            build.copy(&src, &sysroot_dir.join(obj));\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Test {\n-    pub compiler: Compiler,\n     pub target: Interned<String>,\n+    pub compiler: Compiler,\n }\n \n impl Step for Test {\n@@ -352,7 +352,7 @@ impl Step for Test {\n                 compiler: builder.compiler(1, build.build),\n                 target,\n             });\n-            println!(\"Uplifting stage1 test ({} -> {})\", &build.build, target);\n+            build.info(&format!(\"Uplifting stage1 test ({} -> {})\", &build.build, target));\n             builder.ensure(TestLink {\n                 compiler: builder.compiler(1, build.build),\n                 target_compiler: compiler,\n@@ -367,8 +367,8 @@ impl Step for Test {\n         test_cargo(build, &compiler, target, &mut cargo);\n \n         let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n-        println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target);\n+        build.info(&format!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n+                &compiler.host, target));\n         run_cargo(build,\n                   &mut cargo,\n                   &libtest_stamp(build, compiler, target),\n@@ -414,13 +414,13 @@ impl Step for TestLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        println!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n+        build.info(&format!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n                 target_compiler.stage,\n                 compiler.stage,\n                 &compiler.host,\n                 target_compiler.host,\n-                target);\n-        add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n+                target));\n+        add_to_sysroot(&build, &builder.sysroot_libdir(target_compiler, target),\n                     &libtest_stamp(build, compiler, target));\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n@@ -430,10 +430,10 @@ impl Step for TestLink {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n-    pub compiler: Compiler,\n     pub target: Interned<String>,\n+    pub compiler: Compiler,\n }\n \n impl Step for Rustc {\n@@ -469,7 +469,7 @@ impl Step for Rustc {\n                 compiler: builder.compiler(1, build.build),\n                 target,\n             });\n-            println!(\"Uplifting stage1 rustc ({} -> {})\", &build.build, target);\n+            build.info(&format!(\"Uplifting stage1 rustc ({} -> {})\", &build.build, target));\n             builder.ensure(RustcLink {\n                 compiler: builder.compiler(1, build.build),\n                 target_compiler: compiler,\n@@ -491,8 +491,8 @@ impl Step for Rustc {\n         rustc_cargo(build, &mut cargo);\n \n         let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n-        println!(\"Building stage{} compiler artifacts ({} -> {})\",\n-                 compiler.stage, &compiler.host, target);\n+        build.info(&format!(\"Building stage{} compiler artifacts ({} -> {})\",\n+                 compiler.stage, &compiler.host, target));\n         run_cargo(build,\n                   &mut cargo,\n                   &librustc_stamp(build, compiler, target),\n@@ -569,13 +569,13 @@ impl Step for RustcLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        println!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n+        build.info(&format!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n                  target_compiler.stage,\n                  compiler.stage,\n                  &compiler.host,\n                  target_compiler.host,\n-                 target);\n-        add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n+                 target));\n+        add_to_sysroot(&build, &builder.sysroot_libdir(target_compiler, target),\n                        &librustc_stamp(build, compiler, target));\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n@@ -648,8 +648,8 @@ impl Step for CodegenBackend {\n                     features.push_str(\" emscripten\");\n                 }\n \n-                println!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n-                         compiler.stage, &compiler.host, target, self.backend);\n+                build.info(&format!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n+                         compiler.stage, &compiler.host, target, self.backend));\n \n                 // Pass down configuration from the LLVM build into the build of\n                 // librustc_llvm and librustc_trans.\n@@ -690,6 +690,9 @@ impl Step for CodegenBackend {\n                               cargo.arg(\"--features\").arg(features),\n                               &tmp_stamp,\n                               false);\n+        if builder.config.dry_run {\n+            return;\n+        }\n         let mut files = files.into_iter()\n             .filter(|f| {\n                 let filename = f.file_name().unwrap().to_str().unwrap();\n@@ -733,6 +736,10 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n     let dst = builder.sysroot_codegen_backends(target_compiler);\n     t!(fs::create_dir_all(&dst));\n \n+    if builder.config.dry_run {\n+        return;\n+    }\n+\n     for backend in builder.config.rust_codegen_backends.iter() {\n         let stamp = codegen_backend_stamp(build, compiler, target, *backend);\n         let mut dylib = String::new();\n@@ -748,7 +755,7 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n                     backend,\n                     &filename[dot..])\n         };\n-        copy(&file, &dst.join(target_filename));\n+        build.copy(&file, &dst.join(target_filename));\n     }\n }\n \n@@ -764,7 +771,7 @@ fn copy_lld_to_sysroot(builder: &Builder,\n     t!(fs::create_dir_all(&dst));\n \n     let exe = exe(\"lld\", &target);\n-    copy(&lld_install_root.join(\"bin\").join(&exe), &dst.join(&exe));\n+    builder.copy(&lld_install_root.join(\"bin\").join(&exe), &dst.join(&exe));\n }\n \n /// Cargo's output path for the standard library in a given stage, compiled\n@@ -836,7 +843,7 @@ impl Step for Sysroot {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, PartialOrd, Ord, Clone, PartialEq, Eq, Hash)]\n pub struct Assemble {\n     /// The compiler which we will produce in this step. Assemble itself will\n     /// take care of ensuring that the necessary prerequisites to do so exist,\n@@ -926,17 +933,17 @@ impl Step for Assemble {\n \n         let stage = target_compiler.stage;\n         let host = target_compiler.host;\n-        println!(\"Assembling stage{} compiler ({})\", stage, host);\n+        build.info(&format!(\"Assembling stage{} compiler ({})\", stage, host));\n \n         // Link in all dylibs to the libdir\n         let sysroot = builder.sysroot(target_compiler);\n         let sysroot_libdir = sysroot.join(libdir(&*host));\n         t!(fs::create_dir_all(&sysroot_libdir));\n         let src_libdir = builder.sysroot_libdir(build_compiler, host);\n-        for f in t!(fs::read_dir(&src_libdir)).map(|f| t!(f)) {\n+        for f in builder.read_dir(&src_libdir) {\n             let filename = f.file_name().into_string().unwrap();\n             if is_dylib(&filename) {\n-                copy(&f.path(), &sysroot_libdir.join(&filename));\n+                builder.copy(&f.path(), &sysroot_libdir.join(&filename));\n             }\n         }\n \n@@ -954,7 +961,7 @@ impl Step for Assemble {\n         t!(fs::create_dir_all(&bindir));\n         let compiler = builder.rustc(target_compiler);\n         let _ = fs::remove_file(&compiler);\n-        copy(&rustc, &compiler);\n+        builder.copy(&rustc, &compiler);\n \n         target_compiler\n     }\n@@ -964,10 +971,10 @@ impl Step for Assemble {\n ///\n /// For a particular stage this will link the file listed in `stamp` into the\n /// `sysroot_dst` provided.\n-pub fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n+pub fn add_to_sysroot(build: &Build, sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n-    for path in read_stamp_file(stamp) {\n-        copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n+    for path in build.read_stamp_file(stamp) {\n+        build.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n     }\n }\n \n@@ -997,6 +1004,10 @@ fn stderr_isatty() -> bool {\n pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: bool)\n     -> Vec<PathBuf>\n {\n+    if build.config.dry_run {\n+        return Vec::new();\n+    }\n+\n     // `target_root_dir` looks like $dir/$target/release\n     let target_root_dir = stamp.parent().unwrap();\n     // `target_deps_dir` looks like $dir/$target/release/deps\n@@ -1138,6 +1149,9 @@ pub fn stream_cargo(\n     cargo: &mut Command,\n     cb: &mut FnMut(CargoMessage),\n ) -> bool {\n+    if build.config.dry_run {\n+        return true;\n+    }\n     // Instruct Cargo to give us json messages on stdout, critically leaving\n     // stderr as piped so we can get those pretty colors.\n     cargo.arg(\"--message-format\").arg(\"json\")\n@@ -1172,7 +1186,7 @@ pub fn stream_cargo(\n     // Make sure Cargo actually succeeded after we read all of its stdout.\n     let status = t!(child.wait());\n     if !status.success() {\n-        println!(\"command did not execute successfully: {:?}\\n\\\n+        eprintln!(\"command did not execute successfully: {:?}\\n\\\n                   expected success, got: {}\",\n                  cargo,\n                  status);"}, {"sha": "76672df5c570deeeccd747d9c809c56839dabe29", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -15,7 +15,7 @@\n \n use std::collections::{HashMap, HashSet};\n use std::env;\n-use std::fs::File;\n+use std::fs::{self, File};\n use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n use std::process;\n@@ -69,6 +69,7 @@ pub struct Config {\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n     pub incremental: bool,\n+    pub dry_run: bool,\n \n     // llvm codegen options\n     pub llvm_enabled: bool,\n@@ -143,6 +144,7 @@ pub struct Config {\n     // These are either the stage0 downloaded binaries or the locally installed ones.\n     pub initial_cargo: PathBuf,\n     pub initial_rustc: PathBuf,\n+    pub out: PathBuf,\n }\n \n /// Per-target configuration stored in the global configuration structure.\n@@ -317,11 +319,8 @@ struct TomlTarget {\n }\n \n impl Config {\n-    pub fn parse(args: &[String]) -> Config {\n-        let flags = Flags::parse(&args);\n-        let file = flags.config.clone();\n+    pub fn default_opts() -> Config {\n         let mut config = Config::default();\n-        config.exclude = flags.exclude;\n         config.llvm_enabled = true;\n         config.llvm_optimize = true;\n         config.llvm_version_check = true;\n@@ -341,15 +340,38 @@ impl Config {\n         config.rust_codegen_backends = vec![INTERNER.intern_str(\"llvm\")];\n         config.rust_codegen_backends_dir = \"codegen-backends\".to_owned();\n \n+        // set by bootstrap.py\n+        config.src = env::var_os(\"SRC\").map(PathBuf::from).expect(\"'SRC' to be set\");\n+        config.build = INTERNER.intern_str(&env::var(\"BUILD\").expect(\"'BUILD' to be set\"));\n+        config.out = env::var_os(\"BUILD_DIR\").map(PathBuf::from).expect(\"'BUILD_DIR' set\");\n+\n+        let stage0_root = config.out.join(&config.build).join(\"stage0/bin\");\n+        config.initial_rustc = stage0_root.join(exe(\"rustc\", &config.build));\n+        config.initial_cargo = stage0_root.join(exe(\"cargo\", &config.build));\n+\n+        config\n+    }\n+\n+    pub fn parse(args: &[String]) -> Config {\n+        let flags = Flags::parse(&args);\n+        let file = flags.config.clone();\n+        let mut config = Config::default_opts();\n+        config.exclude = flags.exclude;\n         config.rustc_error_format = flags.rustc_error_format;\n         config.on_fail = flags.on_fail;\n         config.stage = flags.stage;\n-        config.src = flags.src;\n         config.jobs = flags.jobs;\n         config.cmd = flags.cmd;\n         config.incremental = flags.incremental;\n+        config.dry_run = flags.dry_run;\n         config.keep_stage = flags.keep_stage;\n \n+        if config.dry_run {\n+            let dir = config.out.join(\"tmp-dry-run\");\n+            t!(fs::create_dir_all(&dir));\n+            config.out = dir;\n+        }\n+\n         // If --target was specified but --host wasn't specified, don't run any host-only tests.\n         config.run_host_only = !(flags.host.is_empty() && !flags.target.is_empty());\n \n@@ -368,12 +390,7 @@ impl Config {\n         }).unwrap_or_else(|| TomlConfig::default());\n \n         let build = toml.build.clone().unwrap_or(Build::default());\n-        set(&mut config.build, build.build.clone().map(|x| INTERNER.intern_string(x)));\n-        set(&mut config.build, flags.build);\n-        if config.build.is_empty() {\n-            // set by bootstrap.py\n-            config.build = INTERNER.intern_str(&env::var(\"BUILD\").unwrap());\n-        }\n+        // set by bootstrap.py\n         config.hosts.push(config.build.clone());\n         for host in build.host.iter() {\n             let host = INTERNER.intern_str(host);\n@@ -514,13 +531,13 @@ impl Config {\n                 let mut target = Target::default();\n \n                 if let Some(ref s) = cfg.llvm_config {\n-                    target.llvm_config = Some(env::current_dir().unwrap().join(s));\n+                    target.llvm_config = Some(config.src.join(s));\n                 }\n                 if let Some(ref s) = cfg.jemalloc {\n-                    target.jemalloc = Some(env::current_dir().unwrap().join(s));\n+                    target.jemalloc = Some(config.src.join(s));\n                 }\n                 if let Some(ref s) = cfg.android_ndk {\n-                    target.ndk = Some(env::current_dir().unwrap().join(s));\n+                    target.ndk = Some(config.src.join(s));\n                 }\n                 target.cc = cfg.cc.clone().map(PathBuf::from);\n                 target.cxx = cfg.cxx.clone().map(PathBuf::from);\n@@ -541,22 +558,12 @@ impl Config {\n             set(&mut config.rust_dist_src, t.src_tarball);\n         }\n \n-        let cwd = t!(env::current_dir());\n-        let out = cwd.join(\"build\");\n-\n-        let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n-        config.initial_rustc = match build.rustc {\n-            Some(s) => PathBuf::from(s),\n-            None => stage0_root.join(exe(\"rustc\", &config.build)),\n-        };\n-        config.initial_cargo = match build.cargo {\n-            Some(s) => PathBuf::from(s),\n-            None => stage0_root.join(exe(\"cargo\", &config.build)),\n-        };\n-\n         // Now that we've reached the end of our configuration, infer the\n         // default values for all options that we haven't otherwise stored yet.\n \n+        set(&mut config.initial_rustc, build.rustc.map(PathBuf::from));\n+        set(&mut config.initial_rustc, build.cargo.map(PathBuf::from));\n+\n         let default = false;\n         config.llvm_assertions = llvm_assertions.unwrap_or(default);\n "}, {"sha": "c9be17ff1ad2d2277049a9dbe1fcd4e6837c801e", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 141, "deletions": 168, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -20,15 +20,15 @@\n \n use std::env;\n use std::fs::{self, File};\n-use std::io::{self, Read, Write};\n+use std::io::{Read, Write};\n use std::path::{PathBuf, Path};\n use std::process::{Command, Stdio};\n \n use build_helper::output;\n \n use {Build, Compiler, Mode};\n use channel;\n-use util::{cp_r, libdir, is_dylib, cp_filtered, copy, replace_in_file, exe};\n+use util::{libdir, is_dylib, exe};\n use builder::{Builder, RunConfig, ShouldRun, Step};\n use compile;\n use native;\n@@ -61,7 +61,7 @@ fn rust_installer(builder: &Builder) -> Command {\n     builder.tool_cmd(Tool::RustInstaller)\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Docs {\n     pub stage: u32,\n     pub host: Interned<String>,\n@@ -89,9 +89,9 @@ impl Step for Docs {\n \n         let name = pkgname(build, \"rust-docs\");\n \n-        println!(\"Dist docs ({})\", host);\n+        build.info(&format!(\"Dist docs ({})\", host));\n         if !build.config.docs {\n-            println!(\"\\tskipping - docs disabled\");\n+            build.info(&format!(\"\\tskipping - docs disabled\"));\n             return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n         }\n \n@@ -103,7 +103,7 @@ impl Step for Docs {\n         let dst = image.join(\"share/doc/rust/html\");\n         t!(fs::create_dir_all(&dst));\n         let src = build.doc_out(host);\n-        cp_r(&src, &dst);\n+        build.cp_r(&src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -118,7 +118,7 @@ impl Step for Docs {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--bulk-dirs=share/doc/rust/html\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n \n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, host))\n     }\n@@ -152,9 +152,9 @@ impl Step for RustcDocs {\n \n         let name = pkgname(build, \"rustc-docs\");\n \n-        println!(\"Dist compiler docs ({})\", host);\n+        build.info(&format!(\"Dist compiler docs ({})\", host));\n         if !build.config.compiler_docs {\n-            println!(\"\\tskipping - compiler docs disabled\");\n+            build.info(&format!(\"\\tskipping - compiler docs disabled\"));\n             return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n         }\n \n@@ -166,7 +166,7 @@ impl Step for RustcDocs {\n         let dst = image.join(\"share/doc/rust/html\");\n         t!(fs::create_dir_all(&dst));\n         let src = build.compiler_doc_out(host);\n-        cp_r(&src, &dst);\n+        build.cp_r(&src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -181,7 +181,7 @@ impl Step for RustcDocs {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--bulk-dirs=share/doc/rust/html\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n \n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, host))\n     }\n@@ -292,37 +292,31 @@ fn make_win_dist(\n     let rustc_dlls = find_files(&rustc_dlls, &bin_path);\n     let target_libs = find_files(&target_libs, &lib_path);\n \n-    fn copy_to_folder(src: &Path, dest_folder: &Path) {\n-        let file_name = src.file_name().unwrap();\n-        let dest = dest_folder.join(file_name);\n-        copy(src, &dest);\n-    }\n-\n-    //Copy runtime dlls next to rustc.exe\n+    // Copy runtime dlls next to rustc.exe\n     let dist_bin_dir = rust_root.join(\"bin/\");\n     fs::create_dir_all(&dist_bin_dir).expect(\"creating dist_bin_dir failed\");\n     for src in rustc_dlls {\n-        copy_to_folder(&src, &dist_bin_dir);\n+        build.copy_to_folder(&src, &dist_bin_dir);\n     }\n \n     //Copy platform tools to platform-specific bin directory\n     let target_bin_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"bin\");\n     fs::create_dir_all(&target_bin_dir).expect(\"creating target_bin_dir failed\");\n     for src in target_tools {\n-        copy_to_folder(&src, &target_bin_dir);\n+        build.copy_to_folder(&src, &target_bin_dir);\n     }\n \n     //Copy platform libs to platform-specific lib directory\n     let target_lib_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\");\n     fs::create_dir_all(&target_lib_dir).expect(\"creating target_lib_dir failed\");\n     for src in target_libs {\n-        copy_to_folder(&src, &target_lib_dir);\n+        build.copy_to_folder(&src, &target_lib_dir);\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Mingw {\n-    host: Interned<String>,\n+    pub host: Interned<String>,\n }\n \n impl Step for Mingw {\n@@ -349,7 +343,7 @@ impl Step for Mingw {\n             return None;\n         }\n \n-        println!(\"Dist mingw ({})\", host);\n+        build.info(&format!(\"Dist mingw ({})\", host));\n         let name = pkgname(build, \"rust-mingw\");\n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n@@ -378,7 +372,7 @@ impl Step for Mingw {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustc {\n     pub compiler: Compiler,\n }\n@@ -404,7 +398,7 @@ impl Step for Rustc {\n         let compiler = self.compiler;\n         let host = self.compiler.host;\n \n-        println!(\"Dist rustc stage{} ({})\", compiler.stage, compiler.host);\n+        build.info(&format!(\"Dist rustc stage{} ({})\", compiler.stage, compiler.host));\n         let name = pkgname(build, \"rustc\");\n         let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n@@ -417,17 +411,17 @@ impl Step for Rustc {\n         // Prepare the overlay which is part of the tarball but won't actually be\n         // installed\n         let cp = |file: &str| {\n-            install(&build.src.join(file), &overlay, 0o644);\n+            build.install(&build.src.join(file), &overlay, 0o644);\n         };\n         cp(\"COPYRIGHT\");\n         cp(\"LICENSE-APACHE\");\n         cp(\"LICENSE-MIT\");\n         cp(\"README.md\");\n         // tiny morsel of metadata is used by rust-packaging\n         let version = build.rust_version();\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create(&overlay.join(\"version\"), &version);\n         if let Some(sha) = build.rust_sha() {\n-            t!(t!(File::create(overlay.join(\"git-commit-hash\"))).write_all(sha.as_bytes()));\n+            build.create(&overlay.join(\"git-commit-hash\"), &sha);\n         }\n \n         // On MinGW we've got a few runtime DLL dependencies that we need to\n@@ -445,7 +439,7 @@ impl Step for Rustc {\n \n             let dst = image.join(\"share/doc\");\n             t!(fs::create_dir_all(&dst));\n-            cp_r(&build.src.join(\"src/etc/third-party\"), &dst);\n+            build.cp_r(&build.src.join(\"src/etc/third-party\"), &dst);\n         }\n \n         // Finally, wrap everything up in a nice tarball!\n@@ -462,8 +456,8 @@ impl Step for Rustc {\n            .arg(\"--component-name=rustc\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n-        t!(fs::remove_dir_all(&overlay));\n+        build.remove_dir(&image);\n+        build.remove_dir(&overlay);\n \n         return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n \n@@ -475,17 +469,17 @@ impl Step for Rustc {\n \n             // Copy rustc/rustdoc binaries\n             t!(fs::create_dir_all(image.join(\"bin\")));\n-            cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n+            build.cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n \n-            install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n+            build.install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n \n             // Copy runtime DLLs needed by the compiler\n             if libdir != \"bin\" {\n-                for entry in t!(src.join(libdir).read_dir()).map(|e| t!(e)) {\n+                for entry in build.read_dir(&src.join(libdir)) {\n                     let name = entry.file_name();\n                     if let Some(s) = name.to_str() {\n                         if is_dylib(s) {\n-                            install(&entry.path(), &image.join(libdir), 0o644);\n+                            build.install(&entry.path(), &image.join(libdir), 0o644);\n                         }\n                     }\n                 }\n@@ -496,7 +490,7 @@ impl Step for Rustc {\n             let backends_rel = backends_src.strip_prefix(&src).unwrap();\n             let backends_dst = image.join(&backends_rel);\n             t!(fs::create_dir_all(&backends_dst));\n-            cp_r(&backends_src, &backends_dst);\n+            build.cp_r(&backends_src, &backends_dst);\n \n             // Copy over lld if it's there\n             if builder.config.lld_enabled {\n@@ -511,7 +505,7 @@ impl Step for Rustc {\n                     .join(\"bin\")\n                     .join(&exe);\n                 t!(fs::create_dir_all(&dst.parent().unwrap()));\n-                copy(&src, &dst);\n+                build.copy(&src, &dst);\n             }\n \n             // Man pages\n@@ -521,13 +515,12 @@ impl Step for Rustc {\n             let month_year = t!(time::strftime(\"%B %Y\", &time::now()));\n             // don't use our `bootstrap::util::{copy, cp_r}`, because those try\n             // to hardlink, and we don't want to edit the source templates\n-            for entry_result in t!(fs::read_dir(man_src)) {\n-                let file_entry = t!(entry_result);\n+            for file_entry in build.read_dir(&man_src) {\n                 let page_src = file_entry.path();\n                 let page_dst = man_dst.join(file_entry.file_name());\n                 t!(fs::copy(&page_src, &page_dst));\n                 // template in month/year and version number\n-                replace_in_file(&page_dst,\n+                build.replace_in_file(&page_dst,\n                                 &[(\"<INSERT DATE HERE>\", &month_year),\n                                   (\"<INSERT VERSION HERE>\", channel::CFG_RELEASE_NUM)]);\n             }\n@@ -540,7 +533,7 @@ impl Step for Rustc {\n \n             // Misc license info\n             let cp = |file: &str| {\n-                install(&build.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n+                build.install(&build.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n             };\n             cp(\"COPYRIGHT\");\n             cp(\"LICENSE-APACHE\");\n@@ -578,11 +571,11 @@ impl Step for DebuggerScripts {\n         let dst = sysroot.join(\"lib/rustlib/etc\");\n         t!(fs::create_dir_all(&dst));\n         let cp_debugger_script = |file: &str| {\n-            install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n+            build.install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n         };\n         if host.contains(\"windows-msvc\") {\n             // windbg debugger scripts\n-            install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n+            build.install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n                 0o755);\n \n             cp_debugger_script(\"natvis/intrinsic.natvis\");\n@@ -592,22 +585,22 @@ impl Step for DebuggerScripts {\n             cp_debugger_script(\"debugger_pretty_printers_common.py\");\n \n             // gdb debugger scripts\n-            install(&build.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n+            build.install(&build.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n                     0o755);\n \n             cp_debugger_script(\"gdb_load_rust_pretty_printers.py\");\n             cp_debugger_script(\"gdb_rust_pretty_printing.py\");\n \n             // lldb debugger scripts\n-            install(&build.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n+            build.install(&build.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n                     0o755);\n \n             cp_debugger_script(\"lldb_rust_formatters.py\");\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Std {\n     pub compiler: Compiler,\n     pub target: Interned<String>,\n@@ -634,12 +627,12 @@ impl Step for Std {\n         let target = self.target;\n \n         let name = pkgname(build, \"rust-std\");\n-        println!(\"Dist std stage{} ({} -> {})\", compiler.stage, &compiler.host, target);\n+        build.info(&format!(\"Dist std stage{} ({} -> {})\", compiler.stage, &compiler.host, target));\n \n         // The only true set of target libraries came from the build triple, so\n         // let's reduce redundant work by only producing archives from that host.\n         if compiler.host != build.build {\n-            println!(\"\\tskipping, not a build host\");\n+            build.info(&format!(\"\\tskipping, not a build host\"));\n             return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n@@ -659,7 +652,7 @@ impl Step for Std {\n         t!(fs::create_dir_all(&dst));\n         let mut src = builder.sysroot_libdir(compiler, target).to_path_buf();\n         src.pop(); // Remove the trailing /lib folder from the sysroot_libdir\n-        cp_filtered(&src, &dst, &|path| {\n+        build.cp_filtered(&src, &dst, &|path| {\n             let name = path.file_name().and_then(|s| s.to_str());\n             name != Some(build.config.rust_codegen_backends_dir.as_str()) &&\n                 name != Some(\"bin\")\n@@ -678,7 +671,7 @@ impl Step for Std {\n            .arg(format!(\"--component-name=rust-std-{}\", target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n@@ -711,11 +704,11 @@ impl Step for Analysis {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(build.config.extended);\n-        println!(\"Dist analysis\");\n+        build.info(&format!(\"Dist analysis\"));\n         let name = pkgname(build, \"rust-analysis\");\n \n         if &compiler.host != build.build {\n-            println!(\"\\tskipping, not a build host\");\n+            build.info(&format!(\"\\tskipping, not a build host\"));\n             return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n@@ -737,8 +730,8 @@ impl Step for Analysis {\n         let image_src = src.join(\"save-analysis\");\n         let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n         t!(fs::create_dir_all(&dst));\n-        println!(\"image_src: {:?}, dst: {:?}\", image_src, dst);\n-        cp_r(&image_src, &dst);\n+        build.info(&format!(\"image_src: {:?}, dst: {:?}\", image_src, dst));\n+        build.cp_r(&image_src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -752,7 +745,7 @@ impl Step for Analysis {\n            .arg(format!(\"--component-name=rust-analysis-{}\", target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n@@ -796,11 +789,11 @@ fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_di\n     for item in src_dirs {\n         let dst = &dst_dir.join(item);\n         t!(fs::create_dir_all(dst));\n-        cp_filtered(&build.src.join(item), dst, &|path| filter_fn(exclude_dirs, item, path));\n+        build.cp_filtered(&build.src.join(item), dst, &|path| filter_fn(exclude_dirs, item, path));\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Src;\n \n impl Step for Src {\n@@ -820,7 +813,7 @@ impl Step for Src {\n     /// Creates the `rust-src` installer component\n     fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n-        println!(\"Dist src\");\n+        build.info(&format!(\"Dist src\"));\n \n         let name = pkgname(build, \"rust-src\");\n         let image = tmpdir(build).join(format!(\"{}-image\", name));\n@@ -870,7 +863,7 @@ impl Step for Src {\n \n         copy_src_dirs(build, &std_src_dirs[..], &std_src_dirs_exclude[..], &dst_src);\n         for file in src_files.iter() {\n-            copy(&build.src.join(file), &dst_src.join(file));\n+            build.copy(&build.src.join(file), &dst_src.join(file));\n         }\n \n         // Create source tarball in rust-installer format\n@@ -887,14 +880,14 @@ impl Step for Src {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n \n-        t!(fs::remove_dir_all(&image));\n+        build.remove_dir(&image);\n         distdir(build).join(&format!(\"{}.tar.gz\", name))\n     }\n }\n \n const CARGO_VENDOR_VERSION: &str = \"0.1.4\";\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct PlainSourceTarball;\n \n impl Step for PlainSourceTarball {\n@@ -915,7 +908,7 @@ impl Step for PlainSourceTarball {\n     /// Creates the plain source tarball\n     fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n-        println!(\"Create plain source tarball\");\n+        build.info(&format!(\"Create plain source tarball\"));\n \n         // Make sure that the root folder of tarball has the correct name\n         let plain_name = format!(\"{}-src\", pkgname(build, \"rustc\"));\n@@ -943,13 +936,13 @@ impl Step for PlainSourceTarball {\n \n         // Copy the files normally\n         for item in &src_files {\n-            copy(&build.src.join(item), &plain_dst_src.join(item));\n+            build.copy(&build.src.join(item), &plain_dst_src.join(item));\n         }\n \n         // Create the version file\n-        write_file(&plain_dst_src.join(\"version\"), build.rust_version().as_bytes());\n+        build.create(&plain_dst_src.join(\"version\"), &build.rust_version());\n         if let Some(sha) = build.rust_sha() {\n-            write_file(&plain_dst_src.join(\"git-commit-hash\"), sha.as_bytes());\n+            build.create(&plain_dst_src.join(\"git-commit-hash\"), &sha);\n         }\n \n         // If we're building from git sources, we need to vendor a complete distribution.\n@@ -990,9 +983,9 @@ impl Step for PlainSourceTarball {\n         tarball.set_extension(\"\"); // strip .gz\n         tarball.set_extension(\"\"); // strip .tar\n         if let Some(dir) = tarball.parent() {\n-            t!(fs::create_dir_all(dir));\n+            build.create_dir(&dir);\n         }\n-        println!(\"running installer\");\n+        build.info(&format!(\"running installer\"));\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"tarball\")\n            .arg(\"--input\").arg(&plain_name)\n@@ -1004,26 +997,6 @@ impl Step for PlainSourceTarball {\n     }\n }\n \n-fn install(src: &Path, dstdir: &Path, perms: u32) {\n-    let dst = dstdir.join(src.file_name().unwrap());\n-    t!(fs::create_dir_all(dstdir));\n-    drop(fs::remove_file(&dst));\n-    {\n-        let mut s = t!(fs::File::open(&src));\n-        let mut d = t!(fs::File::create(&dst));\n-        io::copy(&mut s, &mut d).expect(\"failed to copy\");\n-    }\n-    chmod(&dst, perms);\n-}\n-\n-#[cfg(unix)]\n-fn chmod(path: &Path, perms: u32) {\n-    use std::os::unix::fs::*;\n-    t!(fs::set_permissions(path, fs::Permissions::from_mode(perms)));\n-}\n-#[cfg(windows)]\n-fn chmod(_path: &Path, _perms: u32) {}\n-\n // We have to run a few shell scripts, which choke quite a bit on both `\\`\n // characters and on `C:\\` paths, so normalize both of them away.\n pub fn sanitize_sh(path: &Path) -> String {\n@@ -1043,12 +1016,7 @@ pub fn sanitize_sh(path: &Path) -> String {\n     }\n }\n \n-fn write_file(path: &Path, data: &[u8]) {\n-    let mut vf = t!(fs::File::create(path));\n-    t!(vf.write_all(data));\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Cargo {\n     pub stage: u32,\n     pub target: Interned<String>,\n@@ -1074,7 +1042,7 @@ impl Step for Cargo {\n         let stage = self.stage;\n         let target = self.target;\n \n-        println!(\"Dist cargo stage{} ({})\", stage, target);\n+        build.info(&format!(\"Dist cargo stage{} ({})\", stage, target));\n         let src = build.src.join(\"src/tools/cargo\");\n         let etc = src.join(\"src/etc\");\n         let release_num = build.release_num(\"cargo\");\n@@ -1084,38 +1052,38 @@ impl Step for Cargo {\n         let tmp = tmpdir(build);\n         let image = tmp.join(\"cargo-image\");\n         drop(fs::remove_dir_all(&image));\n-        t!(fs::create_dir_all(&image));\n+        build.create_dir(&image);\n \n         // Prepare the image directory\n-        t!(fs::create_dir_all(image.join(\"share/zsh/site-functions\")));\n-        t!(fs::create_dir_all(image.join(\"etc/bash_completion.d\")));\n+        build.create_dir(&image.join(\"share/zsh/site-functions\"));\n+        build.create_dir(&image.join(\"etc/bash_completion.d\"));\n         let cargo = builder.ensure(tool::Cargo {\n             compiler: builder.compiler(stage, build.build),\n             target\n         });\n-        install(&cargo, &image.join(\"bin\"), 0o755);\n+        build.install(&cargo, &image.join(\"bin\"), 0o755);\n         for man in t!(etc.join(\"man\").read_dir()) {\n             let man = t!(man);\n-            install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n+            build.install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n         }\n-        install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n-        copy(&etc.join(\"cargo.bashcomp.sh\"),\n+        build.install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n+        build.copy(&etc.join(\"cargo.bashcomp.sh\"),\n              &image.join(\"etc/bash_completion.d/cargo\"));\n         let doc = image.join(\"share/doc/cargo\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n+        build.install(&src.join(\"README.md\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"cargo-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n-        t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create_dir(&overlay);\n+        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n+        build.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1135,7 +1103,7 @@ impl Step for Cargo {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rls {\n     pub stage: u32,\n     pub target: Interned<String>,\n@@ -1162,7 +1130,7 @@ impl Step for Rls {\n         let target = self.target;\n         assert!(build.config.extended);\n \n-        println!(\"Dist RLS stage{} ({})\", stage, target);\n+        build.info(&format!(\"Dist RLS stage{} ({})\", stage, target));\n         let src = build.src.join(\"src/tools/rls\");\n         let release_num = build.release_num(\"rls\");\n         let name = pkgname(build, \"rls\");\n@@ -1181,20 +1149,20 @@ impl Step for Rls {\n             target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build RLS, skipping dist\"); None })?;\n \n-        install(&rls, &image.join(\"bin\"), 0o755);\n+        build.install(&rls, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rls\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        build.install(&src.join(\"README.md\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"rls-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n         t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1216,7 +1184,7 @@ impl Step for Rls {\n }\n \n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustfmt {\n     pub stage: u32,\n     pub target: Interned<String>,\n@@ -1242,7 +1210,7 @@ impl Step for Rustfmt {\n         let stage = self.stage;\n         let target = self.target;\n \n-        println!(\"Dist Rustfmt stage{} ({})\", stage, target);\n+        build.info(&format!(\"Dist Rustfmt stage{} ({})\", stage, target));\n         let src = build.src.join(\"src/tools/rustfmt\");\n         let release_num = build.release_num(\"rustfmt\");\n         let name = pkgname(build, \"rustfmt\");\n@@ -1251,7 +1219,7 @@ impl Step for Rustfmt {\n         let tmp = tmpdir(build);\n         let image = tmp.join(\"rustfmt-image\");\n         drop(fs::remove_dir_all(&image));\n-        t!(fs::create_dir_all(&image));\n+        build.create_dir(&image);\n \n         // Prepare the image directory\n         let rustfmt = builder.ensure(tool::Rustfmt {\n@@ -1263,21 +1231,21 @@ impl Step for Rustfmt {\n             target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build Cargofmt, skipping dist\"); None })?;\n \n-        install(&rustfmt, &image.join(\"bin\"), 0o755);\n-        install(&cargofmt, &image.join(\"bin\"), 0o755);\n+        build.install(&rustfmt, &image.join(\"bin\"), 0o755);\n+        build.install(&cargofmt, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rustfmt\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        build.install(&src.join(\"README.md\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"rustfmt-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n-        t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create_dir(&overlay);\n+        build.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1298,7 +1266,7 @@ impl Step for Rustfmt {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Extended {\n     stage: u32,\n     host: Interned<String>,\n@@ -1329,7 +1297,7 @@ impl Step for Extended {\n         let stage = self.stage;\n         let target = self.target;\n \n-        println!(\"Dist extended stage{} ({})\", stage, target);\n+        build.info(&format!(\"Dist extended stage{} ({})\", stage, target));\n \n         let rustc_installer = builder.ensure(Rustc {\n             compiler: builder.compiler(stage, target),\n@@ -1355,15 +1323,15 @@ impl Step for Extended {\n         let work = tmp.join(\"work\");\n \n         let _ = fs::remove_dir_all(&overlay);\n-        install(&build.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n-        install(&build.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        install(&build.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        build.install(&build.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n+        build.install(&build.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        build.install(&build.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n         let version = build.rust_version();\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        build.create(&overlay.join(\"version\"), &version);\n         if let Some(sha) = build.rust_sha() {\n-            t!(t!(File::create(overlay.join(\"git-commit-hash\"))).write_all(sha.as_bytes()));\n+            build.create(&overlay.join(\"git-commit-hash\"), &sha);\n         }\n-        install(&etc.join(\"README.md\"), &overlay, 0o644);\n+        build.install(&etc.join(\"README.md\"), &overlay, 0o644);\n \n         // When rust-std package split from rustc, we needed to ensure that during\n         // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n@@ -1402,11 +1370,11 @@ impl Step for Extended {\n         build.run(&mut cmd);\n \n         let mut license = String::new();\n-        t!(t!(File::open(build.src.join(\"COPYRIGHT\"))).read_to_string(&mut license));\n+        license += &build.read(&build.src.join(\"COPYRIGHT\"));\n+        license += &build.read(&build.src.join(\"LICENSE-APACHE\"));\n+        license += &build.read(&build.src.join(\"LICENSE-MIT\"));\n         license.push_str(\"\\n\");\n-        t!(t!(File::open(build.src.join(\"LICENSE-APACHE\"))).read_to_string(&mut license));\n         license.push_str(\"\\n\");\n-        t!(t!(File::open(build.src.join(\"LICENSE-MIT\"))).read_to_string(&mut license));\n \n         let rtf = r\"{\\rtf1\\ansi\\deff0{\\fonttbl{\\f0\\fnil\\fcharset0 Arial;}}\\nowwrap\\fs18\";\n         let mut rtf = rtf.to_string();\n@@ -1463,10 +1431,10 @@ impl Step for Extended {\n             };\n \n             let prepare = |name: &str| {\n-                t!(fs::create_dir_all(pkg.join(name)));\n-                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target)),\n+                build.create_dir(&pkg.join(name));\n+                build.cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target)),\n                         &pkg.join(name));\n-                install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n+                build.install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n                 pkgbuild(name);\n             };\n             prepare(\"rustc\");\n@@ -1480,12 +1448,12 @@ impl Step for Extended {\n             }\n \n             // create an 'uninstall' package\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n+            build.install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n             pkgbuild(\"uninstall\");\n \n-            t!(fs::create_dir_all(pkg.join(\"res\")));\n-            t!(t!(File::create(pkg.join(\"res/LICENSE.txt\"))).write_all(license.as_bytes()));\n-            install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n+            build.create_dir(&pkg.join(\"res\"));\n+            build.create(&pkg.join(\"res/LICENSE.txt\"), &license);\n+            build.install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n             let mut cmd = Command::new(\"productbuild\");\n             cmd.arg(\"--distribution\").arg(xform(&etc.join(\"pkg/Distribution.xml\")))\n                 .arg(\"--resources\").arg(pkg.join(\"res\"))\n@@ -1501,18 +1469,18 @@ impl Step for Extended {\n             let _ = fs::remove_dir_all(&exe);\n \n             let prepare = |name: &str| {\n-                t!(fs::create_dir_all(exe.join(name)));\n+                build.create_dir(&exe.join(name));\n                 let dir = if name == \"rust-std\" || name == \"rust-analysis\" {\n                     format!(\"{}-{}\", name, target)\n                 } else if name == \"rls\" {\n                     \"rls-preview\".to_string()\n                 } else {\n                     name.to_string()\n                 };\n-                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target))\n+                build.cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target))\n                             .join(dir),\n                         &exe.join(name));\n-                t!(fs::remove_file(exe.join(name).join(\"manifest.in\")));\n+                build.remove(&exe.join(name).join(\"manifest.in\"));\n             };\n             prepare(\"rustc\");\n             prepare(\"cargo\");\n@@ -1526,11 +1494,11 @@ impl Step for Extended {\n                 prepare(\"rust-mingw\");\n             }\n \n-            install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n-            install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n-            install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n-            install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n-            t!(t!(File::create(exe.join(\"LICENSE.txt\"))).write_all(license.as_bytes()));\n+            build.install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n+            build.install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n+            build.install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n+            build.install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n+            build.create(&exe.join(\"LICENSE.txt\"), &license);\n \n             // Generate exe installer\n             let mut cmd = Command::new(\"iscc\");\n@@ -1541,7 +1509,7 @@ impl Step for Extended {\n             }\n             add_env(build, &mut cmd, target);\n             build.run(&mut cmd);\n-            install(&exe.join(format!(\"{}-{}.exe\", pkgname(build, \"rust\"), target)),\n+            build.install(&exe.join(format!(\"{}-{}.exe\", pkgname(build, \"rust\"), target)),\n                     &distdir(build),\n                     0o755);\n \n@@ -1665,9 +1633,9 @@ impl Step for Extended {\n                 candle(\"GccGroup.wxs\".as_ref());\n             }\n \n-            t!(t!(File::create(exe.join(\"LICENSE.rtf\"))).write_all(rtf.as_bytes()));\n-            install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n-            install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n+            build.create(&exe.join(\"LICENSE.rtf\"), &rtf);\n+            build.install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n+            build.install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n \n             let filename = format!(\"{}-{}.msi\", pkgname(build, \"rust\"), target);\n             let mut cmd = Command::new(&light);\n@@ -1697,7 +1665,9 @@ impl Step for Extended {\n \n             build.run(&mut cmd);\n \n-            t!(fs::rename(exe.join(&filename), distdir(build).join(&filename)));\n+            if !build.config.dry_run {\n+                t!(fs::rename(exe.join(&filename), distdir(build).join(&filename)));\n+            }\n         }\n     }\n }\n@@ -1731,7 +1701,7 @@ fn add_env(build: &Build, cmd: &mut Command, target: Interned<String>) {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct HashSign;\n \n impl Step for HashSign {\n@@ -1749,6 +1719,9 @@ impl Step for HashSign {\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let mut cmd = builder.tool_cmd(Tool::BuildManifest);\n+        if build.config.dry_run {\n+            return;\n+        }\n         let sign = build.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.sign-folder` in `config.toml`\\n\\n\")\n         });\n@@ -1772,7 +1745,7 @@ impl Step for HashSign {\n         cmd.arg(build.package_vers(&build.release_num(\"rustfmt\")));\n         cmd.arg(addr);\n \n-        t!(fs::create_dir_all(distdir(build)));\n+        build.create_dir(&distdir(build));\n \n         let mut child = t!(cmd.stdin(Stdio::piped()).spawn());\n         t!(child.stdin.take().unwrap().write_all(pass.as_bytes()));"}, {"sha": "f07c3e707574b4e4a051fc6e9b1f9e0950b82917", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -26,11 +26,12 @@ use std::path::{PathBuf, Path};\n use {Build, Mode};\n use build_helper::up_to_date;\n \n-use util::{cp_r, symlink_dir};\n+use util::symlink_dir;\n use builder::{Builder, Compiler, RunConfig, ShouldRun, Step};\n use tool::Tool;\n use compile;\n use cache::{INTERNER, Interned};\n+use config::Config;\n \n macro_rules! book {\n     ($($name:ident, $path:expr, $book_name:expr;)+) => {\n@@ -168,7 +169,7 @@ impl Step for CargoBook {\n \n         let out = out.join(name);\n \n-        println!(\"Cargo Book ({}) - {}\", target, name);\n+        build.info(&format!(\"Cargo Book ({}) - {}\", target, name));\n \n         let _ = fs::remove_dir_all(&out);\n \n@@ -210,12 +211,13 @@ impl Step for RustbookSrc {\n         let src = src.join(name);\n         let index = out.join(\"index.html\");\n         let rustbook = builder.tool_exe(Tool::Rustbook);\n+        let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n         if up_to_date(&src, &index) && up_to_date(&rustbook, &index) {\n             return\n         }\n-        println!(\"Rustbook ({}) - {}\", target, name);\n+        build.info(&format!(\"Rustbook ({}) - {}\", target, name));\n         let _ = fs::remove_dir_all(&out);\n-        build.run(builder.tool_cmd(Tool::Rustbook)\n+        build.run(rustbook_cmd\n                        .arg(\"build\")\n                        .arg(&src)\n                        .arg(\"-d\")\n@@ -281,11 +283,11 @@ impl Step for TheBook {\n \n         // build the index page\n         let index = format!(\"{}/index.md\", name);\n-        println!(\"Documenting book index ({})\", target);\n+        build.info(&format!(\"Documenting book index ({})\", target));\n         invoke_rustdoc(builder, compiler, target, &index);\n \n         // build the redirect pages\n-        println!(\"Documenting book redirect pages ({})\", target);\n+        build.info(&format!(\"Documenting book redirect pages ({})\", target));\n         for file in t!(fs::read_dir(build.src.join(\"src/doc/book/redirects\"))) {\n             let file = t!(file);\n             let path = file.path();\n@@ -358,7 +360,7 @@ impl Step for Standalone {\n         let build = builder.build;\n         let target = self.target;\n         let compiler = self.compiler;\n-        println!(\"Documenting standalone ({})\", target);\n+        build.info(&format!(\"Documenting standalone ({})\", target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n@@ -370,7 +372,7 @@ impl Step for Standalone {\n         let version_input = build.src.join(\"src/doc/version_info.html.template\");\n         let version_info = out.join(\"version_info.html\");\n \n-        if !up_to_date(&version_input, &version_info) {\n+        if !build.config.dry_run && !up_to_date(&version_input, &version_info) {\n             let mut info = String::new();\n             t!(t!(File::open(&version_input)).read_to_string(&mut info));\n             let info = info.replace(\"VERSION\", &build.rust_release())\n@@ -394,7 +396,7 @@ impl Step for Standalone {\n                up_to_date(&favicon, &html) &&\n                up_to_date(&full_toc, &html) &&\n                up_to_date(&version_info, &html) &&\n-               up_to_date(&rustdoc, &html) {\n+               (build.config.dry_run || up_to_date(&rustdoc, &html)) {\n                 continue\n             }\n \n@@ -449,7 +451,7 @@ impl Step for Std {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        println!(\"Documenting stage{} std ({})\", stage, target);\n+        build.info(&format!(\"Documenting stage{} std ({})\", stage, target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n@@ -479,7 +481,7 @@ impl Step for Std {\n         // will also directly handle merging.\n         let my_out = build.crate_doc_out(target);\n         build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n+        t!(symlink_dir_force(&build.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"doc\");\n         compile::std_cargo(builder, &compiler, target, &mut cargo);\n@@ -496,7 +498,7 @@ impl Step for Std {\n         }\n \n         build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+        build.cp_r(&my_out, &out);\n     }\n }\n \n@@ -530,7 +532,7 @@ impl Step for Test {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        println!(\"Documenting stage{} test ({})\", stage, target);\n+        build.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n@@ -551,12 +553,12 @@ impl Step for Test {\n         // See docs in std above for why we symlink\n         let my_out = build.crate_doc_out(target);\n         build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n+        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"doc\");\n         compile::test_cargo(build, &compiler, target, &mut cargo);\n         build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+        build.cp_r(&my_out, &out);\n     }\n }\n \n@@ -596,7 +598,7 @@ impl Step for WhitelistedRustc {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        println!(\"Documenting stage{} whitelisted compiler ({})\", stage, target);\n+        build.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n@@ -617,7 +619,7 @@ impl Step for WhitelistedRustc {\n         // See docs in std above for why we symlink\n         let my_out = build.crate_doc_out(target);\n         build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n+        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n         compile::rustc_cargo(build, &mut cargo);\n@@ -631,7 +633,7 @@ impl Step for WhitelistedRustc {\n         }\n \n         build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+        build.cp_r(&my_out, &out);\n     }\n }\n \n@@ -668,7 +670,7 @@ impl Step for Rustc {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        println!(\"Documenting stage{} compiler ({})\", stage, target);\n+        build.info(&format!(\"Documenting stage{} compiler ({})\", stage, target));\n         let out = build.compiler_doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n@@ -680,7 +682,7 @@ impl Step for Rustc {\n         };\n \n         if !build.config.compiler_docs {\n-            println!(\"\\tskipping - compiler docs disabled\");\n+            build.info(&format!(\"\\tskipping - compiler docs disabled\"));\n             return;\n         }\n \n@@ -693,7 +695,7 @@ impl Step for Rustc {\n         // We do not symlink to the same shared folder that already contains std library\n         // documentation from previous steps as we do not want to include that.\n         build.clear_if_dirty(&out, &rustdoc);\n-        t!(symlink_dir_force(&out, &out_dir));\n+        t!(symlink_dir_force(&builder.config, &out, &out_dir));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n         compile::rustc_cargo(build, &mut cargo);\n@@ -759,7 +761,7 @@ impl Step for ErrorIndex {\n         let build = builder.build;\n         let target = self.target;\n \n-        println!(\"Documenting error index ({})\", target);\n+        build.info(&format!(\"Documenting error index ({})\", target));\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let mut index = builder.tool_cmd(Tool::ErrorIndex);\n@@ -804,10 +806,10 @@ impl Step for UnstableBookGen {\n             target,\n         });\n \n-        println!(\"Generating unstable book md files ({})\", target);\n+        build.info(&format!(\"Generating unstable book md files ({})\", target));\n         let out = build.md_doc_out(target).join(\"unstable-book\");\n-        t!(fs::create_dir_all(&out));\n-        t!(fs::remove_dir_all(&out));\n+        build.create_dir(&out);\n+        build.remove_dir(&out);\n         let mut cmd = builder.tool_cmd(Tool::UnstableBookGen);\n         cmd.arg(build.src.join(\"src\"));\n         cmd.arg(out);\n@@ -816,7 +818,10 @@ impl Step for UnstableBookGen {\n     }\n }\n \n-fn symlink_dir_force(src: &Path, dst: &Path) -> io::Result<()> {\n+fn symlink_dir_force(config: &Config, src: &Path, dst: &Path) -> io::Result<()> {\n+    if config.dry_run {\n+        return Ok(());\n+    }\n     if let Ok(m) = fs::symlink_metadata(dst) {\n         if m.file_type().is_dir() {\n             try!(fs::remove_dir_all(dst));\n@@ -829,5 +834,5 @@ fn symlink_dir_force(src: &Path, dst: &Path) -> io::Result<()> {\n         }\n     }\n \n-    symlink_dir(src, dst)\n+    symlink_dir(config, src, dst)\n }"}, {"sha": "cd304fb26e0bfcb939cf226951a19c58c170d4f3", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -13,7 +13,6 @@\n //! This module implements the command-line parsing of the build system which\n //! has various flags to configure how it's run.\n \n-use std::env;\n use std::fs;\n use std::path::PathBuf;\n use std::process;\n@@ -33,17 +32,16 @@ pub struct Flags {\n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n     pub keep_stage: Option<u32>,\n-    pub build: Option<Interned<String>>,\n \n     pub host: Vec<Interned<String>>,\n     pub target: Vec<Interned<String>>,\n     pub config: Option<PathBuf>,\n-    pub src: PathBuf,\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n     pub incremental: bool,\n     pub exclude: Vec<PathBuf>,\n     pub rustc_error_format: Option<String>,\n+    pub dry_run: bool,\n }\n \n pub enum Subcommand {\n@@ -114,6 +112,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         opts.optmulti(\"\", \"target\", \"target targets to build\", \"TARGET\");\n         opts.optmulti(\"\", \"exclude\", \"build paths to exclude\", \"PATH\");\n         opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n+        opts.optflag(\"\", \"dry-run\", \"dry run; don't build anything\");\n         opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n         opts.optopt(\"\", \"keep-stage\", \"stage to keep without recompiling\", \"N\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n@@ -278,10 +277,6 @@ Arguments:\n             _ => { }\n         };\n         // Get any optional paths which occur after the subcommand\n-        let cwd = t!(env::current_dir());\n-        let src = matches.opt_str(\"src\").map(PathBuf::from)\n-            .or_else(|| env::var_os(\"SRC\").map(PathBuf::from))\n-            .unwrap_or(cwd.clone());\n         let paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n \n         let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n@@ -371,10 +366,10 @@ Arguments:\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage,\n+            dry_run: matches.opt_present(\"dry-run\"),\n             on_fail: matches.opt_str(\"on-fail\"),\n             rustc_error_format: matches.opt_str(\"error-format\"),\n             keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n-            build: matches.opt_str(\"build\").map(|s| INTERNER.intern_string(s)),\n             host: split(matches.opt_strs(\"host\"))\n                 .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n             target: split(matches.opt_strs(\"target\"))\n@@ -385,7 +380,6 @@ Arguments:\n             incremental: matches.opt_present(\"incremental\"),\n             exclude: split(matches.opt_strs(\"exclude\"))\n                 .into_iter().map(|p| p.into()).collect::<Vec<_>>(),\n-            src,\n         }\n     }\n }"}, {"sha": "4b05cac1ce6979123e0637c5169c9dd2a4b9dff4", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -63,7 +63,7 @@ fn install_sh(\n     host: Option<Interned<String>>\n ) {\n     let build = builder.build;\n-    println!(\"Install {} stage{} ({:?})\", package, stage, host);\n+    build.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n \n     let prefix_default = PathBuf::from(\"/usr/local\");\n     let sysconfdir_default = PathBuf::from(\"/etc\");\n@@ -212,15 +212,16 @@ install!((self, builder, _config),\n             Self::should_install(builder) {\n             install_rls(builder, self.stage, self.target);\n         } else {\n-            println!(\"skipping Install RLS stage{} ({})\", self.stage, self.target);\n+            builder.info(&format!(\"skipping Install RLS stage{} ({})\", self.stage, self.target));\n         }\n     };\n     Rustfmt, \"rustfmt\", Self::should_build(_config), only_hosts: true, {\n         if builder.ensure(dist::Rustfmt { stage: self.stage, target: self.target }).is_some() ||\n             Self::should_install(builder) {\n             install_rustfmt(builder, self.stage, self.target);\n         } else {\n-            println!(\"skipping Install Rustfmt stage{} ({})\", self.stage, self.target);\n+            builder.info(\n+                &format!(\"skipping Install Rustfmt stage{} ({})\", self.stage, self.target));\n         }\n     };\n     Analysis, \"analysis\", Self::should_build(_config), only_hosts: false, {"}, {"sha": "2eeb2691eaee45a427f68d944257607d894870ab", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 231, "deletions": 25, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -114,7 +114,7 @@\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n #![deny(warnings)]\n-#![feature(core_intrinsics)]\n+#![feature(conservative_impl_trait, fs_read_write, core_intrinsics)]\n #![feature(slice_concat_ext)]\n \n #[macro_use]\n@@ -131,20 +131,27 @@ extern crate getopts;\n extern crate num_cpus;\n extern crate toml;\n extern crate time;\n+extern crate petgraph;\n+\n+#[cfg(test)]\n+#[macro_use]\n+extern crate pretty_assertions;\n \n #[cfg(unix)]\n extern crate libc;\n \n use std::cell::{RefCell, Cell};\n use std::collections::{HashSet, HashMap};\n use std::env;\n-use std::fs::{self, File};\n-use std::io::Read;\n+use std::fs::{self, OpenOptions, File};\n+use std::io::{self, Seek, SeekFrom, Write, Read};\n use std::path::{PathBuf, Path};\n use std::process::{self, Command};\n use std::slice;\n+use std::str;\n \n use build_helper::{run_silent, run_suppressed, try_run_silent, try_run_suppressed, output, mtime};\n+use filetime::FileTime;\n \n use util::{exe, libdir, OutputFolder, CiEnv};\n \n@@ -198,7 +205,7 @@ use toolstate::ToolState;\n /// Each compiler has a `stage` that it is associated with and a `host` that\n /// corresponds to the platform the compiler runs on. This structure is used as\n /// a parameter to many methods below.\n-#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\n+#[derive(Eq, PartialOrd, Ord, PartialEq, Clone, Copy, Hash, Debug)]\n pub struct Compiler {\n     stage: u32,\n     host: Interned<String>,\n@@ -309,9 +316,8 @@ impl Build {\n     ///\n     /// By default all build output will be placed in the current directory.\n     pub fn new(config: Config) -> Build {\n-        let cwd = t!(env::current_dir());\n         let src = config.src.clone();\n-        let out = cwd.join(\"build\");\n+        let out = config.out.clone();\n \n         let is_sudo = match env::var_os(\"SUDO_USER\") {\n             Some(sudo_user) => {\n@@ -327,7 +333,7 @@ impl Build {\n         let rls_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rls\"));\n         let rustfmt_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rustfmt\"));\n \n-        Build {\n+        let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n             initial_cargo: config.initial_cargo.clone(),\n             local_rebuild: config.local_rebuild,\n@@ -358,7 +364,30 @@ impl Build {\n             delayed_failures: RefCell::new(Vec::new()),\n             prerelease_version: Cell::new(None),\n             tool_artifacts: Default::default(),\n+        };\n+\n+        build.verbose(\"finding compilers\");\n+        cc_detect::find(&mut build);\n+        build.verbose(\"running sanity check\");\n+        sanity::check(&mut build);\n+\n+        // If local-rust is the same major.minor as the current version, then force a\n+        // local-rebuild\n+        let local_version_verbose = output(\n+            Command::new(&build.initial_rustc).arg(\"--version\").arg(\"--verbose\"));\n+        let local_release = local_version_verbose\n+            .lines().filter(|x| x.starts_with(\"release:\"))\n+            .next().unwrap().trim_left_matches(\"release:\").trim();\n+        let my_version = channel::CFG_RELEASE_NUM;\n+        if local_release.split('.').take(2).eq(my_version.split('.').take(2)) {\n+            build.verbose(&format!(\"auto-detected local-rebuild {}\", local_release));\n+            build.local_rebuild = true;\n         }\n+\n+        build.verbose(\"learning about cargo\");\n+        metadata::build(&mut build);\n+\n+        build\n     }\n \n     pub fn build_triple(&self) -> &[Interned<String>] {\n@@ -377,25 +406,28 @@ impl Build {\n             return clean::clean(self, all);\n         }\n \n-        self.verbose(\"finding compilers\");\n-        cc_detect::find(self);\n-        self.verbose(\"running sanity check\");\n-        sanity::check(self);\n-        // If local-rust is the same major.minor as the current version, then force a local-rebuild\n-        let local_version_verbose = output(\n-            Command::new(&self.initial_rustc).arg(\"--version\").arg(\"--verbose\"));\n-        let local_release = local_version_verbose\n-            .lines().filter(|x| x.starts_with(\"release:\"))\n-            .next().unwrap().trim_left_matches(\"release:\").trim();\n-        let my_version = channel::CFG_RELEASE_NUM;\n-        if local_release.split('.').take(2).eq(my_version.split('.').take(2)) {\n-            self.verbose(&format!(\"auto-detected local-rebuild {}\", local_release));\n-            self.local_rebuild = true;\n+        {\n+            let builder = builder::Builder::new(&self);\n+            if let Some(path) = builder.paths.get(0) {\n+                if path == Path::new(\"nonexistent/path/to/trigger/cargo/metadata\") {\n+                    return;\n+                }\n+            }\n         }\n-        self.verbose(\"learning about cargo\");\n-        metadata::build(self);\n \n-        builder::Builder::run(&self);\n+        if !self.config.dry_run {\n+            {\n+                self.config.dry_run = true;\n+                let builder = builder::Builder::new(&self);\n+                builder.execute_cli();\n+            }\n+            self.config.dry_run = false;\n+            let builder = builder::Builder::new(&self);\n+            builder.execute_cli();\n+        } else {\n+            let builder = builder::Builder::new(&self);\n+            let _ = builder.execute_cli();\n+        }\n \n         // Check for postponed failures from `test --no-fail-fast`.\n         let failures = self.delayed_failures.borrow();\n@@ -586,12 +618,14 @@ impl Build {\n \n     /// Runs a command, printing out nice contextual information if it fails.\n     fn run(&self, cmd: &mut Command) {\n+        if self.config.dry_run { return; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         run_silent(cmd)\n     }\n \n     /// Runs a command, printing out nice contextual information if it fails.\n     fn run_quiet(&self, cmd: &mut Command) {\n+        if self.config.dry_run { return; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         run_suppressed(cmd)\n     }\n@@ -600,6 +634,7 @@ impl Build {\n     /// Exits if the command failed to execute at all, otherwise returns its\n     /// `status.success()`.\n     fn try_run(&self, cmd: &mut Command) -> bool {\n+        if self.config.dry_run { return true; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         try_run_silent(cmd)\n     }\n@@ -608,6 +643,7 @@ impl Build {\n     /// Exits if the command failed to execute at all, otherwise returns its\n     /// `status.success()`.\n     fn try_run_quiet(&self, cmd: &mut Command) -> bool {\n+        if self.config.dry_run { return true; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         try_run_suppressed(cmd)\n     }\n@@ -623,6 +659,11 @@ impl Build {\n         }\n     }\n \n+    fn info(&self, msg: &str) {\n+        if self.config.dry_run { return; }\n+        println!(\"{}\", msg);\n+    }\n+\n     /// Returns the number of parallel jobs that have been configured for this\n     /// build.\n     fn jobs(&self) -> u32 {\n@@ -930,7 +971,7 @@ impl Build {\n     pub fn fold_output<D, F>(&self, name: F) -> Option<OutputFolder>\n         where D: Into<String>, F: FnOnce() -> D\n     {\n-        if self.ci_env == CiEnv::Travis {\n+        if !self.config.dry_run && self.ci_env == CiEnv::Travis {\n             Some(OutputFolder::new(name().into()))\n         } else {\n             None\n@@ -978,7 +1019,172 @@ impl Build {\n         }\n         ret\n     }\n+\n+    fn read_stamp_file(&self, stamp: &Path) -> Vec<PathBuf> {\n+        if self.config.dry_run {\n+            return Vec::new();\n+        }\n+\n+        let mut paths = Vec::new();\n+        let mut contents = Vec::new();\n+        t!(t!(File::open(stamp)).read_to_end(&mut contents));\n+        // This is the method we use for extracting paths from the stamp file passed to us. See\n+        // run_cargo for more information (in compile.rs).\n+        for part in contents.split(|b| *b == 0) {\n+            if part.is_empty() {\n+                continue\n+            }\n+            let path = PathBuf::from(t!(str::from_utf8(part)));\n+            paths.push(path);\n+        }\n+        paths\n+    }\n+\n+    /// Copies a file from `src` to `dst`\n+    pub fn copy(&self, src: &Path, dst: &Path) {\n+        if self.config.dry_run { return; }\n+        let _ = fs::remove_file(&dst);\n+        // Attempt to \"easy copy\" by creating a hard link (symlinks don't work on\n+        // windows), but if that fails just fall back to a slow `copy` operation.\n+        if let Ok(()) = fs::hard_link(src, dst) {\n+            return\n+        }\n+        if let Err(e) = fs::copy(src, dst) {\n+            panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n+                dst.display(), e)\n+        }\n+        let metadata = t!(src.metadata());\n+        t!(fs::set_permissions(dst, metadata.permissions()));\n+        let atime = FileTime::from_last_access_time(&metadata);\n+        let mtime = FileTime::from_last_modification_time(&metadata);\n+        t!(filetime::set_file_times(dst, atime, mtime));\n+    }\n+\n+    /// Search-and-replaces within a file. (Not maximally efficiently: allocates a\n+    /// new string for each replacement.)\n+    pub fn replace_in_file(&self, path: &Path, replacements: &[(&str, &str)]) {\n+        if self.config.dry_run { return; }\n+        let mut contents = String::new();\n+        let mut file = t!(OpenOptions::new().read(true).write(true).open(path));\n+        t!(file.read_to_string(&mut contents));\n+        for &(target, replacement) in replacements {\n+            contents = contents.replace(target, replacement);\n+        }\n+        t!(file.seek(SeekFrom::Start(0)));\n+        t!(file.set_len(0));\n+        t!(file.write_all(contents.as_bytes()));\n+    }\n+\n+    /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n+    /// when this function is called.\n+    pub fn cp_r(&self, src: &Path, dst: &Path) {\n+        if self.config.dry_run { return; }\n+        for f in t!(fs::read_dir(src)) {\n+            let f = t!(f);\n+            let path = f.path();\n+            let name = path.file_name().unwrap();\n+            let dst = dst.join(name);\n+            if t!(f.file_type()).is_dir() {\n+                t!(fs::create_dir_all(&dst));\n+                self.cp_r(&path, &dst);\n+            } else {\n+                let _ = fs::remove_file(&dst);\n+                self.copy(&path, &dst);\n+            }\n+        }\n+    }\n+\n+    /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n+    /// when this function is called. Unwanted files or directories can be skipped\n+    /// by returning `false` from the filter function.\n+    pub fn cp_filtered(&self, src: &Path, dst: &Path, filter: &Fn(&Path) -> bool) {\n+        // Immediately recurse with an empty relative path\n+        self.recurse_(src, dst, Path::new(\"\"), filter)\n+    }\n+\n+    // Inner function does the actual work\n+    fn recurse_(&self, src: &Path, dst: &Path, relative: &Path, filter: &Fn(&Path) -> bool) {\n+        for f in self.read_dir(src) {\n+            let path = f.path();\n+            let name = path.file_name().unwrap();\n+            let dst = dst.join(name);\n+            let relative = relative.join(name);\n+            // Only copy file or directory if the filter function returns true\n+            if filter(&relative) {\n+                if t!(f.file_type()).is_dir() {\n+                    let _ = fs::remove_dir_all(&dst);\n+                    self.create_dir(&dst);\n+                    self.recurse_(&path, &dst, &relative, filter);\n+                } else {\n+                    let _ = fs::remove_file(&dst);\n+                    self.copy(&path, &dst);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn copy_to_folder(&self, src: &Path, dest_folder: &Path) {\n+        let file_name = src.file_name().unwrap();\n+        let dest = dest_folder.join(file_name);\n+        self.copy(src, &dest);\n+    }\n+\n+    fn install(&self, src: &Path, dstdir: &Path, perms: u32) {\n+        if self.config.dry_run { return; }\n+        let dst = dstdir.join(src.file_name().unwrap());\n+        t!(fs::create_dir_all(dstdir));\n+        drop(fs::remove_file(&dst));\n+        {\n+            let mut s = t!(fs::File::open(&src));\n+            let mut d = t!(fs::File::create(&dst));\n+            io::copy(&mut s, &mut d).expect(\"failed to copy\");\n+        }\n+        chmod(&dst, perms);\n+    }\n+\n+    fn create(&self, path: &Path, s: &str) {\n+        if self.config.dry_run { return; }\n+        t!(fs::write(path, s));\n+    }\n+\n+    fn read(&self, path: &Path) -> String {\n+        if self.config.dry_run { return String::new(); }\n+        t!(fs::read_string(path))\n+    }\n+\n+    fn create_dir(&self, dir: &Path) {\n+        if self.config.dry_run { return; }\n+        t!(fs::create_dir_all(dir))\n+    }\n+\n+    fn remove_dir(&self, dir: &Path) {\n+        if self.config.dry_run { return; }\n+        t!(fs::remove_dir_all(dir))\n+    }\n+\n+    fn read_dir(&self, dir: &Path) -> impl Iterator<Item=fs::DirEntry> {\n+        let iter = match fs::read_dir(dir) {\n+            Ok(v) => v,\n+            Err(_) if self.config.dry_run => return vec![].into_iter(),\n+            Err(err) => panic!(\"could not read dir {:?}: {:?}\", dir, err),\n+        };\n+        iter.map(|e| t!(e)).collect::<Vec<_>>().into_iter()\n+    }\n+\n+    fn remove(&self, f: &Path) {\n+        if self.config.dry_run { return; }\n+        fs::remove_file(f).unwrap_or_else(|_| panic!(\"failed to remove {:?}\", f));\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn chmod(path: &Path, perms: u32) {\n+    use std::os::unix::fs::*;\n+    t!(fs::set_permissions(path, fs::Permissions::from_mode(perms)));\n }\n+#[cfg(windows)]\n+fn chmod(_path: &Path, _perms: u32) {}\n+\n \n impl<'a> Compiler {\n     pub fn with_stage(mut self, stage: u32) -> Compiler {"}, {"sha": "db5891afd6b1fa59ac73c7c7a9590511d64299c4", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -106,8 +106,8 @@ impl Step for Llvm {\n \n         let _folder = build.fold_output(|| \"llvm\");\n         let descriptor = if emscripten { \"Emscripten \" } else { \"\" };\n-        println!(\"Building {}LLVM for {}\", descriptor, target);\n-        let _time = util::timeit();\n+        build.info(&format!(\"Building {}LLVM for {}\", descriptor, target));\n+        let _time = util::timeit(&build);\n         t!(fs::create_dir_all(&out_dir));\n \n         // http://llvm.org/docs/CMake.html\n@@ -217,6 +217,11 @@ impl Step for Llvm {\n         //        libraries here, e.g. we just want a few components and a few\n         //        tools. Figure out how to filter them down and only build the right\n         //        tools and libs on all platforms.\n+\n+        if builder.config.dry_run {\n+            return build_llvm_config;\n+        }\n+\n         cfg.build();\n \n         t!(t!(File::create(&done_stamp)).write_all(rebuild_trigger_contents.as_bytes()));\n@@ -230,6 +235,10 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n         return\n     }\n \n+    if build.config.dry_run {\n+        return;\n+    }\n+\n     let mut cmd = Command::new(llvm_config);\n     let version = output(cmd.arg(\"--version\"));\n     let mut parts = version.split('.').take(2)\n@@ -336,6 +345,9 @@ impl Step for Lld {\n \n     /// Compile LLVM for `target`.\n     fn run(self, builder: &Builder) -> PathBuf {\n+        if builder.config.dry_run {\n+            return PathBuf::from(\"lld-out-dir-test-gen\");\n+        }\n         let target = self.target;\n         let build = builder.build;\n \n@@ -351,8 +363,8 @@ impl Step for Lld {\n         }\n \n         let _folder = build.fold_output(|| \"lld\");\n-        println!(\"Building LLD for {}\", target);\n-        let _time = util::timeit();\n+        build.info(&format!(\"Building LLD for {}\", target));\n+        let _time = util::timeit(&build);\n         t!(fs::create_dir_all(&out_dir));\n \n         let mut cfg = cmake::Config::new(build.src.join(\"src/tools/lld\"));\n@@ -389,6 +401,9 @@ impl Step for TestHelpers {\n     /// Compiles the `rust_test_helpers.c` library which we used in various\n     /// `run-pass` test suites for ABI testing.\n     fn run(self, builder: &Builder) {\n+        if builder.config.dry_run {\n+            return;\n+        }\n         let build = builder.build;\n         let target = self.target;\n         let dst = build.test_helpers_out(target);\n@@ -398,7 +413,7 @@ impl Step for TestHelpers {\n         }\n \n         let _folder = build.fold_output(|| \"build_test_helpers\");\n-        println!(\"Building test helpers\");\n+        build.info(&format!(\"Building test helpers\"));\n         t!(fs::create_dir_all(&dst));\n         let mut cfg = cc::Build::new();\n \n@@ -441,6 +456,9 @@ impl Step for Openssl {\n     }\n \n     fn run(self, builder: &Builder) {\n+        if builder.config.dry_run {\n+            return;\n+        }\n         let build = builder.build;\n         let target = self.target;\n         let out = match build.openssl_dir(target) {\n@@ -591,11 +609,11 @@ impl Step for Openssl {\n             configure.arg(\"no-asm\");\n         }\n         configure.current_dir(&obj);\n-        println!(\"Configuring openssl for {}\", target);\n+        build.info(&format!(\"Configuring openssl for {}\", target));\n         build.run_quiet(&mut configure);\n-        println!(\"Building openssl for {}\", target);\n+        build.info(&format!(\"Building openssl for {}\", target));\n         build.run_quiet(Command::new(\"make\").arg(\"-j1\").current_dir(&obj));\n-        println!(\"Installing openssl for {}\", target);\n+        build.info(&format!(\"Installing openssl for {}\", target));\n         build.run_quiet(Command::new(\"make\").arg(\"install\").arg(\"-j1\").current_dir(&obj));\n \n         let mut f = t!(File::create(&stamp));"}, {"sha": "c175d2c69016f926ff6d24cdc74e97eb408b7d67", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 48, "deletions": 33, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -109,11 +109,11 @@ impl Step for Linkcheck {\n         let build = builder.build;\n         let host = self.host;\n \n-        println!(\"Linkcheck ({})\", host);\n+        build.info(&format!(\"Linkcheck ({})\", host));\n \n         builder.default_doc(None);\n \n-        let _time = util::timeit();\n+        let _time = util::timeit(&build);\n         try_run(build, builder.tool_cmd(Tool::Linkchecker)\n                               .arg(build.out.join(host).join(\"doc\")));\n     }\n@@ -164,7 +164,7 @@ impl Step for Cargotest {\n         let out_dir = build.out.join(\"ct\");\n         t!(fs::create_dir_all(&out_dir));\n \n-        let _time = util::timeit();\n+        let _time = util::timeit(&build);\n         let mut cmd = builder.tool_cmd(Tool::CargoTest);\n         try_run(build, cmd.arg(&build.initial_cargo)\n                           .arg(&out_dir)\n@@ -509,7 +509,7 @@ impl Step for RustdocJS {\n             });\n             builder.run(&mut command);\n         } else {\n-            println!(\"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\");\n+            builder.info(&format!(\"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\"));\n         }\n     }\n }\n@@ -541,7 +541,7 @@ impl Step for Tidy {\n         }\n \n         let _folder = build.fold_output(|| \"tidy\");\n-        println!(\"tidy check\");\n+        builder.info(&format!(\"tidy check\"));\n         try_run(build, &mut cmd);\n     }\n \n@@ -926,15 +926,17 @@ impl Step for Compiletest {\n                 target: build.config.build,\n                 emscripten: false,\n             });\n-            let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n-            cmd.arg(\"--llvm-version\").arg(llvm_version);\n+            if !build.config.dry_run {\n+                let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n+                cmd.arg(\"--llvm-version\").arg(llvm_version);\n+            }\n             if !build.is_rust_llvm(target) {\n                 cmd.arg(\"--system-llvm\");\n             }\n \n             // Only pass correct values for these flags for the `run-make` suite as it\n             // requires that a C++ compiler was configured which isn't always the case.\n-            if suite == \"run-make-fulldeps\" {\n+            if !build.config.dry_run && suite == \"run-make-fulldeps\" {\n                 let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n                 let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n                 cmd.arg(\"--cc\").arg(build.cc(target))\n@@ -948,7 +950,8 @@ impl Step for Compiletest {\n             }\n         }\n         if suite == \"run-make-fulldeps\" && !build.config.llvm_enabled {\n-            println!(\"Ignoring run-make test suite as they generally don't work without LLVM\");\n+            builder.info(\n+                &format!(\"Ignoring run-make test suite as they generally don't work without LLVM\"));\n             return;\n         }\n \n@@ -1002,9 +1005,9 @@ impl Step for Compiletest {\n         build.ci_env.force_coloring_in_ci(&mut cmd);\n \n         let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n-        println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n-                 suite, mode, &compiler.host, target);\n-        let _time = util::timeit();\n+        builder.info(&format!(\"Check compiletest suite={} mode={} ({} -> {})\",\n+                 suite, mode, &compiler.host, target));\n+        let _time = util::timeit(&build);\n         try_run(build, &mut cmd);\n     }\n }\n@@ -1039,9 +1042,10 @@ impl Step for DocTest {\n         // Do a breadth-first traversal of the `src/doc` directory and just run\n         // tests for all files that end in `*.md`\n         let mut stack = vec![build.src.join(self.path)];\n-        let _time = util::timeit();\n+        let _time = util::timeit(&build);\n         let _folder = build.fold_output(|| format!(\"test_{}\", self.name));\n \n+        let mut files = Vec::new();\n         while let Some(p) = stack.pop() {\n             if p.is_dir() {\n                 stack.extend(t!(p.read_dir()).map(|p| t!(p).path()));\n@@ -1058,7 +1062,13 @@ impl Step for DocTest {\n                 continue;\n             }\n \n-            let test_result = markdown_test(builder, compiler, &p);\n+            files.push(p);\n+        }\n+\n+        files.sort();\n+\n+        for file in files {\n+            let test_result = markdown_test(builder, compiler, &file);\n             if self.is_ext_doc {\n                 let toolstate = if test_result {\n                     ToolState::TestPass\n@@ -1160,23 +1170,27 @@ impl Step for ErrorIndex {\n \n \n         let _folder = build.fold_output(|| \"test_error_index\");\n-        println!(\"Testing error-index stage{}\", compiler.stage);\n-        let _time = util::timeit();\n+        build.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n+        let _time = util::timeit(&build);\n         build.run(&mut tool);\n         markdown_test(builder, compiler, &output);\n     }\n }\n \n fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool {\n     let build = builder.build;\n-    let mut file = t!(File::open(markdown));\n-    let mut contents = String::new();\n-    t!(file.read_to_string(&mut contents));\n-    if !contents.contains(\"```\") {\n-        return true;\n+    match File::open(markdown) {\n+        Ok(mut file) => {\n+            let mut contents = String::new();\n+            t!(file.read_to_string(&mut contents));\n+            if !contents.contains(\"```\") {\n+                return true;\n+            }\n+        }\n+        Err(_) => {},\n     }\n \n-    println!(\"doc tests for: {}\", markdown.display());\n+    build.info(&format!(\"doc tests for: {}\", markdown.display()));\n     let mut cmd = builder.rustdoc_cmd(compiler.host);\n     build.add_rust_test_threads(&mut cmd);\n     cmd.arg(\"--test\");\n@@ -1446,8 +1460,8 @@ impl Step for Crate {\n             // The javascript shim implements the syscall interface so that test\n             // output can be correctly reported.\n             if !build.config.wasm_syscall {\n-                println!(\"Libstd was built without `wasm_syscall` feature enabled: \\\n-                          test output may not be visible.\");\n+                build.info(&format!(\"Libstd was built without `wasm_syscall` feature enabled: \\\n+                          test output may not be visible.\"));\n             }\n \n             // On the wasm32-unknown-unknown target we're using LTO which is\n@@ -1469,9 +1483,9 @@ impl Step for Crate {\n         let _folder = build.fold_output(|| {\n             format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, krate)\n         });\n-        println!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n-                &compiler.host, target);\n-        let _time = util::timeit();\n+        build.info(&format!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n+                &compiler.host, target));\n+        let _time = util::timeit(&build);\n         try_run(build, &mut cargo);\n     }\n }\n@@ -1536,9 +1550,9 @@ impl Step for CrateRustdoc {\n         let _folder = build.fold_output(|| {\n             format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n         });\n-        println!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n-                &compiler.host, target);\n-        let _time = util::timeit();\n+        build.info(&format!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n+                &compiler.host, target));\n+        let _time = util::timeit(&build);\n \n         try_run(build, &mut cargo);\n     }\n@@ -1585,7 +1599,7 @@ impl Step for RemoteCopyLibs {\n \n         builder.ensure(compile::Test { compiler, target });\n \n-        println!(\"REMOTE copy libs to emulator ({})\", target);\n+        build.info(&format!(\"REMOTE copy libs to emulator ({})\", target));\n         t!(fs::create_dir_all(build.out.join(\"tmp\")));\n \n         let server = builder.ensure(tool::RemoteTestServer { compiler, target });\n@@ -1633,7 +1647,7 @@ impl Step for Distcheck {\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n \n-        println!(\"Distcheck\");\n+        build.info(&format!(\"Distcheck\"));\n         let dir = build.out.join(\"tmp\").join(\"distcheck\");\n         let _ = fs::remove_dir_all(&dir);\n         t!(fs::create_dir_all(&dir));\n@@ -1657,7 +1671,7 @@ impl Step for Distcheck {\n                          .current_dir(&dir));\n \n         // Now make sure that rust-src has all of libstd's dependencies\n-        println!(\"Distcheck rust-src\");\n+        build.info(&format!(\"Distcheck rust-src\"));\n         let dir = build.out.join(\"tmp\").join(\"distcheck-src\");\n         let _ = fs::remove_dir_all(&dir);\n         t!(fs::create_dir_all(&dir));\n@@ -1692,6 +1706,7 @@ impl Step for Bootstrap {\n         let mut cmd = Command::new(&build.initial_cargo);\n         cmd.arg(\"test\")\n            .current_dir(build.src.join(\"src/bootstrap\"))\n+           .env(\"RUSTFLAGS\", \"-Cdebuginfo=2\")\n            .env(\"CARGO_TARGET_DIR\", build.out.join(\"bootstrap\"))\n            .env(\"RUSTC_BOOTSTRAP\", \"1\")\n            .env(\"RUSTC\", &build.initial_rustc);"}, {"sha": "93b6153fcb2f8c58c2758f3a6284e54e5867df83", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -17,7 +17,7 @@ use std::slice::SliceConcatExt;\n use Mode;\n use Compiler;\n use builder::{Step, RunConfig, ShouldRun, Builder};\n-use util::{copy, exe, add_lib_path};\n+use util::{exe, add_lib_path};\n use compile::{self, libtest_stamp, libstd_stamp, librustc_stamp};\n use native;\n use channel::GitInfo;\n@@ -116,7 +116,7 @@ impl Step for ToolBuild {\n         cargo.arg(\"--features\").arg(self.extra_features.join(\" \"));\n \n         let _folder = build.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n-        println!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target);\n+        build.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n         let mut duplicates = Vec::new();\n         let is_expected = compile::stream_cargo(build, &mut cargo, &mut |msg| {\n             // Only care about big things like the RLS/Cargo for now\n@@ -207,7 +207,7 @@ impl Step for ToolBuild {\n             let cargo_out = build.cargo_out(compiler, Mode::Tool, target)\n                 .join(exe(tool, &compiler.host));\n             let bin = build.tools_dir(compiler).join(exe(tool, &compiler.host));\n-            copy(&cargo_out, &bin);\n+            build.copy(&cargo_out, &bin);\n             Some(bin)\n         }\n     }\n@@ -427,7 +427,8 @@ impl Step for Rustdoc {\n              .env(\"RUSTC_DEBUGINFO_LINES\", builder.config.rust_debuginfo_lines.to_string());\n \n         let _folder = build.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n-        println!(\"Building rustdoc for stage{} ({})\", target_compiler.stage, target_compiler.host);\n+        build.info(&format!(\"Building rustdoc for stage{} ({})\",\n+            target_compiler.stage, target_compiler.host));\n         build.run(&mut cargo);\n \n         // Cargo adds a number of paths to the dylib search path on windows, which results in\n@@ -443,7 +444,7 @@ impl Step for Rustdoc {\n             t!(fs::create_dir_all(&bindir));\n             let bin_rustdoc = bindir.join(exe(\"rustdoc\", &*target_compiler.host));\n             let _ = fs::remove_file(&bin_rustdoc);\n-            copy(&tool_rustdoc, &bin_rustdoc);\n+            build.copy(&tool_rustdoc, &bin_rustdoc);\n             bin_rustdoc\n         } else {\n             tool_rustdoc"}, {"sha": "f8c7032369890b8472a66083dee9ae9b467d6abe", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 15, "deletions": 107, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fea66ba46bb32d1a49495518d899cede1d298a/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=17fea66ba46bb32d1a49495518d899cede1d298a", "patch": "@@ -15,13 +15,14 @@\n \n use std::env;\n use std::str;\n-use std::fs::{self, File, OpenOptions};\n-use std::io::{self, Read, Write, Seek, SeekFrom};\n+use std::fs;\n+use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{SystemTime, Instant};\n \n-use filetime::{self, FileTime};\n+use config::Config;\n+use Build;\n \n /// Returns the `name` as the filename of a static library for `target`.\n pub fn staticlib(name: &str, target: &str) -> String {\n@@ -32,102 +33,6 @@ pub fn staticlib(name: &str, target: &str) -> String {\n     }\n }\n \n-/// Copies a file from `src` to `dst`\n-pub fn copy(src: &Path, dst: &Path) {\n-    let _ = fs::remove_file(&dst);\n-    // Attempt to \"easy copy\" by creating a hard link (symlinks don't work on\n-    // windows), but if that fails just fall back to a slow `copy` operation.\n-    if let Ok(()) = fs::hard_link(src, dst) {\n-        return\n-    }\n-    if let Err(e) = fs::copy(src, dst) {\n-        panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n-               dst.display(), e)\n-    }\n-    let metadata = t!(src.metadata());\n-    t!(fs::set_permissions(dst, metadata.permissions()));\n-    let atime = FileTime::from_last_access_time(&metadata);\n-    let mtime = FileTime::from_last_modification_time(&metadata);\n-    t!(filetime::set_file_times(dst, atime, mtime));\n-}\n-\n-/// Search-and-replaces within a file. (Not maximally efficiently: allocates a\n-/// new string for each replacement.)\n-pub fn replace_in_file(path: &Path, replacements: &[(&str, &str)]) {\n-    let mut contents = String::new();\n-    let mut file = t!(OpenOptions::new().read(true).write(true).open(path));\n-    t!(file.read_to_string(&mut contents));\n-    for &(target, replacement) in replacements {\n-        contents = contents.replace(target, replacement);\n-    }\n-    t!(file.seek(SeekFrom::Start(0)));\n-    t!(file.set_len(0));\n-    t!(file.write_all(contents.as_bytes()));\n-}\n-\n-pub fn read_stamp_file(stamp: &Path) -> Vec<PathBuf> {\n-    let mut paths = Vec::new();\n-    let mut contents = Vec::new();\n-    t!(t!(File::open(stamp)).read_to_end(&mut contents));\n-    // This is the method we use for extracting paths from the stamp file passed to us. See\n-    // run_cargo for more information (in compile.rs).\n-    for part in contents.split(|b| *b == 0) {\n-        if part.is_empty() {\n-            continue\n-        }\n-        let path = PathBuf::from(t!(str::from_utf8(part)));\n-        paths.push(path);\n-    }\n-    paths\n-}\n-\n-/// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n-/// when this function is called.\n-pub fn cp_r(src: &Path, dst: &Path) {\n-    for f in t!(fs::read_dir(src)) {\n-        let f = t!(f);\n-        let path = f.path();\n-        let name = path.file_name().unwrap();\n-        let dst = dst.join(name);\n-        if t!(f.file_type()).is_dir() {\n-            t!(fs::create_dir_all(&dst));\n-            cp_r(&path, &dst);\n-        } else {\n-            let _ = fs::remove_file(&dst);\n-            copy(&path, &dst);\n-        }\n-    }\n-}\n-\n-/// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n-/// when this function is called. Unwanted files or directories can be skipped\n-/// by returning `false` from the filter function.\n-pub fn cp_filtered(src: &Path, dst: &Path, filter: &Fn(&Path) -> bool) {\n-    // Inner function does the actual work\n-    fn recurse(src: &Path, dst: &Path, relative: &Path, filter: &Fn(&Path) -> bool) {\n-        for f in t!(fs::read_dir(src)) {\n-            let f = t!(f);\n-            let path = f.path();\n-            let name = path.file_name().unwrap();\n-            let dst = dst.join(name);\n-            let relative = relative.join(name);\n-            // Only copy file or directory if the filter function returns true\n-            if filter(&relative) {\n-                if t!(f.file_type()).is_dir() {\n-                    let _ = fs::remove_dir_all(&dst);\n-                    t!(fs::create_dir(&dst));\n-                    recurse(&path, &dst, &relative, filter);\n-                } else {\n-                    let _ = fs::remove_file(&dst);\n-                    copy(&path, &dst);\n-                }\n-            }\n-        }\n-    }\n-    // Immediately recurse with an empty relative path\n-    recurse(src, dst, Path::new(\"\"), filter)\n-}\n-\n /// Given an executable called `name`, return the filename for the\n /// executable for a particular target.\n pub fn exe(name: &str, target: &str) -> String {\n@@ -196,25 +101,28 @@ pub fn push_exe_path(mut buf: PathBuf, components: &[&str]) -> PathBuf {\n     buf\n }\n \n-pub struct TimeIt(Instant);\n+pub struct TimeIt(bool, Instant);\n \n /// Returns an RAII structure that prints out how long it took to drop.\n-pub fn timeit() -> TimeIt {\n-    TimeIt(Instant::now())\n+pub fn timeit(build: &Build) -> TimeIt {\n+    TimeIt(build.config.dry_run, Instant::now())\n }\n \n impl Drop for TimeIt {\n     fn drop(&mut self) {\n-        let time = self.0.elapsed();\n-        println!(\"\\tfinished in {}.{:03}\",\n-                 time.as_secs(),\n-                 time.subsec_nanos() / 1_000_000);\n+        let time = self.1.elapsed();\n+        if !self.0 {\n+            println!(\"\\tfinished in {}.{:03}\",\n+                    time.as_secs(),\n+                    time.subsec_nanos() / 1_000_000);\n+        }\n     }\n }\n \n /// Symlinks two directories, using junctions on Windows and normal symlinks on\n /// Unix.\n-pub fn symlink_dir(src: &Path, dest: &Path) -> io::Result<()> {\n+pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n+    if config.dry_run { return Ok(()); }\n     let _ = fs::remove_dir(dest);\n     return symlink_dir_inner(src, dest);\n "}]}