{"sha": "a159f856d54c507052d24a026ccc8a568aa454f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNTlmODU2ZDU0YzUwNzA1MmQyNGEwMjZjY2M4YTU2OGFhNDU0ZjM=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-06-07T17:29:21Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-06-12T20:50:15Z"}, "message": "Properly translate calls to default methods in a number of cases. Closes #4350.", "tree": {"sha": "194994ae8b4defe70eb54ae345b7b37cc615f487", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/194994ae8b4defe70eb54ae345b7b37cc615f487"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a159f856d54c507052d24a026ccc8a568aa454f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a159f856d54c507052d24a026ccc8a568aa454f3", "html_url": "https://github.com/rust-lang/rust/commit/a159f856d54c507052d24a026ccc8a568aa454f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a159f856d54c507052d24a026ccc8a568aa454f3/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "135ba946a233c1d32b98943180d3eaacc9ff26f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/135ba946a233c1d32b98943180d3eaacc9ff26f2", "html_url": "https://github.com/rust-lang/rust/commit/135ba946a233c1d32b98943180d3eaacc9ff26f2"}], "stats": {"total": 73, "additions": 23, "deletions": 50}, "files": [{"sha": "9d8ef2e603b47242d885ce58bd0bfdf6cfb0866e", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 22, "deletions": 47, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a159f856d54c507052d24a026ccc8a568aa454f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a159f856d54c507052d24a026ccc8a568aa454f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=a159f856d54c507052d24a026ccc8a568aa454f3", "patch": "@@ -207,7 +207,9 @@ pub fn trans_method_callee(bcx: block,\n             let method_name =\n                 ty::trait_method(tcx, trait_id, method_index).ident;\n             let method_id =\n-                method_with_name(bcx.ccx(), impl_def_id, method_name);\n+                method_with_name_or_default(bcx.ccx(),\n+                                            impl_def_id,\n+                                            method_name);\n             origin = typeck::method_static(method_id);\n         }\n         typeck::method_super(trait_id, method_index) => {\n@@ -229,9 +231,10 @@ pub fn trans_method_callee(bcx: block,\n                 ty::method(tcx, supertrait_method_def_ids[method_index]).ident;\n             // Now that we know the impl ID, we can look up the method\n             // ID from its name\n-            origin = typeck::method_static(method_with_name(bcx.ccx(),\n-                                                            impl_id,\n-                                                            method_name));\n+            origin = typeck::method_static(\n+                method_with_name_or_default(bcx.ccx(),\n+                                            impl_id,\n+                                            method_name));\n         }\n         typeck::method_static(*) | typeck::method_param(*) |\n         typeck::method_trait(*) => {}\n@@ -345,7 +348,9 @@ pub fn trans_static_method_callee(bcx: block,\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n             assert!(rcvr_substs.all(|t| !ty::type_needs_infer(*t)));\n \n-            let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n+            let mth_id = method_with_name_or_default(bcx.ccx(),\n+                                                     impl_did,\n+                                                     mname);\n             let callee_substs = combine_impl_and_methods_tps(\n                 bcx, mth_id, impl_did, callee_id, *rcvr_substs);\n             let callee_origins = combine_impl_and_methods_origins(\n@@ -374,23 +379,6 @@ pub fn method_from_methods(ms: &[@ast::method], name: ast::ident)\n     ms.find(|m| m.ident == name).map(|m| ast_util::local_def(m.id))\n }\n \n-pub fn method_with_name(ccx: @CrateContext, impl_id: ast::def_id,\n-                        name: ast::ident) -> ast::def_id {\n-    if impl_id.crate == ast::local_crate {\n-        match ccx.tcx.items.get_copy(&impl_id.node) {\n-          ast_map::node_item(@ast::item {\n-                node: ast::item_impl(_, _, _, ref ms),\n-                _\n-            }, _) => {\n-            method_from_methods(*ms, name).get()\n-          }\n-          _ => fail!(\"method_with_name\")\n-        }\n-    } else {\n-        csearch::get_impl_method(ccx.sess.cstore, impl_id, name)\n-    }\n-}\n-\n pub fn method_with_name_or_default(ccx: @CrateContext,\n                                    impl_id: ast::def_id,\n                                    name: ast::ident) -> ast::def_id {\n@@ -770,17 +758,17 @@ pub fn vtable_id(ccx: @CrateContext,\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n-pub fn get_vtable(ccx: @CrateContext,\n+pub fn get_vtable(bcx: block,\n                   self_ty: ty::t,\n                   origin: typeck::vtable_origin)\n                   -> ValueRef {\n-    let hash_id = vtable_id(ccx, &origin);\n-    match ccx.vtables.find(&hash_id) {\n+    let hash_id = vtable_id(bcx.ccx(), &origin);\n+    match bcx.ccx().vtables.find(&hash_id) {\n         Some(&val) => val,\n         None => {\n             match origin {\n                 typeck::vtable_static(id, substs, sub_vtables) => {\n-                    make_impl_vtable(ccx, id, self_ty, substs, sub_vtables)\n+                    make_impl_vtable(bcx, id, self_ty, substs, sub_vtables)\n                 }\n                 _ => fail!(\"get_vtable: expected a static origin\"),\n             }\n@@ -814,12 +802,13 @@ pub fn make_vtable(ccx: @CrateContext,\n }\n \n /// Generates a dynamic vtable for objects.\n-pub fn make_impl_vtable(ccx: @CrateContext,\n+pub fn make_impl_vtable(bcx: block,\n                         impl_id: ast::def_id,\n                         self_ty: ty::t,\n                         substs: ~[ty::t],\n                         vtables: typeck::vtable_res)\n                         -> ValueRef {\n+    let ccx = bcx.ccx();\n     let _icx = ccx.insn_ctxt(\"impl::make_impl_vtable\");\n     let tcx = ccx.tcx;\n \n@@ -829,9 +818,6 @@ pub fn make_impl_vtable(ccx: @CrateContext,\n                                     make a vtable for a type impl!\")\n     };\n \n-    let has_tps =\n-        !ty::lookup_item_type(ccx.tcx, impl_id).generics.type_param_defs.is_empty();\n-\n     let trait_method_def_ids = ty::trait_method_def_ids(tcx, trt_id);\n     let methods = do trait_method_def_ids.map |method_def_id| {\n         let im = ty::method(tcx, *method_def_id);\n@@ -846,22 +832,11 @@ pub fn make_impl_vtable(ccx: @CrateContext,\n         } else {\n             debug!(\"(making impl vtable) adding method to vtable: %s\",\n                    *tcx.sess.str_of(im.ident));\n-            let mut m_id = method_with_name(ccx, impl_id, im.ident);\n-            if has_tps {\n-                // If the method is in another crate, need to make an inlined\n-                // copy first\n-                if m_id.crate != ast::local_crate {\n-                    // XXX: Set impl ID here?\n-                    m_id = inline::maybe_instantiate_inline(ccx, m_id, true);\n-                }\n-                let (val, _) = monomorphize::monomorphic_fn(ccx, m_id, substs,\n-                                Some(vtables), None, None);\n-                val\n-            } else if m_id.crate == ast::local_crate {\n-                get_item_val(ccx, m_id.node)\n-            } else {\n-                trans_external_path(ccx, m_id, fty)\n-            }\n+            let m_id = method_with_name_or_default(ccx, impl_id, im.ident);\n+\n+            trans_fn_ref_with_vtables(bcx, m_id, 0,\n+                                      substs, Some(vtables)).llfn\n+\n         }\n     };\n \n@@ -903,7 +878,7 @@ pub fn trans_trait_cast(bcx: block,\n     // Store the vtable into the pair or triple.\n     let orig = /*bad*/copy ccx.maps.vtable_map.get(&id)[0];\n     let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n-    let vtable = get_vtable(bcx.ccx(), v_ty, orig);\n+    let vtable = get_vtable(bcx, v_ty, orig);\n     Store(bcx, vtable, PointerCast(bcx,\n                                    GEPi(bcx, lldest, [0u, abi::trt_field_vtable]),\n                                    T_ptr(val_ty(vtable))));"}, {"sha": "65009bb716d638fc279267884a9e98ef86429f05", "filename": "src/test/run-pass/traits-default-method-self.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a159f856d54c507052d24a026ccc8a568aa454f3/src%2Ftest%2Frun-pass%2Ftraits-default-method-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a159f856d54c507052d24a026ccc8a568aa454f3/src%2Ftest%2Frun-pass%2Ftraits-default-method-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-default-method-self.rs?ref=a159f856d54c507052d24a026ccc8a568aa454f3", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//xfail-test\n-\n-// Currently failing with an ICE in trans.  (FIXME: #4350)\n+#[allow(default_methods)];\n \n trait Cat {\n     fn meow(&self) -> bool;"}]}