{"sha": "a8bb7fa76b3d9d288ad12e9a86be96ee0e6abadf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4YmI3ZmE3NmIzZDlkMjg4YWQxMmU5YTg2YmU5NmVlMGU2YWJhZGY=", "commit": {"author": {"name": "Ian Jackson", "email": "ijackson@chiark.greenend.org.uk", "date": "2021-05-13T17:59:41Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-07-05T10:43:00Z"}, "message": "aborts: Clarify documentation and comments\n\nIn the docs for intrinsics::abort():\n\n * Strengthen the recommendation by to use process::abort instead.\n * Document the fact that it (ab)uses an LLVM debug trap and what the\n   likely consequences are.\n * State that the precise behaviour is unstable.\n\nIn the docs for process::abort():\n\n * Promise that we have the same behaviour as C `abort()`.\n * Document the likely consequences, including, specifically, the\n   consequences on Unix.\n\nIn the internal comment for unix::abort_internal:\n\n * Refer to the public docs for the public API functions.\n * Correct and expand the description of libc::abort.  Specifically:\n * Do not claim that abort() unregisters signal handlers.  It doesn't;\n   it honours the SIGABRT handler.\n * Discuss, extensively, the issue with abort() flushing stdio buffers.\n * Describe the glibc behaviour in some detail.\n\nCo-authored-by: Mark Wooding <mdw@distorted.org.uk>\nSigned-off-by: Ian Jackson <ijackson@chiark.greenend.org.uk>", "tree": {"sha": "2524e324d86490efb12131d00e55d7fd02db73fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2524e324d86490efb12131d00e55d7fd02db73fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8bb7fa76b3d9d288ad12e9a86be96ee0e6abadf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8bb7fa76b3d9d288ad12e9a86be96ee0e6abadf", "html_url": "https://github.com/rust-lang/rust/commit/a8bb7fa76b3d9d288ad12e9a86be96ee0e6abadf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8bb7fa76b3d9d288ad12e9a86be96ee0e6abadf/comments", "author": {"login": "ijackson", "id": 2090772, "node_id": "MDQ6VXNlcjIwOTA3NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/2090772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ijackson", "html_url": "https://github.com/ijackson", "followers_url": "https://api.github.com/users/ijackson/followers", "following_url": "https://api.github.com/users/ijackson/following{/other_user}", "gists_url": "https://api.github.com/users/ijackson/gists{/gist_id}", "starred_url": "https://api.github.com/users/ijackson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ijackson/subscriptions", "organizations_url": "https://api.github.com/users/ijackson/orgs", "repos_url": "https://api.github.com/users/ijackson/repos", "events_url": "https://api.github.com/users/ijackson/events{/privacy}", "received_events_url": "https://api.github.com/users/ijackson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c54895bea6a96defe4c9a7041013efe7505c3ff2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c54895bea6a96defe4c9a7041013efe7505c3ff2", "html_url": "https://github.com/rust-lang/rust/commit/c54895bea6a96defe4c9a7041013efe7505c3ff2"}], "stats": {"total": 54, "additions": 45, "deletions": 9}, "files": [{"sha": "8be4f5997693c4072f4ad1057365629f1078edc6", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8bb7fa76b3d9d288ad12e9a86be96ee0e6abadf/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8bb7fa76b3d9d288ad12e9a86be96ee0e6abadf/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=a8bb7fa76b3d9d288ad12e9a86be96ee0e6abadf", "patch": "@@ -717,8 +717,12 @@ extern \"rust-intrinsic\" {\n     /// Therefore, implementations must not require the user to uphold\n     /// any safety invariants.\n     ///\n-    /// A more user-friendly and stable version of this operation is\n-    /// [`std::process::abort`](../../std/process/fn.abort.html).\n+    /// [`std::process::abort`](../../std/process/fn.abort.html) is to be preferred if possible,\n+    /// as its behaviour is more user-friendly and more stable.\n+    ///\n+    /// The current implementation of `intrinsics::abort` (ab)uses a debug trap.  On Unix, the\n+    /// process will probably die of a signal like `SIGABRT`, `SIGILL`, `SIGTRAP`, `SIGSEGV` or\n+    /// `SIGBUS`.  The precise behaviour is not guaranteed and not stable.\n     pub fn abort() -> !;\n \n     /// Informs the optimizer that this point in the code is not reachable,"}, {"sha": "95108f96e061c27295aa939368b2e84bf5624034", "filename": "library/std/src/process.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8bb7fa76b3d9d288ad12e9a86be96ee0e6abadf/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8bb7fa76b3d9d288ad12e9a86be96ee0e6abadf/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=a8bb7fa76b3d9d288ad12e9a86be96ee0e6abadf", "patch": "@@ -1908,6 +1908,10 @@ pub fn exit(code: i32) -> ! {\n /// this function at a known point where there are no more destructors left\n /// to run.\n ///\n+/// The process's termination will be similar to that from the C `abort()`\n+/// function.  On Unix, the process will die with signal `SIGABRT`, which\n+/// typically means that the shell prints \"Aborted\".\n+///\n /// # Examples\n ///\n /// ```no_run"}, {"sha": "2da71b2a448ac1d8aea5a6f2be657faeaebf2723", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a8bb7fa76b3d9d288ad12e9a86be96ee0e6abadf/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8bb7fa76b3d9d288ad12e9a86be96ee0e6abadf/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=a8bb7fa76b3d9d288ad12e9a86be96ee0e6abadf", "patch": "@@ -217,13 +217,41 @@ pub fn cvt_nz(error: libc::c_int) -> crate::io::Result<()> {\n     if error == 0 { Ok(()) } else { Err(crate::io::Error::from_raw_os_error(error)) }\n }\n \n-// On Unix-like platforms, libc::abort will unregister signal handlers\n-// including the SIGABRT handler, preventing the abort from being blocked, and\n-// fclose streams, with the side effect of flushing them so libc buffered\n-// output will be printed.  Additionally the shell will generally print a more\n-// understandable error message like \"Abort trap\" rather than \"Illegal\n-// instruction\" that intrinsics::abort would cause, as intrinsics::abort is\n-// implemented as an illegal instruction.\n+// libc::abort() will run the SIGABRT handler.  That's fine because anyone who\n+// installs a SIGABRT handler already has to expect it to run in Very Bad\n+// situations (eg, malloc crashing).\n+//\n+// Current glibc's abort() function unblocks SIGABRT, raises SIGABRT, clears the\n+// SIGABRT handler and raises it again, and then starts to get creative.\n+//\n+// See the public documentation for `intrinsics::abort()` and `process::abort()`\n+// for further discussion.\n+//\n+// There is confusion about whether libc::abort() flushes stdio streams.\n+// libc::abort() is required by ISO C 99 (7.14.1.1p5) to be async-signal-safe,\n+// so flushing streams is at least extremely hard, if not entirely impossible.\n+//\n+// However, some versions of POSIX (eg IEEE Std 1003.1-2001) required abort to\n+// do so.  In 1003.1-2004 this was fixed.\n+//\n+// glibc's implementation did the flush, unsafely, before glibc commit\n+// 91e7cf982d01 `abort: Do not flush stdio streams [BZ #15436]' by Florian\n+// Weimer.  According to glibc's NEWS:\n+//\n+//    The abort function terminates the process immediately, without flushing\n+//    stdio streams.  Previous glibc versions used to flush streams, resulting\n+//    in deadlocks and further data corruption.  This change also affects\n+//    process aborts as the result of assertion failures.\n+//\n+// This is an accurate description of the problem.  The only solution for\n+// program with nontrivial use of C stdio is a fixed libc - one which does not\n+// try to flush in abort - since even libc-internal errors, and assertion\n+// failures generated from C, will go via abort().\n+//\n+// On systems with old, buggy, libcs, the impact can be severe for a\n+// multithreaded C program.  It is much less severe for Rust, because Rust\n+// stdlib doesn't use libc stdio buffering.  In a typical Rust program, which\n+// does not use C stdio, even a buggy libc::abort() is, in fact, safe.\n pub fn abort_internal() -> ! {\n     unsafe { libc::abort() }\n }"}]}