{"sha": "f354c8a580acbb3170883dd271f362d4b9132ddc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNTRjOGE1ODBhY2JiMzE3MDg4M2RkMjcxZjM2MmQ0YjkxMzJkZGM=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-07T23:44:49Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-07T23:44:49Z"}, "message": "New TOC", "tree": {"sha": "41a203106ee792ddbd14685d041930ba8b5fea3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41a203106ee792ddbd14685d041930ba8b5fea3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f354c8a580acbb3170883dd271f362d4b9132ddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f354c8a580acbb3170883dd271f362d4b9132ddc", "html_url": "https://github.com/rust-lang/rust/commit/f354c8a580acbb3170883dd271f362d4b9132ddc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f354c8a580acbb3170883dd271f362d4b9132ddc/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "html_url": "https://github.com/rust-lang/rust/commit/d9146bf8ba0bdf98a46c4656899e54802e96ac0c"}], "stats": {"total": 10567, "additions": 48, "deletions": 10519}, "files": [{"sha": "c9ac638098bdc6ac2276e25c580c17ad550ab7a6", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,41 +1,63 @@\n # Summary\n \n-* [The Basics](basic.md)\n+* [Getting Started](getting-started.md)\n     * [Installing Rust](installing-rust.md)\n     * [Hello, world!](hello-world.md)\n     * [Hello, Cargo!](hello-cargo.md)\n+* [Learn Rust](learn-rust.md)\n+* [Effective Rust](effective-rust.md)\n+    * [The Stack and the Heap](the-stack-and-the-heap.md)\n+    * [`Debug` and `Display`](debug-and-display.md)\n+    * [Testing](testing.md)\n+    * [Documentation](documentation.md)\n+    * [Iterators](iterators.md)\n+    * [Concurrency](concurrency.md)\n+    * [Error Handling](error-handling.md)\n+    * [FFI](ffi.md)\n+    * [`Deref` coercions](deref-coercions.md)\n+* [Syntax and Semantics](syntax-and-semantics.md)\n     * [Variable Bindings](variable-bindings.md)\n-    * [If](if.md)\n+    * [Primitive Types](primitive-types.md)\n     * [Functions](functions.md)\n     * [Comments](comments.md)\n-    * [Compound Data Types](compound-data-types.md)\n+    * [Structs](structs.md)\n+    * [Mutability](mutability.md)\n+    * [Method Syntax](method-syntax.md)\n+    * [Enums](enums.md)\n+    * [`if`](if.md)\n     * [Match](match.md)\n-    * [Looping](looping.md)\n+    * [Patterns](patterns.md)\n+    * [`for` loops](for-loops.md)\n+    * [`while` loops](while-loops.md)\n+    * [Ownership](ownership.md)\n+    * [References and Borrowing](references-and-borrowing.md)\n+    * [Lifetimes](lifetimes.md)\n+    * [Move semantics](move-semantics.md)\n+    * [Drop](drop.md)\n+    * [Vectors](vectors.md)\n+    * [Arrays](arrays.md)\n+    * [Slices](slices.md)\n     * [Strings](strings.md)\n-    * [Arrays, Vectors, and Slices](arrays-vectors-and-slices.md)\n-* [Intermediate Rust](intermediate.md)\n+    * [Traits](traits.md)\n+    * [Operators and Overloading](operators-and-overloading.md)\n+    * [Generics](generics.md)\n+    * [Trait Objects](trait-objects.md)\n+    * [Closures](closures.md)\n+    * [Universal Function Call Syntax](ufcs.md)\n     * [Crates and Modules](crates-and-modules.md)\n-    * [Testing](testing.md)\n-    * [Pointers](pointers.md)\n-    * [Ownership](ownership.md)\n-    * [More Strings](more-strings.md)\n-    * [Patterns](patterns.md)\n-    * [Method Syntax](method-syntax.md)\n+    * [`static`](static.md)\n+    * [`const`](const.md)\n+    * [Tuples](tuples.md)\n+    * [Tuple Structs](tuple-structs.md)\n+    * [Attributes](attributes.md)\n+    * [Conditional Compilation](conditional-compilation.md)\n+    * [`type` aliases](type-aliases.md)\n+    * [Casting between types](casting-between-types.md)\n     * [Associated Types](associated-types.md)\n-    * [Closures](closures.md)\n-    * [Iterators](iterators.md)\n-    * [Generics](generics.md)\n-    * [Traits](traits.md)\n-    * [Static and Dynamic Dispatch](static-and-dynamic-dispatch.md)\n+    * [Unsized Types](unsized-types.md)\n     * [Macros](macros.md)\n-    * [Concurrency](concurrency.md)\n-    * [Error Handling](error-handling.md)\n-    * [Documentation](documentation.md)\n-* [Advanced Topics](advanced.md)\n-    * [FFI](ffi.md)\n-    * [Unsafe Code](unsafe.md)\n-    * [Advanced Macros](advanced-macros.md)\n-* [Unstable Rust](unstable.md)\n+    * [`unsafe` Code](unsafe-code.md)\n+* [Nightly Rust](nightly-rust.md)\n     * [Compiler Plugins](plugins.md)\n     * [Inline Assembly](inline-assembly.md)\n     * [No stdlib](no-stdlib.md)\n@@ -44,5 +66,4 @@\n     * [Link args](link-args.md)\n     * [Benchmark Tests](benchmark-tests.md)\n     * [Box Syntax and Patterns](box-syntax-and-patterns.md)\n-* [Conclusion](conclusion.md)\n * [Glossary](glossary.md)"}, {"sha": "fef458caaaf3343a1aa2e198888d005bc2ba8221", "filename": "src/doc/trpl/advanced-macros.md", "status": "removed", "additions": 0, "deletions": 242, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md?ref=d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "patch": "@@ -1,242 +0,0 @@\n-% Advanced macros\n-\n-This chapter picks up where the [introductory macro chapter](macros.html) left\n-off.\n-\n-# Syntactic requirements\n-\n-Even when Rust code contains un-expanded macros, it can be parsed as a full\n-[syntax tree][ast]. This property can be very useful for editors and other\n-tools that process code. It also has a few consequences for the design of\n-Rust's macro system.\n-\n-[ast]: glossary.html#abstract-syntax-tree\n-\n-One consequence is that Rust must determine, when it parses a macro invocation,\n-whether the macro stands in for\n-\n-* zero or more items,\n-* zero or more methods,\n-* an expression,\n-* a statement, or\n-* a pattern.\n-\n-A macro invocation within a block could stand for some items, or for an\n-expression / statement. Rust uses a simple rule to resolve this ambiguity. A\n-macro invocation that stands for items must be either\n-\n-* delimited by curly braces, e.g. `foo! { ... }`, or\n-* terminated by a semicolon, e.g. `foo!(...);`\n-\n-Another consequence of pre-expansion parsing is that the macro invocation must\n-consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces\n-must be balanced within a macro invocation. For example, `foo!([)` is\n-forbidden. This allows Rust to know where the macro invocation ends.\n-\n-More formally, the macro invocation body must be a sequence of *token trees*.\n-A token tree is defined recursively as either\n-\n-* a sequence of token trees surrounded by matching `()`, `[]`, or `{}`, or\n-* any other single token.\n-\n-Within a matcher, each metavariable has a *fragment specifier*, identifying\n-which syntactic form it matches.\n-\n-* `ident`: an identifier. Examples: `x`; `foo`.\n-* `path`: a qualified name. Example: `T::SpecialA`.\n-* `expr`: an expression. Examples: `2 + 2`; `if true then { 1 } else { 2 }`; `f(42)`.\n-* `ty`: a type. Examples: `i32`; `Vec<(char, String)>`; `&T`.\n-* `pat`: a pattern. Examples: `Some(t)`; `(17, 'a')`; `_`.\n-* `stmt`: a single statement. Example: `let x = 3`.\n-* `block`: a brace-delimited sequence of statements. Example:\n-  `{ log(error, \"hi\"); return 12; }`.\n-* `item`: an [item][]. Examples: `fn foo() { }`; `struct Bar;`.\n-* `meta`: a \"meta item\", as found in attributes. Example: `cfg(target_os = \"windows\")`.\n-* `tt`: a single token tree.\n-\n-There are additional rules regarding the next token after a metavariable:\n-\n-* `expr` variables must be followed by one of: `=> , ;`\n-* `ty` and `path` variables must be followed by one of: `=> , : = > as`\n-* `pat` variables must be followed by one of: `=> , =`\n-* Other variables may be followed by any token.\n-\n-These rules provide some flexibility for Rust's syntax to evolve without\n-breaking existing macros.\n-\n-The macro system does not deal with parse ambiguity at all. For example, the\n-grammar `$($t:ty)* $e:expr` will always fail to parse, because the parser would\n-be forced to choose between parsing `$t` and parsing `$e`. Changing the\n-invocation syntax to put a distinctive token in front can solve the problem. In\n-this case, you can write `$(T $t:ty)* E $e:exp`.\n-\n-[item]: ../reference.html#items\n-\n-# Scoping and macro import/export\n-\n-Macros are expanded at an early stage in compilation, before name resolution.\n-One downside is that scoping works differently for macros, compared to other\n-constructs in the language.\n-\n-Definition and expansion of macros both happen in a single depth-first,\n-lexical-order traversal of a crate's source. So a macro defined at module scope\n-is visible to any subsequent code in the same module, which includes the body\n-of any subsequent child `mod` items.\n-\n-A macro defined within the body of a single `fn`, or anywhere else not at\n-module scope, is visible only within that item.\n-\n-If a module has the `macro_use` attribute, its macros are also visible in its\n-parent module after the child's `mod` item. If the parent also has `macro_use`\n-then the macros will be visible in the grandparent after the parent's `mod`\n-item, and so forth.\n-\n-The `macro_use` attribute can also appear on `extern crate`. In this context\n-it controls which macros are loaded from the external crate, e.g.\n-\n-```rust,ignore\n-#[macro_use(foo, bar)]\n-extern crate baz;\n-```\n-\n-If the attribute is given simply as `#[macro_use]`, all macros are loaded. If\n-there is no `#[macro_use]` attribute then no macros are loaded. Only macros\n-defined with the `#[macro_export]` attribute may be loaded.\n-\n-To load a crate's macros *without* linking it into the output, use `#[no_link]`\n-as well.\n-\n-An example:\n-\n-```rust\n-macro_rules! m1 { () => (()) }\n-\n-// visible here: m1\n-\n-mod foo {\n-    // visible here: m1\n-\n-    #[macro_export]\n-    macro_rules! m2 { () => (()) }\n-\n-    // visible here: m1, m2\n-}\n-\n-// visible here: m1\n-\n-macro_rules! m3 { () => (()) }\n-\n-// visible here: m1, m3\n-\n-#[macro_use]\n-mod bar {\n-    // visible here: m1, m3\n-\n-    macro_rules! m4 { () => (()) }\n-\n-    // visible here: m1, m3, m4\n-}\n-\n-// visible here: m1, m3, m4\n-# fn main() { }\n-```\n-\n-When this library is loaded with `#[macro_use] extern crate`, only `m2` will\n-be imported.\n-\n-The Rust Reference has a [listing of macro-related\n-attributes](../reference.html#macro--and-plugin-related-attributes).\n-\n-# The variable `$crate`\n-\n-A further difficulty occurs when a macro is used in multiple crates. Say that\n-`mylib` defines\n-\n-```rust\n-pub fn increment(x: u32) -> u32 {\n-    x + 1\n-}\n-\n-#[macro_export]\n-macro_rules! inc_a {\n-    ($x:expr) => ( ::increment($x) )\n-}\n-\n-#[macro_export]\n-macro_rules! inc_b {\n-    ($x:expr) => ( ::mylib::increment($x) )\n-}\n-# fn main() { }\n-```\n-\n-`inc_a` only works within `mylib`, while `inc_b` only works outside the\n-library. Furthermore, `inc_b` will break if the user imports `mylib` under\n-another name.\n-\n-Rust does not (yet) have a hygiene system for crate references, but it does\n-provide a simple workaround for this problem. Within a macro imported from a\n-crate named `foo`, the special macro variable `$crate` will expand to `::foo`.\n-By contrast, when a macro is defined and then used in the same crate, `$crate`\n-will expand to nothing. This means we can write\n-\n-```rust\n-#[macro_export]\n-macro_rules! inc {\n-    ($x:expr) => ( $crate::increment($x) )\n-}\n-# fn main() { }\n-```\n-\n-to define a single macro that works both inside and outside our library. The\n-function name will expand to either `::increment` or `::mylib::increment`.\n-\n-To keep this system simple and correct, `#[macro_use] extern crate ...` may\n-only appear at the root of your crate, not inside `mod`. This ensures that\n-`$crate` is a single identifier.\n-\n-# The deep end\n-\n-The introductory chapter mentioned recursive macros, but it did not give the\n-full story. Recursive macros are useful for another reason: Each recursive\n-invocation gives you another opportunity to pattern-match the macro's\n-arguments.\n-\n-As an extreme example, it is possible, though hardly advisable, to implement\n-the [Bitwise Cyclic Tag](http://esolangs.org/wiki/Bitwise_Cyclic_Tag) automaton\n-within Rust's macro system.\n-\n-```rust\n-macro_rules! bct {\n-    // cmd 0:  d ... => ...\n-    (0, $($ps:tt),* ; $_d:tt)\n-        => (bct!($($ps),*, 0 ; ));\n-    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n-        => (bct!($($ps),*, 0 ; $($ds),*));\n-\n-    // cmd 1p:  1 ... => 1 ... p\n-    (1, $p:tt, $($ps:tt),* ; 1)\n-        => (bct!($($ps),*, 1, $p ; 1, $p));\n-    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n-        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n-\n-    // cmd 1p:  0 ... => 0 ...\n-    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n-        => (bct!($($ps),*, 1, $p ; $($ds),*));\n-\n-    // halt on empty data string\n-    ( $($ps:tt),* ; )\n-        => (());\n-}\n-```\n-\n-Exercise: use macros to reduce duplication in the above definition of the\n-`bct!` macro.\n-\n-# Procedural macros\n-\n-If Rust's macro system can't do what you need, you may want to write a\n-[compiler plugin](plugins.html) instead. Compared to `macro_rules!`\n-macros, this is significantly more work, the interfaces are much less stable,\n-and bugs can be much harder to track down. In exchange you get the\n-flexibility of running arbitrary Rust code within the compiler. Syntax\n-extension plugins are sometimes called *procedural macros* for this reason."}, {"sha": "447a8a614bf564c9116fe99bdbd04c2b438b932d", "filename": "src/doc/trpl/advanced.md", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fadvanced.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fadvanced.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced.md?ref=d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "patch": "@@ -1,8 +0,0 @@\n-% Advanced\n-\n-In a similar fashion to \"Intermediate,\" this section is full of individual,\n-deep-dive chapters, which stand alone and can be read in any order. These\n-chapters focus on the most complex features, as well as some things that\n-are only available in upcoming versions of Rust.\n-\n-After reading \"Advanced,\" you'll be a Rust expert!"}, {"sha": "2916dca2c06b01ac863415456de556f289ca44a5", "filename": "src/doc/trpl/arrays-vectors-and-slices.md", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md?ref=d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "patch": "@@ -1,102 +0,0 @@\n-% Arrays, Vectors, and Slices\n-\n-Like many programming languages, Rust has list types to represent a sequence of\n-things. The most basic is the *array*, a fixed-size list of elements of the\n-same type. By default, arrays are immutable.\n-\n-```{rust}\n-let a = [1, 2, 3]; // a: [i32; 3]\n-let mut m = [1, 2, 3]; // mut m: [i32; 3]\n-```\n-\n-There's a shorthand for initializing each element of an array to the same\n-value. In this example, each element of `a` will be initialized to `0`:\n-\n-```{rust}\n-let a = [0; 20]; // a: [i32; 20]\n-```\n-\n-Arrays have type `[T; N]`. We'll talk about this `T` notation later, when we\n-cover generics.\n-\n-You can get the number of elements in an array `a` with `a.len()`, and use\n-`a.iter()` to iterate over them with a for loop. This code will print each\n-number in order:\n-\n-```{rust}\n-let a = [1, 2, 3];\n-\n-println!(\"a has {} elements\", a.len());\n-for e in a.iter() {\n-    println!(\"{}\", e);\n-}\n-```\n-\n-You can access a particular element of an array with *subscript notation*:\n-\n-```{rust}\n-let names = [\"Graydon\", \"Brian\", \"Niko\"]; // names: [&str; 3]\n-\n-println!(\"The second name is: {}\", names[1]);\n-```\n-\n-Subscripts start at zero, like in most programming languages, so the first name\n-is `names[0]` and the second name is `names[1]`. The above example prints\n-`The second name is: Brian`. If you try to use a subscript that is not in the\n-array, you will get an error: array access is bounds-checked at run-time. Such\n-errant access is the source of many bugs in other systems programming\n-languages.\n-\n-A *vector* is a dynamic or \"growable\" array, implemented as the standard\n-library type [`Vec<T>`](../std/vec/) (we'll talk about what the `<T>` means\n-later). Vectors always allocate their data on the heap. Vectors are to slices\n-what `String` is to `&str`. You can create them with the `vec!` macro:\n-\n-```{rust}\n-let v = vec![1, 2, 3]; // v: Vec<i32>\n-```\n-\n-(Notice that unlike the `println!` macro we've used in the past, we use square\n-brackets `[]` with `vec!`. Rust allows you to use either in either situation,\n-this is just convention.)\n-\n-There's an alternate form of `vec!` for repeating an initial value:\n-\n-```\n-let v = vec![0; 10]; // ten zeroes\n-```\n-\n-You can get the length of, iterate over, and subscript vectors just like\n-arrays. In addition, (mutable) vectors can grow automatically:\n-\n-```{rust}\n-let mut nums = vec![1, 2, 3]; // mut nums: Vec<i32>\n-\n-nums.push(4);\n-\n-println!(\"The length of nums is now {}\", nums.len()); // Prints 4\n-```\n-\n-Vectors have many more useful methods.\n-\n-A *slice* is a reference to (or \"view\" into) an array. They are useful for\n-allowing safe, efficient access to a portion of an array without copying. For\n-example, you might want to reference just one line of a file read into memory.\n-By nature, a slice is not created directly, but from an existing variable.\n-Slices have a length, can be mutable or not, and in many ways behave like\n-arrays:\n-\n-```{rust}\n-let a = [0, 1, 2, 3, 4];\n-let middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3\n-\n-for e in middle.iter() {\n-    println!(\"{}\", e); // Prints 1, 2, 3\n-}\n-```\n-\n-You can also take a slice of a vector, `String`, or `&str`, because they are\n-backed by arrays. Slices have type `&[T]`, which we'll talk about when we cover\n-generics.\n-\n-We have now learned all of the most basic Rust concepts."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/arrays.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Farrays.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Farrays.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Farrays.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/associated-types.md", "status": "modified", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fassociated-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fassociated-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fassociated-types.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,202 +0,0 @@\n-% Associated Types\n-\n-Associated types are a powerful part of Rust's type system. They're related to\n-the idea of a 'type family', in other words, grouping multiple types together. That\n-description is a bit abstract, so let's dive right into an example. If you want\n-to write a `Graph` trait, you have two types to be generic over: the node type\n-and the edge type. So you might write a trait, `Graph<N, E>`, that looks like\n-this:\n-\n-```rust\n-trait Graph<N, E> {\n-    fn has_edge(&self, &N, &N) -> bool;\n-    fn edges(&self, &N) -> Vec<E>;\n-    // etc\n-}\n-```\n-\n-While this sort of works, it ends up being awkward. For example, any function\n-that wants to take a `Graph` as a parameter now _also_ needs to be generic over\n-the `N`ode and `E`dge types too:\n-\n-```rust,ignore\n-fn distance<N, E, G: Graph<N, E>>(graph: &G, start: &N, end: &N) -> u32 { ... }\n-```\n-\n-Our distance calculation works regardless of our `Edge` type, so the `E` stuff in\n-this signature is just a distraction.\n-\n-What we really want to say is that a certain `E`dge and `N`ode type come together\n-to form each kind of `Graph`. We can do that with associated types:\n-\n-```rust\n-trait Graph {\n-    type N;\n-    type E;\n-\n-    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n-    fn edges(&self, &Self::N) -> Vec<Self::E>;\n-    // etc\n-}\n-```\n-\n-Now, our clients can be abstract over a given `Graph`:\n-\n-```rust,ignore\n-fn distance<G: Graph>(graph: &G, start: &G::N, end: &G::N) -> uint { ... }\n-```\n-\n-No need to deal with the `E`dge type here!\n-\n-Let's go over all this in more detail.\n-\n-## Defining associated types\n-\n-Let's build that `Graph` trait. Here's the definition:\n-\n-```rust\n-trait Graph {\n-    type N;\n-    type E;\n-\n-    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n-    fn edges(&self, &Self::N) -> Vec<Self::E>;\n-}\n-```\n-\n-Simple enough. Associated types use the `type` keyword, and go inside the body\n-of the trait, with the functions.\n-\n-These `type` declarations can have all the same thing as functions do. For example,\n-if we wanted our `N` type to implement `Display`, so we can print the nodes out,\n-we could do this:\n-\n-```rust\n-use std::fmt;\n-\n-trait Graph {\n-    type N: fmt::Display;\n-    type E;\n-\n-    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n-    fn edges(&self, &Self::N) -> Vec<Self::E>;\n-}\n-```\n-\n-## Implementing associated types\n-\n-Just like any trait, traits that use associated types use the `impl` keyword to\n-provide implementations. Here's a simple implementation of Graph:\n-\n-```rust\n-# trait Graph {\n-#     type N;\n-#     type E;\n-#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n-#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n-# }\n-struct Node;\n-\n-struct Edge;\n-\n-struct MyGraph;\n-\n-impl Graph for MyGraph {\n-    type N = Node;\n-    type E = Edge;\n-\n-    fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n-        true\n-    }\n-\n-    fn edges(&self, n: &Node) -> Vec<Edge> {\n-        Vec::new()\n-    }\n-}\n-```\n-\n-This silly implementation always returns `true` and an empty `Vec<Edge>`, but it\n-gives you an idea of how to implement this kind of thing. We first need three\n-`struct`s, one for the graph, one for the node, and one for the edge. If it made\n-more sense to use a different type, that would work as well, we're just going to\n-use `struct`s for all three here.\n-\n-Next is the `impl` line, which is just like implementing any other trait.\n-\n-From here, we use `=` to define our associated types. The name the trait uses\n-goes on the left of the `=`, and the concrete type we're `impl`ementing this\n-for goes on the right. Finally, we use the concrete types in our function\n-declarations.\n-\n-## Trait objects with associated types\n-\n-There\u2019s one more bit of syntax we should talk about: trait objects. If you\n-try to create a trait object from an associated type, like this:\n-\n-```rust,ignore\n-# trait Graph {\n-#     type N;\n-#     type E;\n-#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n-#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n-# }\n-# struct Node;\n-# struct Edge;\n-# struct MyGraph;\n-# impl Graph for MyGraph {\n-#     type N = Node;\n-#     type E = Edge;\n-#     fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n-#         true\n-#     }\n-#     fn edges(&self, n: &Node) -> Vec<Edge> {\n-#         Vec::new()\n-#     }\n-# }\n-let graph = MyGraph;\n-let obj = Box::new(graph) as Box<Graph>;\n-```\n-\n-You\u2019ll get two errors:\n-\n-```text\n-error: the value of the associated type `E` (from the trait `main::Graph`) must\n-be specified [E0191]\n-let obj = Box::new(graph) as Box<Graph>;\n-          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-24:44 error: the value of the associated type `N` (from the trait\n-`main::Graph`) must be specified [E0191]\n-let obj = Box::new(graph) as Box<Graph>;\n-          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-```\n-\n-We can\u2019t create a trait object like this, because we don\u2019t know the associated\n-types. Instead, we can write this:\n-\n-```rust\n-# trait Graph {\n-#     type N;\n-#     type E;\n-#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n-#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n-# }\n-# struct Node;\n-# struct Edge;\n-# struct MyGraph;\n-# impl Graph for MyGraph {\n-#     type N = Node;\n-#     type E = Edge;\n-#     fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n-#         true\n-#     }\n-#     fn edges(&self, n: &Node) -> Vec<Edge> {\n-#         Vec::new()\n-#     }\n-# }\n-let graph = MyGraph;\n-let obj = Box::new(graph) as Box<Graph<N=Node, E=Edge>>;\n-```\n-\n-The `N=Node` syntax allows us to provide a concrete type, `Node`, for the `N`\n-type parameter. Same with `E=Edge`. If we didn\u2019t proide this constraint, we\n-couldn\u2019t be sure which `impl` to match this trait object to."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/attributes.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fattributes.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fattributes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fattributes.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "c267830e6e0d0c5e0fc700713abb67ad205ef7d4", "filename": "src/doc/trpl/basic.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fbasic.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fbasic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbasic.md?ref=d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "patch": "@@ -1,7 +0,0 @@\n-% Basics\n-\n-This section is a linear introduction to the basic syntax and semantics of\n-Rust. It has individual sections on each part of Rust's syntax.\n-\n-After reading \"Basics,\" you will have a good foundation to learn more about\n-Rust, and can write very simple programs."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/benchmark-tests.md", "status": "modified", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,152 +0,0 @@\n-% Benchmark tests\n-\n-Rust supports benchmark tests, which can test the performance of your\n-code. Let's make our `src/lib.rs` look like this (comments elided):\n-\n-```{rust,ignore}\n-#![feature(test)]\n-\n-extern crate test;\n-\n-pub fn add_two(a: i32) -> i32 {\n-    a + 2\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use test::Bencher;\n-\n-    #[test]\n-    fn it_works() {\n-        assert_eq!(4, add_two(2));\n-    }\n-\n-    #[bench]\n-    fn bench_add_two(b: &mut Bencher) {\n-        b.iter(|| add_two(2));\n-    }\n-}\n-```\n-\n-Note the `test` feature gate, which enables this unstable feature.\n-\n-We've imported the `test` crate, which contains our benchmarking support.\n-We have a new function as well, with the `bench` attribute. Unlike regular\n-tests, which take no arguments, benchmark tests take a `&mut Bencher`. This\n-`Bencher` provides an `iter` method, which takes a closure. This closure\n-contains the code we'd like to benchmark.\n-\n-We can run benchmark tests with `cargo bench`:\n-\n-```bash\n-$ cargo bench\n-   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)\n-     Running target/release/adder-91b3e234d4ed382a\n-\n-running 2 tests\n-test tests::it_works ... ignored\n-test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)\n-\n-test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured\n-```\n-\n-Our non-benchmark test was ignored. You may have noticed that `cargo bench`\n-takes a bit longer than `cargo test`. This is because Rust runs our benchmark\n-a number of times, and then takes the average. Because we're doing so little\n-work in this example, we have a `1 ns/iter (+/- 0)`, but this would show\n-the variance if there was one.\n-\n-Advice on writing benchmarks:\n-\n-\n-* Move setup code outside the `iter` loop; only put the part you want to measure inside\n-* Make the code do \"the same thing\" on each iteration; do not accumulate or change state\n-* Make the outer function idempotent too; the benchmark runner is likely to run\n-  it many times\n-*  Make the inner `iter` loop short and fast so benchmark runs are fast and the\n-   calibrator can adjust the run-length at fine resolution\n-* Make the code in the `iter` loop do something simple, to assist in pinpointing\n-  performance improvements (or regressions)\n-\n-## Gotcha: optimizations\n-\n-There's another tricky part to writing benchmarks: benchmarks compiled with\n-optimizations activated can be dramatically changed by the optimizer so that\n-the benchmark is no longer benchmarking what one expects. For example, the\n-compiler might recognize that some calculation has no external effects and\n-remove it entirely.\n-\n-```{rust,ignore}\n-#![feature(test)]\n-\n-extern crate test;\n-use test::Bencher;\n-\n-#[bench]\n-fn bench_xor_1000_ints(b: &mut Bencher) {\n-    b.iter(|| {\n-        (0..1000).fold(0, |old, new| old ^ new);\n-    });\n-}\n-```\n-\n-gives the following results\n-\n-```text\n-running 1 test\n-test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\n-```\n-\n-The benchmarking runner offers two ways to avoid this. Either, the closure that\n-the `iter` method receives can return an arbitrary value which forces the\n-optimizer to consider the result used and ensures it cannot remove the\n-computation entirely. This could be done for the example above by adjusting the\n-`b.iter` call to\n-\n-```rust\n-# struct X;\n-# impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n-b.iter(|| {\n-    // note lack of `;` (could also use an explicit `return`).\n-    (0..1000).fold(0, |old, new| old ^ new)\n-});\n-```\n-\n-Or, the other option is to call the generic `test::black_box` function, which\n-is an opaque \"black box\" to the optimizer and so forces it to consider any\n-argument as used.\n-\n-```rust\n-#![feature(test)]\n-\n-extern crate test;\n-\n-# fn main() {\n-# struct X;\n-# impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n-b.iter(|| {\n-    let n = test::black_box(1000);\n-\n-    (0..n).fold(0, |a, b| a ^ b)\n-})\n-# }\n-```\n-\n-Neither of these read or modify the value, and are very cheap for small values.\n-Larger values can be passed indirectly to reduce overhead (e.g.\n-`black_box(&huge_struct)`).\n-\n-Performing either of the above changes gives the following benchmarking results\n-\n-```text\n-running 1 test\n-test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\n-```\n-\n-However, the optimizer can still modify a testcase in an undesirable manner\n-even when using either of the above."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/box-syntax-and-patterns.md", "status": "modified", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,100 +0,0 @@\n-%  Box Syntax and Patterns\n-\n-Currently the only stable way to create a `Box` is via the `Box::new` method.\n-Also it is not possible in stable Rust to destructure a `Box` in a match\n-pattern. The unstable `box` keyword can be used to both create and destructure\n-a `Box`. An example usage would be:\n-\n-```\n-#![feature(box_syntax, box_patterns)]\n-\n-fn main() {\n-    let b = Some(box 5);\n-    match b {\n-        Some(box n) if n < 0 => {\n-            println!(\"Box contains negative number {}\", n);\n-        },\n-        Some(box n) if n >= 0 => {\n-            println!(\"Box contains non-negative number {}\", n);\n-        },\n-        None => {\n-            println!(\"No box\");\n-        },\n-        _ => unreachable!()\n-    }\n-}\n-```\n-\n-Note that these features are currently hidden behind the `box_syntax` (box\n-creation) and `box_patterns` (destructuring and pattern matching) gates\n-because the syntax may still change in the future.\n-\n-# Returning Pointers\n-\n-In many languages with pointers, you'd return a pointer from a function\n-so as to avoid copying a large data structure. For example:\n-\n-```{rust}\n-struct BigStruct {\n-    one: i32,\n-    two: i32,\n-    // etc\n-    one_hundred: i32,\n-}\n-\n-fn foo(x: Box<BigStruct>) -> Box<BigStruct> {\n-    Box::new(*x)\n-}\n-\n-fn main() {\n-    let x = Box::new(BigStruct {\n-        one: 1,\n-        two: 2,\n-        one_hundred: 100,\n-    });\n-\n-    let y = foo(x);\n-}\n-```\n-\n-The idea is that by passing around a box, you're only copying a pointer, rather\n-than the hundred `int`s that make up the `BigStruct`.\n-\n-This is an antipattern in Rust. Instead, write this:\n-\n-```rust\n-#![feature(box_syntax)]\n-\n-struct BigStruct {\n-    one: i32,\n-    two: i32,\n-    // etc\n-    one_hundred: i32,\n-}\n-\n-fn foo(x: Box<BigStruct>) -> BigStruct {\n-    *x\n-}\n-\n-fn main() {\n-    let x = Box::new(BigStruct {\n-        one: 1,\n-        two: 2,\n-        one_hundred: 100,\n-    });\n-\n-    let y: Box<BigStruct> = box foo(x);\n-}\n-```\n-\n-This gives you flexibility without sacrificing performance.\n-\n-You may think that this gives us terrible performance: return a value and then\n-immediately box it up ?! Isn't this pattern the worst of both worlds? Rust is\n-smarter than that. There is no copy in this code. `main` allocates enough room\n-for the `box`, passes a pointer to that memory into `foo` as `x`, and then\n-`foo` writes the value straight into the `Box<T>`.\n-\n-This is important enough that it bears repeating: pointers are not for\n-optimizing returning values from your code. Allow the caller to choose how they\n-want to use your output."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/casting-between-types.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/closures.md", "status": "modified", "additions": 0, "deletions": 475, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,475 +0,0 @@\n-% Closures\n-\n-Rust not only has named functions, but anonymous functions as well. Anonymous\n-functions that have an associated environment are called 'closures', because they\n-close over an environment. Rust has a really great implementation of them, as\n-we'll see.\n-\n-# Syntax\n-\n-Closures look like this:\n-\n-```rust\n-let plus_one = |x: i32| x + 1;\n-\n-assert_eq!(2, plus_one(1));\n-```\n-\n-We create a binding, `plus_one`, and assign it to a closure. The closure's\n-arguments go between the pipes (`|`), and the body is an expression, in this\n-case, `x + 1`. Remember that `{ }` is an expression, so we can have multi-line\n-closures too:\n-\n-```rust\n-let plus_two = |x| {\n-    let mut result: i32 = x;\n-\n-    result += 1;\n-    result += 1;\n-\n-    result\n-};\n-\n-assert_eq!(4, plus_two(2));\n-```\n-\n-You'll notice a few things about closures that are a bit different than regular\n-functions defined with `fn`. The first of which is that we did not need to\n-annotate the types of arguments the closure takes or the values it returns. We\n-can:\n-\n-```rust\n-let plus_one = |x: i32| -> i32 { x + 1 };\n-\n-assert_eq!(2, plus_one(1));\n-```\n-\n-But we don't have to. Why is this? Basically, it was chosen for ergonomic reasons.\n-While specifying the full type for named functions is helpful with things like\n-documentation and type inference, the types of closures are rarely documented\n-since they\u2019re anonymous, and they don\u2019t cause the kinds of error-at-a-distance\n-that inferring named function types can.\n-\n-The second is that the syntax is similar, but a bit different. I've added spaces\n-here to make them look a little closer:\n-\n-```rust\n-fn  plus_one_v1   (x: i32 ) -> i32 { x + 1 }\n-let plus_one_v2 = |x: i32 | -> i32 { x + 1 };\n-let plus_one_v3 = |x: i32 |          x + 1  ;\n-```\n-\n-Small differences, but they're similar in ways.\n-\n-# Closures and their environment\n-\n-Closures are called such because they 'close over their environment.' It\n-looks like this:\n-\n-```rust\n-let num = 5;\n-let plus_num = |x: i32| x + num;\n-\n-assert_eq!(10, plus_num(5));\n-```\n-\n-This closure, `plus_num`, refers to a `let` binding in its scope: `num`. More\n-specifically, it borrows the binding. If we do something that would conflict\n-with that binding, we get an error. Like this one:\n-\n-```rust,ignore\n-let mut num = 5;\n-let plus_num = |x: i32| x + num;\n-\n-let y = &mut num;\n-```\n-\n-Which errors with:\n-\n-```text\n-error: cannot borrow `num` as mutable because it is also borrowed as immutable\n-    let y = &mut num;\n-                 ^~~\n-note: previous borrow of `num` occurs here due to use in closure; the immutable\n-  borrow prevents subsequent moves or mutable borrows of `num` until the borrow\n-  ends\n-    let plus_num = |x| x + num;\n-                   ^~~~~~~~~~~\n-note: previous borrow ends here\n-fn main() {\n-    let mut num = 5;\n-    let plus_num = |x| x + num;\n-    \n-    let y = &mut num;\n-}\n-^\n-```\n-\n-A verbose yet helpful error message! As it says, we can't take a mutable borrow\n-on `num` because the closure is already borrowing it. If we let the closure go\n-out of scope, we can:\n-\n-```rust\n-let mut num = 5;\n-{\n-    let plus_num = |x: i32| x + num;\n-\n-} // plus_num goes out of scope, borrow of num ends\n-\n-let y = &mut num;\n-```\n-\n-If your closure requires it, however, Rust will take ownership and move\n-the environment instead:\n-\n-```rust,ignore\n-let nums = vec![1, 2, 3];\n-\n-let takes_nums = || nums;\n-\n-println!(\"{:?}\", nums);\n-```\n-\n-This gives us:\n-\n-```text\n-note: `nums` moved into closure environment here because it has type\n-  `[closure(()) -> collections::vec::Vec<i32>]`, which is non-copyable\n-let takes_nums = || nums;\n-                    ^~~~~~~\n-```\n-\n-`Vec<T>` has ownership over its contents, and therefore, when we refer to it\n-in our closure, we have to take ownership of `nums`. It's the same as if we'd\n-passed `nums` to a function that took ownership of it.\n-\n-## `move` closures\n-\n-We can force our closure to take ownership of its environment with the `move`\n-keyword:\n-\n-```rust\n-let num = 5;\n-\n-let owns_num = move |x: i32| x + num;\n-```\n-\n-Now, even though the keyword is `move`, the variables follow normal move semantics.\n-In this case, `5` implements `Copy`, and so `owns_num` takes ownership of a copy\n-of `num`. So what's the difference?\n-\n-```rust\n-let mut num = 5;\n-\n-{ \n-    let mut add_num = |x: i32| num += x;\n-\n-    add_num(5);\n-}\n-\n-assert_eq!(10, num);\n-```\n-\n-So in this case, our closure took a mutable reference to `num`, and then when\n-we called `add_num`, it mutated the underlying value, as we'd expect. We also\n-needed to declare `add_num` as `mut` too, because we\u2019re mutating its\n-environment.\n-\n-If we change to a `move` closure, it's different:\n-\n-```rust\n-let mut num = 5;\n-\n-{ \n-    let mut add_num = move |x: i32| num += x;\n-\n-    add_num(5);\n-}\n-\n-assert_eq!(5, num);\n-```\n-\n-We only get `5`. Rather than taking a mutable borrow out on our `num`, we took\n-ownership of a copy.\n-\n-Another way to think about `move` closures: they give a closure its own stack\n-frame.  Without `move`, a closure may be tied to the stack frame that created\n-it, while a `move` closure is self-contained. This means that you cannot\n-generally return a non-`move` closure from a function, for example.\n-\n-But before we talk about taking and returning closures, we should talk some more\n-about the way that closures are implemented. As a systems language, Rust gives\n-you tons of control over what your code does, and closures are no different.\n-\n-# Closure implementation\n-\n-Rust's implementation of closures is a bit different than other languages. They\n-are effectively syntax sugar for traits. You'll want to make sure to have read\n-the [traits chapter][traits] before this one, as well as the chapter on [static\n-and dynamic dispatch][dispatch], which talks about trait objects.\n-\n-[traits]: traits.html\n-[dispatch]: static-and-dynamic-dispatch.html\n-\n-Got all that? Good.\n-\n-The key to understanding how closures work under the hood is something a bit\n-strange: Using `()` to call a function, like `foo()`, is an overloadable\n-operator. From this, everything else clicks into place. In Rust, we use the\n-trait system to overload operators. Calling functions is no different. We have\n-three separate traits to overload with:\n-\n-```rust\n-# mod foo {\n-pub trait Fn<Args> : FnMut<Args> {\n-    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n-}\n-\n-pub trait FnMut<Args> : FnOnce<Args> {\n-    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n-}\n-\n-pub trait FnOnce<Args> {\n-    type Output;\n-\n-    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n-}\n-# }\n-```\n-\n-You'll notice a few differences between these traits, but a big one is `self`:\n-`Fn` takes `&self`, `FnMut` takes `&mut self`, and `FnOnce` takes `self`. This\n-covers all three kinds of `self` via the usual method call syntax. But we've\n-split them up into three traits, rather than having a single one. This gives us\n-a large amount of control over what kind of closures we can take.\n-\n-The `|| {}` syntax for closures is sugar for these three traits. Rust will\n-generate a struct for the environment, `impl` the appropriate trait, and then\n-use it.\n-\n-# Taking closures as arguments\n-\n-Now that we know that closures are traits, we already know how to accept and\n-return closures: just like any other trait!\n-\n-This also means that we can choose static vs dynamic dispatch as well. First,\n-let's write a function which takes something callable, calls it, and returns\n-the result:\n-\n-```rust\n-fn call_with_one<F>(some_closure: F) -> i32\n-    where F : Fn(i32) -> i32 {\n-\n-    some_closure(1)\n-}\n-\n-let answer = call_with_one(|x| x + 2);\n-\n-assert_eq!(3, answer);\n-```\n-\n-We pass our closure, `|x| x + 2`, to `call_with_one`. It just does what it\n-suggests: it calls the closure, giving it `1` as an argument.\n-\n-Let's examine the signature of `call_with_one` in more depth:\n-\n-```rust\n-fn call_with_one<F>(some_closure: F) -> i32\n-#    where F : Fn(i32) -> i32 {\n-#    some_closure(1) }\n-```\n-\n-We take one parameter, and it has the type `F`. We also return a `i32`. This part\n-isn't interesting. The next part is:\n-\n-```rust\n-# fn call_with_one<F>(some_closure: F) -> i32\n-    where F : Fn(i32) -> i32 {\n-#   some_closure(1) }\n-```\n-\n-Because `Fn` is a trait, we can bound our generic with it. In this case, our closure\n-takes a `i32` as an argument and returns an `i32`, and so the generic bound we use\n-is `Fn(i32) -> i32`.\n-\n-There's one other key point here: because we're bounding a generic with a\n-trait, this will get monomorphized, and therefore, we'll be doing static\n-dispatch into the closure. That's pretty neat. In many langauges, closures are\n-inherently heap allocated, and will always involve dynamic dispatch. In Rust,\n-we can stack allocate our closure environment, and statically dispatch the\n-call. This happens quite often with iterators and their adapters, which often\n-take closures as arguments.\n-\n-Of course, if we want dynamic dispatch, we can get that too. A trait object\n-handles this case, as usual:\n-\n-```rust\n-fn call_with_one(some_closure: &Fn(i32) -> i32) -> i32 {\n-    some_closure(1)\n-}\n-\n-let answer = call_with_one(&|x| x + 2);\n-\n-assert_eq!(3, answer);\n-```\n-\n-Now we take a trait object, a `&Fn`. And we have to make a reference\n-to our closure when we pass it to `call_with_one`, so we use `&||`.\n-\n-# Returning closures\n-\n-It\u2019s very common for functional-style code to return closures in various\n-situations. If you try to return a closure, you may run into an error. At\n-first, it may seem strange, but we'll figure it out. Here's how you'd probably\n-try to return a closure from a function:\n-\n-```rust,ignore\n-fn factory() -> (Fn(i32) -> Vec<i32>) {\n-    let vec = vec![1, 2, 3];\n-\n-    |n| vec.push(n)\n-}\n-\n-let f = factory();\n-\n-let answer = f(4);\n-assert_eq!(vec![1, 2, 3, 4], answer);\n-```\n-\n-This gives us these long, related errors:\n-\n-```text\n-error: the trait `core::marker::Sized` is not implemented for the type\n-`core::ops::Fn(i32) -> collections::vec::Vec<i32>` [E0277]\n-f = factory();\n-^\n-note: `core::ops::Fn(i32) -> collections::vec::Vec<i32>` does not have a\n-constant size known at compile-time\n-f = factory();\n-^\n-error: the trait `core::marker::Sized` is not implemented for the type\n-`core::ops::Fn(i32) -> collections::vec::Vec<i32>` [E0277]\n-factory() -> (Fn(i32) -> Vec<i32>) {\n-             ^~~~~~~~~~~~~~~~~~~~~\n-note: `core::ops::Fn(i32) -> collections::vec::Vec<i32>` does not have a constant size known at compile-time\n-fa ctory() -> (Fn(i32) -> Vec<i32>) {\n-              ^~~~~~~~~~~~~~~~~~~~~\n-\n-```\n-\n-In order to return something from a function, Rust needs to know what\n-size the return type is. But since `Fn` is a trait, it could be various\n-things of various sizes: many different types can implement `Fn`. An easy\n-way to give something a size is to take a reference to it, as references\n-have a known size. So we'd write this:\n-\n-```rust,ignore\n-fn factory() -> &(Fn(i32) -> Vec<i32>) {\n-    let vec = vec![1, 2, 3];\n-\n-    |n| vec.push(n)\n-}\n-\n-let f = factory();\n-\n-let answer = f(4);\n-assert_eq!(vec![1, 2, 3, 4], answer);\n-```\n-\n-But we get another error:\n-\n-```text\n-error: missing lifetime specifier [E0106]\n-fn factory() -> &(Fn(i32) -> i32) {\n-                ^~~~~~~~~~~~~~~~~\n-```\n-\n-Right. Because we have a reference, we need to give it a lifetime. But\n-our `factory()` function takes no arguments, so elision doesn't kick in\n-here. What lifetime can we choose? `'static`:\n-\n-```rust,ignore\n-fn factory() -> &'static (Fn(i32) -> i32) {\n-    let num = 5;\n-\n-    |x| x + num\n-}\n-\n-let f = factory();\n-\n-let answer = f(1);\n-assert_eq!(6, answer);\n-```\n-\n-But we get another error:\n-\n-```text\n-error: mismatched types:\n- expected `&'static core::ops::Fn(i32) -> i32`,\n-    found `[closure <anon>:7:9: 7:20]`\n-(expected &-ptr,\n-    found closure) [E0308]\n-         |x| x + num\n-         ^~~~~~~~~~~\n-\n-```\n-\n-This error is letting us know that we don't have a `&'static Fn(i32) -> i32`,\n-we have a `[closure <anon>:7:9: 7:20]`. Wait, what?\n-\n-Because each closure generates its own environment `struct` and implementation\n-of `Fn` and friends, these types are anonymous. They exist just solely for\n-this closure. So Rust shows them as `closure <anon>`, rather than some\n-autogenerated name.\n-\n-But why doesn't our closure implement `&'static Fn`? Well, as we discussed before,\n-closures borrow their environment. And in this case, our environment is based\n-on a stack-allocated `5`, the `num` variable binding. So the borrow has a lifetime\n-of the stack frame. So if we returned this closure, the function call would be\n-over, the stack frame would go away, and our closure is capturing an environment\n-of garbage memory!\n-\n-So what to do? This _almost_ works:\n-\n-```rust,ignore\n-fn factory() -> Box<Fn(i32) -> i32> {\n-    let num = 5;\n-\n-    Box::new(|x| x + num)\n-}\n-# fn main() {\n-let f = factory();\n-\n-let answer = f(1);\n-assert_eq!(6, answer);\n-# }\n-```\n-\n-We use a trait object, by `Box`ing up the `Fn`. There's just one last problem:\n-\n-```text\n-error: `num` does not live long enough\n-Box::new(|x| x + num)\n-         ^~~~~~~~~~~\n-```\n-\n-We still have a reference to the parent stack frame. With one last fix, we can\n-make this work:\n-\n-```rust\n-fn factory() -> Box<Fn(i32) -> i32> {\n-    let num = 5;\n-\n-    Box::new(move |x| x + num)\n-}\n-# fn main() {\n-let f = factory();\n-\n-let answer = f(1);\n-assert_eq!(6, answer);\n-# }\n-```\n-\n-By making the inner closure a `move Fn`, we create a new stack frame for our\n-closure. By `Box`ing it up, we've given it a known size, and allowing it to\n-escape our stack frame."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/comments.md", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcomments.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,47 +0,0 @@\n-% Comments\n-\n-Now that we have some functions, it's a good idea to learn about comments.\n-Comments are notes that you leave to other programmers to help explain things\n-about your code. The compiler mostly ignores them.\n-\n-Rust has two kinds of comments that you should care about: *line comments*\n-and *doc comments*.\n-\n-```{rust}\n-// Line comments are anything after '//' and extend to the end of the line.\n-\n-let x = 5; // this is also a line comment.\n-\n-// If you have a long explanation for something, you can put line comments next\n-// to each other. Put a space between the // and your comment so that it's\n-// more readable.\n-```\n-\n-The other kind of comment is a doc comment. Doc comments use `///` instead of\n-`//`, and support Markdown notation inside:\n-\n-```{rust}\n-/// `hello` is a function that prints a greeting that is personalized based on\n-/// the name given.\n-///\n-/// # Arguments\n-///\n-/// * `name` - The name of the person you'd like to greet.\n-///\n-/// # Examples\n-///\n-/// ```rust\n-/// let name = \"Steve\";\n-/// hello(name); // prints \"Hello, Steve!\"\n-/// ```\n-fn hello(name: &str) {\n-    println!(\"Hello, {}!\", name);\n-}\n-```\n-\n-When writing doc comments, adding sections for any arguments, return values,\n-and providing some examples of usage is very, very helpful. Don't worry about\n-the `&str`, we'll get to it soon.\n-\n-You can use the [`rustdoc`](documentation.html) tool to generate HTML documentation\n-from these doc comments."}, {"sha": "e44d2edd667a1ea822cde1798278bbc8b1fe3b55", "filename": "src/doc/trpl/compound-data-types.md", "status": "removed", "additions": 0, "deletions": 364, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "patch": "@@ -1,364 +0,0 @@\n-% Compound Data Types\n-\n-Rust, like many programming languages, has a number of different data types\n-that are built-in. You've already done some simple work with integers and\n-strings, but next, let's talk about some more complicated ways of storing data.\n-\n-## Tuples\n-\n-The first compound data type we're going to talk about is called the *tuple*.\n-A tuple is an ordered list of fixed size. Like this:\n-\n-```rust\n-let x = (1, \"hello\");\n-```\n-\n-The parentheses and commas form this two-length tuple. Here's the same code, but\n-with the type annotated:\n-\n-```rust\n-let x: (i32, &str) = (1, \"hello\");\n-```\n-\n-As you can see, the type of a tuple looks just like the tuple, but with each\n-position having a type name rather than the value. Careful readers will also\n-note that tuples are heterogeneous: we have an `i32` and a `&str` in this tuple.\n-You have briefly seen `&str` used as a type before, and we'll discuss the\n-details of strings later. In systems programming languages, strings are a bit\n-more complex than in other languages. For now, just read `&str` as a *string\n-slice*, and we'll learn more soon.\n-\n-You can access the fields in a tuple through a *destructuring let*. Here's\n-an example:\n-\n-```rust\n-let (x, y, z) = (1, 2, 3);\n-\n-println!(\"x is {}\", x);\n-```\n-\n-Remember before when I said the left-hand side of a `let` statement was more\n-powerful than just assigning a binding? Here we are. We can put a pattern on\n-the left-hand side of the `let`, and if it matches up to the right-hand side,\n-we can assign multiple bindings at once. In this case, `let` \"destructures,\"\n-or \"breaks up,\" the tuple, and assigns the bits to three bindings.\n-\n-This pattern is very powerful, and we'll see it repeated more later.\n-\n-There are also a few things you can do with a tuple as a whole, without\n-destructuring. You can assign one tuple into another, if they have the same\n-contained types and [arity]. Tuples have the same arity when they have the same\n-length.\n-\n-```rust\n-let mut x = (1, 2); // x: (i32, i32)\n-let y = (2, 3); // y: (i32, i32)\n-\n-x = y;\n-```\n-\n-You can also check for equality with `==`. Again, this will only compile if the\n-tuples have the same type.\n-\n-```rust\n-let x = (1, 2, 3);\n-let y = (2, 2, 4);\n-\n-if x == y {\n-    println!(\"yes\");\n-} else {\n-    println!(\"no\");\n-}\n-```\n-\n-This will print `no`, because some of the values aren't equal.\n-\n-Note that the order of the values is considered when checking for equality,\n-so the following example will also print `no`.\n-\n-```rust\n-let x = (1, 2, 3);\n-let y = (2, 1, 3);\n-\n-if x == y {\n-    println!(\"yes\");\n-} else {\n-    println!(\"no\");\n-}\n-```\n-\n-One other use of tuples is to return multiple values from a function:\n-\n-```rust\n-fn next_two(x: i32) -> (i32, i32) { (x + 1, x + 2) }\n-\n-fn main() {\n-    let (x, y) = next_two(5);\n-    println!(\"x, y = {}, {}\", x, y);\n-}\n-```\n-\n-Even though Rust functions can only return one value, a tuple *is* one value,\n-that happens to be made up of more than one value. You can also see in this\n-example how you can destructure a pattern returned by a function, as well.\n-\n-Tuples are a very simple data structure, and so are not often what you want.\n-Let's move on to their bigger sibling, structs.\n-\n-## Structs\n-\n-A struct is another form of a *record type*, just like a tuple. There's a\n-difference: structs give each element that they contain a name, called a\n-*field* or a *member*. Check it out:\n-\n-```rust\n-struct Point {\n-    x: i32,\n-    y: i32,\n-}\n-\n-fn main() {\n-    let origin = Point { x: 0, y: 0 }; // origin: Point\n-\n-    println!(\"The origin is at ({}, {})\", origin.x, origin.y);\n-}\n-```\n-\n-There's a lot going on here, so let's break it down. We declare a struct with\n-the `struct` keyword, and then with a name. By convention, structs begin with a\n-capital letter and are also camel cased: `PointInSpace`, not `Point_In_Space`.\n-\n-We can create an instance of our struct via `let`, as usual, but we use a `key:\n-value` style syntax to set each field. The order doesn't need to be the same as\n-in the original declaration.\n-\n-Finally, because fields have names, we can access the field through dot\n-notation: `origin.x`.\n-\n-The values in structs are immutable by default, like other bindings in Rust.\n-Use `mut` to make them mutable:\n-\n-```{rust}\n-struct Point {\n-    x: i32,\n-    y: i32,\n-}\n-\n-fn main() {\n-    let mut point = Point { x: 0, y: 0 };\n-\n-    point.x = 5;\n-\n-    println!(\"The point is at ({}, {})\", point.x, point.y);\n-}\n-```\n-\n-This will print `The point is at (5, 0)`.\n-\n-## Tuple Structs and Newtypes\n-\n-Rust has another data type that's like a hybrid between a tuple and a struct,\n-called a *tuple struct*. Tuple structs do have a name, but their fields don't:\n-\n-\n-```{rust}\n-struct Color(i32, i32, i32);\n-struct Point(i32, i32, i32);\n-```\n-\n-These two will not be equal, even if they have the same values:\n-\n-```{rust}\n-# struct Color(i32, i32, i32);\n-# struct Point(i32, i32, i32);\n-let black = Color(0, 0, 0);\n-let origin = Point(0, 0, 0);\n-```\n-\n-It is almost always better to use a struct than a tuple struct. We would write\n-`Color` and `Point` like this instead:\n-\n-```{rust}\n-struct Color {\n-    red: i32,\n-    blue: i32,\n-    green: i32,\n-}\n-\n-struct Point {\n-    x: i32,\n-    y: i32,\n-    z: i32,\n-}\n-```\n-\n-Now, we have actual names, rather than positions. Good names are important,\n-and with a struct, we have actual names.\n-\n-There _is_ one case when a tuple struct is very useful, though, and that's a\n-tuple struct with only one element. We call this the *newtype* pattern, because\n-it allows you to create a new type, distinct from that of its contained value\n-and expressing its own semantic meaning:\n-\n-```{rust}\n-struct Inches(i32);\n-\n-let length = Inches(10);\n-\n-let Inches(integer_length) = length;\n-println!(\"length is {} inches\", integer_length);\n-```\n-\n-As you can see here, you can extract the inner integer type through a\n-destructuring `let`, as we discussed previously in 'tuples.' In this case, the\n-`let Inches(integer_length)` assigns `10` to `integer_length`.\n-\n-## Enums\n-\n-Finally, Rust has a \"sum type\", an *enum*. Enums are an incredibly useful\n-feature of Rust, and are used throughout the standard library. An `enum` is\n-a type which relates a set of alternates to a specific name. For example, below\n-we define `Character` to be either a `Digit` or something else. These\n-can be used via their fully scoped names: `Character::Other` (more about `::`\n-below).\n-\n-```rust\n-enum Character {\n-    Digit(i32),\n-    Other,\n-}\n-```\n-\n-Most normal types are allowed as the variant components of an `enum`. Here are\n-some examples:\n-\n-```rust\n-struct Empty;\n-struct Color(i32, i32, i32);\n-struct Length(i32);\n-struct Status { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n-struct HeightDatabase(Vec<i32>);\n-```\n-\n-You see that, depending on its type, an `enum` variant may or may not hold data.\n-In `Character`, for instance, `Digit` gives a meaningful name for an `i32`\n-value, where `Other` is only a name. However, the fact that they represent\n-distinct categories of `Character` is a very useful property.\n-\n-As with structures, the variants of an enum by default are not comparable with\n-equality operators (`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not\n-support other binary operations such as `*` and `+`. As such, the following code\n-is invalid for the example `Character` type:\n-\n-```{rust,ignore}\n-// These assignments both succeed\n-let ten  = Character::Digit(10);\n-let four = Character::Digit(4);\n-\n-// Error: `*` is not implemented for type `Character`\n-let forty = ten * four;\n-\n-// Error: `<=` is not implemented for type `Character`\n-let four_is_smaller = four <= ten;\n-\n-// Error: `==` is not implemented for type `Character`\n-let four_equals_ten = four == ten;\n-```\n-\n-This may seem rather limiting, but it's a limitation which we can overcome.\n-There are two ways: by implementing equality ourselves, or by pattern matching\n-variants with [`match`][match] expressions, which you'll learn in the next\n-chapter. We don't know enough about Rust to implement equality yet, but we can\n-use the `Ordering` enum from the standard library, which does:\n-\n-```\n-enum Ordering {\n-    Less,\n-    Equal,\n-    Greater,\n-}\n-```\n-\n-Because `Ordering` has already been defined for us, we will import it with the\n-`use` keyword. Here's an example of how it is used:\n-\n-```{rust}\n-use std::cmp::Ordering;\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    let ordering = cmp(x, y); // ordering: Ordering\n-\n-    if ordering == Ordering::Less {\n-        println!(\"less\");\n-    } else if ordering == Ordering::Greater {\n-        println!(\"greater\");\n-    } else if ordering == Ordering::Equal {\n-        println!(\"equal\");\n-    }\n-}\n-```\n-\n-The `::` symbol is used to indicate a namespace. In this case, `Ordering` lives\n-in the `cmp` submodule of the `std` module. We'll talk more about modules later\n-in the guide. For now, all you need to know is that you can `use` things from\n-the standard library if you need them.\n-\n-Okay, let's talk about the actual code in the example. `cmp` is a function that\n-compares two things, and returns an `Ordering`. We return either\n-`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on\n-whether the first value is less than, greater than, or equal to the second. Note\n-that each variant of the `enum` is namespaced under the `enum` itself: it's\n-`Ordering::Greater`, not `Greater`.\n-\n-The `ordering` variable has the type `Ordering`, and so contains one of the\n-three values. We then do a bunch of `if`/`else` comparisons to check which\n-one it is.\n-\n-This `Ordering::Greater` notation is too long. Let's use another form of `use`\n-to import the `enum` variants instead. This will avoid full scoping:\n-\n-```{rust}\n-use std::cmp::Ordering::{self, Equal, Less, Greater};\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Less }\n-    else if a > b { Greater }\n-    else { Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    let ordering = cmp(x, y); // ordering: Ordering\n-\n-    if ordering == Less { println!(\"less\"); }\n-    else if ordering == Greater { println!(\"greater\"); }\n-    else if ordering == Equal { println!(\"equal\"); }\n-}\n-```\n-\n-Importing variants is convenient and compact, but can also cause name conflicts,\n-so do this with caution. For this reason, it's normally considered better style\n-to `use` an enum rather than its variants directly.\n-\n-As you can see, `enum`s are quite a powerful tool for data representation, and\n-are even more useful when they're [generic][generics] across types. Before we\n-get to generics, though, let's talk about how to use enums with pattern\n-matching, a tool that will let us deconstruct sum types (the type theory term\n-for enums) like `Ordering` in a very elegant way that avoids all these messy\n-and brittle `if`/`else`s.\n-\n-\n-[arity]: ./glossary.html#arity\n-[match]: ./match.html\n-[generics]: ./generics.html"}, {"sha": "9afddb11314fe9dd0da67ca9e2a6c232fec0280b", "filename": "src/doc/trpl/conclusion.md", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fconclusion.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fconclusion.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconclusion.md?ref=d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "patch": "@@ -1,11 +0,0 @@\n-% Conclusion\n-\n-We covered a lot of ground here. When you've mastered everything in this Guide,\n-you will have a firm grasp of Rust development. There's a whole lot more\n-out there, though, we've just covered the surface. There's tons of topics that\n-you can dig deeper into, e.g. by reading the API documentation of the\n-[standard library](http://doc.rust-lang.org/std/), by discovering solutions for\n-common problems on [Rust by Example](http://rustbyexample.com/), or by browsing\n-crates written by the community on [crates.io](https://crates.io/).\n-\n-Happy hacking!"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 0, "deletions": 358, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,358 +0,0 @@\n-% Concurrency\n-\n-Concurrency and parallelism are incredibly important topics in computer\n-science, and are also a hot topic in industry today. Computers are gaining more\n-and more cores, yet many programmers aren't prepared to fully utilize them.\n-\n-Rust's memory safety features also apply to its concurrency story too. Even\n-concurrent Rust programs must be memory safe, having no data races. Rust's type\n-system is up to the task, and gives you powerful ways to reason about\n-concurrent code at compile time.\n-\n-Before we talk about the concurrency features that come with Rust, it's important\n-to understand something: Rust is low-level enough that all of this is provided\n-by the standard library, not by the language. This means that if you don't like\n-some aspect of the way Rust handles concurrency, you can implement an alternative\n-way of doing things. [mio](https://github.com/carllerche/mio) is a real-world\n-example of this principle in action.\n-\n-## Background: `Send` and `Sync`\n-\n-Concurrency is difficult to reason about. In Rust, we have a strong, static\n-type system to help us reason about our code. As such, Rust gives us two traits\n-to help us make sense of code that can possibly be concurrent.\n-\n-### `Send`\n-\n-The first trait we're going to talk about is\n-[`Send`](../std/marker/trait.Send.html). When a type `T` implements `Send`, it indicates\n-to the compiler that something of this type is able to have ownership transferred\n-safely between threads.\n-\n-This is important to enforce certain restrictions. For example, if we have a\n-channel connecting two threads, we would want to be able to send some data\n-down the channel and to the other thread. Therefore, we'd ensure that `Send` was\n-implemented for that type.\n-\n-In the opposite way, if we were wrapping a library with FFI that isn't\n-threadsafe, we wouldn't want to implement `Send`, and so the compiler will help\n-us enforce that it can't leave the current thread.\n-\n-### `Sync`\n-\n-The second of these traits is called [`Sync`](../std/marker/trait.Sync.html).\n-When a type `T` implements `Sync`, it indicates to the compiler that something\n-of this type has no possibility of introducing memory unsafety when used from\n-multiple threads concurrently.\n-\n-For example, sharing immutable data with an atomic reference count is\n-threadsafe. Rust provides a type like this, `Arc<T>`, and it implements `Sync`,\n-so it is safe to share between threads.\n-\n-These two traits allow you to use the type system to make strong guarantees\n-about the properties of your code under concurrency. Before we demonstrate\n-why, we need to learn how to create a concurrent Rust program in the first\n-place!\n-\n-## Threads\n-\n-Rust's standard library provides a library for 'threads', which allow you to\n-run Rust code in parallel. Here's a basic example of using `std::thread`:\n-\n-```\n-use std::thread;\n-\n-fn main() {\n-    thread::scoped(|| {\n-        println!(\"Hello from a thread!\");\n-    });\n-}\n-```\n-\n-The `thread::scoped()` method accepts a closure, which is executed in a new\n-thread. It's called `scoped` because this thread returns a join guard:\n-\n-```\n-use std::thread;\n-\n-fn main() {\n-    let guard = thread::scoped(|| {\n-        println!(\"Hello from a thread!\");\n-    });\n-\n-    // guard goes out of scope here\n-}\n-```\n-\n-When `guard` goes out of scope, it will block execution until the thread is\n-finished. If we didn't want this behaviour, we could use `thread::spawn()`:\n-\n-```\n-use std::thread;\n-\n-fn main() {\n-    thread::spawn(|| {\n-        println!(\"Hello from a thread!\");\n-    });\n-\n-    thread::sleep_ms(50);\n-}\n-```\n-\n-We need to `sleep` here because when `main()` ends, it kills all of the\n-running threads.\n-\n-[`scoped`](std/thread/struct.Builder.html#method.scoped) has an interesting\n-type signature:\n-\n-```text\n-fn scoped<'a, T, F>(self, f: F) -> JoinGuard<'a, T>\n-    where T: Send + 'a,\n-          F: FnOnce() -> T,\n-          F: Send + 'a\n-```\n-\n-Specifically, `F`, the closure that we pass to execute in the new thread. It\n-has two restrictions: It must be a `FnOnce` from `()` to `T`. Using `FnOnce`\n-allows the closure to take ownership of any data it mentions from the parent\n-thread. The other restriction is that `F` must be `Send`. We aren't allowed to\n-transfer this ownership unless the type thinks that's okay.\n-\n-Many languages have the ability to execute threads, but it's wildly unsafe.\n-There are entire books about how to prevent errors that occur from shared\n-mutable state. Rust helps out with its type system here as well, by preventing\n-data races at compile time. Let's talk about how you actually share things\n-between threads.\n-\n-## Safe Shared Mutable State\n-\n-Due to Rust's type system, we have a concept that sounds like a lie: \"safe\n-shared mutable state.\" Many programmers agree that shared mutable state is\n-very, very bad.\n-\n-Someone once said this:\n-\n-> Shared mutable state is the root of all evil. Most languages attempt to deal\n-> with this problem through the 'mutable' part, but Rust deals with it by\n-> solving the 'shared' part.\n-\n-The same [ownership system](ownership.html) that helps prevent using pointers\n-incorrectly also helps rule out data races, one of the worst kinds of\n-concurrency bugs.\n-\n-As an example, here is a Rust program that would have a data race in many\n-languages. It will not compile:\n-\n-```ignore\n-use std::thread;\n-\n-fn main() {\n-    let mut data = vec![1u32, 2, 3];\n-\n-    for i in 0..2 {\n-        thread::spawn(move || {\n-            data[i] += 1;\n-        });\n-    }\n-\n-    thread::sleep_ms(50);\n-}\n-```\n-\n-This gives us an error:\n-\n-```text\n-8:17 error: capture of moved value: `data`\n-        data[i] += 1;\n-        ^~~~\n-```\n-\n-In this case, we know that our code _should_ be safe, but Rust isn't sure. And\n-it's actually not safe: if we had a reference to `data` in each thread, and the\n-thread takes ownership of the reference, we have three owners! That's bad. We\n-can fix this by using the `Arc<T>` type, which is an atomic reference counted\n-pointer. The 'atomic' part means that it's safe to share across threads.\n-\n-`Arc<T>` assumes one more property about its contents to ensure that it is safe\n-to share across threads: it assumes its contents are `Sync`. But in our\n-case, we want to be able to mutate the value. We need a type that can ensure\n-only one person at a time can mutate what's inside. For that, we can use the\n-`Mutex<T>` type. Here's the second version of our code. It still doesn't work,\n-but for a different reason:\n-\n-```ignore\n-use std::thread;\n-use std::sync::Mutex;\n-\n-fn main() {\n-    let mut data = Mutex::new(vec![1u32, 2, 3]);\n-\n-    for i in 0..2 {\n-        let data = data.lock().unwrap();\n-        thread::spawn(move || {\n-            data[i] += 1;\n-        });\n-    }\n-\n-    thread::sleep_ms(50);\n-}\n-```\n-\n-Here's the error:\n-\n-```text\n-<anon>:9:9: 9:22 error: the trait `core::marker::Send` is not implemented for the type `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` [E0277]\n-<anon>:11         thread::spawn(move || {\n-                  ^~~~~~~~~~~~~\n-<anon>:9:9: 9:22 note: `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` cannot be sent between threads safely\n-<anon>:11         thread::spawn(move || {\n-                  ^~~~~~~~~~~~~\n-```\n-\n-You see, [`Mutex`](std/sync/struct.Mutex.html) has a\n-[`lock`](http://doc.rust-lang.org/nightly/std/sync/struct.Mutex.html#method.lock)\n-method which has this signature:\n-\n-```ignore\n-fn lock(&self) -> LockResult<MutexGuard<T>>\n-```\n-\n-Because `Send` is not implemented for `MutexGuard<T>`, we can't transfer the\n-guard across thread boundaries, which gives us our error.\n-\n-We can use `Arc<T>` to fix this. Here's the working version:\n-\n-```\n-use std::sync::{Arc, Mutex};\n-use std::thread;\n-\n-fn main() {\n-    let data = Arc::new(Mutex::new(vec![1u32, 2, 3]));\n-\n-    for i in 0..2 {\n-        let data = data.clone();\n-        thread::spawn(move || {\n-            let mut data = data.lock().unwrap();\n-            data[i] += 1;\n-        });\n-    }\n-\n-    thread::sleep_ms(50);\n-}\n-```\n-\n-We now call `clone()` on our `Arc`, which increases the internal count. This\n-handle is then moved into the new thread. Let's examine the body of the\n-thread more closely:\n-\n-```rust\n-# use std::sync::{Arc, Mutex};\n-# use std::thread;\n-# fn main() {\n-#     let data = Arc::new(Mutex::new(vec![1u32, 2, 3]));\n-#     for i in 0..2 {\n-#         let data = data.clone();\n-thread::spawn(move || {\n-    let mut data = data.lock().unwrap();\n-    data[i] += 1;\n-});\n-#     }\n-#     thread::sleep_ms(50);\n-# }\n-```\n-\n-First, we call `lock()`, which acquires the mutex's lock. Because this may fail,\n-it returns an `Result<T, E>`, and because this is just an example, we `unwrap()`\n-it to get a reference to the data. Real code would have more robust error handling\n-here. We're then free to mutate it, since we have the lock.\n-\n-Lastly, while the threads are running, we wait on a short timer. But\n-this is not ideal: we may have picked a reasonable amount of time to\n-wait but it's more likely we'll either be waiting longer than\n-necessary or not long enough, depending on just how much time the\n-threads actually take to finish computing when the program runs.\n-\n-A more precise alternative to the timer would be to use one of the\n-mechanisms provided by the Rust standard library for synchronizing\n-threads with each other. Let's talk about one of them: channels.\n-\n-## Channels\n-\n-Here's a version of our code that uses channels for synchronization, rather\n-than waiting for a specific time:\n-\n-```\n-use std::sync::{Arc, Mutex};\n-use std::thread;\n-use std::sync::mpsc;\n-\n-fn main() {\n-    let data = Arc::new(Mutex::new(0u32));\n-\n-    let (tx, rx) = mpsc::channel();\n-\n-    for _ in 0..10 {\n-        let (data, tx) = (data.clone(), tx.clone());\n-\n-        thread::spawn(move || {\n-            let mut data = data.lock().unwrap();\n-            *data += 1;\n-\n-            tx.send(());\n-        });\n-    }\n-\n-    for _ in 0..10 {\n-        rx.recv();\n-    }\n-}\n-```\n-\n-We use the `mpsc::channel()` method to construct a new channel. We just `send`\n-a simple `()` down the channel, and then wait for ten of them to come back.\n-\n-While this channel is just sending a generic signal, we can send any data that\n-is `Send` over the channel!\n-\n-```\n-use std::thread;\n-use std::sync::mpsc;\n-\n-fn main() {\n-    let (tx, rx) = mpsc::channel();\n-\n-    for _ in 0..10 {\n-        let tx = tx.clone();\n-\n-        thread::spawn(move || {\n-            let answer = 42u32;\n-\n-            tx.send(answer);\n-        });\n-    }\n-\n-   rx.recv().ok().expect(\"Could not receive answer\");\n-}\n-```\n-\n-A `u32` is `Send` because we can make a copy. So we create a thread, ask it to calculate\n-the answer, and then it `send()`s us the answer over the channel.\n-\n-\n-## Panics\n-\n-A `panic!` will crash the currently executing thread. You can use Rust's\n-threads as a simple isolation mechanism:\n-\n-```\n-use std::thread;\n-\n-let result = thread::spawn(move || {\n-    panic!(\"oops!\");\n-}).join();\n-\n-assert!(result.is_err());\n-```\n-\n-Our `Thread` gives us a `Result` back, which allows us to check if the thread\n-has panicked or not."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/conditional-compilation.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fconditional-compilation.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fconditional-compilation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconditional-compilation.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/const.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fconst.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fconst.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconst.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 0, "deletions": 533, "changes": 533, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,533 +0,0 @@\n-% Crates and Modules\n-\n-When a project starts getting large, it's considered good software\n-engineering practice to split it up into a bunch of smaller pieces, and then\n-fit them together. It's also important to have a well-defined interface, so\n-that some of your functionality is private, and some is public. To facilitate\n-these kinds of things, Rust has a module system.\n-\n-# Basic terminology: Crates and Modules\n-\n-Rust has two distinct terms that relate to the module system: *crate* and\n-*module*. A crate is synonymous with a *library* or *package* in other\n-languages. Hence \"Cargo\" as the name of Rust's package management tool: you\n-ship your crates to others with Cargo. Crates can produce an executable or a\n-library, depending on the project.\n-\n-Each crate has an implicit *root module* that contains the code for that crate.\n-You can then define a tree of sub-modules under that root module. Modules allow\n-you to partition your code within the crate itself.\n-\n-As an example, let's make a *phrases* crate, which will give us various phrases\n-in different languages. To keep things simple, we'll stick to \"greetings\" and\n-\"farewells\" as two kinds of phrases, and use English and Japanese (\u65e5\u672c\u8a9e) as\n-two languages for those phrases to be in. We'll use this module layout:\n-\n-```text\n-                                    +-----------+\n-                                +---| greetings |\n-                                |   +-----------+\n-                  +---------+   |\n-              +---| english |---+\n-              |   +---------+   |   +-----------+\n-              |                 +---| farewells |\n-+---------+   |                     +-----------+\n-| phrases |---+\n-+---------+   |                     +-----------+\n-              |                 +---| greetings |\n-              |   +----------+  |   +-----------+\n-              +---| japanese |--+\n-                  +----------+  |\n-                                |   +-----------+\n-                                +---| farewells |\n-                                    +-----------+\n-```\n-\n-In this example, `phrases` is the name of our crate. All of the rest are\n-modules.  You can see that they form a tree, branching out from the crate\n-*root*, which is the root of the tree: `phrases` itself.\n-\n-Now that we have a plan, let's define these modules in code. To start,\n-generate a new crate with Cargo:\n-\n-```bash\n-$ cargo new phrases\n-$ cd phrases\n-```\n-\n-If you remember, this generates a simple project for us:\n-\n-```bash\n-$ tree .\n-.\n-\u251c\u2500\u2500 Cargo.toml\n-\u2514\u2500\u2500 src\n-    \u2514\u2500\u2500 lib.rs\n-\n-1 directory, 2 files\n-```\n-\n-`src/lib.rs` is our crate root, corresponding to the `phrases` in our diagram\n-above.\n-\n-# Defining Modules\n-\n-To define each of our modules, we use the `mod` keyword. Let's make our\n-`src/lib.rs` look like this:\n-\n-```\n-mod english {\n-    mod greetings {\n-    }\n-\n-    mod farewells {\n-    }\n-}\n-\n-mod japanese {\n-    mod greetings {\n-    }\n-\n-    mod farewells {\n-    }\n-}\n-```\n-\n-After the `mod` keyword, you give the name of the module. Module names follow\n-the conventions for other Rust identifiers: `lower_snake_case`. The contents of\n-each module are within curly braces (`{}`).\n-\n-Within a given `mod`, you can declare sub-`mod`s. We can refer to sub-modules\n-with double-colon (`::`) notation: our four nested modules are\n-`english::greetings`, `english::farewells`, `japanese::greetings`, and\n-`japanese::farewells`. Because these sub-modules are namespaced under their\n-parent module, the names don't conflict: `english::greetings` and\n-`japanese::greetings` are distinct, even though their names are both\n-`greetings`.\n-\n-Because this crate does not have a `main()` function, and is called `lib.rs`,\n-Cargo will build this crate as a library:\n-\n-```bash\n-$ cargo build\n-   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n-$ ls target/debug\n-build  deps  examples  libphrases-a7448e02a0468eaa.rlib  native\n-```\n-\n-`libphrase-hash.rlib` is the compiled crate. Before we see how to use this\n-crate from another crate, let's break it up into multiple files.\n-\n-# Multiple file crates\n-\n-If each crate were just one file, these files would get very large. It's often\n-easier to split up crates into multiple files, and Rust supports this in two\n-ways.\n-\n-Instead of declaring a module like this:\n-\n-```{rust,ignore}\n-mod english {\n-    // contents of our module go here\n-}\n-```\n-\n-We can instead declare our module like this:\n-\n-```{rust,ignore}\n-mod english;\n-```\n-\n-If we do that, Rust will expect to find either a `english.rs` file, or a\n-`english/mod.rs` file with the contents of our module.\n-\n-Note that in these files, you don't need to re-declare the module: that's\n-already been done with the initial `mod` declaration.\n-\n-Using these two techniques, we can break up our crate into two directories and\n-seven files:\n-\n-```bash\n-$ tree .\n-.\n-\u251c\u2500\u2500 Cargo.lock\n-\u251c\u2500\u2500 Cargo.toml\n-\u251c\u2500\u2500 src\n-\u2502\u00a0\u00a0 \u251c\u2500\u2500 english\n-\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 farewells.rs\n-\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 greetings.rs\n-\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 mod.rs\n-\u2502\u00a0\u00a0 \u251c\u2500\u2500 japanese\n-\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 farewells.rs\n-\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 greetings.rs\n-\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 mod.rs\n-\u2502\u00a0\u00a0 \u2514\u2500\u2500 lib.rs\n-\u2514\u2500\u2500 target\n-    \u2514\u2500\u2500 debug\n-        \u251c\u2500\u2500 build\n-        \u251c\u2500\u2500 deps\n-        \u251c\u2500\u2500 examples\n-        \u251c\u2500\u2500 libphrases-a7448e02a0468eaa.rlib\n-        \u2514\u2500\u2500 native\n-```\n-\n-`src/lib.rs` is our crate root, and looks like this:\n-\n-```{rust,ignore}\n-mod english;\n-mod japanese;\n-```\n-\n-These two declarations tell Rust to look for either `src/english.rs` and\n-`src/japanese.rs`, or `src/english/mod.rs` and `src/japanese/mod.rs`, depending\n-on our preference. In this case, because our modules have sub-modules, we've\n-chosen the second. Both `src/english/mod.rs` and `src/japanese/mod.rs` look\n-like this:\n-\n-```{rust,ignore}\n-mod greetings;\n-mod farewells;\n-```\n-\n-Again, these declarations tell Rust to look for either\n-`src/english/greetings.rs` and `src/japanese/greetings.rs` or\n-`src/english/farewells/mod.rs` and `src/japanese/farewells/mod.rs`. Because\n-these sub-modules don't have their own sub-modules, we've chosen to make them\n-`src/english/greetings.rs` and `src/japanese/farewells.rs`. Whew!\n-\n-The contents of `src/english/greetings.rs` and `src/japanese/farewells.rs` are\n-both empty at the moment. Let's add some functions.\n-\n-Put this in `src/english/greetings.rs`:\n-\n-```rust\n-fn hello() -> String {\n-    \"Hello!\".to_string()\n-}\n-```\n-\n-Put this in `src/english/farewells.rs`:\n-\n-```rust\n-fn goodbye() -> String {\n-    \"Goodbye.\".to_string()\n-}\n-```\n-\n-Put this in `src/japanese/greetings.rs`:\n-\n-```rust\n-fn hello() -> String {\n-    \"\u3053\u3093\u306b\u3061\u306f\".to_string()\n-}\n-```\n-\n-Of course, you can copy and paste this from this web page, or just type\n-something else. It's not important that you actually put \"konnichiwa\" to learn\n-about the module system.\n-\n-Put this in `src/japanese/farewells.rs`:\n-\n-```rust\n-fn goodbye() -> String {\n-    \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n-}\n-```\n-\n-(This is \"Say\u014dnara\", if you're curious.)\n-\n-Now that we have some functionality in our crate, let's try to use it from\n-another crate.\n-\n-# Importing External Crates\n-\n-We have a library crate. Let's make an executable crate that imports and uses\n-our library.\n-\n-Make a `src/main.rs` and put this in it (it won't quite compile yet):\n-\n-```rust,ignore\n-extern crate phrases;\n-\n-fn main() {\n-    println!(\"Hello in English: {}\", phrases::english::greetings::hello());\n-    println!(\"Goodbye in English: {}\", phrases::english::farewells::goodbye());\n-\n-    println!(\"Hello in Japanese: {}\", phrases::japanese::greetings::hello());\n-    println!(\"Goodbye in Japanese: {}\", phrases::japanese::farewells::goodbye());\n-}\n-```\n-\n-The `extern crate` declaration tells Rust that we need to compile and link to\n-the `phrases` crate. We can then use `phrases`' modules in this one. As we\n-mentioned earlier, you can use double colons to refer to sub-modules and the\n-functions inside of them.\n-\n-Also, Cargo assumes that `src/main.rs` is the crate root of a binary crate,\n-rather than a library crate. Our package now has two crates: `src/lib.rs` and\n-`src/main.rs`. This pattern is quite common for executable crates: most\n-functionality is in a library crate, and the executable crate uses that\n-library. This way, other programs can also use the library crate, and it's also\n-a nice separation of concerns.\n-\n-This doesn't quite work yet, though. We get four errors that look similar to\n-this:\n-\n-```bash\n-$ cargo build\n-   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n-src/main.rs:4:38: 4:72 error: function `hello` is private\n-src/main.rs:4     println!(\"Hello in English: {}\", phrases::english::greetings::hello());\n-                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-note: in expansion of format_args!\n-<std macros>:2:25: 2:58 note: expansion site\n-<std macros>:1:1: 2:62 note: in expansion of print!\n-<std macros>:3:1: 3:54 note: expansion site\n-<std macros>:1:1: 3:58 note: in expansion of println!\n-phrases/src/main.rs:4:5: 4:76 note: expansion site\n-```\n-\n-By default, everything is private in Rust. Let's talk about this in some more\n-depth.\n-\n-# Exporting a Public Interface\n-\n-Rust allows you to precisely control which aspects of your interface are\n-public, and so private is the default. To make things public, you use the `pub`\n-keyword. Let's focus on the `english` module first, so let's reduce our `src/main.rs`\n-to just this:\n-\n-```{rust,ignore}\n-extern crate phrases;\n-\n-fn main() {\n-    println!(\"Hello in English: {}\", phrases::english::greetings::hello());\n-    println!(\"Goodbye in English: {}\", phrases::english::farewells::goodbye());\n-}\n-```\n-\n-In our `src/lib.rs`, let's add `pub` to the `english` module declaration:\n-\n-```{rust,ignore}\n-pub mod english;\n-mod japanese;\n-```\n-\n-And in our `src/english/mod.rs`, let's make both `pub`:\n-\n-```{rust,ignore}\n-pub mod greetings;\n-pub mod farewells;\n-```\n-\n-In our `src/english/greetings.rs`, let's add `pub` to our `fn` declaration:\n-\n-```{rust,ignore}\n-pub fn hello() -> String {\n-    \"Hello!\".to_string()\n-}\n-```\n-\n-And also in `src/english/farewells.rs`:\n-\n-```{rust,ignore}\n-pub fn goodbye() -> String {\n-    \"Goodbye.\".to_string()\n-}\n-```\n-\n-Now, our crate compiles, albeit with warnings about not using the `japanese`\n-functions:\n-\n-```bash\n-$ cargo run\n-   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n-src/japanese/greetings.rs:1:1: 3:2 warning: function is never used: `hello`, #[warn(dead_code)] on by default\n-src/japanese/greetings.rs:1 fn hello() -> String {\n-src/japanese/greetings.rs:2     \"\u3053\u3093\u306b\u3061\u306f\".to_string()\n-src/japanese/greetings.rs:3 }\n-src/japanese/farewells.rs:1:1: 3:2 warning: function is never used: `goodbye`, #[warn(dead_code)] on by default\n-src/japanese/farewells.rs:1 fn goodbye() -> String {\n-src/japanese/farewells.rs:2     \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n-src/japanese/farewells.rs:3 }\n-     Running `target/debug/phrases`\n-Hello in English: Hello!\n-Goodbye in English: Goodbye.\n-```\n-\n-Now that our functions are public, we can use them. Great! However, typing out\n-`phrases::english::greetings::hello()` is very long and repetitive. Rust has\n-another keyword for importing names into the current scope, so that you can\n-refer to them with shorter names. Let's talk about `use`.\n-\n-# Importing Modules with `use`\n-\n-Rust has a `use` keyword, which allows us to import names into our local scope.\n-Let's change our `src/main.rs` to look like this:\n-\n-```{rust,ignore}\n-extern crate phrases;\n-\n-use phrases::english::greetings;\n-use phrases::english::farewells;\n-\n-fn main() {\n-    println!(\"Hello in English: {}\", greetings::hello());\n-    println!(\"Goodbye in English: {}\", farewells::goodbye());\n-}\n-```\n-\n-The two `use` lines import each module into the local scope, so we can refer to\n-the functions by a much shorter name. By convention, when importing functions, it's\n-considered best practice to import the module, rather than the function directly. In\n-other words, you _can_ do this:\n-\n-```{rust,ignore}\n-extern crate phrases;\n-\n-use phrases::english::greetings::hello;\n-use phrases::english::farewells::goodbye;\n-\n-fn main() {\n-    println!(\"Hello in English: {}\", hello());\n-    println!(\"Goodbye in English: {}\", goodbye());\n-}\n-```\n-\n-But it is not idiomatic. This is significantly more likely to introduce a\n-naming conflict. In our short program, it's not a big deal, but as it grows, it\n-becomes a problem. If we have conflicting names, Rust will give a compilation\n-error. For example, if we made the `japanese` functions public, and tried to do\n-this:\n-\n-```{rust,ignore}\n-extern crate phrases;\n-\n-use phrases::english::greetings::hello;\n-use phrases::japanese::greetings::hello;\n-\n-fn main() {\n-    println!(\"Hello in English: {}\", hello());\n-    println!(\"Hello in Japanese: {}\", hello());\n-}\n-```\n-\n-Rust will give us a compile-time error:\n-\n-```text\n-   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n-src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this module [E0252]\n-src/main.rs:4 use phrases::japanese::greetings::hello;\n-                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-error: aborting due to previous error\n-Could not compile `phrases`.\n-```\n-\n-If we're importing multiple names from the same module, we don't have to type it out\n-twice. Instead of this:\n-\n-```{rust,ignore}\n-use phrases::english::greetings;\n-use phrases::english::farewells;\n-```\n-\n-We can use this shortcut:\n-\n-```{rust,ignore}\n-use phrases::english::{greetings, farewells};\n-```\n-\n-## Re-exporting with `pub use`\n-\n-You don't just use `use` to shorten identifiers. You can also use it inside of your crate\n-to re-export a function inside another module. This allows you to present an external\n-interface that may not directly map to your internal code organization.\n-\n-Let's look at an example. Modify your `src/main.rs` to read like this:\n-\n-```{rust,ignore}\n-extern crate phrases;\n-\n-use phrases::english::{greetings,farewells};\n-use phrases::japanese;\n-\n-fn main() {\n-    println!(\"Hello in English: {}\", greetings::hello());\n-    println!(\"Goodbye in English: {}\", farewells::goodbye());\n-\n-    println!(\"Hello in Japanese: {}\", japanese::hello());\n-    println!(\"Goodbye in Japanese: {}\", japanese::goodbye());\n-}\n-```\n-\n-Then, modify your `src/lib.rs` to make the `japanese` mod public:\n-\n-```{rust,ignore}\n-pub mod english;\n-pub mod japanese;\n-```\n-\n-Next, make the two functions public, first in `src/japanese/greetings.rs`:\n-\n-```{rust,ignore}\n-pub fn hello() -> String {\n-    \"\u3053\u3093\u306b\u3061\u306f\".to_string()\n-}\n-```\n-\n-And then in `src/japanese/farewells.rs`:\n-\n-```{rust,ignore}\n-pub fn goodbye() -> String {\n-    \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n-}\n-```\n-\n-Finally, modify your `src/japanese/mod.rs` to read like this:\n-\n-```{rust,ignore}\n-pub use self::greetings::hello;\n-pub use self::farewells::goodbye;\n-\n-mod greetings;\n-mod farewells;\n-```\n-\n-The `pub use` declaration brings the function into scope at this part of our\n-module hierarchy. Because we've `pub use`d this inside of our `japanese`\n-module, we now have a `phrases::japanese::hello()` function and a\n-`phrases::japanese::goodbye()` function, even though the code for them lives in\n-`phrases::japanese::greetings::hello()` and\n-`phrases::japanese::farewells::goodbye()`. Our internal organization doesn't\n-define our external interface.\n-\n-Here we have a `pub use` for each function we want to bring into the\n-`japanese` scope. We could alternatively use the wildcard syntax to include\n-everything from `greetings` into the current scope: `pub use self::greetings::*`.\n-\n-What about the `self`? Well, by default, `use` declarations are absolute paths,\n-starting from your crate root. `self` makes that path relative to your current\n-place in the hierarchy instead. There's one more special form of `use`: you can\n-`use super::` to reach one level up the tree from your current location. Some\n-people like to think of `self` as `.` and `super` as `..`, from many shells'\n-display for the current directory and the parent directory.\n-\n-Outside of `use`, paths are relative: `foo::bar()` refers to a function inside\n-of `foo` relative to where we are. If that's prefixed with `::`, as in\n-`::foo::bar()`, it refers to a different `foo`, an absolute path from your\n-crate root.\n-\n-Also, note that we `pub use`d before we declared our `mod`s. Rust requires that\n-`use` declarations go first.\n-\n-This will build and run:\n-\n-```bash\n-$ cargo run\n-   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n-     Running `target/debug/phrases`\n-Hello in English: Hello!\n-Goodbye in English: Goodbye.\n-Hello in Japanese: \u3053\u3093\u306b\u3061\u306f\n-Goodbye in Japanese: \u3055\u3088\u3046\u306a\u3089\n-```"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/debug-and-display.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/deref-coercions.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fderef-coercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fderef-coercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fderef-coercions.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/documentation.md", "status": "modified", "additions": 0, "deletions": 562, "changes": 562, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,562 +0,0 @@\n-% Documentation\n-\n-Documentation is an important part of any software project, and it's\n-first-class in Rust. Let's talk about the tooling Rust gives you to\n-document your project.\n-\n-## About `rustdoc`\n-\n-The Rust distribution includes a tool, `rustdoc`, that generates documentation.\n-`rustdoc` is also used by Cargo through `cargo doc`.\n-\n-Documentation can be generated in two ways: from source code, and from\n-standalone Markdown files.\n-\n-## Documenting source code\n-\n-The primary way of documenting a Rust project is through annotating the source\n-code. You can use documentation comments for this purpose:\n-\n-```rust,ignore\n-/// Constructs a new `Rc<T>`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::rc::Rc;\n-///\n-/// let five = Rc::new(5);\n-/// ```\n-pub fn new(value: T) -> Rc<T> {\n-    // implementation goes here\n-}\n-```\n-\n-This code generates documentation that looks [like this][rc-new]. I've left the\n-implementation out, with a regular comment in its place. That's the first thing\n-to notice about this annotation: it uses `///`, instead of `//`. The triple slash\n-indicates a documentation comment.\n-\n-Documentation comments are written in Markdown.\n-\n-Rust keeps track of these comments, and uses them when generating\n-documentation. This is important when documenting things like enums:\n-\n-```\n-/// The `Option` type. See [the module level documentation](../) for more.\n-enum Option<T> {\n-    /// No value\n-    None,\n-    /// Some value `T`\n-    Some(T),\n-}\n-```\n-\n-The above works, but this does not:\n-\n-```rust,ignore\n-/// The `Option` type. See [the module level documentation](../) for more.\n-enum Option<T> {\n-    None, /// No value\n-    Some(T), /// Some value `T`\n-}\n-```\n-\n-You'll get an error:\n-\n-```text\n-hello.rs:4:1: 4:2 error: expected ident, found `}`\n-hello.rs:4 }\n-           ^\n-```\n-\n-This [unfortunate error](https://github.com/rust-lang/rust/issues/22547) is\n-correct: documentation comments apply to the thing after them, and there's no\n-thing after that last comment.\n-\n-[rc-new]: http://doc.rust-lang.org/nightly/std/rc/struct.Rc.html#method.new\n-\n-### Writing documentation comments\n-\n-Anyway, let's cover each part of this comment in detail:\n-\n-```\n-/// Constructs a new `Rc<T>`.\n-# fn foo() {}\n-```\n-\n-The first line of a documentation comment should be a short summary of its\n-functionality. One sentence. Just the basics. High level.\n-\n-```\n-///\n-/// Other details about constructing `Rc<T>`s, maybe describing complicated\n-/// semantics, maybe additional options, all kinds of stuff.\n-///\n-# fn foo() {}\n-```\n-\n-Our original example had just a summary line, but if we had more things to say,\n-we could have added more explanation in a new paragraph.\n-\n-#### Special sections\n-\n-```\n-/// # Examples\n-# fn foo() {}\n-```\n-\n-Next, are special sections. These are indicated with a header, `#`. There\n-are three kinds of headers that are commonly used. They aren't special syntax,\n-just convention, for now.\n-\n-```\n-/// # Panics\n-# fn foo() {}\n-```\n-\n-Unrecoverable misuses of a function (i.e. programming errors) in Rust are\n-usually indicated by panics, which kill the whole current thread at the very\n-least. If your function has a non-trivial contract like this, that is\n-detected/enforced by panics, documenting it is very important.\n-\n-```\n-/// # Failures\n-# fn foo() {}\n-```\n-\n-If your function or method returns a `Result<T, E>`, then describing the\n-conditions under which it returns `Err(E)` is a nice thing to do. This is\n-slightly less important than `Panics`, because failure is encoded into the type\n-system, but it's still a good thing to do.\n-\n-```\n-/// # Safety\n-# fn foo() {}\n-```\n-\n-If your function is `unsafe`, you should explain which invariants the caller is\n-responsible for upholding.\n-\n-```\n-/// # Examples\n-///\n-/// ```\n-/// use std::rc::Rc;\n-///\n-/// let five = Rc::new(5);\n-/// ```\n-# fn foo() {}\n-```\n-\n-Third, `Examples`. Include one or more examples of using your function or\n-method, and your users will love you for it. These examples go inside of\n-code block annotations, which we'll talk about in a moment, and can have\n-more than one section:\n-\n-```\n-/// # Examples\n-///\n-/// Simple `&str` patterns:\n-///\n-/// ```\n-/// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n-/// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-/// ```\n-///\n-/// More complex patterns with a lambda:\n-///\n-/// ```\n-/// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n-/// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n-/// ```\n-# fn foo() {}\n-```\n-\n-Let's discuss the details of these code blocks.\n-\n-#### Code block annotations\n-\n-To write some Rust code in a comment, use the triple graves:\n-\n-```\n-/// ```\n-/// println!(\"Hello, world\");\n-/// ```\n-# fn foo() {}\n-```\n-\n-If you want something that's not Rust code, you can add an annotation:\n-\n-```\n-/// ```c\n-/// printf(\"Hello, world\\n\");\n-/// ```\n-# fn foo() {}\n-```\n-\n-This will highlight according to whatever language you're showing off.\n-If you're just showing plain text, choose `text`.\n-\n-It's important to choose the correct annotation here, because `rustdoc` uses it\n-in an interesting way: It can be used to actually test your examples, so that\n-they don't get out of date. If you have some C code but `rustdoc` thinks it's\n-Rust because you left off the annotation, `rustdoc` will complain when trying to\n-generate the documentation.\n-\n-## Documentation as tests\n-\n-Let's discuss our sample example documentation:\n-\n-```\n-/// ```\n-/// println!(\"Hello, world\");\n-/// ```\n-# fn foo() {}\n-```\n-\n-You'll notice that you don't need a `fn main()` or anything here. `rustdoc` will\n-automatically add a main() wrapper around your code, and in the right place.\n-For example:\n-\n-```\n-/// ```\n-/// use std::rc::Rc;\n-///\n-/// let five = Rc::new(5);\n-/// ```\n-# fn foo() {}\n-```\n-\n-This will end up testing:\n-\n-```\n-fn main() {\n-    use std::rc::Rc;\n-    let five = Rc::new(5);\n-}\n-```\n-\n-Here's the full algorithm rustdoc uses to postprocess examples:\n-\n-1. Any leading `#![foo]` attributes are left intact as crate attributes.\n-2. Some common `allow` attributes are inserted, including\n-   `unused_variables`, `unused_assignments`, `unused_mut`,\n-   `unused_attributes`, and `dead_code`. Small examples often trigger\n-   these lints.\n-3. If the example does not contain `extern crate`, then `extern crate\n-   <mycrate>;` is inserted.\n-2. Finally, if the example does not contain `fn main`, the remainder of the\n-   text is wrapped in `fn main() { your_code }`\n-\n-Sometimes, this isn't enough, though. For example, all of these code samples\n-with `///` we've been talking about? The raw text:\n-\n-```text\n-/// Some documentation.\n-# fn foo() {}\n-```\n-\n-looks different than the output:\n-\n-```\n-/// Some documentation.\n-# fn foo() {}\n-```\n-\n-Yes, that's right: you can add lines that start with `# `, and they will\n-be hidden from the output, but will be used when compiling your code. You\n-can use this to your advantage. In this case, documentation comments need\n-to apply to some kind of function, so if I want to show you just a\n-documentation comment, I need to add a little function definition below\n-it. At the same time, it's just there to satisfy the compiler, so hiding\n-it makes the example more clear. You can use this technique to explain\n-longer examples in detail, while still preserving the testability of your\n-documentation. For example, this code:\n-\n-```\n-let x = 5;\n-let y = 6;\n-println!(\"{}\", x + y);\n-```\n-\n-Here's an explanation, rendered:\n-\n-First, we set `x` to five:\n-\n-```\n-let x = 5;\n-# let y = 6;\n-# println!(\"{}\", x + y);\n-```\n-\n-Next, we set `y` to six:\n-\n-```\n-# let x = 5;\n-let y = 6;\n-# println!(\"{}\", x + y);\n-```\n-\n-Finally, we print the sum of `x` and `y`:\n-\n-```\n-# let x = 5;\n-# let y = 6;\n-println!(\"{}\", x + y);\n-```\n-\n-Here's the same explanation, in raw text:\n-\n-> First, we set `x` to five:\n->\n-> ```text\n-> let x = 5;\n-> # let y = 6;\n-> # println!(\"{}\", x + y);\n-> ```\n->\n-> Next, we set `y` to six:\n->\n-> ```text\n-> # let x = 5;\n-> let y = 6;\n-> # println!(\"{}\", x + y);\n-> ```\n->\n-> Finally, we print the sum of `x` and `y`:\n->\n-> ```text\n-> # let x = 5;\n-> # let y = 6;\n-> println!(\"{}\", x + y);\n-> ```\n-\n-By repeating all parts of the example, you can ensure that your example still\n-compiles, while only showing the parts that are relevant to that part of your\n-explanation.\n-\n-### Documenting macros\n-\n-Here\u2019s an example of documenting a macro:\n-\n-```\n-/// Panic with a given message unless an expression evaluates to true.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #[macro_use] extern crate foo;\n-/// # fn main() {\n-/// panic_unless!(1 + 1 == 2, \u201cMath is broken.\u201d);\n-/// # }\n-/// ```\n-///\n-/// ```should_panic\n-/// # #[macro_use] extern crate foo;\n-/// # fn main() {\n-/// panic_unless!(true == false, \u201cI\u2019m broken.\u201d);\n-/// # }\n-/// ```\n-#[macro_export]\n-macro_rules! panic_unless {\n-    ($condition:expr, $($rest:expr),+) => ({ if ! $condition { panic!($($rest),+); } });\n-}\n-# fn main() {}\n-```\n-\n-You\u2019ll note three things: we need to add our own `extern crate` line, so that\n-we can add the `#[macro_use]` attribute. Second, we\u2019ll need to add our own\n-`main()` as well. Finally, a judicious use of `#` to comment out those two\n-things, so they don\u2019t show up in the output.\n-\n-### Running documentation tests\n-\n-To run the tests, either\n-\n-```bash\n-$ rustdoc --test path/to/my/crate/root.rs\n-# or\n-$ cargo test\n-```\n-\n-That's right, `cargo test` tests embedded documentation too.\n-\n-There are a few more annotations that are useful to help `rustdoc` do the right\n-thing when testing your code:\n-\n-```\n-/// ```ignore\n-/// fn foo() {\n-/// ```\n-# fn foo() {}\n-```\n-\n-The `ignore` directive tells Rust to ignore your code. This is almost never\n-what you want, as it's the most generic. Instead, consider annotating it\n-with `text` if it's not code, or using `#`s to get a working example that\n-only shows the part you care about.\n-\n-```\n-/// ```should_panic\n-/// assert!(false);\n-/// ```\n-# fn foo() {}\n-```\n-\n-`should_panic` tells `rustdoc` that the code should compile correctly, but\n-not actually pass as a test.\n-\n-```\n-/// ```no_run\n-/// loop {\n-///     println!(\"Hello, world\");\n-/// }\n-/// ```\n-# fn foo() {}\n-```\n-\n-The `no_run` attribute will compile your code, but not run it. This is\n-important for examples such as \"Here's how to start up a network service,\"\n-which you would want to make sure compile, but might run in an infinite loop!\n-\n-### Documenting modules\n-\n-Rust has another kind of doc comment, `//!`. This comment doesn't document the next item, but the enclosing item. In other words:\n-\n-```\n-mod foo {\n-    //! This is documentation for the `foo` module.\n-    //!\n-    //! # Examples\n-\n-    // ...\n-}\n-```\n-\n-This is where you'll see `//!` used most often: for module documentation. If\n-you have a module in `foo.rs`, you'll often open its code and see this:\n-\n-```\n-//! A module for using `foo`s.\n-//!\n-//! The `foo` module contains a lot of useful functionality blah blah blah\n-```\n-\n-### Documentation comment style\n-\n-Check out [RFC 505][rfc505] for full conventions around the style and format of\n-documentation.\n-\n-[rfc505]: https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md\n-\n-## Other documentation\n-\n-All of this behavior works in non-Rust source files too. Because comments\n-are written in Markdown, they're often `.md` files.\n-\n-When you write documentation in Markdown files, you don't need to prefix\n-the documentation with comments. For example:\n-\n-```\n-/// # Examples\n-///\n-/// ```\n-/// use std::rc::Rc;\n-///\n-/// let five = Rc::new(5);\n-/// ```\n-# fn foo() {}\n-```\n-\n-is just\n-\n-~~~markdown\n-# Examples\n-\n-```\n-use std::rc::Rc;\n-\n-let five = Rc::new(5);\n-```\n-~~~\n-\n-when it's in a Markdown file. There is one wrinkle though: Markdown files need\n-to have a title like this:\n-\n-```markdown\n-% The title\n-\n-This is the example documentation.\n-```\n-\n-This `%` line needs to be the very first line of the file.\n-\n-## `doc` attributes\n-\n-At a deeper level, documentation comments are sugar for documentation attributes:\n-\n-```\n-/// this\n-# fn foo() {}\n-\n-#[doc=\"this\"]\n-# fn bar() {}\n-```\n-\n-are the same, as are these:\n-\n-```\n-//! this\n-\n-#![doc=\"/// this\"]\n-```\n-\n-You won't often see this attribute used for writing documentation, but it\n-can be useful when changing some options, or when writing a macro.\n-\n-### Re-exports\n-\n-`rustdoc` will show the documentation for a public re-export in both places:\n-\n-```ignore\n-extern crate foo;\n-\n-pub use foo::bar;\n-```\n-\n-This will create documentation for bar both inside the documentation for the\n-crate `foo`, as well as the documentation for your crate. It will use the same\n-documentation in both places.\n-\n-This behavior can be suppressed with `no_inline`:\n-\n-```ignore\n-extern crate foo;\n-\n-#[doc(no_inline)]\n-pub use foo::bar;\n-```\n-\n-### Controlling HTML\n-\n-You can control a few aspects of the HTML that `rustdoc` generates through the\n-`#![doc]` version of the attribute:\n-\n-```\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/\")];\n-```\n-\n-This sets a few different options, with a logo, favicon, and a root URL.\n-\n-## Generation options\n-\n-`rustdoc` also contains a few other options on the command line, for further customiziation:\n-\n-- `--html-in-header FILE`: includes the contents of FILE at the end of the\n-  `<head>...</head>` section.\n-- `--html-before-content FILE`: includes the contents of FILE directly after\n-  `<body>`, before the rendered content (including the search bar).\n-- `--html-after-content FILE`: includes the contents of FILE after all the rendered content."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/drop.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fdrop.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fdrop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdrop.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/effective-rust.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Feffective-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Feffective-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Feffective-rust.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/enums.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fenums.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fenums.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fenums.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 0, "deletions": 301, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,301 +0,0 @@\n-% Error Handling\n-\n-> The best-laid plans of mice and men  \n-> Often go awry\n->\n-> \"Tae a Moose\", Robert Burns\n-\n-Sometimes, things just go wrong. It's important to have a plan for when the\n-inevitable happens. Rust has rich support for handling errors that may (let's\n-be honest: will) occur in your programs.\n-\n-There are two main kinds of errors that can occur in your programs: failures,\n-and panics. Let's talk about the difference between the two, and then discuss\n-how to handle each. Then, we'll discuss upgrading failures to panics.\n-\n-# Failure vs. Panic\n-\n-Rust uses two terms to differentiate between two forms of error: failure, and\n-panic. A *failure* is an error that can be recovered from in some way. A\n-*panic* is an error that cannot be recovered from.\n-\n-What do we mean by \"recover\"? Well, in most cases, the possibility of an error\n-is expected. For example, consider the `from_str` function:\n-\n-```{rust,ignore}\n-from_str(\"5\");\n-```\n-\n-This function takes a string argument and converts it into another type. But\n-because it's a string, you can't be sure that the conversion actually works.\n-For example, what should this convert to?\n-\n-```{rust,ignore}\n-from_str(\"hello5world\");\n-```\n-\n-This won't work. So we know that this function will only work properly for some\n-inputs. It's expected behavior. We call this kind of error a *failure*.\n-\n-On the other hand, sometimes, there are errors that are unexpected, or which\n-we cannot recover from. A classic example is an `assert!`:\n-\n-```{rust,ignore}\n-assert!(x == 5);\n-```\n-\n-We use `assert!` to declare that something is true. If it's not true, something\n-is very wrong. Wrong enough that we can't continue with things in the current\n-state. Another example is using the `unreachable!()` macro:\n-\n-```{rust,ignore}\n-enum Event {\n-    NewRelease,\n-}\n-\n-fn probability(_: &Event) -> f64 {\n-    // real implementation would be more complex, of course\n-    0.95\n-}\n-\n-fn descriptive_probability(event: Event) -> &'static str {\n-    match probability(&event) {\n-        1.00 => \"certain\",\n-        0.00 => \"impossible\",\n-        0.00 ... 0.25 => \"very unlikely\",\n-        0.25 ... 0.50 => \"unlikely\",\n-        0.50 ... 0.75 => \"likely\",\n-        0.75 ... 1.00 => \"very likely\",\n-    }\n-}\n-\n-fn main() {\n-    std::io::println(descriptive_probability(NewRelease));\n-}\n-```\n-\n-This will give us an error:\n-\n-```text\n-error: non-exhaustive patterns: `_` not covered [E0004]\n-```\n-\n-While we know that we've covered all possible cases, Rust can't tell. It\n-doesn't know that probability is between 0.0 and 1.0. So we add another case:\n-\n-```rust\n-use Event::NewRelease;\n-\n-enum Event {\n-    NewRelease,\n-}\n-\n-fn probability(_: &Event) -> f64 {\n-    // real implementation would be more complex, of course\n-    0.95\n-}\n-\n-fn descriptive_probability(event: Event) -> &'static str {\n-    match probability(&event) {\n-        1.00 => \"certain\",\n-        0.00 => \"impossible\",\n-        0.00 ... 0.25 => \"very unlikely\",\n-        0.25 ... 0.50 => \"unlikely\",\n-        0.50 ... 0.75 => \"likely\",\n-        0.75 ... 1.00 => \"very likely\",\n-        _ => unreachable!()\n-    }\n-}\n-\n-fn main() {\n-    println!(\"{}\", descriptive_probability(NewRelease));\n-}\n-```\n-\n-We shouldn't ever hit the `_` case, so we use the `unreachable!()` macro to\n-indicate this. `unreachable!()` gives a different kind of error than `Result`.\n-Rust calls these sorts of errors *panics*.\n-\n-# Handling errors with `Option` and `Result`\n-\n-The simplest way to indicate that a function may fail is to use the `Option<T>`\n-type. Remember our `from_str()` example? Here's its type signature:\n-\n-```{rust,ignore}\n-pub fn from_str<A: FromStr>(s: &str) -> Option<A>\n-```\n-\n-`from_str()` returns an `Option<A>`. If the conversion succeeds, it will return\n-`Some(value)`, and if it fails, it will return `None`.\n-\n-This is appropriate for the simplest of cases, but doesn't give us a lot of\n-information in the failure case. What if we wanted to know _why_ the conversion\n-failed? For this, we can use the `Result<T, E>` type. It looks like this:\n-\n-```rust\n-enum Result<T, E> {\n-   Ok(T),\n-   Err(E)\n-}\n-```\n-\n-This enum is provided by Rust itself, so you don't need to define it to use it\n-in your code. The `Ok(T)` variant represents a success, and the `Err(E)` variant\n-represents a failure. Returning a `Result` instead of an `Option` is recommended\n-for all but the most trivial of situations.\n-\n-Here's an example of using `Result`:\n-\n-```rust\n-#[derive(Debug)]\n-enum Version { Version1, Version2 }\n-\n-#[derive(Debug)]\n-enum ParseError { InvalidHeaderLength, InvalidVersion }\n-\n-fn parse_version(header: &[u8]) -> Result<Version, ParseError> {\n-    if header.len() < 1 {\n-        return Err(ParseError::InvalidHeaderLength);\n-    }\n-    match header[0] {\n-        1 => Ok(Version::Version1),\n-        2 => Ok(Version::Version2),\n-        _ => Err(ParseError::InvalidVersion)\n-    }\n-}\n-\n-let version = parse_version(&[1, 2, 3, 4]);\n-match version {\n-    Ok(v) => {\n-        println!(\"working with version: {:?}\", v);\n-    }\n-    Err(e) => {\n-        println!(\"error parsing header: {:?}\", e);\n-    }\n-}\n-```\n-\n-This function makes use of an enum, `ParseError`, to enumerate the various\n-errors that can occur.\n-\n-# Non-recoverable errors with `panic!`\n-\n-In the case of an error that is unexpected and not recoverable, the `panic!`\n-macro will induce a panic. This will crash the current thread, and give an error:\n-\n-```{rust,ignore}\n-panic!(\"boom\");\n-```\n-\n-gives\n-\n-```text\n-thread '<main>' panicked at 'boom', hello.rs:2\n-```\n-\n-when you run it.\n-\n-Because these kinds of situations are relatively rare, use panics sparingly.\n-\n-# Upgrading failures to panics\n-\n-In certain circumstances, even though a function may fail, we may want to treat\n-it as a panic instead. For example, `io::stdin().read_line(&mut buffer)` returns\n-an `Result<usize>`, when there is an error reading the line. This allows us to\n-handle and possibly recover from error.\n-\n-If we don't want to handle this error, and would rather just abort the program,\n-we can use the `unwrap()` method:\n-\n-```{rust,ignore}\n-io::stdin().read_line(&mut buffer).unwrap();\n-```\n-\n-`unwrap()` will `panic!` if the `Option` is `None`. This basically says \"Give\n-me the value, and if something goes wrong, just crash.\" This is less reliable\n-than matching the error and attempting to recover, but is also significantly\n-shorter. Sometimes, just crashing is appropriate.\n-\n-There's another way of doing this that's a bit nicer than `unwrap()`:\n-\n-```{rust,ignore}\n-let mut buffer = String::new();\n-let input = io::stdin().read_line(&mut buffer)\n-                       .ok()\n-                       .expect(\"Failed to read line\");\n-```\n-\n-`ok()` converts the `Result` into an `Option`, and `expect()` does the same\n-thing as `unwrap()`, but takes a message. This message is passed along to the\n-underlying `panic!`, providing a better error message if the code errors.\n-\n-# Using `try!`\n-\n-When writing code that calls many functions that return the `Result` type, the\n-error handling can be tedious. The `try!` macro hides some of the boilerplate\n-of propagating errors up the call stack.\n-\n-It replaces this:\n-\n-```rust\n-use std::fs::File;\n-use std::io;\n-use std::io::prelude::*;\n-\n-struct Info {\n-    name: String,\n-    age: i32,\n-    rating: i32,\n-}\n-\n-fn write_info(info: &Info) -> io::Result<()> {\n-    let mut file = File::open(\"my_best_friends.txt\").unwrap();\n-\n-    if let Err(e) = writeln!(&mut file, \"name: {}\", info.name) {\n-        return Err(e)\n-    }\n-    if let Err(e) = writeln!(&mut file, \"age: {}\", info.age) {\n-        return Err(e)\n-    }\n-    if let Err(e) = writeln!(&mut file, \"rating: {}\", info.rating) {\n-        return Err(e)\n-    }\n-\n-    return Ok(());\n-}\n-```\n-\n-With this:\n-\n-```rust\n-use std::fs::File;\n-use std::io;\n-use std::io::prelude::*;\n-\n-struct Info {\n-    name: String,\n-    age: i32,\n-    rating: i32,\n-}\n-\n-fn write_info(info: &Info) -> io::Result<()> {\n-    let mut file = try!(File::open(\"my_best_friends.txt\"));\n-\n-    try!(writeln!(&mut file, \"name: {}\", info.name));\n-    try!(writeln!(&mut file, \"age: {}\", info.age));\n-    try!(writeln!(&mut file, \"rating: {}\", info.rating));\n-\n-    return Ok(());\n-}\n-```\n-\n-Wrapping an expression in `try!` will result in the unwrapped success (`Ok`)\n-value, unless the result is `Err`, in which case `Err` is returned early from\n-the enclosing function.\n-\n-It's worth noting that you can only use `try!` from a function that returns a\n-`Result`, which means that you cannot use `try!` inside of `main()`, because\n-`main()` doesn't return anything.\n-\n-`try!` makes use of [`FromError`](../std/error/#the-fromerror-trait) to determine\n-what to return in the error case."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 0, "deletions": 530, "changes": 530, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,530 +0,0 @@\n-% Foreign Function Interface\n-\n-# Introduction\n-\n-This guide will use the [snappy](https://github.com/google/snappy)\n-compression/decompression library as an introduction to writing bindings for\n-foreign code. Rust is currently unable to call directly into a C++ library, but\n-snappy includes a C interface (documented in\n-[`snappy-c.h`](https://github.com/google/snappy/blob/master/snappy-c.h)).\n-\n-The following is a minimal example of calling a foreign function which will\n-compile if snappy is installed:\n-\n-```no_run\n-# #![feature(libc)]\n-extern crate libc;\n-use libc::size_t;\n-\n-#[link(name = \"snappy\")]\n-extern {\n-    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n-}\n-\n-fn main() {\n-    let x = unsafe { snappy_max_compressed_length(100) };\n-    println!(\"max compressed length of a 100 byte buffer: {}\", x);\n-}\n-```\n-\n-The `extern` block is a list of function signatures in a foreign library, in\n-this case with the platform's C ABI. The `#[link(...)]` attribute is used to\n-instruct the linker to link against the snappy library so the symbols are\n-resolved.\n-\n-Foreign functions are assumed to be unsafe so calls to them need to be wrapped\n-with `unsafe {}` as a promise to the compiler that everything contained within\n-truly is safe. C libraries often expose interfaces that aren't thread-safe, and\n-almost any function that takes a pointer argument isn't valid for all possible\n-inputs since the pointer could be dangling, and raw pointers fall outside of\n-Rust's safe memory model.\n-\n-When declaring the argument types to a foreign function, the Rust compiler can\n-not check if the declaration is correct, so specifying it correctly is part of\n-keeping the binding correct at runtime.\n-\n-The `extern` block can be extended to cover the entire snappy API:\n-\n-```no_run\n-# #![feature(libc)]\n-extern crate libc;\n-use libc::{c_int, size_t};\n-\n-#[link(name = \"snappy\")]\n-extern {\n-    fn snappy_compress(input: *const u8,\n-                       input_length: size_t,\n-                       compressed: *mut u8,\n-                       compressed_length: *mut size_t) -> c_int;\n-    fn snappy_uncompress(compressed: *const u8,\n-                         compressed_length: size_t,\n-                         uncompressed: *mut u8,\n-                         uncompressed_length: *mut size_t) -> c_int;\n-    fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n-    fn snappy_uncompressed_length(compressed: *const u8,\n-                                  compressed_length: size_t,\n-                                  result: *mut size_t) -> c_int;\n-    fn snappy_validate_compressed_buffer(compressed: *const u8,\n-                                         compressed_length: size_t) -> c_int;\n-}\n-# fn main() {}\n-```\n-\n-# Creating a safe interface\n-\n-The raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts\n-like vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe\n-internal details.\n-\n-Wrapping the functions which expect buffers involves using the `slice::raw` module to manipulate Rust\n-vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous block of memory. The\n-length is number of elements currently contained, and the capacity is the total size in elements of\n-the allocated memory. The length is less than or equal to the capacity.\n-\n-```\n-# #![feature(libc)]\n-# extern crate libc;\n-# use libc::{c_int, size_t};\n-# unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -> c_int { 0 }\n-# fn main() {}\n-pub fn validate_compressed_buffer(src: &[u8]) -> bool {\n-    unsafe {\n-        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\n-    }\n-}\n-```\n-\n-The `validate_compressed_buffer` wrapper above makes use of an `unsafe` block, but it makes the\n-guarantee that calling it is safe for all inputs by leaving off `unsafe` from the function\n-signature.\n-\n-The `snappy_compress` and `snappy_uncompress` functions are more complex, since a buffer has to be\n-allocated to hold the output too.\n-\n-The `snappy_max_compressed_length` function can be used to allocate a vector with the maximum\n-required capacity to hold the compressed output. The vector can then be passed to the\n-`snappy_compress` function as an output parameter. An output parameter is also passed to retrieve\n-the true length after compression for setting the length.\n-\n-```\n-# #![feature(libc)]\n-# extern crate libc;\n-# use libc::{size_t, c_int};\n-# unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,\n-#                           d: *mut size_t) -> c_int { 0 }\n-# unsafe fn snappy_max_compressed_length(a: size_t) -> size_t { a }\n-# fn main() {}\n-pub fn compress(src: &[u8]) -> Vec<u8> {\n-    unsafe {\n-        let srclen = src.len() as size_t;\n-        let psrc = src.as_ptr();\n-\n-        let mut dstlen = snappy_max_compressed_length(srclen);\n-        let mut dst = Vec::with_capacity(dstlen as usize);\n-        let pdst = dst.as_mut_ptr();\n-\n-        snappy_compress(psrc, srclen, pdst, &mut dstlen);\n-        dst.set_len(dstlen as usize);\n-        dst\n-    }\n-}\n-```\n-\n-Decompression is similar, because snappy stores the uncompressed size as part of the compression\n-format and `snappy_uncompressed_length` will retrieve the exact buffer size required.\n-\n-```\n-# #![feature(libc)]\n-# extern crate libc;\n-# use libc::{size_t, c_int};\n-# unsafe fn snappy_uncompress(compressed: *const u8,\n-#                             compressed_length: size_t,\n-#                             uncompressed: *mut u8,\n-#                             uncompressed_length: *mut size_t) -> c_int { 0 }\n-# unsafe fn snappy_uncompressed_length(compressed: *const u8,\n-#                                      compressed_length: size_t,\n-#                                      result: *mut size_t) -> c_int { 0 }\n-# fn main() {}\n-pub fn uncompress(src: &[u8]) -> Option<Vec<u8>> {\n-    unsafe {\n-        let srclen = src.len() as size_t;\n-        let psrc = src.as_ptr();\n-\n-        let mut dstlen: size_t = 0;\n-        snappy_uncompressed_length(psrc, srclen, &mut dstlen);\n-\n-        let mut dst = Vec::with_capacity(dstlen as usize);\n-        let pdst = dst.as_mut_ptr();\n-\n-        if snappy_uncompress(psrc, srclen, pdst, &mut dstlen) == 0 {\n-            dst.set_len(dstlen as usize);\n-            Some(dst)\n-        } else {\n-            None // SNAPPY_INVALID_INPUT\n-        }\n-    }\n-}\n-```\n-\n-For reference, the examples used here are also available as an [library on\n-GitHub](https://github.com/thestinger/rust-snappy).\n-\n-# Destructors\n-\n-Foreign libraries often hand off ownership of resources to the calling code.\n-When this occurs, we must use Rust's destructors to provide safety and guarantee\n-the release of these resources (especially in the case of panic).\n-\n-For more about destructors, see the [Drop trait](../std/ops/trait.Drop.html).\n-\n-# Callbacks from C code to Rust functions\n-\n-Some external libraries require the usage of callbacks to report back their\n-current state or intermediate data to the caller.\n-It is possible to pass functions defined in Rust to an external library.\n-The requirement for this is that the callback function is marked as `extern`\n-with the correct calling convention to make it callable from C code.\n-\n-The callback function can then be sent through a registration call\n-to the C library and afterwards be invoked from there.\n-\n-A basic example is:\n-\n-Rust code:\n-\n-```no_run\n-extern fn callback(a: i32) {\n-    println!(\"I'm called from C with value {0}\", a);\n-}\n-\n-#[link(name = \"extlib\")]\n-extern {\n-   fn register_callback(cb: extern fn(i32)) -> i32;\n-   fn trigger_callback();\n-}\n-\n-fn main() {\n-    unsafe {\n-        register_callback(callback);\n-        trigger_callback(); // Triggers the callback\n-    }\n-}\n-```\n-\n-C code:\n-\n-```c\n-typedef void (*rust_callback)(int32_t);\n-rust_callback cb;\n-\n-int32_t register_callback(rust_callback callback) {\n-    cb = callback;\n-    return 1;\n-}\n-\n-void trigger_callback() {\n-  cb(7); // Will call callback(7) in Rust\n-}\n-```\n-\n-In this example Rust's `main()` will call `trigger_callback()` in C,\n-which would, in turn, call back to `callback()` in Rust.\n-\n-\n-## Targeting callbacks to Rust objects\n-\n-The former example showed how a global function can be called from C code.\n-However it is often desired that the callback is targeted to a special\n-Rust object. This could be the object that represents the wrapper for the\n-respective C object.\n-\n-This can be achieved by passing an unsafe pointer to the object down to the\n-C library. The C library can then include the pointer to the Rust object in\n-the notification. This will allow the callback to unsafely access the\n-referenced Rust object.\n-\n-Rust code:\n-\n-```no_run\n-#[repr(C)]\n-struct RustObject {\n-    a: i32,\n-    // other members\n-}\n-\n-extern \"C\" fn callback(target: *mut RustObject, a: i32) {\n-    println!(\"I'm called from C with value {0}\", a);\n-    unsafe {\n-        // Update the value in RustObject with the value received from the callback\n-        (*target).a = a;\n-    }\n-}\n-\n-#[link(name = \"extlib\")]\n-extern {\n-   fn register_callback(target: *mut RustObject,\n-                        cb: extern fn(*mut RustObject, i32)) -> i32;\n-   fn trigger_callback();\n-}\n-\n-fn main() {\n-    // Create the object that will be referenced in the callback\n-    let mut rust_object = Box::new(RustObject { a: 5 });\n-\n-    unsafe {\n-        register_callback(&mut *rust_object, callback);\n-        trigger_callback();\n-    }\n-}\n-```\n-\n-C code:\n-\n-```c\n-typedef void (*rust_callback)(void*, int32_t);\n-void* cb_target;\n-rust_callback cb;\n-\n-int32_t register_callback(void* callback_target, rust_callback callback) {\n-    cb_target = callback_target;\n-    cb = callback;\n-    return 1;\n-}\n-\n-void trigger_callback() {\n-  cb(cb_target, 7); // Will call callback(&rustObject, 7) in Rust\n-}\n-```\n-\n-## Asynchronous callbacks\n-\n-In the previously given examples the callbacks are invoked as a direct reaction\n-to a function call to the external C library.\n-The control over the current thread is switched from Rust to C to Rust for the\n-execution of the callback, but in the end the callback is executed on the\n-same thread that called the function which triggered the callback.\n-\n-Things get more complicated when the external library spawns its own threads\n-and invokes callbacks from there.\n-In these cases access to Rust data structures inside the callbacks is\n-especially unsafe and proper synchronization mechanisms must be used.\n-Besides classical synchronization mechanisms like mutexes, one possibility in\n-Rust is to use channels (in `std::comm`) to forward data from the C thread\n-that invoked the callback into a Rust thread.\n-\n-If an asynchronous callback targets a special object in the Rust address space\n-it is also absolutely necessary that no more callbacks are performed by the\n-C library after the respective Rust object gets destroyed.\n-This can be achieved by unregistering the callback in the object's\n-destructor and designing the library in a way that guarantees that no\n-callback will be performed after deregistration.\n-\n-# Linking\n-\n-The `link` attribute on `extern` blocks provides the basic building block for\n-instructing rustc how it will link to native libraries. There are two accepted\n-forms of the link attribute today:\n-\n-* `#[link(name = \"foo\")]`\n-* `#[link(name = \"foo\", kind = \"bar\")]`\n-\n-In both of these cases, `foo` is the name of the native library that we're\n-linking to, and in the second case `bar` is the type of native library that the\n-compiler is linking to. There are currently three known types of native\n-libraries:\n-\n-* Dynamic - `#[link(name = \"readline\")]`\n-* Static - `#[link(name = \"my_build_dependency\", kind = \"static\")]`\n-* Frameworks - `#[link(name = \"CoreFoundation\", kind = \"framework\")]`\n-\n-Note that frameworks are only available on OSX targets.\n-\n-The different `kind` values are meant to differentiate how the native library\n-participates in linkage. From a linkage perspective, the rust compiler creates\n-two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary).\n-Native dynamic libraries and frameworks are propagated to the final artifact\n-boundary, while static libraries are not propagated at all.\n-\n-A few examples of how this model can be used are:\n-\n-* A native build dependency. Sometimes some C/C++ glue is needed when writing\n-  some rust code, but distribution of the C/C++ code in a library format is just\n-  a burden. In this case, the code will be archived into `libfoo.a` and then the\n-  rust crate would declare a dependency via `#[link(name = \"foo\", kind =\n-  \"static\")]`.\n-\n-  Regardless of the flavor of output for the crate, the native static library\n-  will be included in the output, meaning that distribution of the native static\n-  library is not necessary.\n-\n-* A normal dynamic dependency. Common system libraries (like `readline`) are\n-  available on a large number of systems, and often a static copy of these\n-  libraries cannot be found. When this dependency is included in a rust crate,\n-  partial targets (like rlibs) will not link to the library, but when the rlib\n-  is included in a final target (like a binary), the native library will be\n-  linked in.\n-\n-On OSX, frameworks behave with the same semantics as a dynamic library.\n-\n-# Unsafe blocks\n-\n-Some operations, like dereferencing unsafe pointers or calling functions that have been marked\n-unsafe are only allowed inside unsafe blocks. Unsafe blocks isolate unsafety and are a promise to\n-the compiler that the unsafety does not leak out of the block.\n-\n-Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like\n-this:\n-\n-```\n-unsafe fn kaboom(ptr: *const i32) -> i32 { *ptr }\n-```\n-\n-This function can only be called from an `unsafe` block or another `unsafe` function.\n-\n-# Accessing foreign globals\n-\n-Foreign APIs often export a global variable which could do something like track\n-global state. In order to access these variables, you declare them in `extern`\n-blocks with the `static` keyword:\n-\n-```no_run\n-# #![feature(libc)]\n-extern crate libc;\n-\n-#[link(name = \"readline\")]\n-extern {\n-    static rl_readline_version: libc::c_int;\n-}\n-\n-fn main() {\n-    println!(\"You have readline version {} installed.\",\n-             rl_readline_version as i32);\n-}\n-```\n-\n-Alternatively, you may need to alter global state provided by a foreign\n-interface. To do this, statics can be declared with `mut` so we can mutate\n-them.\n-\n-```no_run\n-# #![feature(libc)]\n-extern crate libc;\n-\n-use std::ffi::CString;\n-use std::ptr;\n-\n-#[link(name = \"readline\")]\n-extern {\n-    static mut rl_prompt: *const libc::c_char;\n-}\n-\n-fn main() {\n-    let prompt = CString::new(\"[my-awesome-shell] $\").unwrap();\n-    unsafe {\n-        rl_prompt = prompt.as_ptr();\n-\n-        println!(\"{:?}\", rl_prompt);\n-\n-        rl_prompt = ptr::null();\n-    }\n-}\n-```\n-\n-Note that all interaction with a `static mut` is unsafe, both reading and\n-writing. Dealing with global mutable state requires a great deal of care.\n-\n-# Foreign calling conventions\n-\n-Most foreign code exposes a C ABI, and Rust uses the platform's C calling convention by default when\n-calling foreign functions. Some foreign functions, most notably the Windows API, use other calling\n-conventions. Rust provides a way to tell the compiler which convention to use:\n-\n-```\n-# #![feature(libc)]\n-extern crate libc;\n-\n-#[cfg(all(target_os = \"win32\", target_arch = \"x86\"))]\n-#[link(name = \"kernel32\")]\n-#[allow(non_snake_case)]\n-extern \"stdcall\" {\n-    fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -> libc::c_int;\n-}\n-# fn main() { }\n-```\n-\n-This applies to the entire `extern` block. The list of supported ABI constraints\n-are:\n-\n-* `stdcall`\n-* `aapcs`\n-* `cdecl`\n-* `fastcall`\n-* `Rust`\n-* `rust-intrinsic`\n-* `system`\n-* `C`\n-* `win64`\n-\n-Most of the abis in this list are self-explanatory, but the `system` abi may\n-seem a little odd. This constraint selects whatever the appropriate ABI is for\n-interoperating with the target's libraries. For example, on win32 with a x86\n-architecture, this means that the abi used would be `stdcall`. On x86_64,\n-however, windows uses the `C` calling convention, so `C` would be used. This\n-means that in our previous example, we could have used `extern \"system\" { ... }`\n-to define a block for all windows systems, not just x86 ones.\n-\n-# Interoperability with foreign code\n-\n-Rust guarantees that the layout of a `struct` is compatible with the platform's\n-representation in C only if the `#[repr(C)]` attribute is applied to it.\n-`#[repr(C, packed)]` can be used to lay out struct members without padding.\n-`#[repr(C)]` can also be applied to an enum.\n-\n-Rust's owned boxes (`Box<T>`) use non-nullable pointers as handles which point\n-to the contained object. However, they should not be manually created because\n-they are managed by internal allocators. References can safely be assumed to be\n-non-nullable pointers directly to the type.  However, breaking the borrow\n-checking or mutability rules is not guaranteed to be safe, so prefer using raw\n-pointers (`*`) if that's needed because the compiler can't make as many\n-assumptions about them.\n-\n-Vectors and strings share the same basic memory layout, and utilities are\n-available in the `vec` and `str` modules for working with C APIs. However,\n-strings are not terminated with `\\0`. If you need a NUL-terminated string for\n-interoperability with C, you should use the `CString` type in the `std::ffi`\n-module.\n-\n-The standard library includes type aliases and function definitions for the C\n-standard library in the `libc` module, and Rust links against `libc` and `libm`\n-by default.\n-\n-# The \"nullable pointer optimization\"\n-\n-Certain types are defined to not be `null`. This includes references (`&T`,\n-`&mut T`), boxes (`Box<T>`), and function pointers (`extern \"abi\" fn()`).\n-When interfacing with C, pointers that might be null are often used.\n-As a special case, a generic `enum` that contains exactly two variants, one of\n-which contains no data and the other containing a single field, is eligible\n-for the \"nullable pointer optimization\". When such an enum is instantiated\n-with one of the non-nullable types, it is represented as a single pointer,\n-and the non-data variant is represented as the null pointer. So\n-`Option<extern \"C\" fn(c_int) -> c_int>` is how one represents a nullable\n-function pointer using the C ABI.\n-\n-# Calling Rust code from C\n-\n-You may wish to compile Rust code in a way so that it can be called from C. This is\n-fairly easy, but requires a few things:\n-\n-```\n-#[no_mangle]\n-pub extern fn hello_rust() -> *const u8 {\n-    \"Hello, world!\\0\".as_ptr()\n-}\n-# fn main() {}\n-```\n-\n-The `extern` makes this function adhere to the C calling convention, as\n-discussed above in \"[Foreign Calling\n-Conventions](ffi.html#foreign-calling-conventions)\". The `no_mangle`\n-attribute turns off Rust's name mangling, so that it is easier to link to."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/for-loops.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ffor-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ffor-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffor-loops.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/functions.md", "status": "modified", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffunctions.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,193 +0,0 @@\n-% Functions\n-\n-You've already seen one function so far, the `main` function:\n-\n-```rust\n-fn main() {\n-}\n-```\n-\n-This is the simplest possible function declaration. As we mentioned before,\n-`fn` says \"this is a function,\" followed by the name, some parentheses because\n-this function takes no arguments, and then some curly braces to indicate the\n-body. Here's a function named `foo`:\n-\n-```rust\n-fn foo() {\n-}\n-```\n-\n-So, what about taking arguments? Here's a function that prints a number:\n-\n-```rust\n-fn print_number(x: i32) {\n-    println!(\"x is: {}\", x);\n-}\n-```\n-\n-Here's a complete program that uses `print_number`:\n-\n-```rust\n-fn main() {\n-    print_number(5);\n-}\n-\n-fn print_number(x: i32) {\n-    println!(\"x is: {}\", x);\n-}\n-```\n-\n-As you can see, function arguments work very similar to `let` declarations:\n-you add a type to the argument name, after a colon.\n-\n-Here's a complete program that adds two numbers together and prints them:\n-\n-```rust\n-fn main() {\n-    print_sum(5, 6);\n-}\n-\n-fn print_sum(x: i32, y: i32) {\n-    println!(\"sum is: {}\", x + y);\n-}\n-```\n-\n-You separate arguments with a comma, both when you call the function, as well\n-as when you declare it.\n-\n-Unlike `let`, you _must_ declare the types of function arguments. This does\n-not work:\n-\n-```{rust,ignore}\n-fn print_sum(x, y) {\n-    println!(\"sum is: {}\", x + y);\n-}\n-```\n-\n-You get this error:\n-\n-```text\n-hello.rs:5:18: 5:19 expected one of `!`, `:`, or `@`, found `)`\n-hello.rs:5 fn print_number(x, y) {\n-```\n-\n-This is a deliberate design decision. While full-program inference is possible,\n-languages which have it, like Haskell, often suggest that documenting your\n-types explicitly is a best-practice. We agree that forcing functions to declare\n-types while allowing for inference inside of function bodies is a wonderful\n-sweet spot between full inference and no inference.\n-\n-What about returning a value? Here's a function that adds one to an integer:\n-\n-```rust\n-fn add_one(x: i32) -> i32 {\n-    x + 1\n-}\n-```\n-\n-Rust functions return exactly one value, and you declare the type after an\n-\"arrow,\" which is a dash (`-`) followed by a greater-than sign (`>`).\n-\n-You'll note the lack of a semicolon here. If we added it in:\n-\n-```{rust,ignore}\n-fn add_one(x: i32) -> i32 {\n-    x + 1;\n-}\n-```\n-\n-We would get an error:\n-\n-```text\n-error: not all control paths return a value\n-fn add_one(x: i32) -> i32 {\n-     x + 1;\n-}\n-\n-help: consider removing this semicolon:\n-     x + 1;\n-          ^\n-```\n-\n-Remember our earlier discussions about semicolons and `()`? Our function claims\n-to return an `i32`, but with a semicolon, it would return `()` instead. Rust\n-realizes this probably isn't what we want, and suggests removing the semicolon.\n-\n-This is very much like our `if` statement before: the result of the block\n-(`{}`) is the value of the expression. Other expression-oriented languages,\n-such as Ruby, work like this, but it's a bit unusual in the systems programming\n-world. When people first learn about this, they usually assume that it\n-introduces bugs. But because Rust's type system is so strong, and because unit\n-is its own unique type, we have never seen an issue where adding or removing a\n-semicolon in a return position would cause a bug.\n-\n-But what about early returns? Rust does have a keyword for that, `return`:\n-\n-```rust\n-fn foo(x: i32) -> i32 {\n-    if x < 5 { return x; }\n-\n-    x + 1\n-}\n-```\n-\n-Using a `return` as the last line of a function works, but is considered poor\n-style:\n-\n-```rust\n-fn foo(x: i32) -> i32 {\n-    if x < 5 { return x; }\n-\n-    return x + 1;\n-}\n-```\n-\n-The previous definition without `return` may look a bit strange if you haven't\n-worked in an expression-based language before, but it becomes intuitive over\n-time. If this were production code, we wouldn't write it in that way anyway,\n-we'd write this:\n-\n-```rust\n-fn foo(x: i32) -> i32 {\n-    if x < 5 {\n-        x\n-    } else {\n-        x + 1\n-    }\n-}\n-```\n-\n-Because `if` is an expression, and it's the only expression in this function,\n-the value will be the result of the `if`.\n-\n-## Diverging functions\n-\n-Rust has some special syntax for 'diverging functions', which are functions that\n-do not return:\n-\n-```\n-fn diverges() -> ! {\n-    panic!(\"This function never returns!\");\n-}\n-```\n-\n-`panic!` is a macro, similar to `println!()` that we've already seen. Unlike\n-`println!()`, `panic!()` causes the current thread of execution to crash with\n-the given message.\n-\n-Because this function will cause a crash, it will never return, and so it has\n-the type '`!`', which is read \"diverges.\" A diverging function can be used\n-as any type:\n-\n-```should_panic\n-# fn diverges() -> ! {\n-#    panic!(\"This function never returns!\");\n-# }\n-\n-let x: i32 = diverges();\n-let x: String = diverges();\n-```\n-\n-We don't have a good use for diverging functions yet, because they're used in\n-conjunction with other Rust features. But when you see `-> !` later, you'll\n-know what it's called."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/generics.md", "status": "modified", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,177 +0,0 @@\n-% Generics\n-\n-Sometimes, when writing a function or data type, we may want it to work for\n-multiple types of arguments. For example, remember our `OptionalInt` type?\n-\n-```{rust}\n-enum OptionalInt {\n-    Value(i32),\n-    Missing,\n-}\n-```\n-\n-If we wanted to also have an `OptionalFloat64`, we would need a new enum:\n-\n-```{rust}\n-enum OptionalFloat64 {\n-    Valuef64(f64),\n-    Missingf64,\n-}\n-```\n-\n-This is really unfortunate. Luckily, Rust has a feature that gives us a better\n-way: generics. Generics are called *parametric polymorphism* in type theory,\n-which means that they are types or functions that have multiple forms (*poly*\n-is multiple, *morph* is form) over a given parameter (*parametric*).\n-\n-Anyway, enough with type theory declarations, let's check out the generic form\n-of `OptionalInt`. It is actually provided by Rust itself, and looks like this:\n-\n-```rust\n-enum Option<T> {\n-    Some(T),\n-    None,\n-}\n-```\n-\n-The `<T>` part, which you've seen a few times before, indicates that this is\n-a generic data type. Inside the declaration of our enum, wherever we see a `T`,\n-we substitute that type for the same type used in the generic. Here's an\n-example of using `Option<T>`, with some extra type annotations:\n-\n-```{rust}\n-let x: Option<i32> = Some(5);\n-```\n-\n-In the type declaration, we say `Option<i32>`. Note how similar this looks to\n-`Option<T>`. So, in this particular `Option`, `T` has the value of `i32`. On\n-the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5`.\n-Since that's an `i32`, the two sides match, and Rust is happy. If they didn't\n-match, we'd get an error:\n-\n-```{rust,ignore}\n-let x: Option<f64> = Some(5);\n-// error: mismatched types: expected `core::option::Option<f64>`,\n-// found `core::option::Option<_>` (expected f64 but found integral variable)\n-```\n-\n-That doesn't mean we can't make `Option<T>`s that hold an `f64`! They just have to\n-match up:\n-\n-```{rust}\n-let x: Option<i32> = Some(5);\n-let y: Option<f64> = Some(5.0f64);\n-```\n-\n-This is just fine. One definition, multiple uses.\n-\n-Generics don't have to only be generic over one type. Consider Rust's built-in\n-`Result<T, E>` type:\n-\n-```{rust}\n-enum Result<T, E> {\n-    Ok(T),\n-    Err(E),\n-}\n-```\n-\n-This type is generic over _two_ types: `T` and `E`. By the way, the capital letters\n-can be any letter you'd like. We could define `Result<T, E>` as:\n-\n-```{rust}\n-enum Result<A, Z> {\n-    Ok(A),\n-    Err(Z),\n-}\n-```\n-\n-if we wanted to. Convention says that the first generic parameter should be\n-`T`, for 'type,' and that we use `E` for 'error.' Rust doesn't care, however.\n-\n-The `Result<T, E>` type is intended to be used to return the result of a\n-computation, and to have the ability to return an error if it didn't work out.\n-Here's an example:\n-\n-```{rust}\n-let x: Result<f64, String> = Ok(2.3f64);\n-let y: Result<f64, String> = Err(\"There was an error.\".to_string());\n-```\n-\n-This particular Result will return an `f64` if there's a success, and a\n-`String` if there's a failure. Let's write a function that uses `Result<T, E>`:\n-\n-```{rust}\n-fn inverse(x: f64) -> Result<f64, String> {\n-    if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0f64 / x)\n-}\n-```\n-\n-We don't want to take the inverse of zero, so we check to make sure that we\n-weren't passed zero. If we were, then we return an `Err`, with a message. If\n-it's okay, we return an `Ok`, with the answer.\n-\n-Why does this matter? Well, remember how `match` does exhaustive matches?\n-Here's how this function gets used:\n-\n-```{rust}\n-# fn inverse(x: f64) -> Result<f64, String> {\n-#     if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n-#     Ok(1.0f64 / x)\n-# }\n-let x = inverse(25.0f64);\n-\n-match x {\n-    Ok(x) => println!(\"The inverse of 25 is {}\", x),\n-    Err(msg) => println!(\"Error: {}\", msg),\n-}\n-```\n-\n-The `match` enforces that we handle the `Err` case. In addition, because the\n-answer is wrapped up in an `Ok`, we can't just use the result without doing\n-the match:\n-\n-```{rust,ignore}\n-let x = inverse(25.0f64);\n-println!(\"{}\", x + 2.0f64); // error: binary operation `+` cannot be applied\n-           // to type `core::result::Result<f64,collections::string::String>`\n-```\n-\n-This function is great, but there's one other problem: it only works for 64 bit\n-floating point values. What if we wanted to handle 32 bit floating point as\n-well? We'd have to write this:\n-\n-```{rust}\n-fn inverse32(x: f32) -> Result<f32, String> {\n-    if x == 0.0f32 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0f32 / x)\n-}\n-```\n-\n-Bummer. What we need is a *generic function*. Luckily, we can write one!\n-However, it won't _quite_ work yet. Before we get into that, let's talk syntax.\n-A generic version of `inverse` would look something like this:\n-\n-```{rust,ignore}\n-fn inverse<T>(x: T) -> Result<T, String> {\n-    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0 / x)\n-}\n-```\n-\n-Just like how we had `Option<T>`, we use a similar syntax for `inverse<T>`.\n-We can then use `T` inside the rest of the signature: `x` has type `T`, and half\n-of the `Result` has type `T`. However, if we try to compile that example, we'll get\n-an error:\n-\n-```text\n-error: binary operation `==` cannot be applied to type `T`\n-```\n-\n-Because `T` can be _any_ type, it may be a type that doesn't implement `==`,\n-and therefore, the first line would be wrong. What do we do?\n-\n-To fix this example, we need to learn about another Rust feature: traits."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/getting-started.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgetting-started.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/glossary.md", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fglossary.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fglossary.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fglossary.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,39 +0,0 @@\n-% Glossary\n-\n-Not every Rustacean has a background in systems programming, nor in computer\n-science, so we've added explanations of terms that might be unfamiliar.\n-\n-### Arity\n-\n-Arity refers to the number of arguments a function or operation takes.\n-\n-```rust\n-let x = (2, 3);\n-let y = (4, 6);\n-let z = (8, 2, 6);\n-```\n-\n-In the example above `x` and `y` have arity 2. `z` has arity 3.\n-\n-### Abstract Syntax Tree\n-\n-When a compiler is compiling your program, it does a number of different\n-things. One of the things that it does is turn the text of your program into an\n-'abstract syntax tree,' or 'AST.' This tree is a representation of the\n-structure of your program. For example, `2 + 3` can be turned into a tree:\n-\n-```text\n-  +\n- / \\\n-2   3\n-```\n-\n-And `2 + (3 * 4)` would look like this:\n-\n-```text\n-  +\n- / \\\n-2   *\n-   / \\\n-  3   4\n-```"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/hello-cargo.md", "status": "modified", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-cargo.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,168 +0,0 @@\n-% Hello, Cargo!\n-\n-[Cargo](http://crates.io) is a tool that Rustaceans use to help manage their\n-Rust projects. Cargo is currently in a pre-1.0 state, just like Rust, and so it\n-is still a work in progress. However, it is already good enough to use for many\n-Rust projects, and so it is assumed that Rust projects will use Cargo from the\n-beginning.\n-\n-Cargo manages three things: building your code, downloading the dependencies\n-your code needs, and building those dependencies. At first, your\n-program doesn't have any dependencies, so we'll only be using the first part of\n-its functionality. Eventually, we'll add more. Since we started off by using\n-Cargo, it'll be easy to add later.\n-\n-If you installed Rust via the official installers you will also have\n-Cargo. If you installed Rust some other way, you may want to [check\n-the Cargo\n-README](https://github.com/rust-lang/cargo#installing-cargo-from-nightlies)\n-for specific instructions about installing it.\n-\n-## Converting to Cargo\n-\n-Let's convert Hello World to Cargo.\n-\n-To Cargo-ify our project, we need to do two things: Make a `Cargo.toml`\n-configuration file, and put our source file in the right place. Let's\n-do that part first:\n-\n-```bash\n-$ mkdir src\n-$ mv main.rs src/main.rs\n-```\n-\n-Cargo expects your source files to live inside a `src` directory. That leaves\n-the top level for other things, like READMEs, license information, and anything\n-not related to your code. Cargo helps us keep our projects nice and tidy. A\n-place for everything, and everything in its place.\n-\n-Next, our configuration file:\n-\n-```bash\n-$ editor Cargo.toml\n-```\n-\n-Make sure to get this name right: you need the capital `C`!\n-\n-Put this inside:\n-\n-```toml\n-[package]\n-\n-name = \"hello_world\"\n-version = \"0.0.1\"\n-authors = [ \"Your name <you@example.com>\" ]\n-\n-[[bin]]\n-\n-name = \"hello_world\"\n-```\n-\n-This file is in the [TOML](https://github.com/toml-lang/toml) format. Let's let\n-it explain itself to you:\n-\n-> TOML aims to be a minimal configuration file format that's easy to read due\n-> to obvious semantics. TOML is designed to map unambiguously to a hash table.\n-> TOML should be easy to parse into data structures in a wide variety of\n-> languages.\n-\n-TOML is very similar to INI, but with some extra goodies.\n-\n-Anyway, there are two *tables* in this file: `package` and `bin`. The first\n-tells Cargo metadata about your package. The second tells Cargo that we're\n-interested in building a binary, not a library (though we could do both!), as\n-well as what it is named.\n-\n-Once you have this file in place, we should be ready to build! Try this:\n-\n-```bash\n-$ cargo build\n-   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)\n-$ ./target/debug/hello_world\n-Hello, world!\n-```\n-\n-Bam! We build our project with `cargo build`, and run it with\n-`./target/debug/hello_world`. This hasn't bought us a whole lot over our simple use\n-of `rustc`, but think about the future: when our project has more than one\n-file, we would need to call `rustc` more than once and pass it a bunch of options to\n-tell it to build everything together. With Cargo, as our project grows, we can\n-just `cargo build`, and it'll work the right way. When your project is finally\n-ready for release, you can use `cargo build --release` to compile your crates with\n-optimizations.\n-\n-You'll also notice that Cargo has created a new file: `Cargo.lock`.\n-\n-```toml\n-[root]\n-name = \"hello_world\"\n-version = \"0.0.1\"\n-```\n-\n-This file is used by Cargo to keep track of dependencies in your application.\n-Right now, we don't have any, so it's a bit sparse. You won't ever need\n-to touch this file yourself, just let Cargo handle it.\n-\n-That's it! We've successfully built `hello_world` with Cargo. Even though our\n-program is simple, it's using much of the real tooling that you'll use for the\n-rest of your Rust career.\n-\n-## A New Project\n-\n-You don't have to go through this whole process every time you want to start a new\n-project! Cargo has the ability to make a bare-bones project directory in which you\n-can start developing right away.\n-\n-To start a new project with Cargo, use `cargo new`:\n-\n-```bash\n-$ cargo new hello_world --bin\n-```\n-\n-We're passing `--bin` because we're making a binary program: if we\n-were making a library, we'd leave it off.\n-\n-Let's check out what Cargo has generated for us:\n-\n-```bash\n-$ cd hello_world\n-$ tree .\n-.\n-\u251c\u2500\u2500 Cargo.toml\n-\u2514\u2500\u2500 src\n-    \u2514\u2500\u2500 main.rs\n-\n-1 directory, 2 files\n-```\n-\n-If you don't have the `tree` command, you can probably get it from your distro's package\n-manager. It's not necessary, but it's certainly useful.\n-\n-This is all we need to get started. First, let's check out `Cargo.toml`:\n-\n-```toml\n-[package]\n-\n-name = \"hello_world\"\n-version = \"0.0.1\"\n-authors = [\"Your Name <you@example.com>\"]\n-```\n-\n-Cargo has populated this file with reasonable defaults based off the arguments you gave\n-it and your `git` global configuration. You may notice that Cargo has also initialized\n-the `hello_world` directory as a `git` repository.\n-\n-Here's what's in `src/main.rs`:\n-\n-```rust\n-fn main() {\n-    println!(\"Hello, world!\");\n-}\n-```\n-\n-Cargo has generated a \"Hello World!\" for us, and you're ready to start coding! A\n-much more in-depth guide to Cargo can be found [here](http://doc.crates.io/guide.html).\n-\n-Now that you've got the tools down, let's actually learn more about the Rust\n-language itself. These are the basics that will serve you well through the rest\n-of your time with Rust."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/hello-world.md", "status": "modified", "additions": 0, "deletions": 164, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fhello-world.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fhello-world.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-world.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,164 +0,0 @@\n-% Hello, world!\n-\n-Now that you have Rust installed, let's write your first Rust program. It's\n-traditional to make your first program in any new language one that prints the\n-text \"Hello, world!\" to the screen. The nice thing about starting with such a\n-simple program is that you can verify that your compiler isn't just installed,\n-but also working properly. And printing information to the screen is a pretty\n-common thing to do.\n-\n-The first thing that we need to do is make a file to put our code in. I like\n-to make a `projects` directory in my home directory, and keep all my projects\n-there. Rust does not care where your code lives.\n-\n-This actually leads to one other concern we should address: this guide will\n-assume that you have basic familiarity with the command line. Rust does not\n-require that you know a whole ton about the command line, but until the\n-language is in a more finished state, IDE support is spotty. Rust makes no\n-specific demands on your editing tooling, or where your code lives.\n-\n-With that said, let's make a directory in our projects directory.\n-\n-```{bash}\n-$ mkdir ~/projects\n-$ cd ~/projects\n-$ mkdir hello_world\n-$ cd hello_world\n-```\n-\n-If you're on Windows and not using PowerShell, the `~` may not work. Consult\n-the documentation for your shell for more details.\n-\n-Let's make a new source file next. I'm going to use the syntax `editor\n-filename` to represent editing a file in these examples, but you should use\n-whatever method you want. We'll call our file `main.rs`:\n-\n-```{bash}\n-$ editor main.rs\n-```\n-\n-Rust files always end in a `.rs` extension. If you're using more than one word\n-in your filename, use an underscore. `hello_world.rs` rather than\n-`helloworld.rs`.\n-\n-Now that you've got your file open, type this in:\n-\n-```{rust}\n-fn main() {\n-    println!(\"Hello, world!\");\n-}\n-```\n-\n-Save the file, and then type this into your terminal window:\n-\n-```{bash}\n-$ rustc main.rs\n-$ ./main # or main.exe on Windows\n-Hello, world!\n-```\n-\n-You can also run these examples on [play.rust-lang.org](http://play.rust-lang.org/) by clicking on the arrow that appears in the upper right of the example when you mouse over the code.\n-\n-Success! Let's go over what just happened in detail.\n-\n-```{rust}\n-fn main() {\n-\n-}\n-```\n-\n-These lines define a *function* in Rust. The `main` function is special:\n-it's the beginning of every Rust program. The first line says \"I'm declaring a\n-function named `main`, which takes no arguments and returns nothing.\" If there\n-were arguments, they would go inside the parentheses (`(` and `)`), and because\n-we aren't returning anything from this function, we can omit the return type\n-entirely. We'll get to it later.\n-\n-You'll also note that the function is wrapped in curly braces (`{` and `}`).\n-Rust requires these around all function bodies. It is also considered good\n-style to put the opening curly brace on the same line as the function\n-declaration, with one space in between.\n-\n-Next up is this line:\n-\n-```{rust}\n-    println!(\"Hello, world!\");\n-```\n-\n-This line does all of the work in our little program. There are a number of\n-details that are important here. The first is that it's indented with four\n-spaces, not tabs. Please configure your editor of choice to insert four spaces\n-with the tab key. We provide some [sample configurations for various\n-editors](https://github.com/rust-lang/rust/tree/master/src/etc/CONFIGS.md).\n-\n-The second point is the `println!()` part. This is calling a Rust *macro*,\n-which is how metaprogramming is done in Rust. If it were a function instead, it\n-would look like this: `println()`. For our purposes, we don't need to worry\n-about this difference. Just know that sometimes, you'll see a `!`, and that\n-means that you're calling a macro instead of a normal function. Rust implements\n-`println!` as a macro rather than a function for good reasons, but that's a\n-very advanced topic. You'll learn more when we talk about macros later. One\n-last thing to mention: Rust's macros are significantly different from C macros,\n-if you've used those. Don't be scared of using macros. We'll get to the details\n-eventually, you'll just have to trust us for now.\n-\n-Next, `\"Hello, world!\"` is a *string*. Strings are a surprisingly complicated\n-topic in a systems programming language, and this is a *statically allocated*\n-string. We will talk more about different kinds of allocation later. We pass\n-this string as an argument to `println!`, which prints the string to the\n-screen. Easy enough!\n-\n-Finally, the line ends with a semicolon (`;`). Rust is an *expression\n-oriented* language, which means that most things are expressions. The `;` is\n-used to indicate that this expression is over, and the next one is ready to\n-begin. Most lines of Rust code end with a `;`. We will cover this in-depth\n-later in the guide.\n-\n-Finally, actually *compiling* and *running* our program. We can compile\n-with our compiler, `rustc`, by passing it the name of our source file:\n-\n-```{bash}\n-$ rustc main.rs\n-```\n-\n-This is similar to `gcc` or `clang`, if you come from a C or C++ background. Rust\n-will output a binary executable. You can see it with `ls`:\n-\n-```{bash}\n-$ ls\n-main  main.rs\n-```\n-\n-Or on Windows:\n-\n-```{bash}\n-$ dir\n-main.exe  main.rs\n-```\n-\n-There are now two files: our source code, with the `.rs` extension, and the\n-executable (`main.exe` on Windows, `main` everywhere else)\n-\n-```{bash}\n-$ ./main  # or main.exe on Windows\n-```\n-\n-This prints out our `Hello, world!` text to our terminal.\n-\n-If you come from a dynamically typed language like Ruby, Python, or JavaScript,\n-you may not be used to these two steps being separate. Rust is an\n-*ahead-of-time compiled language*, which means that you can compile a\n-program, give it to someone else, and they don't need to have Rust installed.\n-If you give someone a `.rb` or `.py` or `.js` file, they need to have a\n-Ruby/Python/JavaScript implementation installed, but you just need one command\n-to both compile and run your program. Everything is a tradeoff in language design,\n-and Rust has made its choice.\n-\n-Congratulations! You have officially written a Rust program. That makes you a\n-Rust programmer! Welcome.\n-\n-Next, I'd like to introduce you to another tool, Cargo, which is used to write\n-real-world Rust programs. Just using `rustc` is nice for simple things, but as\n-your project grows, you'll want something to help you manage all of the options\n-that it has, and to make it easy to share your code with other people and\n-projects."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/if.md", "status": "modified", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fif.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fif.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,155 +0,0 @@\n-% If\n-\n-Rust's take on `if` is not particularly complex, but it's much more like the\n-`if` you'll find in a dynamically typed language than in a more traditional\n-systems language. So let's talk about it, to make sure you grasp the nuances.\n-\n-`if` is a specific form of a more general concept, the *branch*. The name comes\n-from a branch in a tree: a decision point, where depending on a choice,\n-multiple paths can be taken.\n-\n-In the case of `if`, there is one choice that leads down two paths:\n-\n-```rust\n-let x = 5;\n-\n-if x == 5 {\n-    println!(\"x is five!\");\n-}\n-```\n-\n-If we changed the value of `x` to something else, this line would not print.\n-More specifically, if the expression after the `if` evaluates to `true`, then\n-the block is executed. If it's `false`, then it is not.\n-\n-If you want something to happen in the `false` case, use an `else`:\n-\n-```{rust}\n-let x = 5;\n-\n-if x == 5 {\n-    println!(\"x is five!\");\n-} else {\n-    println!(\"x is not five :(\");\n-}\n-```\n-\n-If there is more than one case, use an `else if`:\n-\n-```rust\n-let x = 5;\n-\n-if x == 5 {\n-    println!(\"x is five!\");\n-} else if x == 6 {\n-    println!(\"x is six!\");\n-} else {\n-    println!(\"x is not five or six :(\");\n-}\n-```\n-\n-This is all pretty standard. However, you can also do this:\n-\n-\n-```{rust}\n-let x = 5;\n-\n-let y = if x == 5 {\n-    10\n-} else {\n-    15\n-}; // y: i32\n-```\n-\n-Which we can (and probably should) write like this:\n-\n-```{rust}\n-let x = 5;\n-\n-let y = if x == 5 { 10 } else { 15 }; // y: i32\n-```\n-\n-This reveals two interesting things about Rust: it is an expression-based\n-language, and semicolons are different from semicolons in other 'curly brace\n-and semicolon'-based languages. These two things are related.\n-\n-## Expressions vs. Statements\n-\n-Rust is primarily an expression based language. There are only two kinds of\n-statements, and everything else is an expression.\n-\n-So what's the difference? Expressions return a value, and statements do not.\n-In many languages, `if` is a statement, and therefore, `let x = if ...` would\n-make no sense. But in Rust, `if` is an expression, which means that it returns\n-a value. We can then use this value to initialize the binding.\n-\n-Speaking of which, bindings are a kind of the first of Rust's two statements.\n-The proper name is a *declaration statement*. So far, `let` is the only kind\n-of declaration statement we've seen. Let's talk about that some more.\n-\n-In some languages, variable bindings can be written as expressions, not just\n-statements. Like Ruby:\n-\n-```{ruby}\n-x = y = 5\n-```\n-\n-In Rust, however, using `let` to introduce a binding is _not_ an expression. The\n-following will produce a compile-time error:\n-\n-```{ignore}\n-let x = (let y = 5); // expected identifier, found keyword `let`\n-```\n-\n-The compiler is telling us here that it was expecting to see the beginning of\n-an expression, and a `let` can only begin a statement, not an expression.\n-\n-Note that assigning to an already-bound variable (e.g. `y = 5`) is still an\n-expression, although its value is not particularly useful. Unlike C, where an\n-assignment evaluates to the assigned value (e.g. `5` in the previous example),\n-in Rust the value of an assignment is the unit type `()` (which we'll cover later).\n-\n-The second kind of statement in Rust is the *expression statement*. Its\n-purpose is to turn any expression into a statement. In practical terms, Rust's\n-grammar expects statements to follow other statements. This means that you use\n-semicolons to separate expressions from each other. This means that Rust\n-looks a lot like most other languages that require you to use semicolons\n-at the end of every line, and you will see semicolons at the end of almost\n-every line of Rust code you see.\n-\n-What is this exception that makes us say \"almost\"? You saw it already, in this\n-code:\n-\n-```{rust}\n-let x = 5;\n-\n-let y: i32 = if x == 5 { 10 } else { 15 };\n-```\n-\n-Note that I've added the type annotation to `y`, to specify explicitly that I\n-want `y` to be an integer.\n-\n-This is not the same as this, which won't compile:\n-\n-```{ignore}\n-let x = 5;\n-\n-let y: i32 = if x == 5 { 10; } else { 15; };\n-```\n-\n-Note the semicolons after the 10 and 15. Rust will give us the following error:\n-\n-```text\n-error: mismatched types: expected `i32`, found `()` (expected i32, found ())\n-```\n-\n-We expected an integer, but we got `()`. `()` is pronounced *unit*, and is a\n-special type in Rust's type system. In Rust, `()` is _not_ a valid value for a\n-variable of type `i32`. It's only a valid value for variables of the type `()`,\n-which aren't very useful. Remember how we said statements don't return a value?\n-Well, that's the purpose of unit in this case. The semicolon turns any\n-expression into a statement by throwing away its value and returning unit\n-instead.\n-\n-There's one more time in which you won't see a semicolon at the end of a line\n-of Rust code. For that, we'll need our next concept: functions."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/inline-assembly.md", "status": "modified", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Finline-assembly.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Finline-assembly.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finline-assembly.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,141 +0,0 @@\n-% Inline Assembly\n-\n-For extremely low-level manipulations and performance reasons, one\n-might wish to control the CPU directly. Rust supports using inline\n-assembly to do this via the `asm!` macro. The syntax roughly matches\n-that of GCC & Clang:\n-\n-```ignore\n-asm!(assembly template\n-   : output operands\n-   : input operands\n-   : clobbers\n-   : options\n-   );\n-```\n-\n-Any use of `asm` is feature gated (requires `#![feature(asm)]` on the\n-crate to allow) and of course requires an `unsafe` block.\n-\n-> **Note**: the examples here are given in x86/x86-64 assembly, but\n-> all platforms are supported.\n-\n-## Assembly template\n-\n-The `assembly template` is the only required parameter and must be a\n-literal string (i.e. `\"\"`)\n-\n-```\n-#![feature(asm)]\n-\n-#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn foo() {\n-    unsafe {\n-        asm!(\"NOP\");\n-    }\n-}\n-\n-// other platforms\n-#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-fn foo() { /* ... */ }\n-\n-fn main() {\n-    // ...\n-    foo();\n-    // ...\n-}\n-```\n-\n-(The `feature(asm)` and `#[cfg]`s are omitted from now on.)\n-\n-Output operands, input operands, clobbers and options are all optional\n-but you must add the right number of `:` if you skip them:\n-\n-```\n-# #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-asm!(\"xor %eax, %eax\"\n-    :\n-    :\n-    : \"eax\"\n-   );\n-# } }\n-```\n-\n-Whitespace also doesn't matter:\n-\n-```\n-# #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-asm!(\"xor %eax, %eax\" ::: \"eax\");\n-# } }\n-```\n-\n-## Operands\n-\n-Input and output operands follow the same format: `:\n-\"constraints1\"(expr1), \"constraints2\"(expr2), ...\"`. Output operand\n-expressions must be mutable lvalues:\n-\n-```\n-# #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn add(a: i32, b: i32) -> i32 {\n-    let mut c = 0;\n-    unsafe {\n-        asm!(\"add $2, $0\"\n-             : \"=r\"(c)\n-             : \"0\"(a), \"r\"(b)\n-             );\n-    }\n-    c\n-}\n-# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn add(a: i32, b: i32) -> i32 { a + b }\n-\n-fn main() {\n-    assert_eq!(add(3, 14159), 14162)\n-}\n-```\n-\n-## Clobbers\n-\n-Some instructions modify registers which might otherwise have held\n-different values so we use the clobbers list to indicate to the\n-compiler not to assume any values loaded into those registers will\n-stay valid.\n-\n-```\n-# #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-// Put the value 0x200 in eax\n-asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"eax\");\n-# } }\n-```\n-\n-Input and output registers need not be listed since that information\n-is already communicated by the given constraints. Otherwise, any other\n-registers used either implicitly or explicitly should be listed.\n-\n-If the assembly changes the condition code register `cc` should be\n-specified as one of the clobbers. Similarly, if the assembly modifies\n-memory, `memory` should also be specified.\n-\n-## Options\n-\n-The last section, `options` is specific to Rust. The format is comma\n-separated literal strings (i.e. `:\"foo\", \"bar\", \"baz\"`). It's used to\n-specify some extra info about the inline assembly:\n-\n-Current valid options are:\n-\n-1. *volatile* - specifying this is analogous to\n-   `__asm__ __volatile__ (...)` in gcc/clang.\n-2. *alignstack* - certain instructions expect the stack to be\n-   aligned a certain way (i.e. SSE) and specifying this indicates to\n-   the compiler to insert its usual stack alignment code\n-3. *intel* - use intel syntax instead of the default AT&T.\n-"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/installing-rust.md", "status": "modified", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finstalling-rust.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,93 +0,0 @@\n-% Installing Rust\n-\n-The first step to using Rust is to install it! There are a number of ways to\n-install Rust, but the easiest is to use the `rustup` script. If you're on\n-Linux or a Mac, all you need to do is this (note that you don't need to type\n-in the `$`s, they just indicate the start of each command):\n-\n-```bash\n-$ curl -sf -L https://static.rust-lang.org/rustup.sh | sudo sh\n-```\n-\n-If you're concerned about the [potential insecurity](http://curlpipesh.tumblr.com/) of using `curl | sudo sh`,\n-please keep reading and see our disclaimer below. And feel free to use a two-step version of the installation and examine our installation script:\n-\n-```bash\n-$ curl -f -L https://static.rust-lang.org/rustup.sh -O\n-$ sudo sh rustup.sh\n-```\n-\n-If you're on Windows, please download either the [32-bit\n-installer](https://static.rust-lang.org/dist/rust-1.0.0-beta-i686-pc-windows-gnu.exe)\n-or the [64-bit\n-installer](https://static.rust-lang.org/dist/rust-1.0.0-beta-x86_64-pc-windows-gnu.exe)\n-and run it.\n-\n-If you decide you don't want Rust anymore, we'll be a bit sad, but that's okay.\n-Not every programming language is great for everyone. Just run the uninstall\n-script:\n-\n-```bash\n-$ sudo /usr/local/lib/rustlib/uninstall.sh\n-```\n-\n-If you used the Windows installer, just re-run the `.exe` and it will give you\n-an uninstall option.\n-\n-You can re-run this script any time you want to update Rust. Which, at this\n-point, is often. Rust is still pre-1.0, and so people assume that you're using\n-a very recent Rust.\n-\n-This brings me to one other point: some people, and somewhat rightfully so, get\n-very upset when we tell you to `curl | sudo sh`. And they should be! Basically,\n-when you do this, you are trusting that the good people who maintain Rust\n-aren't going to hack your computer and do bad things. That's a good instinct!\n-If you're one of those people, please check out the documentation on [building\n-Rust from Source](https://github.com/rust-lang/rust#building-from-source), or\n-[the official binary downloads](http://www.rust-lang.org/install.html). And we\n-promise that this method will not be the way to install Rust forever: it's just\n-the easiest way to keep people updated while Rust is in its alpha state.\n-\n-Oh, we should also mention the officially supported platforms:\n-\n-* Windows (7, 8, Server 2008 R2)\n-* Linux (2.6.18 or later, various distributions), x86 and x86-64\n-* OSX 10.7 (Lion) or greater, x86 and x86-64\n-\n-We extensively test Rust on these platforms, and a few others, too, like\n-Android. But these are the ones most likely to work, as they have the most\n-testing.\n-\n-Finally, a comment about Windows. Rust considers Windows to be a first-class\n-platform upon release, but if we're honest, the Windows experience isn't as\n-integrated as the Linux/OS X experience is. We're working on it! If anything\n-does not work, it is a bug. Please let us know if that happens. Each and every\n-commit is tested against Windows just like any other platform.\n-\n-If you've got Rust installed, you can open up a shell, and type this:\n-\n-```bash\n-$ rustc --version\n-```\n-\n-You should see the version number, commit hash, commit date and build date:\n-\n-```bash\n-rustc 1.0.0-nightly (f11f3e7ba 2015-01-04) (built 2015-01-06)\n-```\n-\n-If you did, Rust has been installed successfully! Congrats!\n-\n-This installer also installs a copy of the documentation locally, so you can\n-read it offline. On UNIX systems, `/usr/local/share/doc/rust` is the location.\n-On Windows, it's in a `share/doc` directory, inside wherever you installed Rust\n-to.\n-\n-If not, there are a number of places where you can get help. The easiest is\n-[the #rust IRC channel on irc.mozilla.org](irc://irc.mozilla.org/#rust), which\n-you can access through\n-[Mibbit](http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust). Click\n-that link, and you'll be chatting with other Rustaceans (a silly nickname we\n-call ourselves), and we can help you out. Other great resources include [the\n-/r/rust subreddit](http://www.reddit.com/r/rust), and [Stack\n-Overflow](http://stackoverflow.com/questions/tagged/rust)."}, {"sha": "73370a32231ebec4d452ed56f65343959ccf6891", "filename": "src/doc/trpl/intermediate.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fintermediate.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fintermediate.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fintermediate.md?ref=d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "patch": "@@ -1,7 +0,0 @@\n-% Intermediate\n-\n-This section contains individual chapters, which are self-contained. They focus\n-on specific topics, and can be read in any order.\n-\n-After reading \"Intermediate,\" you will have a solid understanding of Rust,\n-and will be able to understand most Rust code and write more complex programs."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/intrinsics.md", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fintrinsics.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fintrinsics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fintrinsics.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,25 +0,0 @@\n-% Intrinsics\n-\n-> **Note**: intrinsics will forever have an unstable interface, it is\n-> recommended to use the stable interfaces of libcore rather than intrinsics\n-> directly.\n-\n-These are imported as if they were FFI functions, with the special\n-`rust-intrinsic` ABI. For example, if one was in a freestanding\n-context, but wished to be able to `transmute` between types, and\n-perform efficient pointer arithmetic, one would import those functions\n-via a declaration like\n-\n-```\n-# #![feature(intrinsics)]\n-# fn main() {}\n-\n-extern \"rust-intrinsic\" {\n-    fn transmute<T, U>(x: T) -> U;\n-\n-    fn offset<T>(dst: *const T, offset: isize) -> *const T;\n-}\n-```\n-\n-As with any other FFI functions, these are always `unsafe` to call.\n-"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 0, "deletions": 349, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,349 +0,0 @@\n-% Iterators\n-\n-Let's talk about loops.\n-\n-Remember Rust's `for` loop? Here's an example:\n-\n-```rust\n-for x in 0..10 {\n-    println!(\"{}\", x);\n-}\n-```\n-\n-Now that you know more Rust, we can talk in detail about how this works.\n-Ranges (the `0..10`) are 'iterators'. An iterator is something that we can\n-call the `.next()` method on repeatedly, and it gives us a sequence of things.\n-\n-Like this:\n-\n-```rust\n-let mut range = 0..10;\n-\n-loop {\n-    match range.next() {\n-        Some(x) => {\n-            println!(\"{}\", x);\n-        },\n-        None => { break }\n-    }\n-}\n-```\n-\n-We make a mutable binding to the range, which is our iterator. We then `loop`,\n-with an inner `match`. This `match` is used on the result of `range.next()`,\n-which gives us a reference to the next value of the iterator. `next` returns an\n-`Option<i32>`, in this case, which will be `Some(i32)` when we have a value and\n-`None` once we run out. If we get `Some(i32)`, we print it out, and if we get\n-`None`, we `break` out of the loop.\n-\n-This code sample is basically the same as our `for` loop version. The `for`\n-loop is just a handy way to write this `loop`/`match`/`break` construct.\n-\n-`for` loops aren't the only thing that uses iterators, however. Writing your\n-own iterator involves implementing the `Iterator` trait. While doing that is\n-outside of the scope of this guide, Rust provides a number of useful iterators\n-to accomplish various tasks. Before we talk about those, we should talk about a\n-Rust anti-pattern. And that's using ranges like this.\n-\n-Yes, we just talked about how ranges are cool. But ranges are also very\n-primitive. For example, if you needed to iterate over the contents of a vector,\n-you may be tempted to write this:\n-\n-```rust\n-let nums = vec![1, 2, 3];\n-\n-for i in 0..nums.len() {\n-    println!(\"{}\", nums[i]);\n-}\n-```\n-\n-This is strictly worse than using an actual iterator. You can iterate over vectors\n-directly, so write this:\n-\n-```rust\n-let nums = vec![1, 2, 3];\n-\n-for num in &nums {\n-    println!(\"{}\", num);\n-}\n-```\n-\n-There are two reasons for this. First, this more directly expresses what we\n-mean. We iterate through the entire vector, rather than iterating through\n-indexes, and then indexing the vector. Second, this version is more efficient:\n-the first version will have extra bounds checking because it used indexing,\n-`nums[i]`. But since we yield a reference to each element of the vector in turn\n-with the iterator, there's no bounds checking in the second example. This is\n-very common with iterators: we can ignore unnecessary bounds checks, but still\n-know that we're safe.\n-\n-There's another detail here that's not 100% clear because of how `println!`\n-works. `num` is actually of type `&i32`. That is, it's a reference to an `i32`,\n-not an `i32` itself. `println!` handles the dereferencing for us, so we don't\n-see it. This code works fine too:\n-\n-```rust\n-let nums = vec![1, 2, 3];\n-\n-for num in &nums {\n-    println!(\"{}\", *num);\n-}\n-```\n-\n-Now we're explicitly dereferencing `num`. Why does `&nums` give us\n-references?  Firstly, because we explicitly asked it to with\n-`&`. Secondly, if it gave us the data itself, we would have to be its\n-owner, which would involve making a copy of the data and giving us the\n-copy. With references, we're just borrowing a reference to the data,\n-and so it's just passing a reference, without needing to do the move.\n-\n-So, now that we've established that ranges are often not what you want, let's\n-talk about what you do want instead.\n-\n-There are three broad classes of things that are relevant here: iterators,\n-*iterator adapters*, and *consumers*. Here's some definitions:\n-\n-* *iterators* give you a sequence of values.\n-* *iterator adapters* operate on an iterator, producing a new iterator with a\n-  different output sequence.\n-* *consumers* operate on an iterator, producing some final set of values.\n-\n-Let's talk about consumers first, since you've already seen an iterator, ranges.\n-\n-## Consumers\n-\n-A *consumer* operates on an iterator, returning some kind of value or values.\n-The most common consumer is `collect()`. This code doesn't quite compile,\n-but it shows the intention:\n-\n-```{rust,ignore}\n-let one_to_one_hundred = (1..101).collect();\n-```\n-\n-As you can see, we call `collect()` on our iterator. `collect()` takes\n-as many values as the iterator will give it, and returns a collection\n-of the results. So why won't this compile? Rust can't determine what\n-type of things you want to collect, and so you need to let it know.\n-Here's the version that does compile:\n-\n-```rust\n-let one_to_one_hundred = (1..101).collect::<Vec<i32>>();\n-```\n-\n-If you remember, the `::<>` syntax allows us to give a type hint,\n-and so we tell it that we want a vector of integers. You don't always\n-need to use the whole type, though. Using a `_` will let you provide\n-a partial hint:\n-\n-```rust\n-let one_to_one_hundred = (1..101).collect::<Vec<_>>();\n-```\n-\n-This says \"Collect into a `Vec<T>`, please, but infer what the `T` is for me.\"\n-`_` is sometimes called a \"type placeholder\" for this reason.\n-\n-`collect()` is the most common consumer, but there are others too. `find()`\n-is one:\n-\n-```rust\n-let greater_than_forty_two = (0..100)\n-                             .find(|x| *x > 42);\n-\n-match greater_than_forty_two {\n-    Some(_) => println!(\"We got some numbers!\"),\n-    None => println!(\"No numbers found :(\"),\n-}\n-```\n-\n-`find` takes a closure, and works on a reference to each element of an\n-iterator. This closure returns `true` if the element is the element we're\n-looking for, and `false` otherwise. Because we might not find a matching\n-element, `find` returns an `Option` rather than the element itself.\n-\n-Another important consumer is `fold`. Here's what it looks like:\n-\n-```rust\n-let sum = (1..4).fold(0, |sum, x| sum + x);\n-```\n-\n-`fold()` is a consumer that looks like this:\n-`fold(base, |accumulator, element| ...)`. It takes two arguments: the first\n-is an element called the *base*. The second is a closure that itself takes two\n-arguments: the first is called the *accumulator*, and the second is an\n-*element*. Upon each iteration, the closure is called, and the result is the\n-value of the accumulator on the next iteration. On the first iteration, the\n-base is the value of the accumulator.\n-\n-Okay, that's a bit confusing. Let's examine the values of all of these things\n-in this iterator:\n-\n-| base | accumulator | element | closure result |\n-|------|-------------|---------|----------------|\n-| 0    | 0           | 1       | 1              |\n-| 0    | 1           | 2       | 3              |\n-| 0    | 3           | 3       | 6              |\n-\n-We called `fold()` with these arguments:\n-\n-```rust\n-# (1..4)\n-.fold(0, |sum, x| sum + x);\n-```\n-\n-So, `0` is our base, `sum` is our accumulator, and `x` is our element.  On the\n-first iteration, we set `sum` to `0`, and `x` is the first element of `nums`,\n-`1`. We then add `sum` and `x`, which gives us `0 + 1 = 1`. On the second\n-iteration, that value becomes our accumulator, `sum`, and the element is\n-the second element of the array, `2`. `1 + 2 = 3`, and so that becomes\n-the value of the accumulator for the last iteration. On that iteration,\n-`x` is the last element, `3`, and `3 + 3 = 6`, which is our final\n-result for our sum. `1 + 2 + 3 = 6`, and that's the result we got.\n-\n-Whew. `fold` can be a bit strange the first few times you see it, but once it\n-clicks, you can use it all over the place. Any time you have a list of things,\n-and you want a single result, `fold` is appropriate.\n-\n-Consumers are important due to one additional property of iterators we haven't\n-talked about yet: laziness. Let's talk some more about iterators, and you'll\n-see why consumers matter.\n-\n-## Iterators\n-\n-As we've said before, an iterator is something that we can call the\n-`.next()` method on repeatedly, and it gives us a sequence of things.\n-Because you need to call the method, this means that iterators\n-are *lazy* and don't need to generate all of the values upfront.\n-This code, for example, does not actually generate the numbers\n-`1-100`, and just creates a value that represents the sequence:\n-\n-```rust\n-let nums = 1..100;\n-```\n-\n-Since we didn't do anything with the range, it didn't generate the sequence.\n-Let's add the consumer:\n-\n-```rust\n-let nums = (1..100).collect::<Vec<i32>>();\n-```\n-\n-Now, `collect()` will require that the range gives it some numbers, and so\n-it will do the work of generating the sequence.\n-\n-Ranges are one of two basic iterators that you'll see. The other is `iter()`.\n-`iter()` can turn a vector into a simple iterator that gives you each element\n-in turn:\n-\n-```rust\n-let nums = [1, 2, 3];\n-\n-for num in nums.iter() {\n-   println!(\"{}\", num);\n-}\n-```\n-\n-These two basic iterators should serve you well. There are some more\n-advanced iterators, including ones that are infinite. Like using range syntax\n-and `step_by`:\n-\n-```rust\n-# #![feature(step_by)]\n-(1..).step_by(5);\n-```\n-\n-This iterator counts up from one, adding five each time. It will give\n-you a new integer every time, forever (well, technically, until it reaches the\n-maximum number representable by an `i32`). But since iterators are lazy,\n-that's okay! You probably don't want to use `collect()` on it, though...\n-\n-That's enough about iterators. Iterator adapters are the last concept\n-we need to talk about with regards to iterators. Let's get to it!\n-\n-## Iterator adapters\n-\n-*Iterator adapters* take an iterator and modify it somehow, producing\n-a new iterator. The simplest one is called `map`:\n-\n-```{rust,ignore}\n-(1..100).map(|x| x + 1);\n-```\n-\n-`map` is called upon another iterator, and produces a new iterator where each\n-element reference has the closure it's been given as an argument called on it.\n-So this would give us the numbers from `2-100`. Well, almost! If you\n-compile the example, you'll get a warning:\n-\n-```text\n-warning: unused result which must be used: iterator adaptors are lazy and\n-         do nothing unless consumed, #[warn(unused_must_use)] on by default\n-(1..100).map(|x| x + 1);\n- ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-```\n-\n-Laziness strikes again! That closure will never execute. This example\n-doesn't print any numbers:\n-\n-```{rust,ignore}\n-(1..100).map(|x| println!(\"{}\", x));\n-```\n-\n-If you are trying to execute a closure on an iterator for its side effects,\n-just use `for` instead.\n-\n-There are tons of interesting iterator adapters. `take(n)` will return an\n-iterator over the next `n` elements of the original iterator. Note that this\n-has no side effect on the original iterator. Let's try it out with our infinite\n-iterator from before:\n-\n-```rust\n-# #![feature(step_by)]\n-for i in (1..).step_by(5).take(5) {\n-    println!(\"{}\", i);\n-}\n-```\n-\n-This will print\n-\n-```text\n-1\n-6\n-11\n-16\n-21\n-```\n-\n-`filter()` is an adapter that takes a closure as an argument. This closure\n-returns `true` or `false`. The new iterator `filter()` produces\n-only the elements that that closure returns `true` for:\n-\n-```rust\n-for i in (1..100).filter(|&x| x % 2 == 0) {\n-    println!(\"{}\", i);\n-}\n-```\n-\n-This will print all of the even numbers between one and a hundred.\n-(Note that because `filter` doesn't consume the elements that are\n-being iterated over, it is passed a reference to each element, and\n-thus the filter predicate uses the `&x` pattern to extract the integer\n-itself.)\n-\n-You can chain all three things together: start with an iterator, adapt it\n-a few times, and then consume the result. Check it out:\n-\n-```rust\n-(1..1000)\n-    .filter(|&x| x % 2 == 0)\n-    .filter(|&x| x % 3 == 0)\n-    .take(5)\n-    .collect::<Vec<i32>>();\n-```\n-\n-This will give you a vector containing `6`, `12`, `18`, `24`, and `30`.\n-\n-This is just a small taste of what iterators, iterator adapters, and consumers\n-can help you with. There are a number of really useful iterators, and you can\n-write your own as well. Iterators provide a safe, efficient way to manipulate\n-all kinds of lists. They're a little unusual at first, but if you play with\n-them, you'll get hooked. For a full list of the different iterators and\n-consumers, check out the [iterator module documentation](../std/iter/index.html)."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/lang-items.md", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flang-items.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,79 +0,0 @@\n-% Lang items\n-\n-> **Note**: lang items are often provided by crates in the Rust distribution,\n-> and lang items themselves have an unstable interface. It is recommended to use\n-> officially distributed crates instead of defining your own lang items.\n-\n-The `rustc` compiler has certain pluggable operations, that is,\n-functionality that isn't hard-coded into the language, but is\n-implemented in libraries, with a special marker to tell the compiler\n-it exists. The marker is the attribute `#[lang=\"...\"]` and there are\n-various different values of `...`, i.e. various different 'lang\n-items'.\n-\n-For example, `Box` pointers require two lang items, one for allocation\n-and one for deallocation. A freestanding program that uses the `Box`\n-sugar for dynamic allocations via `malloc` and `free`:\n-\n-```\n-#![feature(lang_items, box_syntax, start, no_std, libc)]\n-#![no_std]\n-\n-extern crate libc;\n-\n-extern {\n-    fn abort() -> !;\n-}\n-\n-#[lang = \"owned_box\"]\n-pub struct Box<T>(*mut T);\n-\n-#[lang=\"exchange_malloc\"]\n-unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n-    let p = libc::malloc(size as libc::size_t) as *mut u8;\n-\n-    // malloc failed\n-    if p as usize == 0 {\n-        abort();\n-    }\n-\n-    p\n-}\n-#[lang=\"exchange_free\"]\n-unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {\n-    libc::free(ptr as *mut libc::c_void)\n-}\n-\n-#[start]\n-fn main(argc: isize, argv: *const *const u8) -> isize {\n-    let x = box 1;\n-\n-    0\n-}\n-\n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-```\n-\n-Note the use of `abort`: the `exchange_malloc` lang item is assumed to\n-return a valid pointer, and so needs to do the check internally.\n-\n-Other features provided by lang items include:\n-\n-- overloadable operators via traits: the traits corresponding to the\n-  `==`, `<`, dereferencing (`*`) and `+` (etc.) operators are all\n-  marked with lang items; those specific four are `eq`, `ord`,\n-  `deref`, and `add` respectively.\n-- stack unwinding and general failure; the `eh_personality`, `fail`\n-  and `fail_bounds_checks` lang items.\n-- the traits in `std::marker` used to indicate types of\n-  various kinds; lang items `send`, `sync` and `copy`.\n-- the marker types and variance indicators found in\n-  `std::marker`; lang items `covariant_type`,\n-  `contravariant_lifetime`, etc.\n-\n-Lang items are loaded lazily by the compiler; e.g. if one never uses\n-`Box` then there is no need to define functions for `exchange_malloc`\n-and `exchange_free`. `rustc` will emit an error when an item is needed\n-but not found in the current crate or any that it depends on."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/learn-rust.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Flearn-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Flearn-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flearn-rust.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/lifetimes.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flifetimes.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/link-args.md", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Flink-args.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Flink-args.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flink-args.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,25 +0,0 @@\n-% Link args\n-\n-There is one other way to tell rustc how to customize linking, and that is via\n-the `link_args` attribute. This attribute is applied to `extern` blocks and\n-specifies raw flags which need to get passed to the linker when producing an\n-artifact. An example usage would be:\n-\n-``` no_run\n-#![feature(link_args)]\n-\n-#[link_args = \"-foo -bar -baz\"]\n-extern {}\n-# fn main() {}\n-```\n-\n-Note that this feature is currently hidden behind the `feature(link_args)` gate\n-because this is not a sanctioned way of performing linking. Right now rustc\n-shells out to the system linker, so it makes sense to provide extra command line\n-arguments, but this will not always be the case. In the future rustc may use\n-LLVM directly to link native libraries in which case `link_args` will have no\n-meaning.\n-\n-It is highly recommended to *not* use this attribute, and rather use the more\n-formal `#[link(...)]` attribute on `extern` blocks instead.\n-"}, {"sha": "ea7600113641bcd896ba2f339ee9ff7a78fbac19", "filename": "src/doc/trpl/lol.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Flol.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Flol.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flol.txt?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -0,0 +1 @@\n+getting-started.md installing-rust.md hello-world.md hello-cargo.md learn-rust.md effective-rust.md the-stack-and-the-heap.md debug-and-display.md testing.md documentation.md iterators.md concurrency.md error-handling.md ffi.md deref-coercions.md syntax-and-semantics.md variable-bindings.md primitive-types.md functions.md comments.md structs.md mutability.md method-syntax.md enums.md if.md match.md patterns.md for-loops.md while-loops.md ownership.md references-and-borrowing.md lifetimes.md move-semantics.md drop.md vectors.md arrays.md slices.md strings.md traits.md operators-and-overloading.md generics.md trait-objects.md closures.md ufcs.md crates-and-modules.md static.md const.md tuples.md tuple-structs.md attributes.md conditional-compilation.md type-aliases.md casting-between-types.md associated-types.md unsized-types.md macros.md unsafe-code.md nightly-rust.md plugins.md inline-assembly.md no-stdlib.md intrinsics.md lang-items.md link-args.md benchmark-tests.md box-syntax-and-patterns.md glossary.md"}, {"sha": "28f02b1ffe1528239ba2ba798a12dad126dde496", "filename": "src/doc/trpl/looping.md", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Flooping.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Flooping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flooping.md?ref=d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "patch": "@@ -1,133 +0,0 @@\n-% Looping\n-\n-Looping is the last basic construct that we haven't learned yet in Rust. Rust has\n-two main looping constructs: `for` and `while`.\n-\n-## `for`\n-\n-The `for` loop is used to loop a particular number of times. Rust's `for` loops\n-work a bit differently than in other systems languages, however. Rust's `for`\n-loop doesn't look like this \"C-style\" `for` loop:\n-\n-```{c}\n-for (x = 0; x < 10; x++) {\n-    printf( \"%d\\n\", x );\n-}\n-```\n-\n-Instead, it looks like this:\n-\n-```{rust}\n-for x in 0..10 {\n-    println!(\"{}\", x); // x: i32\n-}\n-```\n-\n-In slightly more abstract terms,\n-\n-```{ignore}\n-for var in expression {\n-    code\n-}\n-```\n-\n-The expression is an iterator, which we will discuss in more depth later in the\n-guide. The iterator gives back a series of elements. Each element is one\n-iteration of the loop. That value is then bound to the name `var`, which is\n-valid for the loop body. Once the body is over, the next value is fetched from\n-the iterator, and we loop another time. When there are no more values, the\n-`for` loop is over.\n-\n-In our example, `0..10` is an expression that takes a start and an end position,\n-and gives an iterator over those values. The upper bound is exclusive, though,\n-so our loop will print `0` through `9`, not `10`.\n-\n-Rust does not have the \"C-style\" `for` loop on purpose. Manually controlling\n-each element of the loop is complicated and error prone, even for experienced C\n-developers.\n-\n-We'll talk more about `for` when we cover *iterators*, later in the Guide.\n-\n-## `while`\n-\n-The other kind of looping construct in Rust is the `while` loop. It looks like\n-this:\n-\n-```{rust}\n-let mut x = 5; // mut x: u32\n-let mut done = false; // mut done: bool\n-\n-while !done {\n-    x += x - 3;\n-    println!(\"{}\", x);\n-    if x % 5 == 0 { done = true; }\n-}\n-```\n-\n-`while` loops are the correct choice when you're not sure how many times\n-you need to loop.\n-\n-If you need an infinite loop, you may be tempted to write this:\n-\n-```{rust,ignore}\n-while true {\n-```\n-\n-However, Rust has a dedicated keyword, `loop`, to handle this case:\n-\n-```{rust,ignore}\n-loop {\n-```\n-\n-Rust's control-flow analysis treats this construct differently than a\n-`while true`, since we know that it will always loop. The details of what\n-that _means_ aren't super important to understand at this stage, but in\n-general, the more information we can give to the compiler, the better it\n-can do with safety and code generation, so you should always prefer\n-`loop` when you plan to loop infinitely.\n-\n-## Ending iteration early\n-\n-Let's take a look at that `while` loop we had earlier:\n-\n-```{rust}\n-let mut x = 5;\n-let mut done = false;\n-\n-while !done {\n-    x += x - 3;\n-    println!(\"{}\", x);\n-    if x % 5 == 0 { done = true; }\n-}\n-```\n-\n-We had to keep a dedicated `mut` boolean variable binding, `done`, to know\n-when we should exit out of the loop. Rust has two keywords to help us with\n-modifying iteration: `break` and `continue`.\n-\n-In this case, we can write the loop in a better way with `break`:\n-\n-```{rust}\n-let mut x = 5;\n-\n-loop {\n-    x += x - 3;\n-    println!(\"{}\", x);\n-    if x % 5 == 0 { break; }\n-}\n-```\n-\n-We now loop forever with `loop` and use `break` to break out early.\n-\n-`continue` is similar, but instead of ending the loop, goes to the next\n-iteration. This will only print the odd numbers:\n-\n-```{rust}\n-for x in 0..10 {\n-    if x % 2 == 0 { continue; }\n-\n-    println!(\"{}\", x);\n-}\n-```\n-\n-Both `continue` and `break` are valid in both kinds of loops."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 0, "deletions": 432, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,432 +0,0 @@\n-% Macros\n-\n-By now you've learned about many of the tools Rust provides for abstracting and\n-reusing code. These units of code reuse have a rich semantic structure. For\n-example, functions have a type signature, type parameters have trait bounds,\n-and overloaded functions must belong to a particular trait.\n-\n-This structure means that Rust's core abstractions have powerful compile-time\n-correctness checking. But this comes at the price of reduced flexibility. If\n-you visually identify a pattern of repeated code, you may find it's difficult\n-or cumbersome to express that pattern as a generic function, a trait, or\n-anything else within Rust's semantics.\n-\n-Macros allow us to abstract at a *syntactic* level. A macro invocation is\n-shorthand for an \"expanded\" syntactic form. This expansion happens early in\n-compilation, before any static checking. As a result, macros can capture many\n-patterns of code reuse that Rust's core abstractions cannot.\n-\n-The drawback is that macro-based code can be harder to understand, because\n-fewer of the built-in rules apply. Like an ordinary function, a well-behaved\n-macro can be used without understanding its implementation. However, it can be\n-difficult to design a well-behaved macro!  Additionally, compiler errors in\n-macro code are harder to interpret, because they describe problems in the\n-expanded code, not the source-level form that developers use.\n-\n-These drawbacks make macros something of a \"feature of last resort\". That's not\n-to say that macros are bad; they are part of Rust because sometimes they're\n-needed for truly concise, well-abstracted code. Just keep this tradeoff in\n-mind.\n-\n-# Defining a macro\n-\n-You may have seen the `vec!` macro, used to initialize a [vector][] with any\n-number of elements.\n-\n-[vector]: arrays-vectors-and-slices.html\n-\n-```rust\n-let x: Vec<u32> = vec![1, 2, 3];\n-# assert_eq!(x, [1, 2, 3]);\n-```\n-\n-This can't be an ordinary function, because it takes any number of arguments.\n-But we can imagine it as syntactic shorthand for\n-\n-```rust\n-let x: Vec<u32> = {\n-    let mut temp_vec = Vec::new();\n-    temp_vec.push(1);\n-    temp_vec.push(2);\n-    temp_vec.push(3);\n-    temp_vec\n-};\n-# assert_eq!(x, [1, 2, 3]);\n-```\n-\n-We can implement this shorthand, using a macro: [^actual]\n-\n-[^actual]: The actual definition of `vec!` in libcollections differs from the\n-           one presented here, for reasons of efficiency and reusability. Some\n-           of these are mentioned in the [advanced macros chapter][].\n-\n-```rust\n-macro_rules! vec {\n-    ( $( $x:expr ),* ) => {\n-        {\n-            let mut temp_vec = Vec::new();\n-            $(\n-                temp_vec.push($x);\n-            )*\n-            temp_vec\n-        }\n-    };\n-}\n-# fn main() {\n-#     assert_eq!(vec![1,2,3], [1, 2, 3]);\n-# }\n-```\n-\n-Whoa, that's a lot of new syntax! Let's break it down.\n-\n-```ignore\n-macro_rules! vec { ... }\n-```\n-\n-This says we're defining a macro named `vec`, much as `fn vec` would define a\n-function named `vec`. In prose, we informally write a macro's name with an\n-exclamation point, e.g. `vec!`. The exclamation point is part of the invocation\n-syntax and serves to distinguish a macro from an ordinary function.\n-\n-## Matching\n-\n-The macro is defined through a series of *rules*, which are pattern-matching\n-cases. Above, we had\n-\n-```ignore\n-( $( $x:expr ),* ) => { ... };\n-```\n-\n-This is like a `match` expression arm, but the matching happens on Rust syntax\n-trees, at compile time. The semicolon is optional on the last (here, only)\n-case. The \"pattern\" on the left-hand side of `=>` is known as a *matcher*.\n-These have [their own little grammar] within the language.\n-\n-[their own little grammar]: ../reference.html#macros\n-\n-The matcher `$x:expr` will match any Rust expression, binding that syntax tree\n-to the *metavariable* `$x`. The identifier `expr` is a *fragment specifier*;\n-the full possibilities are enumerated in the [advanced macros chapter][].\n-Surrounding the matcher with `$(...),*` will match zero or more expressions,\n-separated by commas.\n-\n-Aside from the special matcher syntax, any Rust tokens that appear in a matcher\n-must match exactly. For example,\n-\n-```rust\n-macro_rules! foo {\n-    (x => $e:expr) => (println!(\"mode X: {}\", $e));\n-    (y => $e:expr) => (println!(\"mode Y: {}\", $e));\n-}\n-\n-fn main() {\n-    foo!(y => 3);\n-}\n-```\n-\n-will print\n-\n-```text\n-mode Y: 3\n-```\n-\n-With\n-\n-```rust,ignore\n-foo!(z => 3);\n-```\n-\n-we get the compiler error\n-\n-```text\n-error: no rules expected the token `z`\n-```\n-\n-## Expansion\n-\n-The right-hand side of a macro rule is ordinary Rust syntax, for the most part.\n-But we can splice in bits of syntax captured by the matcher. From the original\n-example:\n-\n-```ignore\n-$(\n-    temp_vec.push($x);\n-)*\n-```\n-\n-Each matched expression `$x` will produce a single `push` statement in the\n-macro expansion. The repetition in the expansion proceeds in \"lockstep\" with\n-repetition in the matcher (more on this in a moment).\n-\n-Because `$x` was already declared as matching an expression, we don't repeat\n-`:expr` on the right-hand side. Also, we don't include a separating comma as\n-part of the repetition operator. Instead, we have a terminating semicolon\n-within the repeated block.\n-\n-Another detail: the `vec!` macro has *two* pairs of braces on the right-hand\n-side. They are often combined like so:\n-\n-```ignore\n-macro_rules! foo {\n-    () => {{\n-        ...\n-    }}\n-}\n-```\n-\n-The outer braces are part of the syntax of `macro_rules!`. In fact, you can use\n-`()` or `[]` instead. They simply delimit the right-hand side as a whole.\n-\n-The inner braces are part of the expanded syntax. Remember, the `vec!` macro is\n-used in an expression context. To write an expression with multiple statements,\n-including `let`-bindings, we use a block. If your macro expands to a single\n-expression, you don't need this extra layer of braces.\n-\n-Note that we never *declared* that the macro produces an expression. In fact,\n-this is not determined until we use the macro as an expression. With care, you\n-can write a macro whose expansion works in several contexts. For example,\n-shorthand for a data type could be valid as either an expression or a pattern.\n-\n-## Repetition\n-\n-The repetition operator follows two principal rules:\n-\n-1. `$(...)*` walks through one \"layer\" of repetitions, for all of the `$name`s\n-   it contains, in lockstep, and\n-2. each `$name` must be under at least as many `$(...)*`s as it was matched\n-   against. If it is under more, it'll be duplicated, as appropriate.\n-\n-This baroque macro illustrates the duplication of variables from outer\n-repetition levels.\n-\n-```rust\n-macro_rules! o_O {\n-    (\n-        $(\n-            $x:expr; [ $( $y:expr ),* ]\n-        );*\n-    ) => {\n-        &[ $($( $x + $y ),*),* ]\n-    }\n-}\n-\n-fn main() {\n-    let a: &[i32]\n-        = o_O!(10; [1, 2, 3];\n-               20; [4, 5, 6]);\n-\n-    assert_eq!(a, [11, 12, 13, 24, 25, 26]);\n-}\n-```\n-\n-That's most of the matcher syntax. These examples use `$(...)*`, which is a\n-\"zero or more\" match. Alternatively you can write `$(...)+` for a \"one or\n-more\" match. Both forms optionally include a separator, which can be any token\n-except `+` or `*`.\n-\n-This system is based on\n-\"[Macro-by-Example](http://www.cs.indiana.edu/ftp/techreports/TR206.pdf)\"\n-(PDF link).\n-\n-# Hygiene\n-\n-Some languages implement macros using simple text substitution, which leads to\n-various problems. For example, this C program prints `13` instead of the\n-expected `25`.\n-\n-```text\n-#define FIVE_TIMES(x) 5 * x\n-\n-int main() {\n-    printf(\"%d\\n\", FIVE_TIMES(2 + 3));\n-    return 0;\n-}\n-```\n-\n-After expansion we have `5 * 2 + 3`, and multiplication has greater precedence\n-than addition. If you've used C macros a lot, you probably know the standard\n-idioms for avoiding this problem, as well as five or six others. In Rust, we\n-don't have to worry about it.\n-\n-```rust\n-macro_rules! five_times {\n-    ($x:expr) => (5 * $x);\n-}\n-\n-fn main() {\n-    assert_eq!(25, five_times!(2 + 3));\n-}\n-```\n-\n-The metavariable `$x` is parsed as a single expression node, and keeps its\n-place in the syntax tree even after substitution.\n-\n-Another common problem in macro systems is *variable capture*. Here's a C\n-macro, using [a GNU C extension] to emulate Rust's expression blocks.\n-\n-[a GNU C extension]: https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html\n-\n-```text\n-#define LOG(msg) ({ \\\n-    int state = get_log_state(); \\\n-    if (state > 0) { \\\n-        printf(\"log(%d): %s\\n\", state, msg); \\\n-    } \\\n-})\n-```\n-\n-Here's a simple use case that goes terribly wrong:\n-\n-```text\n-const char *state = \"reticulating splines\";\n-LOG(state)\n-```\n-\n-This expands to\n-\n-```text\n-const char *state = \"reticulating splines\";\n-int state = get_log_state();\n-if (state > 0) {\n-    printf(\"log(%d): %s\\n\", state, state);\n-}\n-```\n-\n-The second variable named `state` shadows the first one.  This is a problem\n-because the print statement should refer to both of them.\n-\n-The equivalent Rust macro has the desired behavior.\n-\n-```rust\n-# fn get_log_state() -> i32 { 3 }\n-macro_rules! log {\n-    ($msg:expr) => {{\n-        let state: i32 = get_log_state();\n-        if state > 0 {\n-            println!(\"log({}): {}\", state, $msg);\n-        }\n-    }};\n-}\n-\n-fn main() {\n-    let state: &str = \"reticulating splines\";\n-    log!(state);\n-}\n-```\n-\n-This works because Rust has a [hygienic macro system][]. Each macro expansion\n-happens in a distinct *syntax context*, and each variable is tagged with the\n-syntax context where it was introduced. It's as though the variable `state`\n-inside `main` is painted a different \"color\" from the variable `state` inside\n-the macro, and therefore they don't conflict.\n-\n-[hygienic macro system]: http://en.wikipedia.org/wiki/Hygienic_macro\n-\n-This also restricts the ability of macros to introduce new bindings at the\n-invocation site. Code such as the following will not work:\n-\n-```rust,ignore\n-macro_rules! foo {\n-    () => (let x = 3);\n-}\n-\n-fn main() {\n-    foo!();\n-    println!(\"{}\", x);\n-}\n-```\n-\n-Instead you need to pass the variable name into the invocation, so it's tagged\n-with the right syntax context.\n-\n-```rust\n-macro_rules! foo {\n-    ($v:ident) => (let $v = 3);\n-}\n-\n-fn main() {\n-    foo!(x);\n-    println!(\"{}\", x);\n-}\n-```\n-\n-This holds for `let` bindings and loop labels, but not for [items][].\n-So the following code does compile:\n-\n-```rust\n-macro_rules! foo {\n-    () => (fn x() { });\n-}\n-\n-fn main() {\n-    foo!();\n-    x();\n-}\n-```\n-\n-[items]: ../reference.html#items\n-\n-# Recursive macros\n-\n-A macro's expansion can include more macro invocations, including invocations\n-of the very same macro being expanded.  These recursive macros are useful for\n-processing tree-structured input, as illustrated by this (simplistic) HTML\n-shorthand:\n-\n-```rust\n-# #![allow(unused_must_use)]\n-macro_rules! write_html {\n-    ($w:expr, ) => (());\n-\n-    ($w:expr, $e:tt) => (write!($w, \"{}\", $e));\n-\n-    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) => {{\n-        write!($w, \"<{}>\", stringify!($tag));\n-        write_html!($w, $($inner)*);\n-        write!($w, \"</{}>\", stringify!($tag));\n-        write_html!($w, $($rest)*);\n-    }};\n-}\n-\n-fn main() {\n-#   // FIXME(#21826)\n-    use std::fmt::Write;\n-    let mut out = String::new();\n-\n-    write_html!(&mut out,\n-        html[\n-            head[title[\"Macros guide\"]]\n-            body[h1[\"Macros are the best!\"]]\n-        ]);\n-\n-    assert_eq!(out,\n-        \"<html><head><title>Macros guide</title></head>\\\n-         <body><h1>Macros are the best!</h1></body></html>\");\n-}\n-```\n-\n-# Debugging macro code\n-\n-To see the results of expanding macros, run `rustc --pretty expanded`. The\n-output represents a whole crate, so you can also feed it back in to `rustc`,\n-which will sometimes produce better error messages than the original\n-compilation. Note that the `--pretty expanded` output may have a different\n-meaning if multiple variables of the same name (but different syntax contexts)\n-are in play in the same scope. In this case `--pretty expanded,hygiene` will\n-tell you about the syntax contexts.\n-\n-`rustc` provides two syntax extensions that help with macro debugging. For now,\n-they are unstable and require feature gates.\n-\n-* `log_syntax!(...)` will print its arguments to standard output, at compile\n-  time, and \"expand\" to nothing.\n-\n-* `trace_macros!(true)` will enable a compiler message every time a macro is\n-  expanded. Use `trace_macros!(false)` later in expansion to turn it off.\n-\n-# Further reading\n-\n-The [advanced macros chapter][] goes into more detail about macro syntax. It\n-also describes how to share macros between different modules or crates.\n-\n-[advanced macros chapter]: advanced-macros.html"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/match.md", "status": "modified", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmatch.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,156 +0,0 @@\n-% Match\n-\n-Often, a simple `if`/`else` isn't enough, because you have more than two\n-possible options. Also, `else` conditions can get incredibly complicated, so\n-what's the solution?\n-\n-Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`\n-groupings with something more powerful. Check it out:\n-\n-```{rust}\n-let x = 5;\n-\n-match x {\n-    1 => println!(\"one\"),\n-    2 => println!(\"two\"),\n-    3 => println!(\"three\"),\n-    4 => println!(\"four\"),\n-    5 => println!(\"five\"),\n-    _ => println!(\"something else\"),\n-}\n-```\n-\n-`match` takes an expression and then branches based on its value. Each *arm* of\n-the branch is of the form `val => expression`. When the value matches, that arm's\n-expression will be evaluated. It's called `match` because of the term 'pattern\n-matching', which `match` is an implementation of.\n-\n-So what's the big advantage here? Well, there are a few. First of all, `match`\n-enforces *exhaustiveness checking*. Do you see that last arm, the one with the\n-underscore (`_`)? If we remove that arm, Rust will give us an error:\n-\n-```text\n-error: non-exhaustive patterns: `_` not covered\n-```\n-\n-In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n-integer, Rust knows that it can have a number of different values \u2013 for example,\n-`6`. Without the `_`, however, there is no arm that could match, and so Rust refuses\n-to compile. `_` acts like a *catch-all arm*. If none of the other arms match,\n-the arm with `_` will, and since we have this catch-all arm, we now have an arm\n-for every possible value of `x`, and so our program will compile successfully.\n-\n-`match` statements also destructure enums, as well. Remember this code from the\n-section on enums?\n-\n-```{rust}\n-use std::cmp::Ordering;\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    let ordering = cmp(x, y);\n-\n-    if ordering == Ordering::Less {\n-        println!(\"less\");\n-    } else if ordering == Ordering::Greater {\n-        println!(\"greater\");\n-    } else if ordering == Ordering::Equal {\n-        println!(\"equal\");\n-    }\n-}\n-```\n-\n-We can re-write this as a `match`:\n-\n-```{rust}\n-use std::cmp::Ordering;\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    match cmp(x, y) {\n-        Ordering::Less => println!(\"less\"),\n-        Ordering::Greater => println!(\"greater\"),\n-        Ordering::Equal => println!(\"equal\"),\n-    }\n-}\n-```\n-\n-This version has way less noise, and it also checks exhaustively to make sure\n-that we have covered all possible variants of `Ordering`. With our `if`/`else`\n-version, if we had forgotten the `Greater` case, for example, our program would\n-have happily compiled. If we forget in the `match`, it will not. Rust helps us\n-make sure to cover all of our bases.\n-\n-`match` expressions also allow us to get the values contained in an `enum`\n-(also known as destructuring) as follows:\n-\n-```{rust}\n-enum OptionalInt {\n-    Value(i32),\n-    Missing,\n-}\n-\n-fn main() {\n-    let x = OptionalInt::Value(5);\n-    let y = OptionalInt::Missing;\n-\n-    match x {\n-        OptionalInt::Value(n) => println!(\"x is {}\", n),\n-        OptionalInt::Missing => println!(\"x is missing!\"),\n-    }\n-\n-    match y {\n-        OptionalInt::Value(n) => println!(\"y is {}\", n),\n-        OptionalInt::Missing => println!(\"y is missing!\"),\n-    }\n-}\n-```\n-\n-That is how you can get and use the values contained in `enum`s.\n-It can also allow us to handle errors or unexpected computations; for example, a\n-function that is not guaranteed to be able to compute a result (an `i32` here)\n-could return an `OptionalInt`, and we would handle that value with a `match`.\n-As you can see, `enum` and `match` used together are quite useful!\n-\n-`match` is also an expression, which means we can use it on the right-hand\n-side of a `let` binding or directly where an expression is used. We could\n-also implement the previous example like this:\n-\n-```{rust}\n-use std::cmp::Ordering;\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    println!(\"{}\", match cmp(x, y) {\n-        Ordering::Less => \"less\",\n-        Ordering::Greater => \"greater\",\n-        Ordering::Equal => \"equal\",\n-    });\n-}\n-```\n-\n-Sometimes, it's a nice pattern."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 0, "deletions": 232, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,232 +0,0 @@\n-% Method Syntax\n-\n-Functions are great, but if you want to call a bunch of them on some data, it\n-can be awkward. Consider this code:\n-\n-```{rust,ignore}\n-baz(bar(foo(x)));\n-```\n-\n-We would read this left-to right, and so we see \"baz bar foo.\" But this isn't the\n-order that the functions would get called in, that's inside-out: \"foo bar baz.\"\n-Wouldn't it be nice if we could do this instead?\n-\n-```{rust,ignore}\n-x.foo().bar().baz();\n-```\n-\n-Luckily, as you may have guessed with the leading question, you can! Rust provides\n-the ability to use this *method call syntax* via the `impl` keyword.\n-\n-## Method calls\n-\n-Here's how it works:\n-\n-```{rust}\n-# #![feature(core)]\n-struct Circle {\n-    x: f64,\n-    y: f64,\n-    radius: f64,\n-}\n-\n-impl Circle {\n-    fn area(&self) -> f64 {\n-        std::f64::consts::PI * (self.radius * self.radius)\n-    }\n-}\n-\n-fn main() {\n-    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };\n-    println!(\"{}\", c.area());\n-}\n-```\n-\n-This will print `12.566371`.\n-\n-We've made a struct that represents a circle. We then write an `impl` block,\n-and inside it, define a method, `area`. Methods take a  special first\n-parameter, of which there are three variants: `self`, `&self`, and `&mut self`.\n-You can think of this first parameter as being the `x` in `x.foo()`. The three\n-variants correspond to the three kinds of thing `x` could be: `self` if it's\n-just a value on the stack, `&self` if it's a reference, and `&mut self` if it's\n-a mutable reference. We should default to using `&self`, as you should prefer\n-borrowing over taking ownership, as well as taking immutable references\n-over mutable ones. Here's an example of all three variants:\n-\n-```rust\n-struct Circle {\n-    x: f64,\n-    y: f64,\n-    radius: f64,\n-}\n-\n-impl Circle {\n-    fn reference(&self) {\n-       println!(\"taking self by reference!\");\n-    }\n-\n-    fn mutable_reference(&mut self) {\n-       println!(\"taking self by mutable reference!\");\n-    }\n-\n-    fn takes_ownership(self) {\n-       println!(\"taking ownership of self!\");\n-    }\n-}\n-```\n-\n-Finally, as you may remember, the value of the area of a circle is `\u03c0*r\u00b2`.\n-Because we took the `&self` parameter to `area`, we can use it just like any\n-other parameter. Because we know it's a `Circle`, we can access the `radius`\n-just like we would with any other struct. An import of \u03c0 and some\n-multiplications later, and we have our area.\n-\n-## Chaining method calls\n-\n-So, now we know how to call a method, such as `foo.bar()`. But what about our\n-original example, `foo.bar().baz()`? This is called 'method chaining', and we\n-can do it by returning `self`.\n-\n-```\n-# #![feature(core)]\n-struct Circle {\n-    x: f64,\n-    y: f64,\n-    radius: f64,\n-}\n-\n-impl Circle {\n-    fn area(&self) -> f64 {\n-        std::f64::consts::PI * (self.radius * self.radius)\n-    }\n-\n-    fn grow(&self, increment: f64) -> Circle {\n-        Circle { x: self.x, y: self.y, radius: self.radius + increment }\n-    }\n-}\n-\n-fn main() {\n-    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };\n-    println!(\"{}\", c.area());\n-\n-    let d = c.grow(2.0).area();\n-    println!(\"{}\", d);\n-}\n-```\n-\n-Check the return type:\n-\n-```\n-# struct Circle;\n-# impl Circle {\n-fn grow(&self) -> Circle {\n-# Circle } }\n-```\n-\n-We just say we're returning a `Circle`. With this method, we can grow a new\n-circle to any arbitrary size.\n-\n-## Static methods\n-\n-You can also define methods that do not take a `self` parameter. Here's a\n-pattern that's very common in Rust code:\n-\n-```\n-struct Circle {\n-    x: f64,\n-    y: f64,\n-    radius: f64,\n-}\n-\n-impl Circle {\n-    fn new(x: f64, y: f64, radius: f64) -> Circle {\n-        Circle {\n-            x: x,\n-            y: y,\n-            radius: radius,\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let c = Circle::new(0.0, 0.0, 2.0);\n-}\n-```\n-\n-This *static method* builds a new `Circle` for us. Note that static methods\n-are called with the `Struct::method()` syntax, rather than the `ref.method()`\n-syntax.\n-\n-## Builder Pattern\n-\n-Let's say that we want our users to be able to create Circles, but we will\n-allow them to only set the properties they care about. Otherwise, the `x`\n-and `y` attributes will be `0.0`, and the `radius` will be `1.0`. Rust doesn't\n-have method overloading, named arguments, or variable arguments. We employ\n-the builder pattern instead. It looks like this:\n-\n-```\n-# #![feature(core)]\n-struct Circle {\n-    x: f64,\n-    y: f64,\n-    radius: f64,\n-}\n-\n-impl Circle {\n-    fn area(&self) -> f64 {\n-        std::f64::consts::PI * (self.radius * self.radius)\n-    }\n-}\n-\n-struct CircleBuilder {\n-    x: f64,\n-    y: f64,\n-    radius: f64,\n-}\n-\n-impl CircleBuilder {\n-    fn new() -> CircleBuilder {\n-        CircleBuilder { x: 0.0, y: 0.0, radius: 0.0, }\n-    }\n-\n-    fn x(&mut self, coordinate: f64) -> &mut CircleBuilder {\n-        self.x = coordinate;\n-        self\n-    }\n-\n-    fn y(&mut self, coordinate: f64) -> &mut CircleBuilder {\n-        self.y = coordinate;\n-        self\n-    }\n-\n-    fn radius(&mut self, radius: f64) -> &mut CircleBuilder {\n-        self.radius = radius;\n-        self\n-    }\n-\n-    fn finalize(&self) -> Circle {\n-        Circle { x: self.x, y: self.y, radius: self.radius }\n-    }\n-}\n-\n-fn main() {\n-    let c = CircleBuilder::new()\n-                .x(1.0)\n-                .y(2.0)\n-                .radius(2.0)\n-                .finalize();\n-\n-    println!(\"area: {}\", c.area());\n-    println!(\"x: {}\", c.x);\n-    println!(\"y: {}\", c.y);\n-}\n-```\n-\n-What we've done here is make another struct, `CircleBuilder`. We've defined our\n-builder methods on it. We've also defined our `area()` method on `Circle`. We\n-also made one more method on `CircleBuilder`: `finalize()`. This method creates\n-our final `Circle` from the builder. Now, we've used the type system to enforce\n-our concerns: we can use the methods on `CircleBuilder` to constrain making\n-`Circle`s in any way we choose."}, {"sha": "17a463842e71c39fa24c4d9935667a6362b47229", "filename": "src/doc/trpl/more-strings.md", "status": "removed", "additions": 0, "deletions": 325, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmore-strings.md?ref=d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "patch": "@@ -1,325 +0,0 @@\n-% More Strings\n-\n-Strings are an important concept to master in any programming language. If you\n-come from a managed language background, you may be surprised at the complexity\n-of string handling in a systems programming language. Efficient access and\n-allocation of memory for a dynamically sized structure involves a lot of\n-details. Luckily, Rust has lots of tools to help us here.\n-\n-A **string** is a sequence of unicode scalar values encoded as a stream of\n-UTF-8 bytes. All strings are guaranteed to be validly-encoded UTF-8 sequences.\n-Additionally, strings are not null-terminated and can contain null bytes.\n-\n-Rust has two main types of strings: `&str` and `String`.\n-\n-# `&str`\n-\n-The first kind is a `&str`. This is pronounced a 'string slice'.\n-String literals are of the type `&str`:\n-\n-```\n-let string = \"Hello there.\";\n-```\n-\n-Like any Rust reference, string slices have an associated lifetime. A string\n-literal is a `&'static str`.  A string slice can be written without an explicit\n-lifetime in many cases, such as in function arguments. In these cases the\n-lifetime will be inferred:\n-\n-```\n-fn takes_slice(slice: &str) {\n-    println!(\"Got: {}\", slice);\n-}\n-```\n-\n-Like vector slices, string slices are simply a pointer plus a length. This\n-means that they're a 'view' into an already-allocated string, such as a\n-string literal or a `String`.\n-\n-## `str`\n-\n-You may occasionally see references to a `str` type, without the `&`. While\n-this type does exist, it\u2019s not something you want to use yourself. Sometimes,\n-people confuse `str` for `String`, and write this:\n-\n-```rust\n-struct S {\n-    s: str,\n-}\n-```\n-\n-This leads to ugly errors:\n-\n-```text\n-error: the trait `core::marker::Sized` is not implemented for the type `str` [E0277]\n-note: `str` does not have a constant size known at compile-time\n-```\n-\n-Instead, this `struct` should be\n-\n-```rust\n-struct S {\n-    s: String,\n-}\n-```\n-\n-So let\u2019s talk about `String`s.\n-\n-# `String`\n-\n-A `String` is a heap-allocated string. This string is growable, and is\n-also guaranteed to be UTF-8. `String`s are commonly created by\n-converting from a string slice using the `to_string` method.\n-\n-```\n-let mut s = \"Hello\".to_string();\n-println!(\"{}\", s);\n-\n-s.push_str(\", world.\");\n-println!(\"{}\", s);\n-```\n-\n-A reference to a `String` will automatically coerce to a string slice:\n-\n-```\n-fn takes_slice(slice: &str) {\n-    println!(\"Got: {}\", slice);\n-}\n-\n-fn main() {\n-    let s = \"Hello\".to_string();\n-    takes_slice(&s);\n-}\n-```\n-\n-You can also get a `&str` from a stack-allocated array of bytes:\n-\n-```\n-use std::str;\n-\n-let x: &[u8] = &[b'a', b'b'];\n-let stack_str: &str = str::from_utf8(x).unwrap();\n-```\n-\n-# Best Practices\n-\n-## `String` vs. `&str`\n-\n-In general, you should prefer `String` when you need ownership, and `&str` when\n-you just need to borrow a string. This is very similar to using `Vec<T>` vs. `&[T]`,\n-and `T` vs `&T` in general.\n-\n-This means starting off with this:\n-\n-```{rust,ignore}\n-fn foo(s: &str) {\n-```\n-\n-and only moving to this:\n-\n-```{rust,ignore}\n-fn foo(s: String) {\n-```\n-\n-if you have good reason. It's not polite to hold on to ownership you don't\n-need, and it can make your lifetimes more complex.\n-\n-## Generic functions\n-\n-To write a function that's generic over types of strings, use `&str`.\n-\n-```\n-fn some_string_length(x: &str) -> usize {\n-    x.len()\n-}\n-\n-fn main() {\n-    let s = \"Hello, world\";\n-\n-    println!(\"{}\", some_string_length(s));\n-\n-    let s = \"Hello, world\".to_string();\n-\n-    println!(\"{}\", some_string_length(&s));\n-}\n-```\n-\n-Both of these lines will print `12`.\n-\n-## Indexing strings\n-\n-You may be tempted to try to access a certain character of a `String`, like\n-this:\n-\n-```{rust,ignore}\n-let s = \"hello\".to_string();\n-\n-println!(\"{}\", s[0]);\n-```\n-\n-This does not compile. This is on purpose. In the world of UTF-8, direct\n-indexing is basically never what you want to do. The reason is that each\n-character can be a variable number of bytes. This means that you have to iterate\n-through the characters anyway, which is an O(n) operation.\n-\n-There's 3 basic levels of unicode (and its encodings):\n-\n-- code units, the underlying data type used to store everything\n-- code points/unicode scalar values (char)\n-- graphemes (visible characters)\n-\n-Rust provides iterators for each of these situations:\n-\n-- `.bytes()` will iterate over the underlying bytes\n-- `.chars()` will iterate over the code points\n-- `.graphemes()` will iterate over each grapheme\n-\n-Usually, the `graphemes()` method on `&str` is what you want:\n-\n-```\n-# #![feature(unicode)]\n-let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n-\n-for l in s.graphemes(true) {\n-    println!(\"{}\", l);\n-}\n-```\n-\n-This prints:\n-\n-```text\n-u\u0354\n-n\u030e\u0348\u0330\n-i\u0319\u032e\u035a\u0326\n-c\u0309\u035a\n-o\u0357\u033c\u0329\u0330\n-d\u0306\u0343\u0365\u0354\n-e\u0301\n-```\n-\n-Note that `l` has the type `&str` here, since a single grapheme can consist of\n-multiple codepoints, so a `char` wouldn't be appropriate.\n-\n-This will print out each visible character in turn, as you'd expect: first `u\u0354`, then\n-`n\u030e\u0348\u0330`, etc. If you wanted each individual codepoint of each grapheme, you can use `.chars()`:\n-\n-```\n-let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n-\n-for l in s.chars() {\n-    println!(\"{}\", l);\n-}\n-```\n-\n-This prints:\n-\n-```text\n-u\n-\u0354\n-n\n-\u030e\n-\u0348\n-\u0330\n-i\n-\u0319\n-\u032e\n-\u035a\n-\u0326\n-c\n-\u0309\n-\u035a\n-o\n-\u0357\n-\u033c\n-\u0329\n-\u0330\n-d\n-\u0306\n-\u0343\n-\u0365\n-\u0354\n-e\n-\u0301\n-```\n-\n-You can see how some of them are combining characters, and therefore the output\n-looks a bit odd.\n-\n-If you want the individual byte representation of each codepoint, you can use\n-`.bytes()`:\n-\n-```\n-let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n-\n-for l in s.bytes() {\n-    println!(\"{}\", l);\n-}\n-```\n-\n-This will print:\n-\n-```text\n-117\n-205\n-148\n-110\n-204\n-142\n-205\n-136\n-204\n-176\n-105\n-204\n-153\n-204\n-174\n-205\n-154\n-204\n-166\n-99\n-204\n-137\n-205\n-154\n-111\n-205\n-151\n-204\n-188\n-204\n-169\n-204\n-176\n-100\n-204\n-134\n-205\n-131\n-205\n-165\n-205\n-148\n-101\n-204\n-129\n-```\n-\n-Many more bytes than graphemes!\n-\n-# `Deref` coercions\n-\n-References to `String`s will automatically coerce into `&str`s. Like this:\n-\n-```\n-fn hello(s: &str) {\n-   println!(\"Hello, {}!\", s);\n-}\n-\n-let slice = \"Steve\";\n-let string = \"Steve\".to_string();\n-\n-hello(slice);\n-hello(&string);\n-```"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/move-semantics.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fmove-semantics.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fmove-semantics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmove-semantics.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/mutability.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fmutability.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fmutability.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmutability.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "d69831c23783814fb6e60f7c48de024dd1bf7b02", "filename": "src/doc/trpl/nightly-rust.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fnightly-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fnightly-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fnightly-rust.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "previous_filename": "src/doc/trpl/unstable.md"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/no-stdlib.md", "status": "modified", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fno-stdlib.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,168 +0,0 @@\n-% No stdlib\n-\n-By default, `std` is linked to every Rust crate. In some contexts,\n-this is undesirable, and can be avoided with the `#![no_std]`\n-attribute attached to the crate.\n-\n-```ignore\n-// a minimal library\n-#![crate_type=\"lib\"]\n-#![feature(no_std)]\n-#![no_std]\n-# // fn main() {} tricked you, rustdoc!\n-```\n-\n-Obviously there's more to life than just libraries: one can use\n-`#[no_std]` with an executable, controlling the entry point is\n-possible in two ways: the `#[start]` attribute, or overriding the\n-default shim for the C `main` function with your own.\n-\n-The function marked `#[start]` is passed the command line parameters\n-in the same format as C:\n-\n-```\n-#![feature(lang_items, start, no_std, libc)]\n-#![no_std]\n-\n-// Pull in the system libc library for what crt0.o likely requires\n-extern crate libc;\n-\n-// Entry point for this program\n-#[start]\n-fn start(_argc: isize, _argv: *const *const u8) -> isize {\n-    0\n-}\n-\n-// These functions and traits are used by the compiler, but not\n-// for a bare-bones hello world. These are normally\n-// provided by libstd.\n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-# // fn main() {} tricked you, rustdoc!\n-```\n-\n-To override the compiler-inserted `main` shim, one has to disable it\n-with `#![no_main]` and then create the appropriate symbol with the\n-correct ABI and the correct name, which requires overriding the\n-compiler's name mangling too:\n-\n-```ignore\n-#![feature(no_std)]\n-#![no_std]\n-#![no_main]\n-#![feature(lang_items, start)]\n-\n-extern crate libc;\n-\n-#[no_mangle] // ensure that this symbol is called `main` in the output\n-pub extern fn main(argc: i32, argv: *const *const u8) -> i32 {\n-    0\n-}\n-\n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-# // fn main() {} tricked you, rustdoc!\n-```\n-\n-\n-The compiler currently makes a few assumptions about symbols which are available\n-in the executable to call. Normally these functions are provided by the standard\n-library, but without it you must define your own.\n-\n-The first of these three functions, `stack_exhausted`, is invoked whenever stack\n-overflow is detected.  This function has a number of restrictions about how it\n-can be called and what it must do, but if the stack limit register is not being\n-maintained then a thread always has an \"infinite stack\" and this function\n-shouldn't get triggered.\n-\n-The second of these three functions, `eh_personality`, is used by the\n-failure mechanisms of the compiler. This is often mapped to GCC's\n-personality function (see the\n-[libstd implementation](../std/rt/unwind/index.html) for more\n-information), but crates which do not trigger a panic can be assured\n-that this function is never called. The final function, `panic_fmt`, is\n-also used by the failure mechanisms of the compiler.\n-\n-## Using libcore\n-\n-> **Note**: the core library's structure is unstable, and it is recommended to\n-> use the standard library instead wherever possible.\n-\n-With the above techniques, we've got a bare-metal executable running some Rust\n-code. There is a good deal of functionality provided by the standard library,\n-however, that is necessary to be productive in Rust. If the standard library is\n-not sufficient, then [libcore](../core/index.html) is designed to be used\n-instead.\n-\n-The core library has very few dependencies and is much more portable than the\n-standard library itself. Additionally, the core library has most of the\n-necessary functionality for writing idiomatic and effective Rust code.\n-\n-As an example, here is a program that will calculate the dot product of two\n-vectors provided from C, using idiomatic Rust practices.\n-\n-```\n-#![feature(lang_items, start, no_std, core, libc)]\n-#![no_std]\n-\n-# extern crate libc;\n-extern crate core;\n-\n-use core::prelude::*;\n-\n-use core::mem;\n-\n-#[no_mangle]\n-pub extern fn dot_product(a: *const u32, a_len: u32,\n-                          b: *const u32, b_len: u32) -> u32 {\n-    use core::raw::Slice;\n-\n-    // Convert the provided arrays into Rust slices.\n-    // The core::raw module guarantees that the Slice\n-    // structure has the same memory layout as a &[T]\n-    // slice.\n-    //\n-    // This is an unsafe operation because the compiler\n-    // cannot tell the pointers are valid.\n-    let (a_slice, b_slice): (&[u32], &[u32]) = unsafe {\n-        mem::transmute((\n-            Slice { data: a, len: a_len as usize },\n-            Slice { data: b, len: b_len as usize },\n-        ))\n-    };\n-\n-    // Iterate over the slices, collecting the result\n-    let mut ret = 0;\n-    for (i, j) in a_slice.iter().zip(b_slice.iter()) {\n-        ret += (*i) * (*j);\n-    }\n-    return ret;\n-}\n-\n-#[lang = \"panic_fmt\"]\n-extern fn panic_fmt(args: &core::fmt::Arguments,\n-                    file: &str,\n-                    line: u32) -> ! {\n-    loop {}\n-}\n-\n-#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n-#[lang = \"eh_personality\"] extern fn eh_personality() {}\n-# #[start] fn start(argc: isize, argv: *const *const u8) -> isize { 0 }\n-# fn main() {}\n-```\n-\n-Note that there is one extra lang item here which differs from the examples\n-above, `panic_fmt`. This must be defined by consumers of libcore because the\n-core library declares panics, but it does not define it. The `panic_fmt`\n-lang item is this crate's definition of panic, and it must be guaranteed to\n-never return.\n-\n-As can be seen in this example, the core library is intended to provide the\n-power of Rust in all circumstances, regardless of platform requirements. Further\n-libraries, such as liballoc, add functionality to libcore which make other\n-platform-specific assumptions, but continue to be more portable than the\n-standard library itself.\n-"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/operators-and-overloading.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Foperators-and-overloading.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 0, "deletions": 555, "changes": 555, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,555 +0,0 @@\n-% Ownership\n-\n-This guide presents Rust's ownership system. This is one of Rust's most unique\n-and compelling features, with which Rust developers should become quite\n-acquainted. Ownership is how Rust achieves its largest goal, memory safety.\n-The ownership system has a few distinct concepts: *ownership*, *borrowing*,\n-and *lifetimes*. We'll talk about each one in turn.\n-\n-# Meta\n-\n-Before we get to the details, two important notes about the ownership system.\n-\n-Rust has a focus on safety and speed. It accomplishes these goals through many\n-*zero-cost abstractions*, which means that in Rust, abstractions cost as little\n-as possible in order to make them work. The ownership system is a prime example\n-of a zero cost abstraction. All of the analysis we'll talk about in this guide\n-is _done at compile time_. You do not pay any run-time cost for any of these\n-features.\n-\n-However, this system does have a certain cost: learning curve. Many new users\n-to Rust experience something we like to call \"fighting with the borrow\n-checker,\" where the Rust compiler refuses to compile a program that the author\n-thinks is valid. This often happens because the programmer's mental model of\n-how ownership should work doesn't match the actual rules that Rust implements.\n-You probably will experience similar things at first. There is good news,\n-however: more experienced Rust developers report that once they work with the\n-rules of the ownership system for a period of time, they fight the borrow\n-checker less and less.\n-\n-With that in mind, let's learn about ownership.\n-\n-# Ownership\n-\n-At its core, ownership is about *resources*. For the purposes of the vast\n-majority of this guide, we will talk about a specific resource: memory. The\n-concept generalizes to any kind of resource, like a file handle, but to make it\n-more concrete, we'll focus on memory.\n-\n-When your program allocates some memory, it needs some way to deallocate that\n-memory. Imagine a function `foo` that allocates four bytes of memory, and then\n-never deallocates that memory. We call this problem *leaking* memory, because\n-each time we call `foo`, we're allocating another four bytes. Eventually, with\n-enough calls to `foo`, we will run our system out of memory. That's no good. So\n-we need some way for `foo` to deallocate those four bytes. It's also important\n-that we don't deallocate too many times, either. Without getting into the\n-details, attempting to deallocate memory multiple times can lead to problems.\n-In other words, any time some memory is allocated, we need to make sure that we\n-deallocate that memory once and only once. Too many times is bad, not enough\n-times is bad. The counts must match.\n-\n-There's one other important detail with regards to allocating memory. Whenever\n-we request some amount of memory, what we are given is a handle to that memory.\n-This handle (often called a *pointer*, when we're referring to memory) is how\n-we interact with the allocated memory. As long as we have that handle, we can\n-do something with the memory. Once we're done with the handle, we're also done\n-with the memory, as we can't do anything useful without a handle to it.\n-\n-Historically, systems programming languages require you to track these\n-allocations, deallocations, and handles yourself. For example, if we want some\n-memory from the heap in a language like C, we do this:\n-\n-```c\n-{\n-    int *x = malloc(sizeof(int));\n-\n-    // we can now do stuff with our handle x\n-    *x = 5;\n-\n-    free(x);\n-}\n-```\n-\n-The call to `malloc` allocates some memory. The call to `free` deallocates the\n-memory. There's also bookkeeping about allocating the correct amount of memory.\n-\n-Rust combines these two aspects of allocating memory (and other resources) into\n-a concept called *ownership*. Whenever we request some memory, that handle we\n-receive is called the *owning handle*. Whenever that handle goes out of scope,\n-Rust knows that you cannot do anything with the memory anymore, and so\n-therefore deallocates the memory for you. Here's the equivalent example in\n-Rust:\n-\n-```rust\n-{\n-    let x = Box::new(5);\n-}\n-```\n-\n-The `Box::new` function creates a `Box<T>` (specifically `Box<i32>` in this\n-case) by allocating a small segment of memory on the heap with enough space to\n-fit an `i32`. But where in the code is the box deallocated? We said before that\n-we must have a deallocation for each allocation. Rust handles this for you. It\n-knows that our handle, `x`, is the owning reference to our box. Rust knows that\n-`x` will go out of scope at the end of the block, and so it inserts a call to\n-deallocate the memory at the end of the scope. Because the compiler does this\n-for us, it's impossible to forget. We always have exactly one deallocation\n-  paired with each of our allocations.\n-\n-This is pretty straightforward, but what happens when we want to pass our box\n-to a function? Let's look at some code:\n-\n-```rust\n-fn main() {\n-    let x = Box::new(5);\n-\n-    add_one(x);\n-}\n-\n-fn add_one(mut num: Box<i32>) {\n-    *num += 1;\n-}\n-```\n-\n-This code works, but it's not ideal. For example, let's add one more line of\n-code, where we print out the value of `x`:\n-\n-```{rust,ignore}\n-fn main() {\n-    let x = Box::new(5);\n-\n-    add_one(x);\n-\n-    println!(\"{}\", x);\n-}\n-\n-fn add_one(mut num: Box<i32>) {\n-    *num += 1;\n-}\n-```\n-\n-This does not compile, and gives us an error:\n-\n-```text\n-error: use of moved value: `x`\n-   println!(\"{}\", x);\n-                  ^\n-```\n-\n-Remember, we need one deallocation for every allocation. When we try to pass\n-our box to `add_one`, we would have two handles to the memory: `x` in `main`,\n-and `num` in `add_one`. If we deallocated the memory when each handle went out\n-of scope, we would have two deallocations and one allocation, and that's wrong.\n-So when we call `add_one`, Rust defines `num` as the owner of the handle. And\n-so, now that we've given ownership to `num`, `x` is invalid. `x`'s value has\n-\"moved\" from `x` to `num`. Hence the error: use of moved value `x`.\n-\n-To fix this, we can have `add_one` give ownership back when it's done with the\n-box:\n-\n-```rust\n-fn main() {\n-    let x = Box::new(5);\n-\n-    let y = add_one(x);\n-\n-    println!(\"{}\", y);\n-}\n-\n-fn add_one(mut num: Box<i32>) -> Box<i32> {\n-    *num += 1;\n-\n-    num\n-}\n-```\n-\n-This code will compile and run just fine. Now, we return a `box`, and so the\n-ownership is transferred back to `y` in `main`. We only have ownership for the\n-duration of our function before giving it back. This pattern is very common,\n-and so Rust introduces a concept to describe a handle which temporarily refers\n-to something another handle owns. It's called *borrowing*, and it's done with\n-*references*, designated by the `&` symbol.\n-\n-# Borrowing\n-\n-Here's the current state of our `add_one` function:\n-\n-```rust\n-fn add_one(mut num: Box<i32>) -> Box<i32> {\n-    *num += 1;\n-\n-    num\n-}\n-```\n-\n-This function takes ownership, because it takes a `Box`, which owns its\n-contents. But then we give ownership right back.\n-\n-In the physical world, you can give one of your possessions to someone for a\n-short period of time. You still own your possession, you're just letting someone\n-else use it for a while. We call that *lending* something to someone, and that\n-person is said to be *borrowing* that something from you.\n-\n-Rust's ownership system also allows an owner to lend out a handle for a limited\n-period. This is also called *borrowing*. Here's a version of `add_one` which\n-borrows its argument rather than taking ownership:\n-\n-```rust\n-fn add_one(num: &mut i32) {\n-    *num += 1;\n-}\n-```\n-\n-This function borrows an `i32` from its caller, and then increments it. When\n-the function is over, and `num` goes out of scope, the borrow is over.\n-\n-We have to change our `main` a bit too:\n-\n-```rust\n-fn main() {\n-    let mut x = 5;\n-\n-    add_one(&mut x);\n-\n-    println!(\"{}\", x);\n-}\n-\n-fn add_one(num: &mut i32) {\n-    *num += 1;\n-}\n-```\n-\n-We don't need to assign the result of `add_one()` anymore, because it doesn't\n-return anything anymore. This is because we're not passing ownership back,\n-since we just borrow, not take ownership.\n-\n-# Lifetimes\n-\n-Lending out a reference to a resource that someone else owns can be\n-complicated, however. For example, imagine this set of operations:\n-\n-1. I acquire a handle to some kind of resource.\n-2. I lend you a reference to the resource.\n-3. I decide I'm done with the resource, and deallocate it, while you still have\n-   your reference.\n-4. You decide to use the resource.\n-\n-Uh oh! Your reference is pointing to an invalid resource. This is called a\n-*dangling pointer* or \"use after free,\" when the resource is memory.\n-\n-To fix this, we have to make sure that step four never happens after step\n-three. The ownership system in Rust does this through a concept called\n-*lifetimes*, which describe the scope that a reference is valid for.\n-\n-Remember the function that borrowed an `i32`? Let's look at it again.\n-\n-```rust\n-fn add_one(num: &mut i32) {\n-    *num += 1;\n-}\n-```\n-\n-Rust has a feature called *lifetime elision*, which allows you to not write\n-lifetime annotations in certain circumstances. This is one of them. We will\n-cover the others later. Without eliding the lifetimes, `add_one` looks like\n-this:\n-\n-```rust\n-fn add_one<'a>(num: &'a mut i32) {\n-    *num += 1;\n-}\n-```\n-\n-The `'a` is called a *lifetime*. Most lifetimes are used in places where\n-short names like `'a`, `'b` and `'c` are clearest, but it's often useful to\n-have more descriptive names. Let's dig into the syntax in a bit more detail:\n-\n-```{rust,ignore}\n-fn add_one<'a>(...)\n-```\n-\n-This part _declares_ our lifetimes. This says that `add_one` has one lifetime,\n-`'a`. If we had two, it would look like this:\n-\n-```{rust,ignore}\n-fn add_two<'a, 'b>(...)\n-```\n-\n-Then in our parameter list, we use the lifetimes we've named:\n-\n-```{rust,ignore}\n-...(num: &'a mut i32)\n-```\n-\n-If you compare `&mut i32` to `&'a mut i32`, they're the same, it's just that the\n-lifetime `'a` has snuck in between the `&` and the `mut i32`. We read `&mut i32` as \"a\n-mutable reference to an i32\" and `&'a mut i32` as \"a mutable reference to an i32 with the lifetime 'a.'\"\n-\n-Why do lifetimes matter? Well, for example, here's some code:\n-\n-```rust\n-struct Foo<'a> {\n-    x: &'a i32,\n-}\n-\n-fn main() {\n-    let y = &5; // this is the same as `let _y = 5; let y = &_y;`\n-    let f = Foo { x: y };\n-\n-    println!(\"{}\", f.x);\n-}\n-```\n-\n-As you can see, `struct`s can also have lifetimes. In a similar way to functions,\n-\n-```{rust}\n-struct Foo<'a> {\n-# x: &'a i32,\n-# }\n-```\n-\n-declares a lifetime, and\n-\n-```rust\n-# struct Foo<'a> {\n-x: &'a i32,\n-# }\n-```\n-\n-uses it. So why do we need a lifetime here? We need to ensure that any reference\n-to a `Foo` cannot outlive the reference to an `i32` it contains.\n-\n-## Thinking in scopes\n-\n-A way to think about lifetimes is to visualize the scope that a reference is\n-valid for. For example:\n-\n-```rust\n-fn main() {\n-    let y = &5;     // -+ y goes into scope\n-                    //  |\n-    // stuff        //  |\n-                    //  |\n-}                   // -+ y goes out of scope\n-```\n-\n-Adding in our `Foo`:\n-\n-```rust\n-struct Foo<'a> {\n-    x: &'a i32,\n-}\n-\n-fn main() {\n-    let y = &5;           // -+ y goes into scope\n-    let f = Foo { x: y }; // -+ f goes into scope\n-    // stuff              //  |\n-                          //  |\n-}                         // -+ f and y go out of scope\n-```\n-\n-Our `f` lives within the scope of `y`, so everything works. What if it didn't?\n-This code won't work:\n-\n-```{rust,ignore}\n-struct Foo<'a> {\n-    x: &'a i32,\n-}\n-\n-fn main() {\n-    let x;                    // -+ x goes into scope\n-                              //  |\n-    {                         //  |\n-        let y = &5;           // ---+ y goes into scope\n-        let f = Foo { x: y }; // ---+ f goes into scope\n-        x = &f.x;             //  | | error here\n-    }                         // ---+ f and y go out of scope\n-                              //  |\n-    println!(\"{}\", x);        //  |\n-}                             // -+ x goes out of scope\n-```\n-\n-Whew! As you can see here, the scopes of `f` and `y` are smaller than the scope\n-of `x`. But when we do `x = &f.x`, we make `x` a reference to something that's\n-about to go out of scope.\n-\n-Named lifetimes are a way of giving these scopes a name. Giving something a\n-name is the first step towards being able to talk about it.\n-\n-## 'static\n-\n-The lifetime named *static* is a special lifetime. It signals that something\n-has the lifetime of the entire program. Most Rust programmers first come across\n-`'static` when dealing with strings:\n-\n-```rust\n-let x: &'static str = \"Hello, world.\";\n-```\n-\n-String literals have the type `&'static str` because the reference is always\n-alive: they are baked into the data segment of the final binary. Another\n-example are globals:\n-\n-```rust\n-static FOO: i32 = 5;\n-let x: &'static i32 = &FOO;\n-```\n-\n-This adds an `i32` to the data segment of the binary, and `x` is a reference\n-to it.\n-\n-# Shared Ownership\n-\n-In all the examples we've considered so far, we've assumed that each handle has\n-a singular owner. But sometimes, this doesn't work. Consider a car. Cars have\n-four wheels. We would want a wheel to know which car it was attached to. But\n-this won't work:\n-\n-```{rust,ignore}\n-struct Car {\n-    name: String,\n-}\n-\n-struct Wheel {\n-    size: i32,\n-    owner: Car,\n-}\n-\n-fn main() {\n-    let car = Car { name: \"DeLorean\".to_string() };\n-\n-    for _ in 0..4 {\n-        Wheel { size: 360, owner: car };\n-    }\n-}\n-```\n-\n-We try to make four `Wheel`s, each with a `Car` that it's attached to. But the\n-compiler knows that on the second iteration of the loop, there's a problem:\n-\n-```text\n-error: use of moved value: `car`\n-    Wheel { size: 360, owner: car };\n-                              ^~~\n-note: `car` moved here because it has type `Car`, which is non-copyable\n-    Wheel { size: 360, owner: car };\n-                              ^~~\n-```\n-\n-We need our `Car` to be pointed to by multiple `Wheel`s. We can't do that with\n-`Box<T>`, because it has a single owner. We can do it with `Rc<T>` instead:\n-\n-```rust\n-use std::rc::Rc;\n-\n-struct Car {\n-    name: String,\n-}\n-\n-struct Wheel {\n-    size: i32,\n-    owner: Rc<Car>,\n-}\n-\n-fn main() {\n-    let car = Car { name: \"DeLorean\".to_string() };\n-\n-    let car_owner = Rc::new(car);\n-\n-    for _ in 0..4 {\n-        Wheel { size: 360, owner: car_owner.clone() };\n-    }\n-}\n-```\n-\n-We wrap our `Car` in an `Rc<T>`, getting an `Rc<Car>`, and then use the\n-`clone()` method to make new references. We've also changed our `Wheel` to have\n-an `Rc<Car>` rather than just a `Car`.\n-\n-This is the simplest kind of multiple ownership possible. For example, there's\n-also `Arc<T>`, which uses more expensive atomic instructions to be the\n-thread-safe counterpart of `Rc<T>`.\n-\n-## Lifetime Elision\n-\n-Rust supports powerful local type inference in function bodies, but it\u2019s\n-forbidden in item signatures to allow reasoning about the types just based in\n-the item signature alone. However, for ergonomic reasons a very restricted\n-secondary inference algorithm called \u201clifetime elision\u201d applies in function\n-signatures. It infers only based on the signature components themselves and not\n-based on the body of the function, only infers lifetime parameters, and does\n-this with only three easily memorizable and unambiguous rules. This makes\n-lifetime elision a shorthand for writing an item signature, while not hiding\n-away the actual types involved as full local inference would if applied to it.\n-\n-When talking about lifetime elision, we use the term *input lifetime* and\n-*output lifetime*. An *input lifetime* is a lifetime associated with a parameter\n-of a function, and an *output lifetime* is a lifetime associated with the return\n-value of a function. For example, this function has an input lifetime:\n-\n-```{rust,ignore}\n-fn foo<'a>(bar: &'a str)\n-```\n-\n-This one has an output lifetime:\n-\n-```{rust,ignore}\n-fn foo<'a>() -> &'a str\n-```\n-\n-This one has a lifetime in both positions:\n-\n-```{rust,ignore}\n-fn foo<'a>(bar: &'a str) -> &'a str\n-```\n-\n-Here are the three rules:\n-\n-* Each elided lifetime in a function's arguments becomes a distinct lifetime\n-  parameter.\n-\n-* If there is exactly one input lifetime, elided or not, that lifetime is\n-  assigned to all elided lifetimes in the return values of that function.\n-\n-* If there are multiple input lifetimes, but one of them is `&self` or `&mut\n-  self`, the lifetime of `self` is assigned to all elided output lifetimes.\n-\n-Otherwise, it is an error to elide an output lifetime.\n-\n-### Examples\n-\n-Here are some examples of functions with elided lifetimes.  We've paired each\n-example of an elided lifetime with its expanded form.\n-\n-```{rust,ignore}\n-fn print(s: &str); // elided\n-fn print<'a>(s: &'a str); // expanded\n-\n-fn debug(lvl: u32, s: &str); // elided\n-fn debug<'a>(lvl: u32, s: &'a str); // expanded\n-\n-// In the preceding example, `lvl` doesn't need a lifetime because it's not a\n-// reference (`&`). Only things relating to references (such as a `struct`\n-// which contains a reference) need lifetimes.\n-\n-fn substr(s: &str, until: u32) -> &str; // elided\n-fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded\n-\n-fn get_str() -> &str; // ILLEGAL, no inputs\n-\n-fn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs\n-fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is unclear\n-\n-fn get_mut(&mut self) -> &mut T; // elided\n-fn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded\n-\n-fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command // elided\n-fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded\n-\n-fn new(buf: &mut [u8]) -> BufWriter; // elided\n-fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> // expanded\n-```\n-\n-# Related Resources\n-\n-Coming Soon."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,200 +0,0 @@\n-% Patterns\n-\n-We've made use of patterns a few times in the guide: first with `let` bindings,\n-then with `match` statements. Let's go on a whirlwind tour of all of the things\n-patterns can do!\n-\n-A quick refresher: you can match against literals directly, and `_` acts as an\n-*any* case:\n-\n-```{rust}\n-let x = 1;\n-\n-match x {\n-    1 => println!(\"one\"),\n-    2 => println!(\"two\"),\n-    3 => println!(\"three\"),\n-    _ => println!(\"anything\"),\n-}\n-```\n-\n-You can match multiple patterns with `|`:\n-\n-```{rust}\n-let x = 1;\n-\n-match x {\n-    1 | 2 => println!(\"one or two\"),\n-    3 => println!(\"three\"),\n-    _ => println!(\"anything\"),\n-}\n-```\n-\n-You can match a range of values with `...`:\n-\n-```{rust}\n-let x = 1;\n-\n-match x {\n-    1 ... 5 => println!(\"one through five\"),\n-    _ => println!(\"anything\"),\n-}\n-```\n-\n-Ranges are mostly used with integers and single characters.\n-\n-If you're matching multiple things, via a `|` or a `...`, you can bind\n-the value to a name with `@`:\n-\n-```{rust}\n-let x = 1;\n-\n-match x {\n-    e @ 1 ... 5 => println!(\"got a range element {}\", e),\n-    _ => println!(\"anything\"),\n-}\n-```\n-\n-If you're matching on an enum which has variants, you can use `..` to\n-ignore the value and type in the variant:\n-\n-```{rust}\n-enum OptionalInt {\n-    Value(i32),\n-    Missing,\n-}\n-\n-let x = OptionalInt::Value(5);\n-\n-match x {\n-    OptionalInt::Value(..) => println!(\"Got an int!\"),\n-    OptionalInt::Missing => println!(\"No such luck.\"),\n-}\n-```\n-\n-You can introduce *match guards* with `if`:\n-\n-```{rust}\n-enum OptionalInt {\n-    Value(i32),\n-    Missing,\n-}\n-\n-let x = OptionalInt::Value(5);\n-\n-match x {\n-    OptionalInt::Value(i) if i > 5 => println!(\"Got an int bigger than five!\"),\n-    OptionalInt::Value(..) => println!(\"Got an int!\"),\n-    OptionalInt::Missing => println!(\"No such luck.\"),\n-}\n-```\n-\n-If you're matching on a pointer, you can use the same syntax as you declared it\n-with. First, `&`:\n-\n-```{rust}\n-let x = &5;\n-\n-match x {\n-    &val => println!(\"Got a value: {}\", val),\n-}\n-```\n-\n-Here, the `val` inside the `match` has type `i32`. In other words, the left-hand\n-side of the pattern destructures the value. If we have `&5`, then in `&val`, `val`\n-would be `5`.\n-\n-If you want to get a reference, use the `ref` keyword:\n-\n-```{rust}\n-let x = 5;\n-\n-match x {\n-    ref r => println!(\"Got a reference to {}\", r),\n-}\n-```\n-\n-Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`\n-keyword _creates_ a reference, for use in the pattern. If you need a mutable\n-reference, `ref mut` will work in the same way:\n-\n-```{rust}\n-let mut x = 5;\n-\n-match x {\n-    ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n-}\n-```\n-\n-If you have a struct, you can destructure it inside of a pattern:\n-\n-```{rust}\n-# #![allow(non_shorthand_field_patterns)]\n-struct Point {\n-    x: i32,\n-    y: i32,\n-}\n-\n-let origin = Point { x: 0, y: 0 };\n-\n-match origin {\n-    Point { x: x, y: y } => println!(\"({},{})\", x, y),\n-}\n-```\n-\n-If we only care about some of the values, we don't have to give them all names:\n-\n-```{rust}\n-# #![allow(non_shorthand_field_patterns)]\n-struct Point {\n-    x: i32,\n-    y: i32,\n-}\n-\n-let origin = Point { x: 0, y: 0 };\n-\n-match origin {\n-    Point { x: x, .. } => println!(\"x is {}\", x),\n-}\n-```\n-\n-You can do this kind of match on any member, not just the first:\n-\n-```{rust}\n-# #![allow(non_shorthand_field_patterns)]\n-struct Point {\n-    x: i32,\n-    y: i32,\n-}\n-\n-let origin = Point { x: 0, y: 0 };\n-\n-match origin {\n-    Point { y: y, .. } => println!(\"y is {}\", y),\n-}\n-```\n-\n-If you want to match against a slice or array, you can use `&`:\n-\n-```{rust}\n-# #![feature(slice_patterns)]\n-fn main() {\n-    let v = vec![\"match_this\", \"1\"];\n-\n-    match &v[..] {\n-        [\"match_this\", second] => println!(\"The second element is {}\", second),\n-        _ => {},\n-    }\n-}\n-```\n-\n-Whew! That's a lot of different ways to match things, and they can all be\n-mixed and matched, depending on what you're doing:\n-\n-```{rust,ignore}\n-match x {\n-    Foo { x: Some(ref name), y: None } => ...\n-}\n-```\n-\n-Patterns are very powerful.  Make good use of them."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/plugins.md", "status": "modified", "additions": 0, "deletions": 242, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fplugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fplugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fplugins.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,242 +0,0 @@\n-% Compiler Plugins\n-\n-# Introduction\n-\n-`rustc` can load compiler plugins, which are user-provided libraries that\n-extend the compiler's behavior with new syntax extensions, lint checks, etc.\n-\n-A plugin is a dynamic library crate with a designated *registrar* function that\n-registers extensions with `rustc`. Other crates can load these extensions using\n-the crate attribute `#![plugin(...)]`.  See the\n-[`rustc::plugin`](../rustc/plugin/index.html) documentation for more about the\n-mechanics of defining and loading a plugin.\n-\n-If present, arguments passed as `#![plugin(foo(... args ...))]` are not\n-interpreted by rustc itself.  They are provided to the plugin through the\n-`Registry`'s [`args` method](../rustc/plugin/registry/struct.Registry.html#method.args).\n-\n-In the vast majority of cases, a plugin should *only* be used through\n-`#![plugin]` and not through an `extern crate` item.  Linking a plugin would\n-pull in all of libsyntax and librustc as dependencies of your crate.  This is\n-generally unwanted unless you are building another plugin.  The\n-`plugin_as_library` lint checks these guidelines.\n-\n-The usual practice is to put compiler plugins in their own crate, separate from\n-any `macro_rules!` macros or ordinary Rust code meant to be used by consumers\n-of a library.\n-\n-# Syntax extensions\n-\n-Plugins can extend Rust's syntax in various ways. One kind of syntax extension\n-is the procedural macro. These are invoked the same way as [ordinary\n-macros](macros.html), but the expansion is performed by arbitrary Rust\n-code that manipulates [syntax trees](../syntax/ast/index.html) at\n-compile time.\n-\n-Let's write a plugin\n-[`roman_numerals.rs`](https://github.com/rust-lang/rust/tree/master/src/test/auxiliary/roman_numerals.rs)\n-that implements Roman numeral integer literals.\n-\n-```ignore\n-#![crate_type=\"dylib\"]\n-#![feature(plugin_registrar, rustc_private)]\n-\n-extern crate syntax;\n-extern crate rustc;\n-\n-use syntax::codemap::Span;\n-use syntax::parse::token;\n-use syntax::ast::{TokenTree, TtToken};\n-use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n-use syntax::ext::build::AstBuilder;  // trait for expr_usize\n-use rustc::plugin::Registry;\n-\n-fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n-        -> Box<MacResult + 'static> {\n-\n-    static NUMERALS: &'static [(&'static str, u32)] = &[\n-        (\"M\", 1000), (\"CM\", 900), (\"D\", 500), (\"CD\", 400),\n-        (\"C\",  100), (\"XC\",  90), (\"L\",  50), (\"XL\",  40),\n-        (\"X\",   10), (\"IX\",   9), (\"V\",   5), (\"IV\",   4),\n-        (\"I\",    1)];\n-\n-    let text = match args {\n-        [TtToken(_, token::Ident(s, _))] => token::get_ident(s).to_string(),\n-        _ => {\n-            cx.span_err(sp, \"argument should be a single identifier\");\n-            return DummyResult::any(sp);\n-        }\n-    };\n-\n-    let mut text = &*text;\n-    let mut total = 0;\n-    while !text.is_empty() {\n-        match NUMERALS.iter().find(|&&(rn, _)| text.starts_with(rn)) {\n-            Some(&(rn, val)) => {\n-                total += val;\n-                text = &text[rn.len()..];\n-            }\n-            None => {\n-                cx.span_err(sp, \"invalid Roman numeral\");\n-                return DummyResult::any(sp);\n-            }\n-        }\n-    }\n-\n-    MacEager::expr(cx.expr_u32(sp, total))\n-}\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"rn\", expand_rn);\n-}\n-```\n-\n-Then we can use `rn!()` like any other macro:\n-\n-```ignore\n-#![feature(plugin)]\n-#![plugin(roman_numerals)]\n-\n-fn main() {\n-    assert_eq!(rn!(MMXV), 2015);\n-}\n-```\n-\n-The advantages over a simple `fn(&str) -> u32` are:\n-\n-* The (arbitrarily complex) conversion is done at compile time.\n-* Input validation is also performed at compile time.\n-* It can be extended to allow use in patterns, which effectively gives\n-  a way to define new literal syntax for any data type.\n-\n-In addition to procedural macros, you can define new\n-[`derive`](../reference.html#derive)-like attributes and other kinds of\n-extensions.  See\n-[`Registry::register_syntax_extension`](../rustc/plugin/registry/struct.Registry.html#method.register_syntax_extension)\n-and the [`SyntaxExtension`\n-enum](http://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html).  For\n-a more involved macro example, see\n-[`regex_macros`](https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs).\n-\n-\n-## Tips and tricks\n-\n-Some of the [macro debugging tips](macros.html#debugging-macro-code) are applicable.\n-\n-You can use [`syntax::parse`](../syntax/parse/index.html) to turn token trees into\n-higher-level syntax elements like expressions:\n-\n-```ignore\n-fn expand_foo(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n-        -> Box<MacResult+'static> {\n-\n-    let mut parser = cx.new_parser_from_tts(args);\n-\n-    let expr: P<Expr> = parser.parse_expr();\n-```\n-\n-Looking through [`libsyntax` parser\n-code](https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs)\n-will give you a feel for how the parsing infrastructure works.\n-\n-Keep the [`Span`s](../syntax/codemap/struct.Span.html) of\n-everything you parse, for better error reporting. You can wrap\n-[`Spanned`](../syntax/codemap/struct.Spanned.html) around\n-your custom data structures.\n-\n-Calling\n-[`ExtCtxt::span_fatal`](../syntax/ext/base/struct.ExtCtxt.html#method.span_fatal)\n-will immediately abort compilation. It's better to instead call\n-[`ExtCtxt::span_err`](../syntax/ext/base/struct.ExtCtxt.html#method.span_err)\n-and return\n-[`DummyResult`](../syntax/ext/base/struct.DummyResult.html),\n-so that the compiler can continue and find further errors.\n-\n-To print syntax fragments for debugging, you can use\n-[`span_note`](../syntax/ext/base/struct.ExtCtxt.html#method.span_note) together\n-with\n-[`syntax::print::pprust::*_to_string`](http://doc.rust-lang.org/syntax/print/pprust/index.html#functions).\n-\n-The example above produced an integer literal using\n-[`AstBuilder::expr_usize`](../syntax/ext/build/trait.AstBuilder.html#tymethod.expr_usize).\n-As an alternative to the `AstBuilder` trait, `libsyntax` provides a set of\n-[quasiquote macros](../syntax/ext/quote/index.html).  They are undocumented and\n-very rough around the edges.  However, the implementation may be a good\n-starting point for an improved quasiquote as an ordinary plugin library.\n-\n-\n-# Lint plugins\n-\n-Plugins can extend [Rust's lint\n-infrastructure](../reference.html#lint-check-attributes) with additional checks for\n-code style, safety, etc. You can see\n-[`src/test/auxiliary/lint_plugin_test.rs`](https://github.com/rust-lang/rust/blob/master/src/test/auxiliary/lint_plugin_test.rs)\n-for a full example, the core of which is reproduced here:\n-\n-```ignore\n-declare_lint!(TEST_LINT, Warn,\n-              \"Warn about items named 'lintme'\")\n-\n-struct Pass;\n-\n-impl LintPass for Pass {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(TEST_LINT)\n-    }\n-\n-    fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        let name = token::get_ident(it.ident);\n-        if name.get() == \"lintme\" {\n-            cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n-        }\n-    }\n-}\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_lint_pass(box Pass as LintPassObject);\n-}\n-```\n-\n-Then code like\n-\n-```ignore\n-#![plugin(lint_plugin_test)]\n-\n-fn lintme() { }\n-```\n-\n-will produce a compiler warning:\n-\n-```txt\n-foo.rs:4:1: 4:16 warning: item is named 'lintme', #[warn(test_lint)] on by default\n-foo.rs:4 fn lintme() { }\n-         ^~~~~~~~~~~~~~~\n-```\n-\n-The components of a lint plugin are:\n-\n-* one or more `declare_lint!` invocations, which define static\n-  [`Lint`](../rustc/lint/struct.Lint.html) structs;\n-\n-* a struct holding any state needed by the lint pass (here, none);\n-\n-* a [`LintPass`](../rustc/lint/trait.LintPass.html)\n-  implementation defining how to check each syntax element. A single\n-  `LintPass` may call `span_lint` for several different `Lint`s, but should\n-  register them all through the `get_lints` method.\n-\n-Lint passes are syntax traversals, but they run at a late stage of compilation\n-where type information is available. `rustc`'s [built-in\n-lints](https://github.com/rust-lang/rust/blob/master/src/librustc/lint/builtin.rs)\n-mostly use the same infrastructure as lint plugins, and provide examples of how\n-to access type information.\n-\n-Lints defined by plugins are controlled by the usual [attributes and compiler\n-flags](../reference.html#lint-check-attributes), e.g. `#[allow(test_lint)]` or\n-`-A test-lint`. These identifiers are derived from the first argument to\n-`declare_lint!`, with appropriate case and punctuation conversion.\n-\n-You can run `rustc -W help foo.rs` to see a list of lints known to `rustc`,\n-including those provided by plugins loaded by `foo.rs`."}, {"sha": "1b3f2a5b7734cc2dcdc44fd10e678dea53f5817b", "filename": "src/doc/trpl/pointers.md", "status": "removed", "additions": 0, "deletions": 699, "changes": 699, "blob_url": "https://github.com/rust-lang/rust/blob/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "patch": "@@ -1,699 +0,0 @@\n-% Pointers\n-\n-Rust's pointers are one of its more unique and compelling features. Pointers\n-are also one of the more confusing topics for newcomers to Rust. They can also\n-be confusing for people coming from other languages that support pointers, such\n-as C++. This guide will help you understand this important topic.\n-\n-Be sceptical of non-reference pointers in Rust: use them for a deliberate\n-purpose, not just to make the compiler happy. Each pointer type comes with an\n-explanation about when they are appropriate to use. Default to references\n-unless you're in one of those specific situations.\n-\n-You may be interested in the [cheat sheet](#cheat-sheet), which gives a quick\n-overview of the types, names, and purpose of the various pointers.\n-\n-# An introduction\n-\n-If you aren't familiar with the concept of pointers, here's a short\n-introduction.  Pointers are a very fundamental concept in systems programming\n-languages, so it's important to understand them.\n-\n-## Pointer Basics\n-\n-When you create a new variable binding, you're giving a name to a value that's\n-stored at a particular location on the stack. (If you're not familiar with the\n-*heap* vs. *stack*, please check out [this Stack Overflow\n-question](http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap),\n-as the rest of this guide assumes you know the difference.) Like this:\n-\n-```{rust}\n-let x = 5;\n-let y = 8;\n-```\n-\n-| location | value |\n-|----------|-------|\n-| 0xd3e030 | 5\t   |\n-| 0xd3e028 | 8     |\n-\n-We're making up memory locations here, they're just sample values. Anyway, the\n-point is that `x`, the name we're using for our variable, corresponds to the\n-memory location `0xd3e030`, and the value at that location is `5`. When we\n-refer to `x`, we get the corresponding value. Hence, `x` is `5`.\n-\n-Let's introduce a pointer. In some languages, there is just one type of\n-'pointer,' but in Rust, we have many types. In this case, we'll use a Rust\n-*reference*, which is the simplest kind of pointer.\n-\n-```{rust}\n-let x = 5;\n-let y = 8;\n-let z = &y;\n-```\n-\n-|location | value    |\n-|-------- |----------|\n-|0xd3e030 | 5        |\n-|0xd3e028 | 8        |\n-|0xd3e020 | 0xd3e028 |\n-\n-See the difference? Rather than contain a value, the value of a pointer is a\n-location in memory. In this case, the location of `y`. `x` and `y` have the\n-type `i32`, but `z` has the type `&i32`. We can print this location using the\n-`{:p}` format string:\n-\n-```{rust}\n-let x = 5;\n-let y = 8;\n-let z = &y;\n-\n-println!(\"{:p}\", z);\n-```\n-\n-This would print `0xd3e028`, with our fictional memory addresses.\n-\n-Because `i32` and `&i32` are different types, we can't, for example, add them\n-together:\n-\n-```{rust,ignore}\n-let x = 5;\n-let y = 8;\n-let z = &y;\n-\n-println!(\"{}\", x + z);\n-```\n-\n-This gives us an error:\n-\n-```text\n-hello.rs:6:24: 6:25 error: mismatched types: expected `_`, found `&_` (expected integral variable, found &-ptr)\n-hello.rs:6     println!(\"{}\", x + z);\n-                                  ^\n-```\n-\n-We can *dereference* the pointer by using the `*` operator. Dereferencing a\n-pointer means accessing the value at the location stored in the pointer. This\n-will work:\n-\n-```{rust}\n-let x = 5;\n-let y = 8;\n-let z = &y;\n-\n-println!(\"{}\", x + *z);\n-```\n-\n-It prints `13`.\n-\n-That's it! That's all pointers are: they point to some memory location. Not\n-much else to them. Now that we've discussed the *what* of pointers, let's\n-talk about the *why*.\n-\n-## Pointer uses\n-\n-Rust's pointers are quite useful, but in different ways than in other systems\n-languages. We'll talk about best practices for Rust pointers later in\n-the guide, but here are some ways that pointers are useful in other languages:\n-\n-In C, strings are a pointer to a list of `char`s, ending with a null byte.\n-The only way to use strings is to get quite familiar with pointers.\n-\n-Pointers are useful to point to memory locations that are not on the stack. For\n-example, our example used two stack variables, so we were able to give them\n-names. But if we allocated some heap memory, we wouldn't have that name\n-available.  In C, `malloc` is used to allocate heap memory, and it returns a\n-pointer.\n-\n-As a more general variant of the previous two points, any time you have a\n-structure that can change in size, you need a pointer. You can't tell at\n-compile time how much memory to allocate, so you've gotta use a pointer to\n-point at the memory where it will be allocated, and deal with it at run time.\n-\n-Pointers are useful in languages that are pass-by-value, rather than\n-pass-by-reference. Basically, languages can make two choices (this is made\n-up syntax, it's not Rust):\n-\n-```text\n-func foo(x) {\n-    x = 5\n-}\n-\n-func main() {\n-    i = 1\n-    foo(i)\n-    // what is the value of i here?\n-}\n-```\n-\n-In languages that are pass-by-value, `foo` will get a copy of `i`, and so\n-the original version of `i` is not modified. At the comment, `i` will still be\n-`1`. In a language that is pass-by-reference, `foo` will get a reference to `i`,\n-and therefore, can change its value. At the comment, `i` will be `5`.\n-\n-So what do pointers have to do with this? Well, since pointers point to a\n-location in memory...\n-\n-```text\n-func foo(&i32 x) {\n-    *x = 5\n-}\n-\n-func main() {\n-    i = 1\n-    foo(&i)\n-    // what is the value of i here?\n-}\n-```\n-\n-Even in a language which is pass by value, `i` will be `5` at the comment. You\n-see, because the argument `x` is a pointer, we do send a copy over to `foo`,\n-but because it points at a memory location, which we then assign to, the\n-original value is still changed. This pattern is called\n-*pass-reference-by-value*. Tricky!\n-\n-## Common pointer problems\n-\n-We've talked about pointers, and we've sung their praises. So what's the\n-downside? Well, Rust attempts to mitigate each of these kinds of problems,\n-but here are problems with pointers in other languages:\n-\n-Uninitialized pointers can cause a problem. For example, what does this program\n-do?\n-\n-```{ignore}\n-&int x;\n-*x = 5; // whoops!\n-```\n-\n-Who knows? We just declare a pointer, but don't point it at anything, and then\n-set the memory location that it points at to be `5`. But which location? Nobody\n-knows. This might be harmless, and it might be catastrophic.\n-\n-When you combine pointers and functions, it's easy to accidentally invalidate\n-the memory the pointer is pointing to. For example:\n-\n-```text\n-func make_pointer(): &int {\n-    x = 5;\n-\n-    return &x;\n-}\n-\n-func main() {\n-    &int i = make_pointer();\n-    *i = 5; // uh oh!\n-}\n-```\n-\n-`x` is local to the `make_pointer` function, and therefore, is invalid as soon\n-as `make_pointer` returns. But we return a pointer to its memory location, and\n-so back in `main`, we try to use that pointer, and it's a very similar\n-situation to our first one. Setting invalid memory locations is bad.\n-\n-As one last example of a big problem with pointers, *aliasing* can be an\n-issue. Two pointers are said to alias when they point at the same location\n-in memory. Like this:\n-\n-```text\n-func mutate(&int i, int j) {\n-    *i = j;\n-}\n-\n-func main() {\n-  x = 5;\n-  y = &x;\n-  z = &x; //y and z are aliased\n-\n-\n-  run_in_new_thread(mutate, y, 1);\n-  run_in_new_thread(mutate, z, 100);\n-\n-  // what is the value of x here?\n-}\n-```\n-\n-In this made-up example, `run_in_new_thread` spins up a new thread, and calls\n-the given function name with its arguments. Since we have two threads, and\n-they're both operating on aliases to `x`, we can't tell which one finishes\n-first, and therefore, the value of `x` is actually non-deterministic. Worse,\n-what if one of them had invalidated the memory location they pointed to? We'd\n-have the same problem as before, where we'd be setting an invalid location.\n-\n-## Conclusion\n-\n-That's a basic overview of pointers as a general concept. As we alluded to\n-before, Rust has different kinds of pointers, rather than just one, and\n-mitigates all of the problems that we talked about, too. This does mean that\n-Rust pointers are slightly more complicated than in other languages, but\n-it's worth it to not have the problems that simple pointers have.\n-\n-# References\n-\n-The most basic type of pointer that Rust has is called a *reference*. Rust\n-references look like this:\n-\n-```{rust}\n-let x = 5;\n-let y = &x;\n-\n-println!(\"{}\", *y);\n-println!(\"{:p}\", y);\n-println!(\"{}\", y);\n-```\n-\n-We'd say \"`y` is a reference to `x`.\" The first `println!` prints out the\n-value of `y`'s referent by using the dereference operator, `*`. The second\n-one prints out the memory location that `y` points to, by using the pointer\n-format string. The third `println!` *also* prints out the value of `y`'s\n-referent, because `println!` will automatically dereference it for us.\n-\n-Here's a function that takes a reference:\n-\n-```{rust}\n-fn succ(x: &i32) -> i32 { *x + 1 }\n-```\n-\n-You can also use `&` as an operator to create a reference, so we can\n-call this function in two different ways:\n-\n-```{rust}\n-fn succ(x: &i32) -> i32 { *x + 1 }\n-\n-fn main() {\n-\n-    let x = 5;\n-    let y = &x;\n-\n-    println!(\"{}\", succ(y));\n-    println!(\"{}\", succ(&x));\n-}\n-```\n-\n-Both of these `println!`s will print out `6`.\n-\n-Of course, if this were real code, we wouldn't bother with the reference, and\n-just write:\n-\n-```{rust}\n-fn succ(x: i32) -> i32 { x + 1 }\n-```\n-\n-References are immutable by default:\n-\n-```{rust,ignore}\n-let x = 5;\n-let y = &x;\n-\n-*y = 5; // error: cannot assign to immutable borrowed content `*y`\n-```\n-\n-They can be made mutable with `mut`, but only if its referent is also mutable.\n-This works:\n-\n-```{rust}\n-let mut x = 5;\n-let y = &mut x;\n-```\n-\n-This does not:\n-\n-```{rust,ignore}\n-let x = 5;\n-let y = &mut x; // error: cannot borrow immutable local variable `x` as mutable\n-```\n-\n-Immutable pointers are allowed to alias:\n-\n-```{rust}\n-let x = 5;\n-let y = &x;\n-let z = &x;\n-```\n-\n-Mutable ones, however, are not:\n-\n-```{rust,ignore}\n-let mut x = 5;\n-let y = &mut x;\n-let z = &mut x; // error: cannot borrow `x` as mutable more than once at a time\n-```\n-\n-Despite their complete safety, a reference's representation at runtime is the\n-same as that of an ordinary pointer in a C program. They introduce zero\n-overhead. The compiler does all safety checks at compile time. The theory that\n-allows for this was originally called *region pointers*. Region pointers\n-evolved into what we know today as *lifetimes*.\n-\n-Here's the simple explanation: would you expect this code to compile?\n-\n-```{rust,ignore}\n-fn main() {\n-    println!(\"{}\", x);\n-    let x = 5;\n-}\n-```\n-\n-Probably not. That's because you know that the name `x` is valid from where\n-it's declared to when it goes out of scope. In this case, that's the end of\n-the `main` function. So you know this code will cause an error. We call this\n-duration a *lifetime*. Let's try a more complex example:\n-\n-```{rust}\n-fn main() {\n-    let mut x = 5;\n-\n-    if x < 10 {\n-        let y = &x;\n-\n-        println!(\"Oh no: {}\", y);\n-        return;\n-    }\n-\n-    x -= 1;\n-\n-    println!(\"Oh no: {}\", x);\n-}\n-```\n-\n-Here, we're borrowing a pointer to `x` inside of the `if`. The compiler, however,\n-is able to determine that that pointer will go out of scope without `x` being\n-mutated, and therefore, lets us pass. This wouldn't work:\n-\n-```{rust,ignore}\n-fn main() {\n-    let mut x = 5;\n-\n-    if x < 10 {\n-        let y = &x;\n-\n-        x -= 1;\n-\n-        println!(\"Oh no: {}\", y);\n-        return;\n-    }\n-\n-    x -= 1;\n-\n-    println!(\"Oh no: {}\", x);\n-}\n-```\n-\n-It gives this error:\n-\n-```text\n-test.rs:7:9: 7:15 error: cannot assign to `x` because it is borrowed\n-test.rs:7         x -= 1;\n-                  ^~~~~~\n-test.rs:5:18: 5:19 note: borrow of `x` occurs here\n-test.rs:5         let y = &x;\n-                           ^\n-```\n-\n-As you might guess, this kind of analysis is complex for a human, and therefore\n-hard for a computer, too! There is an entire [guide devoted to references, ownership,\n-and lifetimes](ownership.html) that goes into this topic in\n-great detail, so if you want the full details, check that out.\n-\n-## Best practices\n-\n-In general, prefer stack allocation over heap allocation. Using references to\n-stack allocated information is preferred whenever possible. Therefore,\n-references are the default pointer type you should use, unless you have a\n-specific reason to use a different type. The other types of pointers cover when\n-they're appropriate to use in their own best practices sections.\n-\n-Use references when you want to use a pointer, but do not want to take ownership.\n-References just borrow ownership, which is more polite if you don't need the\n-ownership. In other words, prefer:\n-\n-```{rust}\n-fn succ(x: &i32) -> i32 { *x + 1 }\n-```\n-\n-to\n-\n-```{rust}\n-fn succ(x: Box<i32>) -> i32 { *x + 1 }\n-```\n-\n-As a corollary to that rule, references allow you to accept a wide variety of\n-other pointers, and so are useful so that you don't have to write a number\n-of variants per pointer. In other words, prefer:\n-\n-```{rust}\n-fn succ(x: &i32) -> i32 { *x + 1 }\n-```\n-\n-to\n-\n-```{rust}\n-use std::rc::Rc;\n-\n-fn box_succ(x: Box<i32>) -> i32 { *x + 1 }\n-\n-fn rc_succ(x: Rc<i32>) -> i32 { *x + 1 }\n-```\n-\n-Note that the caller of your function will have to modify their calls slightly:\n-\n-```{rust}\n-use std::rc::Rc;\n-\n-fn succ(x: &i32) -> i32 { *x + 1 }\n-\n-let ref_x = &5;\n-let box_x = Box::new(5);\n-let rc_x = Rc::new(5);\n-\n-succ(ref_x);\n-succ(&*box_x);\n-succ(&*rc_x);\n-```\n-\n-The initial `*` dereferences the pointer, and then `&` takes a reference to\n-those contents.\n-\n-# Boxes\n-\n-`Box<T>` is Rust's *boxed pointer* type. Boxes provide the simplest form of\n-heap allocation in Rust. Creating a box looks like this:\n-\n-```{rust}\n-let x = Box::new(5);\n-```\n-\n-Boxes are heap allocated and they are deallocated automatically by Rust when\n-they go out of scope:\n-\n-```{rust}\n-{\n-    let x = Box::new(5);\n-\n-    // stuff happens\n-\n-} // x is destructed and its memory is free'd here\n-```\n-\n-However, boxes do _not_ use reference counting or garbage collection. Boxes are\n-what's called an *affine type*. This means that the Rust compiler, at compile\n-time, determines when the box comes into and goes out of scope, and inserts the\n-appropriate calls there.\n-\n-You don't need to fully grok the theory of affine types to grok boxes, though.\n-As a rough approximation, you can treat this Rust code:\n-\n-```{rust}\n-{\n-    let x = Box::new(5);\n-\n-    // stuff happens\n-}\n-```\n-\n-As being similar to this C code:\n-\n-```c\n-{\n-    int *x;\n-    x = (int *)malloc(sizeof(int));\n-    *x = 5;\n-\n-    // stuff happens\n-\n-    free(x);\n-}\n-```\n-\n-Of course, this is a 10,000 foot view. It leaves out destructors, for example.\n-But the general idea is correct: you get the semantics of `malloc`/`free`, but\n-with some improvements:\n-\n-1. It's impossible to allocate the incorrect amount of memory, because Rust\n-   figures it out from the types.\n-2. You cannot forget to `free` memory you've allocated, because Rust does it\n-   for you.\n-3. Rust ensures that this `free` happens at the right time, when it is truly\n-   not used. Use-after-free is not possible.\n-4. Rust enforces that no other writeable pointers alias to this heap memory,\n-   which means writing to an invalid pointer is not possible.\n-\n-See the section on references or the [ownership guide](ownership.html)\n-for more detail on how lifetimes work.\n-\n-Using boxes and references together is very common. For example:\n-\n-```{rust}\n-fn add_one(x: &i32) -> i32 {\n-    *x + 1\n-}\n-\n-fn main() {\n-    let x = Box::new(5);\n-\n-    println!(\"{}\", add_one(&*x));\n-}\n-```\n-\n-In this case, Rust knows that `x` is being *borrowed* by the `add_one()`\n-function, and since it's only reading the value, allows it.\n-\n-We can borrow `x` as read-only multiple times, even simultaneously:\n-\n-```{rust}\n-fn add(x: &i32, y: &i32) -> i32 {\n-    *x + *y\n-}\n-\n-fn main() {\n-    let x = Box::new(5);\n-\n-    println!(\"{}\", add(&*x, &*x));\n-    println!(\"{}\", add(&*x, &*x));\n-}\n-```\n-\n-We can mutably borrow `x` multiple times, but only if x itself is mutable, and\n-it may not be *simultaneously* borrowed:\n-\n-```{rust,ignore}\n-fn increment(x: &mut i32) {\n-    *x += 1;\n-}\n-\n-fn main() {\n-    // If variable x is not \"mut\", this will not compile\n-    let mut x = Box::new(5);\n-\n-    increment(&mut x);\n-    increment(&mut x);\n-    println!(\"{}\", x);\n-}\n-```\n-\n-Notice the signature of `increment()` requests a mutable reference.\n-\n-## Best practices\n-\n-Boxes are most appropriate to use when defining recursive data structures.\n-\n-### Recursive data structures\n-\n-Sometimes, you need a recursive data structure. The simplest is known as a\n-*cons list*:\n-\n-\n-```{rust}\n-#[derive(Debug)]\n-enum List<T> {\n-    Cons(T, Box<List<T>>),\n-    Nil,\n-}\n-\n-fn main() {\n-    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, Box::new(List::Nil))))));\n-    println!(\"{:?}\", list);\n-}\n-```\n-\n-This prints:\n-\n-```text\n-Cons(1, Box(Cons(2, Box(Cons(3, Box(Nil))))))\n-```\n-\n-The reference to another `List` inside of the `Cons` enum variant must be a box,\n-because we don't know the length of the list. Because we don't know the length,\n-we don't know the size, and therefore, we need to heap allocate our list.\n-\n-Working with recursive or other unknown-sized data structures is the primary\n-use-case for boxes.\n-\n-# Rc and Arc\n-\n-This part is coming soon.\n-\n-## Best practices\n-\n-This part is coming soon.\n-\n-# Raw Pointers\n-\n-This part is coming soon.\n-\n-## Best practices\n-\n-This part is coming soon.\n-\n-# Creating your own Pointers\n-\n-This part is coming soon.\n-\n-## Best practices\n-\n-This part is coming soon.\n-\n-# Patterns and `ref`\n-\n-When you're trying to match something that's stored in a pointer, there may be\n-a situation where matching directly isn't the best option available. Let's see\n-how to properly handle this:\n-\n-```{rust,ignore}\n-fn possibly_print(x: &Option<String>) {\n-    match *x {\n-        // BAD: cannot move out of a `&`\n-        Some(s) => println!(\"{}\", s)\n-\n-        // GOOD: instead take a reference into the memory of the `Option`\n-        Some(ref s) => println!(\"{}\", *s),\n-        None => {}\n-    }\n-}\n-```\n-\n-The `ref s` here means that `s` will be of type `&String`, rather than type\n-`String`.\n-\n-This is important when the type you're trying to get access to has a destructor\n-and you don't want to move it, you just want a reference to it.\n-\n-# Cheat Sheet\n-\n-Here's a quick rundown of Rust's pointer types:\n-\n-| Type         | Name                | Summary                                                             |\n-|--------------|---------------------|---------------------------------------------------------------------|\n-| `&T`         | Reference           | Allows one or more references to read `T`                           |\n-| `&mut T`     | Mutable Reference   | Allows a single reference to read and write `T`                     |\n-| `Box<T>`     | Box                 | Heap allocated `T` with a single owner that may read and write `T`. |\n-| `Rc<T>`      | \"arr cee\" pointer   | Heap allocated `T` with many readers                                |\n-| `Arc<T>`     | Arc pointer         | Same as above, but safe sharing across threads                      |\n-| `*const T`   | Raw pointer         | Unsafe read access to `T`                                           |\n-| `*mut T`     | Mutable raw pointer | Unsafe read and write access to `T`                                 |\n-\n-# Related resources\n-\n-* [API documentation for Box](../std/boxed/index.html)\n-* [Ownership guide](ownership.html)\n-* [Cyclone paper on regions](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf), which inspired Rust's lifetime system"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/primitive-types.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fprimitive-types.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/references-and-borrowing.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/slices.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fslices.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fslices.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fslices.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "a7794814156e63fd330d21713d219cff2d7fd550", "filename": "src/doc/trpl/static-and-dynamic-dispatch.md", "status": "removed", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md?ref=d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "patch": "@@ -1,306 +0,0 @@\n-% Static and Dynamic Dispatch\n-\n-When code involves polymorphism, there needs to be a mechanism to determine\n-which specific version is actually run. This is called 'dispatch.' There are\n-two major forms of dispatch: static dispatch and dynamic dispatch. While Rust\n-favors static dispatch, it also supports dynamic dispatch through a mechanism\n-called 'trait objects.'\n-\n-## Background\n-\n-For the rest of this chapter, we'll need a trait and some implementations.\n-Let's make a simple one, `Foo`. It has one method that is expected to return a\n-`String`.\n-\n-```rust\n-trait Foo {\n-    fn method(&self) -> String;\n-}\n-```\n-\n-We'll also implement this trait for `u8` and `String`:\n-\n-```rust\n-# trait Foo { fn method(&self) -> String; }\n-impl Foo for u8 {\n-    fn method(&self) -> String { format!(\"u8: {}\", *self) }\n-}\n-\n-impl Foo for String {\n-    fn method(&self) -> String { format!(\"string: {}\", *self) }\n-}\n-```\n-\n-\n-## Static dispatch\n-\n-We can use this trait to perform static dispatch with trait bounds:\n-\n-```rust\n-# trait Foo { fn method(&self) -> String; }\n-# impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n-# impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n-fn do_something<T: Foo>(x: T) {\n-    x.method();\n-}\n-\n-fn main() {\n-    let x = 5u8;\n-    let y = \"Hello\".to_string();\n-\n-    do_something(x);\n-    do_something(y);\n-}\n-```\n-\n-Rust uses 'monomorphization' to perform static dispatch here. This means that\n-Rust will create a special version of `do_something()` for both `u8` and\n-`String`, and then replace the call sites with calls to these specialized\n-functions. In other words, Rust generates something like this:\n-\n-```rust\n-# trait Foo { fn method(&self) -> String; }\n-# impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n-# impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n-fn do_something_u8(x: u8) {\n-    x.method();\n-}\n-\n-fn do_something_string(x: String) {\n-    x.method();\n-}\n-\n-fn main() {\n-    let x = 5u8;\n-    let y = \"Hello\".to_string();\n-\n-    do_something_u8(x);\n-    do_something_string(y);\n-}\n-```\n-\n-This has a great upside: static dispatch allows function calls to be\n-inlined because the callee is known at compile time, and inlining is\n-the key to good optimization. Static dispatch is fast, but it comes at\n-a tradeoff: 'code bloat', due to many copies of the same function\n-existing in the binary, one for each type.\n-\n-Furthermore, compilers aren\u2019t perfect and may \u201coptimize\u201d code to become slower.\n-For example, functions inlined too eagerly will bloat the instruction cache\n-(cache rules everything around us). This is part of the reason that `#[inline]`\n-and `#[inline(always)]` should be used carefully, and one reason why using a\n-dynamic dispatch is sometimes more efficient.\n-\n-However, the common case is that it is more efficient to use static dispatch,\n-and one can always have a thin statically-dispatched wrapper function that does\n-a dynamic dispatch, but not vice versa, meaning static calls are more flexible.\n-The standard library tries to be statically dispatched where possible for this\n-reason.\n-\n-## Dynamic dispatch\n-\n-Rust provides dynamic dispatch through a feature called 'trait objects.' Trait\n-objects, like `&Foo` or `Box<Foo>`, are normal values that store a value of\n-*any* type that implements the given trait, where the precise type can only be\n-known at runtime.\n-\n-A trait object can be obtained from a pointer to a concrete type that\n-implements the trait by *casting* it (e.g. `&x as &Foo`) or *coercing* it\n-(e.g. using `&x` as an argument to a function that takes `&Foo`).\n-\n-These trait object coercions and casts also work for pointers like `&mut T` to\n-`&mut Foo` and `Box<T>` to `Box<Foo>`, but that's all at the moment. Coercions\n-and casts are identical.\n-\n-This operation can be seen as \"erasing\" the compiler's knowledge about the\n-specific type of the pointer, and hence trait objects are sometimes referred to\n-as \"type erasure\".\n-\n-Coming back to the example above, we can use the same trait to perform dynamic\n-dispatch with trait objects by casting:\n-\n-```rust\n-# trait Foo { fn method(&self) -> String; }\n-# impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n-# impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n-\n-fn do_something(x: &Foo) {\n-    x.method();\n-}\n-\n-fn main() {\n-    let x = 5u8;\n-    do_something(&x as &Foo);\n-}\n-```\n-\n-or by coercing:\n-\n-```rust\n-# trait Foo { fn method(&self) -> String; }\n-# impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n-# impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n-\n-fn do_something(x: &Foo) {\n-    x.method();\n-}\n-\n-fn main() {\n-    let x = \"Hello\".to_string();\n-    do_something(&x);\n-}\n-```\n-\n-A function that takes a trait object is not specialized to each of the types\n-that implements `Foo`: only one copy is generated, often (but not always)\n-resulting in less code bloat. However, this comes at the cost of requiring\n-slower virtual function calls, and effectively inhibiting any chance of\n-inlining and related optimisations from occurring.\n-\n-### Why pointers?\n-\n-Rust does not put things behind a pointer by default, unlike many managed\n-languages, so types can have different sizes. Knowing the size of the value at\n-compile time is important for things like passing it as an argument to a\n-function, moving it about on the stack and allocating (and deallocating) space\n-on the heap to store it.\n-\n-For `Foo`, we would need to have a value that could be at least either a\n-`String` (24 bytes) or a `u8` (1 byte), as well as any other type for which\n-dependent crates may implement `Foo` (any number of bytes at all). There's no\n-way to guarantee that this last point can work if the values are stored without\n-a pointer, because those other types can be arbitrarily large.\n-\n-Putting the value behind a pointer means the size of the value is not relevant\n-when we are tossing a trait object around, only the size of the pointer itself.\n-\n-### Representation\n-\n-The methods of the trait can be called on a trait object via a special record\n-of function pointers traditionally called a 'vtable' (created and managed by\n-the compiler).\n-\n-Trait objects are both simple and complicated: their core representation and\n-layout is quite straight-forward, but there are some curly error messages and\n-surprising behaviors to discover.\n-\n-Let's start simple, with the runtime representation of a trait object. The\n-`std::raw` module contains structs with layouts that are the same as the\n-complicated built-in types, [including trait objects][stdraw]:\n-\n-```rust\n-# mod foo {\n-pub struct TraitObject {\n-    pub data: *mut (),\n-    pub vtable: *mut (),\n-}\n-# }\n-```\n-\n-[stdraw]: ../std/raw/struct.TraitObject.html\n-\n-That is, a trait object like `&Foo` consists of a \"data\" pointer and a \"vtable\"\n-pointer.\n-\n-The data pointer addresses the data (of some unknown type `T`) that the trait\n-object is storing, and the vtable pointer points to the vtable (\"virtual method\n-table\") corresponding to the implementation of `Foo` for `T`.\n-\n-\n-A vtable is essentially a struct of function pointers, pointing to the concrete\n-piece of machine code for each method in the implementation. A method call like\n-`trait_object.method()` will retrieve the correct pointer out of the vtable and\n-then do a dynamic call of it. For example:\n-\n-```{rust,ignore}\n-struct FooVtable {\n-    destructor: fn(*mut ()),\n-    size: usize,\n-    align: usize,\n-    method: fn(*const ()) -> String,\n-}\n-\n-// u8:\n-\n-fn call_method_on_u8(x: *const ()) -> String {\n-    // the compiler guarantees that this function is only called\n-    // with `x` pointing to a u8\n-    let byte: &u8 = unsafe { &*(x as *const u8) };\n-\n-    byte.method()\n-}\n-\n-static Foo_for_u8_vtable: FooVtable = FooVtable {\n-    destructor: /* compiler magic */,\n-    size: 1,\n-    align: 1,\n-\n-    // cast to a function pointer\n-    method: call_method_on_u8 as fn(*const ()) -> String,\n-};\n-\n-\n-// String:\n-\n-fn call_method_on_String(x: *const ()) -> String {\n-    // the compiler guarantees that this function is only called\n-    // with `x` pointing to a String\n-    let string: &String = unsafe { &*(x as *const String) };\n-\n-    string.method()\n-}\n-\n-static Foo_for_String_vtable: FooVtable = FooVtable {\n-    destructor: /* compiler magic */,\n-    // values for a 64-bit computer, halve them for 32-bit ones\n-    size: 24,\n-    align: 8,\n-\n-    method: call_method_on_String as fn(*const ()) -> String,\n-};\n-```\n-\n-The `destructor` field in each vtable points to a function that will clean up\n-any resources of the vtable's type, for `u8` it is trivial, but for `String` it\n-will free the memory. This is necessary for owning trait objects like\n-`Box<Foo>`, which need to clean-up both the `Box` allocation as well as the\n-internal type when they go out of scope. The `size` and `align` fields store\n-the size of the erased type, and its alignment requirements; these are\n-essentially unused at the moment since the information is embedded in the\n-destructor, but will be used in the future, as trait objects are progressively\n-made more flexible.\n-\n-Suppose we've got some values that implement `Foo`, then the explicit form of\n-construction and use of `Foo` trait objects might look a bit like (ignoring the\n-type mismatches: they're all just pointers anyway):\n-\n-```{rust,ignore}\n-let a: String = \"foo\".to_string();\n-let x: u8 = 1;\n-\n-// let b: &Foo = &a;\n-let b = TraitObject {\n-    // store the data\n-    data: &a,\n-    // store the methods\n-    vtable: &Foo_for_String_vtable\n-};\n-\n-// let y: &Foo = x;\n-let y = TraitObject {\n-    // store the data\n-    data: &x,\n-    // store the methods\n-    vtable: &Foo_for_u8_vtable\n-};\n-\n-// b.method();\n-(b.vtable.method)(b.data);\n-\n-// y.method();\n-(y.vtable.method)(y.data);\n-```\n-\n-If `b` or `y` were owning trait objects (`Box<Foo>`), there would be a\n-`(b.vtable.destructor)(b.data)` (respectively `y`) call when they went out of\n-scope."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/static.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fstatic.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fstatic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstatic.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/strings.md", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstrings.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,61 +0,0 @@\n-% Strings\n-\n-Strings are an important concept for any programmer to master. Rust's string\n-handling system is a bit different from other languages, due to its systems\n-focus. Any time you have a data structure of variable size, things can get\n-tricky, and strings are a re-sizable data structure. That being said, Rust's\n-strings also work differently than in some other systems languages, such as C.\n-\n-Let's dig into the details. A *string* is a sequence of Unicode scalar values\n-encoded as a stream of UTF-8 bytes. All strings are guaranteed to be\n-validly encoded UTF-8 sequences. Additionally, strings are not null-terminated\n-and can contain null bytes.\n-\n-Rust has two main types of strings: `&str` and `String`.\n-\n-The first kind is a `&str`. These are called *string slices*. String literals\n-are of the type `&str`:\n-\n-```{rust}\n-let string = \"Hello there.\"; // string: &str\n-```\n-\n-This string is statically allocated, meaning that it's saved inside our\n-compiled program, and exists for the entire duration it runs. The `string`\n-binding is a reference to this statically allocated string. String slices\n-have a fixed size, and cannot be mutated.\n-\n-A `String`, on the other hand, is a heap-allocated string. This string\n-is growable, and is also guaranteed to be UTF-8. `String`s are\n-commonly created by converting from a string slice using the\n-`to_string` method.\n-\n-```{rust}\n-let mut s = \"Hello\".to_string(); // mut s: String\n-println!(\"{}\", s);\n-\n-s.push_str(\", world.\");\n-println!(\"{}\", s);\n-```\n-\n-`String`s will coerce into `&str` with an `&`:\n-\n-```\n-fn takes_slice(slice: &str) {\n-    println!(\"Got: {}\", slice);\n-}\n-\n-fn main() {\n-    let s = \"Hello\".to_string();\n-    takes_slice(&s);\n-}\n-```\n-\n-Viewing a `String` as a `&str` is cheap, but converting the `&str` to a\n-`String` involves allocating memory. No reason to do that unless you have to!\n-\n-That's the basics of strings in Rust! They're probably a bit more complicated\n-than you are used to, if you come from a scripting language, but when the\n-low-level details matter, they really matter. Just remember that `String`s\n-allocate memory and control their data, while `&str`s are a reference to\n-another string, and you'll be all set."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/structs.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fstructs.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fstructs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstructs.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/syntax-and-semantics.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fsyntax-and-semantics.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fsyntax-and-semantics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fsyntax-and-semantics.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 0, "deletions": 432, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,432 +0,0 @@\n-% Testing\n-\n-> Program testing can be a very effective way to show the presence of bugs, but\n-> it is hopelessly inadequate for showing their absence.\n->\n-> Edsger W. Dijkstra, \"The Humble Programmer\" (1972)\n-\n-Let's talk about how to test Rust code. What we will not be talking about is\n-the right way to test Rust code. There are many schools of thought regarding\n-the right and wrong way to write tests. All of these approaches use the same\n-basic tools, and so we'll show you the syntax for using them.\n-\n-# The `test` attribute\n-\n-At its simplest, a test in Rust is a function that's annotated with the `test`\n-attribute. Let's make a new project with Cargo called `adder`:\n-\n-```bash\n-$ cargo new adder\n-$ cd adder\n-```\n-\n-Cargo will automatically generate a simple test when you make a new project.\n-Here's the contents of `src/lib.rs`:\n-\n-```rust\n-#[test]\n-fn it_works() {\n-}\n-```\n-\n-Note the `#[test]`. This attribute indicates that this is a test function. It\n-currently has no body. That's good enough to pass! We can run the tests with\n-`cargo test`:\n-\n-```bash\n-$ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n-\n-running 1 test\n-test it_works ... ok\n-\n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n-\n-   Doc-tests adder\n-\n-running 0 tests\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n-```\n-\n-Cargo compiled and ran our tests. There are two sets of output here: one\n-for the test we wrote, and another for documentation tests. We'll talk about\n-those later. For now, see this line:\n-\n-```text\n-test it_works ... ok\n-```\n-\n-Note the `it_works`. This comes from the name of our function:\n-\n-```rust\n-fn it_works() {\n-# }\n-```\n-\n-We also get a summary line:\n-\n-```text\n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n-```\n-\n-So why does our do-nothing test pass? Any test which doesn't `panic!` passes,\n-and any test that does `panic!` fails. Let's make our test fail:\n-\n-```rust\n-#[test]\n-fn it_works() {\n-    assert!(false);\n-}\n-```\n-\n-`assert!` is a macro provided by Rust which takes one argument: if the argument\n-is `true`, nothing happens. If the argument is false, it `panic!`s. Let's run\n-our tests again:\n-\n-```bash\n-$ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n-\n-running 1 test\n-test it_works ... FAILED\n-\n-failures:\n-\n----- it_works stdout ----\n-        thread 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3\n-\n-\n-\n-failures:\n-    it_works\n-\n-test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n-\n-thread '<main>' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247\n-```\n-\n-Rust indicates that our test failed:\n-\n-```text\n-test it_works ... FAILED\n-```\n-\n-And that's reflected in the summary line:\n-\n-```text\n-test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n-```\n-\n-We also get a non-zero status code:\n-\n-```bash\n-$ echo $?\n-101\n-```\n-\n-This is useful if you want to integrate `cargo test` into other tooling.\n-\n-We can invert our test's failure with another attribute: `should_panic`:\n-\n-```rust\n-#[test]\n-#[should_panic]\n-fn it_works() {\n-    assert!(false);\n-}\n-```\n-\n-This test will now succeed if we `panic!` and fail if we complete. Let's try it:\n-\n-```bash\n-$ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n-\n-running 1 test\n-test it_works ... ok\n-\n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n-\n-   Doc-tests adder\n-\n-running 0 tests\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n-```\n-\n-Rust provides another macro, `assert_eq!`, that compares two arguments for\n-equality:\n-\n-```rust\n-#[test]\n-#[should_panic]\n-fn it_works() {\n-    assert_eq!(\"Hello\", \"world\");\n-}\n-```\n-\n-Does this test pass or fail? Because of the `should_panic` attribute, it\n-passes:\n-\n-```bash\n-$ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n-\n-running 1 test\n-test it_works ... ok\n-\n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n-\n-   Doc-tests adder\n-\n-running 0 tests\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n-```\n-\n-`should_panic` tests can be fragile, as it's hard to guarantee that the test\n-didn't fail for an unexpected reason. To help with this, an optional `expected`\n-parameter can be added to the `should_panic` attribute. The test harness will\n-make sure that the failure message contains the provided text. A safer version\n-of the example above would be:\n-\n-```\n-#[test]\n-#[should_panic(expected = \"assertion failed\")]\n-fn it_works() {\n-    assert_eq!(\"Hello\", \"world\");\n-}\n-```\n-\n-That's all there is to the basics! Let's write one 'real' test:\n-\n-```{rust,ignore}\n-pub fn add_two(a: i32) -> i32 {\n-    a + 2\n-}\n-\n-#[test]\n-fn it_works() {\n-    assert_eq!(4, add_two(2));\n-}\n-```\n-\n-This is a very common use of `assert_eq!`: call some function with\n-some known arguments and compare it to the expected output.\n-\n-# The `test` module\n-\n-There is one way in which our existing example is not idiomatic: it's\n-missing the test module. The idiomatic way of writing our example\n-looks like this:\n-\n-```{rust,ignore}\n-pub fn add_two(a: i32) -> i32 {\n-    a + 2\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::add_two;\n-\n-    #[test]\n-    fn it_works() {\n-        assert_eq!(4, add_two(2));\n-    }\n-}\n-```\n-\n-There's a few changes here. The first is the introduction of a `mod test` with\n-a `cfg` attribute. The module allows us to group all of our tests together, and\n-to also define helper functions if needed, that don't become a part of the rest\n-of our crate. The `cfg` attribute only compiles our test code if we're\n-currently trying to run the tests. This can save compile time, and also ensures\n-that our tests are entirely left out of a normal build.\n-\n-The second change is the `use` declaration. Because we're in an inner module,\n-we need to bring our test function into scope. This can be annoying if you have\n-a large module, and so this is a common use of the `glob` feature. Let's change\n-our `src/lib.rs` to make use of it:\n-\n-```{rust,ignore}\n-\n-pub fn add_two(a: i32) -> i32 {\n-    a + 2\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    #[test]\n-    fn it_works() {\n-        assert_eq!(4, add_two(2));\n-    }\n-}\n-```\n-\n-Note the different `use` line. Now we run our tests:\n-\n-```bash\n-$ cargo test\n-    Updating registry `https://github.com/rust-lang/crates.io-index`\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n-\n-running 1 test\n-test test::it_works ... ok\n-\n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n-\n-   Doc-tests adder\n-\n-running 0 tests\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n-```\n-\n-It works!\n-\n-The current convention is to use the `test` module to hold your \"unit-style\"\n-tests. Anything that just tests one small bit of functionality makes sense to\n-go here. But what about \"integration-style\" tests instead? For that, we have\n-the `tests` directory\n-\n-# The `tests` directory\n-\n-To write an integration test, let's make a `tests` directory, and\n-put a `tests/lib.rs` file inside, with this as its contents:\n-\n-```{rust,ignore}\n-extern crate adder;\n-\n-#[test]\n-fn it_works() {\n-    assert_eq!(4, adder::add_two(2));\n-}\n-```\n-\n-This looks similar to our previous tests, but slightly different. We now have\n-an `extern crate adder` at the top. This is because the tests in the `tests`\n-directory are an entirely separate crate, and so we need to import our library.\n-This is also why `tests` is a suitable place to write integration-style tests:\n-they use the library like any other consumer of it would.\n-\n-Let's run them:\n-\n-```bash\n-$ cargo test\n-   Compiling adder v0.0.1 (file:///home/you/projects/adder)\n-     Running target/adder-91b3e234d4ed382a\n-\n-running 1 test\n-test test::it_works ... ok\n-\n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n-\n-     Running target/lib-c18e7d3494509e74\n-\n-running 1 test\n-test it_works ... ok\n-\n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n-\n-   Doc-tests adder\n-\n-running 0 tests\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n-```\n-\n-Now we have three sections: our previous test is also run, as well as our new\n-one.\n-\n-That's all there is to the `tests` directory. The `test` module isn't needed\n-here, since the whole thing is focused on tests.\n-\n-Let's finally check out that third section: documentation tests.\n-\n-# Documentation tests\n-\n-Nothing is better than documentation with examples. Nothing is worse than\n-examples that don't actually work, because the code has changed since the\n-documentation has been written. To this end, Rust supports automatically\n-running examples in your documentation. Here's a fleshed-out `src/lib.rs`\n-with examples:\n-\n-```{rust,ignore}\n-//! The `adder` crate provides functions that add numbers to other numbers.\n-//!\n-//! # Examples\n-//!\n-//! ```\n-//! assert_eq!(4, adder::add_two(2));\n-//! ```\n-\n-/// This function adds two to its argument.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use adder::add_two;\n-///\n-/// assert_eq!(4, add_two(2));\n-/// ```\n-pub fn add_two(a: i32) -> i32 {\n-    a + 2\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    #[test]\n-    fn it_works() {\n-        assert_eq!(4, add_two(2));\n-    }\n-}\n-```\n-\n-Note the module-level documentation with `//!` and the function-level\n-documentation with `///`. Rust's documentation supports Markdown in comments,\n-and so triple graves mark code blocks. It is conventional to include the\n-`# Examples` section, exactly like that, with examples following.\n-\n-Let's run the tests again:\n-\n-```bash\n-$ cargo test\n-   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)\n-     Running target/adder-91b3e234d4ed382a\n-\n-running 1 test\n-test test::it_works ... ok\n-\n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n-\n-     Running target/lib-c18e7d3494509e74\n-\n-running 1 test\n-test it_works ... ok\n-\n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n-\n-   Doc-tests adder\n-\n-running 2 tests\n-test add_two_0 ... ok\n-test _0 ... ok\n-\n-test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured\n-```\n-\n-Now we have all three kinds of tests running! Note the names of the\n-documentation tests: the `_0` is generated for the module test, and `add_two_0`\n-for the function test. These will auto increment with names like `add_two_1` as\n-you add more examples.\n-"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/the-stack-and-the-heap.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "6226ea9f3e75a21e067909c49155bad69e03bb4b", "filename": "src/doc/trpl/tracing-macros.md", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Ftracing-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Ftracing-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftracing-macros.md?ref=d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "patch": "@@ -1,91 +0,0 @@\n-% Tracing Macros\n-\n-The `trace_macros` feature allows you to use a special feature: tracing macro\n-invocations.\n-\n-In the advanced macros chapter, we defined a `bct` macro:\n-\n-```rust\n-macro_rules! bct {\n-    // cmd 0:  d ... => ...\n-    (0, $($ps:tt),* ; $_d:tt)\n-        => (bct!($($ps),*, 0 ; ));\n-    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n-        => (bct!($($ps),*, 0 ; $($ds),*));\n-\n-    // cmd 1p:  1 ... => 1 ... p\n-    (1, $p:tt, $($ps:tt),* ; 1)\n-        => (bct!($($ps),*, 1, $p ; 1, $p));\n-    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n-        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n-\n-    // cmd 1p:  0 ... => 0 ...\n-    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n-        => (bct!($($ps),*, 1, $p ; $($ds),*));\n-\n-    // halt on empty data string\n-    ( $($ps:tt),* ; )\n-        => (());\n-}\n-```\n-\n-This is pretty complex! we can see the output\n-\n-```rust,ignore\n-#![feature(trace_macros)]\n-\n-macro_rules! bct {\n-    // cmd 0:  d ... => ...\n-    (0, $($ps:tt),* ; $_d:tt)\n-        => (bct!($($ps),*, 0 ; ));\n-    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n-        => (bct!($($ps),*, 0 ; $($ds),*));\n-\n-    // cmd 1p:  1 ... => 1 ... p\n-    (1, $p:tt, $($ps:tt),* ; 1)\n-        => (bct!($($ps),*, 1, $p ; 1, $p));\n-    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n-        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n-\n-    // cmd 1p:  0 ... => 0 ...\n-    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n-        => (bct!($($ps),*, 1, $p ; $($ds),*));\n-\n-    // halt on empty data string\n-    ( $($ps:tt),* ; )\n-        => (());\n-}\n-\n-fn main() {\n-    trace_macros!(true);\n-\n-    bct!(0, 0, 1, 1, 1 ; 1, 0, 1);\n-}\n-```\n-\n-This will print out a wall of text:\n-\n-```text\n-bct! { 0 , 0 , 1 , 1 , 1 ; 1 , 0 , 1 }\n-bct! { 0 , 1 , 1 , 1 , 0 ; 0 , 1 }\n-bct! { 1 , 1 , 1 , 0 , 0 ; 1 }\n-bct! { 1 , 0 , 0 , 1 , 1 ; 1 , 1 }\n-bct! { 0 , 1 , 1 , 1 , 0 ; 1 , 1 , 0 }\n-bct! { 1 , 1 , 1 , 0 , 0 ; 1 , 0 }\n-bct! { 1 , 0 , 0 , 1 , 1 ; 1 , 0 , 1 }\n-bct! { 0 , 1 , 1 , 1 , 0 ; 1 , 0 , 1 , 0 }\n-bct! { 1 , 1 , 1 , 0 , 0 ; 0 , 1 , 0 }\n-bct! { 1 , 0 , 0 , 1 , 1 ; 0 , 1 , 0 }\n-bct! { 0 , 1 , 1 , 1 , 0 ; 0 , 1 , 0 }\n-```\n-\n-And eventually, error:\n-\n-```text\n-18:45 error: recursion limit reached while expanding the macro `bct`\n-    => (bct!($($ps),*, 1, $p ; $($ds),*));\n-        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-```\n-\n-The `trace_macros!` call is what produces this output, showing how we match\n-each time."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/trait-objects.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ftrait-objects.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ftrait-objects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftrait-objects.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 0, "deletions": 508, "changes": 508, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,508 +0,0 @@\n-% Traits\n-\n-Do you remember the `impl` keyword, used to call a function with method\n-syntax?\n-\n-```{rust}\n-# #![feature(core)]\n-struct Circle {\n-    x: f64,\n-    y: f64,\n-    radius: f64,\n-}\n-\n-impl Circle {\n-    fn area(&self) -> f64 {\n-        std::f64::consts::PI * (self.radius * self.radius)\n-    }\n-}\n-```\n-\n-Traits are similar, except that we define a trait with just the method\n-signature, then implement the trait for that struct. Like this:\n-\n-```{rust}\n-# #![feature(core)]\n-struct Circle {\n-    x: f64,\n-    y: f64,\n-    radius: f64,\n-}\n-\n-trait HasArea {\n-    fn area(&self) -> f64;\n-}\n-\n-impl HasArea for Circle {\n-    fn area(&self) -> f64 {\n-        std::f64::consts::PI * (self.radius * self.radius)\n-    }\n-}\n-```\n-\n-As you can see, the `trait` block looks very similar to the `impl` block,\n-but we don't define a body, just a type signature. When we `impl` a trait,\n-we use `impl Trait for Item`, rather than just `impl Item`.\n-\n-So what's the big deal? Remember the error we were getting with our generic\n-`inverse` function?\n-\n-```text\n-error: binary operation `==` cannot be applied to type `T`\n-```\n-\n-We can use traits to constrain our generics. Consider this function, which\n-does not compile, and gives us a similar error:\n-\n-```{rust,ignore}\n-fn print_area<T>(shape: T) {\n-    println!(\"This shape has an area of {}\", shape.area());\n-}\n-```\n-\n-Rust complains:\n-\n-```text\n-error: type `T` does not implement any method in scope named `area`\n-```\n-\n-Because `T` can be any type, we can't be sure that it implements the `area`\n-method. But we can add a *trait constraint* to our generic `T`, ensuring\n-that it does:\n-\n-```{rust}\n-# trait HasArea {\n-#     fn area(&self) -> f64;\n-# }\n-fn print_area<T: HasArea>(shape: T) {\n-    println!(\"This shape has an area of {}\", shape.area());\n-}\n-```\n-\n-The syntax `<T: HasArea>` means `any type that implements the HasArea trait`.\n-Because traits define function type signatures, we can be sure that any type\n-which implements `HasArea` will have an `.area()` method.\n-\n-Here's an extended example of how this works:\n-\n-```{rust}\n-# #![feature(core)]\n-trait HasArea {\n-    fn area(&self) -> f64;\n-}\n-\n-struct Circle {\n-    x: f64,\n-    y: f64,\n-    radius: f64,\n-}\n-\n-impl HasArea for Circle {\n-    fn area(&self) -> f64 {\n-        std::f64::consts::PI * (self.radius * self.radius)\n-    }\n-}\n-\n-struct Square {\n-    x: f64,\n-    y: f64,\n-    side: f64,\n-}\n-\n-impl HasArea for Square {\n-    fn area(&self) -> f64 {\n-        self.side * self.side\n-    }\n-}\n-\n-fn print_area<T: HasArea>(shape: T) {\n-    println!(\"This shape has an area of {}\", shape.area());\n-}\n-\n-fn main() {\n-    let c = Circle {\n-        x: 0.0f64,\n-        y: 0.0f64,\n-        radius: 1.0f64,\n-    };\n-\n-    let s = Square {\n-        x: 0.0f64,\n-        y: 0.0f64,\n-        side: 1.0f64,\n-    };\n-\n-    print_area(c);\n-    print_area(s);\n-}\n-```\n-\n-This program outputs:\n-\n-```text\n-This shape has an area of 3.141593\n-This shape has an area of 1\n-```\n-\n-As you can see, `print_area` is now generic, but also ensures that we\n-have passed in the correct types. If we pass in an incorrect type:\n-\n-```{rust,ignore}\n-print_area(5);\n-```\n-\n-We get a compile-time error:\n-\n-```text\n-error: failed to find an implementation of trait main::HasArea for int\n-```\n-\n-So far, we've only added trait implementations to structs, but you can\n-implement a trait for any type. So technically, we _could_ implement\n-`HasArea` for `i32`:\n-\n-```{rust}\n-trait HasArea {\n-    fn area(&self) -> f64;\n-}\n-\n-impl HasArea for i32 {\n-    fn area(&self) -> f64 {\n-        println!(\"this is silly\");\n-\n-        *self as f64\n-    }\n-}\n-\n-5.area();\n-```\n-\n-It is considered poor style to implement methods on such primitive types, even\n-though it is possible.\n-\n-This may seem like the Wild West, but there are two other restrictions around\n-implementing traits that prevent this from getting out of hand. First, traits\n-must be `use`d in any scope where you wish to use the trait's method. So for\n-example, this does not work:\n-\n-```{rust,ignore}\n-mod shapes {\n-    use std::f64::consts;\n-\n-    trait HasArea {\n-        fn area(&self) -> f64;\n-    }\n-\n-    struct Circle {\n-        x: f64,\n-        y: f64,\n-        radius: f64,\n-    }\n-\n-    impl HasArea for Circle {\n-        fn area(&self) -> f64 {\n-            consts::PI * (self.radius * self.radius)\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let c = shapes::Circle {\n-        x: 0.0f64,\n-        y: 0.0f64,\n-        radius: 1.0f64,\n-    };\n-\n-    println!(\"{}\", c.area());\n-}\n-```\n-\n-Now that we've moved the structs and traits into their own module, we get an\n-error:\n-\n-```text\n-error: type `shapes::Circle` does not implement any method in scope named `area`\n-```\n-\n-If we add a `use` line right above `main` and make the right things public,\n-everything is fine:\n-\n-```{rust}\n-# #![feature(core)]\n-mod shapes {\n-    use std::f64::consts;\n-\n-    pub trait HasArea {\n-        fn area(&self) -> f64;\n-    }\n-\n-    pub struct Circle {\n-        pub x: f64,\n-        pub y: f64,\n-        pub radius: f64,\n-    }\n-\n-    impl HasArea for Circle {\n-        fn area(&self) -> f64 {\n-            consts::PI * (self.radius * self.radius)\n-        }\n-    }\n-}\n-\n-use shapes::HasArea;\n-\n-fn main() {\n-    let c = shapes::Circle {\n-        x: 0.0f64,\n-        y: 0.0f64,\n-        radius: 1.0f64,\n-    };\n-\n-    println!(\"{}\", c.area());\n-}\n-```\n-\n-This means that even if someone does something bad like add methods to `int`,\n-it won't affect you, unless you `use` that trait.\n-\n-There's one more restriction on implementing traits. Either the trait or the\n-type you're writing the `impl` for must be inside your crate. So, we could\n-implement the `HasArea` type for `i32`, because `HasArea` is in our crate.  But\n-if we tried to implement `Float`, a trait provided by Rust, for `i32`, we could\n-not, because both the trait and the type aren't in our crate.\n-\n-One last thing about traits: generic functions with a trait bound use\n-*monomorphization* (*mono*: one, *morph*: form), so they are statically\n-dispatched. What's that mean? Check out the chapter on [static and dynamic\n-dispatch](static-and-dynamic-dispatch.html) for more.\n-\n-## Multiple trait bounds\n-\n-You\u2019ve seen that you can bound a generic type parameter with a trait:\n-\n-```rust\n-fn foo<T: Clone>(x: T) {\n-    x.clone();\n-}\n-```\n-\n-If you need more than one bound, you can use `+`:\n-\n-```rust\n-use std::fmt::Debug;\n-\n-fn foo<T: Clone + Debug>(x: T) {\n-    x.clone();\n-    println!(\"{:?}\", x);\n-}\n-```\n-\n-`T` now needs to be both `Clone` as well as `Debug`.\n-\n-## Where clause\n-\n-Writing functions with only a few generic types and a small number of trait\n-bounds isn't too bad, but as the number increases, the syntax gets increasingly\n-awkward:\n-\n-```\n-use std::fmt::Debug;\n-\n-fn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n-    x.clone();\n-    y.clone();\n-    println!(\"{:?}\", y);\n-}\n-```\n-\n-The name of the function is on the far left, and the parameter list is on the\n-far right. The bounds are getting in the way.\n-\n-Rust has a solution, and it's called a '`where` clause':\n-\n-```\n-use std::fmt::Debug;\n-\n-fn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n-    x.clone();\n-    y.clone();\n-    println!(\"{:?}\", y);\n-}\n-\n-fn bar<T, K>(x: T, y: K) where T: Clone, K: Clone + Debug {\n-    x.clone();\n-    y.clone();\n-    println!(\"{:?}\", y);\n-}\n-\n-fn main() {\n-    foo(\"Hello\", \"world\");\n-    bar(\"Hello\", \"workd\");\n-}\n-```\n-\n-`foo()` uses the syntax we showed earlier, and `bar()` uses a `where` clause.\n-All you need to do is leave off the bounds when defining your type parameters,\n-and then add `where` after the parameter list. For longer lists, whitespace can\n-be added:\n-\n-```\n-use std::fmt::Debug;\n-\n-fn bar<T, K>(x: T, y: K)\n-    where T: Clone,\n-          K: Clone + Debug {\n-\n-    x.clone();\n-    y.clone();\n-    println!(\"{:?}\", y);\n-}\n-```\n-\n-This flexibility can add clarity in complex situations.\n-\n-`where` is also more powerful than the simpler syntax. For example:\n-\n-```\n-trait ConvertTo<Output> {\n-    fn convert(&self) -> Output;\n-}\n-\n-impl ConvertTo<i64> for i32 {\n-    fn convert(&self) -> i64 { *self as i64 }\n-}\n-\n-// can be called with T == i32\n-fn normal<T: ConvertTo<i64>>(x: &T) -> i64 {\n-    x.convert()\n-}\n-\n-// can be called with T == i64\n-fn inverse<T>() -> T\n-        // this is using ConvertTo as if it were \"ConvertFrom<i32>\"\n-        where i32: ConvertTo<T> {\n-    1i32.convert()\n-}\n-```\n-\n-This shows off the additional feature of `where` clauses: they allow bounds\n-where the left-hand side is an arbitrary type (`i32` in this case), not just a\n-plain type parameter (like `T`).\n-\n-## Our `inverse` Example\n-\n-Back in [Generics](generics.html), we were trying to write code like this:\n-\n-```{rust,ignore}\n-fn inverse<T>(x: T) -> Result<T, String> {\n-    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0 / x)\n-}\n-```\n-\n-If we try to compile it, we get this error:\n-\n-```text\n-error: binary operation `==` cannot be applied to type `T`\n-```\n-\n-This is because `T` is too generic: we don't know if a random `T` can be\n-compared. For that, we can use trait bounds. It doesn't quite work, but try\n-this:\n-\n-```{rust,ignore}\n-fn inverse<T: PartialEq>(x: T) -> Result<T, String> {\n-    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n-\n-    Ok(1.0 / x)\n-}\n-```\n-\n-You should get this error:\n-\n-```text\n-error: mismatched types:\n- expected `T`,\n-    found `_`\n-(expected type parameter,\n-    found floating-point variable)\n-```\n-\n-So this won't work. While our `T` is `PartialEq`, we expected to have another `T`,\n-but instead, we found a floating-point variable. We need a different bound. `Float`\n-to the rescue:\n-\n-```\n-# #![feature(std_misc)]\n-use std::num::Float;\n-\n-fn inverse<T: Float>(x: T) -> Result<T, String> {\n-    if x == Float::zero() { return Err(\"x cannot be zero!\".to_string()) }\n-\n-    let one: T = Float::one();\n-    Ok(one / x)\n-}\n-```\n-\n-We've had to replace our generic `0.0` and `1.0` with the appropriate methods\n-from the `Float` trait. Both `f32` and `f64` implement `Float`, so our function\n-works just fine:\n-\n-```\n-# #![feature(std_misc)]\n-# use std::num::Float;\n-# fn inverse<T: Float>(x: T) -> Result<T, String> {\n-#     if x == Float::zero() { return Err(\"x cannot be zero!\".to_string()) }\n-#     let one: T = Float::one();\n-#     Ok(one / x)\n-# }\n-println!(\"the inverse of {} is {:?}\", 2.0f32, inverse(2.0f32));\n-println!(\"the inverse of {} is {:?}\", 2.0f64, inverse(2.0f64));\n-\n-println!(\"the inverse of {} is {:?}\", 0.0f32, inverse(0.0f32));\n-println!(\"the inverse of {} is {:?}\", 0.0f64, inverse(0.0f64));\n-```\n-\n-## Default methods\n-\n-There's one last feature of traits we should cover: default methods. It's\n-easiest just to show an example:\n-\n-```rust\n-trait Foo {\n-    fn bar(&self);\n-\n-    fn baz(&self) { println!(\"We called baz.\"); }\n-}\n-```\n-\n-Implementors of the `Foo` trait need to implement `bar()`, but they don't\n-need to implement `baz()`. They'll get this default behavior. They can\n-override the default if they so choose:\n-\n-```rust\n-# trait Foo {\n-# fn bar(&self);\n-# fn baz(&self) { println!(\"We called baz.\"); }\n-# }\n-struct UseDefault;\n-\n-impl Foo for UseDefault {\n-    fn bar(&self) { println!(\"We called bar.\"); }\n-}\n-\n-struct OverrideDefault;\n-\n-impl Foo for OverrideDefault {\n-    fn bar(&self) { println!(\"We called bar.\"); }\n-\n-    fn baz(&self) { println!(\"Override baz!\"); }\n-}\n-\n-let default = UseDefault;\n-default.baz(); // prints \"We called baz.\"\n-\n-let over = OverrideDefault;\n-over.baz(); // prints \"Override baz!\"\n-```"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/tuple-structs.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ftuple-structs.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ftuple-structs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftuple-structs.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/tuples.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ftuples.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ftuples.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftuples.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/type-aliases.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ftype-aliases.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Ftype-aliases.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftype-aliases.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/ufcs.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fufcs.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fufcs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fufcs.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/unsafe-code.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Funsafe-code.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Funsafe-code.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe-code.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "3ca3cfd05886ee8add73eaa419c16f7c3c4c34b5", "filename": "src/doc/trpl/unsafe.md", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9146bf8ba0bdf98a46c4656899e54802e96ac0c/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "patch": "@@ -1,183 +0,0 @@\n-% Unsafe and Low-Level Code\n-\n-# Introduction\n-\n-Rust aims to provide safe abstractions over the low-level details of\n-the CPU and operating system, but sometimes one needs to drop down and\n-write code at that level. This guide aims to provide an overview of\n-the dangers and power one gets with Rust's unsafe subset.\n-\n-Rust provides an escape hatch in the form of the `unsafe { ... }`\n-block which allows the programmer to dodge some of the compiler's\n-checks and do a wide range of operations, such as:\n-\n-- dereferencing [raw pointers](#raw-pointers)\n-- calling a function via FFI ([covered by the FFI guide](ffi.html))\n-- casting between types bitwise (`transmute`, aka \"reinterpret cast\")\n-- [inline assembly](#inline-assembly)\n-\n-Note that an `unsafe` block does not relax the rules about lifetimes\n-of `&` and the freezing of borrowed data.\n-\n-Any use of `unsafe` is the programmer saying \"I know more than you\" to\n-the compiler, and, as such, the programmer should be very sure that\n-they actually do know more about why that piece of code is valid.  In\n-general, one should try to minimize the amount of unsafe code in a\n-code base; preferably by using the bare minimum `unsafe` blocks to\n-build safe interfaces.\n-\n-> **Note**: the low-level details of the Rust language are still in\n-> flux, and there is no guarantee of stability or backwards\n-> compatibility. In particular, there may be changes that do not cause\n-> compilation errors, but do cause semantic changes (such as invoking\n-> undefined behaviour). As such, extreme care is required.\n-\n-# Pointers\n-\n-## References\n-\n-One of Rust's biggest features is memory safety.  This is achieved in\n-part via [the ownership system](ownership.html), which is how the\n-compiler can guarantee that every `&` reference is always valid, and,\n-for example, never pointing to freed memory.\n-\n-These restrictions on `&` have huge advantages. However, they also\n-constrain how we can use them. For example, `&` doesn't behave\n-identically to C's pointers, and so cannot be used for pointers in\n-foreign function interfaces (FFI). Additionally, both immutable (`&`)\n-and mutable (`&mut`) references have some aliasing and freezing\n-guarantees, required for memory safety.\n-\n-In particular, if you have an `&T` reference, then the `T` must not be\n-modified through that reference or any other reference. There are some\n-standard library types, e.g. `Cell` and `RefCell`, that provide inner\n-mutability by replacing compile time guarantees with dynamic checks at\n-runtime.\n-\n-An `&mut` reference has a different constraint: when an object has an\n-`&mut T` pointing into it, then that `&mut` reference must be the only\n-such usable path to that object in the whole program. That is, an\n-`&mut` cannot alias with any other references.\n-\n-Using `unsafe` code to incorrectly circumvent and violate these\n-restrictions is undefined behaviour. For example, the following\n-creates two aliasing `&mut` pointers, and is invalid.\n-\n-```\n-use std::mem;\n-let mut x: u8 = 1;\n-\n-let ref_1: &mut u8 = &mut x;\n-let ref_2: &mut u8 = unsafe { mem::transmute(&mut *ref_1) };\n-\n-// oops, ref_1 and ref_2 point to the same piece of data (x) and are\n-// both usable\n-*ref_1 = 10;\n-*ref_2 = 20;\n-```\n-\n-## Raw pointers\n-\n-Rust offers two additional pointer types (*raw pointers*), written as\n-`*const T` and `*mut T`. They're an approximation of C's `const T*` and `T*`\n-respectively; indeed, one of their most common uses is for FFI,\n-interfacing with external C libraries.\n-\n-Raw pointers have much fewer guarantees than other pointer types\n-offered by the Rust language and libraries. For example, they\n-\n-- are not guaranteed to point to valid memory and are not even\n-  guaranteed to be non-null (unlike both `Box` and `&`);\n-- do not have any automatic clean-up, unlike `Box`, and so require\n-  manual resource management;\n-- are plain-old-data, that is, they don't move ownership, again unlike\n-  `Box`, hence the Rust compiler cannot protect against bugs like\n-  use-after-free;\n-- lack any form of lifetimes, unlike `&`, and so the compiler cannot\n-  reason about dangling pointers; and\n-- have no guarantees about aliasing or mutability other than mutation\n-  not being allowed directly through a `*const T`.\n-\n-Fortunately, they come with a redeeming feature: the weaker guarantees\n-mean weaker restrictions. The missing restrictions make raw pointers\n-appropriate as a building block for implementing things like smart\n-pointers and vectors inside libraries. For example, `*` pointers are\n-allowed to alias, allowing them to be used to write shared-ownership\n-types like reference counted and garbage collected pointers, and even\n-thread-safe shared memory types (`Rc` and the `Arc` types are both\n-implemented entirely in Rust).\n-\n-There are two things that you are required to be careful about\n-(i.e. require an `unsafe { ... }` block) with raw pointers:\n-\n-- dereferencing: they can have any value: so possible results include\n-  a crash, a read of uninitialised memory, a use-after-free, or\n-  reading data as normal.\n-- pointer arithmetic via the `offset` [intrinsic](#intrinsics) (or\n-  `.offset` method): this intrinsic uses so-called \"in-bounds\"\n-  arithmetic, that is, it is only defined behaviour if the result is\n-  inside (or one-byte-past-the-end) of the object from which the\n-  original pointer came.\n-\n-The latter assumption allows the compiler to optimize more\n-effectively. As can be seen, actually *creating* a raw pointer is not\n-unsafe, and neither is converting to an integer.\n-\n-### References and raw pointers\n-\n-At runtime, a raw pointer `*` and a reference pointing to the same\n-piece of data have an identical representation. In fact, an `&T`\n-reference will implicitly coerce to an `*const T` raw pointer in safe code\n-and similarly for the `mut` variants (both coercions can be performed\n-explicitly with, respectively, `value as *const T` and `value as *mut T`).\n-\n-Going the opposite direction, from `*const` to a reference `&`, is not\n-safe. A `&T` is always valid, and so, at a minimum, the raw pointer\n-`*const T` has to point to a valid instance of type `T`. Furthermore,\n-the resulting pointer must satisfy the aliasing and mutability laws of\n-references. The compiler assumes these properties are true for any\n-references, no matter how they are created, and so any conversion from\n-raw pointers is asserting that they hold. The programmer *must*\n-guarantee this.\n-\n-The recommended method for the conversion is\n-\n-```\n-let i: u32 = 1;\n-// explicit cast\n-let p_imm: *const u32 = &i as *const u32;\n-let mut m: u32 = 2;\n-// implicit coercion\n-let p_mut: *mut u32 = &mut m;\n-\n-unsafe {\n-    let ref_imm: &u32 = &*p_imm;\n-    let ref_mut: &mut u32 = &mut *p_mut;\n-}\n-```\n-\n-The `&*x` dereferencing style is preferred to using a `transmute`.\n-The latter is far more powerful than necessary, and the more\n-restricted operation is harder to use incorrectly; for example, it\n-requires that `x` is a pointer (unlike `transmute`).\n-\n-\n-\n-## Making the unsafe safe(r)\n-\n-There are various ways to expose a safe interface around some unsafe\n-code:\n-\n-- store pointers privately (i.e. not in public fields of public\n-  structs), so that you can see and control all reads and writes to\n-  the pointer in one place.\n-- use `assert!()` a lot: since you can't rely on the protection of the\n-  compiler & type-system to ensure that your `unsafe` code is correct\n-  at compile-time, use `assert!()` to verify that it is doing the\n-  right thing at run-time.\n-- implement the `Drop` for resource clean-up via a destructor, and use\n-  RAII (Resource Acquisition Is Initialization). This reduces the need\n-  for any manual memory management by users, and automatically ensures\n-  that clean-up is always run, even when the thread panics.\n-- ensure that any data stored behind a raw pointer is destroyed at the\n-  appropriate time."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/unsized-types.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Funsized-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Funsized-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsized-types.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/variable-bindings.md", "status": "modified", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc", "patch": "@@ -1,161 +0,0 @@\n-% Variable Bindings\n-\n-The first thing we'll learn about are *variable bindings*. They look like this:\n-\n-```{rust}\n-fn main() {\n-    let x = 5;\n-}\n-```\n-\n-Putting `fn main() {` in each example is a bit tedious, so we'll leave that out\n-in the future. If you're following along, make sure to edit your `main()`\n-function, rather than leaving it off. Otherwise, you'll get an error.\n-\n-In many languages, this is called a *variable*. But Rust's variable bindings\n-have a few tricks up their sleeves. Rust has a very powerful feature called\n-*pattern matching* that we'll get into detail with later, but the left\n-hand side of a `let` expression is a full pattern, not just a variable name.\n-This means we can do things like:\n-\n-```{rust}\n-let (x, y) = (1, 2);\n-```\n-\n-After this expression is evaluated, `x` will be one, and `y` will be two.\n-Patterns are really powerful, but this is about all we can do with them so far.\n-So let's just keep this in the back of our minds as we go forward.\n-\n-Rust is a statically typed language, which means that we specify our types up\n-front. So why does our first example compile? Well, Rust has this thing called\n-*type inference*. If it can figure out what the type of something is, Rust\n-doesn't require you to actually type it out.\n-\n-We can add the type if we want to, though. Types come after a colon (`:`):\n-\n-```{rust}\n-let x: i32 = 5;\n-```\n-\n-If I asked you to read this out loud to the rest of the class, you'd say \"`x`\n-is a binding with the type `i32` and the value `five`.\"\n-\n-In this case we chose to represent `x` as a 32-bit signed integer. Rust has\n-many different primitive integer types. They begin with `i` for signed integers\n-and `u` for unsigned integers. The possible integer sizes are 8, 16, 32, and 64\n-bits.\n-\n-In future examples, we may annotate the type in a comment. The examples will\n-look like this:\n-\n-```{rust}\n-fn main() {\n-    let x = 5; // x: i32\n-}\n-```\n-\n-Note the similarities between this annotation and the syntax you use with `let`.\n-Including these kinds of comments is not idiomatic Rust, but we'll occasionally\n-include them to help you understand what the types that Rust infers are.\n-\n-By default, bindings are *immutable*. This code will not compile:\n-\n-```{ignore}\n-let x = 5;\n-x = 10;\n-```\n-\n-It will give you this error:\n-\n-```text\n-error: re-assignment of immutable variable `x`\n-     x = 10;\n-     ^~~~~~~\n-```\n-\n-If you want a binding to be mutable, you can use `mut`:\n-\n-```{rust}\n-let mut x = 5; // mut x: i32\n-x = 10;\n-```\n-\n-There is no single reason that bindings are immutable by default, but we can\n-think about it through one of Rust's primary focuses: safety. If you forget to\n-say `mut`, the compiler will catch it, and let you know that you have mutated\n-something you may not have intended to mutate. If bindings were mutable by\n-default, the compiler would not be able to tell you this. If you _did_ intend\n-mutation, then the solution is quite easy: add `mut`.\n-\n-There are other good reasons to avoid mutable state when possible, but they're\n-out of the scope of this guide. In general, you can often avoid explicit\n-mutation, and so it is preferable in Rust. That said, sometimes, mutation is\n-what you need, so it's not verboten.\n-\n-Let's get back to bindings. Rust variable bindings have one more aspect that\n-differs from other languages: bindings are required to be initialized with a\n-value before you're allowed to use them.\n-\n-Let's try it out. Change your `src/main.rs` file to look like this:\n-\n-```{rust}\n-fn main() {\n-    let x: i32;\n-\n-    println!(\"Hello world!\");\n-}\n-```\n-\n-You can use `cargo build` on the command line to build it. You'll get a warning,\n-but it will still print \"Hello, world!\":\n-\n-```text\n-   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n-src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)] on by default\n-src/main.rs:2     let x: i32;\n-                      ^\n-```\n-\n-Rust warns us that we never use the variable binding, but since we never use it,\n-no harm, no foul. Things change if we try to actually use this `x`, however. Let's\n-do that. Change your program to look like this:\n-\n-```{rust,ignore}\n-fn main() {\n-    let x: i32;\n-\n-    println!(\"The value of x is: {}\", x);\n-}\n-```\n-\n-And try to build it. You'll get an error:\n-\n-```{bash}\n-$ cargo build\n-   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n-src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`\n-src/main.rs:4     println!(\"The value of x is: {}\", x);\n-                                                    ^\n-note: in expansion of format_args!\n-<std macros>:2:23: 2:77 note: expansion site\n-<std macros>:1:1: 3:2 note: in expansion of println!\n-src/main.rs:4:5: 4:42 note: expansion site\n-error: aborting due to previous error\n-Could not compile `hello_world`.\n-```\n-\n-Rust will not let us use a value that has not been initialized. Next, let's\n-talk about this stuff we've added to `println!`.\n-\n-If you include two curly braces (`{}`, some call them moustaches...) in your\n-string to print, Rust will interpret this as a request to interpolate some sort\n-of value. *String interpolation* is a computer science term that means \"stick\n-in the middle of a string.\" We add a comma, and then `x`, to indicate that we\n-want `x` to be the value we're interpolating. The comma is used to separate\n-arguments we pass to functions and macros, if you're passing more than one.\n-\n-When you just use the curly braces, Rust will attempt to display the\n-value in a meaningful way by checking out its type. If you want to specify the\n-format in a more detailed manner, there are a [wide number of options\n-available](../std/fmt/index.html). For now, we'll just stick to the default:\n-integers aren't very complicated to print."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/vectors.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fvectors.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fvectors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvectors.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/trpl/while-loops.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/f354c8a580acbb3170883dd271f362d4b9132ddc/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fwhile-loops.md?ref=f354c8a580acbb3170883dd271f362d4b9132ddc"}]}