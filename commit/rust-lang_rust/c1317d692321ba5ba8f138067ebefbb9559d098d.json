{"sha": "c1317d692321ba5ba8f138067ebefbb9559d098d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMzE3ZDY5MjMyMWJhNWJhOGYxMzgwNjdlYmVmYmI5NTU5ZDA5OGQ=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-09T16:37:34Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-09T17:12:50Z"}, "message": "feat: add support for feature attributes in struct literal\n\nSigned-off-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "e29a44577e4d2cf55b6f53e3428abea43bbd33d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e29a44577e4d2cf55b6f53e3428abea43bbd33d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1317d692321ba5ba8f138067ebefbb9559d098d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1317d692321ba5ba8f138067ebefbb9559d098d", "html_url": "https://github.com/rust-lang/rust/commit/c1317d692321ba5ba8f138067ebefbb9559d098d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1317d692321ba5ba8f138067ebefbb9559d098d/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc70cf9458c5234decafdd52b9aced790ac43d7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc70cf9458c5234decafdd52b9aced790ac43d7a", "html_url": "https://github.com/rust-lang/rust/commit/fc70cf9458c5234decafdd52b9aced790ac43d7a"}, {"sha": "30f0ad159a0f260f54356385de63c171722adb72", "url": "https://api.github.com/repos/rust-lang/rust/commits/30f0ad159a0f260f54356385de63c171722adb72", "html_url": "https://github.com/rust-lang/rust/commit/30f0ad159a0f260f54356385de63c171722adb72"}], "stats": {"total": 15809, "additions": 7651, "deletions": 8158}, "files": [{"sha": "72a201b6d2e6a27f0368e15c975c2153b11f70a8", "filename": "crates/ra_assists/src/handlers/add_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -1,5 +1,5 @@\n use ra_syntax::{\n-    ast::{self, AstNode, NameOwner, TypeParamsOwner},\n+    ast::{self, AstNode, AstToken, NameOwner, TypeParamsOwner},\n     TextUnit,\n };\n use stdx::{format_to, SepBy};\n@@ -42,7 +42,7 @@ pub(crate) fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n         if let Some(type_params) = type_params {\n             let lifetime_params = type_params\n                 .lifetime_params()\n-                .filter_map(|it| it.lifetime_token())\n+                .filter_map(|it| it.lifetime())\n                 .map(|it| it.text().clone());\n             let type_params =\n                 type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());"}, {"sha": "c10397249fd18b993c7df343c545498128c7cb8b", "filename": "crates/ra_assists/src/handlers/add_new.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -1,7 +1,8 @@\n use hir::Adt;\n use ra_syntax::{\n     ast::{\n-        self, AstNode, NameOwner, StructKind, TypeAscriptionOwner, TypeParamsOwner, VisibilityOwner,\n+        self, AstNode, AstToken, NameOwner, StructKind, TypeAscriptionOwner, TypeParamsOwner,\n+        VisibilityOwner,\n     },\n     TextUnit, T,\n };\n@@ -105,7 +106,7 @@ fn generate_impl_text(strukt: &ast::StructDef, code: &str) -> String {\n     if let Some(type_params) = type_params {\n         let lifetime_params = type_params\n             .lifetime_params()\n-            .filter_map(|it| it.lifetime_token())\n+            .filter_map(|it| it.lifetime())\n             .map(|it| it.text().clone());\n         let type_params =\n             type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());"}, {"sha": "8a02f1a32c5132ac1ed357fdbde4d3aa7146c88e", "filename": "crates/ra_assists/src/handlers/introduce_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -124,7 +124,7 @@ fn anchor_stmt(expr: ast::Expr) -> Option<(SyntaxNode, bool)> {\n             }\n         }\n \n-        if ast::Stmt::cast(node.clone()).is_some() {\n+        if ast::Stmt::cast(node.clone().into()).is_some() {\n             return Some((node, false));\n         }\n "}, {"sha": "f8b3ddb4e18f3c50dbcb1bce073719ff1f8b7428", "filename": "crates/ra_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -3,7 +3,7 @@ use std::iter::successors;\n use ra_syntax::{\n     algo::{neighbor, SyntaxRewriter},\n     ast::{self, edit::AstNodeEdit, make},\n-    AstNode, Direction, InsertPosition, SyntaxElement, T,\n+    AstNode, AstToken, Direction, InsertPosition, SyntaxElement, T,\n };\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -82,7 +82,7 @@ fn try_merge_trees(old: &ast::UseTree, new: &ast::UseTree) -> Option<ast::UseTre\n             .filter(|it| it.kind() != T!['{'] && it.kind() != T!['}']),\n     );\n     let use_tree_list = lhs.use_tree_list()?;\n-    let pos = InsertPosition::Before(use_tree_list.r_curly()?.into());\n+    let pos = InsertPosition::Before(use_tree_list.r_curly()?.syntax().clone().into());\n     let use_tree_list = use_tree_list.insert_children(pos, to_insert);\n     Some(lhs.with_use_tree_list(use_tree_list))\n }"}, {"sha": "0b4ba1bbe6541a05fddcf1418c34e4526287e4e2", "filename": "crates/ra_fmt/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_fmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_fmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2Fsrc%2Flib.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -60,10 +60,10 @@ pub fn extract_trivial_expression(block: &ast::BlockExpr) -> Option<ast::Expr> {\n     } else {\n         // Unwrap `{ continue; }`\n         let (stmt,) = block.statements().next_tuple()?;\n-        if has_anything_else(stmt.syntax()) {\n-            return None;\n-        }\n         if let ast::Stmt::ExprStmt(expr_stmt) = stmt {\n+            if has_anything_else(expr_stmt.syntax()) {\n+                return None;\n+            }\n             let expr = expr_stmt.expr()?;\n             match expr.syntax().kind() {\n                 CONTINUE_EXPR | BREAK_EXPR | RETURN_EXPR => return Some(expr),"}, {"sha": "032037c8cfeee96564bbae91186598cc9131d040", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -497,14 +497,16 @@ impl ExprCollector<'_> {\n         self.collect_block_items(&block);\n         let statements = block\n             .statements()\n-            .map(|s| match s {\n+            .filter_map(|s| match s {\n                 ast::Stmt::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n                     let type_ref = stmt.ascribed_type().map(TypeRef::from_ast);\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n-                    Statement::Let { pat, type_ref, initializer }\n+                    Some(Statement::Let { pat, type_ref, initializer })\n+                }\n+                ast::Stmt::ExprStmt(stmt) => {\n+                    Some(Statement::Expr(self.collect_expr_opt(stmt.expr())))\n                 }\n-                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n@@ -556,6 +558,7 @@ impl ExprCollector<'_> {\n                     let ast_id = self.expander.ast_id(&def);\n                     (TraitLoc { container, ast_id }.intern(self.db).into(), def.name())\n                 }\n+                ast::ModuleItem::ExternBlock(_) => continue, // FIXME: collect from extern blocks\n                 ast::ModuleItem::ImplDef(_)\n                 | ast::ModuleItem::UseItem(_)\n                 | ast::ModuleItem::ExternCrateItem(_)"}, {"sha": "a9dff3a5d5a712d9b8e93fefcc76048c89882684", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -266,6 +266,10 @@ impl RawItemsCollector {\n                 self.add_macro(current_module, it);\n                 return;\n             }\n+            ast::ModuleItem::ExternBlock(_) => {\n+                // FIXME: add extern block\n+                return;\n+            }\n         };\n         if let Some(name) = name {\n             let name = name.as_name();"}, {"sha": "3c13cb2c788162a649d2fb8f33a6ba4954eef0ee", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -28,7 +28,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     loop {\n         let segment = path.segment()?;\n \n-        if segment.has_colon_colon() {\n+        if segment.coloncolon().is_some() {\n             kind = PathKind::Abs;\n         }\n "}, {"sha": "6ec944228cf69951143e3b52f48f75363decf8f6", "filename": "crates/ra_hir_def/src/path/lower/lower_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -34,7 +34,7 @@ pub(crate) fn lower_use_tree(\n         let alias = tree.alias().map(|a| {\n             a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n         });\n-        let is_glob = tree.has_star();\n+        let is_glob = tree.star().is_some();\n         if let Some(ast_path) = tree.path() {\n             // Handle self in a path.\n             // E.g. `use something::{self, <...>}`"}, {"sha": "1482d3be04da0610288e2bd5932143b452223696", "filename": "crates/ra_hir_def/src/visibility.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -84,6 +84,10 @@ impl RawVisibility {\n                 let path = ModPath { kind: PathKind::Super(1), segments: Vec::new() };\n                 RawVisibility::Module(path)\n             }\n+            ast::VisibilityKind::PubSelf => {\n+                let path = ModPath { kind: PathKind::Plain, segments: Vec::new() };\n+                RawVisibility::Module(path)\n+            }\n             ast::VisibilityKind::Pub => RawVisibility::Public,\n         }\n     }"}, {"sha": "08723068f8ef1a5586660261c04362d076bf381a", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -23,7 +23,7 @@ use insta::assert_snapshot;\n use ra_db::{fixture::WithFixture, salsa::Database, FilePosition, SourceDatabase};\n use ra_syntax::{\n     algo,\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, AstToken},\n };\n use stdx::format_to;\n \n@@ -101,7 +101,7 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n             let node = src_ptr.value.to_node(&src_ptr.file_syntax(&db));\n \n             let (range, text) = if let Some(self_param) = ast::SelfParam::cast(node.clone()) {\n-                (self_param.self_kw_token().text_range(), \"self\".to_string())\n+                (self_param.self_kw().unwrap().syntax().text_range(), \"self\".to_string())\n             } else {\n                 (src_ptr.value.range(), node.text().to_string().replace(\"\\n\", \" \"))\n             };\n@@ -367,7 +367,7 @@ fn no_such_field_with_feature_flag_diagnostics_on_struct_lit() {\n             fn new(foo: u32) -> Self {\n                 Self { foo }\n             }\n-            #[cfg(not(feature = \"foo\"))] \n+            #[cfg(not(feature = \"foo\"))]\n             fn new(bar: u32) -> Self {\n                 Self { bar }\n             }"}, {"sha": "d0530955e0c414daa8e12bc7e0206eb92f27052c", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -245,7 +245,7 @@ fn opt_fn_ret_type(p: &mut Parser) -> bool {\n     if p.at(T![->]) {\n         let m = p.start();\n         p.bump(T![->]);\n-        types::type_(p);\n+        types::type_no_bounds(p);\n         m.complete(p, RET_TYPE);\n         true\n     } else {"}, {"sha": "004f4e564310a58f805008863b7f96e5e7cb118a", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -105,6 +105,7 @@ pub enum SyntaxKind {\n     DEFAULT_KW,\n     EXISTENTIAL_KW,\n     UNION_KW,\n+    RAW_KW,\n     INT_NUMBER,\n     FLOAT_NUMBER,\n     CHAR,\n@@ -258,7 +259,7 @@ impl SyntaxKind {\n             | IMPL_KW | IN_KW | LET_KW | LOOP_KW | MACRO_KW | MATCH_KW | MOD_KW | MOVE_KW\n             | MUT_KW | PUB_KW | REF_KW | RETURN_KW | SELF_KW | STATIC_KW | STRUCT_KW | SUPER_KW\n             | TRAIT_KW | TRUE_KW | TRY_KW | TYPE_KW | UNSAFE_KW | USE_KW | WHERE_KW | WHILE_KW\n-            | AUTO_KW | DEFAULT_KW | EXISTENTIAL_KW | UNION_KW => true,\n+            | AUTO_KW | DEFAULT_KW | EXISTENTIAL_KW | UNION_KW | RAW_KW => true,\n             _ => false,\n         }\n     }\n@@ -651,4 +652,7 @@ macro_rules! T {\n     ( union ) => {\n         $crate::SyntaxKind::UNION_KW\n     };\n+    ( raw ) => {\n+        $crate::SyntaxKind::RAW_KW\n+    };\n }"}, {"sha": "7f87f421262e067485412ea91f831e76e991ada6", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -7,7 +7,7 @@ use std::{\n \n use itertools::Itertools;\n use ra_text_edit::TextEditBuilder;\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n \n use crate::{\n     AstNode, Direction, NodeOrToken, SyntaxElement, SyntaxNode, SyntaxNodePtr, SyntaxToken,\n@@ -72,8 +72,18 @@ pub fn find_covering_element(root: &SyntaxNode, range: TextRange) -> SyntaxEleme\n }\n \n pub fn least_common_ancestor(u: &SyntaxNode, v: &SyntaxNode) -> Option<SyntaxNode> {\n-    let u_ancestors = u.ancestors().collect::<FxHashSet<SyntaxNode>>();\n-    v.ancestors().find(|it| u_ancestors.contains(it))\n+    if u == v {\n+        return Some(u.clone());\n+    }\n+\n+    let u_depth = u.ancestors().count();\n+    let v_depth = v.ancestors().count();\n+    let keep = u_depth.min(v_depth);\n+\n+    let u_candidates = u.ancestors().skip(u_depth - keep);\n+    let v_canidates = v.ancestors().skip(v_depth - keep);\n+    let (res, _) = u_candidates.zip(v_canidates).find(|(x, y)| x == y)?;\n+    Some(res)\n }\n \n pub fn neighbor<T: AstNode>(me: &T, direction: Direction) -> Option<T> {"}, {"sha": "a42eec91a9c20965dcb8955c8d37026a4068d547", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -21,7 +21,7 @@ pub use self::{\n         AttrKind, FieldKind, PathSegmentKind, SelfParamKind, SlicePatComponents, StructKind,\n         TypeBoundKind, VisibilityKind,\n     },\n-    generated::*,\n+    generated::{nodes::*, tokens::*},\n     tokens::*,\n     traits::*,\n };\n@@ -64,6 +64,22 @@ pub trait AstToken {\n     }\n }\n \n+mod support {\n+    use super::{AstChildren, AstNode, AstToken, SyntaxNode};\n+\n+    pub(super) fn child<N: AstNode>(parent: &SyntaxNode) -> Option<N> {\n+        parent.children().find_map(N::cast)\n+    }\n+\n+    pub(super) fn children<N: AstNode>(parent: &SyntaxNode) -> AstChildren<N> {\n+        AstChildren::new(parent)\n+    }\n+\n+    pub(super) fn token<T: AstToken>(parent: &SyntaxNode) -> Option<T> {\n+        parent.children_with_tokens().filter_map(|it| it.into_token()).find_map(T::cast)\n+    }\n+}\n+\n /// An iterator over `SyntaxNode` children of a particular AST type.\n #[derive(Debug, Clone)]\n pub struct AstChildren<N> {\n@@ -271,7 +287,7 @@ where\n     let pred = predicates.next().unwrap();\n     let mut bounds = pred.type_bound_list().unwrap().bounds();\n \n-    assert_eq!(\"'a\", pred.lifetime_token().unwrap().text());\n+    assert_eq!(\"'a\", pred.lifetime().unwrap().text());\n \n     assert_bound(\"'b\", bounds.next());\n     assert_bound(\"'c\", bounds.next());"}, {"sha": "d7931099535bf181d042d50713b9f85316ed23df", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -99,7 +99,7 @@ impl ast::ItemList {\n             None => match self.l_curly() {\n                 Some(it) => (\n                     \"    \".to_string() + &leading_indent(self.syntax()).unwrap_or_default(),\n-                    InsertPosition::After(it),\n+                    InsertPosition::After(it.syntax().clone().into()),\n                 ),\n                 None => return self.clone(),\n             },\n@@ -109,10 +109,6 @@ impl ast::ItemList {\n             [ws.ws().into(), item.syntax().clone().into()].into();\n         self.insert_children(position, to_insert)\n     }\n-\n-    fn l_curly(&self) -> Option<SyntaxElement> {\n-        self.syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n-    }\n }\n \n impl ast::RecordFieldList {\n@@ -147,7 +143,7 @@ impl ast::RecordFieldList {\n         macro_rules! after_l_curly {\n             () => {{\n                 let anchor = match self.l_curly() {\n-                    Some(it) => it,\n+                    Some(it) => it.syntax().clone().into(),\n                     None => return self.clone(),\n                 };\n                 InsertPosition::After(anchor)\n@@ -189,24 +185,20 @@ impl ast::RecordFieldList {\n \n         self.insert_children(position, to_insert)\n     }\n-\n-    fn l_curly(&self) -> Option<SyntaxElement> {\n-        self.syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n-    }\n }\n \n impl ast::TypeParam {\n     #[must_use]\n     pub fn remove_bounds(&self) -> ast::TypeParam {\n-        let colon = match self.colon_token() {\n+        let colon = match self.colon() {\n             Some(it) => it,\n             None => return self.clone(),\n         };\n         let end = match self.type_bound_list() {\n             Some(it) => it.syntax().clone().into(),\n-            None => colon.clone().into(),\n+            None => colon.syntax().clone().into(),\n         };\n-        self.replace_children(colon.into()..=end, iter::empty())\n+        self.replace_children(colon.syntax().clone().into()..=end, iter::empty())\n     }\n }\n \n@@ -305,8 +297,12 @@ impl ast::UseTree {\n             Some(it) => it,\n             None => return self.clone(),\n         };\n-        let use_tree =\n-            make::use_tree(suffix.clone(), self.use_tree_list(), self.alias(), self.has_star());\n+        let use_tree = make::use_tree(\n+            suffix.clone(),\n+            self.use_tree_list(),\n+            self.alias(),\n+            self.star().is_some(),\n+        );\n         let nested = make::use_tree_list(iter::once(use_tree));\n         return make::use_tree(prefix.clone(), Some(nested), None, false);\n "}, {"sha": "40c8fca3be3fffb2ca87109ff7713c446f17e81b", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -52,6 +52,10 @@ impl ast::RefExpr {\n     pub fn is_mut(&self) -> bool {\n         self.syntax().children_with_tokens().any(|n| n.kind() == T![mut])\n     }\n+\n+    pub fn raw_token(&self) -> Option<SyntaxToken> {\n+        None // FIXME: implement &raw\n+    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]"}, {"sha": "33fe60762a34aa8b91eed4611801a5a6116e6f90", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 75, "deletions": 72, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -4,7 +4,9 @@\n use itertools::Itertools;\n \n use crate::{\n-    ast::{self, child_opt, children, AstNode, AttrInput, NameOwner, SyntaxNode},\n+    ast::{\n+        self, child_opt, children, support, AstNode, AstToken, AttrInput, NameOwner, SyntaxNode,\n+    },\n     SmolStr, SyntaxElement,\n     SyntaxKind::*,\n     SyntaxToken, T,\n@@ -130,13 +132,6 @@ impl ast::PathSegment {\n         };\n         Some(res)\n     }\n-\n-    pub fn has_colon_colon(&self) -> bool {\n-        match self.syntax.first_child_or_token().map(|s| s.kind()) {\n-            Some(T![::]) => true,\n-            _ => false,\n-        }\n-    }\n }\n \n impl ast::Path {\n@@ -154,33 +149,13 @@ impl ast::Module {\n     }\n }\n \n-impl ast::UseTree {\n-    pub fn has_star(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|it| it.kind() == T![*])\n-    }\n-}\n-\n impl ast::UseTreeList {\n     pub fn parent_use_tree(&self) -> ast::UseTree {\n         self.syntax()\n             .parent()\n             .and_then(ast::UseTree::cast)\n             .expect(\"UseTreeLists are always nested in UseTrees\")\n     }\n-    pub fn l_curly(&self) -> Option<SyntaxToken> {\n-        self.token(T!['{'])\n-    }\n-\n-    pub fn r_curly(&self) -> Option<SyntaxToken> {\n-        self.token(T!['}'])\n-    }\n-\n-    fn token(&self, kind: SyntaxKind) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == kind)\n-    }\n }\n \n impl ast::ImplDef {\n@@ -387,24 +362,9 @@ pub enum SelfParamKind {\n }\n \n impl ast::SelfParam {\n-    pub fn self_kw_token(&self) -> SyntaxToken {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == T![self])\n-            .expect(\"invalid tree: self param must have self\")\n-    }\n-\n     pub fn kind(&self) -> SelfParamKind {\n-        let borrowed = self.syntax().children_with_tokens().any(|n| n.kind() == T![&]);\n-        if borrowed {\n-            // check for a `mut` coming after the & -- `mut &self` != `&mut self`\n-            if self\n-                .syntax()\n-                .children_with_tokens()\n-                .skip_while(|n| n.kind() != T![&])\n-                .any(|n| n.kind() == T![mut])\n-            {\n+        if self.amp().is_some() {\n+            if self.amp_mut_kw().is_some() {\n                 SelfParamKind::MutRef\n             } else {\n                 SelfParamKind::Ref\n@@ -413,32 +373,23 @@ impl ast::SelfParam {\n             SelfParamKind::Owned\n         }\n     }\n-}\n \n-impl ast::LifetimeParam {\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+    /// the \"mut\" in \"mut self\", not the one in \"&mut self\"\n+    pub fn mut_kw(&self) -> Option<ast::MutKw> {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == LIFETIME)\n+            .take_while(|it| it.kind() != T![&])\n+            .find_map(ast::MutKw::cast)\n     }\n-}\n \n-impl ast::TypeParam {\n-    pub fn colon_token(&self) -> Option<SyntaxToken> {\n+    /// the \"mut\" in \"&mut self\", not the one in \"mut self\"\n+    pub fn amp_mut_kw(&self) -> Option<ast::MutKw> {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == T![:])\n-    }\n-}\n-\n-impl ast::WherePred {\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == LIFETIME)\n+            .skip_while(|it| it.kind() != T![&])\n+            .find_map(ast::MutKw::cast)\n     }\n }\n \n@@ -449,7 +400,7 @@ pub enum TypeBoundKind {\n     /// for<'a> ...\n     ForType(ast::ForType),\n     /// 'a\n-    Lifetime(ast::SyntaxToken),\n+    Lifetime(ast::Lifetime),\n }\n \n impl ast::TypeBound {\n@@ -465,21 +416,28 @@ impl ast::TypeBound {\n         }\n     }\n \n-    fn lifetime(&self) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .children_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == LIFETIME)\n+    pub fn has_question_mark(&self) -> bool {\n+        self.question().is_some()\n     }\n \n-    pub fn question_mark_token(&self) -> Option<SyntaxToken> {\n+    pub fn const_question(&self) -> Option<ast::Question> {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == T![?])\n+            .take_while(|it| it.kind() != T![const])\n+            .find_map(ast::Question::cast)\n     }\n-    pub fn has_question_mark(&self) -> bool {\n-        self.question_mark_token().is_some()\n+\n+    pub fn question(&self) -> Option<ast::Question> {\n+        if self.const_kw().is_some() {\n+            self.syntax()\n+                .children_with_tokens()\n+                .filter_map(|it| it.into_token())\n+                .skip_while(|it| it.kind() != T![const])\n+                .find_map(ast::Question::cast)\n+        } else {\n+            support::token(&self.syntax)\n+        }\n     }\n }\n \n@@ -493,6 +451,7 @@ pub enum VisibilityKind {\n     In(ast::Path),\n     PubCrate,\n     PubSuper,\n+    PubSelf,\n     Pub,\n }\n \n@@ -504,6 +463,8 @@ impl ast::Visibility {\n             VisibilityKind::PubCrate\n         } else if self.is_pub_super() {\n             VisibilityKind::PubSuper\n+        } else if self.is_pub_self() {\n+            VisibilityKind::PubSuper\n         } else {\n             VisibilityKind::Pub\n         }\n@@ -516,6 +477,10 @@ impl ast::Visibility {\n     fn is_pub_super(&self) -> bool {\n         self.syntax().children_with_tokens().any(|it| it.kind() == T![super])\n     }\n+\n+    fn is_pub_self(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|it| it.kind() == T![self])\n+    }\n }\n \n impl ast::MacroCall {\n@@ -528,3 +493,41 @@ impl ast::MacroCall {\n         }\n     }\n }\n+\n+impl ast::LifetimeParam {\n+    pub fn lifetime_bounds(&self) -> impl Iterator<Item = ast::Lifetime> {\n+        self.syntax()\n+            .children_with_tokens()\n+            .filter_map(|it| it.into_token())\n+            .skip_while(|x| x.kind() != T![:])\n+            .filter_map(ast::Lifetime::cast)\n+    }\n+}\n+\n+impl ast::RangePat {\n+    pub fn start(&self) -> Option<ast::Pat> {\n+        self.syntax()\n+            .children_with_tokens()\n+            .take_while(|it| !ast::RangeSeparator::can_cast(it.kind()))\n+            .filter_map(|it| it.into_node())\n+            .find_map(ast::Pat::cast)\n+    }\n+\n+    pub fn end(&self) -> Option<ast::Pat> {\n+        self.syntax()\n+            .children_with_tokens()\n+            .skip_while(|it| !ast::RangeSeparator::can_cast(it.kind()))\n+            .filter_map(|it| it.into_node())\n+            .find_map(ast::Pat::cast)\n+    }\n+}\n+\n+impl ast::TokenTree {\n+    pub fn left_delimiter(&self) -> Option<ast::LeftDelimiter> {\n+        self.syntax().first_child_or_token()?.into_token().and_then(ast::LeftDelimiter::cast)\n+    }\n+\n+    pub fn right_delimiter(&self) -> Option<ast::RightDelimiter> {\n+        self.syntax().last_child_or_token()?.into_token().and_then(ast::RightDelimiter::cast)\n+    }\n+}"}, {"sha": "f5199e09f21066cd1b0d38f49737bdfaac53d904", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 5, "deletions": 7876, "changes": 7881, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d"}, {"sha": "8b348ad6e1369ac18db51c3832573ad35c2e010e", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "added", "additions": 4177, "deletions": 0, "changes": 4177, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d"}, {"sha": "e64b8bce6a488ac8f59fac85d9faa33d7b283408", "filename": "crates/ra_syntax/src/ast/generated/tokens.rs", "status": "added", "additions": 2808, "deletions": 0, "changes": 2808, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -0,0 +1,2808 @@\n+//! Generated file, do not edit by hand, see `xtask/src/codegen`\n+\n+use crate::{\n+    ast::AstToken,\n+    SyntaxKind::{self, *},\n+    SyntaxToken,\n+};\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Semi {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Semi {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Semi {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SEMI }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Comma {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Comma {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Comma {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == COMMA }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LParen {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for LParen {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for LParen {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == L_PAREN }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RParen {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RParen {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RParen {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == R_PAREN }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LCurly {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for LCurly {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for LCurly {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == L_CURLY }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RCurly {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RCurly {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RCurly {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == R_CURLY }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LBrack {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for LBrack {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for LBrack {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == L_BRACK }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RBrack {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RBrack {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RBrack {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == R_BRACK }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LAngle {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for LAngle {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for LAngle {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == L_ANGLE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RAngle {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RAngle {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RAngle {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == R_ANGLE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct At {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for At {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for At {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AT }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Pound {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Pound {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Pound {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == POUND }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Tilde {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Tilde {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Tilde {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TILDE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Question {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Question {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Question {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == QUESTION }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Dollar {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Dollar {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Dollar {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DOLLAR }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Amp {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Amp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Amp {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AMP }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Pipe {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Pipe {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Pipe {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PIPE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Plus {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Plus {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Plus {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PLUS }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Star {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Star {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Star {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STAR }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Slash {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Slash {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Slash {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SLASH }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Caret {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Caret {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Caret {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CARET }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Percent {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Percent {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Percent {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PERCENT }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Underscore {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Underscore {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Underscore {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == UNDERSCORE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Dot {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Dot {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Dot {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DOT }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Dotdot {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Dotdot {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Dotdot {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DOTDOT }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Dotdotdot {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Dotdotdot {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Dotdotdot {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DOTDOTDOT }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Dotdoteq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Dotdoteq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Dotdoteq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DOTDOTEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Colon {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Colon {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Colon {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == COLON }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Coloncolon {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Coloncolon {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Coloncolon {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == COLONCOLON }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Eq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Eq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Eq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Eqeq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Eqeq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Eqeq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EQEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct FatArrow {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for FatArrow {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for FatArrow {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FAT_ARROW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Excl {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Excl {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Excl {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EXCL }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Neq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Neq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Neq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == NEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Minus {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Minus {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Minus {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MINUS }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ThinArrow {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ThinArrow {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ThinArrow {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == THIN_ARROW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Lteq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Lteq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Lteq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LTEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Gteq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Gteq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Gteq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == GTEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Pluseq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Pluseq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Pluseq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PLUSEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Minuseq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Minuseq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Minuseq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MINUSEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Pipeeq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Pipeeq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Pipeeq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PIPEEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Ampeq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Ampeq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Ampeq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AMPEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Careteq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Careteq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Careteq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CARETEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Slasheq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Slasheq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Slasheq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SLASHEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Stareq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Stareq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Stareq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STAREQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Percenteq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Percenteq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Percenteq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PERCENTEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Ampamp {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Ampamp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Ampamp {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AMPAMP }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Pipepipe {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Pipepipe {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Pipepipe {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PIPEPIPE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Shl {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Shl {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Shl {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SHL }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Shr {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Shr {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Shr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SHR }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Shleq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Shleq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Shleq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SHLEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Shreq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Shreq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Shreq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SHREQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct AsKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for AsKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for AsKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AS_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct AsyncKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for AsyncKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for AsyncKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ASYNC_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct AwaitKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for AwaitKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for AwaitKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AWAIT_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct BoxKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for BoxKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for BoxKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BOX_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct BreakKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for BreakKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for BreakKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BREAK_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ConstKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ConstKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ConstKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ContinueKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ContinueKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ContinueKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CONTINUE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct CrateKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for CrateKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for CrateKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CRATE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for DynKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for DynKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DYN_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ElseKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ElseKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ElseKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ELSE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct EnumKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for EnumKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for EnumKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ENUM_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ExternKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ExternKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ExternKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EXTERN_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct FalseKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for FalseKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for FalseKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FALSE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct FnKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for FnKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for FnKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FN_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ForKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ForKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ForKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct IfKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for IfKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for IfKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == IF_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ImplKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ImplKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ImplKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == IMPL_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct InKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for InKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for InKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == IN_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LetKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for LetKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for LetKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LET_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LoopKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for LoopKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for LoopKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LOOP_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MacroKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for MacroKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for MacroKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MACRO_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MatchKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for MatchKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for MatchKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ModKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ModKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ModKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MOD_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MoveKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for MoveKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for MoveKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MOVE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MutKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for MutKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for MutKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MUT_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct PubKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for PubKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for PubKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PUB_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RefKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RefKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RefKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == REF_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ReturnKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ReturnKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ReturnKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RETURN_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct SelfKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for SelfKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for SelfKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SELF_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct StaticKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for StaticKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for StaticKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STATIC_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct StructKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for StructKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for StructKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct SuperKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for SuperKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for SuperKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SUPER_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TraitKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for TraitKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for TraitKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TRAIT_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TrueKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for TrueKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for TrueKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TRUE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TryKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for TryKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for TryKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TRY_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TypeKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for TypeKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for TypeKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct UnsafeKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for UnsafeKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for UnsafeKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == UNSAFE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct UseKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for UseKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for UseKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct WhereKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for WhereKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for WhereKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == WHERE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct WhileKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for WhileKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for WhileKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == WHILE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct AutoKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for AutoKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for AutoKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AUTO_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DefaultKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for DefaultKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for DefaultKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DEFAULT_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ExistentialKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ExistentialKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ExistentialKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EXISTENTIAL_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct UnionKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for UnionKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for UnionKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == UNION_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RawKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RawKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RawKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RAW_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct IntNumber {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for IntNumber {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for IntNumber {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == INT_NUMBER }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct FloatNumber {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for FloatNumber {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for FloatNumber {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FLOAT_NUMBER }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Char {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Char {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Char {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CHAR }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Byte {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Byte {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Byte {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BYTE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct String {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for String {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for String {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STRING }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RawString {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RawString {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RawString {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RAW_STRING }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ByteString {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ByteString {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ByteString {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BYTE_STRING }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RawByteString {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RawByteString {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RawByteString {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RAW_BYTE_STRING }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Error {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Error {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Error {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ERROR }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Ident {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Ident {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Ident {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == IDENT }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Whitespace {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Whitespace {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Whitespace {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == WHITESPACE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Lifetime {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Lifetime {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Lifetime {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LIFETIME }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Comment {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Comment {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Comment {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == COMMENT }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Shebang {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Shebang {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Shebang {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SHEBANG }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LDollar {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for LDollar {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for LDollar {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == L_DOLLAR }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RDollar {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RDollar {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RDollar {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == R_DOLLAR }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum LeftDelimiter {\n+    LParen(LParen),\n+    LBrack(LBrack),\n+    LCurly(LCurly),\n+}\n+impl From<LParen> for LeftDelimiter {\n+    fn from(node: LParen) -> LeftDelimiter { LeftDelimiter::LParen(node) }\n+}\n+impl From<LBrack> for LeftDelimiter {\n+    fn from(node: LBrack) -> LeftDelimiter { LeftDelimiter::LBrack(node) }\n+}\n+impl From<LCurly> for LeftDelimiter {\n+    fn from(node: LCurly) -> LeftDelimiter { LeftDelimiter::LCurly(node) }\n+}\n+impl std::fmt::Display for LeftDelimiter {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for LeftDelimiter {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            L_PAREN | L_BRACK | L_CURLY => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            L_PAREN => LeftDelimiter::LParen(LParen { syntax }),\n+            L_BRACK => LeftDelimiter::LBrack(LBrack { syntax }),\n+            L_CURLY => LeftDelimiter::LCurly(LCurly { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            LeftDelimiter::LParen(it) => &it.syntax,\n+            LeftDelimiter::LBrack(it) => &it.syntax,\n+            LeftDelimiter::LCurly(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum RightDelimiter {\n+    RParen(RParen),\n+    RBrack(RBrack),\n+    RCurly(RCurly),\n+}\n+impl From<RParen> for RightDelimiter {\n+    fn from(node: RParen) -> RightDelimiter { RightDelimiter::RParen(node) }\n+}\n+impl From<RBrack> for RightDelimiter {\n+    fn from(node: RBrack) -> RightDelimiter { RightDelimiter::RBrack(node) }\n+}\n+impl From<RCurly> for RightDelimiter {\n+    fn from(node: RCurly) -> RightDelimiter { RightDelimiter::RCurly(node) }\n+}\n+impl std::fmt::Display for RightDelimiter {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for RightDelimiter {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            R_PAREN | R_BRACK | R_CURLY => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            R_PAREN => RightDelimiter::RParen(RParen { syntax }),\n+            R_BRACK => RightDelimiter::RBrack(RBrack { syntax }),\n+            R_CURLY => RightDelimiter::RCurly(RCurly { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            RightDelimiter::RParen(it) => &it.syntax,\n+            RightDelimiter::RBrack(it) => &it.syntax,\n+            RightDelimiter::RCurly(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum RangeSeparator {\n+    Dotdot(Dotdot),\n+    Dotdotdot(Dotdotdot),\n+    Dotdoteq(Dotdoteq),\n+}\n+impl From<Dotdot> for RangeSeparator {\n+    fn from(node: Dotdot) -> RangeSeparator { RangeSeparator::Dotdot(node) }\n+}\n+impl From<Dotdotdot> for RangeSeparator {\n+    fn from(node: Dotdotdot) -> RangeSeparator { RangeSeparator::Dotdotdot(node) }\n+}\n+impl From<Dotdoteq> for RangeSeparator {\n+    fn from(node: Dotdoteq) -> RangeSeparator { RangeSeparator::Dotdoteq(node) }\n+}\n+impl std::fmt::Display for RangeSeparator {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for RangeSeparator {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            DOTDOT | DOTDOTDOT | DOTDOTEQ => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            DOTDOT => RangeSeparator::Dotdot(Dotdot { syntax }),\n+            DOTDOTDOT => RangeSeparator::Dotdotdot(Dotdotdot { syntax }),\n+            DOTDOTEQ => RangeSeparator::Dotdoteq(Dotdoteq { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            RangeSeparator::Dotdot(it) => &it.syntax,\n+            RangeSeparator::Dotdotdot(it) => &it.syntax,\n+            RangeSeparator::Dotdoteq(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum BinOp {\n+    Pipepipe(Pipepipe),\n+    Ampamp(Ampamp),\n+    Eqeq(Eqeq),\n+    Neq(Neq),\n+    Lteq(Lteq),\n+    Gteq(Gteq),\n+    LAngle(LAngle),\n+    RAngle(RAngle),\n+    Plus(Plus),\n+    Star(Star),\n+    Minus(Minus),\n+    Slash(Slash),\n+    Percent(Percent),\n+    Shl(Shl),\n+    Shr(Shr),\n+    Caret(Caret),\n+    Pipe(Pipe),\n+    Amp(Amp),\n+    Eq(Eq),\n+    Pluseq(Pluseq),\n+    Slasheq(Slasheq),\n+    Stareq(Stareq),\n+    Percenteq(Percenteq),\n+    Shreq(Shreq),\n+    Shleq(Shleq),\n+    Minuseq(Minuseq),\n+    Pipeeq(Pipeeq),\n+    Ampeq(Ampeq),\n+    Careteq(Careteq),\n+}\n+impl From<Pipepipe> for BinOp {\n+    fn from(node: Pipepipe) -> BinOp { BinOp::Pipepipe(node) }\n+}\n+impl From<Ampamp> for BinOp {\n+    fn from(node: Ampamp) -> BinOp { BinOp::Ampamp(node) }\n+}\n+impl From<Eqeq> for BinOp {\n+    fn from(node: Eqeq) -> BinOp { BinOp::Eqeq(node) }\n+}\n+impl From<Neq> for BinOp {\n+    fn from(node: Neq) -> BinOp { BinOp::Neq(node) }\n+}\n+impl From<Lteq> for BinOp {\n+    fn from(node: Lteq) -> BinOp { BinOp::Lteq(node) }\n+}\n+impl From<Gteq> for BinOp {\n+    fn from(node: Gteq) -> BinOp { BinOp::Gteq(node) }\n+}\n+impl From<LAngle> for BinOp {\n+    fn from(node: LAngle) -> BinOp { BinOp::LAngle(node) }\n+}\n+impl From<RAngle> for BinOp {\n+    fn from(node: RAngle) -> BinOp { BinOp::RAngle(node) }\n+}\n+impl From<Plus> for BinOp {\n+    fn from(node: Plus) -> BinOp { BinOp::Plus(node) }\n+}\n+impl From<Star> for BinOp {\n+    fn from(node: Star) -> BinOp { BinOp::Star(node) }\n+}\n+impl From<Minus> for BinOp {\n+    fn from(node: Minus) -> BinOp { BinOp::Minus(node) }\n+}\n+impl From<Slash> for BinOp {\n+    fn from(node: Slash) -> BinOp { BinOp::Slash(node) }\n+}\n+impl From<Percent> for BinOp {\n+    fn from(node: Percent) -> BinOp { BinOp::Percent(node) }\n+}\n+impl From<Shl> for BinOp {\n+    fn from(node: Shl) -> BinOp { BinOp::Shl(node) }\n+}\n+impl From<Shr> for BinOp {\n+    fn from(node: Shr) -> BinOp { BinOp::Shr(node) }\n+}\n+impl From<Caret> for BinOp {\n+    fn from(node: Caret) -> BinOp { BinOp::Caret(node) }\n+}\n+impl From<Pipe> for BinOp {\n+    fn from(node: Pipe) -> BinOp { BinOp::Pipe(node) }\n+}\n+impl From<Amp> for BinOp {\n+    fn from(node: Amp) -> BinOp { BinOp::Amp(node) }\n+}\n+impl From<Eq> for BinOp {\n+    fn from(node: Eq) -> BinOp { BinOp::Eq(node) }\n+}\n+impl From<Pluseq> for BinOp {\n+    fn from(node: Pluseq) -> BinOp { BinOp::Pluseq(node) }\n+}\n+impl From<Slasheq> for BinOp {\n+    fn from(node: Slasheq) -> BinOp { BinOp::Slasheq(node) }\n+}\n+impl From<Stareq> for BinOp {\n+    fn from(node: Stareq) -> BinOp { BinOp::Stareq(node) }\n+}\n+impl From<Percenteq> for BinOp {\n+    fn from(node: Percenteq) -> BinOp { BinOp::Percenteq(node) }\n+}\n+impl From<Shreq> for BinOp {\n+    fn from(node: Shreq) -> BinOp { BinOp::Shreq(node) }\n+}\n+impl From<Shleq> for BinOp {\n+    fn from(node: Shleq) -> BinOp { BinOp::Shleq(node) }\n+}\n+impl From<Minuseq> for BinOp {\n+    fn from(node: Minuseq) -> BinOp { BinOp::Minuseq(node) }\n+}\n+impl From<Pipeeq> for BinOp {\n+    fn from(node: Pipeeq) -> BinOp { BinOp::Pipeeq(node) }\n+}\n+impl From<Ampeq> for BinOp {\n+    fn from(node: Ampeq) -> BinOp { BinOp::Ampeq(node) }\n+}\n+impl From<Careteq> for BinOp {\n+    fn from(node: Careteq) -> BinOp { BinOp::Careteq(node) }\n+}\n+impl std::fmt::Display for BinOp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for BinOp {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PIPEPIPE | AMPAMP | EQEQ | NEQ | LTEQ | GTEQ | L_ANGLE | R_ANGLE | PLUS | STAR\n+            | MINUS | SLASH | PERCENT | SHL | SHR | CARET | PIPE | AMP | EQ | PLUSEQ | SLASHEQ\n+            | STAREQ | PERCENTEQ | SHREQ | SHLEQ | MINUSEQ | PIPEEQ | AMPEQ | CARETEQ => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            PIPEPIPE => BinOp::Pipepipe(Pipepipe { syntax }),\n+            AMPAMP => BinOp::Ampamp(Ampamp { syntax }),\n+            EQEQ => BinOp::Eqeq(Eqeq { syntax }),\n+            NEQ => BinOp::Neq(Neq { syntax }),\n+            LTEQ => BinOp::Lteq(Lteq { syntax }),\n+            GTEQ => BinOp::Gteq(Gteq { syntax }),\n+            L_ANGLE => BinOp::LAngle(LAngle { syntax }),\n+            R_ANGLE => BinOp::RAngle(RAngle { syntax }),\n+            PLUS => BinOp::Plus(Plus { syntax }),\n+            STAR => BinOp::Star(Star { syntax }),\n+            MINUS => BinOp::Minus(Minus { syntax }),\n+            SLASH => BinOp::Slash(Slash { syntax }),\n+            PERCENT => BinOp::Percent(Percent { syntax }),\n+            SHL => BinOp::Shl(Shl { syntax }),\n+            SHR => BinOp::Shr(Shr { syntax }),\n+            CARET => BinOp::Caret(Caret { syntax }),\n+            PIPE => BinOp::Pipe(Pipe { syntax }),\n+            AMP => BinOp::Amp(Amp { syntax }),\n+            EQ => BinOp::Eq(Eq { syntax }),\n+            PLUSEQ => BinOp::Pluseq(Pluseq { syntax }),\n+            SLASHEQ => BinOp::Slasheq(Slasheq { syntax }),\n+            STAREQ => BinOp::Stareq(Stareq { syntax }),\n+            PERCENTEQ => BinOp::Percenteq(Percenteq { syntax }),\n+            SHREQ => BinOp::Shreq(Shreq { syntax }),\n+            SHLEQ => BinOp::Shleq(Shleq { syntax }),\n+            MINUSEQ => BinOp::Minuseq(Minuseq { syntax }),\n+            PIPEEQ => BinOp::Pipeeq(Pipeeq { syntax }),\n+            AMPEQ => BinOp::Ampeq(Ampeq { syntax }),\n+            CARETEQ => BinOp::Careteq(Careteq { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            BinOp::Pipepipe(it) => &it.syntax,\n+            BinOp::Ampamp(it) => &it.syntax,\n+            BinOp::Eqeq(it) => &it.syntax,\n+            BinOp::Neq(it) => &it.syntax,\n+            BinOp::Lteq(it) => &it.syntax,\n+            BinOp::Gteq(it) => &it.syntax,\n+            BinOp::LAngle(it) => &it.syntax,\n+            BinOp::RAngle(it) => &it.syntax,\n+            BinOp::Plus(it) => &it.syntax,\n+            BinOp::Star(it) => &it.syntax,\n+            BinOp::Minus(it) => &it.syntax,\n+            BinOp::Slash(it) => &it.syntax,\n+            BinOp::Percent(it) => &it.syntax,\n+            BinOp::Shl(it) => &it.syntax,\n+            BinOp::Shr(it) => &it.syntax,\n+            BinOp::Caret(it) => &it.syntax,\n+            BinOp::Pipe(it) => &it.syntax,\n+            BinOp::Amp(it) => &it.syntax,\n+            BinOp::Eq(it) => &it.syntax,\n+            BinOp::Pluseq(it) => &it.syntax,\n+            BinOp::Slasheq(it) => &it.syntax,\n+            BinOp::Stareq(it) => &it.syntax,\n+            BinOp::Percenteq(it) => &it.syntax,\n+            BinOp::Shreq(it) => &it.syntax,\n+            BinOp::Shleq(it) => &it.syntax,\n+            BinOp::Minuseq(it) => &it.syntax,\n+            BinOp::Pipeeq(it) => &it.syntax,\n+            BinOp::Ampeq(it) => &it.syntax,\n+            BinOp::Careteq(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum PrefixOp {\n+    Minus(Minus),\n+    Excl(Excl),\n+    Star(Star),\n+}\n+impl From<Minus> for PrefixOp {\n+    fn from(node: Minus) -> PrefixOp { PrefixOp::Minus(node) }\n+}\n+impl From<Excl> for PrefixOp {\n+    fn from(node: Excl) -> PrefixOp { PrefixOp::Excl(node) }\n+}\n+impl From<Star> for PrefixOp {\n+    fn from(node: Star) -> PrefixOp { PrefixOp::Star(node) }\n+}\n+impl std::fmt::Display for PrefixOp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for PrefixOp {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MINUS | EXCL | STAR => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            MINUS => PrefixOp::Minus(Minus { syntax }),\n+            EXCL => PrefixOp::Excl(Excl { syntax }),\n+            STAR => PrefixOp::Star(Star { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            PrefixOp::Minus(it) => &it.syntax,\n+            PrefixOp::Excl(it) => &it.syntax,\n+            PrefixOp::Star(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum RangeOp {\n+    Dotdot(Dotdot),\n+    Dotdoteq(Dotdoteq),\n+}\n+impl From<Dotdot> for RangeOp {\n+    fn from(node: Dotdot) -> RangeOp { RangeOp::Dotdot(node) }\n+}\n+impl From<Dotdoteq> for RangeOp {\n+    fn from(node: Dotdoteq) -> RangeOp { RangeOp::Dotdoteq(node) }\n+}\n+impl std::fmt::Display for RangeOp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for RangeOp {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            DOTDOT | DOTDOTEQ => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            DOTDOT => RangeOp::Dotdot(Dotdot { syntax }),\n+            DOTDOTEQ => RangeOp::Dotdoteq(Dotdoteq { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            RangeOp::Dotdot(it) => &it.syntax,\n+            RangeOp::Dotdoteq(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum LiteralToken {\n+    IntNumber(IntNumber),\n+    FloatNumber(FloatNumber),\n+    String(String),\n+    RawString(RawString),\n+    TrueKw(TrueKw),\n+    FalseKw(FalseKw),\n+    ByteString(ByteString),\n+    RawByteString(RawByteString),\n+    Char(Char),\n+    Byte(Byte),\n+}\n+impl From<IntNumber> for LiteralToken {\n+    fn from(node: IntNumber) -> LiteralToken { LiteralToken::IntNumber(node) }\n+}\n+impl From<FloatNumber> for LiteralToken {\n+    fn from(node: FloatNumber) -> LiteralToken { LiteralToken::FloatNumber(node) }\n+}\n+impl From<String> for LiteralToken {\n+    fn from(node: String) -> LiteralToken { LiteralToken::String(node) }\n+}\n+impl From<RawString> for LiteralToken {\n+    fn from(node: RawString) -> LiteralToken { LiteralToken::RawString(node) }\n+}\n+impl From<TrueKw> for LiteralToken {\n+    fn from(node: TrueKw) -> LiteralToken { LiteralToken::TrueKw(node) }\n+}\n+impl From<FalseKw> for LiteralToken {\n+    fn from(node: FalseKw) -> LiteralToken { LiteralToken::FalseKw(node) }\n+}\n+impl From<ByteString> for LiteralToken {\n+    fn from(node: ByteString) -> LiteralToken { LiteralToken::ByteString(node) }\n+}\n+impl From<RawByteString> for LiteralToken {\n+    fn from(node: RawByteString) -> LiteralToken { LiteralToken::RawByteString(node) }\n+}\n+impl From<Char> for LiteralToken {\n+    fn from(node: Char) -> LiteralToken { LiteralToken::Char(node) }\n+}\n+impl From<Byte> for LiteralToken {\n+    fn from(node: Byte) -> LiteralToken { LiteralToken::Byte(node) }\n+}\n+impl std::fmt::Display for LiteralToken {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for LiteralToken {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            INT_NUMBER | FLOAT_NUMBER | STRING | RAW_STRING | TRUE_KW | FALSE_KW | BYTE_STRING\n+            | RAW_BYTE_STRING | CHAR | BYTE => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            INT_NUMBER => LiteralToken::IntNumber(IntNumber { syntax }),\n+            FLOAT_NUMBER => LiteralToken::FloatNumber(FloatNumber { syntax }),\n+            STRING => LiteralToken::String(String { syntax }),\n+            RAW_STRING => LiteralToken::RawString(RawString { syntax }),\n+            TRUE_KW => LiteralToken::TrueKw(TrueKw { syntax }),\n+            FALSE_KW => LiteralToken::FalseKw(FalseKw { syntax }),\n+            BYTE_STRING => LiteralToken::ByteString(ByteString { syntax }),\n+            RAW_BYTE_STRING => LiteralToken::RawByteString(RawByteString { syntax }),\n+            CHAR => LiteralToken::Char(Char { syntax }),\n+            BYTE => LiteralToken::Byte(Byte { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            LiteralToken::IntNumber(it) => &it.syntax,\n+            LiteralToken::FloatNumber(it) => &it.syntax,\n+            LiteralToken::String(it) => &it.syntax,\n+            LiteralToken::RawString(it) => &it.syntax,\n+            LiteralToken::TrueKw(it) => &it.syntax,\n+            LiteralToken::FalseKw(it) => &it.syntax,\n+            LiteralToken::ByteString(it) => &it.syntax,\n+            LiteralToken::RawByteString(it) => &it.syntax,\n+            LiteralToken::Char(it) => &it.syntax,\n+            LiteralToken::Byte(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum NameRefToken {\n+    Ident(Ident),\n+    IntNumber(IntNumber),\n+}\n+impl From<Ident> for NameRefToken {\n+    fn from(node: Ident) -> NameRefToken { NameRefToken::Ident(node) }\n+}\n+impl From<IntNumber> for NameRefToken {\n+    fn from(node: IntNumber) -> NameRefToken { NameRefToken::IntNumber(node) }\n+}\n+impl std::fmt::Display for NameRefToken {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for NameRefToken {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            IDENT | INT_NUMBER => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            IDENT => NameRefToken::Ident(Ident { syntax }),\n+            INT_NUMBER => NameRefToken::IntNumber(IntNumber { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            NameRefToken::Ident(it) => &it.syntax,\n+            NameRefToken::IntNumber(it) => &it.syntax,\n+        }\n+    }\n+}"}, {"sha": "870e838048ab548ddba224b8d56f46edddd4c4df", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -5,7 +5,7 @@\n use itertools::Itertools;\n \n use crate::{\n-    ast::{self, child_opt, children, AstChildren, AstNode, AstToken},\n+    ast::{self, child_opt, children, support, AstChildren, AstNode, AstToken},\n     syntax_node::SyntaxElementChildren,\n };\n \n@@ -31,6 +31,10 @@ pub trait LoopBodyOwner: AstNode {\n     fn loop_body(&self) -> Option<ast::BlockExpr> {\n         child_opt(self)\n     }\n+\n+    fn label(&self) -> Option<ast::Label> {\n+        child_opt(self)\n+    }\n }\n \n pub trait ArgListOwner: AstNode {\n@@ -65,6 +69,10 @@ pub trait TypeBoundsOwner: AstNode {\n     fn type_bound_list(&self) -> Option<ast::TypeBoundList> {\n         child_opt(self)\n     }\n+\n+    fn colon(&self) -> Option<ast::Colon> {\n+        support::token(self.syntax())\n+    }\n }\n \n pub trait AttrsOwner: AstNode {"}, {"sha": "1b0acf47c6a1cffe70c135f574633582fd7f2ddc", "filename": "crates/ra_syntax/test_data/parser/ok/0065_plus_after_fn_trait_bound.rast", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0065_plus_after_fn_trait_bound.rast", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0065_plus_after_fn_trait_bound.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0065_plus_after_fn_trait_bound.rast?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -0,0 +1,61 @@\n+SOURCE_FILE@[0; 40)\n+  FN_DEF@[0; 39)\n+    FN_KW@[0; 2) \"fn\"\n+    WHITESPACE@[2; 3) \" \"\n+    NAME@[3; 4)\n+      IDENT@[3; 4) \"f\"\n+    TYPE_PARAM_LIST@[4; 7)\n+      L_ANGLE@[4; 5) \"<\"\n+      TYPE_PARAM@[5; 6)\n+        NAME@[5; 6)\n+          IDENT@[5; 6) \"T\"\n+      R_ANGLE@[6; 7) \">\"\n+    PARAM_LIST@[7; 9)\n+      L_PAREN@[7; 8) \"(\"\n+      R_PAREN@[8; 9) \")\"\n+    WHITESPACE@[9; 10) \" \"\n+    WHERE_CLAUSE@[10; 36)\n+      WHERE_KW@[10; 15) \"where\"\n+      WHITESPACE@[15; 16) \" \"\n+      WHERE_PRED@[16; 36)\n+        PATH_TYPE@[16; 17)\n+          PATH@[16; 17)\n+            PATH_SEGMENT@[16; 17)\n+              NAME_REF@[16; 17)\n+                IDENT@[16; 17) \"T\"\n+        COLON@[17; 18) \":\"\n+        WHITESPACE@[18; 19) \" \"\n+        TYPE_BOUND_LIST@[19; 36)\n+          TYPE_BOUND@[19; 29)\n+            PATH_TYPE@[19; 29)\n+              PATH@[19; 29)\n+                PATH_SEGMENT@[19; 29)\n+                  NAME_REF@[19; 21)\n+                    IDENT@[19; 21) \"Fn\"\n+                  PARAM_LIST@[21; 23)\n+                    L_PAREN@[21; 22) \"(\"\n+                    R_PAREN@[22; 23) \")\"\n+                  WHITESPACE@[23; 24) \" \"\n+                  RET_TYPE@[24; 29)\n+                    THIN_ARROW@[24; 26) \"->\"\n+                    WHITESPACE@[26; 27) \" \"\n+                    PATH_TYPE@[27; 29)\n+                      PATH@[27; 29)\n+                        PATH_SEGMENT@[27; 29)\n+                          NAME_REF@[27; 29)\n+                            IDENT@[27; 29) \"u8\"\n+          WHITESPACE@[29; 30) \" \"\n+          PLUS@[30; 31) \"+\"\n+          WHITESPACE@[31; 32) \" \"\n+          TYPE_BOUND@[32; 36)\n+            PATH_TYPE@[32; 36)\n+              PATH@[32; 36)\n+                PATH_SEGMENT@[32; 36)\n+                  NAME_REF@[32; 36)\n+                    IDENT@[32; 36) \"Send\"\n+    WHITESPACE@[36; 37) \" \"\n+    BLOCK_EXPR@[37; 39)\n+      BLOCK@[37; 39)\n+        L_CURLY@[37; 38) \"{\"\n+        R_CURLY@[38; 39) \"}\"\n+  WHITESPACE@[39; 40) \"\\n\""}, {"sha": "29f3655e013c56c6a7c53cca801f5335cb998d4e", "filename": "crates/ra_syntax/test_data/parser/ok/0065_plus_after_fn_trait_bound.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0065_plus_after_fn_trait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0065_plus_after_fn_trait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0065_plus_after_fn_trait_bound.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -0,0 +1 @@\n+fn f<T>() where T: Fn() -> u8 + Send {}"}, {"sha": "eba66ff4d90ff6052924769a9d6fa12d7a67a1b0", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 287, "deletions": 91, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -70,7 +70,7 @@ pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n         \"match\", \"mod\", \"move\", \"mut\", \"pub\", \"ref\", \"return\", \"self\", \"static\", \"struct\", \"super\",\n         \"trait\", \"true\", \"try\", \"type\", \"unsafe\", \"use\", \"where\", \"while\",\n     ],\n-    contextual_keywords: &[\"auto\", \"default\", \"existential\", \"union\"],\n+    contextual_keywords: &[\"auto\", \"default\", \"existential\", \"union\", \"raw\"],\n     literals: &[\n         \"INT_NUMBER\",\n         \"FLOAT_NUMBER\",\n@@ -227,6 +227,7 @@ pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n pub(crate) struct AstSrc<'a> {\n     pub(crate) nodes: &'a [AstNodeSrc<'a>],\n     pub(crate) enums: &'a [AstEnumSrc<'a>],\n+    pub(crate) token_enums: &'a [AstEnumSrc<'a>],\n }\n \n pub(crate) struct AstNodeSrc<'a> {\n@@ -297,248 +298,355 @@ macro_rules! ast_enums {\n \n pub(crate) const AST_SRC: AstSrc = AstSrc {\n     nodes: &ast_nodes! {\n-        struct SourceFile: ModuleItemOwner, FnDefOwner {\n+        struct SourceFile: ModuleItemOwner, FnDefOwner, AttrsOwner {\n             modules: [Module],\n         }\n \n         struct FnDef: VisibilityOwner, NameOwner, TypeParamsOwner, DocCommentsOwner, AttrsOwner {\n+            Abi,\n+            ConstKw,\n+            DefaultKw,\n+            AsyncKw,\n+            UnsafeKw,\n+            FnKw,\n             ParamList,\n             RetType,\n             body: BlockExpr,\n+            Semi\n         }\n \n-        struct RetType { TypeRef }\n+        struct RetType { ThinArrow, TypeRef }\n \n         struct StructDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n+            StructKw,\n+            FieldDefList,\n+            Semi\n         }\n \n         struct UnionDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n+            UnionKw,\n             RecordFieldDefList,\n         }\n \n-        struct RecordFieldDefList { fields: [RecordFieldDef] }\n+        struct RecordFieldDefList { LCurly, fields: [RecordFieldDef], RCurly }\n         struct RecordFieldDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner { }\n \n-        struct TupleFieldDefList { fields: [TupleFieldDef] }\n+        struct TupleFieldDefList { LParen, fields: [TupleFieldDef], RParen }\n         struct TupleFieldDef: VisibilityOwner, AttrsOwner {\n             TypeRef,\n         }\n \n         struct EnumDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner {\n+            EnumKw,\n             variant_list: EnumVariantList,\n         }\n         struct EnumVariantList {\n+            LCurly,\n             variants: [EnumVariant],\n+            RCurly\n         }\n-        struct EnumVariant: NameOwner, DocCommentsOwner, AttrsOwner {\n+        struct EnumVariant: VisibilityOwner, NameOwner, DocCommentsOwner, AttrsOwner {\n+            FieldDefList,\n+            Eq,\n             Expr\n         }\n \n         struct TraitDef: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner, TypeParamsOwner, TypeBoundsOwner {\n+            UnsafeKw,\n+            AutoKw,\n+            TraitKw,\n             ItemList,\n         }\n \n         struct Module: VisibilityOwner, NameOwner, AttrsOwner, DocCommentsOwner {\n+            ModKw,\n             ItemList,\n+            Semi\n         }\n \n         struct ItemList: FnDefOwner, ModuleItemOwner {\n+            LCurly,\n             impl_items: [ImplItem],\n+            RCurly\n         }\n \n         struct ConstDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n+            DefaultKw,\n+            ConstKw,\n+            Eq,\n             body: Expr,\n+            Semi\n         }\n \n         struct StaticDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeAscriptionOwner {\n+            StaticKw,\n+            MutKw,\n+            Eq,\n             body: Expr,\n+            Semi\n         }\n \n         struct TypeAliasDef: VisibilityOwner, NameOwner, TypeParamsOwner, AttrsOwner, DocCommentsOwner, TypeBoundsOwner {\n+            DefaultKw,\n+            TypeKw,\n+            Eq,\n             TypeRef,\n+            Semi\n         }\n \n         struct ImplDef: TypeParamsOwner, AttrsOwner {\n+            DefaultKw,\n+            ConstKw,\n+            UnsafeKw,\n+            ImplKw,\n+            Excl,\n+            ForKw,\n             ItemList,\n         }\n \n-        struct ParenType { TypeRef }\n-        struct TupleType { fields: [TypeRef] }\n-        struct NeverType { }\n+        struct ParenType { LParen, TypeRef, RParen }\n+        struct TupleType { LParen, fields: [TypeRef], RParen }\n+        struct NeverType { Excl }\n         struct PathType { Path }\n-        struct PointerType { TypeRef }\n-        struct ArrayType { TypeRef, Expr }\n-        struct SliceType { TypeRef }\n-        struct ReferenceType { TypeRef }\n-        struct PlaceholderType {  }\n-        struct FnPointerType { ParamList, RetType }\n-        struct ForType { TypeRef }\n-        struct ImplTraitType: TypeBoundsOwner {}\n-        struct DynTraitType: TypeBoundsOwner {}\n-\n-        struct TupleExpr { exprs: [Expr] }\n-        struct ArrayExpr { exprs: [Expr] }\n-        struct ParenExpr { Expr }\n+        struct PointerType { Star, ConstKw, TypeRef }\n+        struct ArrayType { LBrack, TypeRef, Semi, Expr, RBrack }\n+        struct SliceType { LBrack, TypeRef, RBrack }\n+        struct ReferenceType { Amp, Lifetime, MutKw, TypeRef }\n+        struct PlaceholderType { Underscore }\n+        struct FnPointerType { Abi, UnsafeKw, FnKw, ParamList, RetType }\n+        struct ForType { ForKw, TypeParamList, TypeRef }\n+        struct ImplTraitType: TypeBoundsOwner { ImplKw }\n+        struct DynTraitType: TypeBoundsOwner { DynKw }\n+\n+        struct TupleExpr: AttrsOwner { LParen, exprs: [Expr], RParen }\n+        struct ArrayExpr: AttrsOwner { LBrack, exprs: [Expr], Semi, RBrack }\n+        struct ParenExpr: AttrsOwner { LParen, Expr, RParen }\n         struct PathExpr  { Path }\n-        struct LambdaExpr {\n+        struct LambdaExpr: AttrsOwner {\n+            StaticKw,\n+            AsyncKw,\n+            MoveKw,\n             ParamList,\n             RetType,\n             body: Expr,\n         }\n-        struct IfExpr { Condition }\n-        struct LoopExpr: LoopBodyOwner { }\n-        struct TryBlockExpr { body: BlockExpr }\n-        struct ForExpr: LoopBodyOwner {\n+        struct IfExpr: AttrsOwner { IfKw, Condition }\n+        struct LoopExpr: AttrsOwner, LoopBodyOwner { LoopKw }\n+        struct TryBlockExpr: AttrsOwner { TryKw, body: BlockExpr }\n+        struct ForExpr: AttrsOwner, LoopBodyOwner {\n+            ForKw,\n             Pat,\n+            InKw,\n             iterable: Expr,\n         }\n-        struct WhileExpr: LoopBodyOwner { Condition }\n-        struct ContinueExpr {}\n-        struct BreakExpr { Expr }\n-        struct Label {}\n-        struct BlockExpr { Block  }\n-        struct ReturnExpr { Expr }\n+        struct WhileExpr: AttrsOwner, LoopBodyOwner { WhileKw, Condition }\n+        struct ContinueExpr: AttrsOwner { ContinueKw, Lifetime }\n+        struct BreakExpr: AttrsOwner { BreakKw, Lifetime, Expr }\n+        struct Label { Lifetime }\n+        struct BlockExpr: AttrsOwner { Label, UnsafeKw, Block  }\n+        struct ReturnExpr: AttrsOwner { Expr }\n         struct CallExpr: ArgListOwner { Expr }\n-        struct MethodCallExpr: ArgListOwner {\n-            Expr, NameRef, TypeArgList,\n-        }\n-        struct IndexExpr {}\n-        struct FieldExpr { Expr, NameRef }\n-        struct AwaitExpr { Expr }\n-        struct TryExpr { Expr }\n-        struct CastExpr { Expr, TypeRef }\n-        struct RefExpr { Expr }\n-        struct PrefixExpr { Expr }\n-        struct BoxExpr { Expr }\n-        struct RangeExpr {}\n-        struct BinExpr {}\n-        struct Literal {}\n-\n-        struct MatchExpr { Expr, MatchArmList }\n-        struct MatchArmList: AttrsOwner { arms: [MatchArm] }\n+        struct MethodCallExpr: AttrsOwner, ArgListOwner {\n+            Expr, Dot, NameRef, TypeArgList,\n+        }\n+        struct IndexExpr: AttrsOwner { LBrack, RBrack }\n+        struct FieldExpr: AttrsOwner { Expr, Dot, NameRef }\n+        struct AwaitExpr: AttrsOwner { Expr, Dot, AwaitKw }\n+        struct TryExpr: AttrsOwner { TryKw, Expr }\n+        struct CastExpr: AttrsOwner { Expr, AsKw, TypeRef }\n+        struct RefExpr: AttrsOwner { Amp, RawKw, MutKw, Expr }\n+        struct PrefixExpr: AttrsOwner { PrefixOp, Expr }\n+        struct BoxExpr: AttrsOwner { BoxKw, Expr }\n+        struct RangeExpr: AttrsOwner { RangeOp }\n+        struct BinExpr: AttrsOwner { BinOp }\n+        struct Literal { LiteralToken }\n+\n+        struct MatchExpr: AttrsOwner { MatchKw, Expr, MatchArmList }\n+        struct MatchArmList: AttrsOwner { LCurly, arms: [MatchArm], RCurly }\n         struct MatchArm: AttrsOwner {\n             pat: Pat,\n             guard: MatchGuard,\n+            FatArrow,\n             Expr,\n         }\n-        struct MatchGuard { Expr }\n+        struct MatchGuard { IfKw, Expr }\n \n-        struct RecordLit { Path, RecordFieldList }\n+        struct RecordLit { Path, RecordFieldList}\n         struct RecordFieldList {\n+            LCurly,\n             fields: [RecordField],\n+            Dotdot,\n             spread: Expr,\n+            RCurly\n         }\n-        struct RecordField { NameRef, Expr }\n+        struct RecordField: AttrsOwner { NameRef, Colon, Expr }\n \n         struct OrPat { pats: [Pat] }\n-        struct ParenPat { Pat }\n-        struct RefPat { Pat }\n-        struct BoxPat { Pat }\n-        struct BindPat: NameOwner { Pat }\n-        struct PlaceholderPat { }\n-        struct DotDotPat { }\n+        struct ParenPat { LParen, Pat, RParen }\n+        struct RefPat { Amp, MutKw, Pat }\n+        struct BoxPat { BoxKw, Pat }\n+        struct BindPat: AttrsOwner, NameOwner { RefKw, MutKw, Pat }\n+        struct PlaceholderPat { Underscore }\n+        struct DotDotPat { Dotdot }\n         struct PathPat { Path }\n-        struct SlicePat { args: [Pat] }\n-        struct RangePat {}\n+        struct SlicePat { LBrack, args: [Pat], RBrack }\n+        struct RangePat { RangeSeparator }\n         struct LiteralPat { Literal }\n         struct MacroPat { MacroCall }\n \n         struct RecordPat { RecordFieldPatList, Path }\n         struct RecordFieldPatList {\n+            LCurly,\n+            pats: [RecordInnerPat],\n             record_field_pats: [RecordFieldPat],\n             bind_pats: [BindPat],\n+            Dotdot,\n+            RCurly\n         }\n-        struct RecordFieldPat: NameOwner { Pat }\n+        struct RecordFieldPat: AttrsOwner, NameOwner { Colon, Pat }\n \n-        struct TupleStructPat { Path, args: [Pat] }\n-        struct TuplePat { args: [Pat] }\n+        struct TupleStructPat { Path, LParen, args: [Pat], RParen }\n+        struct TuplePat { LParen, args: [Pat], RParen }\n \n-        struct Visibility {}\n-        struct Name {}\n-        struct NameRef {}\n+        struct Visibility { PubKw, SuperKw, SelfKw, CrateKw }\n+        struct Name { Ident }\n+        struct NameRef { NameRefToken }\n \n         struct MacroCall: NameOwner, AttrsOwner,DocCommentsOwner {\n-            TokenTree, Path\n+            Path, Excl, TokenTree, Semi\n         }\n-        struct Attr { Path, input: AttrInput }\n+        struct Attr { Pound, Excl, LBrack, Path, Eq, input: AttrInput, RBrack }\n         struct TokenTree {}\n         struct TypeParamList {\n+            LAngle,\n+            generic_params: [GenericParam],\n             type_params: [TypeParam],\n             lifetime_params: [LifetimeParam],\n+            const_params: [ConstParam],\n+            RAngle\n         }\n         struct TypeParam: NameOwner, AttrsOwner, TypeBoundsOwner {\n+            Eq,\n             default_type: TypeRef,\n         }\n         struct ConstParam: NameOwner, AttrsOwner, TypeAscriptionOwner {\n+            Eq,\n             default_val: Expr,\n         }\n-        struct LifetimeParam: AttrsOwner { }\n-        struct TypeBound { TypeRef}\n+        struct LifetimeParam: AttrsOwner { Lifetime}\n+        struct TypeBound { Lifetime, /* Question,  */ ConstKw, /* Question,  */ TypeRef}\n         struct TypeBoundList { bounds: [TypeBound] }\n-        struct WherePred: TypeBoundsOwner { TypeRef }\n-        struct WhereClause { predicates: [WherePred] }\n-        struct ExprStmt { Expr }\n-        struct LetStmt: TypeAscriptionOwner {\n+        struct WherePred: TypeBoundsOwner { Lifetime, TypeRef }\n+        struct WhereClause { WhereKw, predicates: [WherePred] }\n+        struct Abi { String }\n+        struct ExprStmt: AttrsOwner { Expr, Semi }\n+        struct LetStmt: AttrsOwner, TypeAscriptionOwner {\n+            LetKw,\n             Pat,\n+            Eq,\n             initializer: Expr,\n         }\n-        struct Condition { Pat, Expr }\n+        struct Condition { LetKw, Pat, Eq, Expr }\n         struct Block: AttrsOwner, ModuleItemOwner {\n+            LCurly,\n             statements: [Stmt],\n             Expr,\n+            RCurly,\n         }\n         struct ParamList {\n+            LParen,\n             SelfParam,\n             params: [Param],\n+            RParen\n         }\n-        struct SelfParam: TypeAscriptionOwner, AttrsOwner { }\n+        struct SelfParam: TypeAscriptionOwner, AttrsOwner { Amp, Lifetime, SelfKw }\n         struct Param: TypeAscriptionOwner, AttrsOwner {\n             Pat,\n+            Dotdotdot\n         }\n         struct UseItem: AttrsOwner, VisibilityOwner {\n+            UseKw,\n             UseTree,\n         }\n         struct UseTree {\n-            Path, UseTreeList, Alias\n+            Path, Star, UseTreeList, Alias\n         }\n-        struct Alias: NameOwner { }\n-        struct UseTreeList { use_trees: [UseTree] }\n+        struct Alias: NameOwner { AsKw }\n+        struct UseTreeList { LCurly, use_trees: [UseTree], RCurly }\n         struct ExternCrateItem: AttrsOwner, VisibilityOwner {\n-            NameRef, Alias,\n+            ExternKw, CrateKw, NameRef, Alias,\n         }\n         struct ArgList {\n+            LParen,\n             args: [Expr],\n+            RParen\n         }\n         struct Path {\n             segment: PathSegment,\n             qualifier: Path,\n         }\n         struct PathSegment {\n-            NameRef, TypeArgList, ParamList, RetType, PathType,\n+            Coloncolon, LAngle, NameRef, TypeArgList, ParamList, RetType, PathType, RAngle\n         }\n         struct TypeArgList {\n+            Coloncolon,\n+            LAngle,\n+            generic_args: [GenericArg],\n             type_args: [TypeArg],\n             lifetime_args: [LifetimeArg],\n             assoc_type_args: [AssocTypeArg],\n-            const_arg: [ConstArg],\n+            const_args: [ConstArg],\n+            RAngle\n         }\n         struct TypeArg { TypeRef }\n-        struct AssocTypeArg { NameRef, TypeRef }\n-        struct LifetimeArg {}\n-        struct ConstArg { Literal, BlockExpr }\n+        struct AssocTypeArg : TypeBoundsOwner { NameRef, Eq, TypeRef }\n+        struct LifetimeArg { Lifetime }\n+        struct ConstArg { Literal, Eq, BlockExpr }\n \n         struct MacroItems: ModuleItemOwner, FnDefOwner { }\n \n         struct MacroStmts {\n             statements: [Stmt],\n             Expr,\n         }\n+\n+        struct ExternItemList: FnDefOwner, ModuleItemOwner {\n+            LCurly,\n+            extern_items: [ExternItem],\n+            RCurly\n+        }\n+\n+        struct ExternBlock {\n+            Abi,\n+            ExternItemList\n+        }\n+\n+        struct MetaItem {\n+            Path, Eq, AttrInput, nested_meta_items: [MetaItem]\n+        }\n+\n+        struct MacroDef {\n+            Name, TokenTree\n+        }\n     },\n     enums: &ast_enums! {\n         enum NominalDef: NameOwner, TypeParamsOwner, AttrsOwner {\n             StructDef, EnumDef, UnionDef,\n         }\n \n+        enum GenericParam {\n+            LifetimeParam,\n+            TypeParam,\n+            ConstParam\n+        }\n+\n+        enum GenericArg {\n+            LifetimeArg,\n+            TypeArg,\n+            ConstArg,\n+            AssocTypeArg\n+        }\n+\n         enum TypeRef {\n             ParenType,\n             TupleType,\n@@ -555,7 +663,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             DynTraitType,\n         }\n \n-        enum ModuleItem: AttrsOwner, VisibilityOwner {\n+        enum ModuleItem: NameOwner, AttrsOwner, VisibilityOwner {\n             StructDef,\n             UnionDef,\n             EnumDef,\n@@ -569,13 +677,20 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             StaticDef,\n             Module,\n             MacroCall,\n+            ExternBlock\n         }\n \n-        enum ImplItem: AttrsOwner {\n-            FnDef, TypeAliasDef, ConstDef,\n+        /* impl blocks can also contain MacroCall */\n+        enum ImplItem: NameOwner, AttrsOwner {\n+            FnDef, TypeAliasDef, ConstDef\n         }\n \n-        enum Expr {\n+        /* extern blocks can also contain MacroCall */\n+        enum ExternItem: NameOwner, AttrsOwner, VisibilityOwner {\n+            FnDef, StaticDef\n+        }\n+\n+        enum Expr: AttrsOwner {\n             TupleExpr,\n             ArrayExpr,\n             ParenExpr,\n@@ -627,7 +742,88 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             MacroPat,\n         }\n \n+        enum RecordInnerPat {\n+            RecordFieldPat,\n+            BindPat\n+        }\n+\n         enum AttrInput { Literal, TokenTree }\n-        enum Stmt { ExprStmt, LetStmt }\n+        enum Stmt {\n+            LetStmt,\n+            ExprStmt,\n+            // macro calls are parsed as expression statements */\n+        }\n+\n+        enum FieldDefList {\n+            RecordFieldDefList,\n+            TupleFieldDefList,\n+        }\n+    },\n+\n+    token_enums: &ast_enums! {\n+        enum LeftDelimiter { LParen, LBrack, LCurly }\n+        enum RightDelimiter { RParen, RBrack, RCurly }\n+        enum RangeSeparator { Dotdot, Dotdotdot, Dotdoteq}\n+\n+        enum BinOp {\n+            Pipepipe,\n+            Ampamp,\n+            Eqeq,\n+            Neq,\n+            Lteq,\n+            Gteq,\n+            LAngle,\n+            RAngle,\n+            Plus,\n+            Star,\n+            Minus,\n+            Slash,\n+            Percent,\n+            Shl,\n+            Shr,\n+            Caret,\n+            Pipe,\n+            Amp,\n+            Eq,\n+            Pluseq,\n+            Slasheq,\n+            Stareq,\n+            Percenteq,\n+            Shreq,\n+            Shleq,\n+            Minuseq,\n+            Pipeeq,\n+            Ampeq,\n+            Careteq,\n+        }\n+\n+        enum PrefixOp {\n+            Minus,\n+            Excl,\n+            Star\n+        }\n+\n+        enum RangeOp {\n+            Dotdot,\n+            Dotdoteq\n+        }\n+\n+        enum LiteralToken {\n+            IntNumber,\n+            FloatNumber,\n+            String,\n+            RawString,\n+            TrueKw,\n+            FalseKw,\n+            ByteString,\n+            RawByteString,\n+            Char,\n+            Byte\n+        }\n+\n+        enum NameRefToken {\n+            Ident,\n+            IntNumber\n+        }\n     },\n };"}, {"sha": "678b40133b0c9244f7deaf2b93b59b37e0e177bf", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -22,8 +22,9 @@ const GRAMMAR_DIR: &str = \"crates/ra_parser/src/grammar\";\n const OK_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/test_data/parser/inline/ok\";\n const ERR_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/test_data/parser/inline/err\";\n \n-pub const SYNTAX_KINDS: &str = \"crates/ra_parser/src/syntax_kind/generated.rs\";\n-pub const AST: &str = \"crates/ra_syntax/src/ast/generated.rs\";\n+const SYNTAX_KINDS: &str = \"crates/ra_parser/src/syntax_kind/generated.rs\";\n+const AST_NODES: &str = \"crates/ra_syntax/src/ast/generated/nodes.rs\";\n+const AST_TOKENS: &str = \"crates/ra_syntax/src/ast/generated/tokens.rs\";\n \n const ASSISTS_DIR: &str = \"crates/ra_assists/src/handlers\";\n const ASSISTS_TESTS: &str = \"crates/ra_assists/src/doc_tests/generated.rs\";"}, {"sha": "6657c9fc5f08cd4aa136838002932bc447c01043", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 142, "deletions": 76, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -3,10 +3,13 @@\n //! Specifically, it generates the `SyntaxKind` enum and a number of newtype\n //! wrappers around `SyntaxNode` which implement `ra_syntax::AstNode`.\n \n+use std::{\n+    borrow::Cow,\n+    collections::{BTreeSet, HashSet},\n+};\n+\n use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n-use std::borrow::Cow;\n-use std::collections::{BTreeSet, HashMap, HashSet};\n \n use crate::{\n     ast_src::{AstSrc, FieldSrc, KindsSrc, AST_SRC, KINDS_SRC},\n@@ -19,9 +22,13 @@ pub fn generate_syntax(mode: Mode) -> Result<()> {\n     let syntax_kinds = generate_syntax_kinds(KINDS_SRC)?;\n     update(syntax_kinds_file.as_path(), &syntax_kinds, mode)?;\n \n-    let ast_file = project_root().join(codegen::AST);\n-    let ast = generate_ast(KINDS_SRC, AST_SRC)?;\n-    update(ast_file.as_path(), &ast, mode)?;\n+    let ast_nodes_file = project_root().join(codegen::AST_NODES);\n+    let contents = generate_nodes(KINDS_SRC, AST_SRC)?;\n+    update(ast_nodes_file.as_path(), &contents, mode)?;\n+\n+    let ast_tokens_file = project_root().join(codegen::AST_TOKENS);\n+    let contents = generate_tokens(KINDS_SRC, AST_SRC)?;\n+    update(ast_tokens_file.as_path(), &contents, mode)?;\n \n     Ok(())\n }\n@@ -33,7 +40,7 @@ struct ElementKinds {\n     has_tokens: bool,\n }\n \n-fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n+fn generate_tokens(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n     let all_token_kinds: Vec<_> = kinds\n         .punct\n         .into_iter()\n@@ -51,46 +58,6 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         .chain(kinds.tokens.into_iter().copied().map(|x| x.into()))\n         .collect();\n \n-    let mut element_kinds_map = HashMap::new();\n-    for kind in &all_token_kinds {\n-        let kind = &**kind;\n-        let name = to_pascal_case(kind);\n-        element_kinds_map.insert(\n-            name,\n-            ElementKinds {\n-                kinds: Some(format_ident!(\"{}\", kind)).into_iter().collect(),\n-                has_nodes: false,\n-                has_tokens: true,\n-            },\n-        );\n-    }\n-\n-    for kind in kinds.nodes {\n-        let name = to_pascal_case(kind);\n-        element_kinds_map.insert(\n-            name,\n-            ElementKinds {\n-                kinds: Some(format_ident!(\"{}\", *kind)).into_iter().collect(),\n-                has_nodes: true,\n-                has_tokens: false,\n-            },\n-        );\n-    }\n-\n-    for en in grammar.enums {\n-        let mut element_kinds: ElementKinds = Default::default();\n-        for variant in en.variants {\n-            if let Some(variant_element_kinds) = element_kinds_map.get(*variant) {\n-                element_kinds.kinds.extend(variant_element_kinds.kinds.iter().cloned());\n-                element_kinds.has_tokens |= variant_element_kinds.has_tokens;\n-                element_kinds.has_nodes |= variant_element_kinds.has_nodes;\n-            } else {\n-                panic!(\"Enum variant has type that does not exist or was not declared before the enum: {}\", *variant);\n-            }\n-        }\n-        element_kinds_map.insert(en.name.to_string(), element_kinds);\n-    }\n-\n     let tokens = all_token_kinds.iter().map(|kind_str| {\n         let kind_str = &**kind_str;\n         let kind = format_ident!(\"{}\", kind_str);\n@@ -108,12 +75,7 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n             }\n \n             impl AstToken for #name {\n-                fn can_cast(kind: SyntaxKind) -> bool {\n-                    match kind {\n-                        #kind => true,\n-                        _ => false,\n-                    }\n-                }\n+                fn can_cast(kind: SyntaxKind) -> bool { kind == #kind }\n                 fn cast(syntax: SyntaxToken) -> Option<Self> {\n                     if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n                 }\n@@ -122,6 +84,99 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         }\n     });\n \n+    let enums = grammar.token_enums.iter().map(|en| {\n+        let variants = en.variants.iter().map(|var| format_ident!(\"{}\", var)).collect::<Vec<_>>();\n+        let name = format_ident!(\"{}\", en.name);\n+        let kinds = variants\n+            .iter()\n+            .map(|name| format_ident!(\"{}\", to_upper_snake_case(&name.to_string())))\n+            .collect::<Vec<_>>();\n+        assert!(en.traits.is_empty());\n+\n+        quote! {\n+                #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+                pub enum #name {\n+                    #(#variants(#variants),)*\n+                }\n+\n+                #(\n+                impl From<#variants> for #name {\n+                    fn from(node: #variants) -> #name {\n+                        #name::#variants(node)\n+                    }\n+                }\n+                )*\n+\n+                impl std::fmt::Display for #name {\n+                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+                        std::fmt::Display::fmt(self.syntax(), f)\n+                    }\n+                }\n+\n+                impl AstToken for #name {\n+                    fn can_cast(kind: SyntaxKind) -> bool {\n+                        match kind {\n+                            #(#kinds)|* => true,\n+                            _ => false,\n+                        }\n+                    }\n+                    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+                        let res = match syntax.kind() {\n+                            #(\n+                            #kinds => #name::#variants(#variants { syntax }),\n+                            )*\n+                            _ => return None,\n+                        };\n+                        Some(res)\n+                    }\n+                    fn syntax(&self) -> &SyntaxToken {\n+                        match self {\n+                            #(\n+                            #name::#variants(it) => &it.syntax,\n+                            )*\n+                        }\n+                    }\n+                }\n+        }\n+    });\n+\n+    crate::reformat(quote! {\n+        use crate::{SyntaxToken, SyntaxKind::{self, *}, ast::AstToken};\n+\n+        #(#tokens)*\n+        #(#enums)*\n+    })\n+}\n+\n+fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n+    let all_token_kinds: Vec<_> = kinds\n+        .punct\n+        .into_iter()\n+        .map(|(_, kind)| kind)\n+        .copied()\n+        .map(|x| x.into())\n+        .chain(\n+            kinds\n+                .keywords\n+                .into_iter()\n+                .chain(kinds.contextual_keywords.into_iter())\n+                .map(|name| Cow::Owned(format!(\"{}_KW\", to_upper_snake_case(&name)))),\n+        )\n+        .chain(kinds.literals.into_iter().copied().map(|x| x.into()))\n+        .chain(kinds.tokens.into_iter().copied().map(|x| x.into()))\n+        .collect();\n+\n+    let mut token_kinds = HashSet::new();\n+    for kind in &all_token_kinds {\n+        let kind = &**kind;\n+        let name = to_pascal_case(kind);\n+        token_kinds.insert(name);\n+    }\n+\n+    for en in grammar.token_enums {\n+        token_kinds.insert(en.name.to_string());\n+    }\n+\n     let nodes = grammar.nodes.iter().map(|node| {\n         let name = format_ident!(\"{}\", node.name);\n         let kind = format_ident!(\"{}\", to_upper_snake_case(&name.to_string()));\n@@ -146,14 +201,23 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                 FieldSrc::Many(_) => {\n                     quote! {\n                         pub fn #method_name(&self) -> AstChildren<#ty> {\n-                            AstChildren::new(&self.syntax)\n+                            support::children(&self.syntax)\n                         }\n                     }\n                 }\n                 FieldSrc::Optional(_) | FieldSrc::Shorthand => {\n-                    quote! {\n-                        pub fn #method_name(&self) -> Option<#ty> {\n-                            AstChildren::new(&self.syntax).next()\n+                    let is_token = token_kinds.contains(&ty.to_string());\n+                    if is_token {\n+                        quote! {\n+                            pub fn #method_name(&self) -> Option<#ty> {\n+                                support::token(&self.syntax)\n+                            }\n+                        }\n+                    } else {\n+                        quote! {\n+                            pub fn #method_name(&self) -> Option<#ty> {\n+                                support::child(&self.syntax)\n+                            }\n                         }\n                     }\n                 }\n@@ -166,18 +230,9 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                 pub(crate) syntax: SyntaxNode,\n             }\n \n-            impl std::fmt::Display for #name {\n-                fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-                    std::fmt::Display::fmt(self.syntax(), f)\n-                }\n-            }\n-\n             impl AstNode for #name {\n                 fn can_cast(kind: SyntaxKind) -> bool {\n-                    match kind {\n-                        #kind => true,\n-                        _ => false,\n-                    }\n+                    kind == #kind\n                 }\n                 fn cast(syntax: SyntaxNode) -> Option<Self> {\n                     if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n@@ -219,12 +274,6 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n             }\n             )*\n \n-            impl std::fmt::Display for #name {\n-                fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-                    std::fmt::Display::fmt(self.syntax(), f)\n-                }\n-            }\n-\n             impl AstNode for #name {\n                 fn can_cast(kind: SyntaxKind) -> bool {\n                     match kind {\n@@ -249,10 +298,26 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                     }\n                 }\n             }\n+\n             #(#traits)*\n         }\n     });\n \n+    let displays = grammar\n+        .enums\n+        .iter()\n+        .map(|it| format_ident!(\"{}\", it.name))\n+        .chain(grammar.nodes.iter().map(|it| format_ident!(\"{}\", it.name)))\n+        .map(|name| {\n+            quote! {\n+                impl std::fmt::Display for #name {\n+                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+                        std::fmt::Display::fmt(self.syntax(), f)\n+                    }\n+                }\n+            }\n+        });\n+\n     let defined_nodes: HashSet<_> = grammar.nodes.iter().map(|node| node.name).collect();\n \n     for node in kinds\n@@ -265,15 +330,16 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n     }\n \n     let ast = quote! {\n-        #[allow(unused_imports)]\n         use crate::{\n-            SyntaxNode, SyntaxToken, SyntaxElement, NodeOrToken, SyntaxKind::{self, *},\n-            ast::{self, AstNode, AstToken, AstChildren},\n+            SyntaxNode, SyntaxKind::{self, *},\n+            ast::{self, AstNode, AstChildren, support},\n         };\n \n-        #(#tokens)*\n+        use super::tokens::*;\n+\n         #(#nodes)*\n         #(#enums)*\n+        #(#displays)*\n     };\n \n     let pretty = crate::reformat(ast)?;"}, {"sha": "ec824a5183d498bd5f14ade7609862499732dea6", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1317d692321ba5ba8f138067ebefbb9559d098d/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1317d692321ba5ba8f138067ebefbb9559d098d/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=c1317d692321ba5ba8f138067ebefbb9559d098d", "patch": "@@ -67,6 +67,7 @@ fn reformat(text: impl std::fmt::Display) -> Result<String> {\n     let mut rustfmt = Command::new(\"rustup\")\n         .args(&[\"run\", TOOLCHAIN, \"--\", \"rustfmt\", \"--config-path\"])\n         .arg(project_root().join(\"rustfmt.toml\"))\n+        .args(&[\"--config\", \"fn_single_line=true\"])\n         .stdin(Stdio::piped())\n         .stdout(Stdio::piped())\n         .spawn()?;"}]}