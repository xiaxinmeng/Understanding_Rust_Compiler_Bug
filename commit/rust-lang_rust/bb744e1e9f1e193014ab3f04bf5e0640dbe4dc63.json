{"sha": "bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNzQ0ZTFlOWYxZTE5MzAxNGFiM2YwNGJmNWUwNjQwZGJlNGRjNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-04T02:04:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-04T02:04:04Z"}, "message": "Auto merge of #87568 - petrochenkov:localevel, r=cjgillot\n\nrustc: Replace `HirId`s with `LocalDefId`s in `AccessLevels` tables\n\nand passes using those tables - primarily privacy checking, stability checking and dead code checking.\n\nAll these passes work with definitions rather than with arbitrary HIR nodes.\nr? `@cjgillot`\ncc `@lambinoo` (#87487)", "tree": {"sha": "461416ac8a4134822855c0abf9f80e1a81c9d3b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/461416ac8a4134822855c0abf9f80e1a81c9d3b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "html_url": "https://github.com/rust-lang/rust/commit/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b8de6f21286d6dbd7dd692af7da7dc6937861d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b8de6f21286d6dbd7dd692af7da7dc6937861d3", "html_url": "https://github.com/rust-lang/rust/commit/2b8de6f21286d6dbd7dd692af7da7dc6937861d3"}, {"sha": "f921410b1c4e38e234758db6dbbfc8b9c419c5fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f921410b1c4e38e234758db6dbbfc8b9c419c5fb", "html_url": "https://github.com/rust-lang/rust/commit/f921410b1c4e38e234758db6dbbfc8b9c419c5fb"}], "stats": {"total": 632, "additions": 299, "deletions": 333}, "files": [{"sha": "c590cd00bd54568f3222adc6c846ebd0f35804b6", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -38,7 +38,7 @@ use rustc_feature::{deprecated_attributes, AttributeGate, AttributeTemplate, Att\n use rustc_feature::{GateIssue, Stability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet};\n+use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n use rustc_hir::{ForeignItemKind, GenericParamKind, PatKind};\n use rustc_hir::{HirId, Node};\n use rustc_index::vec::Idx;\n@@ -511,7 +511,7 @@ impl MissingDoc {\n     fn check_missing_docs_attrs(\n         &self,\n         cx: &LateContext<'_>,\n-        id: hir::HirId,\n+        def_id: LocalDefId,\n         sp: Span,\n         article: &'static str,\n         desc: &'static str,\n@@ -530,13 +530,13 @@ impl MissingDoc {\n         // Only check publicly-visible items, using the result from the privacy pass.\n         // It's an option so the crate root can also use this function (it doesn't\n         // have a `NodeId`).\n-        if id != hir::CRATE_HIR_ID {\n-            if !cx.access_levels.is_exported(id) {\n+        if def_id != CRATE_DEF_ID {\n+            if !cx.access_levels.is_exported(def_id) {\n                 return;\n             }\n         }\n \n-        let attrs = cx.tcx.hir().attrs(id);\n+        let attrs = cx.tcx.get_attrs(def_id.to_def_id());\n         let has_doc = attrs.iter().any(|a| has_doc(cx.sess(), a));\n         if !has_doc {\n             cx.struct_span_lint(\n@@ -568,12 +568,12 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &LateContext<'_>, krate: &hir::Crate<'_>) {\n-        self.check_missing_docs_attrs(cx, hir::CRATE_HIR_ID, krate.module().inner, \"the\", \"crate\");\n+        self.check_missing_docs_attrs(cx, CRATE_DEF_ID, krate.module().inner, \"the\", \"crate\");\n \n         for macro_def in krate.exported_macros() {\n             // Non exported macros should be skipped, since `missing_docs` only\n             // applies to externally visible items.\n-            if !cx.access_levels.is_exported(macro_def.hir_id()) {\n+            if !cx.access_levels.is_exported(macro_def.def_id) {\n                 continue;\n             }\n \n@@ -632,7 +632,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n         let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, it.hir_id(), it.span, article, desc);\n+        self.check_missing_docs_attrs(cx, it.def_id, it.span, article, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_>, trait_item: &hir::TraitItem<'_>) {\n@@ -642,7 +642,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n         let (article, desc) = cx.tcx.article_and_description(trait_item.def_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, trait_item.hir_id(), trait_item.span, article, desc);\n+        self.check_missing_docs_attrs(cx, trait_item.def_id, trait_item.span, article, desc);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n@@ -652,22 +652,23 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n         }\n \n         let (article, desc) = cx.tcx.article_and_description(impl_item.def_id.to_def_id());\n-        self.check_missing_docs_attrs(cx, impl_item.hir_id(), impl_item.span, article, desc);\n+        self.check_missing_docs_attrs(cx, impl_item.def_id, impl_item.span, article, desc);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'_>) {\n         let (article, desc) = cx.tcx.article_and_description(foreign_item.def_id.to_def_id());\n-        self.check_missing_docs_attrs(cx, foreign_item.hir_id(), foreign_item.span, article, desc);\n+        self.check_missing_docs_attrs(cx, foreign_item.def_id, foreign_item.span, article, desc);\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, sf: &hir::FieldDef<'_>) {\n         if !sf.is_positional() {\n-            self.check_missing_docs_attrs(cx, sf.hir_id, sf.span, \"a\", \"struct field\")\n+            let def_id = cx.tcx.hir().local_def_id(sf.hir_id);\n+            self.check_missing_docs_attrs(cx, def_id, sf.span, \"a\", \"struct field\")\n         }\n     }\n \n     fn check_variant(&mut self, cx: &LateContext<'_>, v: &hir::Variant<'_>) {\n-        self.check_missing_docs_attrs(cx, v.id, v.span, \"a\", \"variant\");\n+        self.check_missing_docs_attrs(cx, cx.tcx.hir().local_def_id(v.id), v.span, \"a\", \"variant\");\n     }\n }\n \n@@ -709,7 +710,7 @@ declare_lint_pass!(MissingCopyImplementations => [MISSING_COPY_IMPLEMENTATIONS])\n \n impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.access_levels.is_reachable(item.hir_id()) {\n+        if !cx.access_levels.is_reachable(item.def_id) {\n             return;\n         }\n         let (def, ty) = match item.kind {\n@@ -796,7 +797,7 @@ impl_lint_pass!(MissingDebugImplementations => [MISSING_DEBUG_IMPLEMENTATIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.access_levels.is_reachable(item.hir_id()) {\n+        if !cx.access_levels.is_reachable(item.def_id) {\n             return;\n         }\n \n@@ -1314,14 +1315,14 @@ impl UnreachablePub {\n         &self,\n         cx: &LateContext<'_>,\n         what: &str,\n-        id: hir::HirId,\n+        def_id: LocalDefId,\n         vis: &hir::Visibility<'_>,\n         span: Span,\n         exportable: bool,\n     ) {\n         let mut applicability = Applicability::MachineApplicable;\n         match vis.node {\n-            hir::VisibilityKind::Public if !cx.access_levels.is_reachable(id) => {\n+            hir::VisibilityKind::Public if !cx.access_levels.is_reachable(def_id) => {\n                 if span.from_expansion() {\n                     applicability = Applicability::MaybeIncorrect;\n                 }\n@@ -1354,26 +1355,27 @@ impl UnreachablePub {\n \n impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        self.perform_lint(cx, \"item\", item.hir_id(), &item.vis, item.span, true);\n+        self.perform_lint(cx, \"item\", item.def_id, &item.vis, item.span, true);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'tcx>) {\n         self.perform_lint(\n             cx,\n             \"item\",\n-            foreign_item.hir_id(),\n+            foreign_item.def_id,\n             &foreign_item.vis,\n             foreign_item.span,\n             true,\n         );\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n-        self.perform_lint(cx, \"field\", field.hir_id, &field.vis, field.span, false);\n+        let def_id = cx.tcx.hir().local_def_id(field.hir_id);\n+        self.perform_lint(cx, \"field\", def_id, &field.vis, field.span, false);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n-        self.perform_lint(cx, \"item\", impl_item.hir_id(), &impl_item.vis, impl_item.span, false);\n+        self.perform_lint(cx, \"item\", impl_item.def_id, &impl_item.vis, impl_item.span, false);\n     }\n }\n "}, {"sha": "c313146b072225913328a692daab2ac6d706bd55", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -581,14 +581,6 @@ impl<'hir> Map<'hir> {\n         self.body_const_context(self.local_def_id(self.enclosing_body_owner(hir_id))).is_some()\n     }\n \n-    /// Whether `hir_id` corresponds to a `mod` or a crate.\n-    pub fn is_hir_id_module(&self, hir_id: HirId) -> bool {\n-        matches!(\n-            self.get(hir_id),\n-            Node::Item(Item { kind: ItemKind::Mod(_), .. }) | Node::Crate(..)\n-        )\n-    }\n-\n     /// Retrieves the `HirId` for `id`'s enclosing method, unless there's a\n     /// `while` or `loop` before reaching it, as block tail returns are not\n     /// available in them."}, {"sha": "a11ca74b25ee3473c214328b4f5f3f9e7282489e", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -3,9 +3,8 @@\n //! which are available for use externally when compiled as a library.\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::HirId;\n use rustc_macros::HashStable;\n-use std::fmt;\n+use rustc_span::def_id::LocalDefId;\n use std::hash::Hash;\n \n /// Represents the levels of accessibility an item can have.\n@@ -27,8 +26,8 @@ pub enum AccessLevel {\n }\n \n /// Holds a map of accessibility levels for reachable HIR nodes.\n-#[derive(Clone)]\n-pub struct AccessLevels<Id = HirId> {\n+#[derive(Debug)]\n+pub struct AccessLevels<Id = LocalDefId> {\n     pub map: FxHashMap<Id, AccessLevel>,\n }\n \n@@ -49,14 +48,8 @@ impl<Id: Hash + Eq> AccessLevels<Id> {\n     }\n }\n \n-impl<Id: Hash + Eq> Default for AccessLevels<Id> {\n+impl<Id> Default for AccessLevels<Id> {\n     fn default() -> Self {\n         AccessLevels { map: Default::default() }\n     }\n }\n-\n-impl<Id: Hash + Eq + fmt::Debug> fmt::Debug for AccessLevels<Id> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Debug::fmt(&self.map, f)\n-    }\n-}"}, {"sha": "f0b4b6b5a0ca640080c3d48850a8292f50867914", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -11,7 +11,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_feature::GateIssue;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::{self, HirId};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_session::lint::builtin::{DEPRECATED, DEPRECATED_IN_FUTURE, SOFT_UNSTABLE};\n@@ -36,12 +36,12 @@ pub struct DeprecationEntry {\n     pub attr: Deprecation,\n     /// The `DefId` where the attr was originally attached. `None` for non-local\n     /// `DefId`'s.\n-    origin: Option<HirId>,\n+    origin: Option<LocalDefId>,\n }\n \n impl DeprecationEntry {\n-    pub fn local(attr: Deprecation, id: HirId) -> DeprecationEntry {\n-        DeprecationEntry { attr, origin: Some(id) }\n+    pub fn local(attr: Deprecation, def_id: LocalDefId) -> DeprecationEntry {\n+        DeprecationEntry { attr, origin: Some(def_id) }\n     }\n \n     pub fn external(attr: Deprecation) -> DeprecationEntry {\n@@ -61,9 +61,9 @@ impl DeprecationEntry {\n pub struct Index<'tcx> {\n     /// This is mostly a cache, except the stabilities of local items\n     /// are filled by the annotator.\n-    pub stab_map: FxHashMap<HirId, &'tcx Stability>,\n-    pub const_stab_map: FxHashMap<HirId, &'tcx ConstStability>,\n-    pub depr_map: FxHashMap<HirId, DeprecationEntry>,\n+    pub stab_map: FxHashMap<LocalDefId, &'tcx Stability>,\n+    pub const_stab_map: FxHashMap<LocalDefId, &'tcx ConstStability>,\n+    pub depr_map: FxHashMap<LocalDefId, DeprecationEntry>,\n \n     /// Maps for each crate whether it is part of the staged API.\n     pub staged_api: FxHashMap<CrateNum, bool>,\n@@ -73,16 +73,16 @@ pub struct Index<'tcx> {\n }\n \n impl<'tcx> Index<'tcx> {\n-    pub fn local_stability(&self, id: HirId) -> Option<&'tcx Stability> {\n-        self.stab_map.get(&id).cloned()\n+    pub fn local_stability(&self, def_id: LocalDefId) -> Option<&'tcx Stability> {\n+        self.stab_map.get(&def_id).copied()\n     }\n \n-    pub fn local_const_stability(&self, id: HirId) -> Option<&'tcx ConstStability> {\n-        self.const_stab_map.get(&id).cloned()\n+    pub fn local_const_stability(&self, def_id: LocalDefId) -> Option<&'tcx ConstStability> {\n+        self.const_stab_map.get(&def_id).copied()\n     }\n \n-    pub fn local_deprecation_entry(&self, id: HirId) -> Option<DeprecationEntry> {\n-        self.depr_map.get(&id).cloned()\n+    pub fn local_deprecation_entry(&self, def_id: LocalDefId) -> Option<DeprecationEntry> {\n+        self.depr_map.get(&def_id).cloned()\n     }\n }\n "}, {"sha": "3bdd91d2136093af3fa003d7323a96d7e1c996c0", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -2854,18 +2854,11 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         tcx.arena.alloc(tcx.resolutions(()).glob_map.get(&id).cloned().unwrap_or_default())\n     };\n \n-    providers.lookup_stability = |tcx, id| {\n-        let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n-        tcx.stability().local_stability(id)\n-    };\n-    providers.lookup_const_stability = |tcx, id| {\n-        let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n-        tcx.stability().local_const_stability(id)\n-    };\n-    providers.lookup_deprecation_entry = |tcx, id| {\n-        let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n-        tcx.stability().local_deprecation_entry(id)\n-    };\n+    providers.lookup_stability = |tcx, id| tcx.stability().local_stability(id.expect_local());\n+    providers.lookup_const_stability =\n+        |tcx, id| tcx.stability().local_const_stability(id.expect_local());\n+    providers.lookup_deprecation_entry =\n+        |tcx, id| tcx.stability().local_deprecation_entry(id.expect_local());\n     providers.extern_mod_stmt_cnum =\n         |tcx, id| tcx.resolutions(()).extern_crate_map.get(&id).cloned();\n     providers.output_filenames = |tcx, ()| tcx.output_filenames.clone();"}, {"sha": "4e157b0a574fb52b83d9b0d1de0cb464fb40a4e7", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 49, "deletions": 52, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -5,7 +5,7 @@\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::{Node, PatKind, TyKind};\n@@ -14,40 +14,38 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::middle::privacy;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::lint;\n-\n use rustc_span::symbol::{sym, Symbol};\n \n // Any local node that may call something in its body block should be\n // explored. For example, if it's a live Node::Item that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n-fn should_explore(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n+fn should_explore(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     matches!(\n-        tcx.hir().find(hir_id),\n+        tcx.hir().find(tcx.hir().local_def_id_to_hir_id(def_id)),\n         Some(\n             Node::Item(..)\n                 | Node::ImplItem(..)\n                 | Node::ForeignItem(..)\n                 | Node::TraitItem(..)\n                 | Node::Variant(..)\n                 | Node::AnonConst(..)\n-                | Node::Pat(..),\n         )\n     )\n }\n \n struct MarkSymbolVisitor<'tcx> {\n-    worklist: Vec<hir::HirId>,\n+    worklist: Vec<LocalDefId>,\n     tcx: TyCtxt<'tcx>,\n     maybe_typeck_results: Option<&'tcx ty::TypeckResults<'tcx>>,\n-    live_symbols: FxHashSet<hir::HirId>,\n+    live_symbols: FxHashSet<LocalDefId>,\n     repr_has_repr_c: bool,\n     in_pat: bool,\n     inherited_pub_visibility: bool,\n     pub_visibility: bool,\n     ignore_variant_stack: Vec<DefId>,\n     // maps from tuple struct constructors to tuple struct items\n-    struct_constructors: FxHashMap<hir::HirId, hir::HirId>,\n+    struct_constructors: FxHashMap<LocalDefId, LocalDefId>,\n }\n \n impl<'tcx> MarkSymbolVisitor<'tcx> {\n@@ -62,19 +60,17 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n \n     fn check_def_id(&mut self, def_id: DefId) {\n         if let Some(def_id) = def_id.as_local() {\n-            let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-            if should_explore(self.tcx, hir_id) || self.struct_constructors.contains_key(&hir_id) {\n-                self.worklist.push(hir_id);\n+            if should_explore(self.tcx, def_id) || self.struct_constructors.contains_key(&def_id) {\n+                self.worklist.push(def_id);\n             }\n-            self.live_symbols.insert(hir_id);\n+            self.live_symbols.insert(def_id);\n         }\n     }\n \n     fn insert_def_id(&mut self, def_id: DefId) {\n         if let Some(def_id) = def_id.as_local() {\n-            let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-            debug_assert!(!should_explore(self.tcx, hir_id));\n-            self.live_symbols.insert(hir_id);\n+            debug_assert!(!should_explore(self.tcx, def_id));\n+            self.live_symbols.insert(def_id);\n         }\n     }\n \n@@ -233,9 +229,9 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n \n             // in the case of tuple struct constructors we want to check the item, not the generated\n             // tuple struct constructor function\n-            let id = self.struct_constructors.get(&id).cloned().unwrap_or(id);\n+            let id = self.struct_constructors.get(&id).copied().unwrap_or(id);\n \n-            if let Some(node) = self.tcx.hir().find(id) {\n+            if let Some(node) = self.tcx.hir().find(self.tcx.hir().local_def_id_to_hir_id(id)) {\n                 self.live_symbols.insert(id);\n                 self.visit_node(node);\n             }\n@@ -326,7 +322,8 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n         let live_fields = def.fields().iter().filter(|f| {\n             has_repr_c || (pub_visibility && (inherited_pub_visibility || f.vis.node.is_pub()))\n         });\n-        self.live_symbols.extend(live_fields.map(|f| f.hir_id));\n+        let hir = self.tcx.hir();\n+        self.live_symbols.extend(live_fields.map(|f| hir.local_def_id(f.hir_id)));\n \n         intravisit::walk_struct_def(self, def);\n     }\n@@ -398,7 +395,7 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n     }\n \n     fn visit_anon_const(&mut self, c: &'tcx hir::AnonConst) {\n-        self.live_symbols.insert(c.hir_id);\n+        self.live_symbols.insert(self.tcx.hir().local_def_id(c.hir_id));\n         intravisit::walk_anon_const(self, c);\n     }\n }\n@@ -445,47 +442,52 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n //   2) We are not sure to be live or not\n //     * Implementations of traits and trait methods\n struct LifeSeeder<'k, 'tcx> {\n-    worklist: Vec<hir::HirId>,\n+    worklist: Vec<LocalDefId>,\n     krate: &'k hir::Crate<'k>,\n     tcx: TyCtxt<'tcx>,\n     // see `MarkSymbolVisitor::struct_constructors`\n-    struct_constructors: FxHashMap<hir::HirId, hir::HirId>,\n+    struct_constructors: FxHashMap<LocalDefId, LocalDefId>,\n }\n \n impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         let allow_dead_code = has_allow_dead_code_or_lang_attr(self.tcx, item.hir_id());\n         if allow_dead_code {\n-            self.worklist.push(item.hir_id());\n+            self.worklist.push(item.def_id);\n         }\n         match item.kind {\n             hir::ItemKind::Enum(ref enum_def, _) => {\n+                let hir = self.tcx.hir();\n                 if allow_dead_code {\n-                    self.worklist.extend(enum_def.variants.iter().map(|variant| variant.id));\n+                    self.worklist.extend(\n+                        enum_def.variants.iter().map(|variant| hir.local_def_id(variant.id)),\n+                    );\n                 }\n \n                 for variant in enum_def.variants {\n                     if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n-                        self.struct_constructors.insert(ctor_hir_id, variant.id);\n+                        self.struct_constructors\n+                            .insert(hir.local_def_id(ctor_hir_id), hir.local_def_id(variant.id));\n                     }\n                 }\n             }\n             hir::ItemKind::Impl(hir::Impl { ref of_trait, items, .. }) => {\n                 if of_trait.is_some() {\n-                    self.worklist.push(item.hir_id());\n+                    self.worklist.push(item.def_id);\n                 }\n                 for impl_item_ref in items {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if of_trait.is_some()\n                         || has_allow_dead_code_or_lang_attr(self.tcx, impl_item.hir_id())\n                     {\n-                        self.worklist.push(impl_item_ref.id.hir_id());\n+                        self.worklist.push(impl_item_ref.id.def_id);\n                     }\n                 }\n             }\n             hir::ItemKind::Struct(ref variant_data, _) => {\n                 if let Some(ctor_hir_id) = variant_data.ctor_hir_id() {\n-                    self.struct_constructors.insert(ctor_hir_id, item.hir_id());\n+                    self.struct_constructors\n+                        .insert(self.tcx.hir().local_def_id(ctor_hir_id), item.def_id);\n                 }\n             }\n             _ => (),\n@@ -497,7 +499,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n         if matches!(trait_item.kind, Const(_, Some(_)) | Fn(_, hir::TraitFn::Provided(_)))\n             && has_allow_dead_code_or_lang_attr(self.tcx, trait_item.hir_id())\n         {\n-            self.worklist.push(trait_item.hir_id());\n+            self.worklist.push(trait_item.def_id);\n         }\n     }\n \n@@ -510,7 +512,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n         if matches!(foreign_item.kind, Static(..) | Fn(..))\n             && has_allow_dead_code_or_lang_attr(self.tcx, foreign_item.hir_id())\n         {\n-            self.worklist.push(foreign_item.hir_id());\n+            self.worklist.push(foreign_item.def_id);\n         }\n     }\n }\n@@ -519,7 +521,7 @@ fn create_and_seed_worklist<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     access_levels: &privacy::AccessLevels,\n     krate: &hir::Crate<'_>,\n-) -> (Vec<hir::HirId>, FxHashMap<hir::HirId, hir::HirId>) {\n+) -> (Vec<LocalDefId>, FxHashMap<LocalDefId, LocalDefId>) {\n     let worklist = access_levels\n         .map\n         .iter()\n@@ -528,12 +530,8 @@ fn create_and_seed_worklist<'tcx>(\n                 if level >= privacy::AccessLevel::Reachable { Some(id) } else { None }\n             },\n         )\n-        .chain(\n-            // Seed entry point\n-            tcx.entry_fn(()).and_then(|(def_id, _)| {\n-                def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n-            }),\n-        )\n+        // Seed entry point\n+        .chain(tcx.entry_fn(()).and_then(|(def_id, _)| def_id.as_local()))\n         .collect::<Vec<_>>();\n \n     // Seed implemented trait items\n@@ -548,7 +546,7 @@ fn find_live<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     access_levels: &privacy::AccessLevels,\n     krate: &hir::Crate<'_>,\n-) -> FxHashSet<hir::HirId> {\n+) -> FxHashSet<LocalDefId> {\n     let (worklist, struct_constructors) = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n@@ -568,7 +566,7 @@ fn find_live<'tcx>(\n \n struct DeadVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    live_symbols: FxHashSet<hir::HirId>,\n+    live_symbols: FxHashSet<LocalDefId>,\n }\n \n impl DeadVisitor<'tcx> {\n@@ -583,42 +581,41 @@ impl DeadVisitor<'tcx> {\n                 | hir::ItemKind::Struct(..)\n                 | hir::ItemKind::Union(..)\n         );\n-        should_warn && !self.symbol_is_live(item.hir_id())\n+        should_warn && !self.symbol_is_live(item.def_id)\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::FieldDef<'_>) -> bool {\n-        let field_type = self.tcx.type_of(self.tcx.hir().local_def_id(field.hir_id));\n+        let def_id = self.tcx.hir().local_def_id(field.hir_id);\n+        let field_type = self.tcx.type_of(def_id);\n         !field.is_positional()\n-            && !self.symbol_is_live(field.hir_id)\n+            && !self.symbol_is_live(def_id)\n             && !field_type.is_phantom_data()\n             && !has_allow_dead_code_or_lang_attr(self.tcx, field.hir_id)\n     }\n \n     fn should_warn_about_variant(&mut self, variant: &hir::Variant<'_>) -> bool {\n-        !self.symbol_is_live(variant.id) && !has_allow_dead_code_or_lang_attr(self.tcx, variant.id)\n+        let def_id = self.tcx.hir().local_def_id(variant.id);\n+        !self.symbol_is_live(def_id) && !has_allow_dead_code_or_lang_attr(self.tcx, variant.id)\n     }\n \n     fn should_warn_about_foreign_item(&mut self, fi: &hir::ForeignItem<'_>) -> bool {\n-        !self.symbol_is_live(fi.hir_id())\n-            && !has_allow_dead_code_or_lang_attr(self.tcx, fi.hir_id())\n+        !self.symbol_is_live(fi.def_id) && !has_allow_dead_code_or_lang_attr(self.tcx, fi.hir_id())\n     }\n \n     // id := HIR id of an item's definition.\n-    fn symbol_is_live(&mut self, id: hir::HirId) -> bool {\n-        if self.live_symbols.contains(&id) {\n+    fn symbol_is_live(&mut self, def_id: LocalDefId) -> bool {\n+        if self.live_symbols.contains(&def_id) {\n             return true;\n         }\n         // If it's a type whose items are live, then it's live, too.\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let def_id = self.tcx.hir().local_def_id(id);\n         let inherent_impls = self.tcx.inherent_impls(def_id);\n         for &impl_did in inherent_impls.iter() {\n             for item_did in self.tcx.associated_item_def_ids(impl_did) {\n-                if let Some(did) = item_did.as_local() {\n-                    let item_hir_id = self.tcx.hir().local_def_id_to_hir_id(did);\n-                    if self.live_symbols.contains(&item_hir_id) {\n+                if let Some(def_id) = item_did.as_local() {\n+                    if self.live_symbols.contains(&def_id) {\n                         return true;\n                     }\n                 }\n@@ -721,7 +718,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         match impl_item.kind {\n             hir::ImplItemKind::Const(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.hir_id()) {\n+                if !self.symbol_is_live(impl_item.def_id) {\n                     self.warn_dead_code(\n                         impl_item.hir_id(),\n                         impl_item.span,\n@@ -732,7 +729,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                 self.visit_nested_body(body_id)\n             }\n             hir::ImplItemKind::Fn(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.hir_id()) {\n+                if !self.symbol_is_live(impl_item.def_id) {\n                     // FIXME(66095): Because impl_item.span is annotated with things\n                     // like expansion data, and ident.span isn't, we use the\n                     // def_span method if it's part of a macro invocation"}, {"sha": "ad02f4f8269ad0f40c5d123c62bb8f4b806b4eb6", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -351,7 +351,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n         if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(ref trait_ref), ref items, .. }) =\n             item.kind\n         {\n-            if !self.access_levels.is_reachable(item.hir_id()) {\n+            if !self.access_levels.is_reachable(item.def_id) {\n                 // FIXME(#53488) remove `let`\n                 let tcx = self.tcx;\n                 self.worklist.extend(items.iter().map(|ii_ref| ii_ref.id.def_id));\n@@ -404,9 +404,7 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n     //         If other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n-    reachable_context\n-        .worklist\n-        .extend(access_levels.map.iter().map(|(id, _)| tcx.hir().local_def_id(*id)));\n+    reachable_context.worklist.extend(access_levels.map.keys());\n     for item in tcx.lang_items().items().iter() {\n         if let Some(def_id) = *item {\n             if let Some(def_id) = def_id.as_local() {"}, {"sha": "484040de0fb66b7bf4f2b86285db342ada7b299c", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{FieldDef, Generics, HirId, Item, TraitRef, Ty, TyKind, Variant};\n use rustc_middle::hir::map::Map;\n@@ -99,7 +99,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n     // If the node is a function, `fn_sig` is its signature\n     fn annotate<F>(\n         &mut self,\n-        hir_id: HirId,\n+        def_id: LocalDefId,\n         item_sp: Span,\n         fn_sig: Option<&'tcx hir::FnSig<'tcx>>,\n         kind: AnnotationKind,\n@@ -110,11 +110,11 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n     ) where\n         F: FnOnce(&mut Self),\n     {\n-        let attrs = self.tcx.hir().attrs(hir_id);\n-        debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n+        let attrs = self.tcx.get_attrs(def_id.to_def_id());\n+        debug!(\"annotate(id = {:?}, attrs = {:?})\", def_id, attrs);\n         let mut did_error = false;\n         if !self.tcx.features().staged_api {\n-            did_error = self.forbid_staged_api_attrs(hir_id, attrs, inherit_deprecation.clone());\n+            did_error = self.forbid_staged_api_attrs(def_id, attrs, inherit_deprecation.clone());\n         }\n \n         let depr = if did_error { None } else { attr::find_deprecation(&self.tcx.sess, attrs) };\n@@ -123,6 +123,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             is_deprecated = true;\n \n             if kind == AnnotationKind::Prohibited || kind == AnnotationKind::DeprecationProhibited {\n+                let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                 self.tcx.struct_span_lint_hir(USELESS_DEPRECATED, hir_id, *span, |lint| {\n                     lint.build(\"this `#[deprecated]` annotation has no effect\")\n                         .span_suggestion_short(\n@@ -136,13 +137,13 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             }\n \n             // `Deprecation` is just two pointers, no need to intern it\n-            let depr_entry = DeprecationEntry::local(depr.clone(), hir_id);\n-            self.index.depr_map.insert(hir_id, depr_entry);\n+            let depr_entry = DeprecationEntry::local(depr.clone(), def_id);\n+            self.index.depr_map.insert(def_id, depr_entry);\n         } else if let Some(parent_depr) = self.parent_depr.clone() {\n             if inherit_deprecation.yes() {\n                 is_deprecated = true;\n-                info!(\"tagging child {:?} as deprecated from parent\", hir_id);\n-                self.index.depr_map.insert(hir_id, parent_depr);\n+                info!(\"tagging child {:?} as deprecated from parent\", def_id);\n+                self.index.depr_map.insert(def_id, parent_depr);\n             }\n         }\n \n@@ -157,7 +158,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             }\n         } else {\n             self.recurse_with_stability_attrs(\n-                depr.map(|(d, _)| DeprecationEntry::local(d, hir_id)),\n+                depr.map(|(d, _)| DeprecationEntry::local(d, def_id)),\n                 None,\n                 None,\n                 visit_children,\n@@ -170,7 +171,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n \n         let const_stab = const_stab.map(|(const_stab, const_span_node)| {\n             let const_stab = self.tcx.intern_const_stability(const_stab);\n-            self.index.const_stab_map.insert(hir_id, const_stab);\n+            self.index.const_stab_map.insert(def_id, const_stab);\n             const_span = Some(const_span_node);\n             const_stab\n         });\n@@ -183,7 +184,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 && !fn_sig.header.is_const()\n             {\n                 if !self.in_trait_impl\n-                    || (self.in_trait_impl && !self.tcx.is_const_fn_raw(hir_id.owner.to_def_id()))\n+                    || (self.in_trait_impl && !self.tcx.is_const_fn_raw(def_id.to_def_id()))\n                 {\n                     missing_const_err(&self.tcx.sess, fn_sig.span, const_span);\n                 }\n@@ -196,7 +197,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             debug!(\"annotate: const_stab not found, parent = {:?}\", self.parent_const_stab);\n             if let Some(parent) = self.parent_const_stab {\n                 if parent.level.is_unstable() {\n-                    self.index.const_stab_map.insert(hir_id, parent);\n+                    self.index.const_stab_map.insert(def_id, parent);\n                 }\n             }\n         }\n@@ -271,7 +272,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 }\n             }\n \n-            self.index.stab_map.insert(hir_id, stab);\n+            self.index.stab_map.insert(def_id, stab);\n             stab\n         });\n \n@@ -281,13 +282,13 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 if inherit_deprecation.yes() && stab.level.is_unstable()\n                     || inherit_from_parent.yes()\n                 {\n-                    self.index.stab_map.insert(hir_id, stab);\n+                    self.index.stab_map.insert(def_id, stab);\n                 }\n             }\n         }\n \n         self.recurse_with_stability_attrs(\n-            depr.map(|(d, _)| DeprecationEntry::local(d, hir_id)),\n+            depr.map(|(d, _)| DeprecationEntry::local(d, def_id)),\n             stab,\n             if inherit_const_stability.yes() { const_stab } else { None },\n             visit_children,\n@@ -333,7 +334,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n     // returns true if an error occurred, used to suppress some spurious errors\n     fn forbid_staged_api_attrs(\n         &mut self,\n-        hir_id: HirId,\n+        def_id: LocalDefId,\n         attrs: &[Attribute],\n         inherit_deprecation: InheritDeprecation,\n     ) -> bool {\n@@ -365,7 +366,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         // -Zforce-unstable-if-unmarked is set.\n         if let Some(stab) = self.parent_stab {\n             if inherit_deprecation.yes() && stab.level.is_unstable() {\n-                self.index.stab_map.insert(hir_id, stab);\n+                self.index.stab_map.insert(def_id, stab);\n             }\n         }\n \n@@ -407,7 +408,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             hir::ItemKind::Struct(ref sd, _) => {\n                 if let Some(ctor_hir_id) = sd.ctor_hir_id() {\n                     self.annotate(\n-                        ctor_hir_id,\n+                        self.tcx.hir().local_def_id(ctor_hir_id),\n                         i.span,\n                         None,\n                         AnnotationKind::Required,\n@@ -425,7 +426,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         }\n \n         self.annotate(\n-            i.hir_id(),\n+            i.def_id,\n             i.span,\n             fn_sig,\n             kind,\n@@ -444,7 +445,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         };\n \n         self.annotate(\n-            ti.hir_id(),\n+            ti.def_id,\n             ti.span,\n             fn_sig,\n             AnnotationKind::Required,\n@@ -467,7 +468,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         };\n \n         self.annotate(\n-            ii.hir_id(),\n+            ii.def_id,\n             ii.span,\n             fn_sig,\n             kind,\n@@ -482,7 +483,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n \n     fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics<'tcx>, item_id: HirId) {\n         self.annotate(\n-            var.id,\n+            self.tcx.hir().local_def_id(var.id),\n             var.span,\n             None,\n             AnnotationKind::Required,\n@@ -492,7 +493,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             |v| {\n                 if let Some(ctor_hir_id) = var.data.ctor_hir_id() {\n                     v.annotate(\n-                        ctor_hir_id,\n+                        v.tcx.hir().local_def_id(ctor_hir_id),\n                         var.span,\n                         None,\n                         AnnotationKind::Required,\n@@ -510,7 +511,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n \n     fn visit_field_def(&mut self, s: &'tcx FieldDef<'tcx>) {\n         self.annotate(\n-            s.hir_id,\n+            self.tcx.hir().local_def_id(s.hir_id),\n             s.span,\n             None,\n             AnnotationKind::Required,\n@@ -525,7 +526,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n         self.annotate(\n-            i.hir_id(),\n+            i.def_id,\n             i.span,\n             None,\n             AnnotationKind::Required,\n@@ -540,7 +541,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n         self.annotate(\n-            md.hir_id(),\n+            md.def_id,\n             md.span,\n             None,\n             AnnotationKind::Required,\n@@ -560,7 +561,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         };\n \n         self.annotate(\n-            p.hir_id,\n+            self.tcx.hir().local_def_id(p.hir_id),\n             p.span,\n             None,\n             kind,\n@@ -580,22 +581,19 @@ struct MissingStabilityAnnotations<'tcx> {\n }\n \n impl<'tcx> MissingStabilityAnnotations<'tcx> {\n-    fn check_missing_stability(&self, hir_id: HirId, span: Span) {\n-        let stab = self.tcx.stability().local_stability(hir_id);\n-        let is_error =\n-            !self.tcx.sess.opts.test && stab.is_none() && self.access_levels.is_reachable(hir_id);\n-        if is_error {\n-            let def_id = self.tcx.hir().local_def_id(hir_id);\n+    fn check_missing_stability(&self, def_id: LocalDefId, span: Span) {\n+        let stab = self.tcx.stability().local_stability(def_id);\n+        if !self.tcx.sess.opts.test && stab.is_none() && self.access_levels.is_reachable(def_id) {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n             self.tcx.sess.span_err(span, &format!(\"{} has missing stability attribute\", descr));\n         }\n     }\n \n-    fn check_missing_const_stability(&self, hir_id: HirId, span: Span) {\n+    fn check_missing_const_stability(&self, def_id: LocalDefId, span: Span) {\n         let stab_map = self.tcx.stability();\n-        let stab = stab_map.local_stability(hir_id);\n+        let stab = stab_map.local_stability(def_id);\n         if stab.map_or(false, |stab| stab.level.is_stable()) {\n-            let const_stab = stab_map.local_const_stability(hir_id);\n+            let const_stab = stab_map.local_const_stability(def_id);\n             if const_stab.is_none() {\n                 self.tcx.sess.span_err(\n                     span,\n@@ -624,50 +622,50 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n             hir::ItemKind::Impl(hir::Impl { of_trait: None, .. })\n                 | hir::ItemKind::ForeignMod { .. }\n         ) {\n-            self.check_missing_stability(i.hir_id(), i.span);\n+            self.check_missing_stability(i.def_id, i.span);\n         }\n \n         // Ensure `const fn` that are `stable` have one of `rustc_const_unstable` or\n         // `rustc_const_stable`.\n         if self.tcx.features().staged_api\n             && matches!(&i.kind, hir::ItemKind::Fn(sig, ..) if sig.header.is_const())\n         {\n-            self.check_missing_const_stability(i.hir_id(), i.span);\n+            self.check_missing_const_stability(i.def_id, i.span);\n         }\n \n         intravisit::walk_item(self, i)\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n-        self.check_missing_stability(ti.hir_id(), ti.span);\n+        self.check_missing_stability(ti.def_id, ti.span);\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n         let impl_def_id = self.tcx.hir().local_def_id(self.tcx.hir().get_parent_item(ii.hir_id()));\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n-            self.check_missing_stability(ii.hir_id(), ii.span);\n+            self.check_missing_stability(ii.def_id, ii.span);\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics<'tcx>, item_id: HirId) {\n-        self.check_missing_stability(var.id, var.span);\n+        self.check_missing_stability(self.tcx.hir().local_def_id(var.id), var.span);\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n \n     fn visit_field_def(&mut self, s: &'tcx FieldDef<'tcx>) {\n-        self.check_missing_stability(s.hir_id, s.span);\n+        self.check_missing_stability(self.tcx.hir().local_def_id(s.hir_id), s.span);\n         intravisit::walk_field_def(self, s);\n     }\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n-        self.check_missing_stability(i.hir_id(), i.span);\n+        self.check_missing_stability(i.def_id, i.span);\n         intravisit::walk_foreign_item(self, i);\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n-        self.check_missing_stability(md.hir_id(), md.span);\n+        self.check_missing_stability(md.def_id, md.span);\n     }\n \n     // Note that we don't need to `check_missing_stability` for default generic parameters,\n@@ -731,7 +729,7 @@ fn stability_index(tcx: TyCtxt<'tcx>, (): ()) -> Index<'tcx> {\n         }\n \n         annotator.annotate(\n-            hir::CRATE_HIR_ID,\n+            CRATE_DEF_ID,\n             krate.module().inner,\n             None,\n             AnnotationKind::Required,\n@@ -929,7 +927,7 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     if tcx.stability().staged_api[&LOCAL_CRATE] {\n         let krate = tcx.hir().krate();\n         let mut missing = MissingStabilityAnnotations { tcx, access_levels };\n-        missing.check_missing_stability(hir::CRATE_HIR_ID, krate.module().inner);\n+        missing.check_missing_stability(CRATE_DEF_ID, krate.module().inner);\n         intravisit::walk_crate(&mut missing, krate);\n         krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n     }"}, {"sha": "1a0510d23cf1366c9e9273ecd492216f1645ec21", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 80, "deletions": 81, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -11,7 +11,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, DeepVisitor, NestedVisitorMap, Visitor};\n use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n use rustc_middle::bug;\n@@ -385,8 +385,7 @@ impl VisibilityLike for Option<AccessLevel> {\n     fn new_min(find: &FindMin<'_, '_, Self>, def_id: DefId) -> Self {\n         cmp::min(\n             if let Some(def_id) = def_id.as_local() {\n-                let hir_id = find.tcx.hir().local_def_id_to_hir_id(def_id);\n-                find.access_levels.map.get(&hir_id).cloned()\n+                find.access_levels.map.get(&def_id).copied()\n             } else {\n                 Self::MAX\n             },\n@@ -416,7 +415,7 @@ struct EmbargoVisitor<'tcx> {\n     /// pub macro m() {\n     ///     n::p::f()\n     /// }\n-    macro_reachable: FxHashSet<(hir::HirId, DefId)>,\n+    macro_reachable: FxHashSet<(LocalDefId, LocalDefId)>,\n     /// Previous accessibility level; `None` means unreachable.\n     prev_level: Option<AccessLevel>,\n     /// Has something changed in the level map?\n@@ -430,16 +429,16 @@ struct ReachEverythingInTheInterfaceVisitor<'a, 'tcx> {\n }\n \n impl EmbargoVisitor<'tcx> {\n-    fn get(&self, id: hir::HirId) -> Option<AccessLevel> {\n-        self.access_levels.map.get(&id).cloned()\n+    fn get(&self, def_id: LocalDefId) -> Option<AccessLevel> {\n+        self.access_levels.map.get(&def_id).copied()\n     }\n \n     /// Updates node level and returns the updated level.\n-    fn update(&mut self, id: hir::HirId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n-        let old_level = self.get(id);\n+    fn update(&mut self, def_id: LocalDefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n+        let old_level = self.get(def_id);\n         // Accessibility levels can only grow.\n         if level > old_level {\n-            self.access_levels.map.insert(id, level.unwrap());\n+            self.access_levels.map.insert(def_id, level.unwrap());\n             self.changed = true;\n             level\n         } else {\n@@ -461,31 +460,33 @@ impl EmbargoVisitor<'tcx> {\n \n     /// Updates the item as being reachable through a macro defined in the given\n     /// module. Returns `true` if the level has changed.\n-    fn update_macro_reachable(&mut self, reachable_mod: hir::HirId, defining_mod: DefId) -> bool {\n-        if self.macro_reachable.insert((reachable_mod, defining_mod)) {\n-            self.update_macro_reachable_mod(reachable_mod, defining_mod);\n+    fn update_macro_reachable(\n+        &mut self,\n+        module_def_id: LocalDefId,\n+        defining_mod: LocalDefId,\n+    ) -> bool {\n+        if self.macro_reachable.insert((module_def_id, defining_mod)) {\n+            self.update_macro_reachable_mod(module_def_id, defining_mod);\n             true\n         } else {\n             false\n         }\n     }\n \n-    fn update_macro_reachable_mod(&mut self, reachable_mod: hir::HirId, defining_mod: DefId) {\n-        let module_def_id = self.tcx.hir().local_def_id(reachable_mod);\n+    fn update_macro_reachable_mod(&mut self, module_def_id: LocalDefId, defining_mod: LocalDefId) {\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n             let def_kind = self.tcx.def_kind(item_id.def_id);\n             let vis = self.tcx.visibility(item_id.def_id);\n-            self.update_macro_reachable_def(item_id.hir_id(), def_kind, vis, defining_mod);\n+            self.update_macro_reachable_def(item_id.def_id, def_kind, vis, defining_mod);\n         }\n         if let Some(exports) = self.tcx.module_exports(module_def_id) {\n             for export in exports {\n-                if export.vis.is_accessible_from(defining_mod, self.tcx) {\n+                if export.vis.is_accessible_from(defining_mod.to_def_id(), self.tcx) {\n                     if let Res::Def(def_kind, def_id) = export.res {\n                         if let Some(def_id) = def_id.as_local() {\n-                            let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                             let vis = self.tcx.visibility(def_id.to_def_id());\n-                            self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n+                            self.update_macro_reachable_def(def_id, def_kind, vis, defining_mod);\n                         }\n                     }\n                 }\n@@ -495,14 +496,14 @@ impl EmbargoVisitor<'tcx> {\n \n     fn update_macro_reachable_def(\n         &mut self,\n-        hir_id: hir::HirId,\n+        def_id: LocalDefId,\n         def_kind: DefKind,\n         vis: ty::Visibility,\n-        module: DefId,\n+        module: LocalDefId,\n     ) {\n         let level = Some(AccessLevel::Reachable);\n         if let ty::Visibility::Public = vis {\n-            self.update(hir_id, level);\n+            self.update(def_id, level);\n         }\n         match def_kind {\n             // No type privacy, so can be directly marked as reachable.\n@@ -511,8 +512,8 @@ impl EmbargoVisitor<'tcx> {\n             | DefKind::Static\n             | DefKind::TraitAlias\n             | DefKind::TyAlias => {\n-                if vis.is_accessible_from(module, self.tcx) {\n-                    self.update(hir_id, level);\n+                if vis.is_accessible_from(module.to_def_id(), self.tcx) {\n+                    self.update(def_id, level);\n                 }\n             }\n \n@@ -521,23 +522,23 @@ impl EmbargoVisitor<'tcx> {\n             // hygiene these don't need to be marked reachable. The contents of\n             // the module, however may be reachable.\n             DefKind::Mod => {\n-                if vis.is_accessible_from(module, self.tcx) {\n-                    self.update_macro_reachable(hir_id, module);\n+                if vis.is_accessible_from(module.to_def_id(), self.tcx) {\n+                    self.update_macro_reachable(def_id, module);\n                 }\n             }\n \n             DefKind::Struct | DefKind::Union => {\n-                // While structs and unions have type privacy, their fields do\n-                // not.\n+                // While structs and unions have type privacy, their fields do not.\n                 if let ty::Visibility::Public = vis {\n-                    let item = self.tcx.hir().expect_item(hir_id);\n+                    let item =\n+                        self.tcx.hir().expect_item(self.tcx.hir().local_def_id_to_hir_id(def_id));\n                     if let hir::ItemKind::Struct(ref struct_def, _)\n                     | hir::ItemKind::Union(ref struct_def, _) = item.kind\n                     {\n                         for field in struct_def.fields() {\n                             let field_vis =\n                                 self.tcx.visibility(self.tcx.hir().local_def_id(field.hir_id));\n-                            if field_vis.is_accessible_from(module, self.tcx) {\n+                            if field_vis.is_accessible_from(module.to_def_id(), self.tcx) {\n                                 self.reach(field.hir_id, level).ty();\n                             }\n                         }\n@@ -616,7 +617,7 @@ impl EmbargoVisitor<'tcx> {\n                             continue;\n                         }\n                         if let hir::ItemKind::Use(..) = item.kind {\n-                            self.update(item.hir_id(), Some(AccessLevel::Exported));\n+                            self.update(item.def_id, Some(AccessLevel::Exported));\n                         }\n                     }\n                 }\n@@ -665,47 +666,48 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         };\n \n         // Update level of the item itself.\n-        let item_level = self.update(item.hir_id(), inherited_item_level);\n+        let item_level = self.update(item.def_id, inherited_item_level);\n \n         // Update levels of nested things.\n         match item.kind {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in def.variants {\n-                    let variant_level = self.update(variant.id, item_level);\n+                    let variant_level =\n+                        self.update(self.tcx.hir().local_def_id(variant.id), item_level);\n                     if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n-                        self.update(ctor_hir_id, item_level);\n+                        self.update(self.tcx.hir().local_def_id(ctor_hir_id), item_level);\n                     }\n                     for field in variant.data.fields() {\n-                        self.update(field.hir_id, variant_level);\n+                        self.update(self.tcx.hir().local_def_id(field.hir_id), variant_level);\n                     }\n                 }\n             }\n             hir::ItemKind::Impl(ref impl_) => {\n                 for impl_item_ref in impl_.items {\n                     if impl_.of_trait.is_some() || impl_item_ref.vis.node.is_pub() {\n-                        self.update(impl_item_ref.id.hir_id(), item_level);\n+                        self.update(impl_item_ref.id.def_id, item_level);\n                     }\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.hir_id(), item_level);\n+                    self.update(trait_item_ref.id.def_id, item_level);\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n                 if let Some(ctor_hir_id) = def.ctor_hir_id() {\n-                    self.update(ctor_hir_id, item_level);\n+                    self.update(self.tcx.hir().local_def_id(ctor_hir_id), item_level);\n                 }\n                 for field in def.fields() {\n                     if field.vis.node.is_pub() {\n-                        self.update(field.hir_id, item_level);\n+                        self.update(self.tcx.hir().local_def_id(field.hir_id), item_level);\n                     }\n                 }\n             }\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n                     if foreign_item.vis.node.is_pub() {\n-                        self.update(foreign_item.id.hir_id(), item_level);\n+                        self.update(foreign_item.id.def_id, item_level);\n                     }\n                 }\n             }\n@@ -789,7 +791,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     self.reach(item.hir_id(), item_level).generics().predicates().ty().trait_ref();\n \n                     for impl_item_ref in impl_.items {\n-                        let impl_item_level = self.get(impl_item_ref.id.hir_id());\n+                        let impl_item_level = self.get(impl_item_ref.id.def_id);\n                         if impl_item_level.is_some() {\n                             self.reach(impl_item_ref.id.hir_id(), impl_item_level)\n                                 .generics()\n@@ -806,21 +808,21 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     self.reach(item.hir_id(), item_level).generics().predicates();\n                 }\n                 for variant in def.variants {\n-                    let variant_level = self.get(variant.id);\n+                    let variant_level = self.get(self.tcx.hir().local_def_id(variant.id));\n                     if variant_level.is_some() {\n                         for field in variant.data.fields() {\n                             self.reach(field.hir_id, variant_level).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n-                        self.update(item.hir_id(), variant_level);\n+                        self.update(item.def_id, variant_level);\n                     }\n                 }\n             }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    let foreign_item_level = self.get(foreign_item.id.hir_id());\n+                    let foreign_item_level = self.get(foreign_item.id.def_id);\n                     if foreign_item_level.is_some() {\n                         self.reach(foreign_item.id.hir_id(), foreign_item_level)\n                             .generics()\n@@ -834,7 +836,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 if item_level.is_some() {\n                     self.reach(item.hir_id(), item_level).generics().predicates();\n                     for field in struct_def.fields() {\n-                        let field_level = self.get(field.hir_id);\n+                        let field_level = self.get(self.tcx.hir().local_def_id(field.hir_id));\n                         if field_level.is_some() {\n                             self.reach(field.hir_id, field_level).ty();\n                         }\n@@ -867,8 +869,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     if export.vis == ty::Visibility::Public {\n                         if let Some(def_id) = export.res.opt_def_id() {\n                             if let Some(def_id) = def_id.as_local() {\n-                                let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                                self.update(hir_id, Some(AccessLevel::Exported));\n+                                self.update(def_id, Some(AccessLevel::Exported));\n                             }\n                         }\n                     }\n@@ -888,32 +889,35 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // `#[macro_export]`-ed `macro_rules!` are `Public` since they\n             // ignore their containing path to always appear at the crate root.\n             if md.ast.macro_rules {\n-                self.update(md.hir_id(), Some(AccessLevel::Public));\n+                self.update(md.def_id, Some(AccessLevel::Public));\n             }\n             return;\n         }\n \n-        let macro_module_def_id = ty::DefIdTree::parent(self.tcx, md.def_id.to_def_id()).unwrap();\n-        let hir_id = macro_module_def_id\n-            .as_local()\n-            .map(|def_id| self.tcx.hir().local_def_id_to_hir_id(def_id));\n-        let mut module_id = match hir_id {\n-            Some(module_id) if self.tcx.hir().is_hir_id_module(module_id) => module_id,\n-            // `module_id` doesn't correspond to a `mod`, return early (#63164, #65252).\n-            _ => return,\n-        };\n-        let level = if md.vis.node.is_pub() { self.get(module_id) } else { None };\n-        let new_level = self.update(md.hir_id(), level);\n+        let macro_module_def_id =\n+            ty::DefIdTree::parent(self.tcx, md.def_id.to_def_id()).unwrap().expect_local();\n+        if self.tcx.hir().opt_def_kind(macro_module_def_id) != Some(DefKind::Mod) {\n+            // The macro's parent doesn't correspond to a `mod`, return early (#63164, #65252).\n+            return;\n+        }\n+\n+        let level = if md.vis.node.is_pub() { self.get(macro_module_def_id) } else { None };\n+        let new_level = self.update(md.def_id, level);\n         if new_level.is_none() {\n             return;\n         }\n \n+        // Since we are starting from an externally visible module,\n+        // all the parents in the loop below are also guaranteed to be modules.\n+        let mut module_def_id = macro_module_def_id;\n         loop {\n-            let changed_reachability = self.update_macro_reachable(module_id, macro_module_def_id);\n-            if changed_reachability || module_id == hir::CRATE_HIR_ID {\n+            let changed_reachability =\n+                self.update_macro_reachable(module_def_id, macro_module_def_id);\n+            if changed_reachability || module_def_id == CRATE_DEF_ID {\n                 break;\n             }\n-            module_id = self.tcx.hir().get_parent_node(module_id);\n+            module_def_id =\n+                ty::DefIdTree::parent(self.tcx, module_def_id.to_def_id()).unwrap().expect_local();\n         }\n     }\n }\n@@ -971,8 +975,7 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n             if let (ty::Visibility::Public, _) | (_, Some(AccessLevel::ReachableFromImplTrait)) =\n                 (self.tcx().visibility(def_id.to_def_id()), self.access_level)\n             {\n-                let hir_id = self.ev.tcx.hir().local_def_id_to_hir_id(def_id);\n-                self.ev.update(hir_id, self.access_level);\n+                self.ev.update(def_id, self.access_level);\n             }\n         }\n         ControlFlow::CONTINUE\n@@ -1449,7 +1452,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn trait_is_public(&self, trait_id: hir::HirId) -> bool {\n+    fn trait_is_public(&self, trait_id: LocalDefId) -> bool {\n         // FIXME: this would preferably be using `exported_items`, but all\n         // traits are exported currently (see `EmbargoVisitor.exported_trait`).\n         self.access_levels.is_public(trait_id)\n@@ -1463,8 +1466,8 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn item_is_public(&self, id: &hir::HirId, vis: &hir::Visibility<'_>) -> bool {\n-        self.access_levels.is_reachable(*id) || vis.node.is_pub()\n+    fn item_is_public(&self, def_id: LocalDefId, vis: &hir::Visibility<'_>) -> bool {\n+        self.access_levels.is_reachable(def_id) || vis.node.is_pub()\n     }\n }\n \n@@ -1524,7 +1527,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::ForeignMod { .. } => {}\n \n             hir::ItemKind::Trait(.., ref bounds, _) => {\n-                if !self.trait_is_public(item.hir_id()) {\n+                if !self.trait_is_public(item.def_id) {\n                     return;\n                 }\n \n@@ -1564,10 +1567,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                 let not_private_trait = impl_.of_trait.as_ref().map_or(\n                     true, // no trait counts as public trait\n                     |tr| {\n-                        let did = tr.path.res.def_id();\n-\n-                        if let Some(did) = did.as_local() {\n-                            self.trait_is_public(self.tcx.hir().local_def_id_to_hir_id(did))\n+                        if let Some(def_id) = tr.path.res.def_id().as_local() {\n+                            self.trait_is_public(def_id)\n                         } else {\n                             true // external traits must be public\n                         }\n@@ -1587,7 +1588,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                         let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                         match impl_item.kind {\n                             hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..) => {\n-                                self.access_levels.is_reachable(impl_item_ref.id.hir_id())\n+                                self.access_levels.is_reachable(impl_item_ref.id.def_id)\n                             }\n                             hir::ImplItemKind::TyAlias(_) => false,\n                         }\n@@ -1607,10 +1608,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                                 match impl_item.kind {\n                                     hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..)\n-                                        if self.item_is_public(\n-                                            &impl_item.hir_id(),\n-                                            &impl_item.vis,\n-                                        ) =>\n+                                        if self\n+                                            .item_is_public(impl_item.def_id, &impl_item.vis) =>\n                                     {\n                                         intravisit::walk_impl_item(self, impl_item)\n                                     }\n@@ -1651,7 +1650,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for impl_item_ref in impl_.items {\n-                        if self.item_is_public(&impl_item_ref.id.hir_id(), &impl_item_ref.vis) {\n+                        if self.item_is_public(impl_item_ref.id.def_id, &impl_item_ref.vis) {\n                             let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                             match impl_item_ref.kind {\n                                 AssocItemKind::Const => {\n@@ -1678,7 +1677,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::TyAlias(..) => return,\n \n             // Not at all public, so we don't care.\n-            _ if !self.item_is_public(&item.hir_id(), &item.vis) => {\n+            _ if !self.item_is_public(item.def_id, &item.vis) => {\n                 return;\n             }\n \n@@ -1714,7 +1713,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        if self.access_levels.is_reachable(item.hir_id()) {\n+        if self.access_levels.is_reachable(item.def_id) {\n             intravisit::walk_foreign_item(self, item)\n         }\n     }\n@@ -1734,7 +1733,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         g: &'tcx hir::Generics<'tcx>,\n         item_id: hir::HirId,\n     ) {\n-        if self.access_levels.is_reachable(v.id) {\n+        if self.access_levels.is_reachable(self.tcx.hir().local_def_id(v.id)) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;\n@@ -2150,7 +2149,7 @@ fn privacy_access_levels(tcx: TyCtxt<'_>, (): ()) -> &AccessLevels {\n             break;\n         }\n     }\n-    visitor.update(hir::CRATE_HIR_ID, Some(AccessLevel::Public));\n+    visitor.update(CRATE_DEF_ID, Some(AccessLevel::Public));\n \n     tcx.arena.alloc(visitor.access_levels)\n }"}, {"sha": "aea48bf3da8df7d8b08298bf52cca598abbcd91f", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -255,16 +255,17 @@ impl<'tcx> DumpVisitor<'tcx> {\n         &mut self,\n         sig: &'tcx hir::FnSig<'tcx>,\n         body: Option<hir::BodyId>,\n-        hir_id: hir::HirId,\n+        def_id: LocalDefId,\n         ident: Ident,\n         generics: &'tcx hir::Generics<'tcx>,\n         vis: &hir::Visibility<'tcx>,\n         span: Span,\n     ) {\n-        debug!(\"process_method: {}:{}\", hir_id, ident);\n+        debug!(\"process_method: {:?}:{}\", def_id, ident);\n \n         let map = &self.tcx.hir();\n-        self.nest_typeck_results(map.local_def_id(hir_id), |v| {\n+        let hir_id = map.local_def_id_to_hir_id(def_id);\n+        self.nest_typeck_results(def_id, |v| {\n             if let Some(mut method_data) = v.save_ctxt.get_method_data(hir_id, ident, span) {\n                 if let Some(body) = body {\n                     v.process_formals(map.body(body).params, &method_data.qualname);\n@@ -275,7 +276,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     fn_to_string(sig.decl, sig.header, Some(ident.name), generics, vis, &[], None);\n                 method_data.sig = sig::method_signature(hir_id, ident, generics, sig, &v.save_ctxt);\n \n-                v.dumper.dump_def(&access_from_vis!(v.save_ctxt, vis, hir_id), method_data);\n+                v.dumper.dump_def(&access_from_vis!(v.save_ctxt, vis, def_id), method_data);\n             }\n \n             // walk arg and return types\n@@ -301,7 +302,10 @@ impl<'tcx> DumpVisitor<'tcx> {\n     ) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, field, field.hir_id), field_data);\n+            self.dumper.dump_def(\n+                &access_from!(self.save_ctxt, field, self.tcx.hir().local_def_id(field.hir_id)),\n+                field_data,\n+            );\n         }\n     }\n \n@@ -366,7 +370,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 v.process_formals(body.params, &fn_data.qualname);\n                 v.process_generic_params(ty_params, &fn_data.qualname, item.hir_id());\n \n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.hir_id()), fn_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.def_id), fn_data);\n             }\n \n             for arg in decl.inputs {\n@@ -390,7 +394,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         self.nest_typeck_results(item.def_id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.hir_id()), var_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item, item.def_id), var_data);\n             }\n             v.visit_ty(&typ);\n             v.visit_expr(expr);\n@@ -399,23 +403,23 @@ impl<'tcx> DumpVisitor<'tcx> {\n \n     fn process_assoc_const(\n         &mut self,\n-        hir_id: hir::HirId,\n+        def_id: LocalDefId,\n         ident: Ident,\n         typ: &'tcx hir::Ty<'tcx>,\n         expr: Option<&'tcx hir::Expr<'tcx>>,\n         parent_id: DefId,\n         vis: &hir::Visibility<'tcx>,\n         attrs: &'tcx [ast::Attribute],\n     ) {\n-        let qualname =\n-            format!(\"::{}\", self.tcx.def_path_str(self.tcx.hir().local_def_id(hir_id).to_def_id()));\n+        let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id.to_def_id()));\n \n         if !self.span.filter_generated(ident.span) {\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n             let sig = sig::assoc_const_signature(hir_id, ident.name, typ, expr, &self.save_ctxt);\n             let span = self.span_from_span(ident.span);\n \n             self.dumper.dump_def(\n-                &access_from_vis!(self.save_ctxt, vis, hir_id),\n+                &access_from_vis!(self.save_ctxt, vis, def_id),\n                 Def {\n                     kind: DefKind::Const,\n                     id: id_from_hir_id(hir_id, &self.save_ctxt),\n@@ -434,7 +438,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         }\n \n         // walk type and init value\n-        self.nest_typeck_results(self.tcx.hir().local_def_id(hir_id), |v| {\n+        self.nest_typeck_results(def_id, |v| {\n             v.visit_ty(typ);\n             if let Some(expr) = expr {\n                 v.visit_expr(expr);\n@@ -484,7 +488,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             let span = self.span_from_span(item.ident.span);\n             let attrs = self.tcx.hir().attrs(item.hir_id());\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item, item.hir_id()),\n+                &access_from!(self.save_ctxt, item, item.def_id),\n                 Def {\n                     kind,\n                     id: id_from_def_id(item.def_id.to_def_id()),\n@@ -525,7 +529,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n-        let access = access_from!(self.save_ctxt, item, item.hir_id());\n+        let access = access_from!(self.save_ctxt, item, item.def_id);\n \n         for variant in enum_definition.variants {\n             let name = variant.ident.name.to_string();\n@@ -660,7 +664,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 methods.iter().map(|i| id_from_def_id(i.id.def_id.to_def_id())).collect();\n             let attrs = self.tcx.hir().attrs(item.hir_id());\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item, item.hir_id()),\n+                &access_from!(self.save_ctxt, item, item.def_id),\n                 Def {\n                     kind: DefKind::Trait,\n                     id,\n@@ -723,7 +727,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n     fn process_mod(&mut self, item: &'tcx hir::Item<'tcx>) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item, item.hir_id()), mod_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item, item.def_id), mod_data);\n         }\n     }\n \n@@ -985,7 +989,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 let respan = respan(vis_span, hir::VisibilityKind::Public);\n                 let attrs = self.tcx.hir().attrs(trait_item.hir_id());\n                 self.process_assoc_const(\n-                    trait_item.hir_id(),\n+                    trait_item.def_id,\n                     trait_item.ident,\n                     &ty,\n                     body,\n@@ -1001,7 +1005,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.process_method(\n                     sig,\n                     body,\n-                    trait_item.hir_id(),\n+                    trait_item.def_id,\n                     trait_item.ident,\n                     &trait_item.generics,\n                     &respan,\n@@ -1058,7 +1062,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 let body = self.tcx.hir().body(body);\n                 let attrs = self.tcx.hir().attrs(impl_item.hir_id());\n                 self.process_assoc_const(\n-                    impl_item.hir_id(),\n+                    impl_item.def_id,\n                     impl_item.ident,\n                     &ty,\n                     Some(&body.value),\n@@ -1071,7 +1075,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.process_method(\n                     sig,\n                     Some(body),\n-                    impl_item.hir_id(),\n+                    impl_item.def_id,\n                     impl_item.ident,\n                     &impl_item.generics,\n                     &impl_item.vis,\n@@ -1146,7 +1150,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             hir::ItemKind::Use(path, hir::UseKind::Single) => {\n                 let sub_span = path.segments.last().unwrap().ident.span;\n                 if !self.span.filter_generated(sub_span) {\n-                    let access = access_from!(self.save_ctxt, item, item.hir_id());\n+                    let access = access_from!(self.save_ctxt, item, item.def_id);\n                     let ref_id = self.lookup_def_id(item.hir_id()).map(id_from_def_id);\n                     let span = self.span_from_span(sub_span);\n                     let parent =\n@@ -1175,7 +1179,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 // we don't want to track anyway, since it's probably macro-internal `use`\n                 if let Some(sub_span) = self.span.sub_span_of_star(item.span) {\n                     if !self.span.filter_generated(item.span) {\n-                        let access = access_from!(self.save_ctxt, item, item.hir_id());\n+                        let access = access_from!(self.save_ctxt, item, item.def_id);\n                         let span = self.span_from_span(sub_span);\n                         let parent =\n                             self.save_ctxt.tcx.parent(item.def_id.to_def_id()).map(id_from_def_id);\n@@ -1248,7 +1252,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                     let attrs = self.tcx.hir().attrs(item.hir_id());\n \n                     self.dumper.dump_def(\n-                        &access_from!(self.save_ctxt, item, item.hir_id()),\n+                        &access_from!(self.save_ctxt, item, item.def_id),\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1432,7 +1436,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        let access = access_from!(self.save_ctxt, item, item.hir_id());\n+        let access = access_from!(self.save_ctxt, item, item.def_id);\n \n         match item.kind {\n             hir::ForeignItemKind::Fn(decl, _, ref generics) => {"}, {"sha": "46aa961722780ab1fa18cb98a1a130076d4d1d76", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -374,15 +374,8 @@ crate fn run_global_ctxt(\n     });\n     rustc_passes::stability::check_unused_or_stable_features(tcx);\n \n-    let access_levels = tcx.privacy_access_levels(());\n-    // Convert from a HirId set to a DefId set since we don't always have easy access\n-    // to the map from defid -> hirid\n     let access_levels = AccessLevels {\n-        map: access_levels\n-            .map\n-            .iter()\n-            .map(|(&k, &v)| (tcx.hir().local_def_id(k).to_def_id(), v))\n-            .collect(),\n+        map: tcx.privacy_access_levels(()).map.iter().map(|(k, v)| (k.to_def_id(), *v)).collect(),\n     };\n \n     let mut ctxt = DocContext {"}, {"sha": "cbe528a5ae0adfeb08547e8603453b6ea6f77736", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -1244,11 +1244,8 @@ impl LinkCollector<'_, '_> {\n                     item.def_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n                 })\n             {\n-                let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);\n-                let hir_dst = self.cx.tcx.hir().local_def_id_to_hir_id(dst_id);\n-\n-                if self.cx.tcx.privacy_access_levels(()).is_exported(hir_src)\n-                    && !self.cx.tcx.privacy_access_levels(()).is_exported(hir_dst)\n+                if self.cx.tcx.privacy_access_levels(()).is_exported(src_id)\n+                    && !self.cx.tcx.privacy_access_levels(()).is_exported(dst_id)\n                 {\n                     privacy_error(self.cx, &diag_info, &path_str);\n                 }"}, {"sha": "a3a3603c4c0ee5617b86c3c2a5e63f4116cce09b", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -21,6 +21,7 @@ use rustc_parse::maybe_new_parser_from_source_str;\n use rustc_parse::parser::ForceCollect;\n use rustc_session::parse::ParseSess;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{BytePos, FilePathMapping, MultiSpan, SourceMap, Span};\n use rustc_span::{sym, FileName, Pos};\n@@ -231,7 +232,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                     fpu.visit_expr(&body.value);\n                     lint_for_missing_headers(\n                         cx,\n-                        item.hir_id(),\n+                        item.def_id,\n                         item.span,\n                         sig,\n                         headers,\n@@ -258,7 +259,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n         let headers = check_attrs(cx, &self.valid_idents, attrs);\n         if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n             if !in_external_macro(cx.tcx.sess, item.span) {\n-                lint_for_missing_headers(cx, item.hir_id(), item.span, sig, headers, None, None);\n+                lint_for_missing_headers(cx, item.def_id, item.span, sig, headers, None, None);\n             }\n         }\n     }\n@@ -279,7 +280,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n             fpu.visit_expr(&body.value);\n             lint_for_missing_headers(\n                 cx,\n-                item.hir_id(),\n+                item.def_id,\n                 item.span,\n                 sig,\n                 headers,\n@@ -292,14 +293,14 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n \n fn lint_for_missing_headers<'tcx>(\n     cx: &LateContext<'tcx>,\n-    hir_id: hir::HirId,\n+    def_id: LocalDefId,\n     span: impl Into<MultiSpan> + Copy,\n     sig: &hir::FnSig<'_>,\n     headers: DocHeaders,\n     body_id: Option<hir::BodyId>,\n     panic_span: Option<Span>,\n ) {\n-    if !cx.access_levels.is_exported(hir_id) {\n+    if !cx.access_levels.is_exported(def_id) {\n         return; // Private functions do not require doc comments\n     }\n     if !headers.safety && sig.header.unsafety == hir::Unsafety::Unsafe {\n@@ -321,6 +322,7 @@ fn lint_for_missing_headers<'tcx>(\n         );\n     }\n     if !headers.errors {\n+        let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n         if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym::result_type) {\n             span_lint(\n                 cx,"}, {"sha": "174260fabd228688c47943efa52d9cae07f84481", "filename": "src/tools/clippy/clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -297,7 +297,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n             }\n         }\n         if let ItemKind::Enum(ref def, _) = item.kind {\n-            if !(self.avoid_breaking_exported_api && cx.access_levels.is_exported(item.hir_id())) {\n+            if !(self.avoid_breaking_exported_api && cx.access_levels.is_exported(item.def_id)) {\n                 check_variant(cx, self.threshold, def, &item_name, item_name_chars, item.span);\n             }\n         }"}, {"sha": "bb4684ce38b3d7eba4b74988aa8fe5cad9ddf05f", "filename": "src/tools/clippy/clippy_lints/src/exhaustive_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -71,7 +71,7 @@ impl LateLintPass<'_> for ExhaustiveItems {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         if_chain! {\n             if let ItemKind::Enum(..) | ItemKind::Struct(..) = item.kind;\n-            if cx.access_levels.is_exported(item.hir_id());\n+            if cx.access_levels.is_exported(item.def_id);\n             let attrs = cx.tcx.hir().attrs(item.hir_id());\n             if !attrs.iter().any(|a| a.has_name(sym::non_exhaustive));\n             then {"}, {"sha": "ea6193acbe84518ade96aef8d33277b5c5bedac7", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n-use rustc_hir::def_id::DefIdSet;\n+use rustc_hir::def_id::{DefIdSet, LocalDefId};\n use rustc_hir::{self as hir, def::Res, intravisit, QPath};\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::{\n@@ -22,7 +22,7 @@ pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n     let attr = must_use_attr(attrs);\n     if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n@@ -33,7 +33,7 @@ pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n                 sig.decl,\n                 cx.tcx.hir().body(*body_id),\n                 item.span,\n-                item.hir_id(),\n+                item.def_id,\n                 item.span.with_hi(sig.decl.output.span().hi()),\n                 \"this function could have a `#[must_use]` attribute\",\n             );\n@@ -43,7 +43,7 @@ pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n \n pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n     if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n         let attr = must_use_attr(attrs);\n@@ -55,7 +55,7 @@ pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<\n                 sig.decl,\n                 cx.tcx.hir().body(*body_id),\n                 item.span,\n-                item.hir_id(),\n+                item.def_id,\n                 item.span.with_hi(sig.decl.output.span().hi()),\n                 \"this method could have a `#[must_use]` attribute\",\n             );\n@@ -65,7 +65,7 @@ pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<\n \n pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n     if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n \n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n@@ -80,7 +80,7 @@ pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitIte\n                     sig.decl,\n                     body,\n                     item.span,\n-                    item.hir_id(),\n+                    item.def_id,\n                     item.span.with_hi(sig.decl.output.span().hi()),\n                     \"this method could have a `#[must_use]` attribute\",\n                 );\n@@ -132,7 +132,7 @@ fn check_must_use_candidate<'tcx>(\n     decl: &'tcx hir::FnDecl<'_>,\n     body: &'tcx hir::Body<'_>,\n     item_span: Span,\n-    item_id: hir::HirId,\n+    item_id: LocalDefId,\n     fn_span: Span,\n     msg: &str,\n ) {\n@@ -141,7 +141,7 @@ fn check_must_use_candidate<'tcx>(\n         || in_external_macro(cx.sess(), item_span)\n         || returns_unit(decl)\n         || !cx.access_levels.is_exported(item_id)\n-        || is_must_use_ty(cx, return_ty(cx, item_id))\n+        || is_must_use_ty(cx, return_ty(cx, cx.tcx.hir().local_def_id_to_hir_id(item_id)))\n     {\n         return;\n     }"}, {"sha": "f83789bb2199e0e2bfff2fb35eb2d64297c1e7ac", "filename": "src/tools/clippy/clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -1,6 +1,7 @@\n use rustc_hir::{self as hir, intravisit, HirIdSet};\n use rustc_lint::LateContext;\n use rustc_middle::{hir::map::Map, ty};\n+use rustc_span::def_id::LocalDefId;\n \n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::type_is_unsafe_function;\n@@ -21,13 +22,13 @@ pub(super) fn check_fn(\n         intravisit::FnKind::Closure => return,\n     };\n \n-    check_raw_ptr(cx, unsafety, decl, body, hir_id);\n+    check_raw_ptr(cx, unsafety, decl, body, cx.tcx.hir().local_def_id(hir_id));\n }\n \n pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n     if let hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(eid)) = item.kind {\n         let body = cx.tcx.hir().body(eid);\n-        check_raw_ptr(cx, sig.header.unsafety, sig.decl, body, item.hir_id());\n+        check_raw_ptr(cx, sig.header.unsafety, sig.decl, body, item.def_id);\n     }\n }\n \n@@ -36,10 +37,10 @@ fn check_raw_ptr(\n     unsafety: hir::Unsafety,\n     decl: &'tcx hir::FnDecl<'tcx>,\n     body: &'tcx hir::Body<'tcx>,\n-    hir_id: hir::HirId,\n+    def_id: LocalDefId,\n ) {\n     let expr = &body.value;\n-    if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(hir_id) {\n+    if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(def_id) {\n         let raw_ptrs = iter_input_pats(decl, body)\n             .zip(decl.inputs.iter())\n             .filter_map(|(arg, ty)| raw_ptr_arg(arg, ty))"}, {"sha": "13863ec8381bba34f37939e66b4e3abe8cdbe40b", "filename": "src/tools/clippy/clippy_lints/src/functions/result_unit_err.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -15,7 +15,7 @@ use super::RESULT_UNIT_ERR;\n \n pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n     if let hir::ItemKind::Fn(ref sig, ref _generics, _) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if is_public {\n             check_result_unit_err(cx, sig.decl, item.span, fn_header_span);\n@@ -25,7 +25,7 @@ pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n \n pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n     if let hir::ImplItemKind::Fn(ref sig, _) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if is_public && trait_ref_of_method(cx, item.hir_id()).is_none() {\n             check_result_unit_err(cx, sig.decl, item.span, fn_header_span);\n@@ -35,7 +35,7 @@ pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<\n \n pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n     if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n-        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if is_public {\n             check_result_unit_err(cx, sig.decl, item.span, fn_header_span);"}, {"sha": "6b407c7bb6724b5d288ab5dbb61d2af55960c941", "filename": "src/tools/clippy/clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -112,7 +112,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n             }\n         }\n \n-        if !cx.access_levels.is_exported(item.hir_id()) {\n+        if !cx.access_levels.is_exported(item.def_id) {\n             return;\n         }\n "}, {"sha": "a2cbfb1a05eeaec47f6d5979995dcbd4c3383129", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -131,7 +131,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             if item.ident.name == sym::len;\n             if let ImplItemKind::Fn(sig, _) = &item.kind;\n             if sig.decl.implicit_self.has_implicit_self();\n-            if cx.access_levels.is_exported(item.hir_id());\n+            if cx.access_levels.is_exported(item.def_id);\n             if matches!(sig.decl.output, FnRetTy::Return(_));\n             if let Some(imp) = get_parent_as_impl(cx.tcx, item.hir_id());\n             if imp.of_trait.is_none();\n@@ -207,7 +207,7 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n         }\n     }\n \n-    if cx.access_levels.is_exported(visited_trait.hir_id())\n+    if cx.access_levels.is_exported(visited_trait.def_id)\n         && trait_items.iter().any(|i| is_named_self(cx, i, sym::len))\n     {\n         let mut current_and_super_traits = DefIdSet::default();\n@@ -331,11 +331,7 @@ fn check_for_is_empty(\n             None,\n             None,\n         ),\n-        Some(is_empty)\n-            if !cx\n-                .access_levels\n-                .is_exported(cx.tcx.hir().local_def_id_to_hir_id(is_empty.def_id.expect_local())) =>\n-        {\n+        Some(is_empty) if !cx.access_levels.is_exported(is_empty.def_id.expect_local()) => {\n             (\n                 format!(\n                     \"{} `{}` has a public `len` method, but a private `is_empty` method\","}, {"sha": "1909fabb22fe77c35785145f963935cd29fbdc8d", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -1903,7 +1903,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n             then {\n                 // if this impl block implements a trait, lint in trait definition instead\n-                if !implements_trait && cx.access_levels.is_exported(impl_item.hir_id()) {\n+                if !implements_trait && cx.access_levels.is_exported(impl_item.def_id) {\n                     // check missing trait implementations\n                     for method_config in &TRAIT_METHODS {\n                         if name == method_config.method_name &&\n@@ -1935,7 +1935,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n                 if sig.decl.implicit_self.has_implicit_self()\n                     && !(self.avoid_breaking_exported_api\n-                        && cx.access_levels.is_exported(impl_item.hir_id()))\n+                        && cx.access_levels.is_exported(impl_item.def_id))\n                 {\n                     wrong_self_convention::check(\n                         cx,"}, {"sha": "977e6d966e873779cd4d72e909278e2cbced50ea", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -87,7 +87,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             return;\n         }\n \n-        if !cx.access_levels.is_exported(it.hir_id()) {\n+        if !cx.access_levels.is_exported(it.def_id) {\n             return;\n         }\n         match it.kind {\n@@ -140,7 +140,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n         }\n \n         // If the item being implemented is not exported, then we don't need #[inline]\n-        if !cx.access_levels.is_exported(impl_item.hir_id()) {\n+        if !cx.access_levels.is_exported(impl_item.def_id) {\n             return;\n         }\n \n@@ -155,7 +155,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n         };\n \n         if let Some(trait_def_id) = trait_def_id {\n-            if trait_def_id.is_local() && !cx.access_levels.is_exported(impl_item.hir_id()) {\n+            if trait_def_id.is_local() && !cx.access_levels.is_exported(impl_item.def_id) {\n                 // If a trait is being implemented for an item, and the\n                 // trait is not exported, we don't need #[inline]\n                 return;"}, {"sha": "0ad616a39d266bf9657b6875a0c05ce793b1348e", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -99,7 +99,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                         if_chain! {\n                             if sig.decl.inputs.is_empty();\n                             if name == sym::new;\n-                            if cx.access_levels.is_reachable(id);\n+                            if cx.access_levels.is_reachable(impl_item.def_id);\n                             let self_def_id = cx.tcx.hir().local_def_id(cx.tcx.hir().get_parent_item(id));\n                             let self_ty = cx.tcx.type_of(self_def_id);\n                             if TyS::same_type(self_ty, return_ty(cx, id));"}, {"sha": "1222a95d4eaa86852021c60f6cac6bf61dd923ba", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -14,6 +14,7 @@ use rustc_hir::{BindingAnnotation, Body, FnDecl, HirId, Impl, ItemKind, MutTy, M\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::{sym, Span};\n use rustc_target::abi::LayoutOf;\n use rustc_target::spec::abi::Abi;\n@@ -134,13 +135,12 @@ impl<'tcx> PassByRefOrValue {\n         }\n     }\n \n-    fn check_poly_fn(&mut self, cx: &LateContext<'tcx>, hir_id: HirId, decl: &FnDecl<'_>, span: Option<Span>) {\n-        if self.avoid_breaking_exported_api && cx.access_levels.is_exported(hir_id) {\n+    fn check_poly_fn(&mut self, cx: &LateContext<'tcx>, def_id: LocalDefId, decl: &FnDecl<'_>, span: Option<Span>) {\n+        if self.avoid_breaking_exported_api && cx.access_levels.is_exported(def_id) {\n             return;\n         }\n-        let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n \n-        let fn_sig = cx.tcx.fn_sig(fn_def_id);\n+        let fn_sig = cx.tcx.fn_sig(def_id);\n         let fn_sig = cx.tcx.erase_late_bound_regions(fn_sig);\n \n         let fn_body = cx.enclosing_body.map(|id| cx.tcx.hir().body(id));\n@@ -231,7 +231,7 @@ impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n         }\n \n         if let hir::TraitItemKind::Fn(method_sig, _) = &item.kind {\n-            self.check_poly_fn(cx, item.hir_id(), &*method_sig.decl, None);\n+            self.check_poly_fn(cx, item.def_id, &*method_sig.decl, None);\n         }\n     }\n \n@@ -278,6 +278,6 @@ impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n             }\n         }\n \n-        self.check_poly_fn(cx, hir_id, decl, Some(span));\n+        self.check_poly_fn(cx, cx.tcx.hir().local_def_id(hir_id), decl, Some(span));\n     }\n }"}, {"sha": "ed2e1f90fa597a76737ddfaf9b38fc7bfd1cebc8", "filename": "src/tools/clippy/clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -41,7 +41,7 @@ impl_lint_pass!(RedundantPubCrate => [REDUNDANT_PUB_CRATE]);\n impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n         if let VisibilityKind::Crate { .. } = item.vis.node {\n-            if !cx.access_levels.is_exported(item.hir_id()) {\n+            if !cx.access_levels.is_exported(item.def_id) {\n                 if let Some(false) = self.is_exported.last() {\n                     let span = item.span.with_hi(item.ident.span.hi());\n                     let descr = cx.tcx.def_kind(item.def_id).descr(item.def_id.to_def_id());\n@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n         }\n \n         if let ItemKind::Mod { .. } = item.kind {\n-            self.is_exported.push(cx.access_levels.is_exported(item.hir_id()));\n+            self.is_exported.push(cx.access_levels.is_exported(item.def_id));\n         }\n     }\n "}, {"sha": "5ca861a14bf2d121ebf180ebc893e00d790bf726", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -81,7 +81,8 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n         // Abort if public function/method or closure.\n         match fn_kind {\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n-                if self.avoid_breaking_exported_api && cx.access_levels.is_exported(hir_id) {\n+                let def_id = cx.tcx.hir().local_def_id(hir_id);\n+                if self.avoid_breaking_exported_api && cx.access_levels.is_exported(def_id) {\n                     return;\n                 }\n             },"}, {"sha": "dbf335a70c83118eee6fcc88f1829ab6e6baffd8", "filename": "src/tools/clippy/clippy_lints/src/upper_case_acronyms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs?ref=bb744e1e9f1e193014ab3f04bf5e0640dbe4dc63", "patch": "@@ -104,7 +104,7 @@ impl LateLintPass<'_> for UpperCaseAcronyms {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &Item<'_>) {\n         // do not lint public items or in macros\n         if in_external_macro(cx.sess(), it.span)\n-            || (self.avoid_breaking_exported_api && cx.access_levels.is_exported(it.hir_id()))\n+            || (self.avoid_breaking_exported_api && cx.access_levels.is_exported(it.def_id))\n         {\n             return;\n         }"}]}