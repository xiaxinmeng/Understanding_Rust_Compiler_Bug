{"sha": "ad8aa185dff457cc18dc38c80d31d348af3d3486", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkOGFhMTg1ZGZmNDU3Y2MxOGRjMzhjODBkMzFkMzQ4YWYzZDM0ODY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-03-22T01:20:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-22T01:20:24Z"}, "message": "Rollup merge of #80771 - thomcc:nonnull-refmut, r=dtolnay\n\nMake NonNull::as_ref (and friends) return refs with unbound lifetimes\n\n# Rationale:\n\n1. The documentation for all of these functions claims that this is what the functions already do, as they all come with this comment:\n\n    > You must enforce Rust's aliasing rules, *since the returned lifetime 'a is arbitrarily chosen* and does not necessarily reflect the actual lifetime of the data...\n\n    So I think it's just a bug that they weren't this way already. Note that had it not been for this part, I wouldn't be making this PR, so if we decide we won't take this change, I'll follow it up with a docs PR to fix this.\n\n2. This is how the equivalent raw pointer functions behave.\n\n    They also take `self` and not `&self`/`&mut self`, but that can't be changed compatibly at this point. This is the next best thing.\n\n3. Without this fix, often code that uses these methods will find it has to expand the lifetime of the result.\n\n    (I can't speak for others but even in unsafe-heavy code, needing to do this unexpectedly is a huge red flag -- if Rust thinks something should have a specific lifetime, I assume it's for a reason)\n\n### Can this cause existing code to be unsound?\n\nI'm confident this can't cause new unsoundness since the reference exists for at most its lifetime, but you get a borrow checker error if you do something that would require/allow the reference to exist past its lifetime.\n\nAdditionally, the aliasing rules of a reference only applies while the reference exists.\n\nThis *must* be the case, as it is required by the rules used by safe code. (That said, the documentation in this file sort of contradicts it, but I think it's just ambiguity between the lifetime `'a` in `&'a T` and lifetime of the `&'a T` reference itself...)\n\nWe are increasing the lifetime of these references, but they should already have hard bounds on that lifetime, or they'd have borrow checker errors.\n\n(CC ``@RalfJung`` because I have gone and done the mistake where I say something definitive about aliasing in Rust which is honestly outside the group of things I should make definitive comments about).\n\n# Caveats\n\n1. This is insta-stable (except for on the unstable functions ofc). I don't think there's any other alternative.\n\n2. I don't believe this is a breaking change in practice. In theory someone could be assigning `NonNull::as_ref` to a function pointer of type `fn(&NonNull<T>) -> &T`. Now they'd need to use a slightly different function pointer type which is (probably) incompatible. This seems pathological, but I guess crater could be used if there are concerns.\n\n3. This has no tests. The old version didn't either that I saw. I could add some stuff that fails to compile without it, if that would be useful.\n\n4. Sometimes the NLL borrow checker gives up and decides lifetimes live till the end of the scope, as opposed to the range where they're used. If this change can cause this to happen more, then my soundness rationale is wrong, and it's likely breaking.\n\n    In practice this seems super unlikely.\n\nAnyway. That was a lot of typing.\n\nFixes https://github.com/rust-lang/rust/issues/80183", "tree": {"sha": "1c6d87c5f58fa67febb17283904c35be2cd37cfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c6d87c5f58fa67febb17283904c35be2cd37cfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad8aa185dff457cc18dc38c80d31d348af3d3486", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgV/DZCRBK7hj4Ov3rIwAAdHIIADkmvlcu2HPz0vkNjP+P6Jzn\nn9CZbS4cUo5Ani87SzoDXOSGoPmvsbRDfCdFWRlfa2EVQMoNH6iaGEYGGYN9dRAS\nHRvplI87M0i+Gm9RM21AaDH9rlIUrGgQxspXx11sOVQki/+2qBAcjnUWCDtkEMTv\nMJ1Mgn9mQSILcru3fJZlReHRlhsbMg9l/I4+pAh6/5CvDFAwmjaq2tnpSxujZN7r\nlhVTdVbRFjXJAvGpaD7HNn6A+QPiOvcnKMpcw+TYzAF40Gsa7G1WuHWNQDYfU8Qz\nO0CzNEDyCo6Nlqr6KgsjHRK/PtapGewfWGPyBmuBJeqfc4Njed1YsTsHqQSdJOM=\n=1ECr\n-----END PGP SIGNATURE-----\n", "payload": "tree 1c6d87c5f58fa67febb17283904c35be2cd37cfd\nparent e9398bcc4d7dd3b5ccdd705dc4ba8d29bbb96354\nparent cce258b2b2e5f96367044fb85c04e35dda449dbe\nauthor Dylan DPC <dylan.dpc@gmail.com> 1616376024 +0100\ncommitter GitHub <noreply@github.com> 1616376024 +0100\n\nRollup merge of #80771 - thomcc:nonnull-refmut, r=dtolnay\n\nMake NonNull::as_ref (and friends) return refs with unbound lifetimes\n\n# Rationale:\n\n1. The documentation for all of these functions claims that this is what the functions already do, as they all come with this comment:\n\n    > You must enforce Rust's aliasing rules, *since the returned lifetime 'a is arbitrarily chosen* and does not necessarily reflect the actual lifetime of the data...\n\n    So I think it's just a bug that they weren't this way already. Note that had it not been for this part, I wouldn't be making this PR, so if we decide we won't take this change, I'll follow it up with a docs PR to fix this.\n\n2. This is how the equivalent raw pointer functions behave.\n\n    They also take `self` and not `&self`/`&mut self`, but that can't be changed compatibly at this point. This is the next best thing.\n\n3. Without this fix, often code that uses these methods will find it has to expand the lifetime of the result.\n\n    (I can't speak for others but even in unsafe-heavy code, needing to do this unexpectedly is a huge red flag -- if Rust thinks something should have a specific lifetime, I assume it's for a reason)\n\n### Can this cause existing code to be unsound?\n\nI'm confident this can't cause new unsoundness since the reference exists for at most its lifetime, but you get a borrow checker error if you do something that would require/allow the reference to exist past its lifetime.\n\nAdditionally, the aliasing rules of a reference only applies while the reference exists.\n\nThis *must* be the case, as it is required by the rules used by safe code. (That said, the documentation in this file sort of contradicts it, but I think it's just ambiguity between the lifetime `'a` in `&'a T` and lifetime of the `&'a T` reference itself...)\n\nWe are increasing the lifetime of these references, but they should already have hard bounds on that lifetime, or they'd have borrow checker errors.\n\n(CC ``@RalfJung`` because I have gone and done the mistake where I say something definitive about aliasing in Rust which is honestly outside the group of things I should make definitive comments about).\n\n# Caveats\n\n1. This is insta-stable (except for on the unstable functions ofc). I don't think there's any other alternative.\n\n2. I don't believe this is a breaking change in practice. In theory someone could be assigning `NonNull::as_ref` to a function pointer of type `fn(&NonNull<T>) -> &T`. Now they'd need to use a slightly different function pointer type which is (probably) incompatible. This seems pathological, but I guess crater could be used if there are concerns.\n\n3. This has no tests. The old version didn't either that I saw. I could add some stuff that fails to compile without it, if that would be useful.\n\n4. Sometimes the NLL borrow checker gives up and decides lifetimes live till the end of the scope, as opposed to the range where they're used. If this change can cause this to happen more, then my soundness rationale is wrong, and it's likely breaking.\n\n    In practice this seems super unlikely.\n\nAnyway. That was a lot of typing.\n\nFixes https://github.com/rust-lang/rust/issues/80183\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad8aa185dff457cc18dc38c80d31d348af3d3486", "html_url": "https://github.com/rust-lang/rust/commit/ad8aa185dff457cc18dc38c80d31d348af3d3486", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad8aa185dff457cc18dc38c80d31d348af3d3486/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9398bcc4d7dd3b5ccdd705dc4ba8d29bbb96354", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9398bcc4d7dd3b5ccdd705dc4ba8d29bbb96354", "html_url": "https://github.com/rust-lang/rust/commit/e9398bcc4d7dd3b5ccdd705dc4ba8d29bbb96354"}, {"sha": "cce258b2b2e5f96367044fb85c04e35dda449dbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/cce258b2b2e5f96367044fb85c04e35dda449dbe", "html_url": "https://github.com/rust-lang/rust/commit/cce258b2b2e5f96367044fb85c04e35dda449dbe"}], "stats": {"total": 12, "additions": 6, "deletions": 6}, "files": [{"sha": "83b88ffd91694d3a4462dcc0cde08dc5ca912c67", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad8aa185dff457cc18dc38c80d31d348af3d3486/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8aa185dff457cc18dc38c80d31d348af3d3486/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=ad8aa185dff457cc18dc38c80d31d348af3d3486", "patch": "@@ -110,7 +110,7 @@ impl<T: Sized> NonNull<T> {\n     /// [the module documentation]: crate::ptr#safety\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_ref(&self) -> &MaybeUninit<T> {\n+    pub unsafe fn as_uninit_ref<'a>(&self) -> &'a MaybeUninit<T> {\n         // SAFETY: the caller must guarantee that `self` meets all the\n         // requirements for a reference.\n         unsafe { &*self.cast().as_ptr() }\n@@ -142,7 +142,7 @@ impl<T: Sized> NonNull<T> {\n     /// [the module documentation]: crate::ptr#safety\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_mut(&mut self) -> &mut MaybeUninit<T> {\n+    pub unsafe fn as_uninit_mut<'a>(&mut self) -> &'a mut MaybeUninit<T> {\n         // SAFETY: the caller must guarantee that `self` meets all the\n         // requirements for a reference.\n         unsafe { &mut *self.cast().as_ptr() }\n@@ -244,7 +244,7 @@ impl<T: ?Sized> NonNull<T> {\n     /// [the module documentation]: crate::ptr#safety\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n-    pub unsafe fn as_ref(&self) -> &T {\n+    pub unsafe fn as_ref<'a>(&self) -> &'a T {\n         // SAFETY: the caller must guarantee that `self` meets all the\n         // requirements for a reference.\n         unsafe { &*self.as_ptr() }\n@@ -280,7 +280,7 @@ impl<T: ?Sized> NonNull<T> {\n     /// [the module documentation]: crate::ptr#safety\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n-    pub unsafe fn as_mut(&mut self) -> &mut T {\n+    pub unsafe fn as_mut<'a>(&mut self) -> &'a mut T {\n         // SAFETY: the caller must guarantee that `self` meets all the\n         // requirements for a mutable reference.\n         unsafe { &mut *self.as_ptr() }\n@@ -427,7 +427,7 @@ impl<T> NonNull<[T]> {\n     /// [valid]: crate::ptr#safety\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_slice(&self) -> &[MaybeUninit<T>] {\n+    pub unsafe fn as_uninit_slice<'a>(&self) -> &'a [MaybeUninit<T>] {\n         // SAFETY: the caller must uphold the safety contract for `as_uninit_slice`.\n         unsafe { slice::from_raw_parts(self.cast().as_ptr(), self.len()) }\n     }\n@@ -488,7 +488,7 @@ impl<T> NonNull<[T]> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n-    pub unsafe fn as_uninit_slice_mut(&self) -> &mut [MaybeUninit<T>] {\n+    pub unsafe fn as_uninit_slice_mut<'a>(&self) -> &'a mut [MaybeUninit<T>] {\n         // SAFETY: the caller must uphold the safety contract for `as_uninit_slice_mut`.\n         unsafe { slice::from_raw_parts_mut(self.cast().as_ptr(), self.len()) }\n     }"}]}