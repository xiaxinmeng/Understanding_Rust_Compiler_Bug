{"sha": "d1fc7368c858a8280f2463e81e074a2c699b0819", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxZmM3MzY4Yzg1OGE4MjgwZjI0NjNlODFlMDc0YTJjNjk5YjA4MTk=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-15T03:21:39Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-15T17:22:50Z"}, "message": "Enable multiple condvars on a single mutex/rwlock.", "tree": {"sha": "a7d023c9d9c042793fe4aa24a48f6a8e6a142641", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7d023c9d9c042793fe4aa24a48f6a8e6a142641"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1fc7368c858a8280f2463e81e074a2c699b0819", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1fc7368c858a8280f2463e81e074a2c699b0819", "html_url": "https://github.com/rust-lang/rust/commit/d1fc7368c858a8280f2463e81e074a2c699b0819", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1fc7368c858a8280f2463e81e074a2c699b0819/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6f9333d5cafc4317f6e470d2ef59587e19af0a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f9333d5cafc4317f6e470d2ef59587e19af0a7", "html_url": "https://github.com/rust-lang/rust/commit/f6f9333d5cafc4317f6e470d2ef59587e19af0a7"}], "stats": {"total": 210, "additions": 172, "deletions": 38}, "files": [{"sha": "c8a16b58d32dd14499f199fb5024390a1a3502a2", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 172, "deletions": 38, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/d1fc7368c858a8280f2463e81e074a2c699b0819/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1fc7368c858a8280f2463e81e074a2c699b0819/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=d1fc7368c858a8280f2463e81e074a2c699b0819", "patch": "@@ -67,9 +67,13 @@ fn new_sem<Q: send>(count: int, +q: Q) -> sem<Q> {\n         waiters: waitqueue { head: wait_head, tail: wait_tail },\n         blocked: q }))\n }\n-fn new_sem_and_signal(count: int) -> sem<waitqueue> {\n-    let (block_tail, block_head) = pipes::stream();\n-    new_sem(count, waitqueue { head: block_head, tail: block_tail })\n+fn new_sem_and_signal(count: int, num_condvars: uint) -> sem<~[waitqueue]> {\n+    let mut queues = ~[];\n+    for num_condvars.times {\n+        let (block_tail, block_head) = pipes::stream();\n+        vec::push(queues, waitqueue { head: block_head, tail: block_tail });\n+    }\n+    new_sem(count, queues)\n }\n \n impl<Q: send> &sem<Q> {\n@@ -119,7 +123,7 @@ impl &sem<()> {\n         blk()\n     }\n }\n-impl &sem<waitqueue> {\n+impl &sem<~[waitqueue]> {\n     fn access<U>(blk: fn() -> U) -> U {\n         let mut release = none;\n         unsafe {\n@@ -139,52 +143,75 @@ struct sem_release {\n     drop { self.sem.release(); }\n }\n struct sem_and_signal_release {\n-    sem: &sem<waitqueue>;\n-    new(sem: &sem<waitqueue>) { self.sem = sem; }\n+    sem: &sem<~[waitqueue]>;\n+    new(sem: &sem<~[waitqueue]>) { self.sem = sem; }\n     drop { self.sem.release(); }\n }\n \n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-struct condvar { priv sem: &sem<waitqueue>; drop { } }\n+struct condvar { priv sem: &sem<~[waitqueue]>; drop { } }\n \n impl &condvar {\n     /// Atomically drop the associated lock, and block until a signal is sent.\n-    fn wait() {\n+    fn wait() { self.wait_on(0) }\n+    /**\n+     * As wait(), but can specify which of multiple condition variables to\n+     * wait on. Only a signal_on() or broadcast_on() with the same condvar_id\n+     * will wake this thread.\n+     *\n+     * The associated lock must have been initialised with an appropriate\n+     * number of condvars. The condvar_id must be between 0 and num_condvars-1\n+     * or else this call will fail.\n+     *\n+     * wait() is equivalent to wait_on(0).\n+     */\n+    fn wait_on(condvar_id: uint) {\n         // Create waiter nobe.\n         let (signal_end, wait_end) = pipes::oneshot();\n+        let mut wait_end   = some(wait_end);\n         let mut signal_end = some(signal_end);\n         let mut reacquire = none;\n+        let mut out_of_bounds = none;\n         unsafe {\n             do task::unkillable {\n+                // Release lock, 'atomically' enqueuing ourselves in so doing.\n+                do (**self.sem).with |state| {\n+                    if condvar_id < vec::len(state.blocked) {\n+                        // Drop the lock.\n+                        state.count += 1;\n+                        if state.count <= 0 {\n+                            signal_waitqueue(&state.waiters);\n+                        }\n+                        // Enqueue ourself to be woken up by a signaller.\n+                        let signal_end = option::swap_unwrap(&mut signal_end);\n+                        state.blocked[condvar_id].tail.send(signal_end);\n+                    } else {\n+                        out_of_bounds = some(vec::len(state.blocked));\n+                    }\n+                }\n+\n                 // If yield checks start getting inserted anywhere, we can be\n                 // killed before or after enqueueing. Deciding whether to\n                 // unkillably reacquire the lock needs to happen atomically\n                 // wrt enqueuing.\n-                reacquire = some(sem_and_signal_reacquire(self.sem));\n-\n-                // Release lock, 'atomically' enqueuing ourselves in so doing.\n-                do (**self.sem).with |state| {\n-                    // Drop the lock.\n-                    state.count += 1;\n-                    if state.count <= 0 {\n-                        signal_waitqueue(&state.waiters);\n-                    }\n-                    // Enqueue ourself to be woken up by a signaller.\n-                    let signal_end = option::swap_unwrap(&mut signal_end);\n-                    state.blocked.tail.send(signal_end);\n+                if out_of_bounds.is_none() {\n+                    reacquire = some(sem_and_signal_reacquire(self.sem));\n                 }\n             }\n         }\n-        // Unconditionally \"block\". (Might not actually block if a signaller\n-        // did send -- I mean 'unconditionally' in contrast with acquire().)\n-        let _ = pipes::recv_one(wait_end);\n+        do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.wait_on()\") {\n+            // Unconditionally \"block\". (Might not actually block if a\n+            // signaller already sent -- I mean 'unconditionally' in contrast\n+            // with acquire().)\n+            let _ = pipes::recv_one(option::swap_unwrap(&mut wait_end));\n+        }\n \n         // This is needed for a failing condition variable to reacquire the\n         // mutex during unwinding. As long as the wrapper (mutex, etc) is\n         // bounded in when it gets released, this shouldn't hang forever.\n         struct sem_and_signal_reacquire {\n-            sem: &sem<waitqueue>;\n-            new(sem: &sem<waitqueue>) { self.sem = sem; }\n+            sem: &sem<~[waitqueue]>;\n+            new(sem: &sem<~[waitqueue]>) { self.sem = sem; }\n             drop unsafe {\n                 // Needs to succeed, instead of itself dying.\n                 do task::unkillable {\n@@ -195,26 +222,64 @@ impl &condvar {\n     }\n \n     /// Wake up a blocked task. Returns false if there was no blocked task.\n-    fn signal() -> bool {\n+    fn signal() -> bool { self.signal_on(0) }\n+    /// As signal, but with a specified condvar_id. See wait_on.\n+    fn signal_on(condvar_id: uint) -> bool {\n+        let mut out_of_bounds = none;\n+        let mut result = false;\n         unsafe {\n             do (**self.sem).with |state| {\n-                signal_waitqueue(&state.blocked)\n+                if condvar_id < vec::len(state.blocked) {\n+                    result = signal_waitqueue(&state.blocked[condvar_id]);\n+                } else {\n+                    out_of_bounds = some(vec::len(state.blocked));\n+                }\n             }\n         }\n+        do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n+            result\n+        }\n     }\n \n     /// Wake up all blocked tasks. Returns the number of tasks woken.\n-    fn broadcast() -> uint {\n+    fn broadcast() -> uint { self.broadcast_on(0) }\n+    /// As broadcast, but with a specified condvar_id. See wait_on.\n+    fn broadcast_on(condvar_id: uint) -> uint {\n+        let mut out_of_bounds = none;\n+        let mut result = 0;\n         unsafe {\n             do (**self.sem).with |state| {\n-                // FIXME(#3145) fix :broadcast_heavy\n-                broadcast_waitqueue(&state.blocked)\n+                if condvar_id < vec::len(state.blocked) {\n+                    // FIXME(#3145) fix :broadcast_heavy\n+                    result = broadcast_waitqueue(&state.blocked[condvar_id])\n+                } else {\n+                    out_of_bounds = some(vec::len(state.blocked));\n+                }\n             }\n         }\n+        do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n+            result\n+        }\n+    }\n+}\n+\n+// Checks whether a condvar ID was out of bounds, and fails if so, or does\n+// something else next on success.\n+#[inline(always)]\n+fn check_cvar_bounds<U>(out_of_bounds: option<uint>, id: uint, act: &str,\n+                        blk: fn() -> U) -> U {\n+    match out_of_bounds {\n+        some(0) =>\n+            fail fmt!(\"%s with illegal ID %u - this lock has no condvars!\",\n+                      act, id),\n+        some(length) =>\n+            fail fmt!(\"%s with illegal ID %u - ID must be less than %u\",\n+                      act, id, length),\n+        none => blk()\n     }\n }\n \n-impl &sem<waitqueue> {\n+impl &sem<~[waitqueue]> {\n     // The only other place that condvars get built is rwlock_write_mode.\n     fn access_cond<U>(blk: fn(c: &condvar) -> U) -> U {\n         do self.access { blk(&condvar { sem: self }) }\n@@ -263,10 +328,19 @@ impl &semaphore {\n  * FIFO condition variable.\n  * FIXME(#3145): document killability\n  */\n-struct mutex { priv sem: sem<waitqueue>; }\n+struct mutex { priv sem: sem<~[waitqueue]>; }\n \n-/// Create a new mutex.\n-fn mutex() -> mutex { mutex { sem: new_sem_and_signal(1) } }\n+/// Create a new mutex, with one associated condvar.\n+fn mutex() -> mutex { mutex_with_condvars(1) }\n+/**\n+ * Create a new mutex, with a specified number of associated condvars. This\n+ * will allow calling wait_on/signal_on/broadcast_on with condvar IDs between\n+ * 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be allowed but\n+ * any operations on the condvar will fail.)\n+ */\n+fn mutex_with_condvars(num_condvars: uint) -> mutex {\n+    mutex { sem: new_sem_and_signal(1, num_condvars) }\n+}\n \n impl &mutex {\n     /// Create a new handle to the mutex.\n@@ -295,13 +369,20 @@ struct rwlock_inner {\n /// A blocking, no-starvation, reader-writer lock with an associated condvar.\n struct rwlock {\n     /* priv */ order_lock:  semaphore;\n-    /* priv */ access_lock: sem<waitqueue>;\n+    /* priv */ access_lock: sem<~[waitqueue]>;\n     /* priv */ state:       Exclusive<rwlock_inner>;\n }\n \n-/// Create a new rwlock.\n-fn rwlock() -> rwlock {\n-    rwlock { order_lock: semaphore(1), access_lock: new_sem_and_signal(1),\n+/// Create a new rwlock, with one associated condvar.\n+fn rwlock() -> rwlock { rwlock_with_condvars(1) }\n+\n+/**\n+ * Create a new rwlock, with a specified number of associated condvars.\n+ * Similar to mutex_with_condvars.\n+ */\n+fn rwlock_with_condvars(num_condvars: uint) -> rwlock {\n+    rwlock { order_lock: semaphore(1),\n+             access_lock: new_sem_and_signal(1, num_condvars),\n              state: exclusive(rwlock_inner { read_mode:  false,\n                                              read_count: 0 }) }\n }\n@@ -813,6 +894,59 @@ mod tests {\n             drop { self.c.send(()); }\n         }\n     }\n+    #[test]\n+    fn test_mutex_cond_signal_on_0() {\n+        // Tests that signal_on(0) is equivalent to signal().\n+        let m = ~mutex();\n+        do m.lock_cond |cond| {\n+            let m2 = ~m.clone();\n+            do task::spawn {\n+                do m2.lock_cond |cond| {\n+                    cond.signal_on(0);\n+                }\n+            }\n+            cond.wait();\n+        }\n+    }\n+    #[test] #[ignore(cfg(windows))]\n+    fn test_mutex_different_conds() {\n+        let result = do task::try {\n+            let m = ~mutex_with_condvars(2);\n+            let m2 = ~m.clone();\n+            let (c,p) = pipes::stream();\n+            do task::spawn {\n+                do m2.lock_cond |cond| {\n+                    c.send(());\n+                    cond.wait_on(1);\n+                }\n+            }\n+            let _ = p.recv();\n+            do m.lock_cond |cond| {\n+                if !cond.signal_on(0) {\n+                    fail; // success; punt sibling awake.\n+                }\n+            }\n+        };\n+        assert result.is_err();\n+    }\n+    #[test] #[ignore(cfg(windows))]\n+    fn test_mutex_no_condvars() {\n+        let result = do task::try {\n+            let m = ~mutex_with_condvars(0);\n+            do m.lock_cond |cond| { cond.wait(); }\n+        };\n+        assert result.is_err();\n+        let result = do task::try {\n+            let m = ~mutex_with_condvars(0);\n+            do m.lock_cond |cond| { cond.signal(); }\n+        };\n+        assert result.is_err();\n+        let result = do task::try {\n+            let m = ~mutex_with_condvars(0);\n+            do m.lock_cond |cond| { cond.broadcast(); }\n+        };\n+        assert result.is_err();\n+    }\n     /************************************************************************\n      * Reader/writer lock tests\n      ************************************************************************/"}]}