{"sha": "24d4f10ab20ce9f38e7c2154679487533c95c640", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZDRmMTBhYjIwY2U5ZjM4ZTdjMjE1NDY3OTQ4NzUzM2M5NWM2NDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-21T12:29:50Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-31T23:58:44Z"}, "message": "change to use `higher_ranked_match`\n\nalso, consolidate the return type into from a tuple into a struct\n`Progress`", "tree": {"sha": "8990b87586eb309668be10c7392d9b95a1c1e641", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8990b87586eb309668be10c7392d9b95a1c1e641"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24d4f10ab20ce9f38e7c2154679487533c95c640", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24d4f10ab20ce9f38e7c2154679487533c95c640", "html_url": "https://github.com/rust-lang/rust/commit/24d4f10ab20ce9f38e7c2154679487533c95c640", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24d4f10ab20ce9f38e7c2154679487533c95c640/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21eb36608e5ff53a250afe5b7443606ab96c429a", "url": "https://api.github.com/repos/rust-lang/rust/commits/21eb36608e5ff53a250afe5b7443606ab96c429a", "html_url": "https://github.com/rust-lang/rust/commit/21eb36608e5ff53a250afe5b7443606ab96c429a"}], "stats": {"total": 150, "additions": 90, "deletions": 60}, "files": [{"sha": "4dbee6ffa79d998e697acc28e8c7e1a81c3872b9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24d4f10ab20ce9f38e7c2154679487533c95c640/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d4f10ab20ce9f38e7c2154679487533c95c640/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=24d4f10ab20ce9f38e7c2154679487533c95c640", "patch": "@@ -1619,7 +1619,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                            origin: TypeOrigin,\n                                            match_a: ty::PolyProjectionPredicate<'tcx>,\n                                            match_b: ty::TraitRef<'tcx>)\n-                                           -> RelateResult<HrMatchResult<Ty<'tcx>>>\n+                                           -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>>\n     {\n         let span = origin.span();\n         let match_trait_ref = match_a.skip_binder().projection_ty.trait_ref;\n@@ -1629,8 +1629,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref, p.ty));\n-        self.combine_fields(true, trace)\n-            .higher_ranked_match(span, &match_pair, &match_b)\n+        let combine = self.combine_fields(true, trace);\n+        let result = combine.higher_ranked_match(span, &match_pair, &match_b)?;\n+        Ok(InferOk { value: result, obligations: combine.obligations })\n     }\n \n     /// See `verify_generic_bound` method in `region_inference`"}, {"sha": "516f1204f6fd24d07eab319e1e144fea81a78fce", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 86, "deletions": 57, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/24d4f10ab20ce9f38e7c2154679487533c95c640/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d4f10ab20ce9f38e7c2154679487533c95c640/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=24d4f10ab20ce9f38e7c2154679487533c95c640", "patch": "@@ -28,6 +28,7 @@ use infer::{self, InferOk, TypeOrigin};\n use ty::subst::Subst;\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n+use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::parse::token;\n use syntax::ast;\n use util::common::FN_OUTPUT_NAME;\n@@ -424,19 +425,25 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n \n     let obligation = Obligation::with_depth(cause.clone(), depth, projection_ty.clone());\n     match project_type(selcx, &obligation) {\n-        Ok(ProjectedTy::Progress(projected_ty, mut obligations)) => {\n+        Ok(ProjectedTy::Progress(Progress { ty: projected_ty,\n+                                            mut obligations,\n+                                            cacheable })) => {\n             // if projection succeeded, then what we get out of this\n             // is also non-normalized (consider: it was derived from\n             // an impl, where-clause etc) and hence we must\n             // re-normalize it\n \n             debug!(\"opt_normalize_projection_type: \\\n-                    projected_ty={:?} depth={} obligations={:?}\",\n+                    projected_ty={:?} \\\n+                    depth={} \\\n+                    obligations={:?} \\\n+                    cacheable={:?}\",\n                    projected_ty,\n                    depth,\n-                   obligations);\n+                   obligations,\n+                   cacheable);\n \n-            if projected_ty.has_projection_types() {\n+            let result = if projected_ty.has_projection_types() {\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth+1);\n                 let normalized_ty = normalizer.fold(&projected_ty);\n \n@@ -455,7 +462,9 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                     value: projected_ty,\n                     obligations: obligations,\n                 })\n-            }\n+            };\n+\n+            result\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n             debug!(\"opt_normalize_projection_type: \\\n@@ -520,11 +529,37 @@ fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tc\n }\n \n enum ProjectedTy<'tcx> {\n-    Progress(Ty<'tcx>, Vec<PredicateObligation<'tcx>>),\n+    Progress(Progress<'tcx>),\n     NoProgress(Ty<'tcx>),\n }\n \n+struct Progress<'tcx> {\n+    ty: Ty<'tcx>,\n+    obligations: Vec<PredicateObligation<'tcx>>,\n+    cacheable: bool,\n+}\n+\n+impl<'tcx> Progress<'tcx> {\n+    fn error<'a,'gcx>(tcx: TyCtxt<'a,'gcx,'tcx>) -> Self {\n+        Progress {\n+            ty: tcx.types.err,\n+            obligations: vec![],\n+            cacheable: true\n+        }\n+    }\n+\n+    fn with_addl_obligations(mut self,\n+                             mut obligations: Vec<PredicateObligation<'tcx>>)\n+                             -> Self {\n+        self.obligations.append(&mut obligations);\n+        self\n+    }\n+}\n+\n /// Compute the result of a projection type (if we can).\n+///\n+/// IMPORTANT:\n+/// - `obligation` must be fully normalized\n fn project_type<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>)\n@@ -539,13 +574,12 @@ fn project_type<'cx, 'gcx, 'tcx>(\n         selcx.infcx().report_overflow_error(&obligation, true);\n     }\n \n-    let obligation_trait_ref =\n-        selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate.trait_ref);\n+    let obligation_trait_ref = &obligation.predicate.trait_ref;\n \n     debug!(\"project: obligation_trait_ref={:?}\", obligation_trait_ref);\n \n     if obligation_trait_ref.references_error() {\n-        return Ok(ProjectedTy::Progress(selcx.tcx().types.err, vec!()));\n+        return Ok(ProjectedTy::Progress(Progress::error(selcx.tcx())));\n     }\n \n     let mut candidates = ProjectionTyCandidateSet {\n@@ -623,16 +657,17 @@ fn project_type<'cx, 'gcx, 'tcx>(\n \n     match candidates.vec.pop() {\n         Some(candidate) => {\n-            let (ty, obligations) = confirm_candidate(selcx,\n-                                                      obligation,\n-                                                      &obligation_trait_ref,\n-                                                      candidate);\n-            Ok(ProjectedTy::Progress(ty, obligations))\n+            Ok(ProjectedTy::Progress(\n+                confirm_candidate(selcx,\n+                                  obligation,\n+                                  &obligation_trait_ref,\n+                                  candidate)))\n         }\n         None => {\n-            Ok(ProjectedTy::NoProgress(selcx.tcx().mk_projection(\n-                obligation.predicate.trait_ref.clone(),\n-                obligation.predicate.item_name)))\n+            Ok(ProjectedTy::NoProgress(\n+                selcx.tcx().mk_projection(\n+                    obligation.predicate.trait_ref.clone(),\n+                    obligation.predicate.item_name)))\n         }\n     }\n }\n@@ -935,7 +970,7 @@ fn confirm_candidate<'cx, 'gcx, 'tcx>(\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate: ProjectionTyCandidate<'tcx>)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     debug!(\"confirm_candidate(candidate={:?}, obligation={:?})\",\n            candidate,\n@@ -957,7 +992,7 @@ fn confirm_select_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n     let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n@@ -995,7 +1030,7 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation:  &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     let self_ty = obligation_trait_ref.self_ty();\n     let object_ty = selcx.infcx().shallow_resolve(self_ty);\n@@ -1007,7 +1042,7 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n             span_bug!(\n                 obligation.cause.span,\n                 \"confirm_object_candidate called with non-object: {:?}\",\n-                object_ty);\n+                object_ty)\n         }\n     };\n     let projection_bounds = data.projection_bounds_with_self_ty(selcx.tcx(), object_ty);\n@@ -1051,7 +1086,7 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n                 debug!(\"confirm_object_candidate: no env-predicate \\\n                         found in object type `{:?}`; ill-formed\",\n                        object_ty);\n-                return (selcx.tcx().types.err, vec!());\n+                return Progress::error(selcx.tcx());\n             }\n         }\n     };\n@@ -1063,7 +1098,7 @@ fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     // FIXME(#32730) drop this assertion once obligations are propagated from inference (fn pointer\n     // vtable nested obligations ONLY come from unification in inference)\n@@ -1077,31 +1112,30 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     let closure_typer = selcx.closure_typer();\n     let closure_type = closure_typer.closure_type(vtable.closure_def_id, vtable.substs);\n     let Normalized {\n         value: closure_type,\n-        mut obligations\n+        obligations\n     } = normalize_with_depth(selcx,\n                              obligation.cause.clone(),\n                              obligation.recursion_depth+1,\n                              &closure_type);\n-    let (ty, mut cc_obligations) = confirm_callable_candidate(selcx,\n-                                                              obligation,\n-                                                              &closure_type.sig,\n-                                                              util::TupleArgumentsFlag::No);\n-    obligations.append(&mut cc_obligations);\n-    (ty, obligations)\n+    confirm_callable_candidate(selcx,\n+                               obligation,\n+                               &closure_type.sig,\n+                               util::TupleArgumentsFlag::No)\n+        .with_addl_obligations(obligations)\n }\n \n fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_sig: &ty::PolyFnSig<'tcx>,\n     flag: util::TupleArgumentsFlag)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     let tcx = selcx.tcx();\n \n@@ -1134,47 +1168,38 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     poly_projection: ty::PolyProjectionPredicate<'tcx>)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     let infcx = selcx.infcx();\n-\n-    let projection =\n-        infcx.replace_late_bound_regions_with_fresh_var(\n-            obligation.cause.span,\n-            infer::LateBoundRegionConversionTime::HigherRankedType,\n-            &poly_projection).0;\n-\n-    assert_eq!(projection.projection_ty.item_name,\n-               obligation.predicate.item_name);\n-\n     let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n-    let obligations = match infcx.eq_trait_refs(false,\n-                                                origin,\n-                                                obligation.predicate.trait_ref.clone(),\n-                                                projection.projection_ty.trait_ref.clone()) {\n-        Ok(InferOk { obligations, .. }) => {\n-            // FIXME(#32730) once obligations are generated in inference, remove this assertion\n+    let trait_ref = obligation.predicate.trait_ref;\n+    match infcx.match_poly_projection_predicate(origin, poly_projection, trait_ref) {\n+        Ok(InferOk { value: ty_match, obligations }) => {\n+            // FIXME(#32730) once obligations are generated in inference, drop this assertion\n             assert!(obligations.is_empty());\n-            obligations\n+            Progress {\n+                ty: ty_match.value,\n+                obligations: obligations,\n+                cacheable: ty_match.unconstrained_regions.is_empty(),\n+            }\n         }\n         Err(e) => {\n             span_bug!(\n                 obligation.cause.span,\n-                \"Failed to unify `{:?}` and `{:?}` in projection: {}\",\n+                \"Failed to unify obligation `{:?}` \\\n+                 with poly_projection `{:?}`: {:?}\",\n                 obligation,\n-                projection,\n+                poly_projection,\n                 e);\n         }\n-    };\n-\n-    (projection.ty, obligations)\n+    }\n }\n \n fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>)\n-    -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n {\n     let VtableImplData { substs, nested, impl_def_id } = impl_vtable;\n \n@@ -1195,7 +1220,11 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n                 tcx.types.err\n             });\n             let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n-            (ty.subst(tcx, substs), nested)\n+            Progress {\n+                ty: ty.subst(tcx, substs),\n+                obligations: nested,\n+                cacheable: true\n+            }\n         }\n         None => {\n             span_bug!(obligation.cause.span,"}]}