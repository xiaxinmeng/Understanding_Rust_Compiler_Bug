{"sha": "8a10440641f7ec89236b1f40129738426ad4d702", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMTA0NDA2NDFmN2VjODkyMzZiMWY0MDEyOTczODQyNmFkNGQ3MDI=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-21T17:00:33Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-21T17:24:38Z"}, "message": "utils: add match_type() helper function\n\nwhich saves one level of matching when checking for type paths", "tree": {"sha": "573b3d0b15b843c27a5b477f3957dec97f03ec62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/573b3d0b15b843c27a5b477f3957dec97f03ec62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a10440641f7ec89236b1f40129738426ad4d702", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a10440641f7ec89236b1f40129738426ad4d702", "html_url": "https://github.com/rust-lang/rust/commit/8a10440641f7ec89236b1f40129738426ad4d702", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a10440641f7ec89236b1f40129738426ad4d702/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a437936d49081faa82227c7d216ff3b0d6363ed3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a437936d49081faa82227c7d216ff3b0d6363ed3", "html_url": "https://github.com/rust-lang/rust/commit/a437936d49081faa82227c7d216ff3b0d6363ed3"}], "stats": {"total": 116, "additions": 53, "deletions": 63}, "files": [{"sha": "df8e35d98fbcc14c19bf1166e0f60669d88bba7a", "filename": "src/methods.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8a10440641f7ec89236b1f40129738426ad4d702/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a10440641f7ec89236b1f40129738426ad4d702/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=8a10440641f7ec89236b1f40129738426ad4d702", "patch": "@@ -2,7 +2,7 @@ use syntax::ast::*;\n use rustc::lint::*;\n use rustc::middle::ty;\n \n-use utils::{span_lint, match_def_path, walk_ptrs_ty};\n+use utils::{span_lint, match_type, walk_ptrs_ty};\n use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n \n #[derive(Copy,Clone)]\n@@ -24,31 +24,24 @@ impl LintPass for MethodsPass {\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n         if let ExprMethodCall(ref ident, _, ref args) = expr.node {\n-            let ref obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(&*args[0])).sty;\n+            let obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(&*args[0]));\n             if ident.node.name == \"unwrap\" {\n-                if let ty::TyEnum(did, _) = *obj_ty {\n-                    if match_def_path(cx, did.did, &OPTION_PATH) {\n-                        span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n-                                  \"used unwrap() on an Option value. If you don't want \\\n-                                   to handle the None case gracefully, consider using\n-                                   expect() to provide a better panic message\");\n-                    }\n-                    else if match_def_path(cx, did.did, &RESULT_PATH) {\n-                        span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n-                                  \"used unwrap() on a Result value. Graceful handling \\\n-                                   of Err values is preferred\");\n-                    }\n+                if match_type(cx, obj_ty, &OPTION_PATH) {\n+                    span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n+                              \"used unwrap() on an Option value. If you don't want \\\n+                               to handle the None case gracefully, consider using \\\n+                               expect() to provide a better panic message\");\n+                } else if match_type(cx, obj_ty, &RESULT_PATH) {\n+                    span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n+                              \"used unwrap() on a Result value. Graceful handling \\\n+                               of Err values is preferred\");\n                 }\n             }\n             else if ident.node.name == \"to_string\" {\n-                if let ty::TyStr = *obj_ty {\n+                if obj_ty.sty == ty::TyStr {\n                     span_lint(cx, STR_TO_STRING, expr.span, \"`str.to_owned()` is faster\");\n-                }\n-                else if let ty::TyStruct(did, _) = *obj_ty {\n-                    if match_def_path(cx, did.did, &STRING_PATH) {\n-                        span_lint(cx, STRING_TO_STRING, expr.span,\n-                                  \"`String.to_string()` is a no-op\")\n-                    }\n+                } else if match_type(cx, obj_ty, &STRING_PATH) {\n+                    span_lint(cx, STRING_TO_STRING, expr.span, \"`String.to_string()` is a no-op\");\n                 }\n             }\n         }"}, {"sha": "f0a0592f5e2c5ad9c8b642ec0cc0243318d137d6", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8a10440641f7ec89236b1f40129738426ad4d702/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a10440641f7ec89236b1f40129738426ad4d702/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=8a10440641f7ec89236b1f40129738426ad4d702", "patch": "@@ -6,7 +6,7 @@ use rustc::lint::*;\n use syntax::ast::*;\n use rustc::middle::ty;\n \n-use utils::{span_lint, match_def_path};\n+use utils::{span_lint, match_type};\n use utils::{STRING_PATH, VEC_PATH};\n \n declare_lint! {\n@@ -50,18 +50,15 @@ fn check_fn(cx: &Context, decl: &FnDecl) {\n         }\n         let ref sty = cx.tcx.pat_ty(&*arg.pat).sty;\n         if let &ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = sty {\n-            if let ty::TyStruct(did, _) = ty.sty {\n-                if match_def_path(cx, did.did, &VEC_PATH) {\n-                    span_lint(cx, PTR_ARG, arg.ty.span,\n-                              \"writing `&Vec<_>` instead of `&[_]` involves one more reference \\\n-                               and cannot be used with non-Vec-based slices. Consider changing \\\n-                               the type to `&[...]`\");\n-                }\n-                else if match_def_path(cx, did.did, &STRING_PATH) {\n-                    span_lint(cx, PTR_ARG, arg.ty.span,\n-                              \"writing `&String` instead of `&str` involves a new object \\\n-                               where a slice will do. Consider changing the type to `&str`\");\n-                }\n+            if match_type(cx, ty, &VEC_PATH) {\n+                span_lint(cx, PTR_ARG, arg.ty.span,\n+                          \"writing `&Vec<_>` instead of `&[_]` involves one more reference \\\n+                           and cannot be used with non-Vec-based slices. Consider changing \\\n+                           the type to `&[...]`\");\n+            } else if match_type(cx, ty, &STRING_PATH) {\n+                span_lint(cx, PTR_ARG, arg.ty.span,\n+                          \"writing `&String` instead of `&str` involves a new object \\\n+                           where a slice will do. Consider changing the type to `&str`\");\n             }\n         }\n     }"}, {"sha": "d1a0a7e702e4ba0d63e4b40e034a48566f8dee88", "filename": "src/ranges.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a10440641f7ec89236b1f40129738426ad4d702/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a10440641f7ec89236b1f40129738426ad4d702/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=8a10440641f7ec89236b1f40129738426ad4d702", "patch": "@@ -1,8 +1,7 @@\n use rustc::lint::{Context, LintArray, LintPass};\n-use rustc::middle::ty::TypeVariants::TyStruct;\n use syntax::ast::*;\n use syntax::codemap::Spanned;\n-use utils::{match_def_path};\n+use utils::match_type;\n \n declare_lint! {\n     pub RANGE_STEP_BY_ZERO, Warn,\n@@ -34,11 +33,9 @@ impl LintPass for StepByZero {\n fn is_range(cx: &Context, expr: &Expr) -> bool {\n     // No need for walk_ptrs_ty here because step_by moves self, so it\n     // can't be called on a borrowed range.\n-    if let TyStruct(did, _) = cx.tcx.expr_ty(expr).sty {\n-        // Note: RangeTo and RangeFull don't have step_by\n-        match_def_path(cx, did.did, &[\"core\", \"ops\", \"Range\"]) ||\n-        match_def_path(cx, did.did, &[\"core\", \"ops\", \"RangeFrom\"])\n-    } else { false }\n+    let ty = cx.tcx.expr_ty(expr);\n+    // Note: RangeTo and RangeFull don't have step_by\n+    match_type(cx, ty, &[\"core\", \"ops\", \"Range\"]) || match_type(cx, ty, &[\"core\", \"ops\", \"RangeFrom\"])\n }\n \n fn is_lit_zero(expr: &Expr) -> bool {"}, {"sha": "64d18eeb26d5b897b4dc25cc8400b47227fa2d2b", "filename": "src/strings.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a10440641f7ec89236b1f40129738426ad4d702/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a10440641f7ec89236b1f40129738426ad4d702/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=8a10440641f7ec89236b1f40129738426ad4d702", "patch": "@@ -4,12 +4,11 @@\n //! disable the subsumed lint unless it has a higher level\n \n use rustc::lint::*;\n-use rustc::middle::ty::TypeVariants::TyStruct;\n use syntax::ast::*;\n use syntax::codemap::Spanned;\n \n use eq_op::is_exp_equal;\n-use utils::{match_def_path, span_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n use utils::STRING_PATH;\n \n declare_lint! {\n@@ -62,10 +61,7 @@ impl LintPass for StringAdd {\n }\n \n fn is_string(cx: &Context, e: &Expr) -> bool {\n-    let ty = walk_ptrs_ty(cx.tcx.expr_ty(e));\n-    if let TyStruct(did, _) = ty.sty {\n-        match_def_path(cx, did.did, &STRING_PATH)\n-    } else { false }\n+    match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(e)), &STRING_PATH)\n }\n \n fn is_add(cx: &Context, src: &Expr, target: &Expr) -> bool {"}, {"sha": "622f733f8122c809793c2f4f7058d06ef9dedc2d", "filename": "src/types.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8a10440641f7ec89236b1f40129738426ad4d702/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a10440641f7ec89236b1f40129738426ad4d702/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=8a10440641f7ec89236b1f40129738426ad4d702", "patch": "@@ -5,7 +5,7 @@ use syntax::ast_util::{is_comparison_binop, binop_to_string};\n use rustc::middle::ty;\n use syntax::codemap::ExpnInfo;\n \n-use utils::{in_macro, match_def_path, snippet, span_lint, span_help_and_lint, in_external_macro};\n+use utils::{in_macro, match_type, snippet, span_lint, span_help_and_lint, in_external_macro};\n use utils::{LL_PATH, VEC_PATH};\n \n /// Handles all the linting of funky types\n@@ -26,24 +26,19 @@ impl LintPass for TypePass {\n     fn check_ty(&mut self, cx: &Context, ast_ty: &ast::Ty) {\n         if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n             if let ty::TyBox(ref inner) = ty.sty {\n-                if let ty::TyStruct(did, _) = inner.sty {\n-                    if match_def_path(cx, did.did, &VEC_PATH) {\n-                        span_help_and_lint(\n-                            cx, BOX_VEC, ast_ty.span,\n-                            \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n-                            \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\");\n-                    }\n-                }\n-            }\n-            if let ty::TyStruct(did, _) = ty.sty {\n-                if match_def_path(cx, did.did, &LL_PATH) {\n+                if match_type(cx, inner, &VEC_PATH) {\n                     span_help_and_lint(\n-                        cx, LINKEDLIST, ast_ty.span,\n-                        \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                        \"a RingBuf might work\");\n-                    return;\n+                        cx, BOX_VEC, ast_ty.span,\n+                        \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n+                        \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\");\n                 }\n             }\n+            else if match_type(cx, ty, &LL_PATH) {\n+                span_help_and_lint(\n+                    cx, LINKEDLIST, ast_ty.span,\n+                    \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n+                    \"a RingBuf might work\");\n+            }\n         }\n     }\n }"}, {"sha": "4fd36fb91d4174b32f75aee5ae61c2c0edbfbba2", "filename": "src/utils.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a10440641f7ec89236b1f40129738426ad4d702/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a10440641f7ec89236b1f40129738426ad4d702/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=8a10440641f7ec89236b1f40129738426ad4d702", "patch": "@@ -44,6 +44,18 @@ pub fn match_def_path(cx: &Context, def_id: DefId, path: &[&str]) -> bool {\n         .zip(path.iter()).all(|(nm, p)| nm == p))\n }\n \n+/// check if type is struct or enum type with given def path\n+pub fn match_type(cx: &Context, ty: ty::Ty, path: &[&str]) -> bool {\n+    match ty.sty {\n+        ty::TyEnum(ref adt, _) | ty::TyStruct(ref adt, _) => {\n+            match_def_path(cx, adt.did, path)\n+        }\n+        _ => {\n+            false\n+        }\n+    }\n+}\n+\n /// match a Path against a slice of segment string literals, e.g.\n /// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {"}]}