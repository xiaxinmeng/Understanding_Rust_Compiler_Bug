{"sha": "6132111f87a6891db28ce37909607034c228f7a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMzIxMTFmODdhNjg5MWRiMjhjZTM3OTA5NjA3MDM0YzIyOGY3YTk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-09T12:45:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-09T12:45:24Z"}, "message": "Merge #5281\n\n5281: Remove insta from ra_ide r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "364b2e0662bb9fe7b0d4af4e933c62cac596d772", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/364b2e0662bb9fe7b0d4af4e933c62cac596d772"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6132111f87a6891db28ce37909607034c228f7a9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfBxFkCRBK7hj4Ov3rIwAAdHIIAGgBG8lpZHJQfq2e1zKZj0C0\nRLUJG6fWAeSsqyyBu1fBr0L1+6R/rdObhaVFXxZ6vLFfMvC/nPD6QcT+0Ur3924X\nsH4hIKM+3jUWXmvqxAr8Ic65BAOgN5w/arWX6aQpwGySxSD5Zxv5y7vrh8J4gkKa\nP4ZJsrxIBX7m6C67wB8Bbo3pL8O5z05fiE5W9kIxR1NwJtD8LBp6HEljyUzRmhHv\necO9i0QGU2O/u3VaPy026aG9K2GuWJKHGy7RI5eiSafFXhckhilu2ELJNUeTQfen\nyaZIVJK/L1/OjHygIDijkpCcADUGJ62bLViCBGYOouM1SuEwkPTv7urnJ7tWn0g=\n=bErG\n-----END PGP SIGNATURE-----\n", "payload": "tree 364b2e0662bb9fe7b0d4af4e933c62cac596d772\nparent 7566d7da8ab035a286f82a60b8e2c679158bc56c\nparent 117392e879f2732aacd029189de844bda286df2c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1594298724 +0000\ncommitter GitHub <noreply@github.com> 1594298724 +0000\n\nMerge #5281\n\n5281: Remove insta from ra_ide r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6132111f87a6891db28ce37909607034c228f7a9", "html_url": "https://github.com/rust-lang/rust/commit/6132111f87a6891db28ce37909607034c228f7a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6132111f87a6891db28ce37909607034c228f7a9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7566d7da8ab035a286f82a60b8e2c679158bc56c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7566d7da8ab035a286f82a60b8e2c679158bc56c", "html_url": "https://github.com/rust-lang/rust/commit/7566d7da8ab035a286f82a60b8e2c679158bc56c"}, {"sha": "117392e879f2732aacd029189de844bda286df2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/117392e879f2732aacd029189de844bda286df2c", "html_url": "https://github.com/rust-lang/rust/commit/117392e879f2732aacd029189de844bda286df2c"}], "stats": {"total": 706, "additions": 282, "deletions": 424}, "files": [{"sha": "84ca3344ced4226a7630ba6d927e275d0ca346f1", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6132111f87a6891db28ce37909607034c228f7a9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6132111f87a6891db28ce37909607034c228f7a9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6132111f87a6891db28ce37909607034c228f7a9", "patch": "@@ -1127,7 +1127,6 @@ dependencies = [\n  \"either\",\n  \"expect\",\n  \"indexmap\",\n- \"insta\",\n  \"itertools\",\n  \"log\",\n  \"ra_assists\","}, {"sha": "df2fad520142b2bfdb970722c08142b5514b3d79", "filename": "crates/ra_ide/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6132111f87a6891db28ce37909607034c228f7a9/crates%2Fra_ide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6132111f87a6891db28ce37909607034c228f7a9/crates%2Fra_ide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2FCargo.toml?ref=6132111f87a6891db28ce37909607034c228f7a9", "patch": "@@ -36,5 +36,4 @@ ra_ssr = { path = \"../ra_ssr\" }\n hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n \n [dev-dependencies]\n-insta = \"0.16.0\"\n expect = { path = \"../expect\" }"}, {"sha": "00f6bb18649da15a1193725427613f6adcecbbae", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 274, "deletions": 410, "changes": 684, "blob_url": "https://github.com/rust-lang/rust/blob/6132111f87a6891db28ce37909607034c228f7a9/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6132111f87a6891db28ce37909607034c228f7a9/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=6132111f87a6891db28ce37909607034c228f7a9", "patch": "@@ -281,53 +281,21 @@ fn check_struct_shorthand_initialization(\n \n #[cfg(test)]\n mod tests {\n-    use insta::assert_debug_snapshot;\n-    use ra_syntax::SourceFile;\n     use stdx::trim_indent;\n     use test_utils::assert_eq_text;\n \n-    use crate::mock_analysis::{analysis_and_position, single_file};\n-\n-    use super::*;\n-\n-    type DiagnosticChecker = fn(&mut Vec<Diagnostic>, FileId, &SyntaxNode) -> Option<()>;\n-\n-    fn check_not_applicable(code: &str, func: DiagnosticChecker) {\n-        let parse = SourceFile::parse(code);\n-        let mut diagnostics = Vec::new();\n-        for node in parse.tree().syntax().descendants() {\n-            func(&mut diagnostics, FileId(0), &node);\n-        }\n-        assert!(diagnostics.is_empty());\n-    }\n-\n-    fn check_apply(before: &str, after: &str, func: DiagnosticChecker) {\n-        let parse = SourceFile::parse(before);\n-        let mut diagnostics = Vec::new();\n-        for node in parse.tree().syntax().descendants() {\n-            func(&mut diagnostics, FileId(0), &node);\n-        }\n-        let diagnostic =\n-            diagnostics.pop().unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));\n-        let mut fix = diagnostic.fix.unwrap();\n-        let edit = fix.source_change.source_file_edits.pop().unwrap().edit;\n-        let actual = {\n-            let mut actual = before.to_string();\n-            edit.apply(&mut actual);\n-            actual\n-        };\n-        assert_eq_text!(after, &actual);\n-    }\n+    use crate::mock_analysis::{analysis_and_position, single_file, MockAnalysis};\n+    use expect::{expect, Expect};\n \n     /// Takes a multi-file input fixture with annotated cursor positions,\n     /// and checks that:\n     ///  * a diagnostic is produced\n     ///  * this diagnostic touches the input cursor position\n     ///  * that the contents of the file containing the cursor match `after` after the diagnostic fix is applied\n-    fn check_apply_diagnostic_fix_from_position(ra_fixture: &str, after: &str) {\n-        let after = trim_indent(after);\n+    fn check_fix(ra_fixture_before: &str, ra_fixture_after: &str) {\n+        let after = trim_indent(ra_fixture_after);\n \n-        let (analysis, file_position) = analysis_and_position(ra_fixture);\n+        let (analysis, file_position) = analysis_and_position(ra_fixture_before);\n         let diagnostic = analysis.diagnostics(file_position.file_id).unwrap().pop().unwrap();\n         let mut fix = diagnostic.fix.unwrap();\n         let edit = fix.source_change.source_file_edits.pop().unwrap().edit;\n@@ -348,284 +316,251 @@ mod tests {\n         );\n     }\n \n-    fn check_apply_diagnostic_fix(ra_fixture_before: &str, ra_fixture_after: &str) {\n-        let ra_fixture_after = &trim_indent(ra_fixture_after);\n-        let (analysis, file_id) = single_file(ra_fixture_before);\n-        let before = analysis.file_text(file_id).unwrap();\n-        let diagnostic = analysis.diagnostics(file_id).unwrap().pop().unwrap();\n-        let mut fix = diagnostic.fix.unwrap();\n-        let edit = fix.source_change.source_file_edits.pop().unwrap().edit;\n-        let actual = {\n-            let mut actual = before.to_string();\n-            edit.apply(&mut actual);\n-            actual\n-        };\n-        assert_eq_text!(ra_fixture_after, &actual);\n-    }\n-\n     /// Takes a multi-file input fixture with annotated cursor position and checks that no diagnostics\n     /// apply to the file containing the cursor.\n-    fn check_no_diagnostic_for_target_file(ra_fixture: &str) {\n-        let (analysis, file_position) = analysis_and_position(ra_fixture);\n-        let diagnostics = analysis.diagnostics(file_position.file_id).unwrap();\n-        assert_eq!(diagnostics.len(), 0);\n-    }\n-\n-    fn check_no_diagnostic(ra_fixture: &str) {\n+    fn check_no_diagnostics(ra_fixture: &str) {\n+        let mock = MockAnalysis::with_files(ra_fixture);\n+        let files = mock.files().map(|(it, _)| it).collect::<Vec<_>>();\n+        let analysis = mock.analysis();\n+        let diagnostics = files\n+            .into_iter()\n+            .flat_map(|file_id| analysis.diagnostics(file_id).unwrap())\n+            .collect::<Vec<_>>();\n+        assert_eq!(diagnostics.len(), 0, \"unexpected diagnostics:\\n{:#?}\", diagnostics);\n+    }\n+\n+    fn check_expect(ra_fixture: &str, expect: Expect) {\n         let (analysis, file_id) = single_file(ra_fixture);\n         let diagnostics = analysis.diagnostics(file_id).unwrap();\n-        assert_eq!(diagnostics.len(), 0, \"expected no diagnostic, found one\");\n+        expect.assert_debug_eq(&diagnostics)\n     }\n \n     #[test]\n     fn test_wrap_return_type() {\n-        let before = r#\"\n-            //- /main.rs\n-            use core::result::Result::{self, Ok, Err};\n-\n-            fn div(x: i32, y: i32) -> Result<i32, ()> {\n-                if y == 0 {\n-                    return Err(());\n-                }\n-                x / y<|>\n-            }\n-            //- /core/lib.rs\n-            pub mod result {\n-                pub enum Result<T, E> { Ok(T), Err(E) }\n-            }\n-        \"#;\n-        let after = r#\"\n-            use core::result::Result::{self, Ok, Err};\n-\n-            fn div(x: i32, y: i32) -> Result<i32, ()> {\n-                if y == 0 {\n-                    return Err(());\n-                }\n-                Ok(x / y)\n-            }\n-        \"#;\n-        check_apply_diagnostic_fix_from_position(before, after);\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+use core::result::Result::{self, Ok, Err};\n+\n+fn div(x: i32, y: i32) -> Result<i32, ()> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    x / y<|>\n+}\n+//- /core/lib.rs\n+pub mod result {\n+    pub enum Result<T, E> { Ok(T), Err(E) }\n+}\n+\"#,\n+            r#\"\n+use core::result::Result::{self, Ok, Err};\n+\n+fn div(x: i32, y: i32) -> Result<i32, ()> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    Ok(x / y)\n+}\n+\"#,\n+        );\n     }\n \n     #[test]\n     fn test_wrap_return_type_handles_generic_functions() {\n-        let before = r#\"\n-            //- /main.rs\n-            use core::result::Result::{self, Ok, Err};\n-\n-            fn div<T>(x: T) -> Result<T, i32> {\n-                if x == 0 {\n-                    return Err(7);\n-                }\n-                <|>x\n-            }\n-            //- /core/lib.rs\n-            pub mod result {\n-                pub enum Result<T, E> { Ok(T), Err(E) }\n-            }\n-        \"#;\n-        let after = r#\"\n-            use core::result::Result::{self, Ok, Err};\n-\n-            fn div<T>(x: T) -> Result<T, i32> {\n-                if x == 0 {\n-                    return Err(7);\n-                }\n-                Ok(x)\n-            }\n-        \"#;\n-        check_apply_diagnostic_fix_from_position(before, after);\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+use core::result::Result::{self, Ok, Err};\n+\n+fn div<T>(x: T) -> Result<T, i32> {\n+    if x == 0 {\n+        return Err(7);\n+    }\n+    <|>x\n+}\n+//- /core/lib.rs\n+pub mod result {\n+    pub enum Result<T, E> { Ok(T), Err(E) }\n+}\n+\"#,\n+            r#\"\n+use core::result::Result::{self, Ok, Err};\n+\n+fn div<T>(x: T) -> Result<T, i32> {\n+    if x == 0 {\n+        return Err(7);\n+    }\n+    Ok(x)\n+}\n+\"#,\n+        );\n     }\n \n     #[test]\n     fn test_wrap_return_type_handles_type_aliases() {\n-        let before = r#\"\n-            //- /main.rs\n-            use core::result::Result::{self, Ok, Err};\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+use core::result::Result::{self, Ok, Err};\n \n-            type MyResult<T> = Result<T, ()>;\n+type MyResult<T> = Result<T, ()>;\n \n-            fn div(x: i32, y: i32) -> MyResult<i32> {\n-                if y == 0 {\n-                    return Err(());\n-                }\n-                x <|>/ y\n-            }\n-            //- /core/lib.rs\n-            pub mod result {\n-                pub enum Result<T, E> { Ok(T), Err(E) }\n-            }\n-        \"#;\n-        let after = r#\"\n-            use core::result::Result::{self, Ok, Err};\n+fn div(x: i32, y: i32) -> MyResult<i32> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    x <|>/ y\n+}\n+//- /core/lib.rs\n+pub mod result {\n+    pub enum Result<T, E> { Ok(T), Err(E) }\n+}\n+\"#,\n+            r#\"\n+use core::result::Result::{self, Ok, Err};\n \n-            type MyResult<T> = Result<T, ()>;\n+type MyResult<T> = Result<T, ()>;\n \n-            fn div(x: i32, y: i32) -> MyResult<i32> {\n-                if y == 0 {\n-                    return Err(());\n-                }\n-                Ok(x / y)\n-            }\n-        \"#;\n-        check_apply_diagnostic_fix_from_position(before, after);\n+fn div(x: i32, y: i32) -> MyResult<i32> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    Ok(x / y)\n+}\n+\"#,\n+        );\n     }\n \n     #[test]\n     fn test_wrap_return_type_not_applicable_when_expr_type_does_not_match_ok_type() {\n-        check_no_diagnostic_for_target_file(\n-            r\"\n-            //- /main.rs\n-            use core::result::Result::{self, Ok, Err};\n+        check_no_diagnostics(\n+            r#\"\n+//- /main.rs\n+use core::result::Result::{self, Ok, Err};\n \n-            fn foo() -> Result<(), i32> {\n-                0<|>\n-            }\n+fn foo() -> Result<(), i32> { 0 }\n \n-            //- /core/lib.rs\n-            pub mod result {\n-                pub enum Result<T, E> { Ok(T), Err(E) }\n-            }\n-        \",\n+//- /core/lib.rs\n+pub mod result {\n+    pub enum Result<T, E> { Ok(T), Err(E) }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn test_wrap_return_type_not_applicable_when_return_type_is_not_result() {\n-        check_no_diagnostic_for_target_file(\n-            r\"\n-            //- /main.rs\n-            use core::result::Result::{self, Ok, Err};\n+        check_no_diagnostics(\n+            r#\"\n+//- /main.rs\n+use core::result::Result::{self, Ok, Err};\n \n-            enum SomeOtherEnum {\n-                Ok(i32),\n-                Err(String),\n-            }\n+enum SomeOtherEnum { Ok(i32), Err(String) }\n \n-            fn foo() -> SomeOtherEnum {\n-                0<|>\n-            }\n+fn foo() -> SomeOtherEnum { 0 }\n \n-            //- /core/lib.rs\n-            pub mod result {\n-                pub enum Result<T, E> { Ok(T), Err(E) }\n-            }\n-        \",\n+//- /core/lib.rs\n+pub mod result {\n+    pub enum Result<T, E> { Ok(T), Err(E) }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn test_fill_struct_fields_empty() {\n-        let before = r\"\n-            struct TestStruct {\n-                one: i32,\n-                two: i64,\n-            }\n+        check_fix(\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n \n-            fn test_fn() {\n-                let s = TestStruct{};\n-            }\n-        \";\n-        let after = r\"\n-            struct TestStruct {\n-                one: i32,\n-                two: i64,\n-            }\n+fn test_fn() {\n+    let s = TestStruct {<|>};\n+}\n+\"#,\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n \n-            fn test_fn() {\n-                let s = TestStruct{ one: (), two: ()};\n-            }\n-        \";\n-        check_apply_diagnostic_fix(before, after);\n+fn test_fn() {\n+    let s = TestStruct { one: (), two: ()};\n+}\n+\"#,\n+        );\n     }\n \n     #[test]\n     fn test_fill_struct_fields_self() {\n-        let before = r\"\n-            struct TestStruct {\n-                one: i32,\n-            }\n+        check_fix(\n+            r#\"\n+struct TestStruct { one: i32 }\n \n-            impl TestStruct {\n-                fn test_fn() {\n-                    let s = Self {};\n-                }\n-            }\n-        \";\n-        let after = r\"\n-            struct TestStruct {\n-                one: i32,\n-            }\n+impl TestStruct {\n+    fn test_fn() { let s = Self {<|>}; }\n+}\n+\"#,\n+            r#\"\n+struct TestStruct { one: i32 }\n \n-            impl TestStruct {\n-                fn test_fn() {\n-                    let s = Self { one: ()};\n-                }\n-            }\n-        \";\n-        check_apply_diagnostic_fix(before, after);\n+impl TestStruct {\n+    fn test_fn() { let s = Self { one: ()}; }\n+}\n+\"#,\n+        );\n     }\n \n     #[test]\n     fn test_fill_struct_fields_enum() {\n-        let before = r\"\n-            enum Expr {\n-                Bin { lhs: Box<Expr>, rhs: Box<Expr> }\n-            }\n+        check_fix(\n+            r#\"\n+enum Expr {\n+    Bin { lhs: Box<Expr>, rhs: Box<Expr> }\n+}\n \n-            impl Expr {\n-                fn new_bin(lhs: Box<Expr>, rhs: Box<Expr>) -> Expr {\n-                    Expr::Bin { }\n-                }\n-            }\n-        \";\n-        let after = r\"\n-            enum Expr {\n-                Bin { lhs: Box<Expr>, rhs: Box<Expr> }\n-            }\n+impl Expr {\n+    fn new_bin(lhs: Box<Expr>, rhs: Box<Expr>) -> Expr {\n+        Expr::Bin {<|> }\n+    }\n+}\n+\"#,\n+            r#\"\n+enum Expr {\n+    Bin { lhs: Box<Expr>, rhs: Box<Expr> }\n+}\n \n-            impl Expr {\n-                fn new_bin(lhs: Box<Expr>, rhs: Box<Expr>) -> Expr {\n-                    Expr::Bin { lhs: (), rhs: () }\n-                }\n-            }\n-        \";\n-        check_apply_diagnostic_fix(before, after);\n+impl Expr {\n+    fn new_bin(lhs: Box<Expr>, rhs: Box<Expr>) -> Expr {\n+        Expr::Bin { lhs: (), rhs: () }\n+    }\n+}\n+\"#,\n+        );\n     }\n \n     #[test]\n     fn test_fill_struct_fields_partial() {\n-        let before = r\"\n-            struct TestStruct {\n-                one: i32,\n-                two: i64,\n-            }\n+        check_fix(\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n \n-            fn test_fn() {\n-                let s = TestStruct{ two: 2 };\n-            }\n-        \";\n-        let after = r\"\n-            struct TestStruct {\n-                one: i32,\n-                two: i64,\n-            }\n+fn test_fn() {\n+    let s = TestStruct{ two: 2<|> };\n+}\n+\"#,\n+            r\"\n+struct TestStruct { one: i32, two: i64 }\n \n-            fn test_fn() {\n-                let s = TestStruct{ two: 2, one: () };\n-            }\n-        \";\n-        check_apply_diagnostic_fix(before, after);\n+fn test_fn() {\n+    let s = TestStruct{ two: 2, one: () };\n+}\n+\",\n+        );\n     }\n \n     #[test]\n     fn test_fill_struct_fields_no_diagnostic() {\n-        check_no_diagnostic(\n+        check_no_diagnostics(\n             r\"\n-            struct TestStruct {\n-                one: i32,\n-                two: i64,\n-            }\n+            struct TestStruct { one: i32, two: i64 }\n \n             fn test_fn() {\n                 let one = 1;\n@@ -637,12 +572,9 @@ mod tests {\n \n     #[test]\n     fn test_fill_struct_fields_no_diagnostic_on_spread() {\n-        check_no_diagnostic(\n+        check_no_diagnostics(\n             r\"\n-            struct TestStruct {\n-                one: i32,\n-                two: i64,\n-            }\n+            struct TestStruct { one: i32, two: i64 }\n \n             fn test_fn() {\n                 let one = 1;\n@@ -654,211 +586,143 @@ mod tests {\n \n     #[test]\n     fn test_unresolved_module_diagnostic() {\n-        let (analysis, file_id) = single_file(\"mod foo;\");\n-        let diagnostics = analysis.diagnostics(file_id).unwrap();\n-        assert_debug_snapshot!(diagnostics, @r###\"\n-        [\n-            Diagnostic {\n-                message: \"unresolved module\",\n-                range: 0..8,\n-                severity: Error,\n-                fix: Some(\n-                    Fix {\n-                        label: \"Create module\",\n-                        source_change: SourceChange {\n-                            source_file_edits: [],\n-                            file_system_edits: [\n-                                CreateFile {\n-                                    anchor: FileId(\n-                                        1,\n-                                    ),\n-                                    dst: \"foo.rs\",\n+        check_expect(\n+            r#\"mod foo;\"#,\n+            expect![[r#\"\n+                [\n+                    Diagnostic {\n+                        message: \"unresolved module\",\n+                        range: 0..8,\n+                        severity: Error,\n+                        fix: Some(\n+                            Fix {\n+                                label: \"Create module\",\n+                                source_change: SourceChange {\n+                                    source_file_edits: [],\n+                                    file_system_edits: [\n+                                        CreateFile {\n+                                            anchor: FileId(\n+                                                1,\n+                                            ),\n+                                            dst: \"foo.rs\",\n+                                        },\n+                                    ],\n+                                    is_snippet: false,\n                                 },\n-                            ],\n-                            is_snippet: false,\n-                        },\n+                            },\n+                        ),\n                     },\n-                ),\n-            },\n-        ]\n-        \"###);\n+                ]\n+            \"#]],\n+        );\n     }\n \n     #[test]\n     fn range_mapping_out_of_macros() {\n-        let (analysis, file_id) = single_file(\n-            r\"\n-            fn some() {}\n-            fn items() {}\n-            fn here() {}\n+        // FIXME: this is very wrong, but somewhat tricky to fix.\n+        check_fix(\n+            r#\"\n+fn some() {}\n+fn items() {}\n+fn here() {}\n \n-            macro_rules! id {\n-                ($($tt:tt)*) => { $($tt)*};\n-            }\n+macro_rules! id { ($($tt:tt)*) => { $($tt)*}; }\n \n-            fn main() {\n-                let _x = id![Foo { a: 42 }];\n-            }\n+fn main() {\n+    let _x = id![Foo { a: <|>42 }];\n+}\n \n-            pub struct Foo {\n-                pub a: i32,\n-                pub b: i32,\n-            }\n-        \",\n+pub struct Foo { pub a: i32, pub b: i32 }\n+\"#,\n+            r#\"\n+fn {a:42, b: ()} {}\n+fn items() {}\n+fn here() {}\n+\n+macro_rules! id { ($($tt:tt)*) => { $($tt)*}; }\n+\n+fn main() {\n+    let _x = id![Foo { a: 42 }];\n+}\n+\n+pub struct Foo { pub a: i32, pub b: i32 }\n+\"#,\n         );\n-        let diagnostics = analysis.diagnostics(file_id).unwrap();\n-        assert_debug_snapshot!(diagnostics, @r###\"\n-        [\n-            Diagnostic {\n-                message: \"Missing structure fields:\\n- b\\n\",\n-                range: 127..136,\n-                severity: Error,\n-                fix: Some(\n-                    Fix {\n-                        label: \"Fill struct fields\",\n-                        source_change: SourceChange {\n-                            source_file_edits: [\n-                                SourceFileEdit {\n-                                    file_id: FileId(\n-                                        1,\n-                                    ),\n-                                    edit: TextEdit {\n-                                        indels: [\n-                                            Indel {\n-                                                insert: \"{a:42, b: ()}\",\n-                                                delete: 3..9,\n-                                            },\n-                                        ],\n-                                    },\n-                                },\n-                            ],\n-                            file_system_edits: [],\n-                            is_snippet: false,\n-                        },\n-                    },\n-                ),\n-            },\n-        ]\n-        \"###);\n     }\n \n     #[test]\n     fn test_check_unnecessary_braces_in_use_statement() {\n-        check_not_applicable(\n-            \"\n-            use a;\n-            use a::{c, d::e};\n-        \",\n-            check_unnecessary_braces_in_use_statement,\n-        );\n-        check_apply(\"use {b};\", \"use b;\", check_unnecessary_braces_in_use_statement);\n-        check_apply(\"use a::{c};\", \"use a::c;\", check_unnecessary_braces_in_use_statement);\n-        check_apply(\"use a::{self};\", \"use a;\", check_unnecessary_braces_in_use_statement);\n-        check_apply(\n-            \"use a::{c, d::{e}};\",\n-            \"use a::{c, d::e};\",\n-            check_unnecessary_braces_in_use_statement,\n+        check_no_diagnostics(\n+            r#\"\n+use a;\n+use a::{c, d::e};\n+\"#,\n         );\n+        check_fix(r#\"use {<|>b};\"#, r#\"use b;\"#);\n+        check_fix(r#\"use {b<|>};\"#, r#\"use b;\"#);\n+        check_fix(r#\"use a::{c<|>};\"#, r#\"use a::c;\"#);\n+        check_fix(r#\"use a::{self<|>};\"#, r#\"use a;\"#);\n+        check_fix(r#\"use a::{c, d::{e<|>}};\"#, r#\"use a::{c, d::e};\"#);\n     }\n \n     #[test]\n     fn test_check_struct_shorthand_initialization() {\n-        check_not_applicable(\n+        check_no_diagnostics(\n             r#\"\n-            struct A {\n-                a: &'static str\n-            }\n-\n-            fn main() {\n-                A {\n-                    a: \"hello\"\n-                }\n-            }\n-        \"#,\n-            check_struct_shorthand_initialization,\n+struct A { a: &'static str }\n+fn main() { A { a: \"hello\" } }\n+\"#,\n         );\n-        check_not_applicable(\n+        check_no_diagnostics(\n             r#\"\n-            struct A(usize);\n-\n-            fn main() {\n-                A {\n-                    0: 0\n-                }\n-            }\n-        \"#,\n-            check_struct_shorthand_initialization,\n+struct A(usize);\n+fn main() { A { 0: 0 } }\n+\"#,\n         );\n \n-        check_apply(\n+        check_fix(\n             r#\"\n-struct A {\n-    a: &'static str\n-}\n-\n+struct A { a: &'static str }\n fn main() {\n     let a = \"haha\";\n-    A {\n-        a: a\n-    }\n+    A { a<|>: a }\n }\n-        \"#,\n+\"#,\n             r#\"\n-struct A {\n-    a: &'static str\n-}\n-\n+struct A { a: &'static str }\n fn main() {\n     let a = \"haha\";\n-    A {\n-        a\n-    }\n+    A { a }\n }\n-        \"#,\n-            check_struct_shorthand_initialization,\n+\"#,\n         );\n \n-        check_apply(\n+        check_fix(\n             r#\"\n-struct A {\n-    a: &'static str,\n-    b: &'static str\n-}\n-\n+struct A { a: &'static str, b: &'static str }\n fn main() {\n     let a = \"haha\";\n     let b = \"bb\";\n-    A {\n-        a: a,\n-        b\n-    }\n+    A { a<|>: a, b }\n }\n-        \"#,\n+\"#,\n             r#\"\n-struct A {\n-    a: &'static str,\n-    b: &'static str\n-}\n-\n+struct A { a: &'static str, b: &'static str }\n fn main() {\n     let a = \"haha\";\n     let b = \"bb\";\n-    A {\n-        a,\n-        b\n-    }\n+    A { a, b }\n }\n-        \"#,\n-            check_struct_shorthand_initialization,\n+\"#,\n         );\n     }\n \n     #[test]\n     fn test_add_field_from_usage() {\n-        check_apply_diagnostic_fix(\n+        check_fix(\n             r\"\n fn main() {\n-    Foo { bar: 3, baz: false};\n+    Foo { bar: 3, baz<|>: false};\n }\n struct Foo {\n     bar: i32"}, {"sha": "b28054688783dc49e4befbdcc1d722f583d7e58e", "filename": "crates/ra_ide/src/mock_analysis.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6132111f87a6891db28ce37909607034c228f7a9/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6132111f87a6891db28ce37909607034c228f7a9/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmock_analysis.rs?ref=6132111f87a6891db28ce37909607034c228f7a9", "patch": "@@ -71,27 +71,23 @@ impl MockAnalysis {\n     }\n \n     pub fn id_of(&self, path: &str) -> FileId {\n-        let (idx, _) = self\n-            .files\n-            .iter()\n-            .enumerate()\n-            .find(|(_, data)| path == data.path)\n-            .expect(\"no file in this mock\");\n-        FileId(idx as u32 + 1)\n+        let (file_id, _) =\n+            self.files().find(|(_, data)| path == data.path).expect(\"no file in this mock\");\n+        file_id\n     }\n     pub fn annotations(&self) -> Vec<(FileRange, String)> {\n-        self.files\n-            .iter()\n-            .enumerate()\n-            .flat_map(|(idx, fixture)| {\n-                let file_id = FileId(idx as u32 + 1);\n+        self.files()\n+            .flat_map(|(file_id, fixture)| {\n                 let annotations = extract_annotations(&fixture.text);\n                 annotations\n                     .into_iter()\n                     .map(move |(range, data)| (FileRange { file_id, range }, data))\n             })\n             .collect()\n     }\n+    pub fn files(&self) -> impl Iterator<Item = (FileId, &Fixture)> + '_ {\n+        self.files.iter().enumerate().map(|(idx, fixture)| (FileId(idx as u32 + 1), fixture))\n+    }\n     pub fn annotation(&self) -> (FileRange, String) {\n         let mut all = self.annotations();\n         assert_eq!(all.len(), 1);"}]}