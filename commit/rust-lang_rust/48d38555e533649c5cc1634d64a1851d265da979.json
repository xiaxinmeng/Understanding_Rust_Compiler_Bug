{"sha": "48d38555e533649c5cc1634d64a1851d265da979", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZDM4NTU1ZTUzMzY0OWM1Y2MxNjM0ZDY0YTE4NTFkMjY1ZGE5Nzk=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-12-03T22:43:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-12-03T22:43:50Z"}, "message": "Rollup merge of #46473 - frewsxcv:frewsxcv-param-name, r=TimNN\n\nConsistent parameter name for numeric \u2018checked\u2019 operations.\n\nSome checked operations use `rhs` as a parameter name, and some use\n`other`. For the sake of consistency, unify everything under the `rhs`\nname.\n\nFixes https://github.com/rust-lang/rust/issues/46308.", "tree": {"sha": "9c058b0c4e8abc4e05df0d9be8fe02eea727b7a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c058b0c4e8abc4e05df0d9be8fe02eea727b7a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48d38555e533649c5cc1634d64a1851d265da979", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48d38555e533649c5cc1634d64a1851d265da979", "html_url": "https://github.com/rust-lang/rust/commit/48d38555e533649c5cc1634d64a1851d265da979", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48d38555e533649c5cc1634d64a1851d265da979/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "909a8de9530c5ade8d1b5ec0298e4075e6a672cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/909a8de9530c5ade8d1b5ec0298e4075e6a672cd", "html_url": "https://github.com/rust-lang/rust/commit/909a8de9530c5ade8d1b5ec0298e4075e6a672cd"}, {"sha": "a2d87d83bfdffe3d9ba78c93d5da2b39148b01e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2d87d83bfdffe3d9ba78c93d5da2b39148b01e1", "html_url": "https://github.com/rust-lang/rust/commit/a2d87d83bfdffe3d9ba78c93d5da2b39148b01e1"}], "stats": {"total": 138, "additions": 69, "deletions": 69}, "files": [{"sha": "7c7562eac5152e6de9a88c907ea40a0ccd37cc96", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/48d38555e533649c5cc1634d64a1851d265da979/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d38555e533649c5cc1634d64a1851d265da979/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=48d38555e533649c5cc1634d64a1851d265da979", "patch": "@@ -380,7 +380,7 @@ macro_rules! int_impl {\n             if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n         }\n \n-        /// Checked integer addition. Computes `self + other`, returning `None`\n+        /// Checked integer addition. Computes `self + rhs`, returning `None`\n         /// if overflow occurred.\n         ///\n         /// # Examples\n@@ -393,12 +393,12 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_add(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_add(other);\n+        pub fn checked_add(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_add(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer subtraction. Computes `self - other`, returning\n+        /// Checked integer subtraction. Computes `self - rhs`, returning\n         /// `None` if underflow occurred.\n         ///\n         /// # Examples\n@@ -411,12 +411,12 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_sub(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_sub(other);\n+        pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_sub(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer multiplication. Computes `self * other`, returning\n+        /// Checked integer multiplication. Computes `self * rhs`, returning\n         /// `None` if underflow or overflow occurred.\n         ///\n         /// # Examples\n@@ -429,13 +429,13 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_mul(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_mul(other);\n+        pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_mul(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer division. Computes `self / other`, returning `None`\n-        /// if `other == 0` or the operation results in underflow or overflow.\n+        /// Checked integer division. Computes `self / rhs`, returning `None`\n+        /// if `rhs == 0` or the operation results in underflow or overflow.\n         ///\n         /// # Examples\n         ///\n@@ -448,16 +448,16 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_div(self, other: Self) -> Option<Self> {\n-            if other == 0 || (self == Self::min_value() && other == -1) {\n+        pub fn checked_div(self, rhs: Self) -> Option<Self> {\n+            if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                 None\n             } else {\n-                Some(unsafe { intrinsics::unchecked_div(self, other) })\n+                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n             }\n         }\n \n-        /// Checked integer remainder. Computes `self % other`, returning `None`\n-        /// if `other == 0` or the operation results in underflow or overflow.\n+        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n+        /// if `rhs == 0` or the operation results in underflow or overflow.\n         ///\n         /// # Examples\n         ///\n@@ -472,11 +472,11 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n-        pub fn checked_rem(self, other: Self) -> Option<Self> {\n-            if other == 0 || (self == Self::min_value() && other == -1) {\n+        pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n+            if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                 None\n             } else {\n-                Some(unsafe { intrinsics::unchecked_rem(self, other) })\n+                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n             }\n         }\n \n@@ -559,7 +559,7 @@ macro_rules! int_impl {\n             }\n         }\n \n-        /// Saturating integer addition. Computes `self + other`, saturating at\n+        /// Saturating integer addition. Computes `self + rhs`, saturating at\n         /// the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -572,15 +572,15 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_add(self, other: Self) -> Self {\n-            match self.checked_add(other) {\n+        pub fn saturating_add(self, rhs: Self) -> Self {\n+            match self.checked_add(rhs) {\n                 Some(x) => x,\n-                None if other >= 0 => Self::max_value(),\n+                None if rhs >= 0 => Self::max_value(),\n                 None => Self::min_value(),\n             }\n         }\n \n-        /// Saturating integer subtraction. Computes `self - other`, saturating\n+        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n         /// at the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -593,15 +593,15 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_sub(self, other: Self) -> Self {\n-            match self.checked_sub(other) {\n+        pub fn saturating_sub(self, rhs: Self) -> Self {\n+            match self.checked_sub(rhs) {\n                 Some(x) => x,\n-                None if other >= 0 => Self::min_value(),\n+                None if rhs >= 0 => Self::min_value(),\n                 None => Self::max_value(),\n             }\n         }\n \n-        /// Saturating integer multiplication. Computes `self * other`,\n+        /// Saturating integer multiplication. Computes `self * rhs`,\n         /// saturating at the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -617,17 +617,17 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n-        pub fn saturating_mul(self, other: Self) -> Self {\n-            self.checked_mul(other).unwrap_or_else(|| {\n-                if (self < 0 && other < 0) || (self > 0 && other > 0) {\n+        pub fn saturating_mul(self, rhs: Self) -> Self {\n+            self.checked_mul(rhs).unwrap_or_else(|| {\n+                if (self < 0 && rhs < 0) || (self > 0 && rhs > 0) {\n                     Self::max_value()\n                 } else {\n                     Self::min_value()\n                 }\n             })\n         }\n \n-        /// Wrapping (modular) addition. Computes `self + other`,\n+        /// Wrapping (modular) addition. Computes `self + rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n@@ -646,7 +646,7 @@ macro_rules! int_impl {\n             }\n         }\n \n-        /// Wrapping (modular) subtraction. Computes `self - other`,\n+        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n@@ -666,7 +666,7 @@ macro_rules! int_impl {\n         }\n \n         /// Wrapping (modular) multiplication. Computes `self *\n-        /// other`, wrapping around at the boundary of the type.\n+        /// rhs`, wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n         ///\n@@ -684,7 +684,7 @@ macro_rules! int_impl {\n             }\n         }\n \n-        /// Wrapping (modular) division. Computes `self / other`,\n+        /// Wrapping (modular) division. Computes `self / rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// The only case where such wrapping can occur is when one\n@@ -712,7 +712,7 @@ macro_rules! int_impl {\n             self.overflowing_div(rhs).0\n         }\n \n-        /// Wrapping (modular) remainder. Computes `self % other`,\n+        /// Wrapping (modular) remainder. Computes `self % rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// Such wrap-around never actually occurs mathematically;\n@@ -1573,7 +1573,7 @@ macro_rules! uint_impl {\n             if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n         }\n \n-        /// Checked integer addition. Computes `self + other`, returning `None`\n+        /// Checked integer addition. Computes `self + rhs`, returning `None`\n         /// if overflow occurred.\n         ///\n         /// # Examples\n@@ -1586,12 +1586,12 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_add(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_add(other);\n+        pub fn checked_add(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_add(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer subtraction. Computes `self - other`, returning\n+        /// Checked integer subtraction. Computes `self - rhs`, returning\n         /// `None` if underflow occurred.\n         ///\n         /// # Examples\n@@ -1604,12 +1604,12 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_sub(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_sub(other);\n+        pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_sub(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer multiplication. Computes `self * other`, returning\n+        /// Checked integer multiplication. Computes `self * rhs`, returning\n         /// `None` if underflow or overflow occurred.\n         ///\n         /// # Examples\n@@ -1622,13 +1622,13 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_mul(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_mul(other);\n+        pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_mul(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer division. Computes `self / other`, returning `None`\n-        /// if `other == 0` or the operation results in underflow or overflow.\n+        /// Checked integer division. Computes `self / rhs`, returning `None`\n+        /// if `rhs == 0` or the operation results in underflow or overflow.\n         ///\n         /// # Examples\n         ///\n@@ -1640,15 +1640,15 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_div(self, other: Self) -> Option<Self> {\n-            match other {\n+        pub fn checked_div(self, rhs: Self) -> Option<Self> {\n+            match rhs {\n                 0 => None,\n-                other => Some(unsafe { intrinsics::unchecked_div(self, other) }),\n+                rhs => Some(unsafe { intrinsics::unchecked_div(self, rhs) }),\n             }\n         }\n \n-        /// Checked integer remainder. Computes `self % other`, returning `None`\n-        /// if `other == 0` or the operation results in underflow or overflow.\n+        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n+        /// if `rhs == 0` or the operation results in underflow or overflow.\n         ///\n         /// # Examples\n         ///\n@@ -1660,11 +1660,11 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n-        pub fn checked_rem(self, other: Self) -> Option<Self> {\n-            if other == 0 {\n+        pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n+            if rhs == 0 {\n                 None\n             } else {\n-                Some(unsafe { intrinsics::unchecked_rem(self, other) })\n+                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n             }\n         }\n \n@@ -1724,7 +1724,7 @@ macro_rules! uint_impl {\n             if b {None} else {Some(a)}\n         }\n \n-        /// Saturating integer addition. Computes `self + other`, saturating at\n+        /// Saturating integer addition. Computes `self + rhs`, saturating at\n         /// the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -1737,14 +1737,14 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_add(self, other: Self) -> Self {\n-            match self.checked_add(other) {\n+        pub fn saturating_add(self, rhs: Self) -> Self {\n+            match self.checked_add(rhs) {\n                 Some(x) => x,\n                 None => Self::max_value(),\n             }\n         }\n \n-        /// Saturating integer subtraction. Computes `self - other`, saturating\n+        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n         /// at the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -1757,14 +1757,14 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_sub(self, other: Self) -> Self {\n-            match self.checked_sub(other) {\n+        pub fn saturating_sub(self, rhs: Self) -> Self {\n+            match self.checked_sub(rhs) {\n                 Some(x) => x,\n                 None => Self::min_value(),\n             }\n         }\n \n-        /// Saturating integer multiplication. Computes `self * other`,\n+        /// Saturating integer multiplication. Computes `self * rhs`,\n         /// saturating at the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -1779,11 +1779,11 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n-        pub fn saturating_mul(self, other: Self) -> Self {\n-            self.checked_mul(other).unwrap_or(Self::max_value())\n+        pub fn saturating_mul(self, rhs: Self) -> Self {\n+            self.checked_mul(rhs).unwrap_or(Self::max_value())\n         }\n \n-        /// Wrapping (modular) addition. Computes `self + other`,\n+        /// Wrapping (modular) addition. Computes `self + rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n@@ -1802,7 +1802,7 @@ macro_rules! uint_impl {\n             }\n         }\n \n-        /// Wrapping (modular) subtraction. Computes `self - other`,\n+        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n@@ -1822,7 +1822,7 @@ macro_rules! uint_impl {\n         }\n \n         /// Wrapping (modular) multiplication. Computes `self *\n-        /// other`, wrapping around at the boundary of the type.\n+        /// rhs`, wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n         ///\n@@ -1840,7 +1840,7 @@ macro_rules! uint_impl {\n             }\n         }\n \n-        /// Wrapping (modular) division. Computes `self / other`.\n+        /// Wrapping (modular) division. Computes `self / rhs`.\n         /// Wrapped division on unsigned types is just normal division.\n         /// There's no way wrapping could ever happen.\n         /// This function exists, so that all operations\n@@ -1859,7 +1859,7 @@ macro_rules! uint_impl {\n             self / rhs\n         }\n \n-        /// Wrapping (modular) remainder. Computes `self % other`.\n+        /// Wrapping (modular) remainder. Computes `self % rhs`.\n         /// Wrapped remainder calculation on unsigned types is\n         /// just the regular remainder calculation.\n         /// There's no way wrapping could ever happen."}]}