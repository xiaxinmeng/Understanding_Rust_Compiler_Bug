{"sha": "e62ce6f61a602fb51f0bacb592ff50202fd89151", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MmNlNmY2MWE2MDJmYjUxZjBiYWNiNTkyZmY1MDIwMmZkODkxNTE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-03T16:24:33Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-03T16:24:33Z"}, "message": "Reorganize functions in extract_function assist", "tree": {"sha": "667b04f4cd04fc282733e4aef479861254d7fef4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/667b04f4cd04fc282733e4aef479861254d7fef4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e62ce6f61a602fb51f0bacb592ff50202fd89151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e62ce6f61a602fb51f0bacb592ff50202fd89151", "html_url": "https://github.com/rust-lang/rust/commit/e62ce6f61a602fb51f0bacb592ff50202fd89151", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e62ce6f61a602fb51f0bacb592ff50202fd89151/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "027a99fc700e9e0c49ee4cebffb8f9f635955e4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/027a99fc700e9e0c49ee4cebffb8f9f635955e4a", "html_url": "https://github.com/rust-lang/rust/commit/027a99fc700e9e0c49ee4cebffb8f9f635955e4a"}], "stats": {"total": 656, "additions": 362, "deletions": 294}, "files": [{"sha": "c6cd62edd5f0b63b0c719151260702ca878b55a2", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 362, "deletions": 294, "changes": 656, "blob_url": "https://github.com/rust-lang/rust/blob/e62ce6f61a602fb51f0bacb592ff50202fd89151/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e62ce6f61a602fb51f0bacb592ff50202fd89151/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=e62ce6f61a602fb51f0bacb592ff50202fd89151", "patch": "@@ -17,7 +17,7 @@ use syntax::{\n         edit::{AstNodeEdit, IndentLevel},\n         AstNode,\n     },\n-    ted,\n+    match_ast, ted,\n     SyntaxKind::{self, COMMENT},\n     SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, WalkEvent, T,\n };\n@@ -71,17 +71,43 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         syntax::NodeOrToken::Token(t) => t.parent()?,\n     };\n     let body = extraction_target(&node, range)?;\n+    let container_expr = body.parent()?.ancestors().find_map(|it| {\n+        // double Option as we want to short circuit\n+        let res = match_ast! {\n+            match it {\n+                ast::ClosureExpr(closure) => closure.body(),\n+                ast::EffectExpr(effect) => effect.block_expr().map(ast::Expr::BlockExpr),\n+                ast::Fn(fn_) => fn_.body().map(ast::Expr::BlockExpr),\n+                ast::Static(statik) => statik.body(),\n+                ast::ConstArg(ca) => ca.expr(),\n+                ast::Const(konst) => konst.body(),\n+                ast::ConstParam(cp) => cp.default_val(),\n+                ast::ConstBlockPat(cbp) => cbp.block_expr().map(ast::Expr::BlockExpr),\n+                ast::Variant(__) => None,\n+                ast::Meta(__) => None,\n+                _ => return None,\n+            }\n+        };\n+        Some(res)\n+    })??;\n+    let container_tail = match container_expr {\n+        ast::Expr::BlockExpr(block) => block.tail_expr(),\n+        expr => Some(expr),\n+    };\n+    let in_tail =\n+        container_tail.zip(body.tail_expr()).map_or(false, |(container_tail, body_tail)| {\n+            container_tail.syntax().text_range().contains_range(body_tail.syntax().text_range())\n+        });\n \n-    let (locals_used, has_await, self_param) = analyze_body(&ctx.sema, &body);\n+    let (locals_used, has_await, self_param) = body.analyze(&ctx.sema);\n \n     let anchor = if self_param.is_some() { Anchor::Method } else { Anchor::Freestanding };\n     let insert_after = node_to_insert_after(&body, anchor)?;\n     let module = ctx.sema.scope(&insert_after).module()?;\n \n-    let ret_ty = body_return_ty(ctx, &body)?;\n-    let ret_values = ret_values(ctx, &body, node.parent().as_ref().unwrap_or(&node));\n-\n-    let control_flow = external_control_flow(ctx, &body)?;\n+    let ret_ty = body.return_ty(ctx)?;\n+    let control_flow = body.external_control_flow(ctx)?;\n+    let ret_values = body.ret_values(ctx, node.parent().as_ref().unwrap_or(&node));\n \n     let target_range = body.text_range();\n \n@@ -90,13 +116,14 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         \"Extract into function\",\n         target_range,\n         move |builder| {\n-            let ret_values: Vec<_> = ret_values.collect();\n-            if stdx::never!(!ret_values.is_empty() && !ret_ty.is_unit()) {\n+            let outliving_locals: Vec<_> = ret_values.collect();\n+            if stdx::never!(!outliving_locals.is_empty() && !ret_ty.is_unit()) {\n                 // We should not have variables that outlive body if we have expression block\n+                stdx::never!();\n                 return;\n             }\n \n-            let params = extracted_function_params(ctx, &body, locals_used.iter().copied());\n+            let params = body.extracted_function_params(ctx, locals_used.iter().copied());\n \n             let insert_comma = body\n                 .parent()\n@@ -109,7 +136,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n                 control_flow,\n                 ret_ty,\n                 body,\n-                vars_defined_in_body_and_outlive: ret_values,\n+                outliving_locals,\n             };\n \n             let new_indent = IndentLevel::from_node(&insert_after);\n@@ -120,7 +147,8 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n                 builder.insert(target_range.end(), \",\");\n             }\n \n-            let fn_def = format_function(ctx, module, &fun, old_indent, new_indent, has_await);\n+            let fn_def =\n+                format_function(ctx, module, &fun, old_indent, new_indent, has_await, in_tail);\n             let insert_offset = insert_after.text_range().end();\n             match ctx.config.snippet_cap {\n                 Some(cap) => builder.insert_snippet(cap, insert_offset, fn_def),\n@@ -129,6 +157,50 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         },\n     )\n }\n+\n+/// Try to guess what user wants to extract\n+///\n+/// We have basically have two cases:\n+/// * We want whole node, like `loop {}`, `2 + 2`, `{ let n = 1; }` exprs.\n+///   Then we can use `ast::Expr`\n+/// * We want a few statements for a block. E.g.\n+///   ```rust,no_run\n+///   fn foo() -> i32 {\n+///     let m = 1;\n+///     $0\n+///     let n = 2;\n+///     let k = 3;\n+///     k + n\n+///     $0\n+///   }\n+///   ```\n+///\n+fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<FunctionBody> {\n+    if let Some(stmt) = ast::Stmt::cast(node.clone()) {\n+        return match stmt {\n+            ast::Stmt::Item(_) => None,\n+            ast::Stmt::ExprStmt(_) | ast::Stmt::LetStmt(_) => Some(FunctionBody::from_range(\n+                node.parent().and_then(ast::BlockExpr::cast)?,\n+                node.text_range(),\n+            )),\n+        };\n+    }\n+\n+    let expr = ast::Expr::cast(node.clone())?;\n+    // A node got selected fully\n+    if node.text_range() == selection_range {\n+        return FunctionBody::from_expr(expr.clone());\n+    }\n+\n+    // Covering element returned the parent block of one or multiple statements that have been selected\n+    if let ast::Expr::BlockExpr(block) = expr {\n+        // Extract the full statements.\n+        return Some(FunctionBody::from_range(block, selection_range));\n+    }\n+\n+    node.ancestors().find_map(ast::Expr::cast).and_then(FunctionBody::from_expr)\n+}\n+\n #[derive(Debug)]\n struct Function {\n     name: String,\n@@ -137,7 +209,7 @@ struct Function {\n     control_flow: ControlFlow,\n     ret_ty: RetType,\n     body: FunctionBody,\n-    vars_defined_in_body_and_outlive: Vec<OutlivedLocal>,\n+    outliving_locals: Vec<OutlivedLocal>,\n }\n \n #[derive(Debug)]\n@@ -267,7 +339,7 @@ impl Function {\n         match &self.ret_ty {\n             RetType::Expr(ty) if ty.is_unit() => FunType::Unit,\n             RetType::Expr(ty) => FunType::Single(ty.clone()),\n-            RetType::Stmt => match self.vars_defined_in_body_and_outlive.as_slice() {\n+            RetType::Stmt => match self.outliving_locals.as_slice() {\n                 [] => FunType::Unit,\n                 [var] => FunType::Single(var.local.ty(ctx.db())),\n                 vars => {\n@@ -325,6 +397,24 @@ impl Param {\n     }\n }\n \n+impl TryKind {\n+    fn of_ty(ty: hir::Type, ctx: &AssistContext) -> Option<TryKind> {\n+        if ty.is_unknown() {\n+            // We favour Result for `expr?`\n+            return Some(TryKind::Result { ty });\n+        }\n+        let adt = ty.as_adt()?;\n+        let name = adt.name(ctx.db());\n+        // FIXME: use lang items to determine if it is std type or user defined\n+        //        E.g. if user happens to define type named `Option`, we would have false positive\n+        match name.to_string().as_str() {\n+            \"Option\" => Some(TryKind::Option),\n+            \"Result\" => Some(TryKind::Result { ty }),\n+            _ => None,\n+        }\n+    }\n+}\n+\n impl FlowKind {\n     fn make_result_handler(&self, expr: Option<ast::Expr>) -> ast::Expr {\n         match self {\n@@ -357,22 +447,6 @@ impl FlowKind {\n     }\n }\n \n-fn try_kind_of_ty(ty: hir::Type, ctx: &AssistContext) -> Option<TryKind> {\n-    if ty.is_unknown() {\n-        // We favour Result for `expr?`\n-        return Some(TryKind::Result { ty });\n-    }\n-    let adt = ty.as_adt()?;\n-    let name = adt.name(ctx.db());\n-    // FIXME: use lang items to determine if it is std type or user defined\n-    //        E.g. if user happens to define type named `Option`, we would have false positive\n-    match name.to_string().as_str() {\n-        \"Option\" => Some(TryKind::Option),\n-        \"Result\" => Some(TryKind::Result { ty }),\n-        _ => None,\n-    }\n-}\n-\n impl FunctionBody {\n     fn parent(&self) -> Option<SyntaxNode> {\n         match self {\n@@ -525,130 +599,192 @@ impl FunctionBody {\n     }\n }\n \n-/// Try to guess what user wants to extract\n-///\n-/// We have basically have two cases:\n-/// * We want whole node, like `loop {}`, `2 + 2`, `{ let n = 1; }` exprs.\n-///   Then we can use `ast::Expr`\n-/// * We want a few statements for a block. E.g.\n-///   ```rust,no_run\n-///   fn foo() -> i32 {\n-///     let m = 1;\n-///     $0\n-///     let n = 2;\n-///     let k = 3;\n-///     k + n\n-///     $0\n-///   }\n-///   ```\n-///\n-fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<FunctionBody> {\n-    if let Some(stmt) = ast::Stmt::cast(node.clone()) {\n-        return match stmt {\n-            ast::Stmt::Item(_) => None,\n-            ast::Stmt::ExprStmt(_) | ast::Stmt::LetStmt(_) => Some(FunctionBody::from_range(\n-                node.parent().and_then(ast::BlockExpr::cast)?,\n-                node.text_range(),\n-            )),\n-        };\n+impl FunctionBody {\n+    /// Analyzes a function body, returning the used local variables that are referenced in it as well as\n+    /// whether it contains an await expression.\n+    fn analyze(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+    ) -> (FxIndexSet<Local>, bool, Option<ast::SelfParam>) {\n+        // FIXME: currently usages inside macros are not found\n+        let mut has_await = false;\n+        let mut self_param = None;\n+        let mut res = FxIndexSet::default();\n+        self.walk_expr(&mut |expr| {\n+            has_await |= matches!(expr, ast::Expr::AwaitExpr(_));\n+            let name_ref = match expr {\n+                ast::Expr::PathExpr(path_expr) => {\n+                    path_expr.path().and_then(|it| it.as_single_name_ref())\n+                }\n+                _ => return,\n+            };\n+            if let Some(name_ref) = name_ref {\n+                if let Some(\n+                    NameRefClass::Definition(Definition::Local(local_ref))\n+                    | NameRefClass::FieldShorthand { local_ref, field_ref: _ },\n+                ) = NameRefClass::classify(sema, &name_ref)\n+                {\n+                    if local_ref.is_self(sema.db) {\n+                        match local_ref.source(sema.db).value {\n+                            Either::Right(it) => {\n+                                stdx::always!(\n+                                    self_param.replace(it).is_none(),\n+                                    \"body references two different self params\"\n+                                );\n+                            }\n+                            Either::Left(_) => {\n+                                stdx::never!(\n+                                    \"Local::is_self returned true, but source is IdentPat\"\n+                                );\n+                            }\n+                        }\n+                    } else {\n+                        res.insert(local_ref);\n+                    }\n+                }\n+            }\n+        });\n+        (res, has_await, self_param)\n     }\n \n-    let expr = ast::Expr::cast(node.clone())?;\n-    // A node got selected fully\n-    if node.text_range() == selection_range {\n-        return FunctionBody::from_expr(expr.clone());\n+    fn return_ty(&self, ctx: &AssistContext) -> Option<RetType> {\n+        match self.tail_expr() {\n+            Some(expr) => ctx.sema.type_of_expr(&expr).map(TypeInfo::original).map(RetType::Expr),\n+            None => Some(RetType::Stmt),\n+        }\n     }\n \n-    // Covering element returned the parent block of one or multiple statements that have been selected\n-    if let ast::Expr::BlockExpr(block) = expr {\n-        // Extract the full statements.\n-        return Some(FunctionBody::from_range(block, selection_range));\n-    }\n+    /// Local variables defined inside `body` that are accessed outside of it\n+    fn ret_values<'a>(\n+        &self,\n+        ctx: &'a AssistContext,\n+        parent: &SyntaxNode,\n+    ) -> impl Iterator<Item = OutlivedLocal> + 'a {\n+        let parent = parent.clone();\n+        let range = self.text_range();\n+        locals_defined_in_body(&ctx.sema, self)\n+            .into_iter()\n+            .filter_map(move |local| local_outlives_body(ctx, range, local, &parent))\n+    }\n+\n+    /// Analyses the function body for external control flow.\n+    fn external_control_flow(&self, ctx: &AssistContext) -> Option<ControlFlow> {\n+        let mut ret_expr = None;\n+        let mut try_expr = None;\n+        let mut break_expr = None;\n+        let mut continue_expr = None;\n+\n+        let mut loop_depth = 0;\n+\n+        self.preorder_expr(&mut |expr| {\n+            let expr = match expr {\n+                WalkEvent::Enter(e) => e,\n+                WalkEvent::Leave(\n+                    ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_),\n+                ) => {\n+                    loop_depth -= 1;\n+                    return false;\n+                }\n+                WalkEvent::Leave(_) => return false,\n+            };\n+            match expr {\n+                ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_) => {\n+                    loop_depth += 1;\n+                }\n+                ast::Expr::ReturnExpr(it) => {\n+                    ret_expr = Some(it);\n+                }\n+                ast::Expr::TryExpr(it) => {\n+                    try_expr = Some(it);\n+                }\n+                ast::Expr::BreakExpr(it) if loop_depth == 0 => {\n+                    break_expr = Some(it);\n+                }\n+                ast::Expr::ContinueExpr(it) if loop_depth == 0 => {\n+                    continue_expr = Some(it);\n+                }\n+                _ => {}\n+            }\n+            false\n+        });\n \n-    node.ancestors().find_map(ast::Expr::cast).and_then(FunctionBody::from_expr)\n-}\n+        let kind = match (try_expr, ret_expr, break_expr, continue_expr) {\n+            (Some(e), None, None, None) => {\n+                let func = e.syntax().ancestors().find_map(ast::Fn::cast)?;\n+                let def = ctx.sema.to_def(&func)?;\n+                let ret_ty = def.ret_type(ctx.db());\n+                let kind = TryKind::of_ty(ret_ty, ctx)?;\n \n-/// Analyzes a function body, returning the used local variables that are referenced in it as well as\n-/// whether it contains an await expression.\n-fn analyze_body(\n-    sema: &Semantics<RootDatabase>,\n-    body: &FunctionBody,\n-) -> (FxIndexSet<Local>, bool, Option<ast::SelfParam>) {\n-    // FIXME: currently usages inside macros are not found\n-    let mut has_await = false;\n-    let mut self_param = None;\n-    let mut res = FxIndexSet::default();\n-    body.walk_expr(&mut |expr| {\n-        has_await |= matches!(expr, ast::Expr::AwaitExpr(_));\n-        let name_ref = match expr {\n-            ast::Expr::PathExpr(path_expr) => {\n-                path_expr.path().and_then(|it| it.as_single_name_ref())\n+                Some(FlowKind::Try { kind })\n             }\n-            _ => return,\n-        };\n-        if let Some(name_ref) = name_ref {\n-            if let Some(\n-                NameRefClass::Definition(Definition::Local(local_ref))\n-                | NameRefClass::FieldShorthand { local_ref, field_ref: _ },\n-            ) = NameRefClass::classify(sema, &name_ref)\n-            {\n-                if local_ref.is_self(sema.db) {\n-                    match local_ref.source(sema.db).value {\n-                        Either::Right(it) => {\n-                            stdx::always!(\n-                                self_param.replace(it).is_none(),\n-                                \"body references two different self params\"\n-                            );\n-                        }\n-                        Either::Left(_) => {\n-                            stdx::never!(\"Local::is_self returned true, but source is IdentPat\");\n-                        }\n+            (Some(_), Some(r), None, None) => match r.expr() {\n+                Some(expr) => {\n+                    if let Some(kind) = expr_err_kind(&expr, ctx) {\n+                        Some(FlowKind::TryReturn { expr, kind })\n+                    } else {\n+                        cov_mark::hit!(external_control_flow_try_and_return_non_err);\n+                        return None;\n                     }\n-                } else {\n-                    res.insert(local_ref);\n                 }\n+                None => return None,\n+            },\n+            (Some(_), _, _, _) => {\n+                cov_mark::hit!(external_control_flow_try_and_bc);\n+                return None;\n             }\n-        }\n-    });\n-    (res, has_await, self_param)\n-}\n-\n-/// find variables that should be extracted as params\n-///\n-/// Computes additional info that affects param type and mutability\n-fn extracted_function_params(\n-    ctx: &AssistContext,\n-    body: &FunctionBody,\n-    locals: impl Iterator<Item = Local>,\n-) -> Vec<Param> {\n-    locals\n-        .map(|local| (local, local.source(ctx.db())))\n-        .filter(|(_, src)| is_defined_outside_of_body(ctx, body, src))\n-        .filter_map(|(local, src)| {\n-            if src.value.is_left() {\n-                Some(local)\n-            } else {\n-                stdx::never!(false, \"Local::is_self returned false, but source is SelfParam\");\n-                None\n+            (None, Some(r), None, None) => Some(FlowKind::Return(r.expr())),\n+            (None, Some(_), _, _) => {\n+                cov_mark::hit!(external_control_flow_return_and_bc);\n+                return None;\n             }\n-        })\n-        .map(|var| {\n-            let usages = LocalUsages::find(ctx, var);\n-            let ty = var.ty(ctx.db());\n-            let is_copy = ty.is_copy(ctx.db());\n-            Param {\n-                var,\n-                ty,\n-                has_usages_afterwards: has_usages_after_body(&usages, body),\n-                has_mut_inside_body: has_exclusive_usages(ctx, &usages, body),\n-                is_copy,\n+            (None, None, Some(_), Some(_)) => {\n+                cov_mark::hit!(external_control_flow_break_and_continue);\n+                return None;\n             }\n-        })\n-        .collect()\n-}\n+            (None, None, Some(b), None) => Some(FlowKind::Break(b.expr())),\n+            (None, None, None, Some(_)) => Some(FlowKind::Continue),\n+            (None, None, None, None) => None,\n+        };\n+\n+        Some(ControlFlow { kind })\n+    }\n+    /// find variables that should be extracted as params\n+    ///\n+    /// Computes additional info that affects param type and mutability\n+    fn extracted_function_params(\n+        &self,\n+        ctx: &AssistContext,\n+        locals: impl Iterator<Item = Local>,\n+    ) -> Vec<Param> {\n+        locals\n+            .map(|local| (local, local.source(ctx.db())))\n+            .filter(|(_, src)| is_defined_outside_of_body(ctx, self, src))\n+            .filter_map(|(local, src)| {\n+                if src.value.is_left() {\n+                    Some(local)\n+                } else {\n+                    stdx::never!(false, \"Local::is_self returned false, but source is SelfParam\");\n+                    None\n+                }\n+            })\n+            .map(|var| {\n+                let usages = LocalUsages::find(ctx, var);\n+                let ty = var.ty(ctx.db());\n+                let is_copy = ty.is_copy(ctx.db());\n+                Param {\n+                    var,\n+                    ty,\n+                    has_usages_afterwards: self.has_usages_after_body(&usages),\n+                    has_mut_inside_body: has_exclusive_usages(ctx, &usages, self),\n+                    is_copy,\n+                }\n+            })\n+            .collect()\n+    }\n \n-fn has_usages_after_body(usages: &LocalUsages, body: &FunctionBody) -> bool {\n-    usages.iter().any(|reference| body.precedes_range(reference.range))\n+    fn has_usages_after_body(&self, usages: &LocalUsages) -> bool {\n+        usages.iter().any(|reference| self.precedes_range(reference.range))\n+    }\n }\n \n /// checks if relevant var is used with `&mut` access inside body\n@@ -801,19 +937,6 @@ fn locals_defined_in_body(\n     res\n }\n \n-/// Local variables defined inside `body` that are accessed outside of it\n-fn ret_values<'a>(\n-    ctx: &'a AssistContext,\n-    body: &FunctionBody,\n-    parent: &SyntaxNode,\n-) -> impl Iterator<Item = OutlivedLocal> + 'a {\n-    let parent = parent.clone();\n-    let range = body.text_range();\n-    locals_defined_in_body(&ctx.sema, body)\n-        .into_iter()\n-        .filter_map(move |local| local_outlives_body(ctx, range, local, &parent))\n-}\n-\n /// Returns usage details if local variable is used after(outside of) body\n fn local_outlives_body(\n     ctx: &AssistContext,\n@@ -856,95 +979,6 @@ fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n     }\n }\n \n-fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n-    match body.tail_expr() {\n-        Some(expr) => ctx.sema.type_of_expr(&expr).map(TypeInfo::original).map(RetType::Expr),\n-        None => Some(RetType::Stmt),\n-    }\n-}\n-\n-/// Analyses the function body for external control flow.\n-fn external_control_flow(ctx: &AssistContext, body: &FunctionBody) -> Option<ControlFlow> {\n-    let mut ret_expr = None;\n-    let mut try_expr = None;\n-    let mut break_expr = None;\n-    let mut continue_expr = None;\n-\n-    let mut loop_depth = 0;\n-\n-    body.preorder_expr(&mut |expr| {\n-        let expr = match expr {\n-            WalkEvent::Enter(e) => e,\n-            WalkEvent::Leave(\n-                ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_),\n-            ) => {\n-                loop_depth -= 1;\n-                return false;\n-            }\n-            WalkEvent::Leave(_) => return false,\n-        };\n-        match expr {\n-            ast::Expr::LoopExpr(_) | ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_) => {\n-                loop_depth += 1;\n-            }\n-            ast::Expr::ReturnExpr(it) => {\n-                ret_expr = Some(it);\n-            }\n-            ast::Expr::TryExpr(it) => {\n-                try_expr = Some(it);\n-            }\n-            ast::Expr::BreakExpr(it) if loop_depth == 0 => {\n-                break_expr = Some(it);\n-            }\n-            ast::Expr::ContinueExpr(it) if loop_depth == 0 => {\n-                continue_expr = Some(it);\n-            }\n-            _ => {}\n-        }\n-        false\n-    });\n-\n-    let kind = match (try_expr, ret_expr, break_expr, continue_expr) {\n-        (Some(e), None, None, None) => {\n-            let func = e.syntax().ancestors().find_map(ast::Fn::cast)?;\n-            let def = ctx.sema.to_def(&func)?;\n-            let ret_ty = def.ret_type(ctx.db());\n-            let kind = try_kind_of_ty(ret_ty, ctx)?;\n-\n-            Some(FlowKind::Try { kind })\n-        }\n-        (Some(_), Some(r), None, None) => match r.expr() {\n-            Some(expr) => {\n-                if let Some(kind) = expr_err_kind(&expr, ctx) {\n-                    Some(FlowKind::TryReturn { expr, kind })\n-                } else {\n-                    cov_mark::hit!(external_control_flow_try_and_return_non_err);\n-                    return None;\n-                }\n-            }\n-            None => return None,\n-        },\n-        (Some(_), _, _, _) => {\n-            cov_mark::hit!(external_control_flow_try_and_bc);\n-            return None;\n-        }\n-        (None, Some(r), None, None) => Some(FlowKind::Return(r.expr())),\n-        (None, Some(_), _, _) => {\n-            cov_mark::hit!(external_control_flow_return_and_bc);\n-            return None;\n-        }\n-        (None, None, Some(_), Some(_)) => {\n-            cov_mark::hit!(external_control_flow_break_and_continue);\n-            return None;\n-        }\n-        (None, None, Some(b), None) => Some(FlowKind::Break(b.expr())),\n-        (None, None, None, Some(_)) => Some(FlowKind::Continue),\n-        (None, None, None, None) => None,\n-    };\n-\n-    Some(ControlFlow { kind })\n-}\n-\n /// Checks is expr is `Err(_)` or `None`\n fn expr_err_kind(expr: &ast::Expr, ctx: &AssistContext) -> Option<TryKind> {\n     let func_name = match expr {\n@@ -1020,7 +1054,7 @@ fn make_call(\n     let expr = handler.make_call_expr(call_expr).indent(indent);\n \n     let mut buf = String::new();\n-    match fun.vars_defined_in_body_and_outlive.as_slice() {\n+    match fun.outliving_locals.as_slice() {\n         [] => {}\n         [var] => {\n             format_to!(buf, \"let {}{} = \", mut_modifier(var), var.local.name(ctx.db()).unwrap())\n@@ -1045,9 +1079,7 @@ fn make_call(\n     if body_contains_await {\n         buf.push_str(\".await\");\n     }\n-    if fun.ret_ty.is_unit()\n-        && (!fun.vars_defined_in_body_and_outlive.is_empty() || !expr.is_block_like())\n-    {\n+    if fun.ret_ty.is_unit() && (!fun.outliving_locals.is_empty() || !expr.is_block_like()) {\n         buf.push(';');\n     }\n     buf\n@@ -1178,11 +1210,12 @@ fn format_function(\n     old_indent: IndentLevel,\n     new_indent: IndentLevel,\n     body_contains_await: bool,\n+    in_tail: bool,\n ) -> String {\n     let mut fn_def = String::new();\n-    let params = make_param_list(ctx, module, fun);\n-    let ret_ty = make_ret_ty(ctx, module, fun);\n-    let body = make_body(ctx, old_indent, new_indent, fun);\n+    let params = fun.make_param_list(ctx, module);\n+    let ret_ty = fun.make_ret_ty(ctx, module, in_tail);\n+    let body = make_body(ctx, old_indent, new_indent, fun, in_tail);\n     let async_kw = if body_contains_await { \"async \" } else { \"\" };\n     match ctx.config.snippet_cap {\n         Some(_) => format_to!(fn_def, \"\\n\\n{}{}fn $0{}{}\", new_indent, async_kw, fun.name, params),\n@@ -1196,10 +1229,59 @@ fn format_function(\n     fn_def\n }\n \n-fn make_param_list(ctx: &AssistContext, module: hir::Module, fun: &Function) -> ast::ParamList {\n-    let self_param = fun.self_param.clone();\n-    let params = fun.params.iter().map(|param| param.to_param(ctx, module));\n-    make::param_list(self_param, params)\n+impl Function {\n+    fn make_param_list(&self, ctx: &AssistContext, module: hir::Module) -> ast::ParamList {\n+        let self_param = self.self_param.clone();\n+        let params = self.params.iter().map(|param| param.to_param(ctx, module));\n+        make::param_list(self_param, params)\n+    }\n+\n+    fn make_ret_ty(\n+        &self,\n+        ctx: &AssistContext,\n+        module: hir::Module,\n+        in_tail: bool,\n+    ) -> Option<ast::RetType> {\n+        let fun_ty = self.return_type(ctx);\n+        let handler =\n+            if in_tail { FlowHandler::None } else { FlowHandler::from_ret_ty(self, &fun_ty) };\n+        let ret_ty = match &handler {\n+            FlowHandler::None => {\n+                if matches!(fun_ty, FunType::Unit) {\n+                    return None;\n+                }\n+                fun_ty.make_ty(ctx, module)\n+            }\n+            FlowHandler::Try { kind: TryKind::Option } => {\n+                make::ext::ty_option(fun_ty.make_ty(ctx, module))\n+            }\n+            FlowHandler::Try { kind: TryKind::Result { ty: parent_ret_ty } } => {\n+                let handler_ty = parent_ret_ty\n+                    .type_arguments()\n+                    .nth(1)\n+                    .map(|ty| make_ty(&ty, ctx, module))\n+                    .unwrap_or_else(make::ty_unit);\n+                make::ext::ty_result(fun_ty.make_ty(ctx, module), handler_ty)\n+            }\n+            FlowHandler::If { .. } => make::ext::ty_bool(),\n+            FlowHandler::IfOption { action } => {\n+                let handler_ty = action\n+                    .expr_ty(ctx)\n+                    .map(|ty| make_ty(&ty, ctx, module))\n+                    .unwrap_or_else(make::ty_unit);\n+                make::ext::ty_option(handler_ty)\n+            }\n+            FlowHandler::MatchOption { .. } => make::ext::ty_option(fun_ty.make_ty(ctx, module)),\n+            FlowHandler::MatchResult { err } => {\n+                let handler_ty = err\n+                    .expr_ty(ctx)\n+                    .map(|ty| make_ty(&ty, ctx, module))\n+                    .unwrap_or_else(make::ty_unit);\n+                make::ext::ty_result(fun_ty.make_ty(ctx, module), handler_ty)\n+            }\n+        };\n+        Some(make::ret_type(ret_ty))\n+    }\n }\n \n impl FunType {\n@@ -1225,53 +1307,15 @@ impl FunType {\n     }\n }\n \n-fn make_ret_ty(ctx: &AssistContext, module: hir::Module, fun: &Function) -> Option<ast::RetType> {\n-    let fun_ty = fun.return_type(ctx);\n-    let handler = FlowHandler::from_ret_ty(fun, &fun_ty);\n-    let ret_ty = match &handler {\n-        FlowHandler::None => {\n-            if matches!(fun_ty, FunType::Unit) {\n-                return None;\n-            }\n-            fun_ty.make_ty(ctx, module)\n-        }\n-        FlowHandler::Try { kind: TryKind::Option } => {\n-            make::ext::ty_option(fun_ty.make_ty(ctx, module))\n-        }\n-        FlowHandler::Try { kind: TryKind::Result { ty: parent_ret_ty } } => {\n-            let handler_ty = parent_ret_ty\n-                .type_arguments()\n-                .nth(1)\n-                .map(|ty| make_ty(&ty, ctx, module))\n-                .unwrap_or_else(make::ty_unit);\n-            make::ext::ty_result(fun_ty.make_ty(ctx, module), handler_ty)\n-        }\n-        FlowHandler::If { .. } => make::ext::ty_bool(),\n-        FlowHandler::IfOption { action } => {\n-            let handler_ty = action\n-                .expr_ty(ctx)\n-                .map(|ty| make_ty(&ty, ctx, module))\n-                .unwrap_or_else(make::ty_unit);\n-            make::ext::ty_option(handler_ty)\n-        }\n-        FlowHandler::MatchOption { .. } => make::ext::ty_option(fun_ty.make_ty(ctx, module)),\n-        FlowHandler::MatchResult { err } => {\n-            let handler_ty =\n-                err.expr_ty(ctx).map(|ty| make_ty(&ty, ctx, module)).unwrap_or_else(make::ty_unit);\n-            make::ext::ty_result(fun_ty.make_ty(ctx, module), handler_ty)\n-        }\n-    };\n-    Some(make::ret_type(ret_ty))\n-}\n-\n fn make_body(\n     ctx: &AssistContext,\n     old_indent: IndentLevel,\n     new_indent: IndentLevel,\n     fun: &Function,\n+    in_tail: bool,\n ) -> ast::BlockExpr {\n     let ret_ty = fun.return_type(ctx);\n-    let handler = FlowHandler::from_ret_ty(fun, &ret_ty);\n+    let handler = if in_tail { FlowHandler::None } else { FlowHandler::from_ret_ty(fun, &ret_ty) };\n     let block = match &fun.body {\n         FunctionBody::Expr(expr) => {\n             let expr = rewrite_body_segment(ctx, &fun.params, &handler, expr.syntax());\n@@ -1307,7 +1351,7 @@ fn make_body(\n             };\n \n             if tail_expr.is_none() {\n-                match fun.vars_defined_in_body_and_outlive.as_slice() {\n+                match fun.outliving_locals.as_slice() {\n                     [] => {}\n                     [var] => {\n                         tail_expr = Some(path_expr_from_local(ctx, var.local));\n@@ -3861,6 +3905,30 @@ fn $0fun_name() {\n     foo();\n     foo();\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_does_not_wrap_res_in_res() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+//- minicore: result\n+fn foo() -> Result<(), i64> {\n+    $0Result::<i32, i64>::Ok(0)?;\n+    Ok(())$0\n+}\n+\"#,\n+            r#\"\n+fn foo() -> Result<(), i64> {\n+    fun_name()?\n+}\n+\n+fn $0fun_name() -> Result<(), i64> {\n+    Result::<i32, i64>::Ok(0)?;\n+    Ok(())\n+}\n \"#,\n         );\n     }"}]}