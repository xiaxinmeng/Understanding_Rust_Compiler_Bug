{"sha": "194302493ca269eb33e2718672c2f12380a19497", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NDMwMjQ5M2NhMjY5ZWIzM2UyNzE4NjcyYzJmMTIzODBhMTk0OTc=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-10-16T01:54:35Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-10-16T01:54:35Z"}, "message": "Remove extra::flatpipes\n\nCloses #9884", "tree": {"sha": "fae5a93061cf4717f19e51ecb35f00cbf2187bfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fae5a93061cf4717f19e51ecb35f00cbf2187bfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/194302493ca269eb33e2718672c2f12380a19497", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/194302493ca269eb33e2718672c2f12380a19497", "html_url": "https://github.com/rust-lang/rust/commit/194302493ca269eb33e2718672c2f12380a19497", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/194302493ca269eb33e2718672c2f12380a19497/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1252ad409258c2d3a2595f8a77dc7b84491cca77", "url": "https://api.github.com/repos/rust-lang/rust/commits/1252ad409258c2d3a2595f8a77dc7b84491cca77", "html_url": "https://github.com/rust-lang/rust/commit/1252ad409258c2d3a2595f8a77dc7b84491cca77"}], "stats": {"total": 980, "additions": 0, "deletions": 980}, "files": [{"sha": "3cea76b8edd40ce44735d6156d424a6788cc97d6", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/194302493ca269eb33e2718672c2f12380a19497/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/194302493ca269eb33e2718672c2f12380a19497/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=194302493ca269eb33e2718672c2f12380a19497", "patch": "@@ -54,7 +54,6 @@ pub mod arc;\n pub mod comm;\n pub mod future;\n pub mod task_pool;\n-pub mod flatpipes;\n \n // Collections\n "}, {"sha": "1fd81626188c526c3279485b032e68d970cd2a71", "filename": "src/libextra/flatpipes.rs", "status": "removed", "additions": 0, "deletions": 979, "changes": 979, "blob_url": "https://github.com/rust-lang/rust/blob/1252ad409258c2d3a2595f8a77dc7b84491cca77/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1252ad409258c2d3a2595f8a77dc7b84491cca77/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=1252ad409258c2d3a2595f8a77dc7b84491cca77", "patch": "@@ -1,979 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Generic communication channels for things that can be represented as,\n-or transformed to and from, byte vectors.\n-\n-The `FlatPort` and `FlatChan` types implement the generic channel and\n-port interface for arbitrary types and transport strategies. It can\n-particularly be used to send and receive serializable types over I/O\n-streams.\n-\n-`FlatPort` and `FlatChan` implement the same comm traits as pipe-based\n-ports and channels.\n-\n-# Example\n-\n-This example sends boxed integers across tasks using serialization.\n-\n-```rust\n-let (port, chan) = serial::pipe_stream();\n-\n-do task::spawn || {\n-    for i in range(0, 10) {\n-        chan.send(@i)\n-    }\n-}\n-\n-for i in range(0, 10) {\n-    assert @i == port.recv()\n-}\n- ```\n-\n-# Safety Note\n-\n-Flat pipes created from `io::Reader`s and `io::Writer`s share the same\n-blocking properties as the underlying stream. Since some implementations\n-block the scheduler thread, so will their pipes.\n-\n-*/\n-\n-#[allow(missing_doc)];\n-\n-\n-// The basic send/recv interface FlatChan and PortChan will implement\n-use std::io;\n-use std::comm::GenericChan;\n-use std::comm::GenericPort;\n-use std::sys::size_of;\n-\n-/**\n-A FlatPort, consisting of a `BytePort` that receives byte vectors,\n-and an `Unflattener` that converts the bytes to a value.\n-\n-Create using the constructors in the `serial` and `pod` modules.\n-*/\n-pub struct FlatPort<T, U, P> {\n-    unflattener: U,\n-    byte_port: P\n-}\n-\n-/**\n-A FlatChan, consisting of a `Flattener` that converts values to\n-byte vectors, and a `ByteChan` that transmits the bytes.\n-\n-Create using the constructors in the `serial` and `pod` modules.\n-*/\n-pub struct FlatChan<T, F, C> {\n-    flattener: F,\n-    byte_chan: C\n-}\n-\n-/**\n-Constructors for flat pipes that using serialization-based flattening.\n-*/\n-pub mod serial {\n-    pub use DefaultEncoder = ebml::writer::Encoder;\n-    pub use DefaultDecoder = ebml::reader::Decoder;\n-\n-    use serialize::{Decodable, Encodable};\n-    use flatpipes::flatteners::{DeserializingUnflattener,\n-                                SerializingFlattener};\n-    use flatpipes::flatteners::{deserialize_buffer, serialize_value};\n-    use flatpipes::bytepipes::{ReaderBytePort, WriterByteChan};\n-    use flatpipes::bytepipes::{PipeBytePort, PipeByteChan};\n-    use flatpipes::{FlatPort, FlatChan};\n-\n-    use std::io::{Reader, Writer};\n-    use std::comm::{Port, Chan};\n-    use std::comm;\n-\n-    pub type ReaderPort<T, R> = FlatPort<\n-        T, DeserializingUnflattener<DefaultDecoder, T>,\n-        ReaderBytePort<R>>;\n-    pub type WriterChan<T, W> = FlatChan<\n-        T, SerializingFlattener<DefaultEncoder, T>, WriterByteChan<W>>;\n-    pub type PipePort<T> = FlatPort<\n-        T, DeserializingUnflattener<DefaultDecoder, T>, PipeBytePort>;\n-    pub type PipeChan<T> = FlatChan<\n-        T, SerializingFlattener<DefaultEncoder, T>, PipeByteChan>;\n-\n-    /// Create a `FlatPort` from a `Reader`\n-    pub fn reader_port<T: Decodable<DefaultDecoder>,\n-                       R: Reader>(reader: R) -> ReaderPort<T, R> {\n-        let unflat: DeserializingUnflattener<DefaultDecoder, T> =\n-            DeserializingUnflattener::new(\n-                deserialize_buffer::<DefaultDecoder, T>);\n-        let byte_port = ReaderBytePort::new(reader);\n-        FlatPort::new(unflat, byte_port)\n-    }\n-\n-    /// Create a `FlatChan` from a `Writer`\n-    pub fn writer_chan<T: Encodable<DefaultEncoder>,\n-                       W: Writer>(writer: W) -> WriterChan<T, W> {\n-        let flat: SerializingFlattener<DefaultEncoder, T> =\n-            SerializingFlattener::new(\n-                serialize_value::<DefaultEncoder, T>);\n-        let byte_chan = WriterByteChan::new(writer);\n-        FlatChan::new(flat, byte_chan)\n-    }\n-\n-    /// Create a `FlatPort` from a `Port<~[u8]>`\n-    pub fn pipe_port<T:Decodable<DefaultDecoder>>(\n-        port: Port<~[u8]>\n-    ) -> PipePort<T> {\n-        let unflat: DeserializingUnflattener<DefaultDecoder, T> =\n-            DeserializingUnflattener::new(\n-                deserialize_buffer::<DefaultDecoder, T>);\n-        let byte_port = PipeBytePort::new(port);\n-        FlatPort::new(unflat, byte_port)\n-    }\n-\n-    /// Create a `FlatChan` from a `Chan<~[u8]>`\n-    pub fn pipe_chan<T:Encodable<DefaultEncoder>>(\n-        chan: Chan<~[u8]>\n-    ) -> PipeChan<T> {\n-        let flat: SerializingFlattener<DefaultEncoder, T> =\n-            SerializingFlattener::new(\n-                serialize_value::<DefaultEncoder, T>);\n-        let byte_chan = PipeByteChan::new(chan);\n-        FlatChan::new(flat, byte_chan)\n-    }\n-\n-    /// Create a pair of `FlatChan` and `FlatPort`, backed by pipes\n-    pub fn pipe_stream<T: Encodable<DefaultEncoder> +\n-                          Decodable<DefaultDecoder>>(\n-                          ) -> (PipePort<T>, PipeChan<T>) {\n-        let (port, chan) = comm::stream();\n-        return (pipe_port(port), pipe_chan(chan));\n-    }\n-}\n-\n-// FIXME #4074 this doesn't correctly enforce POD bounds\n-/**\n-Constructors for flat pipes that send POD types using memcpy.\n-\n-# Safety Note\n-\n-This module is currently unsafe because it uses `Clone + Send` as a type\n-parameter bounds meaning POD (plain old data), but `Clone + Send` and\n-POD are not equivalent.\n-\n-*/\n-pub mod pod {\n-\n-    use flatpipes::flatteners::{PodUnflattener, PodFlattener};\n-    use flatpipes::bytepipes::{ReaderBytePort, WriterByteChan};\n-    use flatpipes::bytepipes::{PipeBytePort, PipeByteChan};\n-    use flatpipes::{FlatPort, FlatChan};\n-\n-    use std::io::{Reader, Writer};\n-    use std::comm::{Port, Chan};\n-    use std::comm;\n-\n-    pub type ReaderPort<T, R> =\n-        FlatPort<T, PodUnflattener<T>, ReaderBytePort<R>>;\n-    pub type WriterChan<T, W> =\n-        FlatChan<T, PodFlattener<T>, WriterByteChan<W>>;\n-    pub type PipePort<T> = FlatPort<T, PodUnflattener<T>, PipeBytePort>;\n-    pub type PipeChan<T> = FlatChan<T, PodFlattener<T>, PipeByteChan>;\n-\n-    /// Create a `FlatPort` from a `Reader`\n-    pub fn reader_port<T:Clone + Send,R:Reader>(\n-        reader: R\n-    ) -> ReaderPort<T, R> {\n-        let unflat: PodUnflattener<T> = PodUnflattener::new();\n-        let byte_port = ReaderBytePort::new(reader);\n-        FlatPort::new(unflat, byte_port)\n-    }\n-\n-    /// Create a `FlatChan` from a `Writer`\n-    pub fn writer_chan<T:Clone + Send,W:Writer>(\n-        writer: W\n-    ) -> WriterChan<T, W> {\n-        let flat: PodFlattener<T> = PodFlattener::new();\n-        let byte_chan = WriterByteChan::new(writer);\n-        FlatChan::new(flat, byte_chan)\n-    }\n-\n-    /// Create a `FlatPort` from a `Port<~[u8]>`\n-    pub fn pipe_port<T:Clone + Send>(port: Port<~[u8]>) -> PipePort<T> {\n-        let unflat: PodUnflattener<T> = PodUnflattener::new();\n-        let byte_port = PipeBytePort::new(port);\n-        FlatPort::new(unflat, byte_port)\n-    }\n-\n-    /// Create a `FlatChan` from a `Chan<~[u8]>`\n-    pub fn pipe_chan<T:Clone + Send>(chan: Chan<~[u8]>) -> PipeChan<T> {\n-        let flat: PodFlattener<T> = PodFlattener::new();\n-        let byte_chan = PipeByteChan::new(chan);\n-        FlatChan::new(flat, byte_chan)\n-    }\n-\n-    /// Create a pair of `FlatChan` and `FlatPort`, backed by pipes\n-    pub fn pipe_stream<T:Clone + Send>() -> (PipePort<T>, PipeChan<T>) {\n-        let (port, chan) = comm::stream();\n-        return (pipe_port(port), pipe_chan(chan));\n-    }\n-\n-}\n-\n-/**\n-Flatteners present a value as a byte vector\n-*/\n-pub trait Flattener<T> {\n-    fn flatten(&self, val: T) -> ~[u8];\n-}\n-\n-/**\n-Unflatteners convert a byte vector to a value\n-*/\n-pub trait Unflattener<T> {\n-    fn unflatten(&self, buf: ~[u8]) -> T;\n-}\n-\n-/**\n-BytePorts are a simple interface for receiving a specified number\n-*/\n-pub trait BytePort {\n-    fn try_recv(&self, count: uint) -> Option<~[u8]>;\n-}\n-\n-/**\n-ByteChans are a simple interface for sending bytes\n-*/\n-pub trait ByteChan {\n-    fn send(&self, val: ~[u8]);\n-}\n-\n-static CONTINUE: [u8, ..4] = [0xAA, 0xBB, 0xCC, 0xDD];\n-\n-impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n-    fn recv(&self) -> T {\n-        match self.try_recv() {\n-            Some(val) => val,\n-            None => fail2!(\"port is closed\")\n-        }\n-    }\n-    fn try_recv(&self) -> Option<T> {\n-        let command = match self.byte_port.try_recv(CONTINUE.len()) {\n-            Some(c) => c,\n-            None => {\n-                warn2!(\"flatpipe: broken pipe\");\n-                return None;\n-            }\n-        };\n-\n-        if CONTINUE.as_slice() == command {\n-            let msg_len = match self.byte_port.try_recv(size_of::<u64>()) {\n-                Some(bytes) => {\n-                    io::u64_from_be_bytes(bytes, 0, size_of::<u64>())\n-                },\n-                None => {\n-                    warn2!(\"flatpipe: broken pipe\");\n-                    return None;\n-                }\n-            };\n-\n-            let msg_len = msg_len as uint;\n-\n-            match self.byte_port.try_recv(msg_len) {\n-                Some(bytes) => {\n-                    Some(self.unflattener.unflatten(bytes))\n-                }\n-                None => {\n-                    warn2!(\"flatpipe: broken pipe\");\n-                    return None;\n-                }\n-            }\n-        }\n-        else {\n-            fail2!(\"flatpipe: unrecognized command\");\n-        }\n-    }\n-}\n-\n-impl<T,F:Flattener<T>,C:ByteChan> GenericChan<T> for FlatChan<T, F, C> {\n-    fn send(&self, val: T) {\n-        self.byte_chan.send(CONTINUE.to_owned());\n-        let bytes = self.flattener.flatten(val);\n-        let len = bytes.len() as u64;\n-        do io::u64_to_be_bytes(len, size_of::<u64>()) |len_bytes| {\n-            self.byte_chan.send(len_bytes.to_owned());\n-        }\n-        self.byte_chan.send(bytes);\n-    }\n-}\n-\n-impl<T,U:Unflattener<T>,P:BytePort> FlatPort<T, U, P> {\n-    pub fn new(u: U, p: P) -> FlatPort<T, U, P> {\n-        FlatPort {\n-            unflattener: u,\n-            byte_port: p\n-        }\n-    }\n-}\n-\n-impl<T,F:Flattener<T>,C:ByteChan> FlatChan<T, F, C> {\n-    pub fn new(f: F, c: C) -> FlatChan<T, F, C> {\n-        FlatChan {\n-            flattener: f,\n-            byte_chan: c\n-        }\n-    }\n-}\n-\n-\n-pub mod flatteners {\n-\n-    use ebml;\n-    use flatpipes::{Flattener, Unflattener};\n-    use io_util::BufReader;\n-    use json;\n-    use serialize::{Encoder, Decoder, Encodable, Decodable};\n-\n-    use std::cast;\n-    use std::io::{Writer, Reader, ReaderUtil};\n-    use std::io;\n-    use std::ptr;\n-    use std::sys::size_of;\n-    use std::vec;\n-\n-    // FIXME #4074: Clone + Send != POD\n-    pub struct PodUnflattener<T> {\n-        bogus: ()\n-    }\n-\n-    pub struct PodFlattener<T> {\n-        bogus: ()\n-    }\n-\n-    impl<T:Clone + Send> Unflattener<T> for PodUnflattener<T> {\n-        fn unflatten(&self, buf: ~[u8]) -> T {\n-            assert!(size_of::<T>() != 0);\n-            assert_eq!(size_of::<T>(), buf.len());\n-            let addr_of_init: &u8 = unsafe { &*vec::raw::to_ptr(buf) };\n-            let addr_of_value: &T = unsafe { cast::transmute(addr_of_init) };\n-            (*addr_of_value).clone()\n-        }\n-    }\n-\n-    impl<T:Clone + Send> Flattener<T> for PodFlattener<T> {\n-        fn flatten(&self, val: T) -> ~[u8] {\n-            assert!(size_of::<T>() != 0);\n-            let val: *T = ptr::to_unsafe_ptr(&val);\n-            let byte_value = val as *u8;\n-            unsafe { vec::from_buf(byte_value, size_of::<T>()) }\n-        }\n-    }\n-\n-    impl<T:Clone + Send> PodUnflattener<T> {\n-        pub fn new() -> PodUnflattener<T> {\n-            PodUnflattener {\n-                bogus: ()\n-            }\n-        }\n-    }\n-\n-    impl<T:Clone + Send> PodFlattener<T> {\n-        pub fn new() -> PodFlattener<T> {\n-            PodFlattener {\n-                bogus: ()\n-            }\n-        }\n-    }\n-\n-\n-    pub type DeserializeBuffer<T> = ~fn(buf: &[u8]) -> T;\n-\n-    pub struct DeserializingUnflattener<D, T> {\n-        deserialize_buffer: DeserializeBuffer<T>\n-    }\n-\n-    pub type SerializeValue<T> = ~fn(val: &T) -> ~[u8];\n-\n-    pub struct SerializingFlattener<S, T> {\n-        serialize_value: SerializeValue<T>\n-    }\n-\n-    impl<D:Decoder,T:Decodable<D>> Unflattener<T>\n-            for DeserializingUnflattener<D, T> {\n-        fn unflatten(&self, buf: ~[u8]) -> T {\n-            (self.deserialize_buffer)(buf)\n-        }\n-    }\n-\n-    impl<S:Encoder,T:Encodable<S>> Flattener<T>\n-            for SerializingFlattener<S, T> {\n-        fn flatten(&self, val: T) -> ~[u8] {\n-            (self.serialize_value)(&val)\n-        }\n-    }\n-\n-    impl<D:Decoder,T:Decodable<D>> DeserializingUnflattener<D, T> {\n-        pub fn new(deserialize_buffer: DeserializeBuffer<T>)\n-                   -> DeserializingUnflattener<D, T> {\n-            DeserializingUnflattener {\n-                deserialize_buffer: deserialize_buffer\n-            }\n-        }\n-    }\n-\n-    impl<S:Encoder,T:Encodable<S>> SerializingFlattener<S, T> {\n-        pub fn new(serialize_value: SerializeValue<T>)\n-                   -> SerializingFlattener<S, T> {\n-            SerializingFlattener {\n-                serialize_value: serialize_value\n-            }\n-        }\n-    }\n-\n-    /*\n-    Implementations of the serialization functions required by\n-    SerializingFlattener\n-    */\n-\n-    pub fn deserialize_buffer<D: Decoder + FromReader,\n-                              T: Decodable<D>>(\n-                              buf: &[u8])\n-                              -> T {\n-        let buf = buf.to_owned();\n-        let buf_reader = @BufReader::new(buf);\n-        let reader = buf_reader as @Reader;\n-        let mut deser: D = FromReader::from_reader(reader);\n-        Decodable::decode(&mut deser)\n-    }\n-\n-    pub fn serialize_value<D: Encoder + FromWriter,\n-                           T: Encodable<D>>(\n-                           val: &T)\n-                           -> ~[u8] {\n-        do io::with_bytes_writer |writer| {\n-            let mut ser = FromWriter::from_writer(writer);\n-            val.encode(&mut ser);\n-        }\n-    }\n-\n-    pub trait FromReader {\n-        fn from_reader(r: @Reader) -> Self;\n-    }\n-\n-    pub trait FromWriter {\n-        fn from_writer(w: @Writer) -> Self;\n-    }\n-\n-    impl FromReader for json::Decoder {\n-        fn from_reader(r: @Reader) -> json::Decoder {\n-            match json::from_reader(r) {\n-                Ok(json) => {\n-                    json::Decoder(json)\n-                }\n-                Err(e) => fail2!(\"flatpipe: can't parse json: {:?}\", e)\n-            }\n-        }\n-    }\n-\n-    impl FromWriter for json::Encoder {\n-        fn from_writer(w: @Writer) -> json::Encoder {\n-            json::Encoder(w)\n-        }\n-    }\n-\n-    impl FromReader for ebml::reader::Decoder {\n-        fn from_reader(r: @Reader) -> ebml::reader::Decoder {\n-            let buf = @r.read_whole_stream();\n-            let doc = ebml::reader::Doc(buf);\n-            ebml::reader::Decoder(doc)\n-        }\n-    }\n-\n-    impl FromWriter for ebml::writer::Encoder {\n-        fn from_writer(w: @Writer) -> ebml::writer::Encoder {\n-            ebml::writer::Encoder(w)\n-        }\n-    }\n-\n-}\n-\n-pub mod bytepipes {\n-\n-    use flatpipes::{ByteChan, BytePort};\n-\n-    use std::comm::{Port, Chan};\n-    use std::comm;\n-    use std::io::{Writer, Reader, ReaderUtil};\n-\n-    pub struct ReaderBytePort<R> {\n-        reader: R\n-    }\n-\n-    pub struct WriterByteChan<W> {\n-        writer: W\n-    }\n-\n-    impl<R:Reader> BytePort for ReaderBytePort<R> {\n-        fn try_recv(&self, count: uint) -> Option<~[u8]> {\n-            let mut left = count;\n-            let mut bytes = ~[];\n-            while !self.reader.eof() && left > 0 {\n-                assert!(left <= count);\n-                assert!(left > 0);\n-                let new_bytes = self.reader.read_bytes(left);\n-                bytes.push_all(new_bytes);\n-                assert!(new_bytes.len() <= left);\n-                left -= new_bytes.len();\n-            }\n-\n-            if left == 0 {\n-                return Some(bytes);\n-            } else {\n-                warn2!(\"flatpipe: dropped {} broken bytes\", left);\n-                return None;\n-            }\n-        }\n-    }\n-\n-    impl<W:Writer> ByteChan for WriterByteChan<W> {\n-        fn send(&self, val: ~[u8]) {\n-            self.writer.write(val);\n-        }\n-    }\n-\n-    impl<R:Reader> ReaderBytePort<R> {\n-        pub fn new(r: R) -> ReaderBytePort<R> {\n-            ReaderBytePort {\n-                reader: r\n-            }\n-        }\n-    }\n-\n-    impl<W:Writer> WriterByteChan<W> {\n-        pub fn new(w: W) -> WriterByteChan<W> {\n-            WriterByteChan {\n-                writer: w\n-            }\n-        }\n-    }\n-\n-    // FIXME #6850: Remove `@mut` when this module is ported to the new I/O traits,\n-    // which use `&mut self` properly. (For example, util::comm::GenericPort's try_recv\n-    // method doesn't use `&mut self`, so the `try_recv` method in the impl of `BytePort`\n-    // for `PipeBytePort` can't have `&mut self` either.)\n-    pub struct PipeBytePort {\n-        port: comm::Port<~[u8]>,\n-        buf: @mut ~[u8]\n-    }\n-\n-    pub struct PipeByteChan {\n-        chan: comm::Chan<~[u8]>\n-    }\n-\n-    impl BytePort for PipeBytePort {\n-        fn try_recv(&self, count: uint) -> Option<~[u8]> {\n-            if self.buf.len() >= count {\n-                let mut bytes = ::std::util::replace(&mut *self.buf, ~[]);\n-                *self.buf = bytes.slice(count, bytes.len()).to_owned();\n-                bytes.truncate(count);\n-                return Some(bytes);\n-            } else if !self.buf.is_empty() {\n-                let mut bytes = ::std::util::replace(&mut *self.buf, ~[]);\n-                assert!(count > bytes.len());\n-                match self.try_recv(count - bytes.len()) {\n-                    Some(rest) => {\n-                        bytes.push_all(rest);\n-                        return Some(bytes);\n-                    }\n-                    None => return None\n-                }\n-            } else /* empty */ {\n-                match self.port.try_recv() {\n-                    Some(buf) => {\n-                        assert!(!buf.is_empty());\n-                        *self.buf = buf;\n-                        return self.try_recv(count);\n-                    }\n-                    None => return None\n-                }\n-            }\n-        }\n-    }\n-\n-    impl ByteChan for PipeByteChan {\n-        fn send(&self, val: ~[u8]) {\n-            self.chan.send(val)\n-        }\n-    }\n-\n-    impl PipeBytePort {\n-        pub fn new(p: Port<~[u8]>) -> PipeBytePort {\n-            PipeBytePort {\n-                port: p,\n-                buf: @mut ~[]\n-            }\n-        }\n-    }\n-\n-    impl PipeByteChan {\n-        pub fn new(c: Chan<~[u8]>) -> PipeByteChan {\n-            PipeByteChan {\n-                chan: c\n-            }\n-        }\n-    }\n-\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use flatpipes::BytePort;\n-    use flatpipes::pod;\n-    use flatpipes::serial;\n-    use io_util::BufReader;\n-\n-    use std::io::BytesWriter;\n-    use std::task;\n-\n-    #[test]\n-    #[ignore(reason = \"ebml failure\")]\n-    fn test_serializing_memory_stream() {\n-        let writer = BytesWriter::new();\n-        let chan = serial::writer_chan(writer);\n-\n-        chan.send(10);\n-\n-        let bytes = (*chan.byte_chan.writer.bytes).clone();\n-\n-        let reader = BufReader::new(bytes);\n-        let port = serial::reader_port(reader);\n-\n-        let res: int = port.recv();\n-        assert_eq!(res, 10i);\n-    }\n-\n-    #[test]\n-    #[ignore(reason = \"FIXME #6211 failing on linux snapshot machine\")]\n-    fn test_serializing_pipes() {\n-        let (port, chan) = serial::pipe_stream();\n-\n-        do task::spawn || {\n-            for i in range(0, 10) {\n-                chan.send(i)\n-            }\n-        }\n-\n-        for i in range(0, 10) {\n-            assert!(i == port.recv())\n-        }\n-    }\n-\n-    #[test]\n-    #[ignore(reason = \"ebml failure\")]\n-    fn test_serializing_boxes() {\n-        let (port, chan) = serial::pipe_stream();\n-\n-        do task::spawn || {\n-            for i in range(0, 10) {\n-                chan.send(@i)\n-            }\n-        }\n-\n-        for i in range(0, 10) {\n-            assert!(@i == port.recv())\n-        }\n-    }\n-\n-    #[test]\n-    fn test_pod_memory_stream() {\n-        let writer = BytesWriter::new();\n-        let chan = pod::writer_chan(writer);\n-\n-        chan.send(10);\n-\n-        let bytes = (*chan.byte_chan.writer.bytes).clone();\n-\n-        let reader = BufReader::new(bytes);\n-        let port = pod::reader_port(reader);\n-\n-        let res: int = port.recv();\n-        assert_eq!(res, 10);\n-    }\n-\n-    #[test]\n-    fn test_pod_pipes() {\n-        let (port, chan) = pod::pipe_stream();\n-\n-        do task::spawn || {\n-            for i in range(0, 10) {\n-                chan.send(i)\n-            }\n-        }\n-\n-        for i in range(0, 10) {\n-            assert!(i == port.recv())\n-        }\n-    }\n-\n-    // FIXME #2064: Networking doesn't work on x86\n-    // XXX Broken until networking support is added back\n-    /*\n-    use flatpipes::{Flattener, Unflattener, FlatChan, FlatPort};\n-    use flatpipes::bytepipes::*;\n-\n-    #[test]\n-    #[cfg(target_arch = \"x86_64\")]\n-    fn test_pod_tcp_stream() {\n-        fn reader_port(buf: TcpSocketBuf\n-                      ) -> pod::ReaderPort<int, TcpSocketBuf> {\n-            pod::reader_port(buf)\n-        }\n-        fn writer_chan(buf: TcpSocketBuf\n-                      ) -> pod::WriterChan<int, TcpSocketBuf> {\n-            pod::writer_chan(buf)\n-        }\n-        test_some_tcp_stream(reader_port, writer_chan, 9666);\n-    }\n-\n-    #[test]\n-    #[cfg(target_arch = \"x86_64\")]\n-    fn test_serializing_tcp_stream() {\n-        // XXX Broken until networking support is added back\n-        fn reader_port(buf: TcpSocketBuf\n-                      ) -> serial::ReaderPort<int, TcpSocketBuf> {\n-            serial::reader_port(buf)\n-        }\n-        fn writer_chan(buf: TcpSocketBuf\n-                      ) -> serial::WriterChan<int, TcpSocketBuf> {\n-            serial::writer_chan(buf)\n-        }\n-        test_some_tcp_stream(reader_port, writer_chan, 9667);\n-    }\n-\n-    type ReaderPortFactory<U> =\n-        ~fn(TcpSocketBuf) -> FlatPort<int, U, ReaderBytePort<TcpSocketBuf>>;\n-    type WriterChanFactory<F> =\n-        ~fn(TcpSocketBuf) -> FlatChan<int, F, WriterByteChan<TcpSocketBuf>>;\n-\n-    fn test_some_tcp_stream<U:Unflattener<int>,F:Flattener<int>>(\n-        reader_port: ReaderPortFactory<U>,\n-        writer_chan: WriterChanFactory<F>,\n-        port: uint) {\n-\n-        use std::cell::Cell;\n-        use std::comm;\n-        use std::result;\n-        use net::ip;\n-        use net::tcp;\n-        use uv;\n-\n-        // Indicate to the client task that the server is listening\n-        let (begin_connect_port, begin_connect_chan) = comm::stream();\n-        // The connection is sent from the server task to the receiver task\n-        // to handle the connection\n-        let (accept_port, accept_chan) = comm::stream();\n-        // The main task will wait until the test is over to proceed\n-        let (finish_port, finish_chan) = comm::stream();\n-\n-        let addr0 = ip::v4::parse_addr(\"127.0.0.1\");\n-\n-        let begin_connect_chan = Cell::new(begin_connect_chan);\n-        let accept_chan = Cell::new(accept_chan);\n-\n-        // The server task\n-        let addr = addr0.clone();\n-        do task::spawn || {\n-            let iotask = &uv::global_loop::get();\n-            let begin_connect_chan = begin_connect_chan.take();\n-            let accept_chan = accept_chan.take();\n-            let listen_res = do tcp::listen(\n-                addr.clone(), port, 128, iotask, |_kill_ch| {\n-                    // Tell the sender to initiate the connection\n-                    debug2!(\"listening\");\n-                    begin_connect_chan.send(())\n-                }) |new_conn, kill_ch| {\n-\n-                // Incoming connection. Send it to the receiver task to accept\n-                let (res_port, res_chan) = comm::stream();\n-                accept_chan.send((new_conn, res_chan));\n-                // Wait until the connection is accepted\n-                res_port.recv();\n-\n-                // Stop listening\n-                kill_ch.send(None)\n-            };\n-\n-            assert!(listen_res.is_ok());\n-        }\n-\n-        // Client task\n-        let addr = addr0.clone();\n-        do task::spawn || {\n-            // Wait for the server to start listening\n-            begin_connect_port.recv();\n-\n-            debug2!(\"connecting\");\n-            let iotask = &uv::global_loop::get();\n-            let connect_result = tcp::connect(addr.clone(), port, iotask);\n-            assert!(connect_result.is_ok());\n-            let sock = result::unwrap(connect_result);\n-            let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(sock);\n-\n-            // TcpSocketBuf is a Writer!\n-            let chan = writer_chan(socket_buf);\n-\n-            for i in range(0, 10) {\n-                debug2!(\"sending {}\", i);\n-                chan.send(i)\n-            }\n-        }\n-\n-        // Receiver task\n-        do task::spawn || {\n-            // Wait for a connection\n-            let (conn, res_chan) = accept_port.recv();\n-\n-            debug2!(\"accepting connection\");\n-            let accept_result = tcp::accept(conn);\n-            debug2!(\"accepted\");\n-            assert!(accept_result.is_ok());\n-            let sock = result::unwrap(accept_result);\n-            res_chan.send(());\n-\n-            let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(sock);\n-\n-            // TcpSocketBuf is a Reader!\n-            let port = reader_port(socket_buf);\n-\n-            for i in range(0, 10) {\n-                let j = port.recv();\n-                debug2!(\"received {:?}\", j);\n-                assert_eq!(i, j);\n-            }\n-\n-            // The test is over!\n-            finish_chan.send(());\n-        }\n-\n-        finish_port.recv();\n-    }*/\n-\n-    // Tests that the different backends behave the same when the\n-    // binary streaming protocol is broken\n-    mod broken_protocol {\n-\n-        use flatpipes::{BytePort, FlatPort};\n-        use flatpipes::flatteners::PodUnflattener;\n-        use flatpipes::pod;\n-        use io_util::BufReader;\n-\n-        use std::comm;\n-        use std::io;\n-        use std::sys;\n-        use std::task;\n-\n-        type PortLoader<P> =\n-            ~fn(~[u8]) -> FlatPort<int, PodUnflattener<int>, P>;\n-\n-        fn reader_port_loader(bytes: ~[u8]\n-                             ) -> pod::ReaderPort<int, BufReader> {\n-            let reader = BufReader::new(bytes);\n-            pod::reader_port(reader)\n-        }\n-\n-        fn pipe_port_loader(bytes: ~[u8]\n-                           ) -> pod::PipePort<int> {\n-            let (port, chan) = comm::stream();\n-            if !bytes.is_empty() {\n-                chan.send(bytes);\n-            }\n-            pod::pipe_port(port)\n-        }\n-\n-        fn test_try_recv_none1<P:BytePort>(loader: PortLoader<P>) {\n-            let bytes = ~[];\n-            let port = loader(bytes);\n-            let res: Option<int> = port.try_recv();\n-            assert!(res.is_none());\n-        }\n-\n-        #[test]\n-        fn test_try_recv_none1_reader() {\n-            test_try_recv_none1(reader_port_loader);\n-        }\n-        #[test]\n-        fn test_try_recv_none1_pipe() {\n-            test_try_recv_none1(pipe_port_loader);\n-        }\n-\n-        fn test_try_recv_none2<P:BytePort>(loader: PortLoader<P>) {\n-            // The control word in the protocol is interrupted\n-            let bytes = ~[0];\n-            let port = loader(bytes);\n-            let res: Option<int> = port.try_recv();\n-            assert!(res.is_none());\n-        }\n-\n-        #[test]\n-        fn test_try_recv_none2_reader() {\n-            test_try_recv_none2(reader_port_loader);\n-        }\n-        #[test]\n-        fn test_try_recv_none2_pipe() {\n-            test_try_recv_none2(pipe_port_loader);\n-        }\n-\n-        fn test_try_recv_none3<P:BytePort>(loader: PortLoader<P>) {\n-            static CONTINUE: [u8, ..4] = [0xAA, 0xBB, 0xCC, 0xDD];\n-            // The control word is followed by garbage\n-            let bytes = CONTINUE.to_owned() + &[0u8];\n-            let port = loader(bytes);\n-            let res: Option<int> = port.try_recv();\n-            assert!(res.is_none());\n-        }\n-\n-        #[test]\n-        fn test_try_recv_none3_reader() {\n-            test_try_recv_none3(reader_port_loader);\n-        }\n-        #[test]\n-        fn test_try_recv_none3_pipe() {\n-            test_try_recv_none3(pipe_port_loader);\n-        }\n-\n-        fn test_try_recv_none4<P:BytePort>(loader: PortLoader<P>) {\n-            assert!(do task::try || {\n-                static CONTINUE: [u8, ..4] = [0xAA, 0xBB, 0xCC, 0xDD];\n-                // The control word is followed by a valid length,\n-                // then undeserializable garbage\n-                let len_bytes = do io::u64_to_be_bytes(\n-                    1, sys::size_of::<u64>()) |len_bytes| {\n-                    len_bytes.to_owned()\n-                };\n-                let bytes = CONTINUE.to_owned() + len_bytes + &[0u8, 0, 0, 0];\n-\n-                let port = loader(bytes);\n-\n-                let _res: Option<int> = port.try_recv();\n-            }.is_err());\n-        }\n-\n-        #[test]\n-        fn test_try_recv_none4_reader() {\n-            test_try_recv_none4(reader_port_loader);\n-        }\n-        #[test]\n-        fn test_try_recv_none4_pipe() {\n-            test_try_recv_none4(pipe_port_loader);\n-        }\n-    }\n-\n-}"}]}