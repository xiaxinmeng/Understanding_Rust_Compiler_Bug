{"sha": "9e528ffe9c32b9a6b3be7554aa7929abb77b83a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllNTI4ZmZlOWMzMmI5YTZiM2JlNzU1NGFhNzkyOWFiYjc3YjgzYTE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-08T06:54:26Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-11-03T08:17:06Z"}, "message": "Revert \"Greatly improve generics handling in rustdoc search\"\n\nThis reverts commit 64382f4b78bdca6bea1dd06e4a1039646b04ae93.", "tree": {"sha": "33ac9519f3d39659237b8c037ec1b10f50a6b786", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33ac9519f3d39659237b8c037ec1b10f50a6b786"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e528ffe9c32b9a6b3be7554aa7929abb77b83a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e528ffe9c32b9a6b3be7554aa7929abb77b83a1", "html_url": "https://github.com/rust-lang/rust/commit/9e528ffe9c32b9a6b3be7554aa7929abb77b83a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e528ffe9c32b9a6b3be7554aa7929abb77b83a1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b19cc0c215217e2423173bf8ef346f882238f8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b19cc0c215217e2423173bf8ef346f882238f8c", "html_url": "https://github.com/rust-lang/rust/commit/9b19cc0c215217e2423173bf8ef346f882238f8c"}], "stats": {"total": 86, "additions": 22, "deletions": 64}, "files": [{"sha": "9ae8f2d607899bfc715562ecb168273e5a5206e6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 53, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9e528ffe9c32b9a6b3be7554aa7929abb77b83a1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e528ffe9c32b9a6b3be7554aa7929abb77b83a1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9e528ffe9c32b9a6b3be7554aa7929abb77b83a1", "patch": "@@ -1142,10 +1142,6 @@ fn report_assoc_ty_on_inherent_impl(tcx: TyCtxt<'_>, span: Span) {\n     );\n }\n \n-fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n-    checked_type_of(tcx, def_id, true).unwrap()\n-}\n-\n fn infer_placeholder_type(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n@@ -1189,26 +1185,14 @@ fn infer_placeholder_type(\n     ty\n }\n \n-/// Same as [`type_of`] but returns [`Option`] instead of failing.\n-///\n-/// If you want to fail anyway, you can set the `fail` parameter to true, but in this case,\n-/// you'd better just call [`type_of`] directly.\n-pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<'_>> {\n+fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     use rustc::hir::*;\n \n-    let hir_id = match tcx.hir().as_local_hir_id(def_id) {\n-        Some(hir_id) => hir_id,\n-        None => {\n-            if !fail {\n-                return None;\n-            }\n-            bug!(\"invalid node\");\n-        }\n-    };\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    Some(match tcx.hir().get(hir_id) {\n+    match tcx.hir().get(hir_id) {\n         Node::TraitItem(item) => match item.kind {\n             TraitItemKind::Method(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n@@ -1225,9 +1209,6 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             },\n             TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n             TraitItemKind::Type(_, None) => {\n-                if !fail {\n-                    return None;\n-                }\n                 span_bug!(item.span, \"associated type missing default\");\n             }\n         },\n@@ -1321,9 +1302,6 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                 | ItemKind::GlobalAsm(..)\n                 | ItemKind::ExternCrate(..)\n                 | ItemKind::Use(..) => {\n-                    if !fail {\n-                        return None;\n-                    }\n                     span_bug!(\n                         item.span,\n                         \"compute_type_of_item: unexpected item type: {:?}\",\n@@ -1361,7 +1339,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             ..\n         }) => {\n             if gen.is_some() {\n-                return Some(tcx.typeck_tables_of(def_id).node_type(hir_id));\n+                return tcx.typeck_tables_of(def_id).node_type(hir_id);\n             }\n \n             let substs = InternalSubsts::identity_for_item(tcx, def_id);\n@@ -1436,13 +1414,9 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                                     .map(|(index, _)| index)\n                                     .next()\n                             })\n-                            .or_else(|| {\n-                                if !fail {\n-                                    None\n-                                } else {\n-                                    bug!(\"no arg matching AnonConst in path\")\n-                                }\n-                            })?;\n+                            .unwrap_or_else(|| {\n+                                bug!(\"no arg matching AnonConst in path\");\n+                            });\n \n                         // We've encountered an `AnonConst` in some path, so we need to\n                         // figure out which generic parameter it corresponds to and return\n@@ -1452,8 +1426,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                                 tcx.generics_of(tcx.parent(def_id).unwrap())\n                             }\n                             Res::Def(_, def_id) => tcx.generics_of(def_id),\n-                            Res::Err => return Some(tcx.types.err),\n-                            _ if !fail => return None,\n+                            Res::Err => return tcx.types.err,\n                             res => {\n                                 tcx.sess.delay_span_bug(\n                                     DUMMY_SP,\n@@ -1462,7 +1435,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                                         res,\n                                     ),\n                                 );\n-                                return Some(tcx.types.err);\n+                                return tcx.types.err;\n                             }\n                         };\n \n@@ -1480,24 +1453,18 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                             // probably from an extra arg where one is not needed.\n                             .unwrap_or(tcx.types.err)\n                     } else {\n-                        if !fail {\n-                            return None;\n-                        }\n                         tcx.sess.delay_span_bug(\n                             DUMMY_SP,\n                             &format!(\n                                 \"unexpected const parent path {:?}\",\n                                 parent_node,\n                             ),\n                         );\n-                        return Some(tcx.types.err);\n+                        return tcx.types.err;\n                     }\n                 }\n \n                 x => {\n-                    if !fail {\n-                        return None;\n-                    }\n                     tcx.sess.delay_span_bug(\n                         DUMMY_SP,\n                         &format!(\n@@ -1547,21 +1514,13 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                 }\n                 ty\n             }\n-            x => {\n-                if !fail {\n-                    return None;\n-                }\n-                bug!(\"unexpected non-type Node::GenericParam: {:?}\", x)\n-            },\n+            x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n         },\n \n         x => {\n-            if !fail {\n-                return None;\n-            }\n             bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n         }\n-    })\n+    }\n }\n \n fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {"}, {"sha": "a5a4cfa2babc03e5a82167792a7fad07b22c310c", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e528ffe9c32b9a6b3be7554aa7929abb77b83a1/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e528ffe9c32b9a6b3be7554aa7929abb77b83a1/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=9e528ffe9c32b9a6b3be7554aa7929abb77b83a1", "patch": "@@ -109,8 +109,6 @@ use util::common::time;\n use std::iter;\n \n use astconv::{AstConv, Bounds};\n-pub use collect::checked_type_of;\n-\n pub struct TypeAndSubsts<'tcx> {\n     substs: SubstsRef<'tcx>,\n     ty: Ty<'tcx>,"}, {"sha": "a8a3f54ef5a8f306aeebd13df9efed11808831f8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9e528ffe9c32b9a6b3be7554aa7929abb77b83a1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e528ffe9c32b9a6b3be7554aa7929abb77b83a1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9e528ffe9c32b9a6b3be7554aa7929abb77b83a1", "patch": "@@ -1491,12 +1491,13 @@ impl GenericParamDefKind {\n         }\n     }\n \n-    pub fn get_type(&self, cx: &DocContext<'_>) -> Option<Type> {\n-        match *self {\n-            GenericParamDefKind::Type { did, .. } => {\n-                rustc_typeck::checked_type_of(cx.tcx, did, false).map(|t| t.clean(cx))\n-            }\n-            GenericParamDefKind::Const { ref ty, .. } => Some(ty.clone()),\n+    // FIXME(eddyb) this either returns the default of a type parameter, or the\n+    // type of a `const` parameter. It seems that the intention is to *visit*\n+    // any embedded types, but `get_type` seems to be the wrong name for that.\n+    pub fn get_type(&self) -> Option<Type> {\n+        match self {\n+            GenericParamDefKind::Type { default, .. } => default.clone(),\n+            GenericParamDefKind::Const { ty, .. } => Some(ty.clone()),\n             GenericParamDefKind::Lifetime => None,\n         }\n     }\n@@ -1522,8 +1523,8 @@ impl GenericParamDef {\n         self.kind.is_type()\n     }\n \n-    pub fn get_type(&self, cx: &DocContext<'_>) -> Option<Type> {\n-        self.kind.get_type(cx)\n+    pub fn get_type(&self) -> Option<Type> {\n+        self.kind.get_type()\n     }\n \n     pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n@@ -1891,7 +1892,7 @@ fn get_real_types(\n                             if !x.is_type() {\n                                 continue\n                             }\n-                            if let Some(ty) = x.get_type(cx) {\n+                            if let Some(ty) = x.get_type() {\n                                 let adds = get_real_types(generics, &ty, cx, recurse + 1);\n                                 if !adds.is_empty() {\n                                     res.extend(adds);"}]}