{"sha": "cd282d7f75da9080fda0f1740a729516e7fbec68", "node_id": "C_kwDOAAsO6NoAKGNkMjgyZDdmNzVkYTkwODBmZGEwZjE3NDBhNzI5NTE2ZTdmYmVjNjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-18T20:12:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-18T20:12:07Z"}, "message": "Auto merge of #97019 - b-naber:transition-to-valtrees-pt1, r=oli-obk\n\nTransition to valtrees pt1\n\nCompartmentalising https://github.com/rust-lang/rust/pull/96591 as much as possible.\n\nr? `@oli-obk`", "tree": {"sha": "7e55bf30bbcb3318fd38faec8a3490506d1bf4f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e55bf30bbcb3318fd38faec8a3490506d1bf4f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd282d7f75da9080fda0f1740a729516e7fbec68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd282d7f75da9080fda0f1740a729516e7fbec68", "html_url": "https://github.com/rust-lang/rust/commit/cd282d7f75da9080fda0f1740a729516e7fbec68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd282d7f75da9080fda0f1740a729516e7fbec68/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07ae142d77f56dd48f2736605e0a6c015f2aecc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/07ae142d77f56dd48f2736605e0a6c015f2aecc6", "html_url": "https://github.com/rust-lang/rust/commit/07ae142d77f56dd48f2736605e0a6c015f2aecc6"}, {"sha": "96b36d6eb21daaca2c2d04fd8d7c27bef5eb90c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/96b36d6eb21daaca2c2d04fd8d7c27bef5eb90c6", "html_url": "https://github.com/rust-lang/rust/commit/96b36d6eb21daaca2c2d04fd8d7c27bef5eb90c6"}], "stats": {"total": 784, "additions": 540, "deletions": 244}, "files": [{"sha": "d7cbc48e0328185b53fb55d415bcdfe3757a238b", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -135,7 +135,7 @@ pub(super) fn op_to_const<'tcx>(\n     } else {\n         // It is guaranteed that any non-slice scalar pair is actually ByRef here.\n         // When we come back from raw const eval, we are always by-ref. The only way our op here is\n-        // by-val is if we are in destructure_const, i.e., if this is (a field of) something that we\n+        // by-val is if we are in destructure_mir_constant, i.e., if this is (a field of) something that we\n         // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n         // structs containing such.\n         op.try_as_mplace()"}, {"sha": "db43f7a425ce66558658b0889f31da6b82703bc3", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 126, "deletions": 4, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -4,6 +4,7 @@ use std::convert::TryFrom;\n \n use rustc_hir::Mutability;\n use rustc_middle::mir;\n+use rustc_middle::mir::interpret::{EvalToValTreeResult, GlobalId};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n \n@@ -22,7 +23,7 @@ pub use error::*;\n pub use eval_queries::*;\n pub use fn_queries::*;\n pub use machine::*;\n-pub(crate) use valtrees::{const_to_valtree, valtree_to_const_value};\n+pub(crate) use valtrees::{const_to_valtree_inner, valtree_to_const_value};\n \n pub(crate) fn const_caller_location(\n     tcx: TyCtxt<'_>,\n@@ -38,6 +39,57 @@ pub(crate) fn const_caller_location(\n     ConstValue::Scalar(Scalar::from_maybe_pointer(loc_place.ptr, &tcx))\n }\n \n+// We forbid type-level constants that contain more than `VALTREE_MAX_NODES` nodes.\n+const VALTREE_MAX_NODES: usize = 1000;\n+\n+pub(crate) enum ValTreeCreationError {\n+    NodesOverflow,\n+    NonSupportedType,\n+    Other,\n+}\n+pub(crate) type ValTreeCreationResult<'tcx> = Result<ty::ValTree<'tcx>, ValTreeCreationError>;\n+\n+/// Evaluates a constant and turns it into a type-level constant value.\n+pub(crate) fn eval_to_valtree<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cid: GlobalId<'tcx>,\n+) -> EvalToValTreeResult<'tcx> {\n+    let const_alloc = tcx.eval_to_allocation_raw(param_env.and(cid))?;\n+    let ecx = mk_eval_cx(\n+        tcx, DUMMY_SP, param_env,\n+        // It is absolutely crucial for soundness that\n+        // we do not read from static items or other mutable memory.\n+        false,\n+    );\n+    let place = ecx.raw_const_to_mplace(const_alloc).unwrap();\n+    debug!(?place);\n+\n+    let mut num_nodes = 0;\n+    let valtree_result = const_to_valtree_inner(&ecx, &place, &mut num_nodes);\n+\n+    match valtree_result {\n+        Ok(valtree) => Ok(Some(valtree)),\n+        Err(err) => {\n+            let did = cid.instance.def_id();\n+            let s = cid.display(tcx);\n+            match err {\n+                ValTreeCreationError::NodesOverflow => {\n+                    let msg = format!(\"maximum number of nodes exceeded in constant {}\", &s);\n+                    let mut diag = match tcx.hir().span_if_local(did) {\n+                        Some(span) => tcx.sess.struct_span_err(span, &msg),\n+                        None => tcx.sess.struct_err(&msg),\n+                    };\n+                    diag.emit();\n+\n+                    Ok(None)\n+                }\n+                ValTreeCreationError::NonSupportedType | ValTreeCreationError::Other => Ok(None),\n+            }\n+        }\n+    }\n+}\n+\n /// This function should never fail for validated constants. However, it is also invoked from the\n /// pretty printer which might attempt to format invalid constants and in that case it might fail.\n pub(crate) fn try_destructure_const<'tcx>(\n@@ -48,7 +100,6 @@ pub(crate) fn try_destructure_const<'tcx>(\n     trace!(\"destructure_const: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n     let op = ecx.const_to_op(val, None)?;\n-\n     // We go to `usize` as we cannot allocate anything bigger anyway.\n     let (field_count, variant, down) = match val.ty().kind() {\n         ty::Array(_, len) => (usize::try_from(len.eval_usize(tcx, param_env)).unwrap(), None, op),\n@@ -64,7 +115,6 @@ pub(crate) fn try_destructure_const<'tcx>(\n         ty::Tuple(substs) => (substs.len(), None, op),\n         _ => bug!(\"cannot destructure constant {:?}\", val),\n     };\n-\n     let fields = (0..field_count)\n         .map(|i| {\n             let field_op = ecx.operand_field(&down, i)?;\n@@ -73,10 +123,46 @@ pub(crate) fn try_destructure_const<'tcx>(\n         })\n         .collect::<InterpResult<'tcx, Vec<_>>>()?;\n     let fields = tcx.arena.alloc_from_iter(fields);\n-\n     Ok(mir::DestructuredConst { variant, fields })\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n+pub(crate) fn try_destructure_mir_constant<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    val: mir::ConstantKind<'tcx>,\n+) -> InterpResult<'tcx, mir::DestructuredMirConstant<'tcx>> {\n+    trace!(\"destructure_mir_constant: {:?}\", val);\n+    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n+    let op = ecx.mir_const_to_op(&val, None)?;\n+\n+    // We go to `usize` as we cannot allocate anything bigger anyway.\n+    let (field_count, variant, down) = match val.ty().kind() {\n+        ty::Array(_, len) => (len.eval_usize(tcx, param_env) as usize, None, op),\n+        ty::Adt(def, _) if def.variants().is_empty() => {\n+            throw_ub!(Unreachable)\n+        }\n+        ty::Adt(def, _) => {\n+            let variant = ecx.read_discriminant(&op).unwrap().1;\n+            let down = ecx.operand_downcast(&op, variant).unwrap();\n+            (def.variants()[variant].fields.len(), Some(variant), down)\n+        }\n+        ty::Tuple(substs) => (substs.len(), None, op),\n+        _ => bug!(\"cannot destructure mir constant {:?}\", val),\n+    };\n+\n+    let fields_iter = (0..field_count)\n+        .map(|i| {\n+            let field_op = ecx.operand_field(&down, i)?;\n+            let val = op_to_const(&ecx, &field_op);\n+            Ok(mir::ConstantKind::Val(val, field_op.layout.ty))\n+        })\n+        .collect::<InterpResult<'tcx, Vec<_>>>()?;\n+    let fields = tcx.arena.alloc_from_iter(fields_iter);\n+\n+    Ok(mir::DestructuredMirConstant { variant, fields })\n+}\n+\n #[instrument(skip(tcx), level = \"debug\")]\n pub(crate) fn deref_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -113,3 +199,39 @@ pub(crate) fn deref_const<'tcx>(\n \n     tcx.mk_const(ty::ConstS { val: ty::ConstKind::Value(op_to_const(&ecx, &mplace.into())), ty })\n }\n+\n+#[instrument(skip(tcx), level = \"debug\")]\n+pub(crate) fn deref_mir_constant<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    val: mir::ConstantKind<'tcx>,\n+) -> mir::ConstantKind<'tcx> {\n+    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n+    let op = ecx.mir_const_to_op(&val, None).unwrap();\n+    let mplace = ecx.deref_operand(&op).unwrap();\n+    if let Some(alloc_id) = mplace.ptr.provenance {\n+        assert_eq!(\n+            tcx.get_global_alloc(alloc_id).unwrap().unwrap_memory().0.0.mutability,\n+            Mutability::Not,\n+            \"deref_const cannot be used with mutable allocations as \\\n+            that could allow pattern matching to observe mutable statics\",\n+        );\n+    }\n+\n+    let ty = match mplace.meta {\n+        MemPlaceMeta::None => mplace.layout.ty,\n+        MemPlaceMeta::Poison => bug!(\"poison metadata in `deref_const`: {:#?}\", mplace),\n+        // In case of unsized types, figure out the real type behind.\n+        MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n+            ty::Str => bug!(\"there's no sized equivalent of a `str`\"),\n+            ty::Slice(elem_ty) => tcx.mk_array(*elem_ty, scalar.to_machine_usize(&tcx).unwrap()),\n+            _ => bug!(\n+                \"type {} should not have metadata, but had {:?}\",\n+                mplace.layout.ty,\n+                mplace.meta\n+            ),\n+        },\n+    };\n+\n+    mir::ConstantKind::Val(op_to_const(&ecx, &mplace.into()), ty)\n+}"}, {"sha": "7346d69bb5de3f11c1d9429765ba47a82d703a8d", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 82, "deletions": 61, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -1,124 +1,142 @@\n use super::eval_queries::{mk_eval_cx, op_to_const};\n use super::machine::CompileTimeEvalContext;\n+use super::{ValTreeCreationError, ValTreeCreationResult, VALTREE_MAX_NODES};\n use crate::interpret::{\n     intern_const_alloc_recursive, ConstValue, ImmTy, Immediate, InternKind, MemPlaceMeta,\n     MemoryKind, PlaceTy, Scalar, ScalarMaybeUninit,\n };\n-use rustc_middle::mir::interpret::ConstAlloc;\n-use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n use rustc_span::source_map::DUMMY_SP;\n use rustc_target::abi::{Align, VariantIdx};\n \n use crate::interpret::MPlaceTy;\n use crate::interpret::Value;\n-\n-/// Convert an evaluated constant to a type level constant\n-#[instrument(skip(tcx), level = \"debug\")]\n-pub(crate) fn const_to_valtree<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    raw: ConstAlloc<'tcx>,\n-) -> Option<ty::ValTree<'tcx>> {\n-    let ecx = mk_eval_cx(\n-        tcx, DUMMY_SP, param_env,\n-        // It is absolutely crucial for soundness that\n-        // we do not read from static items or other mutable memory.\n-        false,\n-    );\n-    let place = ecx.raw_const_to_mplace(raw).unwrap();\n-    const_to_valtree_inner(&ecx, &place)\n-}\n+use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n \n #[instrument(skip(ecx), level = \"debug\")]\n fn branches<'tcx>(\n     ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n     place: &MPlaceTy<'tcx>,\n     n: usize,\n     variant: Option<VariantIdx>,\n-) -> Option<ty::ValTree<'tcx>> {\n+    num_nodes: &mut usize,\n+) -> ValTreeCreationResult<'tcx> {\n     let place = match variant {\n         Some(variant) => ecx.mplace_downcast(&place, variant).unwrap(),\n         None => *place,\n     };\n     let variant = variant.map(|variant| Some(ty::ValTree::Leaf(ScalarInt::from(variant.as_u32()))));\n     debug!(?place, ?variant);\n \n-    let fields = (0..n).map(|i| {\n+    let mut fields = Vec::with_capacity(n);\n+    for i in 0..n {\n         let field = ecx.mplace_field(&place, i).unwrap();\n-        const_to_valtree_inner(ecx, &field)\n-    });\n-    // For enums, we preped their variant index before the variant's fields so we can figure out\n+        let valtree = const_to_valtree_inner(ecx, &field, num_nodes)?;\n+        fields.push(Some(valtree));\n+    }\n+\n+    // For enums, we prepend their variant index before the variant's fields so we can figure out\n     // the variant again when just seeing a valtree.\n-    let branches = variant.into_iter().chain(fields);\n-    Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n+    let branches = variant\n+        .into_iter()\n+        .chain(fields.into_iter())\n+        .collect::<Option<Vec<_>>>()\n+        .expect(\"should have already checked for errors in ValTree creation\");\n+\n+    // Have to account for ZSTs here\n+    if branches.len() == 0 {\n+        *num_nodes += 1;\n+    }\n+\n+    Ok(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches)))\n }\n \n #[instrument(skip(ecx), level = \"debug\")]\n fn slice_branches<'tcx>(\n     ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n     place: &MPlaceTy<'tcx>,\n-) -> Option<ty::ValTree<'tcx>> {\n+    num_nodes: &mut usize,\n+) -> ValTreeCreationResult<'tcx> {\n     let n = place\n         .len(&ecx.tcx.tcx)\n         .unwrap_or_else(|_| panic!(\"expected to use len of place {:?}\", place));\n-    let branches = (0..n).map(|i| {\n+\n+    let mut elems = Vec::with_capacity(n as usize);\n+    for i in 0..n {\n         let place_elem = ecx.mplace_index(place, i).unwrap();\n-        const_to_valtree_inner(ecx, &place_elem)\n-    });\n+        let valtree = const_to_valtree_inner(ecx, &place_elem, num_nodes)?;\n+        elems.push(valtree);\n+    }\n \n-    Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n+    Ok(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(elems)))\n }\n \n #[instrument(skip(ecx), level = \"debug\")]\n-fn const_to_valtree_inner<'tcx>(\n+pub(crate) fn const_to_valtree_inner<'tcx>(\n     ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n     place: &MPlaceTy<'tcx>,\n-) -> Option<ty::ValTree<'tcx>> {\n-    match place.layout.ty.kind() {\n-        ty::FnDef(..) => Some(ty::ValTree::zst()),\n+    num_nodes: &mut usize,\n+) -> ValTreeCreationResult<'tcx> {\n+    if *num_nodes >= VALTREE_MAX_NODES {\n+        return Err(ValTreeCreationError::NodesOverflow);\n+    }\n+\n+    let ty = place.layout.ty;\n+    debug!(\"ty kind: {:?}\", ty.kind());\n+\n+    match ty.kind() {\n+        ty::FnDef(..) => {\n+            *num_nodes += 1;\n+            Ok(ty::ValTree::zst())\n+        }\n         ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n-            let val = ecx.read_immediate(&place.into()).unwrap();\n+            let Ok(val) = ecx.read_immediate(&place.into()) else {\n+                return Err(ValTreeCreationError::Other);\n+            };\n             let val = val.to_scalar().unwrap();\n-            Some(ty::ValTree::Leaf(val.assert_int()))\n+            *num_nodes += 1;\n+\n+            Ok(ty::ValTree::Leaf(val.assert_int()))\n         }\n \n         // Raw pointers are not allowed in type level constants, as we cannot properly test them for\n         // equality at compile-time (see `ptr_guaranteed_eq`/`_ne`).\n         // Technically we could allow function pointers (represented as `ty::Instance`), but this is not guaranteed to\n         // agree with runtime equality tests.\n-        ty::FnPtr(_) | ty::RawPtr(_) => None,\n+        ty::FnPtr(_) | ty::RawPtr(_) => Err(ValTreeCreationError::NonSupportedType),\n \n         ty::Ref(_, _, _)  => {\n-            let derefd_place = ecx.deref_operand(&place.into()).unwrap_or_else(|e| bug!(\"couldn't deref {:?}, error: {:?}\", place, e));\n+            let Ok(derefd_place)= ecx.deref_operand(&place.into()) else {\n+                return Err(ValTreeCreationError::Other);\n+            };\n             debug!(?derefd_place);\n \n-            const_to_valtree_inner(ecx, &derefd_place)\n+            const_to_valtree_inner(ecx, &derefd_place, num_nodes)\n         }\n \n         ty::Str | ty::Slice(_) | ty::Array(_, _) => {\n-            let valtree = slice_branches(ecx, place);\n-            debug!(?valtree);\n-\n-            valtree\n+            slice_branches(ecx, place, num_nodes)\n         }\n         // Trait objects are not allowed in type level constants, as we have no concept for\n         // resolving their backing type, even if we can do that at const eval time. We may\n         // hypothetically be able to allow `dyn StructuralEq` trait objects in the future,\n         // but it is unclear if this is useful.\n-        ty::Dynamic(..) => None,\n+        ty::Dynamic(..) => Err(ValTreeCreationError::NonSupportedType),\n \n-        ty::Tuple(substs) => branches(ecx, place, substs.len(), None),\n+        ty::Tuple(elem_tys) => {\n+            branches(ecx, place, elem_tys.len(), None, num_nodes)\n+        }\n \n         ty::Adt(def, _) => {\n             if def.is_union() {\n-                return None\n+                return Err(ValTreeCreationError::NonSupportedType);\n             } else if def.variants().is_empty() {\n                 bug!(\"uninhabited types should have errored and never gotten converted to valtree\")\n             }\n \n-            let variant = ecx.read_discriminant(&place.into()).unwrap().1;\n-\n-            branches(ecx, place, def.variant(variant).fields.len(), def.is_enum().then_some(variant))\n+            let Ok((_, variant)) = ecx.read_discriminant(&place.into()) else {\n+                return Err(ValTreeCreationError::Other);\n+            };\n+            branches(ecx, place, def.variant(variant).fields.len(), def.is_enum().then_some(variant), num_nodes)\n         }\n \n         ty::Never\n@@ -136,7 +154,7 @@ fn const_to_valtree_inner<'tcx>(\n         // FIXME(oli-obk): we can probably encode closures just like structs\n         | ty::Closure(..)\n         | ty::Generator(..)\n-        | ty::GeneratorWitness(..) => None,\n+        | ty::GeneratorWitness(..) => Err(ValTreeCreationError::NonSupportedType),\n     }\n }\n \n@@ -225,8 +243,11 @@ fn create_pointee_place<'tcx>(\n             .unwrap();\n         debug!(?ptr);\n \n-        let mut place = MPlaceTy::from_aligned_ptr(ptr.into(), layout);\n-        place.meta = MemPlaceMeta::Meta(Scalar::from_u64(num_elems as u64));\n+        let place = MPlaceTy::from_aligned_ptr_with_meta(\n+            ptr.into(),\n+            layout,\n+            MemPlaceMeta::Meta(Scalar::from_u64(num_elems as u64)),\n+        );\n         debug!(?place);\n \n         place\n@@ -237,11 +258,11 @@ fn create_pointee_place<'tcx>(\n \n /// Converts a `ValTree` to a `ConstValue`, which is needed after mir\n /// construction has finished.\n-// FIXME Merge `valtree_to_const_value` and `fill_place_recursively` into one function\n+// FIXME Merge `valtree_to_const_value` and `valtree_into_mplace` into one function\n #[instrument(skip(tcx), level = \"debug\")]\n pub fn valtree_to_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    param_env_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    ty: Ty<'tcx>,\n     valtree: ty::ValTree<'tcx>,\n ) -> ConstValue<'tcx> {\n     // Basic idea: We directly construct `Scalar` values from trivial `ValTree`s\n@@ -251,8 +272,8 @@ pub fn valtree_to_const_value<'tcx>(\n     // create inner `MPlace`s which are filled recursively.\n     // FIXME Does this need an example?\n \n-    let (param_env, ty) = param_env_ty.into_parts();\n-    let mut ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n+    let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::empty(), false);\n+    let param_env_ty = ty::ParamEnv::empty().and(ty);\n \n     match ty.kind() {\n         ty::FnDef(..) => {\n@@ -275,7 +296,7 @@ pub fn valtree_to_const_value<'tcx>(\n             };\n             debug!(?place);\n \n-            fill_place_recursively(&mut ecx, &mut place, valtree);\n+            valtree_into_mplace(&mut ecx, &mut place, valtree);\n             dump_place(&ecx, place.into());\n             intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &place).unwrap();\n \n@@ -317,7 +338,7 @@ pub fn valtree_to_const_value<'tcx>(\n \n // FIXME Needs a better/correct name\n #[instrument(skip(ecx), level = \"debug\")]\n-fn fill_place_recursively<'tcx>(\n+fn valtree_into_mplace<'tcx>(\n     ecx: &mut CompileTimeEvalContext<'tcx, 'tcx>,\n     place: &mut MPlaceTy<'tcx>,\n     valtree: ty::ValTree<'tcx>,\n@@ -349,7 +370,7 @@ fn fill_place_recursively<'tcx>(\n             let mut pointee_place = create_pointee_place(ecx, *inner_ty, valtree);\n             debug!(?pointee_place);\n \n-            fill_place_recursively(ecx, &mut pointee_place, valtree);\n+            valtree_into_mplace(ecx, &mut pointee_place, valtree);\n             dump_place(ecx, pointee_place.into());\n             intern_const_alloc_recursive(ecx, InternKind::Constant, &pointee_place).unwrap();\n \n@@ -437,7 +458,7 @@ fn fill_place_recursively<'tcx>(\n                 };\n \n                 debug!(?place_inner);\n-                fill_place_recursively(ecx, &mut place_inner, *inner_valtree);\n+                valtree_into_mplace(ecx, &mut place_inner, *inner_valtree);\n                 dump_place(&ecx, place_inner.into());\n             }\n "}, {"sha": "62f9c8f990d709bad5d6248ca44bea4968507b50", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -115,12 +115,6 @@ impl<'tcx, Tag: Provenance> std::ops::Deref for MPlaceTy<'tcx, Tag> {\n     }\n }\n \n-impl<'tcx, Tag: Provenance> std::ops::DerefMut for MPlaceTy<'tcx, Tag> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        &mut self.mplace\n-    }\n-}\n-\n impl<'tcx, Tag: Provenance> From<MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n     #[inline(always)]\n     fn from(mplace: MPlaceTy<'tcx, Tag>) -> Self {\n@@ -196,6 +190,18 @@ impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n         MPlaceTy { mplace: MemPlace::from_ptr(ptr, layout.align.abi), layout }\n     }\n \n+    #[inline]\n+    pub fn from_aligned_ptr_with_meta(\n+        ptr: Pointer<Option<Tag>>,\n+        layout: TyAndLayout<'tcx>,\n+        meta: MemPlaceMeta<Tag>,\n+    ) -> Self {\n+        let mut mplace = MemPlace::from_ptr(ptr, layout.align.abi);\n+        mplace.meta = meta;\n+\n+        MPlaceTy { mplace, layout }\n+    }\n+\n     #[inline]\n     pub(crate) fn len(&self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n         if self.layout.is_unsized() {\n@@ -495,7 +501,7 @@ where\n \n     /// Project into an mplace\n     #[instrument(skip(self), level = \"debug\")]\n-    pub(crate) fn mplace_projection(\n+    pub(super) fn mplace_projection(\n         &self,\n         base: &MPlaceTy<'tcx, M::PointerTag>,\n         proj_elem: mir::PlaceElem<'tcx>,"}, {"sha": "8b6689ca213ab0772acac31065e71b3eb1ecf8a9", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -34,26 +34,32 @@ pub mod transform;\n pub mod util;\n \n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::ParamEnv;\n \n pub fn provide(providers: &mut Providers) {\n     const_eval::provide(providers);\n     providers.eval_to_const_value_raw = const_eval::eval_to_const_value_raw_provider;\n     providers.eval_to_allocation_raw = const_eval::eval_to_allocation_raw_provider;\n     providers.const_caller_location = const_eval::const_caller_location;\n-    providers.try_destructure_const = |tcx, param_env_and_value| {\n-        let (param_env, value) = param_env_and_value.into_parts();\n-        const_eval::try_destructure_const(tcx, param_env, value).ok()\n+    providers.try_destructure_const = |tcx, param_env_and_val| {\n+        let (param_env, c) = param_env_and_val.into_parts();\n+        const_eval::try_destructure_const(tcx, param_env, c).ok()\n     };\n-    providers.const_to_valtree = |tcx, param_env_and_value| {\n+    providers.eval_to_valtree = |tcx, param_env_and_value| {\n         let (param_env, raw) = param_env_and_value.into_parts();\n-        const_eval::const_to_valtree(tcx, param_env, raw)\n+        const_eval::eval_to_valtree(tcx, param_env, raw)\n     };\n-    providers.valtree_to_const_val = |tcx, (ty, valtree)| {\n-        const_eval::valtree_to_const_value(tcx, ParamEnv::empty().and(ty), valtree)\n+    providers.try_destructure_mir_constant = |tcx, param_env_and_value| {\n+        let (param_env, value) = param_env_and_value.into_parts();\n+        const_eval::try_destructure_mir_constant(tcx, param_env, value).ok()\n     };\n+    providers.valtree_to_const_val =\n+        |tcx, (ty, valtree)| const_eval::valtree_to_const_value(tcx, ty, valtree);\n     providers.deref_const = |tcx, param_env_and_value| {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::deref_const(tcx, param_env, value)\n     };\n+    providers.deref_mir_constant = |tcx, param_env_and_value| {\n+        let (param_env, value) = param_env_and_value.into_parts();\n+        const_eval::deref_mir_constant(tcx, param_env, value)\n+    };\n }"}, {"sha": "bb6b10149ab49de8b9d2d72b97aa6c782432719d", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -1,7 +1,7 @@\n use super::{AllocId, ConstAlloc, Pointer, Scalar};\n \n use crate::mir::interpret::ConstValue;\n-use crate::ty::{layout, query::TyCtxtAt, tls, FnSig, Ty};\n+use crate::ty::{layout, query::TyCtxtAt, tls, FnSig, Ty, ValTree};\n \n use rustc_data_structures::sync::Lock;\n use rustc_errors::{pluralize, struct_span_err, DiagnosticBuilder, ErrorGuaranteed};\n@@ -35,6 +35,7 @@ TrivialTypeFoldableAndLiftImpls! {\n \n pub type EvalToAllocationRawResult<'tcx> = Result<ConstAlloc<'tcx>, ErrorHandled>;\n pub type EvalToConstValueResult<'tcx> = Result<ConstValue<'tcx>, ErrorHandled>;\n+pub type EvalToValTreeResult<'tcx> = Result<Option<ValTree<'tcx>>, ErrorHandled>;\n \n pub fn struct_error<'tcx>(\n     tcx: TyCtxtAt<'tcx>,"}, {"sha": "0fa4b10399a4b081dbb426960949e698853698a4", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -119,9 +119,9 @@ use crate::ty::{self, Instance, Ty, TyCtxt};\n \n pub use self::error::{\n     struct_error, CheckInAllocMsg, ErrorHandled, EvalToAllocationRawResult, EvalToConstValueResult,\n-    InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType,\n-    ResourceExhaustionInfo, ScalarSizeMismatch, UndefinedBehaviorInfo, UninitBytesAccess,\n-    UnsupportedOpInfo,\n+    EvalToValTreeResult, InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo,\n+    MachineStopType, ResourceExhaustionInfo, ScalarSizeMismatch, UndefinedBehaviorInfo,\n+    UninitBytesAccess, UnsupportedOpInfo,\n };\n \n pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar, ScalarMaybeUninit};"}, {"sha": "5fb8e911124d26dbb5f2d9887caea4d4a944d3b8", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -110,11 +110,22 @@ impl<'tcx> TyCtxt<'tcx> {\n         Ok(self.global_alloc(raw_const.alloc_id).unwrap_memory())\n     }\n \n-    /// Destructure a constant ADT or array into its variant index and its field values.\n+    /// Destructure a type-level constant ADT or array into its variant index and its field values.\n+    /// Panics if the destructuring fails, use `try_destructure_const` for fallible version.\n     pub fn destructure_const(\n         self,\n         param_env_and_val: ty::ParamEnvAnd<'tcx, ty::Const<'tcx>>,\n     ) -> mir::DestructuredConst<'tcx> {\n         self.try_destructure_const(param_env_and_val).unwrap()\n     }\n+\n+    /// Destructure a mir constant ADT or array into its variant index and its field values.\n+    /// Panics if the destructuring fails, use `try_destructure_const` for fallible version.\n+    pub fn destructure_mir_constant(\n+        self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        constant: mir::ConstantKind<'tcx>,\n+    ) -> mir::DestructuredMirConstant<'tcx> {\n+        self.try_destructure_mir_constant(param_env.and(constant)).unwrap()\n+    }\n }"}, {"sha": "7b68b1d755df7a40ef83b7fd7908b38e9c5ab18f", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -3,7 +3,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/mir/index.html\n \n use crate::mir::coverage::{CodeRegion, CoverageKind};\n-use crate::mir::interpret::{ConstAllocation, ConstValue, GlobalAlloc, Scalar};\n+use crate::mir::interpret::{ConstAllocation, ConstValue, GlobalAlloc, LitToConstInput, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n@@ -3075,6 +3075,58 @@ impl<'tcx> ConstantKind<'tcx> {\n         Self::from_opt_const_arg_anon_const(tcx, ty::WithOptConstParam::unknown(def_id), param_env)\n     }\n \n+    #[instrument(skip(tcx), level = \"debug\")]\n+    pub fn from_inline_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        let body_id = match tcx.hir().get(hir_id) {\n+            hir::Node::AnonConst(ac) => ac.body,\n+            _ => span_bug!(\n+                tcx.def_span(def_id.to_def_id()),\n+                \"from_inline_const can only process anonymous constants\"\n+            ),\n+        };\n+        let expr = &tcx.hir().body(body_id).value;\n+        let ty = tcx.typeck(def_id).node_type(hir_id);\n+\n+        let lit_input = match expr.kind {\n+            hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n+            hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => match expr.kind {\n+                hir::ExprKind::Lit(ref lit) => {\n+                    Some(LitToConstInput { lit: &lit.node, ty, neg: true })\n+                }\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+        if let Some(lit_input) = lit_input {\n+            // If an error occurred, ignore that it's a literal and leave reporting the error up to\n+            // mir.\n+            match tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n+                Ok(c) => return c,\n+                Err(_) => {}\n+            }\n+        }\n+\n+        let typeck_root_def_id = tcx.typeck_root_def_id(def_id.to_def_id());\n+        let parent_substs =\n+            tcx.erase_regions(InternalSubsts::identity_for_item(tcx, typeck_root_def_id));\n+        let substs =\n+            ty::InlineConstSubsts::new(tcx, ty::InlineConstSubstsParts { parent_substs, ty })\n+                .substs;\n+        let uneval_const = tcx.mk_const(ty::ConstS {\n+            val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n+                def: ty::WithOptConstParam::unknown(def_id).to_global(),\n+                substs,\n+                promoted: None,\n+            }),\n+            ty,\n+        });\n+        debug!(?uneval_const);\n+        debug_assert!(!uneval_const.has_free_regions());\n+\n+        Self::Ty(uneval_const)\n+    }\n+\n     #[instrument(skip(tcx), level = \"debug\")]\n     fn from_opt_const_arg_anon_const(\n         tcx: TyCtxt<'tcx>,"}, {"sha": "7f7b8bdfc146172209da89890e85074c29d413e7", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -1,6 +1,6 @@\n //! Values computed by queries that use MIR.\n \n-use crate::mir::{Body, Promoted};\n+use crate::mir::{self, Body, Promoted};\n use crate::ty::{self, OpaqueHiddenType, Ty, TyCtxt};\n use rustc_data_structures::stable_map::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n@@ -413,13 +413,20 @@ pub enum ClosureOutlivesSubject<'tcx> {\n     Region(ty::RegionVid),\n }\n \n-/// The constituent parts of an ADT or array.\n+/// The constituent parts of a type level constant of kind ADT or array.\n #[derive(Copy, Clone, Debug, HashStable)]\n pub struct DestructuredConst<'tcx> {\n     pub variant: Option<VariantIdx>,\n     pub fields: &'tcx [ty::Const<'tcx>],\n }\n \n+/// The constituent parts of a mir constant of kind ADT or array.\n+#[derive(Copy, Clone, Debug, HashStable)]\n+pub struct DestructuredMirConstant<'tcx> {\n+    pub variant: Option<VariantIdx>,\n+    pub fields: &'tcx [mir::ConstantKind<'tcx>],\n+}\n+\n /// Coverage information summarized from a MIR if instrumented for source code coverage (see\n /// compiler option `-Cinstrument-coverage`). This information is generated by the\n /// `InstrumentCoverage` MIR pass and can be retrieved via the `coverageinfo` query."}, {"sha": "6432c653f1ce72516f93f807cd2ace1bfe291e29", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -946,12 +946,12 @@ rustc_queries! {\n         cache_on_disk_if { true }\n     }\n \n-    /// Convert an evaluated constant to a type level constant or\n+    /// Evaluate a constant and convert it to a type level constant or\n     /// return `None` if that is not possible.\n-    query const_to_valtree(\n-        key: ty::ParamEnvAnd<'tcx, ConstAlloc<'tcx>>\n-    ) -> Option<ty::ValTree<'tcx>> {\n-        desc { \"destructure constant\" }\n+    query eval_to_valtree(\n+        key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>\n+    ) -> EvalToValTreeResult<'tcx> {\n+        desc { \"evaluate type-level constant\" }\n         remap_env_constness\n     }\n \n@@ -964,10 +964,14 @@ rustc_queries! {\n     /// field values or return `None` if constant is invalid.\n     ///\n     /// Use infallible `TyCtxt::destructure_const` when you know that constant is valid.\n-    query try_destructure_const(\n-        key: ty::ParamEnvAnd<'tcx, ty::Const<'tcx>>\n-    ) -> Option<mir::DestructuredConst<'tcx>> {\n-        desc { \"destructure constant\" }\n+    query try_destructure_const(key: ty::ParamEnvAnd<'tcx, ty::Const<'tcx>>) -> Option<mir::DestructuredConst<'tcx>> {\n+        desc { \"destructure type level constant\"}\n+    }\n+\n+    /// Tries to destructure an `mir::ConstantKind` ADT or array into its variant index\n+    /// and its field values.\n+    query try_destructure_mir_constant(key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>) -> Option<mir::DestructuredMirConstant<'tcx>> {\n+        desc { \"destructure mir constant\"}\n         remap_env_constness\n     }\n \n@@ -980,6 +984,15 @@ rustc_queries! {\n         remap_env_constness\n     }\n \n+    /// Dereference a constant reference or raw pointer and turn the result into a constant\n+    /// again.\n+    query deref_mir_constant(\n+        key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>\n+    ) -> mir::ConstantKind<'tcx> {\n+        desc { \"deref constant\" }\n+        remap_env_constness\n+    }\n+\n     query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> ConstValue<'tcx> {\n         desc { \"get a &core::panic::Location referring to a span\" }\n     }\n@@ -991,6 +1004,10 @@ rustc_queries! {\n         desc { \"converting literal to const\" }\n     }\n \n+    query lit_to_mir_constant(key: LitToConstInput<'tcx>) -> Result<mir::ConstantKind<'tcx>, LitToConstError> {\n+        desc { \"converting literal to mir constant\" }\n+    }\n+\n     query check_match(key: DefId) {\n         desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }"}, {"sha": "26e070af76406a046c6bfb996379a1c98a89ba1e", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -662,7 +662,7 @@ pub enum PatKind<'tcx> {\n     /// * Opaque constants, that must not be matched structurally. So anything that does not derive\n     ///   `PartialEq` and `Eq`.\n     Constant {\n-        value: ty::Const<'tcx>,\n+        value: mir::ConstantKind<'tcx>,\n     },\n \n     Range(PatRange<'tcx>),\n@@ -692,8 +692,8 @@ pub enum PatKind<'tcx> {\n \n #[derive(Copy, Clone, Debug, PartialEq, HashStable)]\n pub struct PatRange<'tcx> {\n-    pub lo: ty::Const<'tcx>,\n-    pub hi: ty::Const<'tcx>,\n+    pub lo: mir::ConstantKind<'tcx>,\n+    pub hi: mir::ConstantKind<'tcx>,\n     pub end: RangeEnd,\n }\n "}, {"sha": "0398a83e22020006ec3e3eef2bebb543c7bfed16", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -13,8 +13,10 @@ use crate::middle::resolve_lifetime::{\n use crate::middle::stability::{self, DeprecationEntry};\n use crate::mir;\n use crate::mir::interpret::GlobalId;\n-use crate::mir::interpret::{ConstAlloc, LitToConstError, LitToConstInput};\n-use crate::mir::interpret::{ConstValue, EvalToAllocationRawResult, EvalToConstValueResult};\n+use crate::mir::interpret::{\n+    ConstValue, EvalToAllocationRawResult, EvalToConstValueResult, EvalToValTreeResult,\n+};\n+use crate::mir::interpret::{LitToConstError, LitToConstInput};\n use crate::mir::mono::CodegenUnit;\n use crate::thir;\n use crate::traits::query::{"}, {"sha": "55f08b5678aa32728acd9907a281b656fa38ad59", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -6,7 +6,7 @@ use crate::ty::layout::IntegerExt;\n use crate::ty::query::TyCtxtAt;\n use crate::ty::subst::{GenericArgKind, Subst, SubstsRef};\n use crate::ty::{\n-    self, Const, DebruijnIndex, DefIdTree, EarlyBinder, List, ReEarlyBound, Ty, TyCtxt, TyKind::*,\n+    self, DebruijnIndex, DefIdTree, EarlyBinder, List, ReEarlyBound, Ty, TyCtxt, TyKind::*,\n     TypeFoldable,\n };\n use rustc_apfloat::Float as _;\n@@ -690,7 +690,7 @@ impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n impl<'tcx> Ty<'tcx> {\n     /// Returns the maximum value for the given numeric type (including `char`s)\n     /// or returns `None` if the type is not numeric.\n-    pub fn numeric_max_val(self, tcx: TyCtxt<'tcx>) -> Option<Const<'tcx>> {\n+    pub fn numeric_max_val(self, tcx: TyCtxt<'tcx>) -> Option<ty::Const<'tcx>> {\n         let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n                 let (size, signed) = int_size_and_signed(tcx, self);\n@@ -705,12 +705,13 @@ impl<'tcx> Ty<'tcx> {\n             }),\n             _ => None,\n         };\n-        val.map(|v| Const::from_bits(tcx, v, ty::ParamEnv::empty().and(self)))\n+\n+        val.map(|v| ty::Const::from_bits(tcx, v, ty::ParamEnv::empty().and(self)))\n     }\n \n     /// Returns the minimum value for the given numeric type (including `char`s)\n     /// or returns `None` if the type is not numeric.\n-    pub fn numeric_min_val(self, tcx: TyCtxt<'tcx>) -> Option<Const<'tcx>> {\n+    pub fn numeric_min_val(self, tcx: TyCtxt<'tcx>) -> Option<ty::Const<'tcx>> {\n         let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n                 let (size, signed) = int_size_and_signed(tcx, self);\n@@ -724,7 +725,8 @@ impl<'tcx> Ty<'tcx> {\n             }),\n             _ => None,\n         };\n-        val.map(|v| Const::from_bits(tcx, v, ty::ParamEnv::empty().and(self)))\n+\n+        val.map(|v| ty::Const::from_bits(tcx, v, ty::ParamEnv::empty().and(self)))\n     }\n \n     /// Checks whether values of this type `T` are *moved* or *copied*"}, {"sha": "25ba5d570b83b11083a853a0d0e3a0cb5cf8a5b0", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 56, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -1,16 +1,12 @@\n //! See docs in build/expr/mod.rs\n \n-use crate::build::Builder;\n-use crate::thir::constant::parse_float;\n-use rustc_ast as ast;\n+use crate::build::{lit_to_mir_constant, Builder};\n use rustc_hir::def_id::DefId;\n-use rustc_middle::mir::interpret::Allocation;\n use rustc_middle::mir::interpret::{ConstValue, LitToConstError, LitToConstInput, Scalar};\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt};\n-use rustc_target::abi::Size;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n@@ -88,54 +84,3 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n }\n-\n-#[instrument(skip(tcx, lit_input))]\n-fn lit_to_mir_constant<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    lit_input: LitToConstInput<'tcx>,\n-) -> Result<ConstantKind<'tcx>, LitToConstError> {\n-    let LitToConstInput { lit, ty, neg } = lit_input;\n-    let trunc = |n| {\n-        let param_ty = ty::ParamEnv::reveal_all().and(ty);\n-        let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n-        trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n-        let result = width.truncate(n);\n-        trace!(\"trunc result: {}\", result);\n-        Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n-    };\n-\n-    let value = match (lit, &ty.kind()) {\n-        (ast::LitKind::Str(s, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_str() => {\n-            let s = s.as_str();\n-            let allocation = Allocation::from_bytes_byte_aligned_immutable(s.as_bytes());\n-            let allocation = tcx.intern_const_alloc(allocation);\n-            ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n-        }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n-            if matches!(inner_ty.kind(), ty::Slice(_)) =>\n-        {\n-            let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n-            let allocation = tcx.intern_const_alloc(allocation);\n-            ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n-        }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n-            let id = tcx.allocate_bytes(data);\n-            ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n-        }\n-        (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n-            ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))\n-        }\n-        (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n-            trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?\n-        }\n-        (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n-            parse_float(*n, *fty, neg).ok_or(LitToConstError::Reported)?\n-        }\n-        (ast::LitKind::Bool(b), ty::Bool) => ConstValue::Scalar(Scalar::from_bool(*b)),\n-        (ast::LitKind::Char(c), ty::Char) => ConstValue::Scalar(Scalar::from_char(*c)),\n-        (ast::LitKind::Err(_), _) => return Err(LitToConstError::Reported),\n-        _ => return Err(LitToConstError::TypeError),\n-    };\n-\n-    Ok(ConstantKind::Val(value, ty))\n-}"}, {"sha": "05b1342cf8c0783c3e7036500f0e6dc80d69a813", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -966,13 +966,13 @@ enum TestKind<'tcx> {\n         ///\n         /// For `bool` we always generate two edges, one for `true` and one for\n         /// `false`.\n-        options: FxIndexMap<ty::Const<'tcx>, u128>,\n+        options: FxIndexMap<ConstantKind<'tcx>, u128>,\n     },\n \n     /// Test for equality with value, possibly after an unsizing coercion to\n     /// `ty`,\n     Eq {\n-        value: ty::Const<'tcx>,\n+        value: ConstantKind<'tcx>,\n         // Integer types are handled by `SwitchInt`, and constants with ADT\n         // types are converted back into patterns, so this can only be `&str`,\n         // `&[T]`, `f32` or `f64`."}, {"sha": "895df5808dbe16c6eb0cbb2abbeecab6d35c9598", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -228,9 +228,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     _ => (None, 0),\n                 };\n                 if let Some((min, max, sz)) = range {\n-                    if let (Some(lo), Some(hi)) =\n-                        (lo.val().try_to_bits(sz), hi.val().try_to_bits(sz))\n-                    {\n+                    if let (Some(lo), Some(hi)) = (lo.try_to_bits(sz), hi.try_to_bits(sz)) {\n                         // We want to compare ranges numerically, but the order of the bitwise\n                         // representation of signed integers does not match their numeric order.\n                         // Thus, to correct the ordering, we need to shift the range of signed"}, {"sha": "565345595d5002d7092886d64295b32aa6331588", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         test_place: &PlaceBuilder<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n         switch_ty: Ty<'tcx>,\n-        options: &mut FxIndexMap<ty::Const<'tcx>, u128>,\n+        options: &mut FxIndexMap<ConstantKind<'tcx>, u128>,\n     ) -> bool {\n         let Some(match_pair) = candidate.match_pairs.iter().find(|mp| mp.place == *test_place) else {\n             return false;\n@@ -366,7 +366,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         block: BasicBlock,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n         source_info: SourceInfo,\n-        value: ty::Const<'tcx>,\n+        value: ConstantKind<'tcx>,\n         place: Place<'tcx>,\n         mut ty: Ty<'tcx>,\n     ) {\n@@ -760,7 +760,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span_bug!(match_pair.pattern.span, \"simplifyable pattern found: {:?}\", match_pair.pattern)\n     }\n \n-    fn const_range_contains(&self, range: PatRange<'tcx>, value: ty::Const<'tcx>) -> Option<bool> {\n+    fn const_range_contains(\n+        &self,\n+        range: PatRange<'tcx>,\n+        value: ConstantKind<'tcx>,\n+    ) -> Option<bool> {\n         use std::cmp::Ordering::*;\n \n         let tcx = self.tcx;\n@@ -777,7 +781,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn values_not_contained_in_range(\n         &self,\n         range: PatRange<'tcx>,\n-        options: &FxIndexMap<ty::Const<'tcx>, u128>,\n+        options: &FxIndexMap<ConstantKind<'tcx>, u128>,\n     ) -> Option<bool> {\n         for &val in options.keys() {\n             if self.const_range_contains(range, val)? {"}, {"sha": "8b1ab482ee8be109c1aa2eb8727f1eec592631b9", "filename": "compiler/rustc_mir_build/src/build/misc.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -3,7 +3,6 @@\n \n use crate::build::Builder;\n \n-use rustc_middle::mir;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::{Span, DUMMY_SP};\n@@ -26,11 +25,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience function for creating a literal operand, one\n     /// without any user type annotation.\n-    crate fn literal_operand(\n-        &mut self,\n-        span: Span,\n-        literal: mir::ConstantKind<'tcx>,\n-    ) -> Operand<'tcx> {\n+    crate fn literal_operand(&mut self, span: Span, literal: ConstantKind<'tcx>) -> Operand<'tcx> {\n         let constant = Box::new(Constant { span, user_ty: None, literal });\n         Operand::Constant(constant)\n     }"}, {"sha": "1cbe8c5a68af4120367de86ed94a3417f8d3d737", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -1,7 +1,9 @@\n use crate::build;\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n+use crate::thir::constant::parse_float;\n use crate::thir::pattern::pat_from_hir;\n+use rustc_ast as ast;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -11,12 +13,15 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::middle::region;\n+use rustc_middle::mir::interpret::Allocation;\n+use rustc_middle::mir::interpret::{ConstValue, LitToConstError, LitToConstInput, Scalar};\n use rustc_middle::mir::*;\n use rustc_middle::thir::{BindingMode, Expr, ExprId, LintLevel, PatKind, Thir};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeckResults};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n+use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n use super::lints;\n@@ -260,6 +265,57 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n     })\n }\n \n+#[instrument(skip(tcx, lit_input))]\n+pub(crate) fn lit_to_mir_constant<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    lit_input: LitToConstInput<'tcx>,\n+) -> Result<ConstantKind<'tcx>, LitToConstError> {\n+    let LitToConstInput { lit, ty, neg } = lit_input;\n+    let trunc = |n| {\n+        let param_ty = ty::ParamEnv::reveal_all().and(ty);\n+        let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n+        trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n+        let result = width.truncate(n);\n+        trace!(\"trunc result: {}\", result);\n+        Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n+    };\n+\n+    let value = match (lit, &ty.kind()) {\n+        (ast::LitKind::Str(s, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_str() => {\n+            let s = s.as_str();\n+            let allocation = Allocation::from_bytes_byte_aligned_immutable(s.as_bytes());\n+            let allocation = tcx.intern_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n+        }\n+        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n+            if matches!(inner_ty.kind(), ty::Slice(_)) =>\n+        {\n+            let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n+            let allocation = tcx.intern_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n+        }\n+        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n+            let id = tcx.allocate_bytes(data);\n+            ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n+        }\n+        (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n+            ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))\n+        }\n+        (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n+            trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?\n+        }\n+        (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n+            parse_float(*n, *fty, neg).ok_or(LitToConstError::Reported)?\n+        }\n+        (ast::LitKind::Bool(b), ty::Bool) => ConstValue::Scalar(Scalar::from_bool(*b)),\n+        (ast::LitKind::Char(c), ty::Char) => ConstValue::Scalar(Scalar::from_char(*c)),\n+        (ast::LitKind::Err(_), _) => return Err(LitToConstError::Reported),\n+        _ => return Err(LitToConstError::TypeError),\n+    };\n+\n+    Ok(ConstantKind::Val(value, ty))\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n "}, {"sha": "4f0402bfa8bc791ec75de7e6400cc0f59b51a086", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -27,6 +27,7 @@ use rustc_middle::ty::query::Providers;\n pub fn provide(providers: &mut Providers) {\n     providers.check_match = thir::pattern::check_match;\n     providers.lit_to_const = thir::constant::lit_to_const;\n+    providers.lit_to_mir_constant = build::lit_to_mir_constant;\n     providers.mir_built = build::mir_built;\n     providers.thir_check_unsafety = check_unsafety::thir_check_unsafety;\n     providers.thir_check_unsafety_for_const_arg = check_unsafety::thir_check_unsafety_for_const_arg;"}, {"sha": "aafc368d3fdaaded6bbf3cd778ab358ced8dad78", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -5,15 +5,18 @@\n use crate::thir::pattern::pat_from_hir;\n use crate::thir::util::UserAnnotatedTyHelpers;\n \n+use rustc_ast as ast;\n use rustc_data_structures::steal::Steal;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::HirId;\n use rustc_hir::Node;\n use rustc_middle::middle::region;\n+use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n+use rustc_middle::mir::ConstantKind;\n use rustc_middle::thir::*;\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n \n crate fn thir_body<'tcx>(\n@@ -75,6 +78,24 @@ impl<'tcx> Cx<'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n+    crate fn const_eval_literal(\n+        &mut self,\n+        lit: &'tcx ast::LitKind,\n+        ty: Ty<'tcx>,\n+        sp: Span,\n+        neg: bool,\n+    ) -> ConstantKind<'tcx> {\n+        match self.tcx.at(sp).lit_to_mir_constant(LitToConstInput { lit, ty, neg }) {\n+            Ok(c) => c,\n+            Err(LitToConstError::Reported) => {\n+                // create a dummy value and continue compiling\n+                ConstantKind::Ty(self.tcx.const_error(ty))\n+            }\n+            Err(LitToConstError::TypeError) => bug!(\"const_eval_literal: had type error\"),\n+        }\n+    }\n+\n     crate fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Pat<'tcx> {\n         let p = match self.tcx.hir().get(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,"}, {"sha": "880f86aff5d01acdf4b8f807dba494c351861275", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -1,7 +1,7 @@\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n-use rustc_middle::mir::Field;\n+use rustc_middle::mir::{self, Field};\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n@@ -22,7 +22,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn const_to_pat(\n         &self,\n-        cv: ty::Const<'tcx>,\n+        cv: mir::ConstantKind<'tcx>,\n         id: hir::HirId,\n         span: Span,\n         mir_structural_match_violation: bool,\n@@ -152,7 +152,11 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         ty.is_structural_eq_shallow(self.infcx.tcx)\n     }\n \n-    fn to_pat(&mut self, cv: ty::Const<'tcx>, mir_structural_match_violation: bool) -> Pat<'tcx> {\n+    fn to_pat(\n+        &mut self,\n+        cv: mir::ConstantKind<'tcx>,\n+        mir_structural_match_violation: bool,\n+    ) -> Pat<'tcx> {\n         trace!(self.treat_byte_string_as_slice);\n         // This method is just a wrapper handling a validity check; the heavy lifting is\n         // performed by the recursive `recur` method, which is not meant to be\n@@ -246,7 +250,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n \n     fn field_pats(\n         &self,\n-        vals: impl Iterator<Item = ty::Const<'tcx>>,\n+        vals: impl Iterator<Item = mir::ConstantKind<'tcx>>,\n     ) -> Result<Vec<FieldPat<'tcx>>, FallbackToConstRef> {\n         vals.enumerate()\n             .map(|(idx, val)| {\n@@ -257,9 +261,10 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     }\n \n     // Recursive helper for `to_pat`; invoke that (instead of calling this directly).\n+    #[instrument(skip(self), level = \"debug\")]\n     fn recur(\n         &self,\n-        cv: ty::Const<'tcx>,\n+        cv: mir::ConstantKind<'tcx>,\n         mir_structural_match_violation: bool,\n     ) -> Result<Pat<'tcx>, FallbackToConstRef> {\n         let id = self.id;\n@@ -365,7 +370,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n-                let destructured = tcx.destructure_const(param_env.and(cv));\n+                let destructured = tcx.destructure_mir_constant(param_env, cv);\n                 PatKind::Variant {\n                     adt_def: *adt_def,\n                     substs,\n@@ -376,12 +381,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 }\n             }\n             ty::Tuple(_) | ty::Adt(_, _) => {\n-                let destructured = tcx.destructure_const(param_env.and(cv));\n+                let destructured = tcx.destructure_mir_constant(param_env, cv);\n                 PatKind::Leaf { subpatterns: self.field_pats(destructured.fields.iter().copied())? }\n             }\n             ty::Array(..) => PatKind::Array {\n                 prefix: tcx\n-                    .destructure_const(param_env.and(cv))\n+                    .destructure_mir_constant(param_env, cv)\n                     .fields\n                     .iter()\n                     .map(|val| self.recur(*val, false))\n@@ -412,12 +417,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // arrays.\n                 ty::Array(..) if !self.treat_byte_string_as_slice => {\n                     let old = self.behind_reference.replace(true);\n-                    let array = tcx.deref_const(self.param_env.and(cv));\n+                    let array = tcx.deref_mir_constant(self.param_env.and(cv));\n                     let val = PatKind::Deref {\n                         subpattern: Pat {\n                             kind: Box::new(PatKind::Array {\n                                 prefix: tcx\n-                                    .destructure_const(param_env.and(array))\n+                                    .destructure_mir_constant(param_env, array)\n                                     .fields\n                                     .iter()\n                                     .map(|val| self.recur(*val, false))\n@@ -438,12 +443,12 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // pattern.\n                 ty::Slice(elem_ty) => {\n                     let old = self.behind_reference.replace(true);\n-                    let array = tcx.deref_const(self.param_env.and(cv));\n+                    let array = tcx.deref_mir_constant(self.param_env.and(cv));\n                     let val = PatKind::Deref {\n                         subpattern: Pat {\n                             kind: Box::new(PatKind::Slice {\n                                 prefix: tcx\n-                                    .destructure_const(param_env.and(array))\n+                                    .destructure_mir_constant(param_env, array)\n                                     .fields\n                                     .iter()\n                                     .map(|val| self.recur(*val, false))\n@@ -512,7 +517,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                         // we fall back to a const pattern. If we do not do this, we may end up with\n                         // a !structural-match constant that is not of reference type, which makes it\n                         // very hard to invoke `PartialEq::eq` on it as a fallback.\n-                        let val = match self.recur(tcx.deref_const(self.param_env.and(cv)), false) {\n+                        let val = match self.recur(tcx.deref_mir_constant(self.param_env.and(cv)), false) {\n                             Ok(subpattern) => PatKind::Deref { subpattern },\n                             Err(_) => PatKind::Constant { value: cv },\n                         };"}, {"sha": "b7de3f28872e5f100cb1cdaedcd5c1ec0bc44050", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -52,7 +52,7 @@ use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n \n use rustc_hir::{HirId, RangeEnd};\n-use rustc_middle::mir::Field;\n+use rustc_middle::mir::{self, Field};\n use rustc_middle::thir::{FieldPat, Pat, PatKind, PatRange};\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Ty, TyCtxt, VariantDef};\n@@ -133,23 +133,35 @@ impl IntRange {\n     }\n \n     #[inline]\n-    fn from_const<'tcx>(\n+    fn from_constant<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: ty::Const<'tcx>,\n+        value: mir::ConstantKind<'tcx>,\n     ) -> Option<IntRange> {\n         let ty = value.ty();\n         if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, ty) {\n             let val = (|| {\n-                if let ty::ConstKind::Value(ConstValue::Scalar(scalar)) = value.val() {\n-                    // For this specific pattern we can skip a lot of effort and go\n-                    // straight to the result, after doing a bit of checking. (We\n-                    // could remove this branch and just fall through, which\n-                    // is more general but much slower.)\n-                    if let Ok(bits) = scalar.to_bits_or_ptr_internal(target_size).unwrap() {\n-                        return Some(bits);\n+                match value {\n+                    mir::ConstantKind::Val(ConstValue::Scalar(scalar), _) => {\n+                        // For this specific pattern we can skip a lot of effort and go\n+                        // straight to the result, after doing a bit of checking. (We\n+                        // could remove this branch and just fall through, which\n+                        // is more general but much slower.)\n+                        if let Ok(Ok(bits)) = scalar.to_bits_or_ptr_internal(target_size) {\n+                            return Some(bits);\n+                        } else {\n+                            return None;\n+                        }\n                     }\n+                    mir::ConstantKind::Ty(c) => match c.val() {\n+                        ty::ConstKind::Value(_) => bug!(\n+                            \"encountered ConstValue in mir::ConstantKind::Ty, whereas this is expected to be in ConstantKind::Val\"\n+                        ),\n+                        _ => {}\n+                    },\n+                    _ => {}\n                 }\n+\n                 // This is a more general form of the previous case.\n                 value.try_eval_bits(tcx, param_env, ty)\n             })()?;\n@@ -234,8 +246,8 @@ impl IntRange {\n         let (lo, hi) = (lo ^ bias, hi ^ bias);\n \n         let env = ty::ParamEnv::empty().and(ty);\n-        let lo_const = ty::Const::from_bits(tcx, lo, env);\n-        let hi_const = ty::Const::from_bits(tcx, hi, env);\n+        let lo_const = mir::ConstantKind::from_bits(tcx, lo, env);\n+        let hi_const = mir::ConstantKind::from_bits(tcx, hi, env);\n \n         let kind = if lo == hi {\n             PatKind::Constant { value: lo_const }\n@@ -635,9 +647,9 @@ pub(super) enum Constructor<'tcx> {\n     /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n     IntRange(IntRange),\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n-    FloatRange(ty::Const<'tcx>, ty::Const<'tcx>, RangeEnd),\n+    FloatRange(mir::ConstantKind<'tcx>, mir::ConstantKind<'tcx>, RangeEnd),\n     /// String literals. Strings are not quite the same as `&[u8]` so we treat them separately.\n-    Str(ty::Const<'tcx>),\n+    Str(mir::ConstantKind<'tcx>),\n     /// Array and slice patterns.\n     Slice(Slice),\n     /// Constants that must not be matched structurally. They are treated as black\n@@ -1376,7 +1388,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                 }\n             }\n             PatKind::Constant { value } => {\n-                if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, *value) {\n+                if let Some(int_range) = IntRange::from_constant(cx.tcx, cx.param_env, *value) {\n                     ctor = IntRange(int_range);\n                     fields = Fields::empty();\n                 } else {"}, {"sha": "55d84782c485eb62f47c595bf35832d81965abff", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -17,7 +17,7 @@ use rustc_hir::RangeEnd;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{get_slice_bytes, ConstValue};\n use rustc_middle::mir::interpret::{ErrorHandled, LitToConstError, LitToConstInput};\n-use rustc_middle::mir::UserTypeProjection;\n+use rustc_middle::mir::{self, UserTypeProjection};\n use rustc_middle::mir::{BorrowKind, Field, Mutability};\n use rustc_middle::thir::{Ascription, BindingMode, FieldPat, Pat, PatKind, PatRange, PatTyProj};\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n@@ -121,8 +121,8 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     fn lower_pattern_range(\n         &mut self,\n         ty: Ty<'tcx>,\n-        lo: ty::Const<'tcx>,\n-        hi: ty::Const<'tcx>,\n+        lo: mir::ConstantKind<'tcx>,\n+        hi: mir::ConstantKind<'tcx>,\n         end: RangeEnd,\n         span: Span,\n     ) -> PatKind<'tcx> {\n@@ -177,16 +177,18 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         lo: Option<&PatKind<'tcx>>,\n         hi: Option<&PatKind<'tcx>>,\n-    ) -> Option<(ty::Const<'tcx>, ty::Const<'tcx>)> {\n+    ) -> Option<(mir::ConstantKind<'tcx>, mir::ConstantKind<'tcx>)> {\n         match (lo, hi) {\n             (Some(PatKind::Constant { value: lo }), Some(PatKind::Constant { value: hi })) => {\n                 Some((*lo, *hi))\n             }\n             (Some(PatKind::Constant { value: lo }), None) => {\n-                Some((*lo, ty.numeric_max_val(self.tcx)?))\n+                let hi = ty.numeric_max_val(self.tcx)?;\n+                Some((*lo, hi.into()))\n             }\n             (None, Some(PatKind::Constant { value: hi })) => {\n-                Some((ty.numeric_min_val(self.tcx)?, *hi))\n+                let lo = ty.numeric_min_val(self.tcx)?;\n+                Some((lo.into(), *hi))\n             }\n             _ => None,\n         }\n@@ -446,6 +448,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// Takes a HIR Path. If the path is a constant, evaluates it and feeds\n     /// it to `const_to_pat`. Any other path (like enum variants without fields)\n     /// is converted to the corresponding pattern via `lower_variant_or_leaf`.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn lower_path(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) -> Pat<'tcx> {\n         let ty = self.typeck_results.node_type(id);\n         let res = self.typeck_results.qpath_res(qpath, id);\n@@ -487,8 +490,8 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         debug!(\"mir_structural_match_violation({:?}) -> {}\", qpath, mir_structural_match_violation);\n \n         match self.tcx.const_eval_instance(param_env_reveal_all, instance, Some(span)) {\n-            Ok(value) => {\n-                let const_ = ty::Const::from_value(self.tcx, value, ty);\n+            Ok(literal) => {\n+                let const_ = mir::ConstantKind::Val(literal, ty);\n                 let pattern = self.const_to_pat(const_, id, span, mir_structural_match_violation);\n \n                 if !is_associated_const {\n@@ -537,25 +540,30 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         span: Span,\n     ) -> PatKind<'tcx> {\n         let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n-        let value = ty::Const::from_inline_const(self.tcx, anon_const_def_id);\n+        let value = mir::ConstantKind::from_inline_const(self.tcx, anon_const_def_id);\n \n         // Evaluate early like we do in `lower_path`.\n         let value = value.eval(self.tcx, self.param_env);\n \n-        match value.val() {\n-            ConstKind::Param(_) => {\n-                self.errors.push(PatternError::ConstParamInPattern(span));\n-                return PatKind::Wild;\n-            }\n-            ConstKind::Unevaluated(_) => {\n-                // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n-                self.tcx.sess.span_err(span, \"constant pattern depends on a generic parameter\");\n-                return PatKind::Wild;\n+        match value {\n+            mir::ConstantKind::Ty(c) => {\n+                match c.val() {\n+                    ConstKind::Param(_) => {\n+                        self.errors.push(PatternError::ConstParamInPattern(span));\n+                        return PatKind::Wild;\n+                    }\n+                    ConstKind::Unevaluated(_) => {\n+                        // If we land here it means the const can't be evaluated because it's `TooGeneric`.\n+                        self.tcx\n+                            .sess\n+                            .span_err(span, \"constant pattern depends on a generic parameter\");\n+                        return PatKind::Wild;\n+                    }\n+                    _ => bug!(\"Expected either ConstKind::Param or ConstKind::Unevaluated\"),\n+                }\n             }\n-            _ => (),\n+            mir::ConstantKind::Val(_, _) => *self.const_to_pat(value, id, span, false).kind,\n         }\n-\n-        *self.const_to_pat(value, id, span, false).kind\n     }\n \n     /// Converts literals, paths and negation of literals to patterns.\n@@ -582,7 +590,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n         let lit_input =\n             LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n-        match self.tcx.at(expr.span).lit_to_const(lit_input) {\n+        match self.tcx.at(expr.span).lit_to_mir_constant(lit_input) {\n             Ok(constant) => *self.const_to_pat(constant, expr.hir_id, lit.span, false).kind,\n             Err(LitToConstError::Reported) => PatKind::Wild,\n             Err(LitToConstError::TypeError) => bug!(\"lower_lit: had type error\"),\n@@ -740,8 +748,8 @@ impl<'tcx> PatternFoldable<'tcx> for PatKind<'tcx> {\n #[instrument(skip(tcx), level = \"debug\")]\n crate fn compare_const_vals<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    a: ty::Const<'tcx>,\n-    b: ty::Const<'tcx>,\n+    a: mir::ConstantKind<'tcx>,\n+    b: mir::ConstantKind<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<Ordering> {\n@@ -754,9 +762,7 @@ crate fn compare_const_vals<'tcx>(\n         return fallback();\n     }\n \n-    // Early return for equal constants (so e.g. references to ZSTs can be compared, even if they\n-    // are just integer addresses).\n-    if a.val() == b.val() {\n+    if a == b {\n         return from_bool(true);\n     }\n \n@@ -788,9 +794,9 @@ crate fn compare_const_vals<'tcx>(\n     }\n \n     if let ty::Str = ty.kind() && let (\n-        ty::ConstKind::Value(a_val @ ConstValue::Slice { .. }),\n-        ty::ConstKind::Value(b_val @ ConstValue::Slice { .. }),\n-    ) = (a.val(), b.val())\n+        Some(a_val @ ConstValue::Slice { .. }),\n+        Some(b_val @ ConstValue::Slice { .. }),\n+    ) = (a.try_val(), b.try_val())\n     {\n         let a_bytes = get_slice_bytes(&tcx, a_val);\n         let b_bytes = get_slice_bytes(&tcx, b_val);"}, {"sha": "7c0d83516ea29d09450b99cbd96d3881f796e431", "filename": "src/test/ui/inline-const/const-match-pat-generic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.rs?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -6,7 +6,8 @@\n fn foo<const V: usize>() {\n     match 0 {\n         const { V } => {},\n-        //~^ ERROR const parameters cannot be referenced in patterns [E0158]\n+        //~^ ERROR constant pattern depends on a generic parameter\n+        //~| ERROR constant pattern depends on a generic parameter\n         _ => {},\n     }\n }"}, {"sha": "77267f12fb11a74ae5ece696413ba7c85bf491ed", "filename": "src/test/ui/inline-const/const-match-pat-generic.stderr", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cd282d7f75da9080fda0f1740a729516e7fbec68/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd282d7f75da9080fda0f1740a729516e7fbec68/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-match-pat-generic.stderr?ref=cd282d7f75da9080fda0f1740a729516e7fbec68", "patch": "@@ -1,21 +1,26 @@\n-error[E0158]: const parameters cannot be referenced in patterns\n+error: constant pattern depends on a generic parameter\n   --> $DIR/const-match-pat-generic.rs:8:9\n    |\n LL |         const { V } => {},\n    |         ^^^^^^^^^^^\n \n error: constant pattern depends on a generic parameter\n-  --> $DIR/const-match-pat-generic.rs:20:9\n+  --> $DIR/const-match-pat-generic.rs:21:9\n    |\n LL |         const { f(V) } => {},\n    |         ^^^^^^^^^^^^^^\n \n error: constant pattern depends on a generic parameter\n-  --> $DIR/const-match-pat-generic.rs:20:9\n+  --> $DIR/const-match-pat-generic.rs:8:9\n+   |\n+LL |         const { V } => {},\n+   |         ^^^^^^^^^^^\n+\n+error: constant pattern depends on a generic parameter\n+  --> $DIR/const-match-pat-generic.rs:21:9\n    |\n LL |         const { f(V) } => {},\n    |         ^^^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0158`."}]}