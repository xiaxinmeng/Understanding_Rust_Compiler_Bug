{"sha": "f19783dbb8b7ba6d7a76b199b4314c87ed1cb8c1", "node_id": "C_kwDOAAsO6NoAKGYxOTc4M2RiYjhiN2JhNmQ3YTc2YjE5OWI0MzE0Yzg3ZWQxY2I4YzE", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-08-30T23:47:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-30T23:47:21Z"}, "message": "Rollup merge of #101193 - thomcc:win-stdio-nozero, r=ChrisDenton\n\nAvoid zeroing large stack buffers in stdio on Windows\n\nDoes what it says on the tin, using `[MaybeUninit<u16>; N]` instead of `[0u16; N]`. These buffers seem to be around 8kb, which is big enough that this is likely to be a very nice perf boost to stdio-heavy windows code.\n\nr? ``@ChrisDenton``\n\n*(Note: this PR also has a commit that adds windows to CI, but as it mentions I'll revert that after it comes out green -- I can only do a check build on the machine I'm typing this on)*", "tree": {"sha": "f3745251dc9167d3305b3c48b188c042226ee171", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3745251dc9167d3305b3c48b188c042226ee171"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f19783dbb8b7ba6d7a76b199b4314c87ed1cb8c1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDqGJCRBK7hj4Ov3rIwAABaoIAKzZLH1jnaXINOj6yvjzI/+I\nsn81snKmQCOJY3dwdF2QnmhNOsQN6wRZ3hPc8ePfzqQY5ySILu/grGL34++powaS\nc99v67gbHYB98jSkZgGNpAvgettp9EZrX1Wk1EI/3b3eJ+Z84By5qs7jfcnZGN16\nb+CLzlWidmNbrvu4gvd0zPzBtFzpGg/sp3XaXQFGKfGIwQT1Q7yudJv5Rt2/U1Qm\nGoTpsExH25MvXFpvXQ2U85mPYPkwpOLejOmfFwP1sOgH+i02C9Zbxn0JydSVeCCx\nM7RvmoSpL7Ebn0z6Q5J6GkAlhXHP946YThie34R6SFfOYbW99MLfX0adEIiT9ug=\n=J6Or\n-----END PGP SIGNATURE-----\n", "payload": "tree f3745251dc9167d3305b3c48b188c042226ee171\nparent 42a1901cf43e145b3a90bac086cb844b94ffc7a1\nparent 1b8b2dc2ff9196ba4532c7d6f2775e2112bfc060\nauthor Yuki Okushi <jtitor@2k36.org> 1661903241 +0900\ncommitter GitHub <noreply@github.com> 1661903241 +0900\n\nRollup merge of #101193 - thomcc:win-stdio-nozero, r=ChrisDenton\n\nAvoid zeroing large stack buffers in stdio on Windows\n\nDoes what it says on the tin, using `[MaybeUninit<u16>; N]` instead of `[0u16; N]`. These buffers seem to be around 8kb, which is big enough that this is likely to be a very nice perf boost to stdio-heavy windows code.\n\nr? ``@ChrisDenton``\n\n*(Note: this PR also has a commit that adds windows to CI, but as it mentions I'll revert that after it comes out green -- I can only do a check build on the machine I'm typing this on)*\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f19783dbb8b7ba6d7a76b199b4314c87ed1cb8c1", "html_url": "https://github.com/rust-lang/rust/commit/f19783dbb8b7ba6d7a76b199b4314c87ed1cb8c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f19783dbb8b7ba6d7a76b199b4314c87ed1cb8c1/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42a1901cf43e145b3a90bac086cb844b94ffc7a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/42a1901cf43e145b3a90bac086cb844b94ffc7a1", "html_url": "https://github.com/rust-lang/rust/commit/42a1901cf43e145b3a90bac086cb844b94ffc7a1"}, {"sha": "1b8b2dc2ff9196ba4532c7d6f2775e2112bfc060", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b8b2dc2ff9196ba4532c7d6f2775e2112bfc060", "html_url": "https://github.com/rust-lang/rust/commit/1b8b2dc2ff9196ba4532c7d6f2775e2112bfc060"}], "stats": {"total": 41, "additions": 27, "deletions": 14}, "files": [{"sha": "70c9b14a08fa7f41deea5d3c48580e0269f734b5", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f19783dbb8b7ba6d7a76b199b4314c87ed1cb8c1/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f19783dbb8b7ba6d7a76b199b4314c87ed1cb8c1/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=f19783dbb8b7ba6d7a76b199b4314c87ed1cb8c1", "patch": "@@ -3,6 +3,7 @@\n use crate::char::decode_utf16;\n use crate::cmp;\n use crate::io;\n+use crate::mem::MaybeUninit;\n use crate::os::windows::io::{FromRawHandle, IntoRawHandle};\n use crate::ptr;\n use crate::str;\n@@ -169,13 +170,14 @@ fn write(\n }\n \n fn write_valid_utf8_to_console(handle: c::HANDLE, utf8: &str) -> io::Result<usize> {\n-    let mut utf16 = [0u16; MAX_BUFFER_SIZE / 2];\n+    let mut utf16 = [MaybeUninit::<u16>::uninit(); MAX_BUFFER_SIZE / 2];\n     let mut len_utf16 = 0;\n     for (chr, dest) in utf8.encode_utf16().zip(utf16.iter_mut()) {\n-        *dest = chr;\n+        *dest = MaybeUninit::new(chr);\n         len_utf16 += 1;\n     }\n-    let utf16 = &utf16[..len_utf16];\n+    // Safety: We've initialized `len_utf16` values.\n+    let utf16: &[u16] = unsafe { MaybeUninit::slice_assume_init_ref(&utf16[..len_utf16]) };\n \n     let mut written = write_u16s(handle, &utf16)?;\n \n@@ -250,27 +252,33 @@ impl io::Read for Stdin {\n             return Ok(bytes_copied);\n         } else if buf.len() - bytes_copied < 4 {\n             // Not enough space to get a UTF-8 byte. We will use the incomplete UTF8.\n-            let mut utf16_buf = [0u16; 1];\n+            let mut utf16_buf = [MaybeUninit::new(0); 1];\n             // Read one u16 character.\n             let read = read_u16s_fixup_surrogates(handle, &mut utf16_buf, 1, &mut self.surrogate)?;\n             // Read bytes, using the (now-empty) self.incomplete_utf8 as extra space.\n-            let read_bytes = utf16_to_utf8(&utf16_buf[..read], &mut self.incomplete_utf8.bytes)?;\n+            let read_bytes = utf16_to_utf8(\n+                unsafe { MaybeUninit::slice_assume_init_ref(&utf16_buf[..read]) },\n+                &mut self.incomplete_utf8.bytes,\n+            )?;\n \n             // Read in the bytes from incomplete_utf8 until the buffer is full.\n             self.incomplete_utf8.len = read_bytes as u8;\n             // No-op if no bytes.\n             bytes_copied += self.incomplete_utf8.read(&mut buf[bytes_copied..]);\n             Ok(bytes_copied)\n         } else {\n-            let mut utf16_buf = [0u16; MAX_BUFFER_SIZE / 2];\n+            let mut utf16_buf = [MaybeUninit::<u16>::uninit(); MAX_BUFFER_SIZE / 2];\n+\n             // In the worst case, a UTF-8 string can take 3 bytes for every `u16` of a UTF-16. So\n             // we can read at most a third of `buf.len()` chars and uphold the guarantee no data gets\n             // lost.\n             let amount = cmp::min(buf.len() / 3, utf16_buf.len());\n             let read =\n                 read_u16s_fixup_surrogates(handle, &mut utf16_buf, amount, &mut self.surrogate)?;\n-\n-            match utf16_to_utf8(&utf16_buf[..read], buf) {\n+            // Safety `read_u16s_fixup_surrogates` returns the number of items\n+            // initialized.\n+            let utf16s = unsafe { MaybeUninit::slice_assume_init_ref(&utf16_buf[..read]) };\n+            match utf16_to_utf8(utf16s, buf) {\n                 Ok(value) => return Ok(bytes_copied + value),\n                 Err(e) => return Err(e),\n             }\n@@ -283,14 +291,14 @@ impl io::Read for Stdin {\n // This is a best effort, and might not work if we are not the only reader on Stdin.\n fn read_u16s_fixup_surrogates(\n     handle: c::HANDLE,\n-    buf: &mut [u16],\n+    buf: &mut [MaybeUninit<u16>],\n     mut amount: usize,\n     surrogate: &mut u16,\n ) -> io::Result<usize> {\n     // Insert possibly remaining unpaired surrogate from last read.\n     let mut start = 0;\n     if *surrogate != 0 {\n-        buf[0] = *surrogate;\n+        buf[0] = MaybeUninit::new(*surrogate);\n         *surrogate = 0;\n         start = 1;\n         if amount == 1 {\n@@ -303,7 +311,10 @@ fn read_u16s_fixup_surrogates(\n     let mut amount = read_u16s(handle, &mut buf[start..amount])? + start;\n \n     if amount > 0 {\n-        let last_char = buf[amount - 1];\n+        // Safety: The returned `amount` is the number of values initialized,\n+        // and it is not 0, so we know that `buf[amount - 1]` have been\n+        // initialized.\n+        let last_char = unsafe { buf[amount - 1].assume_init() };\n         if last_char >= 0xD800 && last_char <= 0xDBFF {\n             // high surrogate\n             *surrogate = last_char;\n@@ -313,7 +324,8 @@ fn read_u16s_fixup_surrogates(\n     Ok(amount)\n }\n \n-fn read_u16s(handle: c::HANDLE, buf: &mut [u16]) -> io::Result<usize> {\n+// Returns `Ok(n)` if it initialized `n` values in `buf`.\n+fn read_u16s(handle: c::HANDLE, buf: &mut [MaybeUninit<u16>]) -> io::Result<usize> {\n     // Configure the `pInputControl` parameter to not only return on `\\r\\n` but also Ctrl-Z, the\n     // traditional DOS method to indicate end of character stream / user input (SUB).\n     // See #38274 and https://stackoverflow.com/questions/43836040/win-api-readconsole.\n@@ -346,8 +358,9 @@ fn read_u16s(handle: c::HANDLE, buf: &mut [u16]) -> io::Result<usize> {\n         }\n         break;\n     }\n-\n-    if amount > 0 && buf[amount as usize - 1] == CTRL_Z {\n+    // Safety: if `amount > 0`, then that many bytes were written, so\n+    // `buf[amount as usize - 1]` has been initialized.\n+    if amount > 0 && unsafe { buf[amount as usize - 1].assume_init() } == CTRL_Z {\n         amount -= 1;\n     }\n     Ok(amount as usize)"}]}