{"sha": "a3d666bfdf3ef87a91eace7b533e433945b06d76", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZDY2NmJmZGYzZWY4N2E5MWVhY2U3YjUzM2U0MzM5NDViMDZkNzY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-03T22:53:53Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-03T22:54:46Z"}, "message": "rustc: Use an extensible annotation field instead of putting option[@ty] everywhere", "tree": {"sha": "f8bffa03b37a27dead809b9e00aec3eba733ae8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8bffa03b37a27dead809b9e00aec3eba733ae8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3d666bfdf3ef87a91eace7b533e433945b06d76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3d666bfdf3ef87a91eace7b533e433945b06d76", "html_url": "https://github.com/rust-lang/rust/commit/a3d666bfdf3ef87a91eace7b533e433945b06d76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3d666bfdf3ef87a91eace7b533e433945b06d76/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0382617621b9728aa7e87b4b80928e33c4f338b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0382617621b9728aa7e87b4b80928e33c4f338b", "html_url": "https://github.com/rust-lang/rust/commit/c0382617621b9728aa7e87b4b80928e33c4f338b"}], "stats": {"total": 183, "additions": 94, "deletions": 89}, "files": [{"sha": "e635c1191b34d6ab573a94207b28f07b77a260ba", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a3d666bfdf3ef87a91eace7b533e433945b06d76/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d666bfdf3ef87a91eace7b533e433945b06d76/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=a3d666bfdf3ef87a91eace7b533e433945b06d76", "patch": "@@ -15,6 +15,12 @@ type crate_num = int;\n type def_num = int;\n type def_id = tup(crate_num, def_num);\n \n+// Annotations added during successive passes.\n+tag ann {\n+    ann_none;\n+    ann_type(@ty);\n+}\n+\n tag def {\n     def_fn(def_id);\n     def_mod(def_id);\n@@ -85,22 +91,22 @@ tag decl_ {\n \n type expr = spanned[expr_];\n tag expr_ {\n-    expr_vec(vec[@expr], option[@ty]);\n-    expr_tup(vec[tup(bool /* mutability */, @expr)], option[@ty]);\n-    expr_rec(vec[tup(ident,@expr)], option[@ty]);\n-    expr_call(@expr, vec[@expr], option[@ty]);\n-    expr_binary(binop, @expr, @expr, option[@ty]);\n-    expr_unary(unop, @expr, option[@ty]);\n-    expr_lit(@lit, option[@ty]);\n-    expr_cast(@expr, @ty);\n-    expr_if(@expr, block, option[block], option[@ty]);\n-    expr_while(@expr, block, option[@ty]);\n-    expr_do_while(block, @expr, option[@ty]);\n-    expr_block(block, option[@ty]);\n-    expr_assign(@expr /* TODO: @expr|is_lval */, @expr, option[@ty]);\n-    expr_field(@expr, ident, option[@ty]);\n-    expr_index(@expr, @expr, option[@ty]);\n-    expr_name(name, option[def], option[@ty]);\n+    expr_vec(vec[@expr], ann);\n+    expr_tup(vec[tup(bool /* mutability */, @expr)], ann);\n+    expr_rec(vec[tup(ident,@expr)], ann);\n+    expr_call(@expr, vec[@expr], ann);\n+    expr_binary(binop, @expr, @expr, ann);\n+    expr_unary(unop, @expr, ann);\n+    expr_lit(@lit, ann);\n+    expr_cast(@expr, @ty, ann);\n+    expr_if(@expr, block, option[block], ann);\n+    expr_while(@expr, block, ann);\n+    expr_do_while(block, @expr, ann);\n+    expr_block(block, ann);\n+    expr_assign(@expr /* TODO: @expr|is_lval */, @expr, ann);\n+    expr_field(@expr, ident, ann);\n+    expr_index(@expr, @expr, ann);\n+    expr_name(name, option[def], ann);\n }\n \n type lit = spanned[lit_];"}, {"sha": "97742a1853bab779d96e586b5e66db4f2a4191e7", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a3d666bfdf3ef87a91eace7b533e433945b06d76/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d666bfdf3ef87a91eace7b533e433945b06d76/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=a3d666bfdf3ef87a91eace7b533e433945b06d76", "patch": "@@ -260,14 +260,14 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n     // FIXME: can only remove this sort of thing when both typestate and\n     // alt-exhaustive-match checking are co-operating.\n     auto lit = @spanned(lo, lo, ast.lit_nil);\n-    let ast.expr_ ex = ast.expr_lit(lit, none[@ast.ty]);\n+    let ast.expr_ ex = ast.expr_lit(lit, ast.ann_none);\n \n     alt (p.peek()) {\n \n         case (token.IDENT(?i)) {\n             auto n = parse_name(p, i);\n             hi = n.span;\n-            ex = ast.expr_name(n, none[ast.def], none[@ast.ty]);\n+            ex = ast.expr_name(n, none[ast.def], ast.ann_none);\n             alt (p.peek()) {\n                 case (token.LPAREN) {\n                     // Call expr.\n@@ -277,7 +277,7 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n                                                    some(token.COMMA),\n                                                    pf, p);\n                     ex = ast.expr_call(@spanned(lo, hi, ex),\n-                                       es.node, none[@ast.ty]);\n+                                       es.node, ast.ann_none);\n                     hi = es.span;\n                 }\n             }\n@@ -299,7 +299,7 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n                                                       some(token.COMMA),\n                                                       pf, p);\n             hi = es.span;\n-            ex = ast.expr_tup(es.node, none[@ast.ty]);\n+            ex = ast.expr_tup(es.node, ast.ann_none);\n         }\n \n         case (token.VEC) {\n@@ -310,7 +310,7 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n                                            some(token.COMMA),\n                                            pf, p);\n             hi = es.span;\n-            ex = ast.expr_vec(es.node, none[@ast.ty]);\n+            ex = ast.expr_vec(es.node, ast.ann_none);\n         }\n \n         case (token.REC) {\n@@ -329,14 +329,14 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n                                                      some(token.COMMA),\n                                                      pf, p);\n             hi = es.span;\n-            ex = ast.expr_rec(es.node, none[@ast.ty]);\n+            ex = ast.expr_rec(es.node, ast.ann_none);\n         }\n \n         case (_) {\n             alt (parse_lit(p)) {\n                 case (some[ast.lit](?lit)) {\n                     hi = lit.span;\n-                    ex = ast.expr_lit(@lit, none[@ast.ty]);\n+                    ex = ast.expr_lit(@lit, ast.ann_none);\n                 }\n                 case (none[ast.lit]) {\n                     p.err(\"expecting expression\");\n@@ -361,14 +361,14 @@ impure fn parse_path_expr(parser p) -> @ast.expr {\n                     case (token.IDENT(?i)) {\n                         hi = p.get_span();\n                         p.bump();\n-                        auto e_ = ast.expr_field(e, i, none[@ast.ty]);\n+                        auto e_ = ast.expr_field(e, i, ast.ann_none);\n                         e = @spanned(lo, hi, e_);\n                     }\n \n                     case (token.LPAREN) {\n                         auto ix = parse_bottom_expr(p);\n                         hi = ix.span;\n-                        auto e_ = ast.expr_index(e, ix, none[@ast.ty]);\n+                        auto e_ = ast.expr_index(e, ix, ast.ann_none);\n                         e = @spanned(lo, hi, e_);\n                     }\n                 }\n@@ -389,22 +389,22 @@ impure fn parse_prefix_expr(parser p) -> @ast.expr {\n     // FIXME: can only remove this sort of thing when both typestate and\n     // alt-exhaustive-match checking are co-operating.\n     auto lit = @spanned(lo, lo, ast.lit_nil);\n-    let ast.expr_ ex = ast.expr_lit(lit, none[@ast.ty]);\n+    let ast.expr_ ex = ast.expr_lit(lit, ast.ann_none);\n \n     alt (p.peek()) {\n \n         case (token.NOT) {\n             p.bump();\n             auto e = parse_prefix_expr(p);\n             hi = e.span;\n-            ex = ast.expr_unary(ast.not, e, none[@ast.ty]);\n+            ex = ast.expr_unary(ast.not, e, ast.ann_none);\n         }\n \n         case (token.TILDE) {\n             p.bump();\n             auto e = parse_prefix_expr(p);\n             hi = e.span;\n-            ex = ast.expr_unary(ast.bitnot, e, none[@ast.ty]);\n+            ex = ast.expr_unary(ast.bitnot, e, ast.ann_none);\n         }\n \n         case (token.BINOP(?b)) {\n@@ -413,14 +413,14 @@ impure fn parse_prefix_expr(parser p) -> @ast.expr {\n                     p.bump();\n                     auto e = parse_prefix_expr(p);\n                     hi = e.span;\n-                    ex = ast.expr_unary(ast.neg, e, none[@ast.ty]);\n+                    ex = ast.expr_unary(ast.neg, e, ast.ann_none);\n                 }\n \n                 case (token.STAR) {\n                     p.bump();\n                     auto e = parse_prefix_expr(p);\n                     hi = e.span;\n-                    ex = ast.expr_unary(ast.deref, e, none[@ast.ty]);\n+                    ex = ast.expr_unary(ast.deref, e, ast.ann_none);\n                 }\n \n                 case (_) {\n@@ -433,7 +433,7 @@ impure fn parse_prefix_expr(parser p) -> @ast.expr {\n             p.bump();\n             auto e = parse_prefix_expr(p);\n             hi = e.span;\n-            ex = ast.expr_unary(ast.box, e, none[@ast.ty]);\n+            ex = ast.expr_unary(ast.box, e, ast.ann_none);\n         }\n \n         case (_) {\n@@ -461,7 +461,7 @@ impure fn parse_binops(parser p,\n                         auto rhs = sub(p);\n                         hi = rhs.span;\n                         auto exp = ast.expr_binary(pair._1, e, rhs,\n-                                                   none[@ast.ty]);\n+                                                   ast.ann_none);\n                         e = @spanned(lo, hi, exp);\n                         more = true;\n                     }\n@@ -487,7 +487,7 @@ impure fn parse_binary_exprs(parser p,\n                 p.bump();\n                 auto rhs = sub(p);\n                 hi = rhs.span;\n-                auto exp = ast.expr_binary(pair._1, e, rhs, none[@ast.ty]);\n+                auto exp = ast.expr_binary(pair._1, e, rhs, ast.ann_none);\n                 e = @spanned(lo, hi, exp);\n                 more = true;\n             }\n@@ -541,7 +541,7 @@ impure fn parse_cast_expr(parser p) -> @ast.expr {\n                 p.bump();\n                 auto t = parse_ty(p);\n                 hi = t.span;\n-                e = @spanned(lo, hi, ast.expr_cast(e, t));\n+                e = @spanned(lo, hi, ast.expr_cast(e, t, ast.ann_none));\n             }\n \n             case (_) {\n@@ -585,7 +585,7 @@ impure fn parse_assign_expr(parser p) -> @ast.expr {\n             p.bump();\n             auto rhs = parse_expr(p);\n             ret @spanned(lo, rhs.span,\n-                         ast.expr_assign(lhs, rhs, none[@ast.ty]));\n+                         ast.expr_assign(lhs, rhs, ast.ann_none));\n         }\n     }\n     ret lhs;\n@@ -610,7 +610,7 @@ impure fn parse_if_expr(parser p) -> @ast.expr {\n             hi = eblk.span;\n         }\n     }\n-    ret @spanned(lo, hi, ast.expr_if(cond, thn, els, none[@ast.ty]));\n+    ret @spanned(lo, hi, ast.expr_if(cond, thn, els, ast.ann_none));\n }\n \n impure fn parse_while_expr(parser p) -> @ast.expr {\n@@ -623,7 +623,7 @@ impure fn parse_while_expr(parser p) -> @ast.expr {\n     expect(p, token.RPAREN);\n     auto body = parse_block(p);\n     hi = body.span;\n-    ret @spanned(lo, hi, ast.expr_while(cond, body, none[@ast.ty]));\n+    ret @spanned(lo, hi, ast.expr_while(cond, body, ast.ann_none));\n }\n \n impure fn parse_do_while_expr(parser p) -> @ast.expr {\n@@ -637,15 +637,15 @@ impure fn parse_do_while_expr(parser p) -> @ast.expr {\n     auto cond = parse_expr(p);\n     expect(p, token.RPAREN);\n     hi = cond.span;\n-    ret @spanned(lo, hi, ast.expr_do_while(body, cond, none[@ast.ty]));\n+    ret @spanned(lo, hi, ast.expr_do_while(body, cond, ast.ann_none));\n }\n \n impure fn parse_expr(parser p) -> @ast.expr {\n     alt (p.peek()) {\n         case (token.LBRACE) {\n             auto blk = parse_block(p);\n             ret @spanned(blk.span, blk.span,\n-                         ast.expr_block(blk, none[@ast.ty]));\n+                         ast.expr_block(blk, ast.ann_none));\n         }\n         case (token.IF) {\n             ret parse_if_expr(p);"}, {"sha": "8b38c894c8cd394147b03a7f4e3161d10571076d", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a3d666bfdf3ef87a91eace7b533e433945b06d76/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d666bfdf3ef87a91eace7b533e433945b06d76/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=a3d666bfdf3ef87a91eace7b533e433945b06d76", "patch": "@@ -22,6 +22,7 @@ import front.ast.arg;\n import front.ast.decl;\n import front.ast.def;\n import front.ast.def_id;\n+import front.ast.ann;\n \n import std._vec;\n \n@@ -50,64 +51,64 @@ type ast_fold[ENV] =\n \n      // Expr folds.\n      (fn(&ENV e, &span sp,\n-         vec[@expr] es, option[@ty] ty) -> @expr) fold_expr_vec,\n+         vec[@expr] es, ann a) -> @expr)          fold_expr_vec,\n \n      (fn(&ENV e, &span sp,\n          vec[tup(bool,@expr)] es,\n-         option[@ty] ty) -> @expr)                fold_expr_tup,\n+         ann a) -> @expr)                         fold_expr_tup,\n \n      (fn(&ENV e, &span sp,\n          vec[tup(ident,@expr)] fields,\n-         option[@ty] ty) -> @expr)                fold_expr_rec,\n+         ann a) -> @expr)                         fold_expr_rec,\n \n      (fn(&ENV e, &span sp,\n          @expr f, vec[@expr] args,\n-         option[@ty] ty) -> @expr)                fold_expr_call,\n+         ann a) -> @expr)                         fold_expr_call,\n \n      (fn(&ENV e, &span sp,\n          ast.binop,\n          @expr lhs, @expr rhs,\n-         option[@ty] ty) -> @expr)                fold_expr_binary,\n+         ann a) -> @expr)                         fold_expr_binary,\n \n      (fn(&ENV e, &span sp,\n          ast.unop, @expr e,\n-         option[@ty] ty) -> @expr)                fold_expr_unary,\n+         ann a) -> @expr)                         fold_expr_unary,\n \n      (fn(&ENV e, &span sp,\n-         @ast.lit, option[@ty] ty) -> @expr)      fold_expr_lit,\n+         @ast.lit, ann a) -> @expr)               fold_expr_lit,\n \n      (fn(&ENV e, &span sp,\n          @expr cond, &block thn,\n          &option[block] els,\n-         option[@ty] ty) -> @expr)                fold_expr_if,\n+         ann a) -> @expr)                         fold_expr_if,\n \n      (fn(&ENV e, &span sp,\n          @expr cond, &block body,\n-         option[@ty] ty) -> @expr)                fold_expr_while,\n+         ann a) -> @expr)                         fold_expr_while,\n \n      (fn(&ENV e, &span sp,\n          &block body, @expr cond,\n-         option[@ty] ty) -> @expr)                fold_expr_do_while,\n+         ann a) -> @expr)                         fold_expr_do_while,\n \n      (fn(&ENV e, &span sp,\n-         &block blk, option[@ty] ty) -> @expr)    fold_expr_block,\n+         &block blk, ann a) -> @expr)             fold_expr_block,\n \n      (fn(&ENV e, &span sp,\n          @expr lhs, @expr rhs,\n-         option[@ty] ty) -> @expr)                fold_expr_assign,\n+         ann a) -> @expr)                         fold_expr_assign,\n \n      (fn(&ENV e, &span sp,\n          @expr e, ident i,\n-         option[@ty] ty) -> @expr)                fold_expr_field,\n+         ann a) -> @expr)                         fold_expr_field,\n \n      (fn(&ENV e, &span sp,\n          @expr e, @expr ix,\n-         option[@ty] ty) -> @expr)                fold_expr_index,\n+         ann a) -> @expr)                         fold_expr_index,\n \n      (fn(&ENV e, &span sp,\n          &name n,\n          &option[def] d,\n-         option[@ty] ty) -> @expr)                fold_expr_name,\n+         ann a) -> @expr)                         fold_expr_name,\n \n      // Decl folds.\n      (fn(&ENV e, &span sp,\n@@ -575,86 +576,83 @@ fn identity_fold_ty_path[ENV](&ENV env, &span sp, ast.path p,\n // Expr identities.\n \n fn identity_fold_expr_vec[ENV](&ENV env, &span sp, vec[@expr] es,\n-                               option[@ty] t) -> @expr {\n-    ret @respan(sp, ast.expr_vec(es, t));\n+                               ann a) -> @expr {\n+    ret @respan(sp, ast.expr_vec(es, a));\n }\n \n fn identity_fold_expr_tup[ENV](&ENV env, &span sp, vec[tup(bool, @expr)] es,\n-                               option[@ty] t) -> @expr {\n-    ret @respan(sp, ast.expr_tup(es, t));\n+                               ann a) -> @expr {\n+    ret @respan(sp, ast.expr_tup(es, a));\n }\n \n fn identity_fold_expr_rec[ENV](&ENV env, &span sp,\n-                               vec[tup(ident,@expr)] fields, option[@ty] t)\n-    -> @expr {\n-    ret @respan(sp, ast.expr_rec(fields, t));\n+                               vec[tup(ident,@expr)] fields, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_rec(fields, a));\n }\n \n fn identity_fold_expr_call[ENV](&ENV env, &span sp, @expr f,\n-                                vec[@expr] args, option[@ty] t) -> @expr {\n-    ret @respan(sp, ast.expr_call(f, args, t));\n+                                vec[@expr] args, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_call(f, args, a));\n }\n \n fn identity_fold_expr_binary[ENV](&ENV env, &span sp, ast.binop b,\n                                   @expr lhs, @expr rhs,\n-                                  option[@ty] t) -> @expr {\n-    ret @respan(sp, ast.expr_binary(b, lhs, rhs, t));\n+                                  ann a) -> @expr {\n+    ret @respan(sp, ast.expr_binary(b, lhs, rhs, a));\n }\n \n fn identity_fold_expr_unary[ENV](&ENV env, &span sp,\n-                                 ast.unop u, @expr e, option[@ty] t)\n+                                 ast.unop u, @expr e, ann a)\n         -> @expr {\n-    ret @respan(sp, ast.expr_unary(u, e, t));\n+    ret @respan(sp, ast.expr_unary(u, e, a));\n }\n \n fn identity_fold_expr_lit[ENV](&ENV env, &span sp, @ast.lit lit,\n-                               option[@ty] t) -> @expr {\n-    ret @respan(sp, ast.expr_lit(lit, t));\n+                               ann a) -> @expr {\n+    ret @respan(sp, ast.expr_lit(lit, a));\n }\n \n fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n                               @expr cond, &block thn,\n-                              &option[block] els, option[@ty] t) -> @expr {\n-    ret @respan(sp, ast.expr_if(cond, thn, els, t));\n+                              &option[block] els, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_if(cond, thn, els, a));\n }\n \n fn identity_fold_expr_while[ENV](&ENV env, &span sp,\n-                                 @expr cond, &block body,\n-                                 option[@ty] t) -> @expr {\n-    ret @respan(sp, ast.expr_while(cond, body, t));\n+                                 @expr cond, &block body, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_while(cond, body, a));\n }\n \n fn identity_fold_expr_do_while[ENV](&ENV env, &span sp,\n-                                    &block body, @expr cond,\n-                                    option[@ty] t) -> @expr {\n-    ret @respan(sp, ast.expr_do_while(body, cond, t));\n+                                    &block body, @expr cond, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_do_while(body, cond, a));\n }\n \n fn identity_fold_expr_block[ENV](&ENV env, &span sp, &block blk,\n-                                 option[@ty] t) -> @expr {\n-    ret @respan(sp, ast.expr_block(blk, t));\n+                                 ann a) -> @expr {\n+    ret @respan(sp, ast.expr_block(blk, a));\n }\n \n fn identity_fold_expr_assign[ENV](&ENV env, &span sp,\n-                                  @expr lhs, @expr rhs, option[@ty] t)\n+                                  @expr lhs, @expr rhs, ann a)\n         -> @expr {\n-    ret @respan(sp, ast.expr_assign(lhs, rhs, t));\n+    ret @respan(sp, ast.expr_assign(lhs, rhs, a));\n }\n \n fn identity_fold_expr_field[ENV](&ENV env, &span sp,\n-                                 @expr e, ident i, option[@ty] t) -> @expr {\n-    ret @respan(sp, ast.expr_field(e, i, t));\n+                                 @expr e, ident i, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_field(e, i, a));\n }\n \n fn identity_fold_expr_index[ENV](&ENV env, &span sp,\n-                                 @expr e, @expr ix, option[@ty] t) -> @expr {\n-    ret @respan(sp, ast.expr_index(e, ix, t));\n+                                 @expr e, @expr ix, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_index(e, ix, a));\n }\n \n fn identity_fold_expr_name[ENV](&ENV env, &span sp,\n                                 &name n, &option[def] d,\n-                                option[@ty] t) -> @expr {\n-    ret @respan(sp, ast.expr_name(n, d, t));\n+                                ann a) -> @expr {\n+    ret @respan(sp, ast.expr_name(n, d, a));\n }\n \n "}, {"sha": "5741bac44d6943e76d448f75bb17eb7d1bff396c", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3d666bfdf3ef87a91eace7b533e433945b06d76/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3d666bfdf3ef87a91eace7b533e433945b06d76/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=a3d666bfdf3ef87a91eace7b533e433945b06d76", "patch": "@@ -1,6 +1,7 @@\n import front.ast;\n import front.ast.ident;\n import front.ast.def;\n+import front.ast.ann;\n import driver.session;\n import util.common.span;\n import std.map.hashmap;\n@@ -102,7 +103,7 @@ fn lookup_name(&env e, ast.ident i) -> option[def] {\n }\n \n fn fold_expr_name(&env e, &span sp, &ast.name n,\n-                  &option[def] d, option[@ast.ty] t) -> @ast.expr {\n+                  &option[def] d, ann a) -> @ast.expr {\n \n     auto d_ = lookup_name(e, n.node.ident);\n \n@@ -115,7 +116,7 @@ fn fold_expr_name(&env e, &span sp, &ast.name n,\n         }\n     }\n \n-    ret @fold.respan[ast.expr_](sp, ast.expr_name(n, d_, t));\n+    ret @fold.respan[ast.expr_](sp, ast.expr_name(n, d_, a));\n }\n \n fn update_env_for_crate(&env e, @ast.crate c) -> env {"}]}