{"sha": "5e5ce4327a4574cd207f0a427822848be7f71e8d", "node_id": "C_kwDOAAsO6NoAKDVlNWNlNDMyN2E0NTc0Y2QyMDdmMGE0Mjc4MjI4NDhiZTdmNzFlOGQ", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-24T16:50:02Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-24T17:51:09Z"}, "message": "Rename and document the new BufReader internals", "tree": {"sha": "4b7d3b727b7c2a989d635f819cbf6faf640fa8c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b7d3b727b7c2a989d635f819cbf6faf640fa8c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e5ce4327a4574cd207f0a427822848be7f71e8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e5ce4327a4574cd207f0a427822848be7f71e8d", "html_url": "https://github.com/rust-lang/rust/commit/5e5ce4327a4574cd207f0a427822848be7f71e8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e5ce4327a4574cd207f0a427822848be7f71e8d/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9497be7d0650915f75597738bb2715745fbe359", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9497be7d0650915f75597738bb2715745fbe359", "html_url": "https://github.com/rust-lang/rust/commit/b9497be7d0650915f75597738bb2715745fbe359"}], "stats": {"total": 62, "additions": 33, "deletions": 29}, "files": [{"sha": "0be559044070292fed19337b1a1377963400537a", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e5ce4327a4574cd207f0a427822848be7f71e8d/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5ce4327a4574cd207f0a427822848be7f71e8d/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=5e5ce4327a4574cd207f0a427822848be7f71e8d", "patch": "@@ -238,7 +238,7 @@ impl<R: Seek> BufReader<R> {\n                 return Ok(());\n             }\n         } else if let Some(new_pos) = pos.checked_add(offset as u64) {\n-            if new_pos <= self.buf.cap() as u64 {\n+            if new_pos <= self.buf.filled() as u64 {\n                 self.buf.consume(offset as usize);\n                 return Ok(());\n             }\n@@ -254,7 +254,7 @@ impl<R: Read> Read for BufReader<R> {\n         // If we don't have any buffered data and we're doing a massive read\n         // (larger than our internal buffer), bypass our internal buffer\n         // entirely.\n-        if self.buf.pos() == self.buf.cap() && buf.len() >= self.capacity() {\n+        if self.buf.pos() == self.buf.filled() && buf.len() >= self.capacity() {\n             self.discard_buffer();\n             return self.inner.read(buf);\n         }\n@@ -270,7 +270,7 @@ impl<R: Read> Read for BufReader<R> {\n         // If we don't have any buffered data and we're doing a massive read\n         // (larger than our internal buffer), bypass our internal buffer\n         // entirely.\n-        if self.buf.pos() == self.buf.cap() && buf.remaining() >= self.capacity() {\n+        if self.buf.pos() == self.buf.filled() && buf.remaining() >= self.capacity() {\n             self.discard_buffer();\n             return self.inner.read_buf(buf);\n         }\n@@ -301,7 +301,7 @@ impl<R: Read> Read for BufReader<R> {\n \n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n-        if self.buf.pos() == self.buf.cap() && total_len >= self.capacity() {\n+        if self.buf.pos() == self.buf.filled() && total_len >= self.capacity() {\n             self.discard_buffer();\n             return self.inner.read_vectored(bufs);\n         }\n@@ -385,7 +385,7 @@ where\n             .field(\"reader\", &self.inner)\n             .field(\n                 \"buffer\",\n-                &format_args!(\"{}/{}\", self.buf.cap() - self.buf.pos(), self.capacity()),\n+                &format_args!(\"{}/{}\", self.buf.filled() - self.buf.pos(), self.capacity()),\n             )\n             .finish()\n     }\n@@ -418,7 +418,7 @@ impl<R: Seek> Seek for BufReader<R> {\n     fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n         let result: u64;\n         if let SeekFrom::Current(n) = pos {\n-            let remainder = (self.buf.cap() - self.buf.pos()) as i64;\n+            let remainder = (self.buf.filled() - self.buf.pos()) as i64;\n             // it should be safe to assume that remainder fits within an i64 as the alternative\n             // means we managed to allocate 8 exbibytes and that's absurd.\n             // But it's not out of the realm of possibility for some weird underlying reader to\n@@ -476,7 +476,7 @@ impl<R: Seek> Seek for BufReader<R> {\n     /// }\n     /// ```\n     fn stream_position(&mut self) -> io::Result<u64> {\n-        let remainder = (self.buf.cap() - self.buf.pos()) as u64;\n+        let remainder = (self.buf.filled() - self.buf.pos()) as u64;\n         self.inner.stream_position().map(|pos| {\n             pos.checked_sub(remainder).expect(\n                 \"overflow when subtracting remaining buffer size from inner stream position\","}, {"sha": "bf3462bf00cb85ae8a3f701da15ea4f1f3e71f67", "filename": "library/std/src/io/buffered/bufreader/buffer.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5e5ce4327a4574cd207f0a427822848be7f71e8d/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e5ce4327a4574cd207f0a427822848be7f71e8d/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs?ref=5e5ce4327a4574cd207f0a427822848be7f71e8d", "patch": "@@ -1,27 +1,39 @@\n+///! An encapsulation of `BufReader`'s buffer management logic.\n+///\n+/// This module factors out the basic functionality of `BufReader` in order to protect two core\n+/// invariants:\n+/// * `filled` bytes of `buf` are always initialized\n+/// * `pos` is always <= `filled`\n+/// Since this module encapsulates the buffer management logic, we can ensure that the range\n+/// `pos..filled` is always a valid index into the initialized region of the buffer. This means\n+/// that user code which wants to do reads from a `BufReader` via `buffer` + `consume` can do so\n+/// without encountering any runtime bounds checks.\n use crate::cmp;\n use crate::io::{self, Read, ReadBuf};\n use crate::mem::MaybeUninit;\n \n pub struct Buffer {\n+    // The buffer.\n     buf: Box<[MaybeUninit<u8>]>,\n+    // The current seek offset into `buf`, must always be <= `filled`.\n     pos: usize,\n-    cap: usize,\n-    init: usize,\n+    // Each call to `fill_buf` sets `filled` to indicate how many bytes at the start of `buf` are\n+    // initialized with bytes from a read.\n+    filled: usize,\n }\n \n impl Buffer {\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Self {\n         let buf = Box::new_uninit_slice(capacity);\n-        Self { buf, pos: 0, cap: 0, init: 0 }\n+        Self { buf, pos: 0, filled: 0 }\n     }\n \n     #[inline]\n     pub fn buffer(&self) -> &[u8] {\n-        // SAFETY: self.cap is always <= self.init, so self.buf[self.pos..self.cap] is always init\n-        // Additionally, both self.pos and self.cap are valid and and self.cap => self.pos, and\n+        // SAFETY: self.pos and self.cap are valid, and self.cap => self.pos, and\n         // that region is initialized because those are all invariants of this type.\n-        unsafe { MaybeUninit::slice_assume_init_ref(&self.buf.get_unchecked(self.pos..self.cap)) }\n+        unsafe { MaybeUninit::slice_assume_init_ref(self.buf.get_unchecked(self.pos..self.filled)) }\n     }\n \n     #[inline]\n@@ -30,8 +42,8 @@ impl Buffer {\n     }\n \n     #[inline]\n-    pub fn cap(&self) -> usize {\n-        self.cap\n+    pub fn filled(&self) -> usize {\n+        self.filled\n     }\n \n     #[inline]\n@@ -42,12 +54,12 @@ impl Buffer {\n     #[inline]\n     pub fn discard_buffer(&mut self) {\n         self.pos = 0;\n-        self.cap = 0;\n+        self.filled = 0;\n     }\n \n     #[inline]\n     pub fn consume(&mut self, amt: usize) {\n-        self.pos = cmp::min(self.pos + amt, self.cap);\n+        self.pos = cmp::min(self.pos + amt, self.filled);\n     }\n \n     #[inline]\n@@ -58,25 +70,17 @@ impl Buffer {\n     #[inline]\n     pub fn fill_buf(&mut self, mut reader: impl Read) -> io::Result<&[u8]> {\n         // If we've reached the end of our internal buffer then we need to fetch\n-        // some more data from the underlying reader.\n+        // some more data from the reader.\n         // Branch using `>=` instead of the more correct `==`\n         // to tell the compiler that the pos..cap slice is always valid.\n-        if self.pos >= self.cap {\n-            debug_assert!(self.pos == self.cap);\n+        if self.pos >= self.filled {\n+            debug_assert!(self.pos == self.filled);\n \n             let mut readbuf = ReadBuf::uninit(&mut self.buf);\n \n-            // SAFETY: `self.init` is either 0 or set to `readbuf.initialized_len()`\n-            // from the last time this function was called\n-            unsafe {\n-                readbuf.assume_init(self.init);\n-            }\n-\n             reader.read_buf(&mut readbuf)?;\n \n-            self.cap = readbuf.filled_len();\n-            self.init = readbuf.initialized_len();\n-\n+            self.filled = readbuf.filled_len();\n             self.pos = 0;\n         }\n         Ok(self.buffer())"}]}