{"sha": "cef4a3ebfaa7809d6ab8d8578b14160a83215321", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZjRhM2ViZmFhNzgwOWQ2YWI4ZDg1NzhiMTQxNjBhODMyMTUzMjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-01T17:32:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-01T17:32:34Z"}, "message": "Auto merge of #44897 - Havvy:doc-size_of, r=steveklabnik\n\nDocs for size_of::<#[repr(C)]> items.\n\nMost of this info comes from camlorn's blog post on optimizing struct layout and the Rustonomicon.\n\nI don't really like my wording in the first paragraph.\n\nI also cannot find a definition of what `#[repr(C)]` does for enums that have variants with fields. They're allowed, unlike `#[repr(C)] enum`s with no variants.", "tree": {"sha": "3cb22c89d3b057fbddd8fedb1413fdd7d088bb60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cb22c89d3b057fbddd8fedb1413fdd7d088bb60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cef4a3ebfaa7809d6ab8d8578b14160a83215321", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cef4a3ebfaa7809d6ab8d8578b14160a83215321", "html_url": "https://github.com/rust-lang/rust/commit/cef4a3ebfaa7809d6ab8d8578b14160a83215321", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cef4a3ebfaa7809d6ab8d8578b14160a83215321/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3651cddc441716ffa8aa4d1c771e26dab7f56216", "url": "https://api.github.com/repos/rust-lang/rust/commits/3651cddc441716ffa8aa4d1c771e26dab7f56216", "html_url": "https://github.com/rust-lang/rust/commit/3651cddc441716ffa8aa4d1c771e26dab7f56216"}, {"sha": "0ece48e2113cd8de4a8bce66eecdd081872ce56e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ece48e2113cd8de4a8bce66eecdd081872ce56e", "html_url": "https://github.com/rust-lang/rust/commit/0ece48e2113cd8de4a8bce66eecdd081872ce56e"}], "stats": {"total": 78, "additions": 78, "deletions": 0}, "files": [{"sha": "e085d427b8ce9214bf6fb3caf61d40d5d0c87c3e", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/cef4a3ebfaa7809d6ab8d8578b14160a83215321/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cef4a3ebfaa7809d6ab8d8578b14160a83215321/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=cef4a3ebfaa7809d6ab8d8578b14160a83215321", "patch": "@@ -209,6 +209,35 @@ pub fn forget<T>(t: T) {\n /// The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n /// have the same size. Likewise for `*const T` and `*mut T`.\n ///\n+/// # Size of `#[repr(C)]` items\n+///\n+/// The `C` representation for items has a defined layout. With this layout,\n+/// the size of items is also stable as long as all fields have a stable size.\n+///\n+/// ## Size of Structs\n+///\n+/// For `structs`, the size is determined by the following algorithm.\n+///\n+/// For each field in the struct ordered by declaration order:\n+///\n+/// 1. Add the size of the field.\n+/// 2. Round up the current size to the nearest multiple of the next field's [alignment].\n+///\n+/// Finally, round the size of the struct to the nearest multiple of its [alignment].\n+///\n+/// Unlike `C`, zero sized structs are not rounded up to one byte in size.\n+///\n+/// ## Size of Enums\n+///\n+/// Enums that carry no data other than the descriminant have the same size as C enums\n+/// on the platform they are compiled for.\n+///\n+/// ## Size of Unions\n+///\n+/// The size of a union is the size of its largest field.\n+///\n+/// Unlike `C`, zero sized unions are not rounded up to one byte in size.\n+///\n /// # Examples\n ///\n /// ```\n@@ -231,6 +260,55 @@ pub fn forget<T>(t: T) {\n /// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\n /// assert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n /// ```\n+///\n+/// Using `#[repr(C)]`.\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// #[repr(C)]\n+/// struct FieldStruct {\n+///     first: u8,\n+///     second: u16,\n+///     third: u8\n+/// }\n+///\n+/// // The size of the first field is 1, so add 1 to the size. Size is 1.\n+/// // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n+/// // The size of the second field is 2, so add 2 to the size. Size is 4.\n+/// // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n+/// // The size of the third field is 1, so add 1 to the size. Size is 5.\n+/// // Finally, the alignment of the struct is 2, so add 1 to the size for padding. Size is 6.\n+/// assert_eq!(6, mem::size_of::<FieldStruct>());\n+///\n+/// #[repr(C)]\n+/// struct TupleStruct(u8, u16, u8);\n+///\n+/// // Tuple structs follow the same rules.\n+/// assert_eq!(6, mem::size_of::<TupleStruct>());\n+///\n+/// // Note that reordering the fields can lower the size. We can remove both padding bytes\n+/// // by putting `third` before `second`.\n+/// #[repr(C)]\n+/// struct FieldStructOptimized {\n+///     first: u8,\n+///     third: u8,\n+///     second: u16\n+/// }\n+///\n+/// assert_eq!(4, mem::size_of::<FieldStructOptimized>());\n+///\n+/// // Union size is the size of the largest field.\n+/// #[repr(C)]\n+/// union ExampleUnion {\n+///     smaller: u8,\n+///     larger: u16\n+/// }\n+///\n+/// assert_eq!(2, mem::size_of::<ExampleUnion>());\n+/// ```\n+///\n+/// [alignment]: ./fn.align_of.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_size_of\"))]"}]}