{"sha": "690525ed814d3a60560188d7d76e2727d6f22347", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MDUyNWVkODE0ZDNhNjA1NjAxODhkN2Q3NmUyNzI3ZDZmMjIzNDc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-24T01:45:42Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-24T01:45:51Z"}, "message": "tutorial: Update ptr/vec/fn sections with new terminology", "tree": {"sha": "72f1f78fa7d571223d9ede7f05c84fee78c43a52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72f1f78fa7d571223d9ede7f05c84fee78c43a52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/690525ed814d3a60560188d7d76e2727d6f22347", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/690525ed814d3a60560188d7d76e2727d6f22347", "html_url": "https://github.com/rust-lang/rust/commit/690525ed814d3a60560188d7d76e2727d6f22347", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/690525ed814d3a60560188d7d76e2727d6f22347/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d3396bef191e06568ecbb7c7dd55667db1d8809", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d3396bef191e06568ecbb7c7dd55667db1d8809", "html_url": "https://github.com/rust-lang/rust/commit/2d3396bef191e06568ecbb7c7dd55667db1d8809"}], "stats": {"total": 160, "additions": 95, "deletions": 65}, "files": [{"sha": "8a5d80038e4a11fd58fda386d5f7dabbb6e1b223", "filename": "doc/tutorial.md", "status": "modified", "additions": 95, "deletions": 65, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/690525ed814d3a60560188d7d76e2727d6f22347/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/690525ed814d3a60560188d7d76e2727d6f22347/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=690525ed814d3a60560188d7d76e2727d6f22347", "patch": "@@ -918,9 +918,9 @@ garbage-collected heap to manage all of the objects. This approach is\n straightforward both in concept and in implementation, but has\n significant costs. Languages that take this approach tend to\n aggressively pursue ways to ameliorate allocation costs (think the\n-Java Virtual Machine). Rust supports this strategy with _shared\n-boxes_: memory allocated on the heap that may be referred to (shared)\n-by multiple variables.\n+Java Virtual Machine). Rust supports this strategy with _managed\n+boxes_: memory allocated on the heap whose lifetime is managed\n+by the garbage collector.\n \n By comparison, languages like C++ offer very precise control over\n where objects are allocated. In particular, it is common to put them\n@@ -950,16 +950,16 @@ inefficient for large data structures.  Because of this, Rust also\n employs a global _exchange heap_. Objects allocated in the exchange\n heap have _ownership semantics_, meaning that there is only a single\n variable that refers to them. For this reason, they are referred to as\n-_unique boxes_. All tasks may allocate objects on the exchange heap,\n+_owned boxes_. All tasks may allocate objects on the exchange heap,\n then transfer ownership of those objects to other tasks, avoiding\n expensive copies.\n \n ## What to be aware of\n \n Rust has three \"realms\" in which objects can be allocated: the stack,\n the local heap, and the exchange heap. These realms have corresponding\n-pointer types: the borrowed pointer (`&T`), the shared box (`@T`),\n-and the unique box (`~T`). These three sigils will appear\n+pointer types: the borrowed pointer (`&T`), the managed box (`@T`),\n+and the owned box (`~T`). These three sigils will appear\n repeatedly as we explore the language. Learning the appropriate role\n of each is key to using Rust effectively.\n \n@@ -978,17 +978,22 @@ records with mutable fields, it can be useful to have a single copy on\n the heap, and refer to that through a pointer.\n \n Rust supports several types of pointers. The safe pointer types are\n-`@T` for shared boxes allocated on the local heap, `~T`, for\n+`@T` for managed boxes allocated on the local heap, `~T`, for\n uniquely-owned boxes allocated on the exchange heap, and `&T`, for\n borrowed pointers, which may point to any memory, and whose lifetimes\n are governed by the call stack.\n \n All pointer types can be dereferenced with the `*` unary operator.\n \n-## Shared boxes\n+> ***Note***: You may also hear managed boxes referred to as 'shared\n+> boxes' or 'shared pointers', and owned boxes as 'unique boxes/pointers'.\n+> Borrowed pointers are sometimes called 'region pointers'. The preferred\n+> terminology is as presented here.\n \n-Shared boxes are pointers to heap-allocated, garbage collected memory.\n-Creating a shared box is done by simply applying the unary `@`\n+## Managed boxes\n+\n+Managed boxes are pointers to heap-allocated, garbage collected memory.\n+Creating a managed box is done by simply applying the unary `@`\n operator to an expression. The result of the expression will be boxed,\n resulting in a box of the right type. Copying a shared box, as happens\n during assignment, only copies a pointer, never the contents of the\n@@ -1000,22 +1005,24 @@ let y = x; // Copy the pointer, increase refcount\n // When x and y go out of scope, refcount goes to 0, box is freed\n ~~~~\n \n-Shared boxes never cross task boundaries.\n+Managed boxes never cross task boundaries.\n \n-> ***Note:*** shared boxes are currently reclaimed through reference\n+> ***Note:*** managed boxes are currently reclaimed through reference\n > counting and cycle collection, but we will switch to a tracing\n-> garbage collector.\n+> garbage collector eventually.\n \n-## Unique boxes\n+## Owned boxes\n \n-In contrast to shared boxes, unique boxes have a single owner and thus\n-two unique boxes may not refer to the same memory. All unique boxes\n-across all tasks are allocated on a single _exchange heap_, where\n-their uniquely owned nature allows them to be passed between tasks.\n+In contrast to maneged boxes, owned boxes have a single owning memory\n+slot and thus two owned boxes may not refer to the same memory. All\n+owned boxes across all tasks are allocated on a single _exchange\n+heap_, where their uniquely owned nature allows them to be passed\n+between tasks.\n \n-Because unique boxes are uniquely owned, copying them involves allocating\n-a new unique box and duplicating the contents. Copying unique boxes\n-is expensive so the compiler will complain if you do.\n+Because owned boxes are uniquely owned, copying them involves allocating\n+a new owned box and duplicating the contents. Copying owned boxes\n+is expensive so the compiler will complain if you do so without writing\n+the word `copy`.\n \n ~~~~\n let x = ~10;\n@@ -1029,23 +1036,23 @@ let x = ~10;\n let y = copy x;\n ~~~~\n \n-This is where the 'move' (`<-`) operator comes in. It is similar to\n-`=`, but it de-initializes its source. Thus, the unique box can move\n+This is where the 'move' operator comes in. It is similar to\n+`copy`, but it de-initializes its source. Thus, the owned box can move\n from `x` to `y`, without violating the constraint that it only has a\n single owner (if you used assignment instead of the move operator, the\n box would, in principle, be copied).\n \n ~~~~\n let x = ~10;\n-let y <- x;\n+let y = move x;\n ~~~~\n \n > ***Note:*** this discussion of copying vs moving does not account\n > for the \"last use\" rules that automatically promote copy operations\n > to moves. This is an evolving area of the language that will\n > continue to change.\n \n-Unique boxes, when they do not contain any shared boxes, can be sent\n+Owned boxes, when they do not contain any managed boxes, can be sent\n to other tasks. The sending task will give up ownership of the box,\n and won't be able to access it afterwards. The receiving task will\n become the sole owner of the box.\n@@ -1054,7 +1061,7 @@ become the sole owner of the box.\n \n Rust borrowed pointers are a general purpose reference/pointer type,\n similar to the C++ reference type, but guaranteed to point to valid\n-memory. In contrast to unique pointers, where the holder of a unique\n+memory. In contrast to owned pointers, where the holder of a unique\n pointer is the owner of the pointed-to memory, borrowed pointers never\n imply ownership. Pointers may be borrowed from any type, in which case\n the pointer is guaranteed not to outlive the value it points to.\n@@ -1095,11 +1102,12 @@ fn increase_contents(pt: @mut int) {\n }\n ~~~~\n \n-# Vectors\n+# Vectors and strings\n \n Vectors are a contiguous section of memory containing zero or more\n values of the same type. Like other types in Rust, vectors can be\n-stored on the stack, the local heap, or the exchange heap.\n+stored on the stack, the local heap, or the exchange heap. Borrowed\n+pointers to vectors are also called 'slices'.\n \n ~~~\n enum Crayon {\n@@ -1108,24 +1116,19 @@ enum Crayon {\n     BananaMania, Beaver, Bittersweet\n }\n \n-// A stack vector of crayons\n+// A fixed-size stack vector\n+let stack_crayons: [Crayon * 3] = [Almond, AntiqueBrass, Apricot];\n+\n+// A borrowed pointer to stack allocated vector\n let stack_crayons: &[Crayon] = &[Almond, AntiqueBrass, Apricot];\n-// A local heap (shared) vector of crayons\n+\n+// A local heap (managed) vector of crayons\n let local_crayons: @[Crayon] = @[Aquamarine, Asparagus, AtomicTangerine];\n-// An exchange heap (unique) vector of crayons\n+\n+// An exchange heap (owned) vector of crayons\n let exchange_crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];\n ~~~\n \n-> ***Note:*** Until recently Rust only had unique vectors, using the\n-> unadorned `[]` syntax for literals. This syntax is still supported\n-> but is deprecated. In the future it will probably represent some\n-> \"reasonable default\" vector type.\n->\n-> Unique vectors are the currently-recommended vector type for general\n-> use as they are the most tested and well-supported by existing\n-> libraries. There will be a gradual shift toward using more\n-> stack and local vectors in the coming releases.\n-\n Vector literals are enclosed in square brackets and dereferencing is\n also done with square brackets (zero-based):\n \n@@ -1135,24 +1138,24 @@ also done with square brackets (zero-based):\n #               BananaMania, Beaver, Bittersweet };\n # fn draw_scene(c: Crayon) { }\n \n-let crayons = ~[BananaMania, Beaver, Bittersweet];\n+let crayons = [BananaMania, Beaver, Bittersweet];\n match crayons[0] {\n     Bittersweet => draw_scene(crayons[0]),\n     _ => ()\n }\n ~~~~\n \n By default, vectors are immutable\u2014you can not replace their elements.\n-The type written as `~[mut T]` is a vector with mutable\n-elements. Mutable vector literals are written `~[mut]` (empty) or `~[mut\n+The type written as `[mut T]` is a vector with mutable\n+elements. Mutable vector literals are written `[mut]` (empty) or `[mut\n 1, 2, 3]` (with elements).\n \n ~~~~\n # enum Crayon { Almond, AntiqueBrass, Apricot,\n #               Aquamarine, Asparagus, AtomicTangerine,\n #               BananaMania, Beaver, Bittersweet };\n \n-let crayons = ~[mut BananaMania, Beaver, Bittersweet];\n+let crayons = [mut BananaMania, Beaver, Bittersweet];\n crayons[0] = AtomicTangerine;\n ~~~~\n \n@@ -1183,7 +1186,30 @@ let your_crayons = ~[BananaMania, Beaver, Bittersweet];\n my_crayons += your_crayons;\n ~~~~\n \n-## Vector and string methods\n+> ***Note:*** The above examples of vector addition use owned\n+> vectors. Some operations on slices and stack vectors are\n+> not well supported yet, owned vectors are often the most\n+> usable.\n+\n+Strings are simply vectors of `[u8]`, though they have a distinct\n+type. They support most of the same allocation aptions as\n+vectors, though the string literal without a storage sigil, e.g.\n+`\"foo\"` is treated differently than a comparable vector (`[foo]`).\n+Where\n+\n+~~~\n+// A plain string is a slice to read-only (static) memory\n+let stack_crayons: &str = \"Almond, AntiqueBrass, Apricot\";\n+\n+// The same thing, but without\n+let stack_crayons: &str = &\"Almond, AntiqueBrass, Apricot\";\n+\n+// A local heap (managed) string\n+let local_crayons: @str = @\"Aquamarine, Asparagus, AtomicTangerine\";\n+\n+// An exchange heap (owned) string\n+let exchange_crayons: ~str = ~\"BananaMania, Beaver, Bittersweet\";\n+~~~\n \n Both vectors and strings support a number of useful\n [methods](#implementation).  While we haven't covered methods yet,\n@@ -1202,7 +1228,7 @@ brief look at a few common ones.\n # fn store_crayon_in_nasal_cavity(i: uint, c: Crayon) { }\n # fn crayon_to_str(c: Crayon) -> ~str { ~\"\" }\n \n-let crayons = ~[Almond, AntiqueBrass, Apricot];\n+let crayons = &[Almond, AntiqueBrass, Apricot];\n \n // Check the length of the vector\n assert crayons.len() == 3;\n@@ -1282,15 +1308,15 @@ position and cannot be stored in structures nor returned from\n functions. Despite the limitations stack closures are used\n pervasively in Rust code.\n \n-## Shared closures\n+## Managed closures\n \n When you need to store a closure in a data structure, a stack closure\n will not do, since the compiler will refuse to let you store it. For\n this purpose, Rust provides a type of closure that has an arbitrary\n lifetime, written `fn@` (boxed closure, analogous to the `@` pointer\n type described earlier).\n \n-A boxed closure does not directly access its environment, but merely\n+A managed closure does not directly access its environment, but merely\n copies out the values that it closes over into a private data\n structure. This means that it can not assign to these variables, and\n will not 'see' updates to them.\n@@ -1315,7 +1341,7 @@ This example uses the long closure syntax, `fn@(s: ~str) ...`,\n making the fact that we are declaring a box closure explicit. In\n practice boxed closures are usually defined with the short closure\n syntax introduced earlier, in which case the compiler will infer\n-the type of closure. Thus our boxed closure example could also\n+the type of closure. Thus our managed closure example could also\n be written:\n \n ~~~~\n@@ -1324,13 +1350,13 @@ fn mk_appender(suffix: ~str) -> fn@(~str) -> ~str {\n }\n ~~~~\n \n-## Unique closures\n+## Owned closures\n \n-Unique closures, written `fn~` in analogy to the `~` pointer type,\n+Owned closures, written `fn~` in analogy to the `~` pointer type,\n hold on to things that can safely be sent between\n-processes. They copy the values they close over, much like boxed\n+processes. They copy the values they close over, much like managed\n closures, but they also 'own' them\u2014meaning no other code can access\n-them. Unique closures are used in concurrent code, particularly\n+them. Owned closures are used in concurrent code, particularly\n for spawning [tasks](#tasks).\n \n ## Closure compatibility\n@@ -1346,12 +1372,16 @@ that callers have the flexibility to pass whatever they want.\n fn call_twice(f: fn()) { f(); f(); }\n call_twice(|| { ~\"I am an inferred stack closure\"; } );\n call_twice(fn&() { ~\"I am also a stack closure\"; } );\n-call_twice(fn@() { ~\"I am a boxed closure\"; });\n-call_twice(fn~() { ~\"I am a unique closure\"; });\n+call_twice(fn@() { ~\"I am a managed closure\"; });\n+call_twice(fn~() { ~\"I am a owned closure\"; });\n fn bare_function() { ~\"I am a plain function\"; }\n call_twice(bare_function);\n ~~~~\n \n+> ***Note:*** Both the syntax and the semantics will be changing\n+> in small ways. At the moment they can be unsound in multiple\n+> scenarios, particularly with non-copyable types.\n+\n ## Do syntax\n \n Closures in Rust are frequently used in combination with higher-order\n@@ -1360,7 +1390,7 @@ functions to simulate control structures like `if` and\n integers, passing in a pointer to each integer in the vector:\n \n ~~~~\n-fn each(v: ~[int], op: fn(v: &int)) {\n+fn each(v: &[int], op: fn(v: &int)) {\n    let mut n = 0;\n    while n < v.len() {\n        op(&v[n]);\n@@ -1378,9 +1408,9 @@ closure to provide the final operator argument, we can write it in a\n way that has a pleasant, block-like structure.\n \n ~~~~\n-# fn each(v: ~[int], op: fn(v: &int)) { }\n+# fn each(v: &[int], op: fn(v: &int)) { }\n # fn do_some_work(i: int) { }\n-each(~[1, 2, 3], |n| {\n+each(&[1, 2, 3], |n| {\n     debug!(\"%i\", *n);\n     do_some_work(*n);\n });\n@@ -1390,9 +1420,9 @@ This is such a useful pattern that Rust has a special form of function\n call that can be written more like a built-in control structure:\n \n ~~~~\n-# fn each(v: ~[int], op: fn(v: &int)) { }\n+# fn each(v: &[int], op: fn(v: &int)) { }\n # fn do_some_work(i: int) { }\n-do each(~[1, 2, 3]) |n| {\n+do each(&[1, 2, 3]) |n| {\n     debug!(\"%i\", *n);\n     do_some_work(*n);\n }\n@@ -1438,7 +1468,7 @@ Consider again our `each` function, this time improved to\n break early when the iteratee returns `false`:\n \n ~~~~\n-fn each(v: ~[int], op: fn(v: &int) -> bool) {\n+fn each(v: &[int], op: fn(v: &int) -> bool) {\n    let mut n = 0;\n    while n < v.len() {\n        if !op(&v[n]) {\n@@ -1454,7 +1484,7 @@ And using this function to iterate over a vector:\n ~~~~\n # use each = vec::each;\n # use println = io::println;\n-each(~[2, 4, 8, 5, 16], |n| {\n+each(&[2, 4, 8, 5, 16], |n| {\n     if *n % 2 != 0 {\n         println(~\"found odd number!\");\n         false\n@@ -1471,7 +1501,7 @@ to the next iteration, write `again`.\n ~~~~\n # use each = vec::each;\n # use println = io::println;\n-for each(~[2, 4, 8, 5, 16]) |n| {\n+for each(&[2, 4, 8, 5, 16]) |n| {\n     if *n % 2 != 0 {\n         println(~\"found odd number!\");\n         break;\n@@ -1486,7 +1516,7 @@ function, not just the loop body.\n \n ~~~~\n # use each = vec::each;\n-fn contains(v: ~[int], elt: int) -> bool {\n+fn contains(v: &[int], elt: int) -> bool {\n     for each(v) |x| {\n         if (*x == elt) { return true; }\n     }"}]}