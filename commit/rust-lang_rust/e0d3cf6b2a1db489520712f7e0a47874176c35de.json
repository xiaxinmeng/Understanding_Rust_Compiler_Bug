{"sha": "e0d3cf6b2a1db489520712f7e0a47874176c35de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZDNjZjZiMmExZGI0ODk1MjA3MTJmN2UwYTQ3ODc0MTc2YzM1ZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-05T08:31:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-05T08:31:48Z"}, "message": "auto merge of #15418 : pnkfelix/rust/fsk-revise-VecPerParamSpace, r=pcwalton\n\nIn my informal measurements, this brings the peak memory usage when\r\nbuilding librustc from 1662M down to 1502M.  Since 1662 - 1502 = 160,\r\nthis may not recover the entirety of the observed memory regression\r\n(250M) from PR #14604.  (However, according to my local measurements,\r\nthe regression when building librustc was more like 209M, so perhaps\r\nthis will still recover the lions share of the lost memory.)", "tree": {"sha": "81ea51b1f712635ea2984bb7134788de085a14f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81ea51b1f712635ea2984bb7134788de085a14f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0d3cf6b2a1db489520712f7e0a47874176c35de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0d3cf6b2a1db489520712f7e0a47874176c35de", "html_url": "https://github.com/rust-lang/rust/commit/e0d3cf6b2a1db489520712f7e0a47874176c35de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0d3cf6b2a1db489520712f7e0a47874176c35de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b00f4ec8f17e7007c9032114c5b0d0d50ab18522", "url": "https://api.github.com/repos/rust-lang/rust/commits/b00f4ec8f17e7007c9032114c5b0d0d50ab18522", "html_url": "https://github.com/rust-lang/rust/commit/b00f4ec8f17e7007c9032114c5b0d0d50ab18522"}, {"sha": "4459fe3e5ef84bc25a93c7c388006465b157dab2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4459fe3e5ef84bc25a93c7c388006465b157dab2", "html_url": "https://github.com/rust-lang/rust/commit/4459fe3e5ef84bc25a93c7c388006465b157dab2"}], "stats": {"total": 378, "additions": 240, "deletions": 138}, "files": [{"sha": "b207543398aaa2ec6b18df2ffbb1c74a754f39a1", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -100,7 +100,7 @@ fn enc_vec_per_param_space<T>(w: &mut MemWriter,\n                               op: |&mut MemWriter, &ctxt, &T|) {\n     for &space in subst::ParamSpace::all().iter() {\n         mywrite!(w, \"[\");\n-        for t in v.get_vec(space).iter() {\n+        for t in v.get_slice(space).iter() {\n             op(w, cx, t);\n         }\n         mywrite!(w, \"]\");"}, {"sha": "d7a7d2902b49153b87d489896d3f113071062f5c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -810,7 +810,7 @@ fn encode_vec_per_param_space<T>(ebml_w: &mut Encoder,\n                                  v: &subst::VecPerParamSpace<T>,\n                                  f: |&mut Encoder, &T|) {\n     for &space in subst::ParamSpace::all().iter() {\n-        ebml_w.emit_from_vec(v.get_vec(space).as_slice(),\n+        ebml_w.emit_from_vec(v.get_slice(space),\n                              |ebml_w, n| Ok(f(ebml_w, n))).unwrap();\n     }\n }"}, {"sha": "4684bd3532ec13ebb9daedfbb227b958c0da7031", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 135, "deletions": 34, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -15,7 +15,6 @@ use middle::ty_fold;\n use middle::ty_fold::{TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n-use std::iter::Chain;\n use std::mem;\n use std::raw;\n use std::slice::{Items, MutItems};\n@@ -191,8 +190,8 @@ impl Substs {\n     }\n \n     pub fn with_method_from(self, substs: &Substs) -> Substs {\n-        self.with_method((*substs.types.get_vec(FnSpace)).clone(),\n-                         (*substs.regions().get_vec(FnSpace)).clone())\n+        self.with_method(Vec::from_slice(substs.types.get_slice(FnSpace)),\n+                         Vec::from_slice(substs.regions().get_slice(FnSpace)))\n     }\n \n     pub fn with_method(self,\n@@ -261,13 +260,44 @@ impl ParamSpace {\n  */\n #[deriving(PartialEq, Eq, Clone, Hash, Encodable, Decodable)]\n pub struct VecPerParamSpace<T> {\n-    vecs: (Vec<T>, Vec<T>, Vec<T>)\n+    // This was originally represented as a tuple with one Vec<T> for\n+    // each variant of ParamSpace, and that remains the abstraction\n+    // that it provides to its clients.\n+    //\n+    // Here is how the representation corresponds to the abstraction\n+    // i.e. the \"abstraction function\" AF:\n+    //\n+    // AF(self) = (self.content.slice_to(self.type_limit),\n+    //             self.content.slice(self.type_limit, self.self_limit),\n+    //             self.content.slice_from(self.self_limit))\n+    type_limit: uint,\n+    self_limit: uint,\n+    content: Vec<T>,\n+}\n+\n+impl<T:Clone> VecPerParamSpace<T> {\n+    pub fn push_all(&mut self, space: ParamSpace, values: &[T]) {\n+        // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n+        for t in values.iter() {\n+            self.push(space, t.clone());\n+        }\n+    }\n }\n \n impl<T> VecPerParamSpace<T> {\n+    fn limits(&self, space: ParamSpace) -> (uint, uint) {\n+        match space {\n+            TypeSpace => (0, self.type_limit),\n+            SelfSpace => (self.type_limit, self.self_limit),\n+            FnSpace => (self.self_limit, self.content.len()),\n+        }\n+    }\n+\n     pub fn empty() -> VecPerParamSpace<T> {\n         VecPerParamSpace {\n-            vecs: (Vec::new(), Vec::new(), Vec::new())\n+            type_limit: 0,\n+            self_limit: 0,\n+            content: Vec::new()\n         }\n     }\n \n@@ -276,8 +306,15 @@ impl<T> VecPerParamSpace<T> {\n     }\n \n     pub fn new(t: Vec<T>, s: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n+        let type_limit = t.len();\n+        let self_limit = t.len() + s.len();\n+        let mut content = t;\n+        content.push_all_move(s);\n+        content.push_all_move(f);\n         VecPerParamSpace {\n-            vecs: (t, s, f)\n+            type_limit: type_limit,\n+            self_limit: self_limit,\n+            content: content,\n         }\n     }\n \n@@ -289,55 +326,98 @@ impl<T> VecPerParamSpace<T> {\n         result\n     }\n \n+    /// Appends `value` to the vector associated with `space`.\n+    ///\n+    /// Unlike the `push` method in `Vec`, this should not be assumed\n+    /// to be a cheap operation (even when amortized over many calls).\n     pub fn push(&mut self, space: ParamSpace, value: T) {\n-        self.get_mut_vec(space).push(value);\n+        let (_, limit) = self.limits(space);\n+        match space {\n+            TypeSpace => { self.type_limit += 1; self.self_limit += 1; }\n+            SelfSpace => { self.self_limit += 1; }\n+            FnSpace   => {}\n+        }\n+        self.content.insert(limit, value);\n+    }\n+\n+    pub fn pop(&mut self, space: ParamSpace) -> Option<T> {\n+        let (start, limit) = self.limits(space);\n+        if start == limit {\n+            None\n+        } else {\n+            match space {\n+                TypeSpace => { self.type_limit -= 1; self.self_limit -= 1; }\n+                SelfSpace => { self.self_limit -= 1; }\n+                FnSpace   => {}\n+            }\n+            self.content.remove(limit - 1)\n+        }\n+    }\n+\n+    pub fn truncate(&mut self, space: ParamSpace, len: uint) {\n+        // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n+        while self.len(space) > len {\n+            self.pop(space);\n+        }\n+    }\n+\n+    pub fn replace(&mut self, space: ParamSpace, elems: Vec<T>) {\n+        // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n+        self.truncate(space, 0);\n+        for t in elems.move_iter() {\n+            self.push(space, t);\n+        }\n     }\n \n     pub fn get_self<'a>(&'a self) -> Option<&'a T> {\n-        let v = self.get_vec(SelfSpace);\n+        let v = self.get_slice(SelfSpace);\n         assert!(v.len() <= 1);\n-        if v.len() == 0 { None } else { Some(v.get(0)) }\n+        if v.len() == 0 { None } else { Some(&v[0]) }\n     }\n \n     pub fn len(&self, space: ParamSpace) -> uint {\n-        self.get_vec(space).len()\n+        self.get_slice(space).len()\n+    }\n+\n+    pub fn is_empty_in(&self, space: ParamSpace) -> bool {\n+        self.len(space) == 0\n     }\n \n-    pub fn get_vec<'a>(&'a self, space: ParamSpace) -> &'a Vec<T> {\n-        self.vecs.get(space as uint).unwrap()\n+    pub fn get_slice<'a>(&'a self, space: ParamSpace) -> &'a [T] {\n+        let (start, limit) = self.limits(space);\n+        self.content.slice(start, limit)\n     }\n \n-    pub fn get_mut_vec<'a>(&'a mut self, space: ParamSpace) -> &'a mut Vec<T> {\n-        self.vecs.get_mut(space as uint).unwrap()\n+    fn get_mut_slice<'a>(&'a mut self, space: ParamSpace) -> &'a mut [T] {\n+        let (start, limit) = self.limits(space);\n+        self.content.mut_slice(start, limit)\n     }\n \n     pub fn opt_get<'a>(&'a self,\n                        space: ParamSpace,\n                        index: uint)\n                        -> Option<&'a T> {\n-        let v = self.get_vec(space);\n-        if index < v.len() { Some(v.get(index)) } else { None }\n+        let v = self.get_slice(space);\n+        if index < v.len() { Some(&v[index]) } else { None }\n     }\n \n     pub fn get<'a>(&'a self, space: ParamSpace, index: uint) -> &'a T {\n-        self.get_vec(space).get(index)\n+        &self.get_slice(space)[index]\n     }\n \n     pub fn get_mut<'a>(&'a mut self,\n                        space: ParamSpace,\n                        index: uint) -> &'a mut T {\n-        self.get_mut_vec(space).get_mut(index)\n+        &mut self.get_mut_slice(space)[index]\n     }\n \n-    pub fn iter<'a>(&'a self) -> Chain<Items<'a,T>,\n-                                       Chain<Items<'a,T>,\n-                                             Items<'a,T>>> {\n-        let (ref r, ref s, ref f) = self.vecs;\n-        r.iter().chain(s.iter().chain(f.iter()))\n+    pub fn iter<'a>(&'a self) -> Items<'a,T> {\n+        self.content.iter()\n     }\n \n-    pub fn all_vecs(&self, pred: |&Vec<T>| -> bool) -> bool {\n-        self.vecs.iter().all(pred)\n+    pub fn all_vecs(&self, pred: |&[T]| -> bool) -> bool {\n+        let spaces = [TypeSpace, SelfSpace, FnSpace];\n+        spaces.iter().all(|&space| { pred(self.get_slice(space)) })\n     }\n \n     pub fn all(&self, pred: |&T| -> bool) -> bool {\n@@ -353,9 +433,13 @@ impl<T> VecPerParamSpace<T> {\n     }\n \n     pub fn map<U>(&self, pred: |&T| -> U) -> VecPerParamSpace<U> {\n-        VecPerParamSpace::new(self.vecs.ref0().iter().map(|p| pred(p)).collect(),\n-                              self.vecs.ref1().iter().map(|p| pred(p)).collect(),\n-                              self.vecs.ref2().iter().map(|p| pred(p)).collect())\n+        // FIXME (#15418): this could avoid allocating the intermediate\n+        // Vec's, but note that the values of type_limit and self_limit\n+        // also need to be kept in sync during construction.\n+        VecPerParamSpace::new(\n+            self.get_slice(TypeSpace).iter().map(|p| pred(p)).collect(),\n+            self.get_slice(SelfSpace).iter().map(|p| pred(p)).collect(),\n+            self.get_slice(FnSpace).iter().map(|p| pred(p)).collect())\n     }\n \n     pub fn map_rev<U>(&self, pred: |&T| -> U) -> VecPerParamSpace<U> {\n@@ -368,29 +452,46 @@ impl<T> VecPerParamSpace<T> {\n          * can be run to a fixed point\n          */\n \n-        let mut fns: Vec<U> = self.vecs.ref2().iter().rev().map(|p| pred(p)).collect();\n+        let mut fns: Vec<U> = self.get_slice(FnSpace).iter().rev().map(|p| pred(p)).collect();\n \n         // NB: Calling foo.rev().map().rev() causes the calls to map\n         // to occur in the wrong order. This was somewhat surprising\n         // to me, though it makes total sense.\n         fns.reverse();\n \n-        let mut selfs: Vec<U> = self.vecs.ref1().iter().rev().map(|p| pred(p)).collect();\n+        let mut selfs: Vec<U> = self.get_slice(SelfSpace).iter().rev().map(|p| pred(p)).collect();\n         selfs.reverse();\n-        let mut tys: Vec<U> = self.vecs.ref0().iter().rev().map(|p| pred(p)).collect();\n+        let mut tys: Vec<U> = self.get_slice(TypeSpace).iter().rev().map(|p| pred(p)).collect();\n         tys.reverse();\n         VecPerParamSpace::new(tys, selfs, fns)\n     }\n \n     pub fn split(self) -> (Vec<T>, Vec<T>, Vec<T>) {\n-        self.vecs\n+        // FIXME (#15418): this does two traversals when in principle\n+        // one would suffice.  i.e. change to use `move_iter`.\n+        let VecPerParamSpace { type_limit, self_limit, content } = self;\n+        let mut i = 0;\n+        let (prefix, fn_vec) = content.partition(|_| {\n+            let on_left = i < self_limit;\n+            i += 1;\n+            on_left\n+        });\n+\n+        let mut i = 0;\n+        let (type_vec, self_vec) = prefix.partition(|_| {\n+            let on_left = i < type_limit;\n+            i += 1;\n+            on_left\n+        });\n+\n+        (type_vec, self_vec, fn_vec)\n     }\n \n     pub fn with_vec(mut self, space: ParamSpace, vec: Vec<T>)\n                     -> VecPerParamSpace<T>\n     {\n-        assert!(self.get_vec(space).is_empty());\n-        *self.get_mut_vec(space) = vec;\n+        assert!(self.is_empty_in(space));\n+        self.replace(space, vec);\n         self\n     }\n }"}, {"sha": "dc9828606cc33d73e5ae9857285b8b6be1b58f1b", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -216,10 +216,8 @@ fn resolve_default_method_vtables(bcx: &Block,\n         bcx.tcx(), &param_substs, &impl_res);\n \n     // Now we pull any vtables for parameters on the actual method.\n-    param_vtables\n-        .get_mut_vec(subst::FnSpace)\n-        .push_all(\n-            impl_vtables.get_vec(subst::FnSpace).as_slice());\n+    param_vtables.push_all(subst::FnSpace,\n+                           impl_vtables.get_slice(subst::FnSpace));\n \n     param_vtables\n }"}, {"sha": "ddcc4c4bfa124720cbc73b4e44041a8098864a33", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -554,7 +554,7 @@ impl TypeMap {\n \n             // Maybe check that there is no self type here.\n \n-            let tps = substs.types.get_vec(subst::TypeSpace);\n+            let tps = substs.types.get_slice(subst::TypeSpace);\n             if tps.len() > 0 {\n                 output.push_char('<');\n \n@@ -1377,9 +1377,9 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         }\n \n         // Handle other generic parameters\n-        let actual_types = param_substs.substs.types.get_vec(subst::FnSpace);\n+        let actual_types = param_substs.substs.types.get_slice(subst::FnSpace);\n         for (index, &ast::TyParam{ ident: ident, .. }) in generics.ty_params.iter().enumerate() {\n-            let actual_type = *actual_types.get(index);\n+            let actual_type = actual_types[index];\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,"}, {"sha": "c26e11134b60afaf9e6c0c6728dbbab604004510", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -209,7 +209,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         // avoids creating more than one copy of the enum when one\n         // of the enum's variants refers to the enum itself.\n         let repr = adt::represent_type(cx, t);\n-        let tps = substs.types.get_vec(subst::TypeSpace);\n+        let tps = substs.types.get_slice(subst::TypeSpace);\n         let name = llvm_type_name(cx, an_enum, did, tps);\n         adt::incomplete_type_of(cx, &*repr, name.as_slice())\n       }\n@@ -266,7 +266,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n               // in *after* placing it into the type cache. This prevents\n               // infinite recursion with recursive struct types.\n               let repr = adt::represent_type(cx, t);\n-              let tps = substs.types.get_vec(subst::TypeSpace);\n+              let tps = substs.types.get_slice(subst::TypeSpace);\n               let name = llvm_type_name(cx, a_struct, did, tps);\n               adt::incomplete_type_of(cx, &*repr, name.as_slice())\n           }\n@@ -305,7 +305,7 @@ pub enum named_ty { a_struct, an_enum }\n pub fn llvm_type_name(cx: &CrateContext,\n                       what: named_ty,\n                       did: ast::DefId,\n-                      tps: &Vec<ty::t>)\n+                      tps: &[ty::t])\n                       -> String\n {\n     let name = match what {"}, {"sha": "141731ded9562fa2410de52540892997075fc434", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -981,7 +981,7 @@ impl Generics {\n     }\n \n     pub fn has_type_params(&self, space: subst::ParamSpace) -> bool {\n-        !self.types.get_vec(space).is_empty()\n+        !self.types.is_empty_in(space)\n     }\n }\n \n@@ -4644,14 +4644,14 @@ pub fn construct_parameter_environment(\n     let mut types = VecPerParamSpace::empty();\n     for &space in subst::ParamSpace::all().iter() {\n         push_types_from_defs(tcx, &mut types, space,\n-                             generics.types.get_vec(space));\n+                             generics.types.get_slice(space));\n     }\n \n     // map bound 'a => free 'a\n     let mut regions = VecPerParamSpace::empty();\n     for &space in subst::ParamSpace::all().iter() {\n         push_region_params(&mut regions, space, free_id,\n-                           generics.regions.get_vec(space));\n+                           generics.regions.get_slice(space));\n     }\n \n     let free_substs = Substs {\n@@ -4666,7 +4666,7 @@ pub fn construct_parameter_environment(\n     let mut bounds = VecPerParamSpace::empty();\n     for &space in subst::ParamSpace::all().iter() {\n         push_bounds_from_defs(tcx, &mut bounds, space, &free_substs,\n-                              generics.types.get_vec(space));\n+                              generics.types.get_slice(space));\n     }\n \n     debug!(\"construct_parameter_environment: free_id={} \\\n@@ -4684,7 +4684,7 @@ pub fn construct_parameter_environment(\n     fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,\n                           space: subst::ParamSpace,\n                           free_id: ast::NodeId,\n-                          region_params: &Vec<RegionParameterDef>)\n+                          region_params: &[RegionParameterDef])\n     {\n         for r in region_params.iter() {\n             regions.push(space, ty::free_region_from_def(free_id, r));\n@@ -4694,7 +4694,7 @@ pub fn construct_parameter_environment(\n     fn push_types_from_defs(tcx: &ty::ctxt,\n                             types: &mut subst::VecPerParamSpace<ty::t>,\n                             space: subst::ParamSpace,\n-                            defs: &Vec<TypeParameterDef>) {\n+                            defs: &[TypeParameterDef]) {\n         for (i, def) in defs.iter().enumerate() {\n             let ty = ty::mk_param(tcx, space, i, def.def_id);\n             types.push(space, ty);\n@@ -4705,7 +4705,7 @@ pub fn construct_parameter_environment(\n                              bounds: &mut subst::VecPerParamSpace<ParamBounds>,\n                              space: subst::ParamSpace,\n                              free_substs: &subst::Substs,\n-                             defs: &Vec<TypeParameterDef>) {\n+                             defs: &[TypeParameterDef]) {\n         for def in defs.iter() {\n             let b = (*def.bounds).subst(tcx, free_substs);\n             bounds.push(space, b);"}, {"sha": "286cb5364758a9d5c157d19c99fe190012e36125", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -203,7 +203,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     };\n \n     // Convert the type parameters supplied by the user.\n-    let ty_param_defs = decl_generics.types.get_vec(TypeSpace);\n+    let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n     let supplied_ty_param_count = path.segments.iter().flat_map(|s| s.types.iter()).count();\n     let formal_ty_param_count = ty_param_defs.len();\n     let required_ty_param_count = ty_param_defs.iter()"}, {"sha": "6e44665fb3b46bc5e9b625be38f8fa4e27a953c8", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -264,7 +264,7 @@ fn construct_transformed_self_ty_for_object(\n     // The subst we get in has Err as the \"Self\" type. For an object\n     // type, we don't put any type into the Self paramspace, so let's\n     // make a copy of rcvr_substs that has the Self paramspace empty.\n-    obj_substs.types.get_mut_vec(subst::SelfSpace).pop().unwrap();\n+    obj_substs.types.pop(subst::SelfSpace).unwrap();\n \n     match method_ty.explicit_self {\n         ast::SelfStatic => {\n@@ -1133,7 +1133,7 @@ impl<'a> LookupContext<'a> {\n         let m_regions =\n             self.fcx.infcx().region_vars_for_defs(\n                 self.span,\n-                candidate.method_ty.generics.regions.get_vec(subst::FnSpace));\n+                candidate.method_ty.generics.regions.get_slice(subst::FnSpace));\n \n         let all_substs = candidate.rcvr_substs.clone().with_method(m_types, m_regions);\n "}, {"sha": "e4d9bcfad61ce3fe19dc1fc5b1f1088e2bd62902", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -917,8 +917,8 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         return;\n     }\n \n-    let it = trait_m.generics.types.get_vec(subst::FnSpace).iter()\n-        .zip(impl_m.generics.types.get_vec(subst::FnSpace).iter());\n+    let it = trait_m.generics.types.get_slice(subst::FnSpace).iter()\n+        .zip(impl_m.generics.types.get_slice(subst::FnSpace).iter());\n \n     // This code is best explained by example. Consider a trait:\n     //\n@@ -989,8 +989,8 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     let trait_to_skol_substs =\n         trait_to_impl_substs\n         .subst(tcx, &impl_to_skol_substs)\n-        .with_method(skol_tps.get_vec(subst::FnSpace).clone(),\n-                     skol_regions.get_vec(subst::FnSpace).clone());\n+        .with_method(Vec::from_slice(skol_tps.get_slice(subst::FnSpace)),\n+                     Vec::from_slice(skol_regions.get_slice(subst::FnSpace)));\n     let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n@@ -2002,7 +2002,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n     let ity = ty::lookup_item_type(tcx, did);\n     let (n_tps, rps, raw_ty) =\n         (ity.generics.types.len(subst::TypeSpace),\n-         ity.generics.regions.get_vec(subst::TypeSpace),\n+         ity.generics.regions.get_slice(subst::TypeSpace),\n          ity.ty);\n \n     let rps = vcx.infcx.region_vars_for_defs(span, rps);\n@@ -4126,12 +4126,10 @@ pub fn instantiate_path(fcx: &FnCtxt,\n     // a problem.\n     for &space in ParamSpace::all().iter() {\n         adjust_type_parameters(fcx, span, space, type_defs, &mut substs);\n-        assert_eq!(substs.types.get_vec(space).len(),\n-                   type_defs.get_vec(space).len());\n+        assert_eq!(substs.types.len(space), type_defs.len(space));\n \n         adjust_region_parameters(fcx, span, space, region_defs, &mut substs);\n-        assert_eq!(substs.regions().get_vec(space).len(),\n-                   region_defs.get_vec(space).len());\n+        assert_eq!(substs.regions().len(space), region_defs.len(space));\n     }\n \n     fcx.write_ty_substs(node_id, polytype.ty, ty::ItemSubsts {\n@@ -4183,8 +4181,8 @@ pub fn instantiate_path(fcx: &FnCtxt,\n          */\n \n         {\n-            let type_count = type_defs.get_vec(space).len();\n-            assert_eq!(substs.types.get_vec(space).len(), 0);\n+            let type_count = type_defs.len(space);\n+            assert_eq!(substs.types.len(space), 0);\n             for (i, &typ) in segment.types.iter().enumerate() {\n                 let t = fcx.to_ty(&*typ);\n                 if i < type_count {\n@@ -4198,14 +4196,14 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                              but found {} parameter(s)\",\n                             type_count,\n                             segment.types.len()).as_slice());\n-                    substs.types.get_mut_vec(space).truncate(0);\n+                    substs.types.truncate(space, 0);\n                 }\n             }\n         }\n \n         {\n-            let region_count = region_defs.get_vec(space).len();\n-            assert_eq!(substs.regions().get_vec(space).len(), 0);\n+            let region_count = region_defs.len(space);\n+            assert_eq!(substs.regions().len(space), 0);\n             for (i, lifetime) in segment.lifetimes.iter().enumerate() {\n                 let r = ast_region_to_region(fcx.tcx(), lifetime);\n                 if i < region_count {\n@@ -4218,7 +4216,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                              expected {} parameter(s) but found {} parameter(s)\",\n                             region_count,\n                             segment.lifetimes.len()).as_slice());\n-                    substs.mut_regions().get_mut_vec(space).truncate(0);\n+                    substs.mut_regions().truncate(space, 0);\n                 }\n             }\n         }\n@@ -4231,8 +4229,8 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         defs: &VecPerParamSpace<ty::TypeParameterDef>,\n         substs: &mut Substs)\n     {\n-        let provided_len = substs.types.get_vec(space).len();\n-        let desired = defs.get_vec(space).as_slice();\n+        let provided_len = substs.types.len(space);\n+        let desired = defs.get_slice(space);\n         let required_len = desired.iter()\n                               .take_while(|d| d.default.is_none())\n                               .count();\n@@ -4252,8 +4250,8 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         // Nothing specified at all: supply inference variables for\n         // everything.\n         if provided_len == 0 {\n-            let provided = substs.types.get_mut_vec(space);\n-            *provided = fcx.infcx().next_ty_vars(desired.len());\n+            substs.types.replace(space,\n+                                 fcx.infcx().next_ty_vars(desired.len()));\n             return;\n         }\n \n@@ -4270,8 +4268,8 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                             qualifier,\n                             required_len,\n                             provided_len).as_slice());\n-            let provided = substs.types.get_mut_vec(space);\n-            *provided = Vec::from_elem(desired.len(), ty::mk_err());\n+            substs.types.replace(space,\n+                                 Vec::from_elem(desired.len(), ty::mk_err()));\n             return;\n         }\n \n@@ -4287,7 +4285,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n             let default = default.subst_spanned(fcx.tcx(), substs, Some(span));\n             substs.types.push(space, default);\n         }\n-        assert_eq!(substs.types.get_vec(space).len(), desired.len());\n+        assert_eq!(substs.types.len(space), desired.len());\n \n         debug!(\"Final substs: {}\", substs.repr(fcx.tcx()));\n     }\n@@ -4299,20 +4297,22 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         defs: &VecPerParamSpace<ty::RegionParameterDef>,\n         substs: &mut Substs)\n     {\n-        let provided = substs.mut_regions().get_mut_vec(space);\n-        let desired = defs.get_vec(space);\n+        let provided_len = substs.mut_regions().len(space);\n+        let desired = defs.get_slice(space);\n \n         // Enforced by `push_explicit_parameters_from_segment_to_substs()`.\n-        assert!(provided.len() <= desired.len());\n+        assert!(provided_len <= desired.len());\n \n         // If nothing was provided, just use inference variables.\n-        if provided.len() == 0 {\n-            *provided = fcx.infcx().region_vars_for_defs(span, desired);\n+        if provided_len == 0 {\n+            substs.mut_regions().replace(\n+                space,\n+                fcx.infcx().region_vars_for_defs(span, desired));\n             return;\n         }\n \n         // If just the right number were provided, everybody is happy.\n-        if provided.len() == desired.len() {\n+        if provided_len == desired.len() {\n             return;\n         }\n \n@@ -4325,9 +4325,11 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                          expected {} parameter(s) \\\n                          but found {} parameter(s)\",\n                 desired.len(),\n-                provided.len()).as_slice());\n+                provided_len).as_slice());\n \n-        *provided = fcx.infcx().region_vars_for_defs(span, desired);\n+        substs.mut_regions().replace(\n+            space,\n+            fcx.infcx().region_vars_for_defs(span, desired));\n     }\n }\n "}, {"sha": "b9bf8e37dead8c926faaa328412dd77a5e90edbc", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -735,12 +735,12 @@ pub fn make_substs_for_receiver_types(tcx: &ty::ctxt,\n      */\n \n     let meth_tps: Vec<ty::t> =\n-        method.generics.types.get_vec(subst::FnSpace)\n+        method.generics.types.get_slice(subst::FnSpace)\n               .iter()\n               .map(|def| ty::mk_param_from_def(tcx, def))\n               .collect();\n     let meth_regions: Vec<ty::Region> =\n-        method.generics.regions.get_vec(subst::FnSpace)\n+        method.generics.regions.get_slice(subst::FnSpace)\n               .iter()\n               .map(|def| ty::ReEarlyBound(def.def_id.node, def.space,\n                                           def.index, def.name))\n@@ -767,10 +767,12 @@ fn subst_receiver_types_in_method_ty(tcx: &ty::ctxt,\n     // replace the type parameters declared on the trait with those\n     // from the impl\n     for &space in [subst::TypeSpace, subst::SelfSpace].iter() {\n-        *method_generics.types.get_mut_vec(space) =\n-            impl_poly_type.generics.types.get_vec(space).clone();\n-        *method_generics.regions.get_mut_vec(space) =\n-            impl_poly_type.generics.regions.get_vec(space).clone();\n+        method_generics.types.replace(\n+            space,\n+            Vec::from_slice(impl_poly_type.generics.types.get_slice(space)));\n+        method_generics.regions.replace(\n+            space,\n+            Vec::from_slice(impl_poly_type.generics.regions.get_slice(space)));\n     }\n \n     debug!(\"subst_receiver_types_in_method_ty: method_generics={}\","}, {"sha": "1e33b1d5d0ebd5368044a1a6c51a5c273a95ed64", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -115,32 +115,30 @@ pub trait Combine {\n         let mut substs = subst::Substs::empty();\n \n         for &space in subst::ParamSpace::all().iter() {\n-            let a_tps = a_subst.types.get_vec(space);\n-            let b_tps = b_subst.types.get_vec(space);\n-            let tps = if_ok!(self.tps(space,\n-                                      a_tps.as_slice(),\n-                                      b_tps.as_slice()));\n-\n-            let a_regions = a_subst.regions().get_vec(space);\n-            let b_regions = b_subst.regions().get_vec(space);\n-            let r_variances = variances.regions.get_vec(space);\n+            let a_tps = a_subst.types.get_slice(space);\n+            let b_tps = b_subst.types.get_slice(space);\n+            let tps = if_ok!(self.tps(space, a_tps, b_tps));\n+\n+            let a_regions = a_subst.regions().get_slice(space);\n+            let b_regions = b_subst.regions().get_slice(space);\n+            let r_variances = variances.regions.get_slice(space);\n             let regions = if_ok!(relate_region_params(self,\n                                                       item_def_id,\n                                                       r_variances,\n                                                       a_regions,\n                                                       b_regions));\n \n-            *substs.types.get_mut_vec(space) = tps;\n-            *substs.mut_regions().get_mut_vec(space) = regions;\n+            substs.types.replace(space, tps);\n+            substs.mut_regions().replace(space, regions);\n         }\n \n         return Ok(substs);\n \n         fn relate_region_params<C:Combine>(this: &C,\n                                            item_def_id: ast::DefId,\n-                                           variances: &Vec<ty::Variance>,\n-                                           a_rs: &Vec<ty::Region>,\n-                                           b_rs: &Vec<ty::Region>)\n+                                           variances: &[ty::Variance],\n+                                           a_rs: &[ty::Region],\n+                                           b_rs: &[ty::Region])\n                                            -> cres<Vec<ty::Region>>\n         {\n             let tcx = this.infcx().tcx;\n@@ -160,9 +158,9 @@ pub trait Combine {\n             assert_eq!(num_region_params, b_rs.len());\n             let mut rs = vec!();\n             for i in range(0, num_region_params) {\n-                let a_r = *a_rs.get(i);\n-                let b_r = *b_rs.get(i);\n-                let variance = *variances.get(i);\n+                let a_r = a_rs[i];\n+                let b_r = b_rs[i];\n+                let variance = variances[i];\n                 let r = match variance {\n                     ty::Invariant => {\n                         eq_regions(this, a_r, b_r)"}, {"sha": "b505536a59db2b210b9d6d8bdaad8b137b310c03", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -624,7 +624,7 @@ impl<'a> InferCtxt<'a> {\n \n     pub fn region_vars_for_defs(&self,\n                                 span: Span,\n-                                defs: &Vec<ty::RegionParameterDef>)\n+                                defs: &[ty::RegionParameterDef])\n                                 -> Vec<ty::Region> {\n         defs.iter()\n             .map(|d| self.next_region_var(EarlyBoundRegion(span, d.name)))\n@@ -647,7 +647,7 @@ impl<'a> InferCtxt<'a> {\n         assert!(generics.regions.len(subst::FnSpace) == 0);\n \n         let type_parameter_count = generics.types.len(subst::TypeSpace);\n-        let region_param_defs = generics.regions.get_vec(subst::TypeSpace);\n+        let region_param_defs = generics.regions.get_slice(subst::TypeSpace);\n         let regions = self.region_vars_for_defs(span, region_param_defs);\n         let type_parameters = self.next_ty_vars(type_parameter_count);\n         subst::Substs::new_type(type_parameters, regions)"}, {"sha": "fb3ce391d8e34b12d4756de47e2f5c904933faf9", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -749,15 +749,15 @@ impl<'a> ConstraintContext<'a> {\n \n                 // All type parameters on enums and structs should be\n                 // in the TypeSpace.\n-                assert!(generics.types.get_vec(subst::SelfSpace).is_empty());\n-                assert!(generics.types.get_vec(subst::FnSpace).is_empty());\n-                assert!(generics.regions.get_vec(subst::SelfSpace).is_empty());\n-                assert!(generics.regions.get_vec(subst::FnSpace).is_empty());\n+                assert!(generics.types.is_empty_in(subst::SelfSpace));\n+                assert!(generics.types.is_empty_in(subst::FnSpace));\n+                assert!(generics.regions.is_empty_in(subst::SelfSpace));\n+                assert!(generics.regions.is_empty_in(subst::FnSpace));\n \n                 self.add_constraints_from_substs(\n                     def_id,\n-                    generics.types.get_vec(subst::TypeSpace),\n-                    generics.regions.get_vec(subst::TypeSpace),\n+                    generics.types.get_slice(subst::TypeSpace),\n+                    generics.regions.get_slice(subst::TypeSpace),\n                     substs,\n                     variance);\n             }\n@@ -768,22 +768,22 @@ impl<'a> ConstraintContext<'a> {\n \n                 // Traits DO have a Self type parameter, but it is\n                 // erased from object types.\n-                assert!(!generics.types.get_vec(subst::SelfSpace).is_empty() &&\n-                        substs.types.get_vec(subst::SelfSpace).is_empty());\n+                assert!(!generics.types.is_empty_in(subst::SelfSpace) &&\n+                        substs.types.is_empty_in(subst::SelfSpace));\n \n                 // Traits never declare region parameters in the self\n                 // space.\n-                assert!(generics.regions.get_vec(subst::SelfSpace).is_empty());\n+                assert!(generics.regions.is_empty_in(subst::SelfSpace));\n \n                 // Traits never declare type/region parameters in the\n                 // fn space.\n-                assert!(generics.types.get_vec(subst::FnSpace).is_empty());\n-                assert!(generics.regions.get_vec(subst::FnSpace).is_empty());\n+                assert!(generics.types.is_empty_in(subst::FnSpace));\n+                assert!(generics.regions.is_empty_in(subst::FnSpace));\n \n                 self.add_constraints_from_substs(\n                     def_id,\n-                    generics.types.get_vec(subst::TypeSpace),\n-                    generics.regions.get_vec(subst::TypeSpace),\n+                    generics.types.get_slice(subst::TypeSpace),\n+                    generics.regions.get_slice(subst::TypeSpace),\n                     substs,\n                     variance);\n             }\n@@ -832,8 +832,8 @@ impl<'a> ConstraintContext<'a> {\n     /// object, etc) appearing in a context with ambient variance `variance`\n     fn add_constraints_from_substs(&mut self,\n                                    def_id: ast::DefId,\n-                                   type_param_defs: &Vec<ty::TypeParameterDef>,\n-                                   region_param_defs: &Vec<ty::RegionParameterDef>,\n+                                   type_param_defs: &[ty::TypeParameterDef],\n+                                   region_param_defs: &[ty::RegionParameterDef],\n                                    substs: &subst::Substs,\n                                    variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);"}, {"sha": "85edd4ea481aeb031249b273e28ce94a5c914454", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -449,8 +449,8 @@ pub fn parameterized(cx: &ctxt,\n         }\n     }\n \n-    let tps = substs.types.get_vec(subst::TypeSpace);\n-    let ty_params = generics.types.get_vec(subst::TypeSpace);\n+    let tps = substs.types.get_slice(subst::TypeSpace);\n+    let ty_params = generics.types.get_slice(subst::TypeSpace);\n     let has_defaults = ty_params.last().map_or(false, |def| def.default.is_some());\n     let num_defaults = if has_defaults && !cx.sess.verbose() {\n         ty_params.iter().zip(tps.iter()).rev().take_while(|&(def, &actual)| {\n@@ -468,7 +468,7 @@ pub fn parameterized(cx: &ctxt,\n     }\n \n     if cx.sess.verbose() {\n-        for t in substs.types.get_vec(subst::SelfSpace).iter() {\n+        for t in substs.types.get_slice(subst::SelfSpace).iter() {\n             strs.push(format!(\"for {}\", t.repr(cx)));\n         }\n     }\n@@ -598,9 +598,9 @@ impl Repr for subst::Substs {\n impl<T:Repr> Repr for subst::VecPerParamSpace<T> {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"[{};{};{}]\",\n-                       self.get_vec(subst::TypeSpace).repr(tcx),\n-                       self.get_vec(subst::SelfSpace).repr(tcx),\n-                       self.get_vec(subst::FnSpace).repr(tcx))\n+                       self.get_slice(subst::TypeSpace).repr(tcx),\n+                       self.get_slice(subst::SelfSpace).repr(tcx),\n+                       self.get_slice(subst::FnSpace).repr(tcx))\n     }\n }\n "}, {"sha": "12c183132d622d7abd8a25490788545f865e0af1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d3cf6b2a1db489520712f7e0a47874176c35de/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e0d3cf6b2a1db489520712f7e0a47874176c35de", "patch": "@@ -505,11 +505,12 @@ impl Clean<TyParamBound> for ast::TyParamBound {\n }\n \n fn external_path(name: &str, substs: &subst::Substs) -> Path {\n-    let lifetimes = substs.regions().get_vec(subst::TypeSpace)\n+    let lifetimes = substs.regions().get_slice(subst::TypeSpace)\n                     .iter()\n                     .filter_map(|v| v.clean())\n                     .collect();\n-    let types = substs.types.get_vec(subst::TypeSpace).clean();\n+    let types = Vec::from_slice(substs.types.get_slice(subst::TypeSpace));\n+    let types = types.clean();\n     Path {\n         global: false,\n         segments: vec![PathSegment {\n@@ -674,8 +675,8 @@ impl Clean<Generics> for ty::Generics {\n         // is implicit.\n \n         let space = {\n-            if !self.types.get_vec(subst::FnSpace).is_empty() ||\n-                !self.regions.get_vec(subst::FnSpace).is_empty()\n+            if !self.types.is_empty_in(subst::FnSpace) ||\n+                !self.regions.is_empty_in(subst::FnSpace)\n             {\n                 subst::FnSpace\n             } else {\n@@ -684,8 +685,8 @@ impl Clean<Generics> for ty::Generics {\n         };\n \n         Generics {\n-            type_params: self.types.get_vec(space).clean(),\n-            lifetimes: self.regions.get_vec(space).clean(),\n+            type_params: Vec::from_slice(self.types.get_slice(space)).clean(),\n+            lifetimes: Vec::from_slice(self.regions.get_slice(space)).clean(),\n         }\n     }\n }"}]}