{"sha": "b92c6ee882853313698f1148512e8e992ba36b2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MmM2ZWU4ODI4NTMzMTM2OThmMTE0ODUxMmU4ZTk5MmJhMzZiMmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-14T23:11:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-14T23:11:03Z"}, "message": "Auto merge of #69172 - JohnTitor:rollup-6cbmwcw, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #68129 (Correct inference of primitive operand type behind binary operation)\n - #68475 (Use a `ParamEnvAnd<Predicate>` for caching in `ObligationForest`)\n - #68856 (typeck: clarify def_bm adjustments & add tests for or-patterns)\n - #69051 (simplify_try: address some of eddyb's comments)\n - #69128 (Fix extra subslice lowering)\n - #69150 (Follow-up to #68848)\n - #69164 (Update pulldown-cmark dependency)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "8932cd3cddd9fe9a5c99eab6fae97fb7bf435e99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8932cd3cddd9fe9a5c99eab6fae97fb7bf435e99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b92c6ee882853313698f1148512e8e992ba36b2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b92c6ee882853313698f1148512e8e992ba36b2d", "html_url": "https://github.com/rust-lang/rust/commit/b92c6ee882853313698f1148512e8e992ba36b2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b92c6ee882853313698f1148512e8e992ba36b2d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "433aae93e4ef866a1fdfefad136b32ed89acd3e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/433aae93e4ef866a1fdfefad136b32ed89acd3e7", "html_url": "https://github.com/rust-lang/rust/commit/433aae93e4ef866a1fdfefad136b32ed89acd3e7"}, {"sha": "a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67", "html_url": "https://github.com/rust-lang/rust/commit/a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67"}], "stats": {"total": 922, "additions": 715, "deletions": 207}, "files": [{"sha": "2847e3cfb04b1007dc4668ad71caa75f6ce08e4b", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -1564,7 +1564,7 @@ dependencies = [\n  \"rand_xoshiro\",\n  \"sized-chunks\",\n  \"typenum\",\n- \"version_check 0.9.1\",\n+ \"version_check\",\n ]\n \n [[package]]\n@@ -2014,9 +2014,9 @@ dependencies = [\n \n [[package]]\n name = \"memchr\"\n-version = \"2.2.0\"\n+version = \"2.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2efc7bc57c883d4a4d6e3246905283d8dae951bb3bd32f49d6ef297f546e1c39\"\n+checksum = \"53445de381a1f436797497c61d851644d0e8e88e6140f22872ad33a704933978\"\n \n [[package]]\n name = \"memmap\"\n@@ -2604,23 +2604,23 @@ dependencies = [\n \n [[package]]\n name = \"pulldown-cmark\"\n-version = \"0.5.3\"\n+version = \"0.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"77043da1282374688ee212dc44b3f37ff929431de9c9adc3053bd3cee5630357\"\n+checksum = \"1c205cc82214f3594e2d50686730314f817c67ffa80fe800cf0db78c3c2b9d9e\"\n dependencies = [\n  \"bitflags\",\n+ \"getopts\",\n  \"memchr\",\n  \"unicase\",\n ]\n \n [[package]]\n name = \"pulldown-cmark\"\n-version = \"0.6.1\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1c205cc82214f3594e2d50686730314f817c67ffa80fe800cf0db78c3c2b9d9e\"\n+checksum = \"2c2d7fd131800e0d63df52aff46201acaab70b431a4a1ec6f0343fe8e64f35a4\"\n dependencies = [\n  \"bitflags\",\n- \"getopts\",\n  \"memchr\",\n  \"unicase\",\n ]\n@@ -4160,7 +4160,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"itertools 0.8.0\",\n  \"minifier\",\n- \"pulldown-cmark 0.5.3\",\n+ \"pulldown-cmark 0.7.0\",\n  \"rustc-rayon\",\n  \"serde\",\n  \"serde_json\",\n@@ -5160,11 +5160,11 @@ checksum = \"535c204ee4d8434478593480b8f86ab45ec9aae0e83c568ca81abf0fd0e88f86\"\n \n [[package]]\n name = \"unicase\"\n-version = \"2.5.1\"\n+version = \"2.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2e2e6bd1e59e56598518beb94fd6db628ded570326f0a98c679a304bd9f00150\"\n+checksum = \"50f37be617794602aabbeee0be4f259dc1778fabe05e2d67ee8f79326d5cb4f6\"\n dependencies = [\n- \"version_check 0.1.5\",\n+ \"version_check\",\n ]\n \n [[package]]\n@@ -5334,12 +5334,6 @@ dependencies = [\n  \"failure\",\n ]\n \n-[[package]]\n-name = \"version_check\"\n-version = \"0.1.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"914b1a6776c4c929a602fafd8bc742e06365d4bcbe48c30f9cca5824f70dc9dd\"\n-\n [[package]]\n name = \"version_check\"\n version = \"0.9.1\""}, {"sha": "07352a3f9478a0c3723394f929925f7891bfa872", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -18,10 +18,13 @@ use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation};\n \n impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n-    type Predicate = ty::Predicate<'tcx>;\n+    /// Note that we include both the `ParamEnv` and the `Predicate`,\n+    /// as the `ParamEnv` can influence whether fulfillment succeeds\n+    /// or fails.\n+    type CacheKey = ty::ParamEnvAnd<'tcx, ty::Predicate<'tcx>>;\n \n-    fn as_predicate(&self) -> &Self::Predicate {\n-        &self.obligation.predicate\n+    fn as_cache_key(&self) -> Self::CacheKey {\n+        self.obligation.param_env.and(self.obligation.predicate)\n     }\n }\n "}, {"sha": "b42b12c4dd8513a1e610f314a1d5b3eea13b58a4", "filename": "src/librustc_ast_lowering/pat.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_ast_lowering%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_ast_lowering%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpat.rs?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -128,6 +128,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut slice = None;\n         let mut prev_rest_span = None;\n \n+        // Lowers `$bm $ident @ ..` to `$bm $ident @ _`.\n+        let lower_rest_sub = |this: &mut Self, pat, bm, ident, sub| {\n+            let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n+            let node = this.lower_pat_ident(pat, bm, ident, lower_sub);\n+            this.pat_with_node_id_of(pat, node)\n+        };\n+\n         let mut iter = pats.iter();\n         // Lower all the patterns until the first occurrence of a sub-slice pattern.\n         for pat in iter.by_ref() {\n@@ -142,9 +149,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n                 PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n                     prev_rest_span = Some(sub.span);\n-                    let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n-                    let node = self.lower_pat_ident(pat, bm, ident, lower_sub);\n-                    slice = Some(self.pat_with_node_id_of(pat, node));\n+                    slice = Some(lower_rest_sub(self, pat, bm, ident, sub));\n                     break;\n                 }\n                 // It was not a subslice pattern so lower it normally.\n@@ -157,9 +162,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // There was a previous subslice pattern; make sure we don't allow more.\n             let rest_span = match pat.kind {\n                 PatKind::Rest => Some(pat.span),\n-                PatKind::Ident(.., Some(ref sub)) if sub.is_rest() => {\n-                    // The `HirValidator` is merciless; add a `_` pattern to avoid ICEs.\n-                    after.push(self.pat_wild_with_node_id_of(pat));\n+                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                    // #69103: Lower into `binding @ _` as above to avoid ICEs.\n+                    after.push(lower_rest_sub(self, pat, bm, ident, sub));\n                     Some(sub.span)\n                 }\n                 _ => None,"}, {"sha": "e1784f44fd112a01961703c0ee8477e24a32247a", "filename": "src/librustc_data_structures/obligation_forest/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -52,7 +52,7 @@ impl<'a, O: ForestObligation + 'a> dot::Labeller<'a> for &'a ObligationForest<O>\n \n     fn node_label(&self, index: &Self::Node) -> dot::LabelText<'_> {\n         let node = &self.nodes[*index];\n-        let label = format!(\"{:?} ({:?})\", node.obligation.as_predicate(), node.state.get());\n+        let label = format!(\"{:?} ({:?})\", node.obligation.as_cache_key(), node.state.get());\n \n         dot::LabelText::LabelStr(label.into())\n     }"}, {"sha": "334daddba8820ad6bd13dad125f6a07733751260", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -86,9 +86,13 @@ mod graphviz;\n mod tests;\n \n pub trait ForestObligation: Clone + Debug {\n-    type Predicate: Clone + hash::Hash + Eq + Debug;\n+    type CacheKey: Clone + hash::Hash + Eq + Debug;\n \n-    fn as_predicate(&self) -> &Self::Predicate;\n+    /// Converts this `ForestObligation` suitable for use as a cache key.\n+    /// If two distinct `ForestObligations`s return the same cache key,\n+    /// then it must be sound to use the result of processing one obligation\n+    /// (e.g. success for error) for the other obligation\n+    fn as_cache_key(&self) -> Self::CacheKey;\n }\n \n pub trait ObligationProcessor {\n@@ -138,12 +142,12 @@ pub struct ObligationForest<O: ForestObligation> {\n     nodes: Vec<Node<O>>,\n \n     /// A cache of predicates that have been successfully completed.\n-    done_cache: FxHashSet<O::Predicate>,\n+    done_cache: FxHashSet<O::CacheKey>,\n \n     /// A cache of the nodes in `nodes`, indexed by predicate. Unfortunately,\n     /// its contents are not guaranteed to match those of `nodes`. See the\n     /// comments in `process_obligation` for details.\n-    active_cache: FxHashMap<O::Predicate, usize>,\n+    active_cache: FxHashMap<O::CacheKey, usize>,\n \n     /// A vector reused in compress(), to avoid allocating new vectors.\n     node_rewrites: Vec<usize>,\n@@ -157,7 +161,7 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// See [this][details] for details.\n     ///\n     /// [details]: https://github.com/rust-lang/rust/pull/53255#issuecomment-421184780\n-    error_cache: FxHashMap<ObligationTreeId, FxHashSet<O::Predicate>>,\n+    error_cache: FxHashMap<ObligationTreeId, FxHashSet<O::CacheKey>>,\n }\n \n #[derive(Debug)]\n@@ -305,11 +309,12 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     // Returns Err(()) if we already know this obligation failed.\n     fn register_obligation_at(&mut self, obligation: O, parent: Option<usize>) -> Result<(), ()> {\n-        if self.done_cache.contains(obligation.as_predicate()) {\n+        if self.done_cache.contains(&obligation.as_cache_key()) {\n+            debug!(\"register_obligation_at: ignoring already done obligation: {:?}\", obligation);\n             return Ok(());\n         }\n \n-        match self.active_cache.entry(obligation.as_predicate().clone()) {\n+        match self.active_cache.entry(obligation.as_cache_key().clone()) {\n             Entry::Occupied(o) => {\n                 let node = &mut self.nodes[*o.get()];\n                 if let Some(parent_index) = parent {\n@@ -333,7 +338,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     && self\n                         .error_cache\n                         .get(&obligation_tree_id)\n-                        .map(|errors| errors.contains(obligation.as_predicate()))\n+                        .map(|errors| errors.contains(&obligation.as_cache_key()))\n                         .unwrap_or(false);\n \n                 if already_failed {\n@@ -380,7 +385,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.error_cache\n             .entry(node.obligation_tree_id)\n             .or_default()\n-            .insert(node.obligation.as_predicate().clone());\n+            .insert(node.obligation.as_cache_key().clone());\n     }\n \n     /// Performs a pass through the obligation list. This must\n@@ -618,11 +623,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     // `self.nodes`. See the comment in `process_obligation`\n                     // for more details.\n                     if let Some((predicate, _)) =\n-                        self.active_cache.remove_entry(node.obligation.as_predicate())\n+                        self.active_cache.remove_entry(&node.obligation.as_cache_key())\n                     {\n                         self.done_cache.insert(predicate);\n                     } else {\n-                        self.done_cache.insert(node.obligation.as_predicate().clone());\n+                        self.done_cache.insert(node.obligation.as_cache_key().clone());\n                     }\n                     if do_completed == DoCompleted::Yes {\n                         // Extract the success stories.\n@@ -635,7 +640,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     // We *intentionally* remove the node from the cache at this point. Otherwise\n                     // tests must come up with a different type on every type error they\n                     // check against.\n-                    self.active_cache.remove(node.obligation.as_predicate());\n+                    self.active_cache.remove(&node.obligation.as_cache_key());\n                     self.insert_into_error_cache(index);\n                     node_rewrites[index] = orig_nodes_len;\n                     dead_nodes += 1;"}, {"sha": "01652465eea2cc7a554134354ab6b29b0fdd7d82", "filename": "src/librustc_data_structures/obligation_forest/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -4,9 +4,9 @@ use std::fmt;\n use std::marker::PhantomData;\n \n impl<'a> super::ForestObligation for &'a str {\n-    type Predicate = &'a str;\n+    type CacheKey = &'a str;\n \n-    fn as_predicate(&self) -> &Self::Predicate {\n+    fn as_cache_key(&self) -> Self::CacheKey {\n         self\n     }\n }"}, {"sha": "f6abcce4d3facb79592b6e258032d1be208af178", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -191,9 +191,9 @@ fn generic_extension<'cx>(\n     let mut best_failure: Option<(Token, &str)> = None;\n \n     // We create a base parser that can be used for the \"black box\" parts.\n-    // Every iteration needs a fresh copy of that base parser. However, the\n-    // parser is not mutated on many of the iterations, particularly when\n-    // dealing with macros like this:\n+    // Every iteration needs a fresh copy of that parser. However, the parser\n+    // is not mutated on many of the iterations, particularly when dealing with\n+    // macros like this:\n     //\n     // macro_rules! foo {\n     //     (\"a\") => (A);\n@@ -209,11 +209,9 @@ fn generic_extension<'cx>(\n     // hacky, but speeds up the `html5ever` benchmark significantly. (Issue\n     // 68836 suggests a more comprehensive but more complex change to deal with\n     // this situation.)\n-    let base_parser = base_parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n+    let parser = parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n \n     for (i, lhs) in lhses.iter().enumerate() {\n-        let mut parser = Cow::Borrowed(&base_parser);\n-\n         // try each arm's matchers\n         let lhs_tt = match *lhs {\n             mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n@@ -224,13 +222,14 @@ fn generic_extension<'cx>(\n         // This is used so that if a matcher is not `Success(..)`ful,\n         // then the spans which became gated when parsing the unsuccessful matcher\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n-        let mut gated_spans_snaphot = mem::take(&mut *cx.parse_sess.gated_spans.spans.borrow_mut());\n+        let mut gated_spans_snapshot =\n+            mem::take(&mut *cx.parse_sess.gated_spans.spans.borrow_mut());\n \n-        match parse_tt(&mut parser, lhs_tt) {\n+        match parse_tt(&mut Cow::Borrowed(&parser), lhs_tt) {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n-                cx.parse_sess.gated_spans.merge(gated_spans_snaphot);\n+                cx.parse_sess.gated_spans.merge(gated_spans_snapshot);\n \n                 let rhs = match rhses[i] {\n                     // ignore delimiters\n@@ -291,9 +290,9 @@ fn generic_extension<'cx>(\n \n         // The matcher was not `Success(..)`ful.\n         // Restore to the state before snapshotting and maybe try again.\n-        mem::swap(&mut gated_spans_snaphot, &mut cx.parse_sess.gated_spans.spans.borrow_mut());\n+        mem::swap(&mut gated_spans_snapshot, &mut cx.parse_sess.gated_spans.spans.borrow_mut());\n     }\n-    drop(base_parser);\n+    drop(parser);\n \n     let (token, label) = best_failure.expect(\"ran no matchers\");\n     let span = token.span.substitute_dummy(sp);\n@@ -311,9 +310,8 @@ fn generic_extension<'cx>(\n                 mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n                 _ => continue,\n             };\n-            let base_parser =\n-                base_parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n-            match parse_tt(&mut Cow::Borrowed(&base_parser), lhs_tt) {\n+            let parser = parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n+            match parse_tt(&mut Cow::Borrowed(&parser), lhs_tt) {\n                 Success(_) => {\n                     if comma_span.is_dummy() {\n                         err.note(\"you might be missing a comma\");\n@@ -395,8 +393,8 @@ pub fn compile_declarative_macro(\n         ),\n     ];\n \n-    let base_parser = Parser::new(sess, body, None, true, true, rustc_parse::MACRO_ARGUMENTS);\n-    let argument_map = match parse_tt(&mut Cow::Borrowed(&base_parser), &argument_gram) {\n+    let parser = Parser::new(sess, body, None, true, true, rustc_parse::MACRO_ARGUMENTS);\n+    let argument_map = match parse_tt(&mut Cow::Borrowed(&parser), &argument_gram) {\n         Success(m) => m,\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);\n@@ -1212,7 +1210,7 @@ fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     }\n }\n \n-fn base_parser_from_cx<'cx>(\n+fn parser_from_cx<'cx>(\n     current_expansion: &'cx ExpansionData,\n     sess: &'cx ParseSess,\n     tts: TokenStream,"}, {"sha": "3f28f033047a2c73c1fba285ce378e1b3fb29d58", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -52,6 +52,8 @@ impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n                 Some(x) => x,\n             };\n             if local_tmp_s0 != local_tmp_s1\n+                // Avoid moving into ourselves.\n+                || local_0 == local_1\n                 // The field-and-variant information match up.\n                 || vf_s0 != vf_s1\n                 // Source and target locals have the same type.\n@@ -64,6 +66,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {\n             }\n \n             // Right shape; transform!\n+            s0.source_info = s2.source_info;\n             match &mut s0.kind {\n                 StatementKind::Assign(box (place, rvalue)) => {\n                     *place = local_0.into();"}, {"sha": "0c1557a59c2bc11553d7e015f05c70c9c753e189", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let ty =\n             if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() && is_builtin_binop(lhs_ty, rhs_ty, op) {\n-                self.enforce_builtin_binop_types(lhs, lhs_ty, rhs, rhs_ty, op);\n+                self.enforce_builtin_binop_types(&lhs.span, lhs_ty, &rhs.span, rhs_ty, op);\n                 self.tcx.mk_unit()\n             } else {\n                 return_ty\n@@ -86,8 +86,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     && !rhs_ty.is_ty_var()\n                     && is_builtin_binop(lhs_ty, rhs_ty, op)\n                 {\n-                    let builtin_return_ty =\n-                        self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n+                    let builtin_return_ty = self.enforce_builtin_binop_types(\n+                        &lhs_expr.span,\n+                        lhs_ty,\n+                        &rhs_expr.span,\n+                        rhs_ty,\n+                        op,\n+                    );\n                     self.demand_suptype(expr.span, builtin_return_ty, return_ty);\n                 }\n \n@@ -98,19 +103,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn enforce_builtin_binop_types(\n         &self,\n-        lhs_expr: &'tcx hir::Expr<'tcx>,\n+        lhs_span: &Span,\n         lhs_ty: Ty<'tcx>,\n-        rhs_expr: &'tcx hir::Expr<'tcx>,\n+        rhs_span: &Span,\n         rhs_ty: Ty<'tcx>,\n         op: hir::BinOp,\n     ) -> Ty<'tcx> {\n         debug_assert!(is_builtin_binop(lhs_ty, rhs_ty, op));\n \n+        // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work.\n+        // (See https://github.com/rust-lang/rust/issues/57447.)\n+        let (lhs_ty, rhs_ty) = (deref_ty_if_possible(lhs_ty), deref_ty_if_possible(rhs_ty));\n+\n         let tcx = self.tcx;\n         match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n-                self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n-                self.demand_suptype(rhs_expr.span, tcx.mk_bool(), rhs_ty);\n+                self.demand_suptype(*lhs_span, tcx.mk_bool(), lhs_ty);\n+                self.demand_suptype(*rhs_span, tcx.mk_bool(), rhs_ty);\n                 tcx.mk_bool()\n             }\n \n@@ -121,13 +130,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             BinOpCategory::Math | BinOpCategory::Bitwise => {\n                 // both LHS and RHS and result will have the same type\n-                self.demand_suptype(rhs_expr.span, lhs_ty, rhs_ty);\n+                self.demand_suptype(*rhs_span, lhs_ty, rhs_ty);\n                 lhs_ty\n             }\n \n             BinOpCategory::Comparison => {\n                 // both LHS and RHS and result will have the same type\n-                self.demand_suptype(rhs_expr.span, lhs_ty, rhs_ty);\n+                self.demand_suptype(*rhs_span, lhs_ty, rhs_ty);\n                 tcx.mk_bool()\n             }\n         }\n@@ -862,6 +871,14 @@ enum Op {\n     Unary(hir::UnOp, Span),\n }\n \n+/// Dereferences a single level of immutable referencing.\n+fn deref_ty_if_possible<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n+    match ty.kind {\n+        ty::Ref(_, ty, hir::Mutability::Not) => ty,\n+        _ => ty,\n+    }\n+}\n+\n /// Returns `true` if this is a built-in arithmetic operation (e.g., u32\n /// + u32, i16x4 == i16x4) and false if these types would have to be\n /// overloaded to be legal. There are two reasons that we distinguish\n@@ -878,7 +895,11 @@ enum Op {\n /// Reason #2 is the killer. I tried for a while to always use\n /// overloaded logic and just check the types in constants/codegen after\n /// the fact, and it worked fine, except for SIMD types. -nmatsakis\n-fn is_builtin_binop(lhs: Ty<'_>, rhs: Ty<'_>, op: hir::BinOp) -> bool {\n+fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>, rhs: Ty<'tcx>, op: hir::BinOp) -> bool {\n+    // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work.\n+    // (See https://github.com/rust-lang/rust/issues/57447.)\n+    let (lhs, rhs) = (deref_ty_if_possible(lhs), deref_ty_if_possible(rhs));\n+\n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => true,\n "}, {"sha": "72a2d56af153f19357d1c20839ff0acff41e0c2c", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 64, "deletions": 49, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -89,6 +89,18 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     }\n }\n \n+const INITIAL_BM: BindingMode = BindingMode::BindByValue(hir::Mutability::Not);\n+\n+/// Mode for adjusting the expected type and binding mode.\n+enum AdjustMode {\n+    /// Peel off all immediate reference types.\n+    Peel,\n+    /// Reset binding mode to the inital mode.\n+    Reset,\n+    /// Pass on the input binding mode and expected type.\n+    Pass,\n+}\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Type check the given top level pattern against the `expected` type.\n     ///\n@@ -105,8 +117,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Option<Span>,\n         origin_expr: bool,\n     ) {\n-        let def_bm = BindingMode::BindByValue(hir::Mutability::Not);\n-        self.check_pat(pat, expected, def_bm, TopInfo { expected, origin_expr, span });\n+        self.check_pat(pat, expected, INITIAL_BM, TopInfo { expected, origin_expr, span });\n     }\n \n     /// Type check the given `pat` against the `expected` type\n@@ -123,12 +134,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"check_pat(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n \n-        let path_resolution = match &pat.kind {\n+        let path_res = match &pat.kind {\n             PatKind::Path(qpath) => Some(self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span)),\n             _ => None,\n         };\n-        let is_nrp = self.is_non_ref_pat(pat, path_resolution.map(|(res, ..)| res));\n-        let (expected, def_bm) = self.calc_default_binding_mode(pat, expected, def_bm, is_nrp);\n+        let adjust_mode = self.calc_adjust_mode(pat, path_res.map(|(res, ..)| res));\n+        let (expected, def_bm) = self.calc_default_binding_mode(pat, expected, def_bm, adjust_mode);\n \n         let ty = match pat.kind {\n             PatKind::Wild => expected,\n@@ -141,7 +152,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_pat_tuple_struct(pat, qpath, subpats, ddpos, expected, def_bm, ti)\n             }\n             PatKind::Path(ref qpath) => {\n-                self.check_pat_path(pat, path_resolution.unwrap(), qpath, expected)\n+                self.check_pat_path(pat, path_res.unwrap(), qpath, expected)\n             }\n             PatKind::Struct(ref qpath, fields, etc) => {\n                 self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, ti)\n@@ -223,64 +234,68 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        is_non_ref_pat: bool,\n+        adjust_mode: AdjustMode,\n     ) -> (Ty<'tcx>, BindingMode) {\n-        if is_non_ref_pat {\n-            debug!(\"pattern is non reference pattern\");\n-            self.peel_off_references(pat, expected, def_bm)\n-        } else {\n-            // When you encounter a `&pat` pattern, reset to \"by\n-            // value\". This is so that `x` and `y` here are by value,\n-            // as they appear to be:\n-            //\n-            // ```\n-            // match &(&22, &44) {\n-            //   (&x, &y) => ...\n-            // }\n-            // ```\n-            //\n-            // See issue #46688.\n-            let def_bm = match pat.kind {\n-                PatKind::Ref(..) => ty::BindByValue(hir::Mutability::Not),\n-                _ => def_bm,\n-            };\n-            (expected, def_bm)\n+        match adjust_mode {\n+            AdjustMode::Pass => (expected, def_bm),\n+            AdjustMode::Reset => (expected, INITIAL_BM),\n+            AdjustMode::Peel => self.peel_off_references(pat, expected, def_bm),\n         }\n     }\n \n-    /// Is the pattern a \"non reference pattern\"?\n+    /// How should the binding mode and expected type be adjusted?\n+    ///\n     /// When the pattern is a path pattern, `opt_path_res` must be `Some(res)`.\n-    fn is_non_ref_pat(&self, pat: &'tcx Pat<'tcx>, opt_path_res: Option<Res>) -> bool {\n-        match pat.kind {\n+    fn calc_adjust_mode(&self, pat: &'tcx Pat<'tcx>, opt_path_res: Option<Res>) -> AdjustMode {\n+        match &pat.kind {\n+            // Type checking these product-like types successfully always require\n+            // that the expected type be of those types and not reference types.\n             PatKind::Struct(..)\n             | PatKind::TupleStruct(..)\n             | PatKind::Tuple(..)\n             | PatKind::Box(_)\n             | PatKind::Range(..)\n-            | PatKind::Slice(..) => true,\n-            PatKind::Lit(ref lt) => {\n-                let ty = self.check_expr(lt);\n-                match ty.kind {\n-                    ty::Ref(..) => false,\n-                    _ => true,\n-                }\n-            }\n+            | PatKind::Slice(..) => AdjustMode::Peel,\n+            // String and byte-string literals result in types `&str` and `&[u8]` respectively.\n+            // All other literals result in non-reference types.\n+            // As a result, we allow `if let 0 = &&0 {}` but not `if let \"foo\" = &&\"foo {}`.\n+            PatKind::Lit(lt) => match self.check_expr(lt).kind {\n+                ty::Ref(..) => AdjustMode::Pass,\n+                _ => AdjustMode::Peel,\n+            },\n             PatKind::Path(_) => match opt_path_res.unwrap() {\n-                Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => false,\n-                _ => true,\n+                // These constants can be of a reference type, e.g. `const X: &u8 = &0;`.\n+                // Peeling the reference types too early will cause type checking failures.\n+                // Although it would be possible to *also* peel the types of the constants too.\n+                Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => AdjustMode::Pass,\n+                // In the `ValueNS`, we have `SelfCtor(..) | Ctor(_, Const), _)` remaining which\n+                // could successfully compile. The former being `Self` requires a unit struct.\n+                // In either case, and unlike constants, the pattern itself cannot be\n+                // a reference type wherefore peeling doesn't give up any expressivity.\n+                _ => AdjustMode::Peel,\n             },\n-            // FIXME(or_patterns; Centril | dlrobertson): To keep things compiling\n-            // for or-patterns at the top level, we need to make `p_0 | ... | p_n`\n-            // a \"non reference pattern\". For example the following currently compiles:\n+            // When encountering a `& mut? pat` pattern, reset to \"by value\".\n+            // This is so that `x` and `y` here are by value, as they appear to be:\n+            //\n             // ```\n-            // match &1 {\n-            //     e @ &(1...2) | e @ &(3...4) => {}\n-            //     _ => {}\n+            // match &(&22, &44) {\n+            //   (&x, &y) => ...\n             // }\n             // ```\n             //\n-            // We should consider whether we should do something special in nested or-patterns.\n-            PatKind::Or(_) | PatKind::Wild | PatKind::Binding(..) | PatKind::Ref(..) => false,\n+            // See issue #46688.\n+            PatKind::Ref(..) => AdjustMode::Reset,\n+            // A `_` pattern works with any expected type, so there's no need to do anything.\n+            PatKind::Wild\n+            // Bindings also work with whatever the expected type is,\n+            // and moreover if we peel references off, that will give us the wrong binding type.\n+            // Also, we can have a subpattern `binding @ pat`.\n+            // Each side of the `@` should be treated independently (like with OR-patterns).\n+            | PatKind::Binding(..)\n+            // An OR-pattern just propagates to each individual alternative.\n+            // This is maximally flexible, allowing e.g., `Some(mut x) | &Some(mut x)`.\n+            // In that example, `Some(mut x)` results in `Peel` whereas `&Some(mut x)` in `Reset`.\n+            | PatKind::Or(_) => AdjustMode::Pass,\n         }\n     }\n \n@@ -508,7 +523,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let local_ty = self.local_ty(pat.span, pat.hir_id).decl_ty;\n         let eq_ty = match bm {\n             ty::BindByReference(mutbl) => {\n-                // If the binding is like `ref x | ref const x | ref mut x`\n+                // If the binding is like `ref x | ref mut x`,\n                 // then `x` is assigned a value of type `&M T` where M is the\n                 // mutability and T is the expected type.\n                 //"}, {"sha": "4af13e4cd587aee30ef424b670b3f209f16045ec", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -9,7 +9,7 @@ name = \"rustdoc\"\n path = \"lib.rs\"\n \n [dependencies]\n-pulldown-cmark = { version = \"0.5.3\", default-features = false }\n+pulldown-cmark = { version = \"0.7\", default-features = false }\n minifier = \"0.0.33\"\n rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n serde = { version = \"1.0\", features = [\"derive\"] }"}, {"sha": "07c092a511c04611181071497b20170384e6bbe0", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 95, "deletions": 75, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -33,7 +33,7 @@ use crate::html::highlight;\n use crate::html::toc::TocBuilder;\n use crate::test;\n \n-use pulldown_cmark::{html, CowStr, Event, Options, Parser, Tag};\n+use pulldown_cmark::{html, CodeBlockKind, CowStr, Event, Options, Parser, Tag};\n \n #[cfg(test)]\n mod tests;\n@@ -189,10 +189,15 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n         let compile_fail;\n         let ignore;\n         let edition;\n-        if let Some(Event::Start(Tag::CodeBlock(lang))) = event {\n-            let parse_result = LangString::parse(&lang, self.check_error_codes, false);\n+        if let Some(Event::Start(Tag::CodeBlock(kind))) = event {\n+            let parse_result = match kind {\n+                CodeBlockKind::Fenced(ref lang) => {\n+                    LangString::parse(&lang, self.check_error_codes, false)\n+                }\n+                CodeBlockKind::Indented => LangString::all_false(),\n+            };\n             if !parse_result.rust {\n-                return Some(Event::Start(Tag::CodeBlock(lang)));\n+                return Some(Event::Start(Tag::CodeBlock(kind)));\n             }\n             compile_fail = parse_result.compile_fail;\n             ignore = parse_result.ignore;\n@@ -370,11 +375,11 @@ impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a,\n         }\n \n         let event = self.inner.next();\n-        if let Some(Event::Start(Tag::Header(level))) = event {\n+        if let Some(Event::Start(Tag::Heading(level))) = event {\n             let mut id = String::new();\n             for event in &mut self.inner {\n                 match &event {\n-                    Event::End(Tag::Header(..)) => break,\n+                    Event::End(Tag::Heading(..)) => break,\n                     Event::Text(text) | Event::Code(text) => {\n                         id.extend(text.chars().filter_map(slugify));\n                     }\n@@ -391,18 +396,18 @@ impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a,\n                 let mut html_header = String::new();\n                 html::push_html(&mut html_header, self.buf.iter().cloned());\n                 let sec = builder.push(level as u32, html_header, id.clone());\n-                self.buf.push_front(Event::InlineHtml(format!(\"{} \", sec).into()));\n+                self.buf.push_front(Event::Html(format!(\"{} \", sec).into()));\n             }\n \n-            self.buf.push_back(Event::InlineHtml(format!(\"</a></h{}>\", level).into()));\n+            self.buf.push_back(Event::Html(format!(\"</a></h{}>\", level).into()));\n \n             let start_tags = format!(\n                 \"<h{level} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n                     <a href=\\\"#{id}\\\">\",\n                 id = id,\n                 level = level\n             );\n-            return Some(Event::InlineHtml(start_tags.into()));\n+            return Some(Event::Html(start_tags.into()));\n         }\n         event\n     }\n@@ -556,40 +561,44 @@ pub fn find_testable_code<T: test::Tester>(\n     error_codes: ErrorCodes,\n     enable_per_target_ignores: bool,\n ) {\n-    let mut parser = Parser::new(doc);\n+    let mut parser = Parser::new(doc).into_offset_iter();\n     let mut prev_offset = 0;\n     let mut nb_lines = 0;\n     let mut register_header = None;\n-    while let Some(event) = parser.next() {\n+    while let Some((event, offset)) = parser.next() {\n         match event {\n-            Event::Start(Tag::CodeBlock(s)) => {\n-                let offset = parser.get_offset();\n-\n-                let block_info = if s.is_empty() {\n-                    LangString::all_false()\n-                } else {\n-                    LangString::parse(&*s, error_codes, enable_per_target_ignores)\n+            Event::Start(Tag::CodeBlock(kind)) => {\n+                let block_info = match kind {\n+                    CodeBlockKind::Fenced(ref lang) => {\n+                        if lang.is_empty() {\n+                            LangString::all_false()\n+                        } else {\n+                            LangString::parse(lang, error_codes, enable_per_target_ignores)\n+                        }\n+                    }\n+                    CodeBlockKind::Indented => LangString::all_false(),\n                 };\n                 if !block_info.rust {\n                     continue;\n                 }\n+\n                 let mut test_s = String::new();\n \n-                while let Some(Event::Text(s)) = parser.next() {\n+                while let Some((Event::Text(s), _)) = parser.next() {\n                     test_s.push_str(&s);\n                 }\n-\n                 let text = test_s\n                     .lines()\n                     .map(|l| map_line(l).for_code())\n                     .collect::<Vec<Cow<'_, str>>>()\n                     .join(\"\\n\");\n-                nb_lines += doc[prev_offset..offset].lines().count();\n-                let line = tests.get_line() + nb_lines;\n+\n+                nb_lines += doc[prev_offset..offset.start].lines().count();\n+                let line = tests.get_line() + nb_lines + 1;\n                 tests.add_test(text, block_info, line);\n-                prev_offset = offset;\n+                prev_offset = offset.start;\n             }\n-            Event::Start(Tag::Header(level)) => {\n+            Event::Start(Tag::Heading(level)) => {\n                 register_header = Some(level as u32);\n             }\n             Event::Text(ref s) if register_header.is_some() => {\n@@ -783,7 +792,7 @@ impl MarkdownHtml<'_> {\n \n         // Treat inline HTML as plain text.\n         let p = p.map(|event| match event {\n-            Event::Html(text) | Event::InlineHtml(text) => Event::Text(text),\n+            Event::Html(text) => Event::Text(text),\n             _ => event,\n         });\n \n@@ -842,10 +851,10 @@ pub fn plain_summary_line(md: &str) -> String {\n             let next_event = next_event.unwrap();\n             let (ret, is_in) = match next_event {\n                 Event::Start(Tag::Paragraph) => (None, 1),\n-                Event::Start(Tag::Header(_)) => (None, 1),\n+                Event::Start(Tag::Heading(_)) => (None, 1),\n                 Event::Code(code) => (Some(format!(\"`{}`\", code)), 0),\n                 Event::Text(ref s) if self.is_in > 0 => (Some(s.as_ref().to_owned()), 0),\n-                Event::End(Tag::Paragraph) | Event::End(Tag::Header(_)) => (None, -1),\n+                Event::End(Tag::Paragraph) | Event::End(Tag::Heading(_)) => (None, -1),\n                 _ => (None, 0),\n             };\n             if is_in > 0 || (is_in < 0 && self.is_in > 0) {\n@@ -940,68 +949,79 @@ crate fn rust_code_blocks(md: &str) -> Vec<RustCodeBlock> {\n         return code_blocks;\n     }\n \n-    let mut p = Parser::new_ext(md, opts());\n-\n-    let mut code_block_start = 0;\n-    let mut code_start = 0;\n-    let mut is_fenced = false;\n-    let mut previous_offset = 0;\n-    let mut in_rust_code_block = false;\n-    while let Some(event) = p.next() {\n-        let offset = p.get_offset();\n+    let mut p = Parser::new_ext(md, opts()).into_offset_iter();\n \n+    while let Some((event, offset)) = p.next() {\n         match event {\n             Event::Start(Tag::CodeBlock(syntax)) => {\n-                let lang_string = if syntax.is_empty() {\n-                    LangString::all_false()\n-                } else {\n-                    LangString::parse(&*syntax, ErrorCodes::Yes, false)\n-                };\n-\n-                if lang_string.rust {\n-                    in_rust_code_block = true;\n-\n-                    code_start = offset;\n-                    code_block_start = match md[previous_offset..offset].find(\"```\") {\n-                        Some(fence_idx) => {\n-                            is_fenced = true;\n-                            previous_offset + fence_idx\n+                let (syntax, code_start, code_end, range, is_fenced) = match syntax {\n+                    CodeBlockKind::Fenced(syntax) => {\n+                        let syntax = syntax.as_ref();\n+                        let lang_string = if syntax.is_empty() {\n+                            LangString::all_false()\n+                        } else {\n+                            LangString::parse(&*syntax, ErrorCodes::Yes, false)\n+                        };\n+                        if !lang_string.rust {\n+                            continue;\n                         }\n-                        None => {\n-                            is_fenced = false;\n-                            offset\n+                        let syntax = if syntax.is_empty() { None } else { Some(syntax.to_owned()) };\n+                        let (code_start, mut code_end) = match p.next() {\n+                            Some((Event::Text(_), offset)) => (offset.start, offset.end),\n+                            Some((_, sub_offset)) => {\n+                                let code = Range { start: sub_offset.start, end: sub_offset.start };\n+                                code_blocks.push(RustCodeBlock {\n+                                    is_fenced: true,\n+                                    range: offset,\n+                                    code,\n+                                    syntax,\n+                                });\n+                                continue;\n+                            }\n+                            None => {\n+                                let code = Range { start: offset.end, end: offset.end };\n+                                code_blocks.push(RustCodeBlock {\n+                                    is_fenced: true,\n+                                    range: offset,\n+                                    code,\n+                                    syntax,\n+                                });\n+                                continue;\n+                            }\n+                        };\n+                        while let Some((Event::Text(_), offset)) = p.next() {\n+                            code_end = offset.end;\n                         }\n-                    };\n-                }\n-            }\n-            Event::End(Tag::CodeBlock(syntax)) if in_rust_code_block => {\n-                in_rust_code_block = false;\n-\n-                let code_block_end = if is_fenced {\n-                    let fence_str = &md[previous_offset..offset].chars().rev().collect::<String>();\n-                    fence_str\n-                        .find(\"```\")\n-                        .map(|fence_idx| offset - fence_idx)\n-                        .unwrap_or_else(|| offset)\n-                } else if md.as_bytes().get(offset).map(|b| *b == b'\\n').unwrap_or_default() {\n-                    offset - 1\n-                } else {\n-                    offset\n+                        (syntax, code_start, code_end, offset, true)\n+                    }\n+                    CodeBlockKind::Indented => {\n+                        // The ending of the offset goes too far sometime so we reduce it by one in\n+                        // these cases.\n+                        if offset.end > offset.start\n+                            && md.get(offset.end..=offset.end) == Some(&\"\\n\")\n+                        {\n+                            (\n+                                None,\n+                                offset.start,\n+                                offset.end,\n+                                Range { start: offset.start, end: offset.end - 1 },\n+                                false,\n+                            )\n+                        } else {\n+                            (None, offset.start, offset.end, offset, false)\n+                        }\n+                    }\n                 };\n \n-                let code_end = if is_fenced { previous_offset } else { code_block_end };\n-\n                 code_blocks.push(RustCodeBlock {\n                     is_fenced,\n-                    range: Range { start: code_block_start, end: code_block_end },\n+                    range,\n                     code: Range { start: code_start, end: code_end },\n-                    syntax: if !syntax.is_empty() { Some(syntax.into_string()) } else { None },\n+                    syntax,\n                 });\n             }\n             _ => (),\n         }\n-\n-        previous_offset = offset;\n     }\n \n     code_blocks"}, {"sha": "061b0d675b31f2c98c0e1864de6edaf6c54ddb11", "filename": "src/test/ui/array-slice-vec/issue-69103-extra-binding-subslice.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Ftest%2Fui%2Farray-slice-vec%2Fissue-69103-extra-binding-subslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Ftest%2Fui%2Farray-slice-vec%2Fissue-69103-extra-binding-subslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fissue-69103-extra-binding-subslice.rs?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -0,0 +1,18 @@\n+// We used to not lower the extra `b @ ..` into `b @ _` which meant that no type\n+// was registered for the binding `b` although it passed through resolve.\n+// This resulted in an ICE (#69103).\n+\n+fn main() {\n+    let [a @ .., b @ ..] = &mut [1, 2];\n+    //~^ ERROR `..` can only be used once per slice pattern\n+    b;\n+\n+    let [.., c @ ..] = [1, 2];\n+    //~^ ERROR `..` can only be used once per slice pattern\n+    c;\n+\n+    // This never ICEd, but let's make sure it won't regress either.\n+    let (.., d @ ..) = (1, 2);\n+    //~^ ERROR `..` patterns are not allowed here\n+    d;\n+}"}, {"sha": "9432e2f0c9d34fbf200fdbdd4815e01484d8e369", "filename": "src/test/ui/array-slice-vec/issue-69103-extra-binding-subslice.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Ftest%2Fui%2Farray-slice-vec%2Fissue-69103-extra-binding-subslice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Ftest%2Fui%2Farray-slice-vec%2Fissue-69103-extra-binding-subslice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fissue-69103-extra-binding-subslice.stderr?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -0,0 +1,26 @@\n+error: `..` can only be used once per slice pattern\n+  --> $DIR/issue-69103-extra-binding-subslice.rs:6:22\n+   |\n+LL |     let [a @ .., b @ ..] = &mut [1, 2];\n+   |              --      ^^ can only be used once per slice pattern\n+   |              |\n+   |              previously used here\n+\n+error: `..` can only be used once per slice pattern\n+  --> $DIR/issue-69103-extra-binding-subslice.rs:10:18\n+   |\n+LL |     let [.., c @ ..] = [1, 2];\n+   |          --      ^^ can only be used once per slice pattern\n+   |          |\n+   |          previously used here\n+\n+error: `..` patterns are not allowed here\n+  --> $DIR/issue-69103-extra-binding-subslice.rs:15:18\n+   |\n+LL |     let (.., d @ ..) = (1, 2);\n+   |                  ^^\n+   |\n+   = note: only allowed in tuple, tuple struct, and slice patterns\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "0c0a3171ee9a18ae1c4d436f21c1442157a42aa3", "filename": "src/test/ui/inference/infer-binary-operand-behind-reference.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Ftest%2Fui%2Finference%2Finfer-binary-operand-behind-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Ftest%2Fui%2Finference%2Finfer-binary-operand-behind-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Finfer-binary-operand-behind-reference.rs?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -0,0 +1,30 @@\n+// check-pass\n+\n+fn main() {\n+    // Test that we can infer the type of binary operands when\n+    // references are involved, on various types and operators.\n+    let _: u8 = 0 + 0;\n+    let _: u8 = 0 + &0;\n+    let _: u8 = &0 + 0;\n+    let _: u8 = &0 + &0;\n+\n+    let _: f32 = 0.0 + 0.0;\n+    let _: f32 = 0.0 + &0.0;\n+    let _: f32 = &0.0 + 0.0;\n+    let _: f32 = &0.0 + &0.0;\n+\n+    let _: u8 = 0 << 0;\n+    let _: u8 = 0 << &0;\n+    let _: u8 = &0 << 0;\n+    let _: u8 = &0 << &0;\n+\n+    // Test type inference when variable types are indirectly inferred.\n+    let a = 22;\n+    let _: usize = a + &44;\n+\n+    // When we have no expected type, the types of the operands is the default type.\n+    let _ = 0 + 0;\n+    let _ = 0 + &0;\n+    let _ = &0 + 0;\n+    let _ = &0 + &0;\n+}"}, {"sha": "973954bca5a5e823877180da26ca2ddf6a82cc87", "filename": "src/test/ui/or-patterns/or-pattern-mismatch.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/433aae93e4ef866a1fdfefad136b32ed89acd3e7/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433aae93e4ef866a1fdfefad136b32ed89acd3e7/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.rs?ref=433aae93e4ef866a1fdfefad136b32ed89acd3e7", "patch": "@@ -1,4 +0,0 @@\n-enum Blah { A(isize, isize, usize), B(isize, isize) }\n-\n-fn main() { match Blah::A(1, 1, 2) { Blah::A(_, x, y) | Blah::B(x, y) => { } } }\n-//~^ ERROR mismatched types"}, {"sha": "bc288e06250751d914801818d0240c36253341cb", "filename": "src/test/ui/or-patterns/or-pattern-mismatch.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/433aae93e4ef866a1fdfefad136b32ed89acd3e7/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433aae93e4ef866a1fdfefad136b32ed89acd3e7/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr?ref=433aae93e4ef866a1fdfefad136b32ed89acd3e7", "patch": "@@ -1,9 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/or-pattern-mismatch.rs:3:68\n-   |\n-LL | fn main() { match Blah::A(1, 1, 2) { Blah::A(_, x, y) | Blah::B(x, y) => { } } }\n-   |                   ---------------- this expression has type `Blah` ^ expected `usize`, found `isize`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "5ec7dc6962c18ef3bdf249410856c0802f8a5359", "filename": "src/test/ui/or-patterns/or-patterns-binding-type-mismatch.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.rs?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -0,0 +1,68 @@\n+// Here we test type checking of bindings when combined with or-patterns.\n+// Specifically, we ensure that introducing bindings of different types result in type errors.\n+\n+#![feature(or_patterns)]\n+\n+fn main() {\n+    enum Blah {\n+        A(isize, isize, usize),\n+        B(isize, isize),\n+    }\n+\n+    match Blah::A(1, 1, 2) {\n+        Blah::A(_, x, y) | Blah::B(x, y) => {} //~ ERROR mismatched types\n+    }\n+\n+    match Some(Blah::A(1, 1, 2)) {\n+        Some(Blah::A(_, x, y) | Blah::B(x, y)) => {} //~ ERROR mismatched types\n+    }\n+\n+    match (0u8, 1u16) {\n+        (x, y) | (y, x) => {} //~ ERROR mismatched types\n+                              //~^ ERROR mismatched types\n+    }\n+\n+    match Some((0u8, Some((1u16, 2u32)))) {\n+        Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n+        //~^ ERROR mismatched types\n+        //~| ERROR mismatched types\n+        //~| ERROR mismatched types\n+        //~| ERROR mismatched types\n+        _ => {}\n+    }\n+\n+    if let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2) {\n+        //~^ ERROR mismatched types\n+    }\n+\n+    if let Some(Blah::A(_, x, y) | Blah::B(x, y)) = Some(Blah::A(1, 1, 2)) {\n+        //~^ ERROR mismatched types\n+    }\n+\n+    if let (x, y) | (y, x) = (0u8, 1u16) {\n+        //~^ ERROR mismatched types\n+        //~| ERROR mismatched types\n+    }\n+\n+    if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n+        //~^ ERROR mismatched types\n+        //~| ERROR mismatched types\n+        //~| ERROR mismatched types\n+        //~| ERROR mismatched types\n+    = Some((0u8, Some((1u16, 2u32))))\n+    {}\n+\n+    let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2);\n+    //~^ ERROR mismatched types\n+\n+    let (x, y) | (y, x) = (0u8, 1u16);\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+\n+    fn f1((Blah::A(_, x, y) | Blah::B(x, y)): Blah) {}\n+    //~^ ERROR mismatched types\n+\n+    fn f2(((x, y) | (y, x)): (u8, u16)) {}\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+}"}, {"sha": "5094f04b9204f1d7258a9ad4dde3c6e4b76823b0", "filename": "src/test/ui/or-patterns/or-patterns-binding-type-mismatch.stderr", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-binding-type-mismatch.stderr?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -0,0 +1,183 @@\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:13:39\n+   |\n+LL |     match Blah::A(1, 1, 2) {\n+   |           ---------------- this expression has type `main::Blah`\n+LL |         Blah::A(_, x, y) | Blah::B(x, y) => {}\n+   |                                       ^ expected `usize`, found `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:17:44\n+   |\n+LL |     match Some(Blah::A(1, 1, 2)) {\n+   |           ---------------------- this expression has type `std::option::Option<main::Blah>`\n+LL |         Some(Blah::A(_, x, y) | Blah::B(x, y)) => {}\n+   |                                            ^ expected `usize`, found `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:21:19\n+   |\n+LL |     match (0u8, 1u16) {\n+   |           ----------- this expression has type `(u8, u16)`\n+LL |         (x, y) | (y, x) => {}\n+   |                   ^ expected `u16`, found `u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:21:22\n+   |\n+LL |     match (0u8, 1u16) {\n+   |           ----------- this expression has type `(u8, u16)`\n+LL |         (x, y) | (y, x) => {}\n+   |                      ^ expected `u8`, found `u16`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:26:41\n+   |\n+LL |     match Some((0u8, Some((1u16, 2u32)))) {\n+   |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n+   |                                         ^ expected `u16`, found `u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:26:50\n+   |\n+LL |     match Some((0u8, Some((1u16, 2u32)))) {\n+   |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n+   |                                                  ^ expected `u8`, found `u16`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:26:59\n+   |\n+LL |     match Some((0u8, Some((1u16, 2u32)))) {\n+   |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n+   |                                                           ^ expected `u32`, found `u16`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:26:62\n+   |\n+LL |     match Some((0u8, Some((1u16, 2u32)))) {\n+   |           ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+LL |         Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x)))) => {}\n+   |                                                              ^ expected `u8`, found `u32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:34:42\n+   |\n+LL |     if let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2) {\n+   |                                          ^    ---------------- this expression has type `main::Blah`\n+   |                                          |\n+   |                                          expected `usize`, found `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:38:47\n+   |\n+LL |     if let Some(Blah::A(_, x, y) | Blah::B(x, y)) = Some(Blah::A(1, 1, 2)) {\n+   |                                               ^     ---------------------- this expression has type `std::option::Option<main::Blah>`\n+   |                                               |\n+   |                                               expected `usize`, found `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:42:22\n+   |\n+LL |     if let (x, y) | (y, x) = (0u8, 1u16) {\n+   |                      ^       ----------- this expression has type `(u8, u16)`\n+   |                      |\n+   |                      expected `u16`, found `u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:42:25\n+   |\n+LL |     if let (x, y) | (y, x) = (0u8, 1u16) {\n+   |                         ^    ----------- this expression has type `(u8, u16)`\n+   |                         |\n+   |                         expected `u8`, found `u16`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:47:44\n+   |\n+LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n+   |                                            ^ expected `u16`, found `u8`\n+...\n+LL |     = Some((0u8, Some((1u16, 2u32))))\n+   |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:47:53\n+   |\n+LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n+   |                                                     ^ expected `u8`, found `u16`\n+...\n+LL |     = Some((0u8, Some((1u16, 2u32))))\n+   |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:47:62\n+   |\n+LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n+   |                                                              ^ expected `u32`, found `u16`\n+...\n+LL |     = Some((0u8, Some((1u16, 2u32))))\n+   |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:47:65\n+   |\n+LL |     if let Some((x, Some((y, z)))) | Some((y, Some((x, z) | (z, x))))\n+   |                                                                 ^ expected `u8`, found `u32`\n+...\n+LL |     = Some((0u8, Some((1u16, 2u32))))\n+   |       ------------------------------- this expression has type `std::option::Option<(u8, std::option::Option<(u16, u32)>)>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:55:39\n+   |\n+LL |     let Blah::A(_, x, y) | Blah::B(x, y) = Blah::A(1, 1, 2);\n+   |                                       ^    ---------------- this expression has type `main::Blah`\n+   |                                       |\n+   |                                       expected `usize`, found `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:58:19\n+   |\n+LL |     let (x, y) | (y, x) = (0u8, 1u16);\n+   |                   ^       ----------- this expression has type `(u8, u16)`\n+   |                   |\n+   |                   expected `u16`, found `u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:58:22\n+   |\n+LL |     let (x, y) | (y, x) = (0u8, 1u16);\n+   |                      ^    ----------- this expression has type `(u8, u16)`\n+   |                      |\n+   |                      expected `u8`, found `u16`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:62:42\n+   |\n+LL |     fn f1((Blah::A(_, x, y) | Blah::B(x, y)): Blah) {}\n+   |                                          ^    ---- expected due to this\n+   |                                          |\n+   |                                          expected `usize`, found `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:65:22\n+   |\n+LL |     fn f2(((x, y) | (y, x)): (u8, u16)) {}\n+   |                      ^       --------- expected due to this\n+   |                      |\n+   |                      expected `u16`, found `u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/or-patterns-binding-type-mismatch.rs:65:25\n+   |\n+LL |     fn f2(((x, y) | (y, x)): (u8, u16)) {}\n+   |                         ^    --------- expected due to this\n+   |                         |\n+   |                         expected `u8`, found `u16`\n+\n+error: aborting due to 22 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "3b6047c7be47df460e07fa2373996df13da5a597", "filename": "src/test/ui/or-patterns/or-patterns-default-binding-modes.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Ftest%2Fui%2For-patterns%2For-patterns-default-binding-modes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b92c6ee882853313698f1148512e8e992ba36b2d/src%2Ftest%2Fui%2For-patterns%2For-patterns-default-binding-modes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-default-binding-modes.rs?ref=b92c6ee882853313698f1148512e8e992ba36b2d", "patch": "@@ -0,0 +1,132 @@\n+// Test that or-patterns are pass-through with respect to default binding modes.\n+\n+// check-pass\n+\n+#![feature(or_patterns)]\n+#![allow(irrefutable_let_patterns)]\n+\n+fn main() {\n+    // A regression test for a mistake we made at one point:\n+    match &1 {\n+        e @ &(1..=2) | e @ &(3..=4) => {}\n+        _ => {}\n+    }\n+\n+    match &0 {\n+        0 | &1 => {}\n+        _ => {}\n+    }\n+\n+    type R<'a> = &'a Result<u8, u8>;\n+\n+    let res: R<'_> = &Ok(0);\n+\n+    match res {\n+        // Alternatives propagate expected type / binding mode independently.\n+        Ok(mut x) | &Err(mut x) => drop::<u8>(x),\n+    }\n+    match res {\n+        &(Ok(x) | Err(x)) => drop::<u8>(x),\n+    }\n+    match res {\n+        Ok(x) | Err(x) => drop::<&u8>(x),\n+    }\n+    if let Ok(mut x) | &Err(mut x) = res {\n+        drop::<u8>(x);\n+    }\n+    if let &(Ok(x) | Err(x)) = res {\n+        drop::<u8>(x);\n+    }\n+    let Ok(mut x) | &Err(mut x) = res;\n+    drop::<u8>(x);\n+    let &(Ok(x) | Err(x)) = res;\n+    drop::<u8>(x);\n+    let Ok(x) | Err(x) = res;\n+    drop::<&u8>(x);\n+    for Ok(mut x) | &Err(mut x) in std::iter::once(res) {\n+        drop::<u8>(x);\n+    }\n+    for &(Ok(x) | Err(x)) in std::iter::once(res) {\n+        drop::<u8>(x);\n+    }\n+    for Ok(x) | Err(x) in std::iter::once(res) {\n+        drop::<&u8>(x);\n+    }\n+    fn f1((Ok(mut x) | &Err(mut x)): R<'_>) {\n+        drop::<u8>(x);\n+    }\n+    fn f2(&(Ok(x) | Err(x)): R<'_>) {\n+        drop::<u8>(x);\n+    }\n+    fn f3((Ok(x) | Err(x)): R<'_>) {\n+        drop::<&u8>(x);\n+    }\n+\n+    // Wrap inside another type (a product for a simplity with irrefutable contexts).\n+    #[derive(Copy, Clone)]\n+    struct Wrap<T>(T);\n+    let wres = Wrap(res);\n+\n+    match wres {\n+        Wrap(Ok(mut x) | &Err(mut x)) => drop::<u8>(x),\n+    }\n+    match wres {\n+        Wrap(&(Ok(x) | Err(x))) => drop::<u8>(x),\n+    }\n+    match wres {\n+        Wrap(Ok(x) | Err(x)) => drop::<&u8>(x),\n+    }\n+    if let Wrap(Ok(mut x) | &Err(mut x)) = wres {\n+        drop::<u8>(x);\n+    }\n+    if let Wrap(&(Ok(x) | Err(x))) = wres {\n+        drop::<u8>(x);\n+    }\n+    if let Wrap(Ok(x) | Err(x)) = wres {\n+        drop::<&u8>(x);\n+    }\n+    let Wrap(Ok(mut x) | &Err(mut x)) = wres;\n+    drop::<u8>(x);\n+    let Wrap(&(Ok(x) | Err(x))) = wres;\n+    drop::<u8>(x);\n+    let Wrap(Ok(x) | Err(x)) = wres;\n+    drop::<&u8>(x);\n+    for Wrap(Ok(mut x) | &Err(mut x)) in std::iter::once(wres) {\n+        drop::<u8>(x);\n+    }\n+    for Wrap(&(Ok(x) | Err(x))) in std::iter::once(wres) {\n+        drop::<u8>(x);\n+    }\n+    for Wrap(Ok(x) | Err(x)) in std::iter::once(wres) {\n+        drop::<&u8>(x);\n+    }\n+    fn fw1(Wrap(Ok(mut x) | &Err(mut x)): Wrap<R<'_>>) {\n+        drop::<u8>(x);\n+    }\n+    fn fw2(Wrap(&(Ok(x) | Err(x))): Wrap<R<'_>>) {\n+        drop::<u8>(x);\n+    }\n+    fn fw3(Wrap(Ok(x) | Err(x)): Wrap<R<'_>>) {\n+        drop::<&u8>(x);\n+    }\n+\n+    // Nest some more:\n+\n+    enum Tri<P> {\n+        A(P),\n+        B(P),\n+        C(P),\n+    }\n+\n+    let tri = &Tri::A(&Ok(0));\n+    let Tri::A(Ok(mut x) | Err(mut x))\n+    | Tri::B(&Ok(mut x) | Err(mut x))\n+    | &Tri::C(Ok(mut x) | Err(mut x)) = tri;\n+    drop::<u8>(x);\n+\n+    match tri {\n+        Tri::A(Ok(mut x) | Err(mut x))\n+        | Tri::B(&Ok(mut x) | Err(mut x))\n+        | &Tri::C(Ok(mut x) | Err(mut x)) => drop::<u8>(x),\n+    }\n+}"}]}