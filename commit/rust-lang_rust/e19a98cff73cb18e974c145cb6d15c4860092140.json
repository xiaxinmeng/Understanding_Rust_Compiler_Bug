{"sha": "e19a98cff73cb18e974c145cb6d15c4860092140", "node_id": "C_kwDOAAsO6NoAKGUxOWE5OGNmZjczY2IxOGU5NzRjMTQ1Y2I2ZDE1YzQ4NjAwOTIxNDA", "commit": {"author": {"name": "Bradford Hovinen", "email": "hovinen@google.com", "date": "2022-07-28T14:45:43Z"}, "committer": {"name": "Bradford Hovinen", "email": "hovinen@google.com", "date": "2022-09-16T14:36:00Z"}, "message": "Do not panic when a test function returns Result::Err.\n\nRust's test library allows test functions to return a Result, so that the test is deemed to have failed if the function returns a Result::Err variant. Currently, this works by having Result implement the Termination trait and asserting in assert_test_result that Termination::report() indicates successful completion. This turns a Result::Err into a panic, which is caught and unwound in the test library.\n\nThis approach is problematic in certain environments where one wishes to save on both binary size and compute resources when running tests by:\n\n * Compiling all code with --panic=abort to avoid having to generate unwinding tables, and\n * Running most tests in-process to avoid the overhead of spawning new processes.\n\nThis change removes the intermediate panic step and passes a Result::Err directly through to the test runner.\n\nTo do this, it modifies assert_test_result to return a Result<(), String> where the Err variant holds what was previously the panic message. It changes the types in the TestFn enum to return Result<(), String>.\n\nThis tries to minimise the changes to benchmark tests, so it calls unwrap() on the Result returned by assert_test_result, effectively keeping the same behaviour as before.", "tree": {"sha": "6bc47fc3fc5eabafeed49bc5c2895c60406b8bc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bc47fc3fc5eabafeed49bc5c2895c60406b8bc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e19a98cff73cb18e974c145cb6d15c4860092140", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e19a98cff73cb18e974c145cb6d15c4860092140", "html_url": "https://github.com/rust-lang/rust/commit/e19a98cff73cb18e974c145cb6d15c4860092140", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e19a98cff73cb18e974c145cb6d15c4860092140/comments", "author": {"login": "hovinenb", "id": 20812431, "node_id": "MDQ6VXNlcjIwODEyNDMx", "avatar_url": "https://avatars.githubusercontent.com/u/20812431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hovinenb", "html_url": "https://github.com/hovinenb", "followers_url": "https://api.github.com/users/hovinenb/followers", "following_url": "https://api.github.com/users/hovinenb/following{/other_user}", "gists_url": "https://api.github.com/users/hovinenb/gists{/gist_id}", "starred_url": "https://api.github.com/users/hovinenb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hovinenb/subscriptions", "organizations_url": "https://api.github.com/users/hovinenb/orgs", "repos_url": "https://api.github.com/users/hovinenb/repos", "events_url": "https://api.github.com/users/hovinenb/events{/privacy}", "received_events_url": "https://api.github.com/users/hovinenb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hovinenb", "id": 20812431, "node_id": "MDQ6VXNlcjIwODEyNDMx", "avatar_url": "https://avatars.githubusercontent.com/u/20812431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hovinenb", "html_url": "https://github.com/hovinenb", "followers_url": "https://api.github.com/users/hovinenb/followers", "following_url": "https://api.github.com/users/hovinenb/following{/other_user}", "gists_url": "https://api.github.com/users/hovinenb/gists{/gist_id}", "starred_url": "https://api.github.com/users/hovinenb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hovinenb/subscriptions", "organizations_url": "https://api.github.com/users/hovinenb/orgs", "repos_url": "https://api.github.com/users/hovinenb/repos", "events_url": "https://api.github.com/users/hovinenb/events{/privacy}", "received_events_url": "https://api.github.com/users/hovinenb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d1aa57d1e05d1d745aaf864965eebd1fd8d6071", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d1aa57d1e05d1d745aaf864965eebd1fd8d6071", "html_url": "https://github.com/rust-lang/rust/commit/2d1aa57d1e05d1d745aaf864965eebd1fd8d6071"}], "stats": {"total": 195, "additions": 135, "deletions": 60}, "files": [{"sha": "23925e6ea72ec13121946491d055c9150d74cfb3", "filename": "library/test/src/bench.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e19a98cff73cb18e974c145cb6d15c4860092140/library%2Ftest%2Fsrc%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19a98cff73cb18e974c145cb6d15c4860092140/library%2Ftest%2Fsrc%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fbench.rs?ref=e19a98cff73cb18e974c145cb6d15c4860092140", "patch": "@@ -49,12 +49,12 @@ impl Bencher {\n         self.summary = Some(iter(&mut inner));\n     }\n \n-    pub fn bench<F>(&mut self, mut f: F) -> Option<stats::Summary>\n+    pub fn bench<F>(&mut self, mut f: F) -> Result<Option<stats::Summary>, String>\n     where\n-        F: FnMut(&mut Bencher),\n+        F: FnMut(&mut Bencher) -> Result<(), String>,\n     {\n-        f(self);\n-        self.summary\n+        let result = f(self);\n+        result.map(|_| self.summary)\n     }\n }\n \n@@ -195,7 +195,7 @@ pub fn benchmark<F>(\n     nocapture: bool,\n     f: F,\n ) where\n-    F: FnMut(&mut Bencher),\n+    F: FnMut(&mut Bencher) -> Result<(), String>,\n {\n     let mut bs = Bencher { mode: BenchMode::Auto, summary: None, bytes: 0 };\n \n@@ -211,32 +211,33 @@ pub fn benchmark<F>(\n \n     let test_result = match result {\n         //bs.bench(f) {\n-        Ok(Some(ns_iter_summ)) => {\n+        Ok(Ok(Some(ns_iter_summ))) => {\n             let ns_iter = cmp::max(ns_iter_summ.median as u64, 1);\n             let mb_s = bs.bytes * 1000 / ns_iter;\n \n             let bs = BenchSamples { ns_iter_summ, mb_s: mb_s as usize };\n             TestResult::TrBench(bs)\n         }\n-        Ok(None) => {\n+        Ok(Ok(None)) => {\n             // iter not called, so no data.\n             // FIXME: error in this case?\n             let samples: &mut [f64] = &mut [0.0_f64; 1];\n             let bs = BenchSamples { ns_iter_summ: stats::Summary::new(samples), mb_s: 0 };\n             TestResult::TrBench(bs)\n         }\n         Err(_) => TestResult::TrFailed,\n+        Ok(Err(_)) => TestResult::TrFailed,\n     };\n \n     let stdout = data.lock().unwrap().to_vec();\n     let message = CompletedTest::new(id, desc, test_result, None, stdout);\n     monitor_ch.send(message).unwrap();\n }\n \n-pub fn run_once<F>(f: F)\n+pub fn run_once<F>(f: F) -> Result<(), String>\n where\n-    F: FnMut(&mut Bencher),\n+    F: FnMut(&mut Bencher) -> Result<(), String>,\n {\n     let mut bs = Bencher { mode: BenchMode::Single, summary: None, bytes: 0 };\n-    bs.bench(f);\n+    bs.bench(f).map(|_| ())\n }"}, {"sha": "d328582c38671cd9463fd984a677ac77d3e24e1c", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e19a98cff73cb18e974c145cb6d15c4860092140/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19a98cff73cb18e974c145cb6d15c4860092140/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=e19a98cff73cb18e974c145cb6d15c4860092140", "patch": "@@ -6,7 +6,8 @@\n //! benchmarks themselves) should be done via the `#[test]` and\n //! `#[bench]` attributes.\n //!\n-//! See the [Testing Chapter](../book/ch11-00-testing.html) of the book for more details.\n+//! See the [Testing Chapter](../book/ch11-00-testing.html) of the book for more\n+//! details.\n \n // Currently, not much of this is meant for users. It is intended to\n // support the simplest interface possible for representing and\n@@ -77,6 +78,7 @@ mod types;\n #[cfg(test)]\n mod tests;\n \n+use core::any::Any;\n use event::{CompletedTest, TestEvent};\n use helpers::concurrency::get_concurrency;\n use helpers::exit_code::get_exit_code;\n@@ -176,17 +178,20 @@ fn make_owned_test(test: &&TestDescAndFn) -> TestDescAndFn {\n     }\n }\n \n-/// Invoked when unit tests terminate. Should panic if the unit\n-/// Tests is considered a failure. By default, invokes `report()`\n-/// and checks for a `0` result.\n-pub fn assert_test_result<T: Termination>(result: T) {\n+/// Invoked when unit tests terminate. Returns `Result::Err` if the test is\n+/// considered a failure. By default, invokes `report() and checks for a `0`\n+/// result.\n+pub fn assert_test_result<T: Termination>(result: T) -> Result<(), String> {\n     let code = result.report().to_i32();\n-    assert_eq!(\n-        code, 0,\n-        \"the test returned a termination value with a non-zero status code ({}) \\\n-         which indicates a failure\",\n-        code\n-    );\n+    if code == 0 {\n+        Ok(())\n+    } else {\n+        Err(format!(\n+            \"the test returned a termination value with a non-zero status code \\\n+             ({}) which indicates a failure\",\n+            code\n+        ))\n+    }\n }\n \n pub fn run_tests<F>(\n@@ -479,7 +484,7 @@ pub fn run_test(\n         id: TestId,\n         desc: TestDesc,\n         monitor_ch: Sender<CompletedTest>,\n-        testfn: Box<dyn FnOnce() + Send>,\n+        testfn: Box<dyn FnOnce() -> Result<(), String> + Send>,\n         opts: TestRunOpts,\n     ) -> Option<thread::JoinHandle<()>> {\n         let concurrency = opts.concurrency;\n@@ -568,19 +573,19 @@ pub fn run_test(\n \n /// Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`.\n #[inline(never)]\n-fn __rust_begin_short_backtrace<F: FnOnce()>(f: F) {\n-    f();\n+fn __rust_begin_short_backtrace<T, F: FnOnce() -> T>(f: F) -> T {\n+    let result = f();\n \n     // prevent this frame from being tail-call optimised away\n-    black_box(());\n+    black_box(result)\n }\n \n fn run_test_in_process(\n     id: TestId,\n     desc: TestDesc,\n     nocapture: bool,\n     report_time: bool,\n-    testfn: Box<dyn FnOnce() + Send>,\n+    testfn: Box<dyn FnOnce() -> Result<(), String> + Send>,\n     monitor_ch: Sender<CompletedTest>,\n     time_opts: Option<time::TestTimeOptions>,\n ) {\n@@ -592,7 +597,7 @@ fn run_test_in_process(\n     }\n \n     let start = report_time.then(Instant::now);\n-    let result = catch_unwind(AssertUnwindSafe(testfn));\n+    let result = fold_err(catch_unwind(AssertUnwindSafe(testfn)));\n     let exec_time = start.map(|start| {\n         let duration = start.elapsed();\n         TestExecTime(duration)\n@@ -609,6 +614,19 @@ fn run_test_in_process(\n     monitor_ch.send(message).unwrap();\n }\n \n+fn fold_err<T, E>(\n+    result: Result<Result<T, E>, Box<dyn Any + Send>>,\n+) -> Result<T, Box<dyn Any + Send>>\n+where\n+    E: Send + 'static,\n+{\n+    match result {\n+        Ok(Err(e)) => Err(Box::new(e)),\n+        Ok(Ok(v)) => Ok(v),\n+        Err(e) => Err(e),\n+    }\n+}\n+\n fn spawn_test_subprocess(\n     id: TestId,\n     desc: TestDesc,\n@@ -664,7 +682,10 @@ fn spawn_test_subprocess(\n     monitor_ch.send(message).unwrap();\n }\n \n-fn run_test_in_spawned_subprocess(desc: TestDesc, testfn: Box<dyn FnOnce() + Send>) -> ! {\n+fn run_test_in_spawned_subprocess(\n+    desc: TestDesc,\n+    testfn: Box<dyn FnOnce() -> Result<(), String> + Send>,\n+) -> ! {\n     let builtin_panic_hook = panic::take_hook();\n     let record_result = Arc::new(move |panic_info: Option<&'_ PanicInfo<'_>>| {\n         let test_result = match panic_info {\n@@ -690,7 +711,9 @@ fn run_test_in_spawned_subprocess(desc: TestDesc, testfn: Box<dyn FnOnce() + Sen\n     });\n     let record_result2 = record_result.clone();\n     panic::set_hook(Box::new(move |info| record_result2(Some(&info))));\n-    testfn();\n+    if let Err(message) = testfn() {\n+        panic!(\"{}\", message);\n+    }\n     record_result(None);\n     unreachable!(\"panic=abort callback should have exited the process\")\n }"}, {"sha": "278cfb15bb13332288ade8891633ccf3f2a46eb0", "filename": "library/test/src/tests.rs", "status": "modified", "additions": 68, "deletions": 22, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e19a98cff73cb18e974c145cb6d15c4860092140/library%2Ftest%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19a98cff73cb18e974c145cb6d15c4860092140/library%2Ftest%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftests.rs?ref=e19a98cff73cb18e974c145cb6d15c4860092140", "patch": "@@ -67,7 +67,7 @@ fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n                 no_run: false,\n                 test_type: TestType::Unknown,\n             },\n-            testfn: DynTestFn(Box::new(move || {})),\n+            testfn: DynTestFn(Box::new(move || Ok(()))),\n         },\n         TestDescAndFn {\n             desc: TestDesc {\n@@ -79,14 +79,14 @@ fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n                 no_run: false,\n                 test_type: TestType::Unknown,\n             },\n-            testfn: DynTestFn(Box::new(move || {})),\n+            testfn: DynTestFn(Box::new(move || Ok(()))),\n         },\n     ]\n }\n \n #[test]\n pub fn do_not_run_ignored_tests() {\n-    fn f() {\n+    fn f() -> Result<(), String> {\n         panic!();\n     }\n     let desc = TestDescAndFn {\n@@ -109,7 +109,9 @@ pub fn do_not_run_ignored_tests() {\n \n #[test]\n pub fn ignored_tests_result_in_ignored() {\n-    fn f() {}\n+    fn f() -> Result<(), String> {\n+        Ok(())\n+    }\n     let desc = TestDescAndFn {\n         desc: TestDesc {\n             name: StaticTestName(\"whatever\"),\n@@ -132,7 +134,7 @@ pub fn ignored_tests_result_in_ignored() {\n #[test]\n #[cfg(not(target_os = \"emscripten\"))]\n fn test_should_panic() {\n-    fn f() {\n+    fn f() -> Result<(), String> {\n         panic!();\n     }\n     let desc = TestDescAndFn {\n@@ -157,7 +159,7 @@ fn test_should_panic() {\n #[test]\n #[cfg(not(target_os = \"emscripten\"))]\n fn test_should_panic_good_message() {\n-    fn f() {\n+    fn f() -> Result<(), String> {\n         panic!(\"an error message\");\n     }\n     let desc = TestDescAndFn {\n@@ -183,7 +185,7 @@ fn test_should_panic_good_message() {\n #[cfg(not(target_os = \"emscripten\"))]\n fn test_should_panic_bad_message() {\n     use crate::tests::TrFailedMsg;\n-    fn f() {\n+    fn f() -> Result<(), String> {\n         panic!(\"an error message\");\n     }\n     let expected = \"foobar\";\n@@ -214,7 +216,7 @@ fn test_should_panic_bad_message() {\n fn test_should_panic_non_string_message_type() {\n     use crate::tests::TrFailedMsg;\n     use std::any::TypeId;\n-    fn f() {\n+    fn f() -> Result<(), String> {\n         std::panic::panic_any(1i32);\n     }\n     let expected = \"foobar\";\n@@ -249,7 +251,9 @@ fn test_should_panic_but_succeeds() {\n     let should_panic_variants = [ShouldPanic::Yes, ShouldPanic::YesWithMessage(\"error message\")];\n \n     for &should_panic in should_panic_variants.iter() {\n-        fn f() {}\n+        fn f() -> Result<(), String> {\n+            Ok(())\n+        }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n                 name: StaticTestName(\"whatever\"),\n@@ -283,7 +287,9 @@ fn test_should_panic_but_succeeds() {\n }\n \n fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n-    fn f() {}\n+    fn f() -> Result<(), String> {\n+        Ok(())\n+    }\n     let desc = TestDescAndFn {\n         desc: TestDesc {\n             name: StaticTestName(\"whatever\"),\n@@ -318,7 +324,9 @@ fn test_should_report_time() {\n }\n \n fn time_test_failure_template(test_type: TestType) -> TestResult {\n-    fn f() {}\n+    fn f() -> Result<(), String> {\n+        Ok(())\n+    }\n     let desc = TestDescAndFn {\n         desc: TestDesc {\n             name: StaticTestName(\"whatever\"),\n@@ -480,7 +488,7 @@ pub fn exclude_should_panic_option() {\n             no_run: false,\n             test_type: TestType::Unknown,\n         },\n-        testfn: DynTestFn(Box::new(move || {})),\n+        testfn: DynTestFn(Box::new(move || Ok(()))),\n     });\n \n     let filtered = filter_tests(&opts, tests);\n@@ -504,7 +512,7 @@ pub fn exact_filter_match() {\n                     no_run: false,\n                     test_type: TestType::Unknown,\n                 },\n-                testfn: DynTestFn(Box::new(move || {})),\n+                testfn: DynTestFn(Box::new(move || Ok(()))),\n             })\n             .collect()\n     }\n@@ -580,7 +588,9 @@ fn sample_tests() -> Vec<TestDescAndFn> {\n         \"test::run_include_ignored_option\".to_string(),\n         \"test::sort_tests\".to_string(),\n     ];\n-    fn testfn() {}\n+    fn testfn() -> Result<(), String> {\n+        Ok(())\n+    }\n     let mut tests = Vec::new();\n     for name in &names {\n         let test = TestDescAndFn {\n@@ -717,21 +727,26 @@ pub fn test_metricmap_compare() {\n \n #[test]\n pub fn test_bench_once_no_iter() {\n-    fn f(_: &mut Bencher) {}\n-    bench::run_once(f);\n+    fn f(_: &mut Bencher) -> Result<(), String> {\n+        Ok(())\n+    }\n+    bench::run_once(f).unwrap();\n }\n \n #[test]\n pub fn test_bench_once_iter() {\n-    fn f(b: &mut Bencher) {\n-        b.iter(|| {})\n+    fn f(b: &mut Bencher) -> Result<(), String> {\n+        b.iter(|| {});\n+        Ok(())\n     }\n-    bench::run_once(f);\n+    bench::run_once(f).unwrap();\n }\n \n #[test]\n pub fn test_bench_no_iter() {\n-    fn f(_: &mut Bencher) {}\n+    fn f(_: &mut Bencher) -> Result<(), String> {\n+        Ok(())\n+    }\n \n     let (tx, rx) = channel();\n \n@@ -751,8 +766,9 @@ pub fn test_bench_no_iter() {\n \n #[test]\n pub fn test_bench_iter() {\n-    fn f(b: &mut Bencher) {\n-        b.iter(|| {})\n+    fn f(b: &mut Bencher) -> Result<(), String> {\n+        b.iter(|| {});\n+        Ok(())\n     }\n \n     let (tx, rx) = channel();\n@@ -821,3 +837,33 @@ fn should_sort_failures_before_printing_them() {\n     let bpos = s.find(\"b\").unwrap();\n     assert!(apos < bpos);\n }\n+\n+#[test]\n+#[cfg(not(target_os = \"emscripten\"))]\n+fn test_dyn_bench_returning_err_fails_when_run_as_test() {\n+    fn f(_: &mut Bencher) -> Result<(), String> {\n+        Result::Err(\"An error\".into())\n+    }\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: false,\n+            ignore_message: None,\n+            should_panic: ShouldPanic::No,\n+            compile_fail: false,\n+            no_run: false,\n+            test_type: TestType::Unknown,\n+        },\n+        testfn: DynBenchFn(Box::new(f)),\n+    };\n+    let (tx, rx) = channel();\n+    let notify = move |event: TestEvent| {\n+        if let TestEvent::TeResult(result) = event {\n+            tx.send(result).unwrap();\n+        }\n+        Ok(())\n+    };\n+    run_tests(&TestOpts { run_tests: true, ..TestOpts::new() }, vec![desc], notify).unwrap();\n+    let result = rx.recv().unwrap().result;\n+    assert_eq!(result, TrFailed);\n+}"}, {"sha": "888afff7921d99f43698988cefa9acecdc41d76d", "filename": "library/test/src/types.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e19a98cff73cb18e974c145cb6d15c4860092140/library%2Ftest%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19a98cff73cb18e974c145cb6d15c4860092140/library%2Ftest%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftypes.rs?ref=e19a98cff73cb18e974c145cb6d15c4860092140", "patch": "@@ -75,14 +75,15 @@ impl fmt::Display for TestName {\n }\n \n // A function that runs a test. If the function returns successfully,\n-// the test succeeds; if the function panics then the test fails. We\n-// may need to come up with a more clever definition of test in order\n-// to support isolation of tests into threads.\n+// the test succeeds; if the function panics or returns Result::Err\n+// then the test fails. We may need to come up with a more clever\n+// definition of test in order to support isolation of tests into\n+// threads.\n pub enum TestFn {\n-    StaticTestFn(fn()),\n-    StaticBenchFn(fn(&mut Bencher)),\n-    DynTestFn(Box<dyn FnOnce() + Send>),\n-    DynBenchFn(Box<dyn Fn(&mut Bencher) + Send>),\n+    StaticTestFn(fn() -> Result<(), String>),\n+    StaticBenchFn(fn(&mut Bencher) -> Result<(), String>),\n+    DynTestFn(Box<dyn FnOnce() -> Result<(), String> + Send>),\n+    DynBenchFn(Box<dyn Fn(&mut Bencher) -> Result<(), String> + Send>),\n }\n \n impl TestFn {"}, {"sha": "f4ec60735a8dd23000d055298f4b6bbf557694d4", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e19a98cff73cb18e974c145cb6d15c4860092140/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19a98cff73cb18e974c145cb6d15c4860092140/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=e19a98cff73cb18e974c145cb6d15c4860092140", "patch": "@@ -1134,6 +1134,7 @@ impl Tester for Collector {\n \n                     panic::resume_unwind(Box::new(()));\n                 }\n+                Ok(())\n             })),\n         });\n     }"}, {"sha": "7c1390cdc6446665472239b9a71bed85d62ef3c3", "filename": "src/test/ui/rfc-1937-termination-trait/termination-trait-test-wrong-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e19a98cff73cb18e974c145cb6d15c4860092140/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e19a98cff73cb18e974c145cb6d15c4860092140/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr?ref=e19a98cff73cb18e974c145cb6d15c4860092140", "patch": "@@ -13,7 +13,7 @@ LL | | }\n note: required by a bound in `assert_test_result`\n   --> $SRC_DIR/test/src/lib.rs:LL:COL\n    |\n-LL | pub fn assert_test_result<T: Termination>(result: T) {\n+LL | pub fn assert_test_result<T: Termination>(result: T) -> Result<(), String> {\n    |                              ^^^^^^^^^^^ required by this bound in `assert_test_result`\n    = note: this error originates in the attribute macro `test` (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "c3af71d465a1f5f3459392b1de60112e3ccd665b", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e19a98cff73cb18e974c145cb6d15c4860092140/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19a98cff73cb18e974c145cb6d15c4860092140/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=e19a98cff73cb18e974c145cb6d15c4860092140", "patch": "@@ -805,7 +805,10 @@ fn make_test_closure(\n     let config = config.clone();\n     let testpaths = testpaths.clone();\n     let revision = revision.cloned();\n-    test::DynTestFn(Box::new(move || runtest::run(config, &testpaths, revision.as_deref())))\n+    test::DynTestFn(Box::new(move || {\n+        runtest::run(config, &testpaths, revision.as_deref());\n+        Ok(())\n+    }))\n }\n \n /// Returns `true` if the given target is an Android target for the"}]}