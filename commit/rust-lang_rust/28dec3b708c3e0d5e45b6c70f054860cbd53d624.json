{"sha": "28dec3b708c3e0d5e45b6c70f054860cbd53d624", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZGVjM2I3MDhjM2UwZDVlNDViNmM3MGYwNTQ4NjBjYmQ1M2Q2MjQ=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2020-11-25T02:37:07Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2020-11-29T21:34:11Z"}, "message": "Add collapsible_match lint", "tree": {"sha": "02b9df6f74ce89844183e2ad21ea3e9ee1b31505", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02b9df6f74ce89844183e2ad21ea3e9ee1b31505"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28dec3b708c3e0d5e45b6c70f054860cbd53d624", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28dec3b708c3e0d5e45b6c70f054860cbd53d624", "html_url": "https://github.com/rust-lang/rust/commit/28dec3b708c3e0d5e45b6c70f054860cbd53d624", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28dec3b708c3e0d5e45b6c70f054860cbd53d624/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e1fbfdb8fe9a6b543fa2b0e688f928d2ee354b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e1fbfdb8fe9a6b543fa2b0e688f928d2ee354b8", "html_url": "https://github.com/rust-lang/rust/commit/6e1fbfdb8fe9a6b543fa2b0e688f928d2ee354b8"}], "stats": {"total": 693, "additions": 693, "deletions": 0}, "files": [{"sha": "e65e7cc639f7a256860ffe4f3066f263111a31a9", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28dec3b708c3e0d5e45b6c70f054860cbd53d624/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/28dec3b708c3e0d5e45b6c70f054860cbd53d624/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=28dec3b708c3e0d5e45b6c70f054860cbd53d624", "patch": "@@ -1770,6 +1770,7 @@ Released 2018-09-13\n [`cmp_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#cmp_owned\n [`cognitive_complexity`]: https://rust-lang.github.io/rust-clippy/master/index.html#cognitive_complexity\n [`collapsible_if`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_if\n+[`collapsible_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_match\n [`comparison_chain`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_chain\n [`comparison_to_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#comparison_to_empty\n [`copy_iterator`]: https://rust-lang.github.io/rust-clippy/master/index.html#copy_iterator"}, {"sha": "a34ba2d00a8c7bc71873bcb692b8ad7498542543", "filename": "clippy_lints/src/collapsible_match.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/28dec3b708c3e0d5e45b6c70f054860cbd53d624/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28dec3b708c3e0d5e45b6c70f054860cbd53d624/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=28dec3b708c3e0d5e45b6c70f054860cbd53d624", "patch": "@@ -0,0 +1,172 @@\n+use crate::utils::visitors::LocalUsedVisitor;\n+use crate::utils::{span_lint_and_then, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, QPath, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{DefIdTree, TyCtxt};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{MultiSpan, Span};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Finds nested `match` or `if let` expressions where the patterns may be \"collapsed\" together\n+    /// without adding any branches.\n+    ///\n+    /// Note that this lint is not intended to find _all_ cases where nested match patterns can be merged, but only\n+    /// cases where merging would most likely make the code more readable.\n+    ///\n+    /// **Why is this bad?** It is unnecessarily verbose and complex.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// fn func(opt: Option<Result<u64, String>>) {\n+    ///     let n = match opt {\n+    ///         Some(n) => match n {\n+    ///             Ok(n) => n,\n+    ///             _ => return,\n+    ///         }\n+    ///         None => return,\n+    ///     };\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn func(opt: Option<Result<u64, String>>) {\n+    ///     let n = match opt {\n+    ///         Some(Ok(n)) => n,\n+    ///         _ => return,\n+    ///     };\n+    /// }\n+    /// ```\n+    pub COLLAPSIBLE_MATCH,\n+    style,\n+    \"Nested `match` or `if let` expressions where the patterns may be \\\"collapsed\\\" together.\"\n+}\n+\n+declare_lint_pass!(CollapsibleMatch => [COLLAPSIBLE_MATCH]);\n+\n+impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n+        if let ExprKind::Match(_expr, arms, _source) = expr.kind {\n+            if let Some(wild_arm) = arms.iter().rfind(|arm| arm_is_wild_like(arm, cx.tcx)) {\n+                for arm in arms {\n+                    check_arm(arm, wild_arm, cx);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn check_arm(arm: &Arm<'_>, wild_outer_arm: &Arm<'_>, cx: &LateContext<'_>) {\n+    if_chain! {\n+        let expr = strip_singleton_blocks(arm.body);\n+        if let ExprKind::Match(expr_in, arms_inner, _) = expr.kind;\n+        // the outer arm pattern and the inner match\n+        if expr_in.span.ctxt() == arm.pat.span.ctxt();\n+        // there must be no more than two arms in the inner match for this lint\n+        if arms_inner.len() == 2;\n+        // no if guards on the inner match\n+        if arms_inner.iter().all(|arm| arm.guard.is_none());\n+        // match expression must be a local binding\n+        // match <local> { .. }\n+        if let ExprKind::Path(QPath::Resolved(None, path)) = expr_in.kind;\n+        if let Res::Local(binding_id) = path.res;\n+        // one of the branches must be \"wild-like\"\n+        if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| arm_is_wild_like(arm_inner, cx.tcx));\n+        let (wild_inner_arm, non_wild_inner_arm) =\n+            (&arms_inner[wild_inner_arm_idx], &arms_inner[1 - wild_inner_arm_idx]);\n+        if !pat_contains_or(non_wild_inner_arm.pat);\n+        // the binding must come from the pattern of the containing match arm\n+        // ..<local>.. => match <local> { .. }\n+        if let Some(binding_span) = find_pat_binding(arm.pat, binding_id);\n+        // the \"wild-like\" branches must be equal\n+        if SpanlessEq::new(cx).eq_expr(wild_inner_arm.body, wild_outer_arm.body);\n+        // the binding must not be used in the if guard\n+        if !matches!(arm.guard, Some(Guard::If(guard)) if LocalUsedVisitor::new(binding_id).check_expr(guard));\n+        // ...or anywhere in the inner match\n+        if !arms_inner.iter().any(|arm| LocalUsedVisitor::new(binding_id).check_arm(arm));\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                COLLAPSIBLE_MATCH,\n+                expr.span,\n+                \"Unnecessary nested match\",\n+                |diag| {\n+                    let mut help_span = MultiSpan::from_spans(vec![binding_span, non_wild_inner_arm.pat.span]);\n+                    help_span.push_span_label(binding_span, \"Replace this binding\".into());\n+                    help_span.push_span_label(non_wild_inner_arm.pat.span, \"with this pattern\".into());\n+                    diag.span_help(help_span, \"The outer pattern can be modified to include the inner pattern.\");\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n+    while let ExprKind::Block(block, _) = expr.kind {\n+        match (block.stmts, block.expr) {\n+            ([stmt], None) => match stmt.kind {\n+                StmtKind::Expr(e) | StmtKind::Semi(e) => expr = e,\n+                _ => break,\n+            },\n+            ([], Some(e)) => expr = e,\n+            _ => break,\n+        }\n+    }\n+    expr\n+}\n+\n+/// A \"wild-like\" pattern is wild (\"_\") or `None`.\n+/// For this lint to apply, both the outer and inner match expressions\n+/// must have \"wild-like\" branches that can be combined.\n+fn arm_is_wild_like(arm: &Arm<'_>, tcx: TyCtxt<'_>) -> bool {\n+    if arm.guard.is_some() {\n+        return false;\n+    }\n+    match arm.pat.kind {\n+        PatKind::Binding(..) | PatKind::Wild => true,\n+        PatKind::Path(QPath::Resolved(None, path)) if is_none_ctor(path.res, tcx) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn find_pat_binding(pat: &Pat<'_>, hir_id: HirId) -> Option<Span> {\n+    let mut span = None;\n+    pat.walk_short(|p| match &p.kind {\n+        // ignore OR patterns\n+        PatKind::Or(_) => false,\n+        PatKind::Binding(_bm, _, _ident, _) => {\n+            let found = p.hir_id == hir_id;\n+            if found {\n+                span = Some(p.span);\n+            }\n+            !found\n+        },\n+        _ => true,\n+    });\n+    span\n+}\n+\n+fn pat_contains_or(pat: &Pat<'_>) -> bool {\n+    let mut result = false;\n+    pat.walk(|p| {\n+        let is_or = matches!(p.kind, PatKind::Or(_));\n+        result |= is_or;\n+        !is_or\n+    });\n+    result\n+}\n+\n+fn is_none_ctor(res: Res, tcx: TyCtxt<'_>) -> bool {\n+    if let Some(none_id) = tcx.lang_items().option_none_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Const), id) = res {\n+            if let Some(variant_id) = tcx.parent(id) {\n+                return variant_id == none_id;\n+            }\n+        }\n+    }\n+    false\n+}"}, {"sha": "ca190986cdbd0ef2e333de2e2de2d94cd67e7340", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28dec3b708c3e0d5e45b6c70f054860cbd53d624/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28dec3b708c3e0d5e45b6c70f054860cbd53d624/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=28dec3b708c3e0d5e45b6c70f054860cbd53d624", "patch": "@@ -172,6 +172,7 @@ mod cargo_common_metadata;\n mod checked_conversions;\n mod cognitive_complexity;\n mod collapsible_if;\n+mod collapsible_match;\n mod comparison_chain;\n mod copies;\n mod copy_iterator;\n@@ -531,6 +532,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &checked_conversions::CHECKED_CONVERSIONS,\n         &cognitive_complexity::COGNITIVE_COMPLEXITY,\n         &collapsible_if::COLLAPSIBLE_IF,\n+        &collapsible_match::COLLAPSIBLE_MATCH,\n         &comparison_chain::COMPARISON_CHAIN,\n         &copies::IFS_SAME_COND,\n         &copies::IF_SAME_THEN_ELSE,\n@@ -960,6 +962,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box len_zero::LenZero);\n     store.register_late_pass(|| box attrs::Attributes);\n     store.register_late_pass(|| box blocks_in_if_conditions::BlocksInIfConditions);\n+    store.register_late_pass(|| box collapsible_match::CollapsibleMatch);\n     store.register_late_pass(|| box unicode::Unicode);\n     store.register_late_pass(|| box unit_return_expecting_ord::UnitReturnExpectingOrd);\n     store.register_late_pass(|| box strings::StringAdd);\n@@ -1351,6 +1354,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&booleans::NONMINIMAL_BOOL),\n         LintId::of(&bytecount::NAIVE_BYTECOUNT),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n+        LintId::of(&collapsible_match::COLLAPSIBLE_MATCH),\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n         LintId::of(&copies::IFS_SAME_COND),\n         LintId::of(&copies::IF_SAME_THEN_ELSE),\n@@ -1617,6 +1621,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n         LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n+        LintId::of(&collapsible_match::COLLAPSIBLE_MATCH),\n         LintId::of(&comparison_chain::COMPARISON_CHAIN),\n         LintId::of(&default::FIELD_REASSIGN_WITH_DEFAULT),\n         LintId::of(&doc::MISSING_SAFETY_DOC),"}, {"sha": "75640b70ff06e8a98c903a9d3bec0eeb3c607dfe", "filename": "tests/ui/collapsible_match.rs", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/28dec3b708c3e0d5e45b6c70f054860cbd53d624/tests%2Fui%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28dec3b708c3e0d5e45b6c70f054860cbd53d624/tests%2Fui%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match.rs?ref=28dec3b708c3e0d5e45b6c70f054860cbd53d624", "patch": "@@ -0,0 +1,278 @@\n+#![warn(clippy::collapsible_match)]\n+#![allow(clippy::needless_return, clippy::no_effect, clippy::single_match)]\n+\n+fn lint_cases(opt_opt: Option<Option<u32>>, res_opt: Result<Option<u32>, String>) {\n+    // match without block\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // match with block\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // if let, if let\n+    if let Ok(val) = res_opt {\n+        if let Some(n) = val {\n+            take(n);\n+        }\n+    }\n+\n+    // if let else, if let else\n+    if let Ok(val) = res_opt {\n+        if let Some(n) = val {\n+            take(n);\n+        } else {\n+            return;\n+        }\n+    } else {\n+        return;\n+    }\n+\n+    // if let, match\n+    if let Ok(val) = res_opt {\n+        match val {\n+            Some(n) => foo(n),\n+            _ => (),\n+        }\n+    }\n+\n+    // match, if let\n+    match res_opt {\n+        Ok(val) => {\n+            if let Some(n) = val {\n+                take(n);\n+            }\n+        },\n+        _ => {},\n+    }\n+\n+    // if let else, match\n+    if let Ok(val) = res_opt {\n+        match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        }\n+    } else {\n+        return;\n+    }\n+\n+    // match, if let else\n+    match res_opt {\n+        Ok(val) => {\n+            if let Some(n) = val {\n+                take(n);\n+            } else {\n+                return;\n+            }\n+        },\n+        _ => return,\n+    }\n+\n+    // None in inner match same as outer wild branch\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            None => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // None in outer match same as inner wild branch\n+    match opt_opt {\n+        Some(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        None => return,\n+    }\n+\n+    // if guards on outer match\n+    {\n+        match res_opt {\n+            Ok(val) if make() => match val {\n+                Some(n) => foo(n),\n+                _ => return,\n+            },\n+            _ => return,\n+        }\n+        match res_opt {\n+            Ok(val) => match val {\n+                Some(n) => foo(n),\n+                _ => return,\n+            },\n+            _ if make() => return,\n+            _ => return,\n+        }\n+    }\n+\n+    // macro\n+    {\n+        macro_rules! mac {\n+            ($outer:expr => $pat:pat, $e:expr => $inner_pat:pat, $then:expr) => {\n+                match $outer {\n+                    $pat => match $e {\n+                        $inner_pat => $then,\n+                        _ => return,\n+                    },\n+                    _ => return,\n+                }\n+            };\n+        }\n+        // Lint this since the patterns are not defined by the macro.\n+        // Allows the lint to work on if_chain! for example.\n+        // Fixing the lint requires knowledge of the specific macro, but we optimistically assume that\n+        // there is still a better way to write this.\n+        mac!(res_opt => Ok(val), val => Some(n), foo(n));\n+    }\n+}\n+\n+fn negative_cases(res_opt: Result<Option<u32>, String>, res_res: Result<Result<u32, String>, String>) {\n+    // no wild pattern in outer match\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        Err(_) => return,\n+    }\n+\n+    // inner branch is not wild or None\n+    match res_res {\n+        Ok(val) => match val {\n+            Ok(n) => foo(n),\n+            Err(_) => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // statement before inner match\n+    match res_opt {\n+        Ok(val) => {\n+            \"hi buddy\";\n+            match val {\n+                Some(n) => foo(n),\n+                _ => return,\n+            }\n+        },\n+        _ => return,\n+    }\n+\n+    // statement after inner match\n+    match res_opt {\n+        Ok(val) => {\n+            match val {\n+                Some(n) => foo(n),\n+                _ => return,\n+            }\n+            \"hi buddy\";\n+        },\n+        _ => return,\n+    }\n+\n+    // wild branches do not match\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(n) => foo(n),\n+            _ => {\n+                \"sup\";\n+                return;\n+            },\n+        },\n+        _ => return,\n+    }\n+\n+    // binding used in if guard\n+    match res_opt {\n+        Ok(val) if val.is_some() => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // binding used in inner match body\n+    match res_opt {\n+        Ok(val) => match val {\n+            Some(_) => take(val),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+\n+    // if guard on inner match\n+    {\n+        match res_opt {\n+            Ok(val) => match val {\n+                Some(n) if make() => foo(n),\n+                _ => return,\n+            },\n+            _ => return,\n+        }\n+        match res_opt {\n+            Ok(val) => match val {\n+                _ => make(),\n+                _ if make() => return,\n+            },\n+            _ => return,\n+        }\n+    }\n+\n+    // differing macro contexts\n+    {\n+        macro_rules! mac {\n+            ($val:ident) => {\n+                match $val {\n+                    Some(n) => foo(n),\n+                    _ => return,\n+                }\n+            };\n+        }\n+        match res_opt {\n+            Ok(val) => mac!(val),\n+            _ => return,\n+        }\n+    }\n+\n+    // OR pattern\n+    enum E<T> {\n+        A(T),\n+        B(T),\n+        C(T),\n+    };\n+    match make::<E<Option<u32>>>() {\n+        E::A(val) | E::B(val) => match val {\n+            Some(n) => foo(n),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+    match make::<Option<E<u32>>>() {\n+        Some(val) => match val {\n+            E::A(val) | E::B(val) => foo(val),\n+            _ => return,\n+        },\n+        _ => return,\n+    }\n+}\n+\n+fn make<T>() -> T {\n+    unimplemented!()\n+}\n+\n+fn foo<T, U>(t: T) -> U {\n+    unimplemented!()\n+}\n+\n+fn take<T>(t: T) {}\n+\n+fn main() {}"}, {"sha": "a9e4f91191410cedfa2a28340b6877eaadcab816", "filename": "tests/ui/collapsible_match.stderr", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/28dec3b708c3e0d5e45b6c70f054860cbd53d624/tests%2Fui%2Fcollapsible_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28dec3b708c3e0d5e45b6c70f054860cbd53d624/tests%2Fui%2Fcollapsible_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match.stderr?ref=28dec3b708c3e0d5e45b6c70f054860cbd53d624", "patch": "@@ -0,0 +1,237 @@\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:7:20\n+   |\n+LL |           Ok(val) => match val {\n+   |  ____________________^\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => return,\n+LL | |         },\n+   | |_________^\n+   |\n+   = note: `-D clippy::collapsible-match` implied by `-D warnings`\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:7:12\n+   |\n+LL |         Ok(val) => match val {\n+   |            ^^^ Replace this binding\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:16:20\n+   |\n+LL |           Ok(val) => match val {\n+   |  ____________________^\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => return,\n+LL | |         },\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:16:12\n+   |\n+LL |         Ok(val) => match val {\n+   |            ^^^ Replace this binding\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:25:9\n+   |\n+LL | /         if let Some(n) = val {\n+LL | |             take(n);\n+LL | |         }\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:24:15\n+   |\n+LL |     if let Ok(val) = res_opt {\n+   |               ^^^ Replace this binding\n+LL |         if let Some(n) = val {\n+   |                ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:32:9\n+   |\n+LL | /         if let Some(n) = val {\n+LL | |             take(n);\n+LL | |         } else {\n+LL | |             return;\n+LL | |         }\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:31:15\n+   |\n+LL |     if let Ok(val) = res_opt {\n+   |               ^^^ Replace this binding\n+LL |         if let Some(n) = val {\n+   |                ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:43:9\n+   |\n+LL | /         match val {\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => (),\n+LL | |         }\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:42:15\n+   |\n+LL |     if let Ok(val) = res_opt {\n+   |               ^^^ Replace this binding\n+LL |         match val {\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:52:13\n+   |\n+LL | /             if let Some(n) = val {\n+LL | |                 take(n);\n+LL | |             }\n+   | |_____________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:51:12\n+   |\n+LL |         Ok(val) => {\n+   |            ^^^ Replace this binding\n+LL |             if let Some(n) = val {\n+   |                    ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:61:9\n+   |\n+LL | /         match val {\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => return,\n+LL | |         }\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:60:15\n+   |\n+LL |     if let Ok(val) = res_opt {\n+   |               ^^^ Replace this binding\n+LL |         match val {\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:72:13\n+   |\n+LL | /             if let Some(n) = val {\n+LL | |                 take(n);\n+LL | |             } else {\n+LL | |                 return;\n+LL | |             }\n+   | |_____________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:71:12\n+   |\n+LL |         Ok(val) => {\n+   |            ^^^ Replace this binding\n+LL |             if let Some(n) = val {\n+   |                    ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:83:20\n+   |\n+LL |           Ok(val) => match val {\n+   |  ____________________^\n+LL | |             Some(n) => foo(n),\n+LL | |             None => return,\n+LL | |         },\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:83:12\n+   |\n+LL |         Ok(val) => match val {\n+   |            ^^^ Replace this binding\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:92:22\n+   |\n+LL |           Some(val) => match val {\n+   |  ______________________^\n+LL | |             Some(n) => foo(n),\n+LL | |             _ => return,\n+LL | |         },\n+   | |_________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:92:14\n+   |\n+LL |         Some(val) => match val {\n+   |              ^^^ Replace this binding\n+LL |             Some(n) => foo(n),\n+   |             ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:102:34\n+   |\n+LL |               Ok(val) if make() => match val {\n+   |  __________________________________^\n+LL | |                 Some(n) => foo(n),\n+LL | |                 _ => return,\n+LL | |             },\n+   | |_____________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:102:16\n+   |\n+LL |             Ok(val) if make() => match val {\n+   |                ^^^ Replace this binding\n+LL |                 Some(n) => foo(n),\n+   |                 ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:109:24\n+   |\n+LL |               Ok(val) => match val {\n+   |  ________________________^\n+LL | |                 Some(n) => foo(n),\n+LL | |                 _ => return,\n+LL | |             },\n+   | |_____________^\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:109:16\n+   |\n+LL |             Ok(val) => match val {\n+   |                ^^^ Replace this binding\n+LL |                 Some(n) => foo(n),\n+   |                 ^^^^^^^ with this pattern\n+\n+error: Unnecessary nested match\n+  --> $DIR/collapsible_match.rs:123:29\n+   |\n+LL |                       $pat => match $e {\n+   |  _____________________________^\n+LL | |                         $inner_pat => $then,\n+LL | |                         _ => return,\n+LL | |                     },\n+   | |_____________________^\n+...\n+LL |           mac!(res_opt => Ok(val), val => Some(n), foo(n));\n+   |           ------------------------------------------------- in this macro invocation\n+   |\n+help: The outer pattern can be modified to include the inner pattern.\n+  --> $DIR/collapsible_match.rs:135:28\n+   |\n+LL |         mac!(res_opt => Ok(val), val => Some(n), foo(n));\n+   |                            ^^^          ^^^^^^^ with this pattern\n+   |                            |\n+   |                            Replace this binding\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 13 previous errors\n+"}]}