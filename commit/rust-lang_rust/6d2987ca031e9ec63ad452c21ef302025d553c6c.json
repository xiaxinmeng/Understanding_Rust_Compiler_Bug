{"sha": "6d2987ca031e9ec63ad452c21ef302025d553c6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMjk4N2NhMDMxZTllYzYzYWQ0NTJjMjFlZjMwMjAyNWQ1NTNjNmM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:36:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:38:10Z"}, "message": "Move categorize logic out of visit_local function", "tree": {"sha": "9e17a33a8dfccad6a2f4709ac955bacda50109a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e17a33a8dfccad6a2f4709ac955bacda50109a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d2987ca031e9ec63ad452c21ef302025d553c6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d2987ca031e9ec63ad452c21ef302025d553c6c", "html_url": "https://github.com/rust-lang/rust/commit/6d2987ca031e9ec63ad452c21ef302025d553c6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d2987ca031e9ec63ad452c21ef302025d553c6c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58b0506d6579455bd28d28c94cf7267205a1ba81", "url": "https://api.github.com/repos/rust-lang/rust/commits/58b0506d6579455bd28d28c94cf7267205a1ba81", "html_url": "https://github.com/rust-lang/rust/commit/58b0506d6579455bd28d28c94cf7267205a1ba81"}], "stats": {"total": 138, "additions": 80, "deletions": 58}, "files": [{"sha": "765d50b4006132ac8eacba7aff7e87ddc8c39371", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 80, "deletions": 58, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/6d2987ca031e9ec63ad452c21ef302025d553c6c/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d2987ca031e9ec63ad452c21ef302025d553c6c/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=6d2987ca031e9ec63ad452c21ef302025d553c6c", "patch": "@@ -220,6 +220,81 @@ impl LivenessResult {\n     }\n }\n \n+#[derive(Eq, PartialEq, Clone)]\n+pub enum DefUse {\n+    Def,\n+    Use,\n+}\n+\n+pub fn categorize<'tcx>(context: PlaceContext<'tcx>, mode: LivenessMode) -> Option<DefUse> {\n+    match context {\n+        ///////////////////////////////////////////////////////////////////////////\n+        // DEFS\n+\n+        PlaceContext::Store |\n+\n+        // This is potentially both a def and a use...\n+        PlaceContext::AsmOutput |\n+\n+        // We let Call define the result in both the success and\n+        // unwind cases. This is not really correct, however it\n+        // does not seem to be observable due to the way that we\n+        // generate MIR. See the test case\n+        // `mir-opt/nll/liveness-call-subtlety.rs`. To do things\n+        // properly, we would apply the def in call only to the\n+        // input from the success path and not the unwind\n+        // path. -nmatsakis\n+        PlaceContext::Call |\n+\n+        // Storage live and storage dead aren't proper defines, but we can ignore\n+        // values that come before them.\n+        PlaceContext::StorageLive |\n+        PlaceContext::StorageDead => Some(DefUse::Def),\n+\n+        ///////////////////////////////////////////////////////////////////////////\n+        // REGULAR USES\n+        //\n+        // These are uses that occur *outside* of a drop. For the\n+        // purposes of NLL, these are special in that **all** the\n+        // lifetimes appearing in the variable must be live for each regular use.\n+\n+        PlaceContext::Projection(..) |\n+\n+        // Borrows only consider their local used at the point of the borrow.\n+        // This won't affect the results since we use this analysis for generators\n+        // and we only care about the result at suspension points. Borrows cannot\n+        // cross suspension points so this behavior is unproblematic.\n+        PlaceContext::Borrow { .. } |\n+\n+        PlaceContext::Inspect |\n+        PlaceContext::Copy |\n+        PlaceContext::Move |\n+        PlaceContext::Validate => {\n+            if mode.include_regular_use {\n+                Some(DefUse::Use)\n+            } else {\n+                None\n+            }\n+        }\n+\n+        ///////////////////////////////////////////////////////////////////////////\n+        // DROP USES\n+        //\n+        // These are uses that occur in a DROP (a MIR drop, not a\n+        // call to `std::mem::drop()`). For the purposes of NLL,\n+        // uses in drop are special because `#[may_dangle]`\n+        // attributes can affect whether lifetimes must be live.\n+\n+        PlaceContext::Drop => {\n+            if mode.include_drops {\n+                Some(DefUse::Use)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n struct DefsUsesVisitor {\n     mode: LivenessMode,\n     defs_uses: DefsUses,\n@@ -268,69 +343,16 @@ impl DefsUses {\n \n impl<'tcx> Visitor<'tcx> for DefsUsesVisitor {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, _: Location) {\n-        match context {\n-            ///////////////////////////////////////////////////////////////////////////\n-            // DEFS\n-\n-            PlaceContext::Store |\n-\n-            // This is potentially both a def and a use...\n-            PlaceContext::AsmOutput |\n-\n-            // We let Call define the result in both the success and\n-            // unwind cases. This is not really correct, however it\n-            // does not seem to be observable due to the way that we\n-            // generate MIR. See the test case\n-            // `mir-opt/nll/liveness-call-subtlety.rs`. To do things\n-            // properly, we would apply the def in call only to the\n-            // input from the success path and not the unwind\n-            // path. -nmatsakis\n-            PlaceContext::Call |\n-\n-            // Storage live and storage dead aren't proper defines, but we can ignore\n-            // values that come before them.\n-            PlaceContext::StorageLive |\n-            PlaceContext::StorageDead => {\n+        match categorize(context, self.mode) {\n+            Some(DefUse::Def) => {\n                 self.defs_uses.add_def(local);\n             }\n \n-            ///////////////////////////////////////////////////////////////////////////\n-            // REGULAR USES\n-            //\n-            // These are uses that occur *outside* of a drop. For the\n-            // purposes of NLL, these are special in that **all** the\n-            // lifetimes appearing in the variable must be live for each regular use.\n-\n-            PlaceContext::Projection(..) |\n-\n-            // Borrows only consider their local used at the point of the borrow.\n-            // This won't affect the results since we use this analysis for generators\n-            // and we only care about the result at suspension points. Borrows cannot\n-            // cross suspension points so this behavior is unproblematic.\n-            PlaceContext::Borrow { .. } |\n-\n-            PlaceContext::Inspect |\n-            PlaceContext::Copy |\n-            PlaceContext::Move |\n-            PlaceContext::Validate => {\n-                if self.mode.include_regular_use {\n-                    self.defs_uses.add_use(local);\n-                }\n+            Some(DefUse::Use) => {\n+                self.defs_uses.add_use(local);\n             }\n \n-            ///////////////////////////////////////////////////////////////////////////\n-            // DROP USES\n-            //\n-            // These are uses that occur in a DROP (a MIR drop, not a\n-            // call to `std::mem::drop()`). For the purposes of NLL,\n-            // uses in drop are special because `#[may_dangle]`\n-            // attributes can affect whether lifetimes must be live.\n-\n-            PlaceContext::Drop => {\n-                if self.mode.include_drops {\n-                    self.defs_uses.add_use(local);\n-                }\n-            }\n+            None => {}\n         }\n     }\n }"}]}