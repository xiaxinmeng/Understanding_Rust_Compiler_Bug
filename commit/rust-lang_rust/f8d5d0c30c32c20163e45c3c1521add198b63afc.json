{"sha": "f8d5d0c30c32c20163e45c3c1521add198b63afc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ZDVkMGMzMGMzMmMyMDE2M2U0NWMzYzE1MjFhZGQxOThiNjNhZmM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-10-03T07:45:07Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:33Z"}, "message": "rustc_trans: compute better align/dereferenceable attributes from pointees.", "tree": {"sha": "80fa9ee82a4771dbadc3d8190453e6149234c872", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80fa9ee82a4771dbadc3d8190453e6149234c872"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8d5d0c30c32c20163e45c3c1521add198b63afc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8d5d0c30c32c20163e45c3c1521add198b63afc", "html_url": "https://github.com/rust-lang/rust/commit/f8d5d0c30c32c20163e45c3c1521add198b63afc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8d5d0c30c32c20163e45c3c1521add198b63afc/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "url": "https://api.github.com/repos/rust-lang/rust/commits/ced5e04e8bfa80ae297cba6c95ec0948dceb6933", "html_url": "https://github.com/rust-lang/rust/commit/ced5e04e8bfa80ae297cba6c95ec0948dceb6933"}], "stats": {"total": 360, "additions": 237, "deletions": 123}, "files": [{"sha": "f8c71d4825513f30daa1b2b51e1b9b95da64a9ce", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8d5d0c30c32c20163e45c3c1521add198b63afc/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d5d0c30c32c20163e45c3c1521add198b63afc/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=f8d5d0c30c32c20163e45c3c1521add198b63afc", "patch": "@@ -730,7 +730,9 @@ extern \"C\" {\n                                        FunctionTy: TypeRef)\n                                        -> ValueRef;\n     pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n+    pub fn LLVMRustAddAlignmentAttr(Fn: ValueRef, index: c_uint, bytes: u32);\n     pub fn LLVMRustAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: u64);\n+    pub fn LLVMRustAddDereferenceableOrNullAttr(Fn: ValueRef, index: c_uint, bytes: u64);\n     pub fn LLVMRustAddFunctionAttribute(Fn: ValueRef, index: c_uint, attr: Attribute);\n     pub fn LLVMRustAddFunctionAttrStringValue(Fn: ValueRef,\n                                               index: c_uint,\n@@ -760,7 +762,11 @@ extern \"C\" {\n     // Operations on call sites\n     pub fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n     pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef, index: c_uint, attr: Attribute);\n+    pub fn LLVMRustAddAlignmentCallSiteAttr(Instr: ValueRef, index: c_uint, bytes: u32);\n     pub fn LLVMRustAddDereferenceableCallSiteAttr(Instr: ValueRef, index: c_uint, bytes: u64);\n+    pub fn LLVMRustAddDereferenceableOrNullCallSiteAttr(Instr: ValueRef,\n+                                                        index: c_uint,\n+                                                        bytes: u64);\n \n     // Operations on load/store instructions (only)\n     pub fn LLVMSetVolatile(MemoryAccessInst: ValueRef, volatile: Bool);"}, {"sha": "aaadc7518e51c9b695f7c6904e0ad86554388cfb", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 167, "deletions": 117, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/f8d5d0c30c32c20163e45c3c1521add198b63afc/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d5d0c30c32c20163e45c3c1521add198b63afc/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=f8d5d0c30c32c20163e45c3c1521add198b63afc", "patch": "@@ -96,20 +96,24 @@ impl ArgAttribute {\n \n /// A compact representation of LLVM attributes (at least those relevant for this module)\n /// that can be manipulated without interacting with LLVM's Attribute machinery.\n-#[derive(Copy, Clone, Debug, Default)]\n+#[derive(Copy, Clone, Debug)]\n pub struct ArgAttributes {\n     regular: ArgAttribute,\n-    dereferenceable_bytes: u64,\n+    pointee_size: Size,\n+    pointee_align: Option<Align>\n }\n \n impl ArgAttributes {\n-    pub fn set(&mut self, attr: ArgAttribute) -> &mut Self {\n-        self.regular = self.regular | attr;\n-        self\n+    fn new() -> Self {\n+        ArgAttributes {\n+            regular: ArgAttribute::default(),\n+            pointee_size: Size::from_bytes(0),\n+            pointee_align: None,\n+        }\n     }\n \n-    pub fn set_dereferenceable(&mut self, size: Size) -> &mut Self {\n-        self.dereferenceable_bytes = size.bytes();\n+    pub fn set(&mut self, attr: ArgAttribute) -> &mut Self {\n+        self.regular = self.regular | attr;\n         self\n     }\n \n@@ -118,24 +122,52 @@ impl ArgAttributes {\n     }\n \n     pub fn apply_llfn(&self, idx: AttributePlace, llfn: ValueRef) {\n+        let mut regular = self.regular;\n         unsafe {\n-            self.regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));\n-            if self.dereferenceable_bytes != 0 {\n-                llvm::LLVMRustAddDereferenceableAttr(llfn,\n-                                                     idx.as_uint(),\n-                                                     self.dereferenceable_bytes);\n+            let deref = self.pointee_size.bytes();\n+            if deref != 0 {\n+                if regular.contains(ArgAttribute::NonNull) {\n+                    llvm::LLVMRustAddDereferenceableAttr(llfn,\n+                                                         idx.as_uint(),\n+                                                         deref);\n+                } else {\n+                    llvm::LLVMRustAddDereferenceableOrNullAttr(llfn,\n+                                                               idx.as_uint(),\n+                                                               deref);\n+                }\n+                regular -= ArgAttribute::NonNull;\n             }\n+            if let Some(align) = self.pointee_align {\n+                llvm::LLVMRustAddAlignmentAttr(llfn,\n+                                               idx.as_uint(),\n+                                               align.abi() as u32);\n+            }\n+            regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));\n         }\n     }\n \n     pub fn apply_callsite(&self, idx: AttributePlace, callsite: ValueRef) {\n+        let mut regular = self.regular;\n         unsafe {\n-            self.regular.for_each_kind(|attr| attr.apply_callsite(idx, callsite));\n-            if self.dereferenceable_bytes != 0 {\n-                llvm::LLVMRustAddDereferenceableCallSiteAttr(callsite,\n-                                                             idx.as_uint(),\n-                                                             self.dereferenceable_bytes);\n+            let deref = self.pointee_size.bytes();\n+            if deref != 0 {\n+                if regular.contains(ArgAttribute::NonNull) {\n+                    llvm::LLVMRustAddDereferenceableCallSiteAttr(callsite,\n+                                                                 idx.as_uint(),\n+                                                                 deref);\n+                } else {\n+                    llvm::LLVMRustAddDereferenceableOrNullCallSiteAttr(callsite,\n+                                                                       idx.as_uint(),\n+                                                                       deref);\n+                }\n+                regular -= ArgAttribute::NonNull;\n+            }\n+            if let Some(align) = self.pointee_align {\n+                llvm::LLVMRustAddAlignmentCallSiteAttr(callsite,\n+                                                       idx.as_uint(),\n+                                                       align.abi() as u32);\n             }\n+            regular.for_each_kind(|attr| attr.apply_callsite(idx, callsite));\n         }\n     }\n }\n@@ -439,12 +471,20 @@ pub struct ArgType<'tcx> {\n \n impl<'a, 'tcx> ArgType<'tcx> {\n     fn new(layout: TyLayout<'tcx>) -> ArgType<'tcx> {\n+        let mut attrs = ArgAttributes::new();\n+\n+        if let layout::Abi::Scalar(ref scalar) = layout.abi {\n+            if scalar.is_bool() {\n+                attrs.set(ArgAttribute::ZExt);\n+            }\n+        }\n+\n         ArgType {\n             kind: ArgKind::Direct,\n             layout,\n             cast: None,\n             pad: None,\n-            attrs: ArgAttributes::default(),\n+            attrs,\n             nested: vec![]\n         }\n     }\n@@ -454,14 +494,16 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         assert_eq!(self.kind, ArgKind::Direct);\n \n         // Wipe old attributes, likely not valid through indirection.\n-        self.attrs = ArgAttributes::default();\n+        self.attrs = ArgAttributes::new();\n \n         // For non-immediate arguments the callee gets its own copy of\n         // the value on the stack, so there are no aliases. It's also\n         // program-invisible so can't possibly capture\n         self.attrs.set(ArgAttribute::NoAlias)\n                   .set(ArgAttribute::NoCapture)\n-                  .set_dereferenceable(self.layout.size);\n+                  .set(ArgAttribute::NonNull);\n+        self.attrs.pointee_size = self.layout.size;\n+        self.attrs.pointee_align = Some(self.layout.align);\n \n         self.kind = ArgKind::Indirect;\n     }\n@@ -472,6 +514,22 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         self.kind = ArgKind::Ignore;\n     }\n \n+    fn safe_pointee(&mut self, layout: TyLayout) {\n+        match self.layout.abi {\n+            layout::Abi::Scalar(layout::Scalar {\n+                value: layout::Pointer,\n+                ref valid_range\n+            }) => {\n+                if valid_range.start > 0 {\n+                    self.attrs.set(ArgAttribute::NonNull);\n+                }\n+                self.attrs.pointee_size = layout.size;\n+                self.attrs.pointee_align = Some(layout.align);\n+            }\n+            _ => bug!(\"ArgType::safe_pointee({:#?}): not a pointer\", self.layout)\n+        }\n+    }\n+\n     pub fn extend_integer_width_to(&mut self, bits: u64) {\n         // Only integers have signedness\n         if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n@@ -694,123 +752,115 @@ impl<'a, 'tcx> FnType<'tcx> {\n             _ => false\n         };\n \n-        let arg_of = |ty: Ty<'tcx>, is_return: bool| {\n-            let mut arg = ArgType::new(ccx.layout_of(ty));\n-            if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n-                if scalar.is_bool() {\n-                    arg.attrs.set(ArgAttribute::ZExt);\n-                }\n-            }\n-            if arg.layout.is_zst() {\n-                // For some forsaken reason, x86_64-pc-windows-gnu\n-                // doesn't ignore zero-sized struct arguments.\n-                // The same is true for s390x-unknown-linux-gnu.\n-                if is_return || rust_abi ||\n-                    (!win_x64_gnu && !linux_s390x) {\n-                    arg.ignore();\n-                }\n-            }\n-            arg\n-        };\n-\n-        let ret_ty = sig.output();\n-        let mut ret = arg_of(ret_ty, true);\n-\n-        if !type_is_fat_ptr(ccx, ret_ty) {\n-            // The `noalias` attribute on the return value is useful to a\n-            // function ptr caller.\n-            if ret_ty.is_box() {\n-                // `Box` pointer return values never alias because ownership\n-                // is transferred\n-                ret.attrs.set(ArgAttribute::NoAlias);\n+        // Handle safe Rust thin and fat pointers.\n+        let adjust_for_rust_type = |arg: &mut ArgType<'tcx>, is_return: bool| {\n+            // We only handle thin pointers here.\n+            match arg.layout.abi {\n+                layout::Abi::Scalar(layout::Scalar { value: layout::Pointer, .. }) => {}\n+                _ => return\n             }\n \n-            // We can also mark the return value as `dereferenceable` in certain cases\n-            match ret_ty.sty {\n-                // These are not really pointers but pairs, (pointer, len)\n-                ty::TyRef(_, ty::TypeAndMut { ty, .. }) => {\n-                    ret.attrs.set_dereferenceable(ccx.size_of(ty));\n-                }\n-                ty::TyAdt(def, _) if def.is_box() => {\n-                    ret.attrs.set_dereferenceable(ccx.size_of(ret_ty.boxed_ty()));\n+            let mut ty = arg.layout.ty;\n+\n+            // FIXME(eddyb) detect more nested cases than `Option<&T>` here.\n+            match arg.layout.variants {\n+                layout::Variants::NicheFilling { dataful_variant, .. } => {\n+                    let variant = arg.layout.for_variant(ccx, dataful_variant);\n+                    for i in 0..variant.fields.count() {\n+                        let field = variant.field(ccx, i);\n+                        match field.abi {\n+                            layout::Abi::Scalar(layout::Scalar { value: layout::Pointer, .. }) => {\n+                                // We found the pointer field, use its type.\n+                                ty = field.ty;\n+                                break;\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n                 }\n                 _ => {}\n             }\n-        }\n \n-        let mut args = Vec::with_capacity(inputs.len() + extra_args.len());\n+            match ty.sty {\n+                // `Box` pointer parameters never alias because ownership is transferred\n+                ty::TyAdt(def, _) if def.is_box() => {\n+                    arg.attrs.set(ArgAttribute::NoAlias);\n \n-        // Handle safe Rust thin and fat pointers.\n-        let rust_ptr_attrs = |ty: Ty<'tcx>, arg: &mut ArgType| match ty.sty {\n-            // `Box` pointer parameters never alias because ownership is transferred\n-            ty::TyAdt(def, _) if def.is_box() => {\n-                arg.attrs.set(ArgAttribute::NoAlias);\n-                Some(ty.boxed_ty())\n-            }\n+                    arg.safe_pointee(ccx.layout_of(ty.boxed_ty()));\n+                }\n \n-            ty::TyRef(_, mt) => {\n-                // `&mut` pointer parameters never alias other parameters, or mutable global data\n-                //\n-                // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as\n-                // both `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely\n-                // on memory dependencies rather than pointer equality\n-                let is_freeze = ccx.shared().type_is_freeze(mt.ty);\n-\n-                let no_alias_is_safe =\n-                    if ccx.shared().tcx().sess.opts.debugging_opts.mutable_noalias ||\n-                       ccx.shared().tcx().sess.panic_strategy() == PanicStrategy::Abort {\n-                        // Mutable refrences or immutable shared references\n-                        mt.mutbl == hir::MutMutable || is_freeze\n-                    } else {\n-                        // Only immutable shared references\n-                        mt.mutbl != hir::MutMutable && is_freeze\n-                    };\n+                ty::TyRef(_, mt) => {\n+                    // `&mut` pointer parameters never alias other parameters,\n+                    // or mutable global data\n+                    //\n+                    // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n+                    // and can be marked as both `readonly` and `noalias`, as\n+                    // LLVM's definition of `noalias` is based solely on memory\n+                    // dependencies rather than pointer equality\n+                    let is_freeze = ccx.shared().type_is_freeze(mt.ty);\n+\n+                    let no_alias_is_safe =\n+                        if ccx.shared().tcx().sess.opts.debugging_opts.mutable_noalias ||\n+                           ccx.shared().tcx().sess.panic_strategy() == PanicStrategy::Abort {\n+                            // Mutable refrences or immutable shared references\n+                            mt.mutbl == hir::MutMutable || is_freeze\n+                        } else {\n+                            // Only immutable shared references\n+                            mt.mutbl != hir::MutMutable && is_freeze\n+                        };\n \n-                if no_alias_is_safe {\n-                    arg.attrs.set(ArgAttribute::NoAlias);\n-                }\n+                    if no_alias_is_safe {\n+                        arg.attrs.set(ArgAttribute::NoAlias);\n+                    }\n \n-                if mt.mutbl == hir::MutImmutable && is_freeze {\n-                    arg.attrs.set(ArgAttribute::ReadOnly);\n+                    if mt.mutbl == hir::MutImmutable && is_freeze && !is_return {\n+                        arg.attrs.set(ArgAttribute::ReadOnly);\n+                    }\n+\n+                    arg.safe_pointee(ccx.layout_of(mt.ty));\n                 }\n+                _ => {}\n+            }\n \n-                Some(mt.ty)\n+            // HACK(eddyb) LLVM inserts `llvm.assume` calls when inlining functions\n+            // with align attributes, and those calls later block optimizations.\n+            if !is_return {\n+                arg.attrs.pointee_align = None;\n             }\n-            _ => None\n         };\n \n-        for ty in inputs.iter().chain(extra_args.iter()) {\n-            let mut arg = arg_of(ty, false);\n-\n-            if type_is_fat_ptr(ccx, ty) {\n-                let mut data = ArgType::new(arg.layout.field(ccx, 0));\n-                let mut info = ArgType::new(arg.layout.field(ccx, 1));\n-\n-                if let Some(inner) = rust_ptr_attrs(ty, &mut data) {\n-                    data.attrs.set(ArgAttribute::NonNull);\n-                    if ccx.tcx().struct_tail(inner).is_trait() {\n-                        // vtables can be safely marked non-null, readonly\n-                        // and noalias.\n-                        info.attrs.set(ArgAttribute::NonNull);\n-                        info.attrs.set(ArgAttribute::ReadOnly);\n-                        info.attrs.set(ArgAttribute::NoAlias);\n-                    }\n-                }\n-                // FIXME(eddyb) other ABIs don't have logic for nested.\n-                if rust_abi {\n-                    arg.nested = vec![data, info];\n+        let arg_of = |ty: Ty<'tcx>, is_return: bool| {\n+            let mut arg = ArgType::new(ccx.layout_of(ty));\n+            if arg.layout.is_zst() {\n+                // For some forsaken reason, x86_64-pc-windows-gnu\n+                // doesn't ignore zero-sized struct arguments.\n+                // The same is true for s390x-unknown-linux-gnu.\n+                if is_return || rust_abi ||\n+                    (!win_x64_gnu && !linux_s390x) {\n+                    arg.ignore();\n                 }\n+            }\n+\n+            // FIXME(eddyb) other ABIs don't have logic for nested.\n+            if !is_return && type_is_fat_ptr(ccx, arg.layout.ty) && rust_abi {\n+                arg.nested = vec![\n+                    ArgType::new(arg.layout.field(ccx, 0)),\n+                    ArgType::new(arg.layout.field(ccx, 1))\n+                ];\n+                adjust_for_rust_type(&mut arg.nested[0], false);\n+                adjust_for_rust_type(&mut arg.nested[1], false);\n             } else {\n-                if let Some(inner) = rust_ptr_attrs(ty, &mut arg) {\n-                    arg.attrs.set_dereferenceable(ccx.size_of(inner));\n-                }\n+                adjust_for_rust_type(&mut arg, is_return);\n             }\n-            args.push(arg);\n-        }\n+\n+            arg\n+        };\n \n         FnType {\n-            args,\n-            ret,\n+            ret: arg_of(sig.output(), true),\n+            args: inputs.iter().chain(extra_args.iter()).map(|ty| {\n+                arg_of(ty, false)\n+            }).collect(),\n             variadic: sig.variadic,\n             cconv,\n         }"}, {"sha": "9aa172591b86f7410d7c030d303c89ce13bdf891", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f8d5d0c30c32c20163e45c3c1521add198b63afc/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f8d5d0c30c32c20163e45c3c1521add198b63afc/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=f8d5d0c30c32c20163e45c3c1521add198b63afc", "patch": "@@ -178,6 +178,22 @@ extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned Index,\n #endif\n }\n \n+extern \"C\" void LLVMRustAddAlignmentCallSiteAttr(LLVMValueRef Instr,\n+                                                 unsigned Index,\n+                                                 uint32_t Bytes) {\n+  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  AttrBuilder B;\n+  B.addAlignmentAttr(Bytes);\n+#if LLVM_VERSION_GE(5, 0)\n+  Call.setAttributes(Call.getAttributes().addAttributes(\n+      Call->getContext(), Index, B));\n+#else\n+  Call.setAttributes(Call.getAttributes().addAttributes(\n+      Call->getContext(), Index,\n+      AttributeSet::get(Call->getContext(), Index, B)));\n+#endif\n+}\n+\n extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n                                                        unsigned Index,\n                                                        uint64_t Bytes) {\n@@ -194,6 +210,22 @@ extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n #endif\n }\n \n+extern \"C\" void LLVMRustAddDereferenceableOrNullCallSiteAttr(LLVMValueRef Instr,\n+                                                             unsigned Index,\n+                                                             uint64_t Bytes) {\n+  CallSite Call = CallSite(unwrap<Instruction>(Instr));\n+  AttrBuilder B;\n+  B.addDereferenceableOrNullAttr(Bytes);\n+#if LLVM_VERSION_GE(5, 0)\n+  Call.setAttributes(Call.getAttributes().addAttributes(\n+      Call->getContext(), Index, B));\n+#else\n+  Call.setAttributes(Call.getAttributes().addAttributes(\n+      Call->getContext(), Index,\n+      AttributeSet::get(Call->getContext(), Index, B)));\n+#endif\n+}\n+\n extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn, unsigned Index,\n                                              LLVMRustAttribute RustAttr) {\n   Function *A = unwrap<Function>(Fn);\n@@ -206,6 +238,19 @@ extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn, unsigned Index,\n #endif\n }\n \n+extern \"C\" void LLVMRustAddAlignmentAttr(LLVMValueRef Fn,\n+                                         unsigned Index,\n+                                         uint32_t Bytes) {\n+  Function *A = unwrap<Function>(Fn);\n+  AttrBuilder B;\n+  B.addAlignmentAttr(Bytes);\n+#if LLVM_VERSION_GE(5, 0)\n+  A->addAttributes(Index, B);\n+#else\n+  A->addAttributes(Index, AttributeSet::get(A->getContext(), Index, B));\n+#endif\n+}\n+\n extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn, unsigned Index,\n                                                uint64_t Bytes) {\n   Function *A = unwrap<Function>(Fn);\n@@ -218,6 +263,19 @@ extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn, unsigned Index,\n #endif\n }\n \n+extern \"C\" void LLVMRustAddDereferenceableOrNullAttr(LLVMValueRef Fn,\n+                                                     unsigned Index,\n+                                                     uint64_t Bytes) {\n+  Function *A = unwrap<Function>(Fn);\n+  AttrBuilder B;\n+  B.addDereferenceableOrNullAttr(Bytes);\n+#if LLVM_VERSION_GE(5, 0)\n+  A->addAttributes(Index, B);\n+#else\n+  A->addAttributes(Index, AttributeSet::get(A->getContext(), Index, B));\n+#endif\n+}\n+\n extern \"C\" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,\n                                                    unsigned Index,\n                                                    const char *Name,"}, {"sha": "6cb1972afa52fd57f347a3edd18c779d2f51be8d", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f8d5d0c30c32c20163e45c3c1521add198b63afc/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d5d0c30c32c20163e45c3c1521add198b63afc/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=f8d5d0c30c32c20163e45c3c1521add198b63afc", "patch": "@@ -15,7 +15,7 @@\n #![feature(custom_attribute)]\n \n pub struct S {\n-  _field: [i64; 4],\n+  _field: [i32; 8],\n }\n \n pub struct UnsafeInner {\n@@ -66,7 +66,7 @@ pub fn mutable_unsafe_borrow(_: &mut UnsafeInner) {\n pub fn mutable_borrow(_: &mut i32) {\n }\n \n-// CHECK: @indirect_struct(%S* noalias nocapture dereferenceable(32) %arg0)\n+// CHECK: @indirect_struct(%S* noalias nocapture align 4 dereferenceable(32) %arg0)\n #[no_mangle]\n pub fn indirect_struct(_: S) {\n }\n@@ -77,17 +77,17 @@ pub fn indirect_struct(_: S) {\n pub fn borrowed_struct(_: &S) {\n }\n \n-// CHECK: noalias dereferenceable(4) i32* @_box(i32* noalias dereferenceable(4) %x)\n+// CHECK: noalias align 4 dereferenceable(4) i32* @_box(i32* noalias dereferenceable(4) %x)\n #[no_mangle]\n pub fn _box(x: Box<i32>) -> Box<i32> {\n   x\n }\n \n-// CHECK: @struct_return(%S* noalias nocapture sret dereferenceable(32))\n+// CHECK: @struct_return(%S* noalias nocapture sret align 4 dereferenceable(32))\n #[no_mangle]\n pub fn struct_return() -> S {\n   S {\n-    _field: [0, 0, 0, 0]\n+    _field: [0, 0, 0, 0, 0, 0, 0, 0]\n   }\n }\n "}, {"sha": "87cf042f27e940402200beea887140e575b7804a", "filename": "src/test/codegen/packed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8d5d0c30c32c20163e45c3c1521add198b63afc/src%2Ftest%2Fcodegen%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d5d0c30c32c20163e45c3c1521add198b63afc/src%2Ftest%2Fcodegen%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpacked.rs?ref=f8d5d0c30c32c20163e45c3c1521add198b63afc", "patch": "@@ -39,7 +39,7 @@ pub struct BigPacked {\n #[no_mangle]\n pub fn call_pkd(f: fn() -> Array) -> BigPacked {\n // CHECK: [[ALLOCA:%[_a-z0-9]+]] = alloca %Array\n-// CHECK: call void %{{.*}}(%Array* noalias nocapture sret dereferenceable(32) [[ALLOCA]])\n+// CHECK: call void %{{.*}}(%Array* noalias nocapture sret align 4 dereferenceable(32) [[ALLOCA]])\n // CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{.*}}, i8* %{{.*}}, i{{[0-9]+}} 32, i32 1, i1 false)\n     // check that calls whose destination is a field of a packed struct\n     // go through an alloca rather than calling the function with an"}]}