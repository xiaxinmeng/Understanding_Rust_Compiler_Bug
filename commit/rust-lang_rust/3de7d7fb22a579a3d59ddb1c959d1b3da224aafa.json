{"sha": "3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "node_id": "C_kwDOAAsO6NoAKDNkZTdkN2ZiMjJhNTc5YTNkNTlkZGIxYzk1OWQxYjNkYTIyNGFhZmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-04T18:11:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-04T18:11:02Z"}, "message": "Auto merge of #107549 - Zoxc:rustc-shared, r=jyn514\n\nMove code in `rustc_driver` out to a new `rustc_driver_impl` crate to allow pipelining\n\nThat adds a `rustc_shared` library which contains all the rustc library crates in a single dylib. It takes over this role from `rustc_driver`. This is done so that `rustc_driver` can be compiled in parallel with other crates. `rustc_shared` is intentionally left empty so it only does linking.\n\nAn alternative could be to move the code currently in `rustc_driver` into a new crate to avoid changing the name of the distributed library.", "tree": {"sha": "0d3e9447ea00657b717fbba42f6a854bc0b95355", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d3e9447ea00657b717fbba42f6a854bc0b95355"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "html_url": "https://github.com/rust-lang/rust/commit/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9dee4e4c42d23b0c5afd6d8fed025181f70fbe12", "url": "https://api.github.com/repos/rust-lang/rust/commits/9dee4e4c42d23b0c5afd6d8fed025181f70fbe12", "html_url": "https://github.com/rust-lang/rust/commit/9dee4e4c42d23b0c5afd6d8fed025181f70fbe12"}, {"sha": "2b8f8922ee5852f97e92082b209c0f4d940a6edb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b8f8922ee5852f97e92082b209c0f4d940a6edb", "html_url": "https://github.com/rust-lang/rust/commit/2b8f8922ee5852f97e92082b209c0f4d940a6edb"}], "stats": {"total": 2852, "additions": 1437, "deletions": 1415}, "files": [{"sha": "705210e44b24c5f67e39747bfacbae2ce1deceb6", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "patch": "@@ -3567,6 +3567,7 @@ dependencies = [\n  \"jemalloc-sys\",\n  \"rustc_codegen_ssa\",\n  \"rustc_driver\",\n+ \"rustc_driver_impl\",\n  \"rustc_smir\",\n ]\n \n@@ -3946,6 +3947,13 @@ dependencies = [\n [[package]]\n name = \"rustc_driver\"\n version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_driver_impl\",\n+]\n+\n+[[package]]\n+name = \"rustc_driver_impl\"\n+version = \"0.0.0\"\n dependencies = [\n  \"libc\",\n  \"rustc_ast\","}, {"sha": "41003ad83f31152956dce55a9feb2623f6b4fcc9", "filename": "compiler/rustc/Cargo.toml", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2FCargo.toml?ref=3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "patch": "@@ -5,6 +5,7 @@ edition = \"2021\"\n \n [dependencies]\n rustc_driver = { path = \"../rustc_driver\" }\n+rustc_driver_impl = { path = \"../rustc_driver_impl\" }\n \n # Make sure rustc_codegen_ssa ends up in the sysroot, because this\n # crate is intended to be used by codegen backends, which may not be in-tree.\n@@ -20,6 +21,6 @@ features = ['unprefixed_malloc_on_supported_platforms']\n \n [features]\n jemalloc = ['jemalloc-sys']\n-llvm = ['rustc_driver/llvm']\n-max_level_info = ['rustc_driver/max_level_info']\n-rustc_use_parallel_compiler = ['rustc_driver/rustc_use_parallel_compiler']\n+llvm = ['rustc_driver_impl/llvm']\n+max_level_info = ['rustc_driver_impl/max_level_info']\n+rustc_use_parallel_compiler = ['rustc_driver_impl/rustc_use_parallel_compiler']"}, {"sha": "d7c295418ba6d6d04688b046d494d9b12880b8c4", "filename": "compiler/rustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FCargo.toml?ref=3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "patch": "@@ -7,39 +7,4 @@ edition = \"2021\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-tracing = { version = \"0.1.35\" }\n-serde_json = \"1.0.59\"\n-rustc_log = { path = \"../rustc_log\" }\n-rustc_middle = { path = \"../rustc_middle\" }\n-rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n-rustc_target = { path = \"../rustc_target\" }\n-rustc_lint = { path = \"../rustc_lint\" }\n-rustc_data_structures = { path = \"../rustc_data_structures\" }\n-rustc_errors = { path = \"../rustc_errors\" }\n-rustc_feature = { path = \"../rustc_feature\" }\n-rustc_hir = { path = \"../rustc_hir\" }\n-rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n-rustc_macros = { path = \"../rustc_macros\" }\n-rustc_metadata = { path = \"../rustc_metadata\" }\n-rustc_parse = { path = \"../rustc_parse\" }\n-rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }\n-rustc_save_analysis = { path = \"../rustc_save_analysis\" }\n-rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n-rustc_session = { path = \"../rustc_session\" }\n-rustc_error_codes = { path = \"../rustc_error_codes\" }\n-rustc_interface = { path = \"../rustc_interface\" }\n-rustc_ast = { path = \"../rustc_ast\" }\n-rustc_span = { path = \"../rustc_span\" }\n-rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n-\n-[target.'cfg(unix)'.dependencies]\n-libc = \"0.2\"\n-\n-[target.'cfg(windows)'.dependencies]\n-winapi = { version = \"0.3\", features = [\"consoleapi\", \"debugapi\", \"processenv\"] }\n-\n-[features]\n-llvm = ['rustc_interface/llvm']\n-max_level_info = ['rustc_log/max_level_info']\n-rustc_use_parallel_compiler = ['rustc_data_structures/rustc_use_parallel_compiler', 'rustc_interface/rustc_use_parallel_compiler',\n-    'rustc_middle/rustc_use_parallel_compiler']\n+rustc_driver_impl = { path = \"../rustc_driver_impl\" }"}, {"sha": "4eabba575f42a425ef264e2d177e9178c9848af7", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1352, "changes": 1355, "blob_url": "https://github.com/rust-lang/rust/blob/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "patch": "@@ -1,1353 +1,4 @@\n-//! The Rust compiler.\n-//!\n-//! # Note\n-//!\n-//! This API is completely unstable and subject to change.\n+// This crate is intentionally empty and a rexport of `rustc_driver_impl` to allow the code in\n+// `rustc_driver_impl` to be compiled in parallel with other crates.\n \n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(is_terminal)]\n-#![feature(once_cell)]\n-#![feature(decl_macro)]\n-#![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n-#![deny(rustc::untranslatable_diagnostic)]\n-#![deny(rustc::diagnostic_outside_of_impl)]\n-\n-#[macro_use]\n-extern crate tracing;\n-\n-pub extern crate rustc_plugin_impl as plugin;\n-\n-use rustc_ast as ast;\n-use rustc_codegen_ssa::{traits::CodegenBackend, CodegenErrors, CodegenResults};\n-use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n-use rustc_data_structures::sync::SeqCst;\n-use rustc_errors::registry::{InvalidErrorCode, Registry};\n-use rustc_errors::{ErrorGuaranteed, PResult};\n-use rustc_feature::find_gated_cfg;\n-use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_interface::util::{self, collect_crate_types, get_codegen_backend};\n-use rustc_interface::{interface, Queries};\n-use rustc_lint::LintStore;\n-use rustc_metadata::locator;\n-use rustc_save_analysis as save;\n-use rustc_save_analysis::DumpHandler;\n-use rustc_session::config::{nightly_options, CG_OPTIONS, Z_OPTIONS};\n-use rustc_session::config::{ErrorOutputType, Input, OutputType, PrintRequest, TrimmedDefPaths};\n-use rustc_session::cstore::MetadataLoader;\n-use rustc_session::getopts;\n-use rustc_session::lint::{Lint, LintId};\n-use rustc_session::{config, Session};\n-use rustc_session::{early_error, early_error_no_abort, early_warn};\n-use rustc_span::source_map::{FileLoader, FileName};\n-use rustc_span::symbol::sym;\n-use rustc_target::json::ToJson;\n-\n-use std::cmp::max;\n-use std::env;\n-use std::ffi::OsString;\n-use std::fs;\n-use std::io::{self, IsTerminal, Read, Write};\n-use std::panic::{self, catch_unwind};\n-use std::path::PathBuf;\n-use std::process::{self, Command, Stdio};\n-use std::str;\n-use std::sync::LazyLock;\n-use std::time::Instant;\n-\n-pub mod args;\n-pub mod pretty;\n-mod session_diagnostics;\n-\n-use crate::session_diagnostics::{\n-    RLinkEmptyVersionNumber, RLinkEncodingVersionMismatch, RLinkRustcVersionMismatch,\n-    RLinkWrongFileType, RlinkNotAFile, RlinkUnableToRead,\n-};\n-\n-/// Exit status code used for successful compilation and help output.\n-pub const EXIT_SUCCESS: i32 = 0;\n-\n-/// Exit status code used for compilation failures and invalid flags.\n-pub const EXIT_FAILURE: i32 = 1;\n-\n-const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust/issues/new\\\n-    ?labels=C-bug%2C+I-ICE%2C+T-compiler&template=ice.md\";\n-\n-const ICE_REPORT_COMPILER_FLAGS: &[&str] = &[\"-Z\", \"-C\", \"--crate-type\"];\n-\n-const ICE_REPORT_COMPILER_FLAGS_EXCLUDE: &[&str] = &[\"metadata\", \"extra-filename\"];\n-\n-const ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE: &[&str] = &[\"incremental\"];\n-\n-pub fn abort_on_err<T>(result: Result<T, ErrorGuaranteed>, sess: &Session) -> T {\n-    match result {\n-        Err(..) => {\n-            sess.abort_if_errors();\n-            panic!(\"error reported but abort_if_errors didn't abort???\");\n-        }\n-        Ok(x) => x,\n-    }\n-}\n-\n-pub trait Callbacks {\n-    /// Called before creating the compiler instance\n-    fn config(&mut self, _config: &mut interface::Config) {}\n-    /// Called after parsing. Return value instructs the compiler whether to\n-    /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n-    fn after_parsing<'tcx>(\n-        &mut self,\n-        _compiler: &interface::Compiler,\n-        _queries: &'tcx Queries<'tcx>,\n-    ) -> Compilation {\n-        Compilation::Continue\n-    }\n-    /// Called after expansion. Return value instructs the compiler whether to\n-    /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n-    fn after_expansion<'tcx>(\n-        &mut self,\n-        _compiler: &interface::Compiler,\n-        _queries: &'tcx Queries<'tcx>,\n-    ) -> Compilation {\n-        Compilation::Continue\n-    }\n-    /// Called after analysis. Return value instructs the compiler whether to\n-    /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n-    fn after_analysis<'tcx>(\n-        &mut self,\n-        _compiler: &interface::Compiler,\n-        _queries: &'tcx Queries<'tcx>,\n-    ) -> Compilation {\n-        Compilation::Continue\n-    }\n-}\n-\n-#[derive(Default)]\n-pub struct TimePassesCallbacks {\n-    time_passes: bool,\n-}\n-\n-impl Callbacks for TimePassesCallbacks {\n-    // JUSTIFICATION: the session doesn't exist at this point.\n-    #[allow(rustc::bad_opt_access)]\n-    fn config(&mut self, config: &mut interface::Config) {\n-        // If a --print=... option has been given, we don't print the \"total\"\n-        // time because it will mess up the --print output. See #64339.\n-        //\n-        self.time_passes = config.opts.prints.is_empty() && config.opts.unstable_opts.time_passes;\n-        config.opts.trimmed_def_paths = TrimmedDefPaths::GoodPath;\n-    }\n-}\n-\n-pub fn diagnostics_registry() -> Registry {\n-    Registry::new(rustc_error_codes::DIAGNOSTICS)\n-}\n-\n-/// This is the primary entry point for rustc.\n-pub struct RunCompiler<'a, 'b> {\n-    at_args: &'a [String],\n-    callbacks: &'b mut (dyn Callbacks + Send),\n-    file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n-    make_codegen_backend:\n-        Option<Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>>,\n-}\n-\n-impl<'a, 'b> RunCompiler<'a, 'b> {\n-    pub fn new(at_args: &'a [String], callbacks: &'b mut (dyn Callbacks + Send)) -> Self {\n-        Self { at_args, callbacks, file_loader: None, make_codegen_backend: None }\n-    }\n-\n-    /// Set a custom codegen backend.\n-    ///\n-    /// Has no uses within this repository, but is used by bjorn3 for \"the\n-    /// hotswapping branch of cg_clif\" for \"setting the codegen backend from a\n-    /// custom driver where the custom codegen backend has arbitrary data.\"\n-    /// (See #102759.)\n-    pub fn set_make_codegen_backend(\n-        &mut self,\n-        make_codegen_backend: Option<\n-            Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n-        >,\n-    ) -> &mut Self {\n-        self.make_codegen_backend = make_codegen_backend;\n-        self\n-    }\n-\n-    /// Load files from sources other than the file system.\n-    ///\n-    /// Has no uses within this repository, but may be used in the future by\n-    /// bjorn3 for \"hooking rust-analyzer's VFS into rustc at some point for\n-    /// running rustc without having to save\". (See #102759.)\n-    pub fn set_file_loader(\n-        &mut self,\n-        file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n-    ) -> &mut Self {\n-        self.file_loader = file_loader;\n-        self\n-    }\n-\n-    /// Parse args and run the compiler.\n-    pub fn run(self) -> interface::Result<()> {\n-        run_compiler(self.at_args, self.callbacks, self.file_loader, self.make_codegen_backend)\n-    }\n-}\n-\n-fn run_compiler(\n-    at_args: &[String],\n-    callbacks: &mut (dyn Callbacks + Send),\n-    file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n-    make_codegen_backend: Option<\n-        Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n-    >,\n-) -> interface::Result<()> {\n-    let args = args::arg_expand_all(at_args);\n-\n-    let Some(matches) = handle_options(&args) else { return Ok(()) };\n-\n-    let sopts = config::build_session_options(&matches);\n-\n-    if let Some(ref code) = matches.opt_str(\"explain\") {\n-        handle_explain(diagnostics_registry(), code, sopts.error_format);\n-        return Ok(());\n-    }\n-\n-    let cfg = interface::parse_cfgspecs(matches.opt_strs(\"cfg\"));\n-    let check_cfg = interface::parse_check_cfg(matches.opt_strs(\"check-cfg\"));\n-    let (odir, ofile) = make_output(&matches);\n-    let mut config = interface::Config {\n-        opts: sopts,\n-        crate_cfg: cfg,\n-        crate_check_cfg: check_cfg,\n-        input: Input::File(PathBuf::new()),\n-        output_file: ofile,\n-        output_dir: odir,\n-        file_loader,\n-        lint_caps: Default::default(),\n-        parse_sess_created: None,\n-        register_lints: None,\n-        override_queries: None,\n-        make_codegen_backend,\n-        registry: diagnostics_registry(),\n-    };\n-\n-    if !tracing::dispatcher::has_been_set() {\n-        init_rustc_env_logger_with_backtrace_option(&config.opts.unstable_opts.log_backtrace);\n-    }\n-\n-    match make_input(config.opts.error_format, &matches.free) {\n-        Err(reported) => return Err(reported),\n-        Ok(Some(input)) => {\n-            config.input = input;\n-\n-            callbacks.config(&mut config);\n-        }\n-        Ok(None) => match matches.free.len() {\n-            0 => {\n-                callbacks.config(&mut config);\n-                interface::run_compiler(config, |compiler| {\n-                    let sopts = &compiler.session().opts;\n-                    if sopts.describe_lints {\n-                        let mut lint_store =\n-                            rustc_lint::new_lint_store(compiler.session().enable_internal_lints());\n-                        let registered_lints =\n-                            if let Some(register_lints) = compiler.register_lints() {\n-                                register_lints(compiler.session(), &mut lint_store);\n-                                true\n-                            } else {\n-                                false\n-                            };\n-                        describe_lints(compiler.session(), &lint_store, registered_lints);\n-                        return;\n-                    }\n-                    let should_stop =\n-                        print_crate_info(&***compiler.codegen_backend(), compiler.session(), false);\n-\n-                    if should_stop == Compilation::Stop {\n-                        return;\n-                    }\n-                    early_error(sopts.error_format, \"no input filename given\")\n-                });\n-                return Ok(());\n-            }\n-            1 => panic!(\"make_input should have provided valid inputs\"),\n-            _ => early_error(\n-                config.opts.error_format,\n-                &format!(\n-                    \"multiple input filenames provided (first two filenames are `{}` and `{}`)\",\n-                    matches.free[0], matches.free[1],\n-                ),\n-            ),\n-        },\n-    };\n-\n-    interface::run_compiler(config, |compiler| {\n-        let sess = compiler.session();\n-        let should_stop = print_crate_info(&***compiler.codegen_backend(), sess, true)\n-            .and_then(|| list_metadata(sess, &*compiler.codegen_backend().metadata_loader()))\n-            .and_then(|| try_process_rlink(sess, compiler));\n-\n-        if should_stop == Compilation::Stop {\n-            return sess.compile_status();\n-        }\n-\n-        let linker = compiler.enter(|queries| {\n-            let early_exit = || sess.compile_status().map(|_| None);\n-            queries.parse()?;\n-\n-            if let Some(ppm) = &sess.opts.pretty {\n-                if ppm.needs_ast_map() {\n-                    queries.global_ctxt()?.enter(|tcx| {\n-                        pretty::print_after_hir_lowering(tcx, *ppm);\n-                        Ok(())\n-                    })?;\n-                } else {\n-                    let krate = queries.parse()?.steal();\n-                    pretty::print_after_parsing(sess, &krate, *ppm);\n-                }\n-                trace!(\"finished pretty-printing\");\n-                return early_exit();\n-            }\n-\n-            if callbacks.after_parsing(compiler, queries) == Compilation::Stop {\n-                return early_exit();\n-            }\n-\n-            if sess.opts.unstable_opts.parse_only || sess.opts.unstable_opts.show_span.is_some() {\n-                return early_exit();\n-            }\n-\n-            {\n-                let plugins = queries.register_plugins()?;\n-                let (_, lint_store) = &*plugins.borrow();\n-\n-                // Lint plugins are registered; now we can process command line flags.\n-                if sess.opts.describe_lints {\n-                    describe_lints(sess, lint_store, true);\n-                    return early_exit();\n-                }\n-            }\n-\n-            let mut gctxt = queries.global_ctxt()?;\n-            if callbacks.after_expansion(compiler, queries) == Compilation::Stop {\n-                return early_exit();\n-            }\n-\n-            // Make sure the `output_filenames` query is run for its side\n-            // effects of writing the dep-info and reporting errors.\n-            gctxt.enter(|tcx| tcx.output_filenames(()));\n-\n-            if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n-                && sess.opts.output_types.len() == 1\n-            {\n-                return early_exit();\n-            }\n-\n-            if sess.opts.unstable_opts.no_analysis {\n-                return early_exit();\n-            }\n-\n-            gctxt.enter(|tcx| {\n-                let result = tcx.analysis(());\n-                if sess.opts.unstable_opts.save_analysis {\n-                    let crate_name = tcx.crate_name(LOCAL_CRATE);\n-                    sess.time(\"save_analysis\", || {\n-                        save::process_crate(\n-                            tcx,\n-                            crate_name,\n-                            &sess.io.input,\n-                            None,\n-                            DumpHandler::new(sess.io.output_dir.as_deref(), crate_name),\n-                        )\n-                    });\n-                }\n-                result\n-            })?;\n-\n-            drop(gctxt);\n-\n-            if callbacks.after_analysis(compiler, queries) == Compilation::Stop {\n-                return early_exit();\n-            }\n-\n-            queries.ongoing_codegen()?;\n-\n-            if sess.opts.unstable_opts.print_type_sizes {\n-                sess.code_stats.print_type_sizes();\n-            }\n-\n-            let linker = queries.linker()?;\n-            Ok(Some(linker))\n-        })?;\n-\n-        if let Some(linker) = linker {\n-            let _timer = sess.timer(\"link\");\n-            linker.link()?\n-        }\n-\n-        if sess.opts.unstable_opts.perf_stats {\n-            sess.print_perf_stats();\n-        }\n-\n-        if sess.opts.unstable_opts.print_fuel.is_some() {\n-            eprintln!(\n-                \"Fuel used by {}: {}\",\n-                sess.opts.unstable_opts.print_fuel.as_ref().unwrap(),\n-                sess.print_fuel.load(SeqCst)\n-            );\n-        }\n-\n-        Ok(())\n-    })\n-}\n-\n-// Extract output directory and file from matches.\n-fn make_output(matches: &getopts::Matches) -> (Option<PathBuf>, Option<PathBuf>) {\n-    let odir = matches.opt_str(\"out-dir\").map(|o| PathBuf::from(&o));\n-    let ofile = matches.opt_str(\"o\").map(|o| PathBuf::from(&o));\n-    (odir, ofile)\n-}\n-\n-// Extract input (string or file and optional path) from matches.\n-fn make_input(\n-    error_format: ErrorOutputType,\n-    free_matches: &[String],\n-) -> Result<Option<Input>, ErrorGuaranteed> {\n-    if free_matches.len() == 1 {\n-        let ifile = &free_matches[0];\n-        if ifile == \"-\" {\n-            let mut src = String::new();\n-            if io::stdin().read_to_string(&mut src).is_err() {\n-                // Immediately stop compilation if there was an issue reading\n-                // the input (for example if the input stream is not UTF-8).\n-                let reported = early_error_no_abort(\n-                    error_format,\n-                    \"couldn't read from stdin, as it did not contain valid UTF-8\",\n-                );\n-                return Err(reported);\n-            }\n-            if let Ok(path) = env::var(\"UNSTABLE_RUSTDOC_TEST_PATH\") {\n-                let line = env::var(\"UNSTABLE_RUSTDOC_TEST_LINE\").expect(\n-                    \"when UNSTABLE_RUSTDOC_TEST_PATH is set \\\n-                                    UNSTABLE_RUSTDOC_TEST_LINE also needs to be set\",\n-                );\n-                let line = isize::from_str_radix(&line, 10)\n-                    .expect(\"UNSTABLE_RUSTDOC_TEST_LINE needs to be an number\");\n-                let file_name = FileName::doc_test_source_code(PathBuf::from(path), line);\n-                Ok(Some(Input::Str { name: file_name, input: src }))\n-            } else {\n-                Ok(Some(Input::Str { name: FileName::anon_source_code(&src), input: src }))\n-            }\n-        } else {\n-            Ok(Some(Input::File(PathBuf::from(ifile))))\n-        }\n-    } else {\n-        Ok(None)\n-    }\n-}\n-\n-/// Whether to stop or continue compilation.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub enum Compilation {\n-    Stop,\n-    Continue,\n-}\n-\n-impl Compilation {\n-    pub fn and_then<F: FnOnce() -> Compilation>(self, next: F) -> Compilation {\n-        match self {\n-            Compilation::Stop => Compilation::Stop,\n-            Compilation::Continue => next(),\n-        }\n-    }\n-}\n-\n-fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n-    let upper_cased_code = code.to_ascii_uppercase();\n-    let normalised =\n-        if upper_cased_code.starts_with('E') { upper_cased_code } else { format!(\"E{code:0>4}\") };\n-    match registry.try_find_description(&normalised) {\n-        Ok(Some(description)) => {\n-            let mut is_in_code_block = false;\n-            let mut text = String::new();\n-            // Slice off the leading newline and print.\n-            for line in description.lines() {\n-                let indent_level =\n-                    line.find(|c: char| !c.is_whitespace()).unwrap_or_else(|| line.len());\n-                let dedented_line = &line[indent_level..];\n-                if dedented_line.starts_with(\"```\") {\n-                    is_in_code_block = !is_in_code_block;\n-                    text.push_str(&line[..(indent_level + 3)]);\n-                } else if is_in_code_block && dedented_line.starts_with(\"# \") {\n-                    continue;\n-                } else {\n-                    text.push_str(line);\n-                }\n-                text.push('\\n');\n-            }\n-            if io::stdout().is_terminal() {\n-                show_content_with_pager(&text);\n-            } else {\n-                print!(\"{text}\");\n-            }\n-        }\n-        Ok(None) => {\n-            early_error(output, &format!(\"no extended information for {code}\"));\n-        }\n-        Err(InvalidErrorCode) => {\n-            early_error(output, &format!(\"{code} is not a valid error code\"));\n-        }\n-    }\n-}\n-\n-fn show_content_with_pager(content: &str) {\n-    let pager_name = env::var_os(\"PAGER\").unwrap_or_else(|| {\n-        if cfg!(windows) { OsString::from(\"more.com\") } else { OsString::from(\"less\") }\n-    });\n-\n-    let mut fallback_to_println = false;\n-\n-    match Command::new(pager_name).stdin(Stdio::piped()).spawn() {\n-        Ok(mut pager) => {\n-            if let Some(pipe) = pager.stdin.as_mut() {\n-                if pipe.write_all(content.as_bytes()).is_err() {\n-                    fallback_to_println = true;\n-                }\n-            }\n-\n-            if pager.wait().is_err() {\n-                fallback_to_println = true;\n-            }\n-        }\n-        Err(_) => {\n-            fallback_to_println = true;\n-        }\n-    }\n-\n-    // If pager fails for whatever reason, we should still print the content\n-    // to standard output\n-    if fallback_to_println {\n-        print!(\"{content}\");\n-    }\n-}\n-\n-pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Compilation {\n-    if sess.opts.unstable_opts.link_only {\n-        if let Input::File(file) = &sess.io.input {\n-            // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n-            sess.init_crate_types(collect_crate_types(sess, &[]));\n-            let outputs = compiler.build_output_filenames(sess, &[]);\n-            let rlink_data = fs::read(file).unwrap_or_else(|err| {\n-                sess.emit_fatal(RlinkUnableToRead { err });\n-            });\n-            let codegen_results = match CodegenResults::deserialize_rlink(rlink_data) {\n-                Ok(codegen) => codegen,\n-                Err(err) => {\n-                    match err {\n-                        CodegenErrors::WrongFileType => sess.emit_fatal(RLinkWrongFileType),\n-                        CodegenErrors::EmptyVersionNumber => {\n-                            sess.emit_fatal(RLinkEmptyVersionNumber)\n-                        }\n-                        CodegenErrors::EncodingVersionMismatch { version_array, rlink_version } => {\n-                            sess.emit_fatal(RLinkEncodingVersionMismatch {\n-                                version_array,\n-                                rlink_version,\n-                            })\n-                        }\n-                        CodegenErrors::RustcVersionMismatch { rustc_version, current_version } => {\n-                            sess.emit_fatal(RLinkRustcVersionMismatch {\n-                                rustc_version,\n-                                current_version,\n-                            })\n-                        }\n-                    };\n-                }\n-            };\n-            let result = compiler.codegen_backend().link(sess, codegen_results, &outputs);\n-            abort_on_err(result, sess);\n-        } else {\n-            sess.emit_fatal(RlinkNotAFile {})\n-        }\n-        Compilation::Stop\n-    } else {\n-        Compilation::Continue\n-    }\n-}\n-\n-pub fn list_metadata(sess: &Session, metadata_loader: &dyn MetadataLoader) -> Compilation {\n-    if sess.opts.unstable_opts.ls {\n-        match sess.io.input {\n-            Input::File(ref ifile) => {\n-                let path = &(*ifile);\n-                let mut v = Vec::new();\n-                locator::list_file_metadata(&sess.target, path, metadata_loader, &mut v).unwrap();\n-                println!(\"{}\", String::from_utf8(v).unwrap());\n-            }\n-            Input::Str { .. } => {\n-                early_error(ErrorOutputType::default(), \"cannot list metadata for stdin\");\n-            }\n-        }\n-        return Compilation::Stop;\n-    }\n-\n-    Compilation::Continue\n-}\n-\n-fn print_crate_info(\n-    codegen_backend: &dyn CodegenBackend,\n-    sess: &Session,\n-    parse_attrs: bool,\n-) -> Compilation {\n-    use rustc_session::config::PrintRequest::*;\n-    // NativeStaticLibs and LinkArgs are special - printed during linking\n-    // (empty iterator returns true)\n-    if sess.opts.prints.iter().all(|&p| p == NativeStaticLibs || p == LinkArgs) {\n-        return Compilation::Continue;\n-    }\n-\n-    let attrs = if parse_attrs {\n-        let result = parse_crate_attrs(sess);\n-        match result {\n-            Ok(attrs) => Some(attrs),\n-            Err(mut parse_error) => {\n-                parse_error.emit();\n-                return Compilation::Stop;\n-            }\n-        }\n-    } else {\n-        None\n-    };\n-    for req in &sess.opts.prints {\n-        match *req {\n-            TargetList => {\n-                let mut targets = rustc_target::spec::TARGETS.to_vec();\n-                targets.sort_unstable();\n-                println!(\"{}\", targets.join(\"\\n\"));\n-            }\n-            Sysroot => println!(\"{}\", sess.sysroot.display()),\n-            TargetLibdir => println!(\"{}\", sess.target_tlib_path.dir.display()),\n-            TargetSpec => {\n-                println!(\"{}\", serde_json::to_string_pretty(&sess.target.to_json()).unwrap());\n-            }\n-            FileNames | CrateName => {\n-                let attrs = attrs.as_ref().unwrap();\n-                let t_outputs = rustc_interface::util::build_output_filenames(attrs, sess);\n-                let id = rustc_session::output::find_crate_name(sess, attrs);\n-                if *req == PrintRequest::CrateName {\n-                    println!(\"{id}\");\n-                    continue;\n-                }\n-                let crate_types = collect_crate_types(sess, attrs);\n-                for &style in &crate_types {\n-                    let fname =\n-                        rustc_session::output::filename_for_input(sess, style, id, &t_outputs);\n-                    println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n-                }\n-            }\n-            Cfg => {\n-                let mut cfgs = sess\n-                    .parse_sess\n-                    .config\n-                    .iter()\n-                    .filter_map(|&(name, value)| {\n-                        // Note that crt-static is a specially recognized cfg\n-                        // directive that's printed out here as part of\n-                        // rust-lang/rust#37406, but in general the\n-                        // `target_feature` cfg is gated under\n-                        // rust-lang/rust#29717. For now this is just\n-                        // specifically allowing the crt-static cfg and that's\n-                        // it, this is intended to get into Cargo and then go\n-                        // through to build scripts.\n-                        if (name != sym::target_feature || value != Some(sym::crt_dash_static))\n-                            && !sess.is_nightly_build()\n-                            && find_gated_cfg(|cfg_sym| cfg_sym == name).is_some()\n-                        {\n-                            return None;\n-                        }\n-\n-                        if let Some(value) = value {\n-                            Some(format!(\"{name}=\\\"{value}\\\"\"))\n-                        } else {\n-                            Some(name.to_string())\n-                        }\n-                    })\n-                    .collect::<Vec<String>>();\n-\n-                cfgs.sort();\n-                for cfg in cfgs {\n-                    println!(\"{cfg}\");\n-                }\n-            }\n-            CallingConventions => {\n-                let mut calling_conventions = rustc_target::spec::abi::all_names();\n-                calling_conventions.sort_unstable();\n-                println!(\"{}\", calling_conventions.join(\"\\n\"));\n-            }\n-            RelocationModels\n-            | CodeModels\n-            | TlsModels\n-            | TargetCPUs\n-            | StackProtectorStrategies\n-            | TargetFeatures => {\n-                codegen_backend.print(*req, sess);\n-            }\n-            // Any output here interferes with Cargo's parsing of other printed output\n-            NativeStaticLibs => {}\n-            LinkArgs => {}\n-            SplitDebuginfo => {\n-                use rustc_target::spec::SplitDebuginfo::{Off, Packed, Unpacked};\n-\n-                for split in &[Off, Packed, Unpacked] {\n-                    let stable = sess.target.options.supported_split_debuginfo.contains(split);\n-                    let unstable_ok = sess.unstable_options();\n-                    if stable || unstable_ok {\n-                        println!(\"{split}\");\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    Compilation::Stop\n-}\n-\n-/// Prints version information\n-///\n-/// NOTE: this is a macro to support drivers built at a different time than the main `rustc_driver` crate.\n-pub macro version($binary: literal, $matches: expr) {\n-    fn unw(x: Option<&str>) -> &str {\n-        x.unwrap_or(\"unknown\")\n-    }\n-    $crate::version_at_macro_invocation(\n-        $binary,\n-        $matches,\n-        unw(option_env!(\"CFG_VERSION\")),\n-        unw(option_env!(\"CFG_VER_HASH\")),\n-        unw(option_env!(\"CFG_VER_DATE\")),\n-        unw(option_env!(\"CFG_RELEASE\")),\n-    )\n-}\n-\n-#[doc(hidden)] // use the macro instead\n-pub fn version_at_macro_invocation(\n-    binary: &str,\n-    matches: &getopts::Matches,\n-    version: &str,\n-    commit_hash: &str,\n-    commit_date: &str,\n-    release: &str,\n-) {\n-    let verbose = matches.opt_present(\"verbose\");\n-\n-    println!(\"{binary} {version}\");\n-\n-    if verbose {\n-        println!(\"binary: {binary}\");\n-        println!(\"commit-hash: {commit_hash}\");\n-        println!(\"commit-date: {commit_date}\");\n-        println!(\"host: {}\", config::host_triple());\n-        println!(\"release: {release}\");\n-\n-        let debug_flags = matches.opt_strs(\"Z\");\n-        let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n-        get_codegen_backend(&None, backend_name).print_version();\n-    }\n-}\n-\n-fn usage(verbose: bool, include_unstable_options: bool, nightly_build: bool) {\n-    let groups = if verbose { config::rustc_optgroups() } else { config::rustc_short_optgroups() };\n-    let mut options = getopts::Options::new();\n-    for option in groups.iter().filter(|x| include_unstable_options || x.is_stable()) {\n-        (option.apply)(&mut options);\n-    }\n-    let message = \"Usage: rustc [OPTIONS] INPUT\";\n-    let nightly_help = if nightly_build {\n-        \"\\n    -Z help             Print unstable compiler options\"\n-    } else {\n-        \"\"\n-    };\n-    let verbose_help = if verbose {\n-        \"\"\n-    } else {\n-        \"\\n    --help -v           Print the full set of options rustc accepts\"\n-    };\n-    let at_path = if verbose {\n-        \"    @path               Read newline separated options from `path`\\n\"\n-    } else {\n-        \"\"\n-    };\n-    println!(\n-        \"{options}{at_path}\\nAdditional help:\n-    -C help             Print codegen options\n-    -W help             \\\n-              Print 'lint' options and default settings{nightly}{verbose}\\n\",\n-        options = options.usage(message),\n-        at_path = at_path,\n-        nightly = nightly_help,\n-        verbose = verbose_help\n-    );\n-}\n-\n-fn print_wall_help() {\n-    println!(\n-        \"\n-The flag `-Wall` does not exist in `rustc`. Most useful lints are enabled by\n-default. Use `rustc -W help` to see all available lints. It's more common to put\n-warning settings in the crate root using `#![warn(LINT_NAME)]` instead of using\n-the command line flag directly.\n-\"\n-    );\n-}\n-\n-/// Write to stdout lint command options, together with a list of all available lints\n-pub fn describe_lints(sess: &Session, lint_store: &LintStore, loaded_plugins: bool) {\n-    println!(\n-        \"\n-Available lint options:\n-    -W <foo>           Warn about <foo>\n-    -A <foo>           \\\n-              Allow <foo>\n-    -D <foo>           Deny <foo>\n-    -F <foo>           Forbid <foo> \\\n-              (deny <foo> and all attempts to override)\n-\n-\"\n-    );\n-\n-    fn sort_lints(sess: &Session, mut lints: Vec<&'static Lint>) -> Vec<&'static Lint> {\n-        // The sort doesn't case-fold but it's doubtful we care.\n-        lints.sort_by_cached_key(|x: &&Lint| (x.default_level(sess.edition()), x.name));\n-        lints\n-    }\n-\n-    fn sort_lint_groups(\n-        lints: Vec<(&'static str, Vec<LintId>, bool)>,\n-    ) -> Vec<(&'static str, Vec<LintId>)> {\n-        let mut lints: Vec<_> = lints.into_iter().map(|(x, y, _)| (x, y)).collect();\n-        lints.sort_by_key(|l| l.0);\n-        lints\n-    }\n-\n-    let (plugin, builtin): (Vec<_>, _) =\n-        lint_store.get_lints().iter().cloned().partition(|&lint| lint.is_plugin);\n-    let plugin = sort_lints(sess, plugin);\n-    let builtin = sort_lints(sess, builtin);\n-\n-    let (plugin_groups, builtin_groups): (Vec<_>, _) =\n-        lint_store.get_lint_groups().partition(|&(.., p)| p);\n-    let plugin_groups = sort_lint_groups(plugin_groups);\n-    let builtin_groups = sort_lint_groups(builtin_groups);\n-\n-    let max_name_len =\n-        plugin.iter().chain(&builtin).map(|&s| s.name.chars().count()).max().unwrap_or(0);\n-    let padded = |x: &str| {\n-        let mut s = \" \".repeat(max_name_len - x.chars().count());\n-        s.push_str(x);\n-        s\n-    };\n-\n-    println!(\"Lint checks provided by rustc:\\n\");\n-\n-    let print_lints = |lints: Vec<&Lint>| {\n-        println!(\"    {}  {:7.7}  {}\", padded(\"name\"), \"default\", \"meaning\");\n-        println!(\"    {}  {:7.7}  {}\", padded(\"----\"), \"-------\", \"-------\");\n-        for lint in lints {\n-            let name = lint.name_lower().replace('_', \"-\");\n-            println!(\n-                \"    {}  {:7.7}  {}\",\n-                padded(&name),\n-                lint.default_level(sess.edition()).as_str(),\n-                lint.desc\n-            );\n-        }\n-        println!(\"\\n\");\n-    };\n-\n-    print_lints(builtin);\n-\n-    let max_name_len = max(\n-        \"warnings\".len(),\n-        plugin_groups\n-            .iter()\n-            .chain(&builtin_groups)\n-            .map(|&(s, _)| s.chars().count())\n-            .max()\n-            .unwrap_or(0),\n-    );\n-\n-    let padded = |x: &str| {\n-        let mut s = \" \".repeat(max_name_len - x.chars().count());\n-        s.push_str(x);\n-        s\n-    };\n-\n-    println!(\"Lint groups provided by rustc:\\n\");\n-\n-    let print_lint_groups = |lints: Vec<(&'static str, Vec<LintId>)>, all_warnings| {\n-        println!(\"    {}  sub-lints\", padded(\"name\"));\n-        println!(\"    {}  ---------\", padded(\"----\"));\n-\n-        if all_warnings {\n-            println!(\"    {}  all lints that are set to issue warnings\", padded(\"warnings\"));\n-        }\n-\n-        for (name, to) in lints {\n-            let name = name.to_lowercase().replace('_', \"-\");\n-            let desc = to\n-                .into_iter()\n-                .map(|x| x.to_string().replace('_', \"-\"))\n-                .collect::<Vec<String>>()\n-                .join(\", \");\n-            println!(\"    {}  {}\", padded(&name), desc);\n-        }\n-        println!(\"\\n\");\n-    };\n-\n-    print_lint_groups(builtin_groups, true);\n-\n-    match (loaded_plugins, plugin.len(), plugin_groups.len()) {\n-        (false, 0, _) | (false, _, 0) => {\n-            println!(\"Lint tools like Clippy can provide additional lints and lint groups.\");\n-        }\n-        (false, ..) => panic!(\"didn't load lint plugins but got them anyway!\"),\n-        (true, 0, 0) => println!(\"This crate does not load any lint plugins or lint groups.\"),\n-        (true, l, g) => {\n-            if l > 0 {\n-                println!(\"Lint checks provided by plugins loaded by this crate:\\n\");\n-                print_lints(plugin);\n-            }\n-            if g > 0 {\n-                println!(\"Lint groups provided by plugins loaded by this crate:\\n\");\n-                print_lint_groups(plugin_groups, false);\n-            }\n-        }\n-    }\n-}\n-\n-fn describe_debug_flags() {\n-    println!(\"\\nAvailable options:\\n\");\n-    print_flag_list(\"-Z\", config::Z_OPTIONS);\n-}\n-\n-fn describe_codegen_flags() {\n-    println!(\"\\nAvailable codegen options:\\n\");\n-    print_flag_list(\"-C\", config::CG_OPTIONS);\n-}\n-\n-pub fn print_flag_list<T>(\n-    cmdline_opt: &str,\n-    flag_list: &[(&'static str, T, &'static str, &'static str)],\n-) {\n-    let max_len = flag_list.iter().map(|&(name, _, _, _)| name.chars().count()).max().unwrap_or(0);\n-\n-    for &(name, _, _, desc) in flag_list {\n-        println!(\n-            \"    {} {:>width$}=val -- {}\",\n-            cmdline_opt,\n-            name.replace('_', \"-\"),\n-            desc,\n-            width = max_len\n-        );\n-    }\n-}\n-\n-/// Process command line options. Emits messages as appropriate. If compilation\n-/// should continue, returns a getopts::Matches object parsed from args,\n-/// otherwise returns `None`.\n-///\n-/// The compiler's handling of options is a little complicated as it ties into\n-/// our stability story. The current intention of each compiler option is to\n-/// have one of two modes:\n-///\n-/// 1. An option is stable and can be used everywhere.\n-/// 2. An option is unstable, and can only be used on nightly.\n-///\n-/// Like unstable library and language features, however, unstable options have\n-/// always required a form of \"opt in\" to indicate that you're using them. This\n-/// provides the easy ability to scan a code base to check to see if anything\n-/// unstable is being used. Currently, this \"opt in\" is the `-Z` \"zed\" flag.\n-///\n-/// All options behind `-Z` are considered unstable by default. Other top-level\n-/// options can also be considered unstable, and they were unlocked through the\n-/// `-Z unstable-options` flag. Note that `-Z` remains to be the root of\n-/// instability in both cases, though.\n-///\n-/// So with all that in mind, the comments below have some more detail about the\n-/// contortions done here to get things to work out correctly.\n-pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n-    // Throw away the first argument, the name of the binary\n-    let args = &args[1..];\n-\n-    if args.is_empty() {\n-        // user did not write `-v` nor `-Z unstable-options`, so do not\n-        // include that extra information.\n-        let nightly_build =\n-            rustc_feature::UnstableFeatures::from_environment(None).is_nightly_build();\n-        usage(false, false, nightly_build);\n-        return None;\n-    }\n-\n-    // Parse with *all* options defined in the compiler, we don't worry about\n-    // option stability here we just want to parse as much as possible.\n-    let mut options = getopts::Options::new();\n-    for option in config::rustc_optgroups() {\n-        (option.apply)(&mut options);\n-    }\n-    let matches = options.parse(args).unwrap_or_else(|e| {\n-        let msg = match e {\n-            getopts::Fail::UnrecognizedOption(ref opt) => CG_OPTIONS\n-                .iter()\n-                .map(|&(name, ..)| ('C', name))\n-                .chain(Z_OPTIONS.iter().map(|&(name, ..)| ('Z', name)))\n-                .find(|&(_, name)| *opt == name.replace('_', \"-\"))\n-                .map(|(flag, _)| format!(\"{e}. Did you mean `-{flag} {opt}`?\")),\n-            _ => None,\n-        };\n-        early_error(ErrorOutputType::default(), &msg.unwrap_or_else(|| e.to_string()));\n-    });\n-\n-    // For all options we just parsed, we check a few aspects:\n-    //\n-    // * If the option is stable, we're all good\n-    // * If the option wasn't passed, we're all good\n-    // * If `-Z unstable-options` wasn't passed (and we're not a -Z option\n-    //   ourselves), then we require the `-Z unstable-options` flag to unlock\n-    //   this option that was passed.\n-    // * If we're a nightly compiler, then unstable options are now unlocked, so\n-    //   we're good to go.\n-    // * Otherwise, if we're an unstable option then we generate an error\n-    //   (unstable option being used on stable)\n-    nightly_options::check_nightly_options(&matches, &config::rustc_optgroups());\n-\n-    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        // Only show unstable options in --help if we accept unstable options.\n-        let unstable_enabled = nightly_options::is_unstable_enabled(&matches);\n-        let nightly_build = nightly_options::match_is_nightly_build(&matches);\n-        usage(matches.opt_present(\"verbose\"), unstable_enabled, nightly_build);\n-        return None;\n-    }\n-\n-    // Handle the special case of -Wall.\n-    let wall = matches.opt_strs(\"W\");\n-    if wall.iter().any(|x| *x == \"all\") {\n-        print_wall_help();\n-        rustc_errors::FatalError.raise();\n-    }\n-\n-    // Don't handle -W help here, because we might first load plugins.\n-    let debug_flags = matches.opt_strs(\"Z\");\n-    if debug_flags.iter().any(|x| *x == \"help\") {\n-        describe_debug_flags();\n-        return None;\n-    }\n-\n-    let cg_flags = matches.opt_strs(\"C\");\n-\n-    if cg_flags.iter().any(|x| *x == \"help\") {\n-        describe_codegen_flags();\n-        return None;\n-    }\n-\n-    if cg_flags.iter().any(|x| *x == \"no-stack-check\") {\n-        early_warn(\n-            ErrorOutputType::default(),\n-            \"the --no-stack-check flag is deprecated and does nothing\",\n-        );\n-    }\n-\n-    if cg_flags.iter().any(|x| *x == \"passes=list\") {\n-        let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n-        get_codegen_backend(&None, backend_name).print_passes();\n-        return None;\n-    }\n-\n-    if matches.opt_present(\"version\") {\n-        version!(\"rustc\", &matches);\n-        return None;\n-    }\n-\n-    Some(matches)\n-}\n-\n-fn parse_crate_attrs<'a>(sess: &'a Session) -> PResult<'a, ast::AttrVec> {\n-    match &sess.io.input {\n-        Input::File(ifile) => rustc_parse::parse_crate_attrs_from_file(ifile, &sess.parse_sess),\n-        Input::Str { name, input } => rustc_parse::parse_crate_attrs_from_source_str(\n-            name.clone(),\n-            input.clone(),\n-            &sess.parse_sess,\n-        ),\n-    }\n-}\n-\n-/// Gets a list of extra command-line flags provided by the user, as strings.\n-///\n-/// This function is used during ICEs to show more information useful for\n-/// debugging, since some ICEs only happens with non-default compiler flags\n-/// (and the users don't always report them).\n-fn extra_compiler_flags() -> Option<(Vec<String>, bool)> {\n-    let mut args = env::args_os().map(|arg| arg.to_string_lossy().to_string()).peekable();\n-\n-    let mut result = Vec::new();\n-    let mut excluded_cargo_defaults = false;\n-    while let Some(arg) = args.next() {\n-        if let Some(a) = ICE_REPORT_COMPILER_FLAGS.iter().find(|a| arg.starts_with(*a)) {\n-            let content = if arg.len() == a.len() {\n-                // A space-separated option, like `-C incremental=foo` or `--crate-type rlib`\n-                match args.next() {\n-                    Some(arg) => arg.to_string(),\n-                    None => continue,\n-                }\n-            } else if arg.get(a.len()..a.len() + 1) == Some(\"=\") {\n-                // An equals option, like `--crate-type=rlib`\n-                arg[a.len() + 1..].to_string()\n-            } else {\n-                // A non-space option, like `-Cincremental=foo`\n-                arg[a.len()..].to_string()\n-            };\n-            let option = content.split_once('=').map(|s| s.0).unwrap_or(&content);\n-            if ICE_REPORT_COMPILER_FLAGS_EXCLUDE.iter().any(|exc| option == *exc) {\n-                excluded_cargo_defaults = true;\n-            } else {\n-                result.push(a.to_string());\n-                match ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE.iter().find(|s| option == **s) {\n-                    Some(s) => result.push(format!(\"{s}=[REDACTED]\")),\n-                    None => result.push(content),\n-                }\n-            }\n-        }\n-    }\n-\n-    if !result.is_empty() { Some((result, excluded_cargo_defaults)) } else { None }\n-}\n-\n-/// Runs a closure and catches unwinds triggered by fatal errors.\n-///\n-/// The compiler currently unwinds with a special sentinel value to abort\n-/// compilation on fatal errors. This function catches that sentinel and turns\n-/// the panic into a `Result` instead.\n-pub fn catch_fatal_errors<F: FnOnce() -> R, R>(f: F) -> Result<R, ErrorGuaranteed> {\n-    catch_unwind(panic::AssertUnwindSafe(f)).map_err(|value| {\n-        if value.is::<rustc_errors::FatalErrorMarker>() {\n-            ErrorGuaranteed::unchecked_claim_error_was_emitted()\n-        } else {\n-            panic::resume_unwind(value);\n-        }\n-    })\n-}\n-\n-/// Variant of `catch_fatal_errors` for the `interface::Result` return type\n-/// that also computes the exit code.\n-pub fn catch_with_exit_code(f: impl FnOnce() -> interface::Result<()>) -> i32 {\n-    let result = catch_fatal_errors(f).and_then(|result| result);\n-    match result {\n-        Ok(()) => EXIT_SUCCESS,\n-        Err(_) => EXIT_FAILURE,\n-    }\n-}\n-\n-static DEFAULT_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> =\n-    LazyLock::new(|| {\n-        let hook = panic::take_hook();\n-        panic::set_hook(Box::new(|info| {\n-            // If the error was caused by a broken pipe then this is not a bug.\n-            // Write the error and return immediately. See #98700.\n-            #[cfg(windows)]\n-            if let Some(msg) = info.payload().downcast_ref::<String>() {\n-                if msg.starts_with(\"failed printing to stdout: \") && msg.ends_with(\"(os error 232)\")\n-                {\n-                    early_error_no_abort(ErrorOutputType::default(), &msg);\n-                    return;\n-                }\n-            };\n-\n-            // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n-            // Don't do this for delayed bugs, which already emit their own more useful backtrace.\n-            if !info.payload().is::<rustc_errors::DelayedBugPanic>() {\n-                (*DEFAULT_HOOK)(info);\n-\n-                // Separate the output with an empty line\n-                eprintln!();\n-            }\n-\n-            // Print the ICE message\n-            report_ice(info, BUG_REPORT_URL);\n-        }));\n-        hook\n-    });\n-\n-/// Prints the ICE message, including query stack, but without backtrace.\n-///\n-/// The message will point the user at `bug_report_url` to report the ICE.\n-///\n-/// When `install_ice_hook` is called, this function will be called as the panic\n-/// hook.\n-pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n-    let fallback_bundle =\n-        rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n-    let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n-        rustc_errors::ColorConfig::Auto,\n-        None,\n-        None,\n-        fallback_bundle,\n-        false,\n-        false,\n-        None,\n-        false,\n-        false,\n-    ));\n-    let handler = rustc_errors::Handler::with_emitter(true, None, emitter);\n-\n-    // a .span_bug or .bug call has already printed what\n-    // it wants to print.\n-    if !info.payload().is::<rustc_errors::ExplicitBug>()\n-        && !info.payload().is::<rustc_errors::DelayedBugPanic>()\n-    {\n-        let mut d = rustc_errors::Diagnostic::new(rustc_errors::Level::Bug, \"unexpected panic\");\n-        handler.emit_diagnostic(&mut d);\n-    }\n-\n-    handler.emit_note(session_diagnostics::Ice);\n-    handler.emit_note(session_diagnostics::IceBugReport { bug_report_url });\n-    handler.emit_note(session_diagnostics::IceVersion {\n-        version: util::version_str!().unwrap_or(\"unknown_version\"),\n-        triple: config::host_triple(),\n-    });\n-\n-    if let Some((flags, excluded_cargo_defaults)) = extra_compiler_flags() {\n-        handler.emit_note(session_diagnostics::IceFlags { flags: flags.join(\" \") });\n-        if excluded_cargo_defaults {\n-            handler.emit_note(session_diagnostics::IceExcludeCargoDefaults);\n-        }\n-    }\n-\n-    // If backtraces are enabled, also print the query stack\n-    let backtrace = env::var_os(\"RUST_BACKTRACE\").map_or(false, |x| &x != \"0\");\n-\n-    let num_frames = if backtrace { None } else { Some(2) };\n-\n-    interface::try_print_query_stack(&handler, num_frames);\n-\n-    #[cfg(windows)]\n-    unsafe {\n-        if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n-            // Trigger a debugger if we crashed during bootstrap\n-            winapi::um::debugapi::DebugBreak();\n-        }\n-    }\n-}\n-\n-/// Installs a panic hook that will print the ICE message on unexpected panics.\n-///\n-/// A custom rustc driver can skip calling this to set up a custom ICE hook.\n-pub fn install_ice_hook() {\n-    // If the user has not explicitly overridden \"RUST_BACKTRACE\", then produce\n-    // full backtraces. When a compiler ICE happens, we want to gather\n-    // as much information as possible to present in the issue opened\n-    // by the user. Compiler developers and other rustc users can\n-    // opt in to less-verbose backtraces by manually setting \"RUST_BACKTRACE\"\n-    // (e.g. `RUST_BACKTRACE=1`)\n-    if std::env::var(\"RUST_BACKTRACE\").is_err() {\n-        std::env::set_var(\"RUST_BACKTRACE\", \"full\");\n-    }\n-    LazyLock::force(&DEFAULT_HOOK);\n-}\n-\n-/// This allows tools to enable rust logging without having to magically match rustc's\n-/// tracing crate version.\n-pub fn init_rustc_env_logger() {\n-    init_rustc_env_logger_with_backtrace_option(&None);\n-}\n-\n-/// This allows tools to enable rust logging without having to magically match rustc's\n-/// tracing crate version. In contrast to `init_rustc_env_logger` it allows you to\n-/// choose a target module you wish to show backtraces along with its logging.\n-pub fn init_rustc_env_logger_with_backtrace_option(backtrace_target: &Option<String>) {\n-    if let Err(error) = rustc_log::init_rustc_env_logger_with_backtrace_option(backtrace_target) {\n-        early_error(ErrorOutputType::default(), &error.to_string());\n-    }\n-}\n-\n-/// This allows tools to enable rust logging without having to magically match rustc's\n-/// tracing crate version. In contrast to `init_rustc_env_logger` it allows you to choose an env var\n-/// other than `RUSTC_LOG`.\n-pub fn init_env_logger(env: &str) {\n-    if let Err(error) = rustc_log::init_env_logger(env) {\n-        early_error(ErrorOutputType::default(), &error.to_string());\n-    }\n-}\n-\n-#[cfg(all(unix, any(target_env = \"gnu\", target_os = \"macos\")))]\n-mod signal_handler {\n-    extern \"C\" {\n-        fn backtrace_symbols_fd(\n-            buffer: *const *mut libc::c_void,\n-            size: libc::c_int,\n-            fd: libc::c_int,\n-        );\n-    }\n-\n-    extern \"C\" fn print_stack_trace(_: libc::c_int) {\n-        const MAX_FRAMES: usize = 256;\n-        static mut STACK_TRACE: [*mut libc::c_void; MAX_FRAMES] =\n-            [std::ptr::null_mut(); MAX_FRAMES];\n-        unsafe {\n-            let depth = libc::backtrace(STACK_TRACE.as_mut_ptr(), MAX_FRAMES as i32);\n-            if depth == 0 {\n-                return;\n-            }\n-            backtrace_symbols_fd(STACK_TRACE.as_ptr(), depth, 2);\n-        }\n-    }\n-\n-    /// When an error signal (such as SIGABRT or SIGSEGV) is delivered to the\n-    /// process, print a stack trace and then exit.\n-    pub(super) fn install() {\n-        unsafe {\n-            const ALT_STACK_SIZE: usize = libc::MINSIGSTKSZ + 64 * 1024;\n-            let mut alt_stack: libc::stack_t = std::mem::zeroed();\n-            alt_stack.ss_sp =\n-                std::alloc::alloc(std::alloc::Layout::from_size_align(ALT_STACK_SIZE, 1).unwrap())\n-                    as *mut libc::c_void;\n-            alt_stack.ss_size = ALT_STACK_SIZE;\n-            libc::sigaltstack(&alt_stack, std::ptr::null_mut());\n-\n-            let mut sa: libc::sigaction = std::mem::zeroed();\n-            sa.sa_sigaction = print_stack_trace as libc::sighandler_t;\n-            sa.sa_flags = libc::SA_NODEFER | libc::SA_RESETHAND | libc::SA_ONSTACK;\n-            libc::sigemptyset(&mut sa.sa_mask);\n-            libc::sigaction(libc::SIGSEGV, &sa, std::ptr::null_mut());\n-        }\n-    }\n-}\n-\n-#[cfg(not(all(unix, any(target_env = \"gnu\", target_os = \"macos\"))))]\n-mod signal_handler {\n-    pub(super) fn install() {}\n-}\n-\n-pub fn main() -> ! {\n-    let start_time = Instant::now();\n-    let start_rss = get_resident_set_size();\n-    signal_handler::install();\n-    let mut callbacks = TimePassesCallbacks::default();\n-    install_ice_hook();\n-    let exit_code = catch_with_exit_code(|| {\n-        let args = env::args_os()\n-            .enumerate()\n-            .map(|(i, arg)| {\n-                arg.into_string().unwrap_or_else(|arg| {\n-                    early_error(\n-                        ErrorOutputType::default(),\n-                        &format!(\"argument {i} is not valid Unicode: {arg:?}\"),\n-                    )\n-                })\n-            })\n-            .collect::<Vec<_>>();\n-        RunCompiler::new(&args, &mut callbacks).run()\n-    });\n-\n-    if callbacks.time_passes {\n-        let end_rss = get_resident_set_size();\n-        print_time_passes_entry(\"total\", start_time.elapsed(), start_rss, end_rss);\n-    }\n-\n-    process::exit(exit_code)\n-}\n+pub use rustc_driver_impl::*;"}, {"sha": "af85b12c52b20dc35362d84a6fb873f468a2947c", "filename": "compiler/rustc_driver_impl/Cargo.toml", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2FCargo.toml?ref=3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "patch": "@@ -0,0 +1,44 @@\n+[package]\n+name = \"rustc_driver_impl\"\n+version = \"0.0.0\"\n+edition = \"2021\"\n+\n+[lib]\n+\n+[dependencies]\n+tracing = { version = \"0.1.35\" }\n+serde_json = \"1.0.59\"\n+rustc_log = { path = \"../rustc_log\" }\n+rustc_middle = { path = \"../rustc_middle\" }\n+rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n+rustc_target = { path = \"../rustc_target\" }\n+rustc_lint = { path = \"../rustc_lint\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_feature = { path = \"../rustc_feature\" }\n+rustc_hir = { path = \"../rustc_hir\" }\n+rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n+rustc_metadata = { path = \"../rustc_metadata\" }\n+rustc_parse = { path = \"../rustc_parse\" }\n+rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }\n+rustc_save_analysis = { path = \"../rustc_save_analysis\" }\n+rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n+rustc_session = { path = \"../rustc_session\" }\n+rustc_error_codes = { path = \"../rustc_error_codes\" }\n+rustc_interface = { path = \"../rustc_interface\" }\n+rustc_ast = { path = \"../rustc_ast\" }\n+rustc_span = { path = \"../rustc_span\" }\n+rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n+\n+[target.'cfg(unix)'.dependencies]\n+libc = \"0.2\"\n+\n+[target.'cfg(windows)'.dependencies]\n+winapi = { version = \"0.3\", features = [\"consoleapi\", \"debugapi\", \"processenv\"] }\n+\n+[features]\n+llvm = ['rustc_interface/llvm']\n+max_level_info = ['rustc_log/max_level_info']\n+rustc_use_parallel_compiler = ['rustc_data_structures/rustc_use_parallel_compiler', 'rustc_interface/rustc_use_parallel_compiler',\n+    'rustc_middle/rustc_use_parallel_compiler']"}, {"sha": "6d7fba36fb3d071f182ab20a105e485a0f2efc47", "filename": "compiler/rustc_driver_impl/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver_impl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver_impl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2FREADME.md?ref=3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "previous_filename": "compiler/rustc_driver/README.md"}, {"sha": "42c97cc6a9d7418be734945a66ed3009a5004337", "filename": "compiler/rustc_driver_impl/src/args.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs?ref=3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "previous_filename": "compiler/rustc_driver/src/args.rs"}, {"sha": "02e0b042ad2631eadad94771b4a2dfab2c2defd4", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "added", "additions": 1353, "deletions": 0, "changes": 1353, "blob_url": "https://github.com/rust-lang/rust/blob/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "patch": "@@ -0,0 +1,1353 @@\n+//! The Rust compiler.\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(is_terminal)]\n+#![feature(once_cell)]\n+#![feature(decl_macro)]\n+#![recursion_limit = \"256\"]\n+#![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n+#[macro_use]\n+extern crate tracing;\n+\n+pub extern crate rustc_plugin_impl as plugin;\n+\n+use rustc_ast as ast;\n+use rustc_codegen_ssa::{traits::CodegenBackend, CodegenErrors, CodegenResults};\n+use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n+use rustc_data_structures::sync::SeqCst;\n+use rustc_errors::registry::{InvalidErrorCode, Registry};\n+use rustc_errors::{ErrorGuaranteed, PResult};\n+use rustc_feature::find_gated_cfg;\n+use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_interface::util::{self, collect_crate_types, get_codegen_backend};\n+use rustc_interface::{interface, Queries};\n+use rustc_lint::LintStore;\n+use rustc_metadata::locator;\n+use rustc_save_analysis as save;\n+use rustc_save_analysis::DumpHandler;\n+use rustc_session::config::{nightly_options, CG_OPTIONS, Z_OPTIONS};\n+use rustc_session::config::{ErrorOutputType, Input, OutputType, PrintRequest, TrimmedDefPaths};\n+use rustc_session::cstore::MetadataLoader;\n+use rustc_session::getopts;\n+use rustc_session::lint::{Lint, LintId};\n+use rustc_session::{config, Session};\n+use rustc_session::{early_error, early_error_no_abort, early_warn};\n+use rustc_span::source_map::{FileLoader, FileName};\n+use rustc_span::symbol::sym;\n+use rustc_target::json::ToJson;\n+\n+use std::cmp::max;\n+use std::env;\n+use std::ffi::OsString;\n+use std::fs;\n+use std::io::{self, IsTerminal, Read, Write};\n+use std::panic::{self, catch_unwind};\n+use std::path::PathBuf;\n+use std::process::{self, Command, Stdio};\n+use std::str;\n+use std::sync::LazyLock;\n+use std::time::Instant;\n+\n+pub mod args;\n+pub mod pretty;\n+mod session_diagnostics;\n+\n+use crate::session_diagnostics::{\n+    RLinkEmptyVersionNumber, RLinkEncodingVersionMismatch, RLinkRustcVersionMismatch,\n+    RLinkWrongFileType, RlinkNotAFile, RlinkUnableToRead,\n+};\n+\n+/// Exit status code used for successful compilation and help output.\n+pub const EXIT_SUCCESS: i32 = 0;\n+\n+/// Exit status code used for compilation failures and invalid flags.\n+pub const EXIT_FAILURE: i32 = 1;\n+\n+const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust/issues/new\\\n+    ?labels=C-bug%2C+I-ICE%2C+T-compiler&template=ice.md\";\n+\n+const ICE_REPORT_COMPILER_FLAGS: &[&str] = &[\"-Z\", \"-C\", \"--crate-type\"];\n+\n+const ICE_REPORT_COMPILER_FLAGS_EXCLUDE: &[&str] = &[\"metadata\", \"extra-filename\"];\n+\n+const ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE: &[&str] = &[\"incremental\"];\n+\n+pub fn abort_on_err<T>(result: Result<T, ErrorGuaranteed>, sess: &Session) -> T {\n+    match result {\n+        Err(..) => {\n+            sess.abort_if_errors();\n+            panic!(\"error reported but abort_if_errors didn't abort???\");\n+        }\n+        Ok(x) => x,\n+    }\n+}\n+\n+pub trait Callbacks {\n+    /// Called before creating the compiler instance\n+    fn config(&mut self, _config: &mut interface::Config) {}\n+    /// Called after parsing. Return value instructs the compiler whether to\n+    /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n+    fn after_parsing<'tcx>(\n+        &mut self,\n+        _compiler: &interface::Compiler,\n+        _queries: &'tcx Queries<'tcx>,\n+    ) -> Compilation {\n+        Compilation::Continue\n+    }\n+    /// Called after expansion. Return value instructs the compiler whether to\n+    /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n+    fn after_expansion<'tcx>(\n+        &mut self,\n+        _compiler: &interface::Compiler,\n+        _queries: &'tcx Queries<'tcx>,\n+    ) -> Compilation {\n+        Compilation::Continue\n+    }\n+    /// Called after analysis. Return value instructs the compiler whether to\n+    /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n+    fn after_analysis<'tcx>(\n+        &mut self,\n+        _compiler: &interface::Compiler,\n+        _queries: &'tcx Queries<'tcx>,\n+    ) -> Compilation {\n+        Compilation::Continue\n+    }\n+}\n+\n+#[derive(Default)]\n+pub struct TimePassesCallbacks {\n+    time_passes: bool,\n+}\n+\n+impl Callbacks for TimePassesCallbacks {\n+    // JUSTIFICATION: the session doesn't exist at this point.\n+    #[allow(rustc::bad_opt_access)]\n+    fn config(&mut self, config: &mut interface::Config) {\n+        // If a --print=... option has been given, we don't print the \"total\"\n+        // time because it will mess up the --print output. See #64339.\n+        //\n+        self.time_passes = config.opts.prints.is_empty() && config.opts.unstable_opts.time_passes;\n+        config.opts.trimmed_def_paths = TrimmedDefPaths::GoodPath;\n+    }\n+}\n+\n+pub fn diagnostics_registry() -> Registry {\n+    Registry::new(rustc_error_codes::DIAGNOSTICS)\n+}\n+\n+/// This is the primary entry point for rustc.\n+pub struct RunCompiler<'a, 'b> {\n+    at_args: &'a [String],\n+    callbacks: &'b mut (dyn Callbacks + Send),\n+    file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n+    make_codegen_backend:\n+        Option<Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>>,\n+}\n+\n+impl<'a, 'b> RunCompiler<'a, 'b> {\n+    pub fn new(at_args: &'a [String], callbacks: &'b mut (dyn Callbacks + Send)) -> Self {\n+        Self { at_args, callbacks, file_loader: None, make_codegen_backend: None }\n+    }\n+\n+    /// Set a custom codegen backend.\n+    ///\n+    /// Has no uses within this repository, but is used by bjorn3 for \"the\n+    /// hotswapping branch of cg_clif\" for \"setting the codegen backend from a\n+    /// custom driver where the custom codegen backend has arbitrary data.\"\n+    /// (See #102759.)\n+    pub fn set_make_codegen_backend(\n+        &mut self,\n+        make_codegen_backend: Option<\n+            Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n+        >,\n+    ) -> &mut Self {\n+        self.make_codegen_backend = make_codegen_backend;\n+        self\n+    }\n+\n+    /// Load files from sources other than the file system.\n+    ///\n+    /// Has no uses within this repository, but may be used in the future by\n+    /// bjorn3 for \"hooking rust-analyzer's VFS into rustc at some point for\n+    /// running rustc without having to save\". (See #102759.)\n+    pub fn set_file_loader(\n+        &mut self,\n+        file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n+    ) -> &mut Self {\n+        self.file_loader = file_loader;\n+        self\n+    }\n+\n+    /// Parse args and run the compiler.\n+    pub fn run(self) -> interface::Result<()> {\n+        run_compiler(self.at_args, self.callbacks, self.file_loader, self.make_codegen_backend)\n+    }\n+}\n+\n+fn run_compiler(\n+    at_args: &[String],\n+    callbacks: &mut (dyn Callbacks + Send),\n+    file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n+    make_codegen_backend: Option<\n+        Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n+    >,\n+) -> interface::Result<()> {\n+    let args = args::arg_expand_all(at_args);\n+\n+    let Some(matches) = handle_options(&args) else { return Ok(()) };\n+\n+    let sopts = config::build_session_options(&matches);\n+\n+    if let Some(ref code) = matches.opt_str(\"explain\") {\n+        handle_explain(diagnostics_registry(), code, sopts.error_format);\n+        return Ok(());\n+    }\n+\n+    let cfg = interface::parse_cfgspecs(matches.opt_strs(\"cfg\"));\n+    let check_cfg = interface::parse_check_cfg(matches.opt_strs(\"check-cfg\"));\n+    let (odir, ofile) = make_output(&matches);\n+    let mut config = interface::Config {\n+        opts: sopts,\n+        crate_cfg: cfg,\n+        crate_check_cfg: check_cfg,\n+        input: Input::File(PathBuf::new()),\n+        output_file: ofile,\n+        output_dir: odir,\n+        file_loader,\n+        lint_caps: Default::default(),\n+        parse_sess_created: None,\n+        register_lints: None,\n+        override_queries: None,\n+        make_codegen_backend,\n+        registry: diagnostics_registry(),\n+    };\n+\n+    if !tracing::dispatcher::has_been_set() {\n+        init_rustc_env_logger_with_backtrace_option(&config.opts.unstable_opts.log_backtrace);\n+    }\n+\n+    match make_input(config.opts.error_format, &matches.free) {\n+        Err(reported) => return Err(reported),\n+        Ok(Some(input)) => {\n+            config.input = input;\n+\n+            callbacks.config(&mut config);\n+        }\n+        Ok(None) => match matches.free.len() {\n+            0 => {\n+                callbacks.config(&mut config);\n+                interface::run_compiler(config, |compiler| {\n+                    let sopts = &compiler.session().opts;\n+                    if sopts.describe_lints {\n+                        let mut lint_store =\n+                            rustc_lint::new_lint_store(compiler.session().enable_internal_lints());\n+                        let registered_lints =\n+                            if let Some(register_lints) = compiler.register_lints() {\n+                                register_lints(compiler.session(), &mut lint_store);\n+                                true\n+                            } else {\n+                                false\n+                            };\n+                        describe_lints(compiler.session(), &lint_store, registered_lints);\n+                        return;\n+                    }\n+                    let should_stop =\n+                        print_crate_info(&***compiler.codegen_backend(), compiler.session(), false);\n+\n+                    if should_stop == Compilation::Stop {\n+                        return;\n+                    }\n+                    early_error(sopts.error_format, \"no input filename given\")\n+                });\n+                return Ok(());\n+            }\n+            1 => panic!(\"make_input should have provided valid inputs\"),\n+            _ => early_error(\n+                config.opts.error_format,\n+                &format!(\n+                    \"multiple input filenames provided (first two filenames are `{}` and `{}`)\",\n+                    matches.free[0], matches.free[1],\n+                ),\n+            ),\n+        },\n+    };\n+\n+    interface::run_compiler(config, |compiler| {\n+        let sess = compiler.session();\n+        let should_stop = print_crate_info(&***compiler.codegen_backend(), sess, true)\n+            .and_then(|| list_metadata(sess, &*compiler.codegen_backend().metadata_loader()))\n+            .and_then(|| try_process_rlink(sess, compiler));\n+\n+        if should_stop == Compilation::Stop {\n+            return sess.compile_status();\n+        }\n+\n+        let linker = compiler.enter(|queries| {\n+            let early_exit = || sess.compile_status().map(|_| None);\n+            queries.parse()?;\n+\n+            if let Some(ppm) = &sess.opts.pretty {\n+                if ppm.needs_ast_map() {\n+                    queries.global_ctxt()?.enter(|tcx| {\n+                        pretty::print_after_hir_lowering(tcx, *ppm);\n+                        Ok(())\n+                    })?;\n+                } else {\n+                    let krate = queries.parse()?.steal();\n+                    pretty::print_after_parsing(sess, &krate, *ppm);\n+                }\n+                trace!(\"finished pretty-printing\");\n+                return early_exit();\n+            }\n+\n+            if callbacks.after_parsing(compiler, queries) == Compilation::Stop {\n+                return early_exit();\n+            }\n+\n+            if sess.opts.unstable_opts.parse_only || sess.opts.unstable_opts.show_span.is_some() {\n+                return early_exit();\n+            }\n+\n+            {\n+                let plugins = queries.register_plugins()?;\n+                let (_, lint_store) = &*plugins.borrow();\n+\n+                // Lint plugins are registered; now we can process command line flags.\n+                if sess.opts.describe_lints {\n+                    describe_lints(sess, lint_store, true);\n+                    return early_exit();\n+                }\n+            }\n+\n+            let mut gctxt = queries.global_ctxt()?;\n+            if callbacks.after_expansion(compiler, queries) == Compilation::Stop {\n+                return early_exit();\n+            }\n+\n+            // Make sure the `output_filenames` query is run for its side\n+            // effects of writing the dep-info and reporting errors.\n+            gctxt.enter(|tcx| tcx.output_filenames(()));\n+\n+            if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n+                && sess.opts.output_types.len() == 1\n+            {\n+                return early_exit();\n+            }\n+\n+            if sess.opts.unstable_opts.no_analysis {\n+                return early_exit();\n+            }\n+\n+            gctxt.enter(|tcx| {\n+                let result = tcx.analysis(());\n+                if sess.opts.unstable_opts.save_analysis {\n+                    let crate_name = tcx.crate_name(LOCAL_CRATE);\n+                    sess.time(\"save_analysis\", || {\n+                        save::process_crate(\n+                            tcx,\n+                            crate_name,\n+                            &sess.io.input,\n+                            None,\n+                            DumpHandler::new(sess.io.output_dir.as_deref(), crate_name),\n+                        )\n+                    });\n+                }\n+                result\n+            })?;\n+\n+            drop(gctxt);\n+\n+            if callbacks.after_analysis(compiler, queries) == Compilation::Stop {\n+                return early_exit();\n+            }\n+\n+            queries.ongoing_codegen()?;\n+\n+            if sess.opts.unstable_opts.print_type_sizes {\n+                sess.code_stats.print_type_sizes();\n+            }\n+\n+            let linker = queries.linker()?;\n+            Ok(Some(linker))\n+        })?;\n+\n+        if let Some(linker) = linker {\n+            let _timer = sess.timer(\"link\");\n+            linker.link()?\n+        }\n+\n+        if sess.opts.unstable_opts.perf_stats {\n+            sess.print_perf_stats();\n+        }\n+\n+        if sess.opts.unstable_opts.print_fuel.is_some() {\n+            eprintln!(\n+                \"Fuel used by {}: {}\",\n+                sess.opts.unstable_opts.print_fuel.as_ref().unwrap(),\n+                sess.print_fuel.load(SeqCst)\n+            );\n+        }\n+\n+        Ok(())\n+    })\n+}\n+\n+// Extract output directory and file from matches.\n+fn make_output(matches: &getopts::Matches) -> (Option<PathBuf>, Option<PathBuf>) {\n+    let odir = matches.opt_str(\"out-dir\").map(|o| PathBuf::from(&o));\n+    let ofile = matches.opt_str(\"o\").map(|o| PathBuf::from(&o));\n+    (odir, ofile)\n+}\n+\n+// Extract input (string or file and optional path) from matches.\n+fn make_input(\n+    error_format: ErrorOutputType,\n+    free_matches: &[String],\n+) -> Result<Option<Input>, ErrorGuaranteed> {\n+    if free_matches.len() == 1 {\n+        let ifile = &free_matches[0];\n+        if ifile == \"-\" {\n+            let mut src = String::new();\n+            if io::stdin().read_to_string(&mut src).is_err() {\n+                // Immediately stop compilation if there was an issue reading\n+                // the input (for example if the input stream is not UTF-8).\n+                let reported = early_error_no_abort(\n+                    error_format,\n+                    \"couldn't read from stdin, as it did not contain valid UTF-8\",\n+                );\n+                return Err(reported);\n+            }\n+            if let Ok(path) = env::var(\"UNSTABLE_RUSTDOC_TEST_PATH\") {\n+                let line = env::var(\"UNSTABLE_RUSTDOC_TEST_LINE\").expect(\n+                    \"when UNSTABLE_RUSTDOC_TEST_PATH is set \\\n+                                    UNSTABLE_RUSTDOC_TEST_LINE also needs to be set\",\n+                );\n+                let line = isize::from_str_radix(&line, 10)\n+                    .expect(\"UNSTABLE_RUSTDOC_TEST_LINE needs to be an number\");\n+                let file_name = FileName::doc_test_source_code(PathBuf::from(path), line);\n+                Ok(Some(Input::Str { name: file_name, input: src }))\n+            } else {\n+                Ok(Some(Input::Str { name: FileName::anon_source_code(&src), input: src }))\n+            }\n+        } else {\n+            Ok(Some(Input::File(PathBuf::from(ifile))))\n+        }\n+    } else {\n+        Ok(None)\n+    }\n+}\n+\n+/// Whether to stop or continue compilation.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum Compilation {\n+    Stop,\n+    Continue,\n+}\n+\n+impl Compilation {\n+    pub fn and_then<F: FnOnce() -> Compilation>(self, next: F) -> Compilation {\n+        match self {\n+            Compilation::Stop => Compilation::Stop,\n+            Compilation::Continue => next(),\n+        }\n+    }\n+}\n+\n+fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n+    let upper_cased_code = code.to_ascii_uppercase();\n+    let normalised =\n+        if upper_cased_code.starts_with('E') { upper_cased_code } else { format!(\"E{code:0>4}\") };\n+    match registry.try_find_description(&normalised) {\n+        Ok(Some(description)) => {\n+            let mut is_in_code_block = false;\n+            let mut text = String::new();\n+            // Slice off the leading newline and print.\n+            for line in description.lines() {\n+                let indent_level =\n+                    line.find(|c: char| !c.is_whitespace()).unwrap_or_else(|| line.len());\n+                let dedented_line = &line[indent_level..];\n+                if dedented_line.starts_with(\"```\") {\n+                    is_in_code_block = !is_in_code_block;\n+                    text.push_str(&line[..(indent_level + 3)]);\n+                } else if is_in_code_block && dedented_line.starts_with(\"# \") {\n+                    continue;\n+                } else {\n+                    text.push_str(line);\n+                }\n+                text.push('\\n');\n+            }\n+            if io::stdout().is_terminal() {\n+                show_content_with_pager(&text);\n+            } else {\n+                print!(\"{text}\");\n+            }\n+        }\n+        Ok(None) => {\n+            early_error(output, &format!(\"no extended information for {code}\"));\n+        }\n+        Err(InvalidErrorCode) => {\n+            early_error(output, &format!(\"{code} is not a valid error code\"));\n+        }\n+    }\n+}\n+\n+fn show_content_with_pager(content: &str) {\n+    let pager_name = env::var_os(\"PAGER\").unwrap_or_else(|| {\n+        if cfg!(windows) { OsString::from(\"more.com\") } else { OsString::from(\"less\") }\n+    });\n+\n+    let mut fallback_to_println = false;\n+\n+    match Command::new(pager_name).stdin(Stdio::piped()).spawn() {\n+        Ok(mut pager) => {\n+            if let Some(pipe) = pager.stdin.as_mut() {\n+                if pipe.write_all(content.as_bytes()).is_err() {\n+                    fallback_to_println = true;\n+                }\n+            }\n+\n+            if pager.wait().is_err() {\n+                fallback_to_println = true;\n+            }\n+        }\n+        Err(_) => {\n+            fallback_to_println = true;\n+        }\n+    }\n+\n+    // If pager fails for whatever reason, we should still print the content\n+    // to standard output\n+    if fallback_to_println {\n+        print!(\"{content}\");\n+    }\n+}\n+\n+pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Compilation {\n+    if sess.opts.unstable_opts.link_only {\n+        if let Input::File(file) = &sess.io.input {\n+            // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n+            sess.init_crate_types(collect_crate_types(sess, &[]));\n+            let outputs = compiler.build_output_filenames(sess, &[]);\n+            let rlink_data = fs::read(file).unwrap_or_else(|err| {\n+                sess.emit_fatal(RlinkUnableToRead { err });\n+            });\n+            let codegen_results = match CodegenResults::deserialize_rlink(rlink_data) {\n+                Ok(codegen) => codegen,\n+                Err(err) => {\n+                    match err {\n+                        CodegenErrors::WrongFileType => sess.emit_fatal(RLinkWrongFileType),\n+                        CodegenErrors::EmptyVersionNumber => {\n+                            sess.emit_fatal(RLinkEmptyVersionNumber)\n+                        }\n+                        CodegenErrors::EncodingVersionMismatch { version_array, rlink_version } => {\n+                            sess.emit_fatal(RLinkEncodingVersionMismatch {\n+                                version_array,\n+                                rlink_version,\n+                            })\n+                        }\n+                        CodegenErrors::RustcVersionMismatch { rustc_version, current_version } => {\n+                            sess.emit_fatal(RLinkRustcVersionMismatch {\n+                                rustc_version,\n+                                current_version,\n+                            })\n+                        }\n+                    };\n+                }\n+            };\n+            let result = compiler.codegen_backend().link(sess, codegen_results, &outputs);\n+            abort_on_err(result, sess);\n+        } else {\n+            sess.emit_fatal(RlinkNotAFile {})\n+        }\n+        Compilation::Stop\n+    } else {\n+        Compilation::Continue\n+    }\n+}\n+\n+pub fn list_metadata(sess: &Session, metadata_loader: &dyn MetadataLoader) -> Compilation {\n+    if sess.opts.unstable_opts.ls {\n+        match sess.io.input {\n+            Input::File(ref ifile) => {\n+                let path = &(*ifile);\n+                let mut v = Vec::new();\n+                locator::list_file_metadata(&sess.target, path, metadata_loader, &mut v).unwrap();\n+                println!(\"{}\", String::from_utf8(v).unwrap());\n+            }\n+            Input::Str { .. } => {\n+                early_error(ErrorOutputType::default(), \"cannot list metadata for stdin\");\n+            }\n+        }\n+        return Compilation::Stop;\n+    }\n+\n+    Compilation::Continue\n+}\n+\n+fn print_crate_info(\n+    codegen_backend: &dyn CodegenBackend,\n+    sess: &Session,\n+    parse_attrs: bool,\n+) -> Compilation {\n+    use rustc_session::config::PrintRequest::*;\n+    // NativeStaticLibs and LinkArgs are special - printed during linking\n+    // (empty iterator returns true)\n+    if sess.opts.prints.iter().all(|&p| p == NativeStaticLibs || p == LinkArgs) {\n+        return Compilation::Continue;\n+    }\n+\n+    let attrs = if parse_attrs {\n+        let result = parse_crate_attrs(sess);\n+        match result {\n+            Ok(attrs) => Some(attrs),\n+            Err(mut parse_error) => {\n+                parse_error.emit();\n+                return Compilation::Stop;\n+            }\n+        }\n+    } else {\n+        None\n+    };\n+    for req in &sess.opts.prints {\n+        match *req {\n+            TargetList => {\n+                let mut targets = rustc_target::spec::TARGETS.to_vec();\n+                targets.sort_unstable();\n+                println!(\"{}\", targets.join(\"\\n\"));\n+            }\n+            Sysroot => println!(\"{}\", sess.sysroot.display()),\n+            TargetLibdir => println!(\"{}\", sess.target_tlib_path.dir.display()),\n+            TargetSpec => {\n+                println!(\"{}\", serde_json::to_string_pretty(&sess.target.to_json()).unwrap());\n+            }\n+            FileNames | CrateName => {\n+                let attrs = attrs.as_ref().unwrap();\n+                let t_outputs = rustc_interface::util::build_output_filenames(attrs, sess);\n+                let id = rustc_session::output::find_crate_name(sess, attrs);\n+                if *req == PrintRequest::CrateName {\n+                    println!(\"{id}\");\n+                    continue;\n+                }\n+                let crate_types = collect_crate_types(sess, attrs);\n+                for &style in &crate_types {\n+                    let fname =\n+                        rustc_session::output::filename_for_input(sess, style, id, &t_outputs);\n+                    println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n+                }\n+            }\n+            Cfg => {\n+                let mut cfgs = sess\n+                    .parse_sess\n+                    .config\n+                    .iter()\n+                    .filter_map(|&(name, value)| {\n+                        // Note that crt-static is a specially recognized cfg\n+                        // directive that's printed out here as part of\n+                        // rust-lang/rust#37406, but in general the\n+                        // `target_feature` cfg is gated under\n+                        // rust-lang/rust#29717. For now this is just\n+                        // specifically allowing the crt-static cfg and that's\n+                        // it, this is intended to get into Cargo and then go\n+                        // through to build scripts.\n+                        if (name != sym::target_feature || value != Some(sym::crt_dash_static))\n+                            && !sess.is_nightly_build()\n+                            && find_gated_cfg(|cfg_sym| cfg_sym == name).is_some()\n+                        {\n+                            return None;\n+                        }\n+\n+                        if let Some(value) = value {\n+                            Some(format!(\"{name}=\\\"{value}\\\"\"))\n+                        } else {\n+                            Some(name.to_string())\n+                        }\n+                    })\n+                    .collect::<Vec<String>>();\n+\n+                cfgs.sort();\n+                for cfg in cfgs {\n+                    println!(\"{cfg}\");\n+                }\n+            }\n+            CallingConventions => {\n+                let mut calling_conventions = rustc_target::spec::abi::all_names();\n+                calling_conventions.sort_unstable();\n+                println!(\"{}\", calling_conventions.join(\"\\n\"));\n+            }\n+            RelocationModels\n+            | CodeModels\n+            | TlsModels\n+            | TargetCPUs\n+            | StackProtectorStrategies\n+            | TargetFeatures => {\n+                codegen_backend.print(*req, sess);\n+            }\n+            // Any output here interferes with Cargo's parsing of other printed output\n+            NativeStaticLibs => {}\n+            LinkArgs => {}\n+            SplitDebuginfo => {\n+                use rustc_target::spec::SplitDebuginfo::{Off, Packed, Unpacked};\n+\n+                for split in &[Off, Packed, Unpacked] {\n+                    let stable = sess.target.options.supported_split_debuginfo.contains(split);\n+                    let unstable_ok = sess.unstable_options();\n+                    if stable || unstable_ok {\n+                        println!(\"{split}\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    Compilation::Stop\n+}\n+\n+/// Prints version information\n+///\n+/// NOTE: this is a macro to support drivers built at a different time than the main `rustc_driver` crate.\n+pub macro version($binary: literal, $matches: expr) {\n+    fn unw(x: Option<&str>) -> &str {\n+        x.unwrap_or(\"unknown\")\n+    }\n+    $crate::version_at_macro_invocation(\n+        $binary,\n+        $matches,\n+        unw(option_env!(\"CFG_VERSION\")),\n+        unw(option_env!(\"CFG_VER_HASH\")),\n+        unw(option_env!(\"CFG_VER_DATE\")),\n+        unw(option_env!(\"CFG_RELEASE\")),\n+    )\n+}\n+\n+#[doc(hidden)] // use the macro instead\n+pub fn version_at_macro_invocation(\n+    binary: &str,\n+    matches: &getopts::Matches,\n+    version: &str,\n+    commit_hash: &str,\n+    commit_date: &str,\n+    release: &str,\n+) {\n+    let verbose = matches.opt_present(\"verbose\");\n+\n+    println!(\"{binary} {version}\");\n+\n+    if verbose {\n+        println!(\"binary: {binary}\");\n+        println!(\"commit-hash: {commit_hash}\");\n+        println!(\"commit-date: {commit_date}\");\n+        println!(\"host: {}\", config::host_triple());\n+        println!(\"release: {release}\");\n+\n+        let debug_flags = matches.opt_strs(\"Z\");\n+        let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n+        get_codegen_backend(&None, backend_name).print_version();\n+    }\n+}\n+\n+fn usage(verbose: bool, include_unstable_options: bool, nightly_build: bool) {\n+    let groups = if verbose { config::rustc_optgroups() } else { config::rustc_short_optgroups() };\n+    let mut options = getopts::Options::new();\n+    for option in groups.iter().filter(|x| include_unstable_options || x.is_stable()) {\n+        (option.apply)(&mut options);\n+    }\n+    let message = \"Usage: rustc [OPTIONS] INPUT\";\n+    let nightly_help = if nightly_build {\n+        \"\\n    -Z help             Print unstable compiler options\"\n+    } else {\n+        \"\"\n+    };\n+    let verbose_help = if verbose {\n+        \"\"\n+    } else {\n+        \"\\n    --help -v           Print the full set of options rustc accepts\"\n+    };\n+    let at_path = if verbose {\n+        \"    @path               Read newline separated options from `path`\\n\"\n+    } else {\n+        \"\"\n+    };\n+    println!(\n+        \"{options}{at_path}\\nAdditional help:\n+    -C help             Print codegen options\n+    -W help             \\\n+              Print 'lint' options and default settings{nightly}{verbose}\\n\",\n+        options = options.usage(message),\n+        at_path = at_path,\n+        nightly = nightly_help,\n+        verbose = verbose_help\n+    );\n+}\n+\n+fn print_wall_help() {\n+    println!(\n+        \"\n+The flag `-Wall` does not exist in `rustc`. Most useful lints are enabled by\n+default. Use `rustc -W help` to see all available lints. It's more common to put\n+warning settings in the crate root using `#![warn(LINT_NAME)]` instead of using\n+the command line flag directly.\n+\"\n+    );\n+}\n+\n+/// Write to stdout lint command options, together with a list of all available lints\n+pub fn describe_lints(sess: &Session, lint_store: &LintStore, loaded_plugins: bool) {\n+    println!(\n+        \"\n+Available lint options:\n+    -W <foo>           Warn about <foo>\n+    -A <foo>           \\\n+              Allow <foo>\n+    -D <foo>           Deny <foo>\n+    -F <foo>           Forbid <foo> \\\n+              (deny <foo> and all attempts to override)\n+\n+\"\n+    );\n+\n+    fn sort_lints(sess: &Session, mut lints: Vec<&'static Lint>) -> Vec<&'static Lint> {\n+        // The sort doesn't case-fold but it's doubtful we care.\n+        lints.sort_by_cached_key(|x: &&Lint| (x.default_level(sess.edition()), x.name));\n+        lints\n+    }\n+\n+    fn sort_lint_groups(\n+        lints: Vec<(&'static str, Vec<LintId>, bool)>,\n+    ) -> Vec<(&'static str, Vec<LintId>)> {\n+        let mut lints: Vec<_> = lints.into_iter().map(|(x, y, _)| (x, y)).collect();\n+        lints.sort_by_key(|l| l.0);\n+        lints\n+    }\n+\n+    let (plugin, builtin): (Vec<_>, _) =\n+        lint_store.get_lints().iter().cloned().partition(|&lint| lint.is_plugin);\n+    let plugin = sort_lints(sess, plugin);\n+    let builtin = sort_lints(sess, builtin);\n+\n+    let (plugin_groups, builtin_groups): (Vec<_>, _) =\n+        lint_store.get_lint_groups().partition(|&(.., p)| p);\n+    let plugin_groups = sort_lint_groups(plugin_groups);\n+    let builtin_groups = sort_lint_groups(builtin_groups);\n+\n+    let max_name_len =\n+        plugin.iter().chain(&builtin).map(|&s| s.name.chars().count()).max().unwrap_or(0);\n+    let padded = |x: &str| {\n+        let mut s = \" \".repeat(max_name_len - x.chars().count());\n+        s.push_str(x);\n+        s\n+    };\n+\n+    println!(\"Lint checks provided by rustc:\\n\");\n+\n+    let print_lints = |lints: Vec<&Lint>| {\n+        println!(\"    {}  {:7.7}  {}\", padded(\"name\"), \"default\", \"meaning\");\n+        println!(\"    {}  {:7.7}  {}\", padded(\"----\"), \"-------\", \"-------\");\n+        for lint in lints {\n+            let name = lint.name_lower().replace('_', \"-\");\n+            println!(\n+                \"    {}  {:7.7}  {}\",\n+                padded(&name),\n+                lint.default_level(sess.edition()).as_str(),\n+                lint.desc\n+            );\n+        }\n+        println!(\"\\n\");\n+    };\n+\n+    print_lints(builtin);\n+\n+    let max_name_len = max(\n+        \"warnings\".len(),\n+        plugin_groups\n+            .iter()\n+            .chain(&builtin_groups)\n+            .map(|&(s, _)| s.chars().count())\n+            .max()\n+            .unwrap_or(0),\n+    );\n+\n+    let padded = |x: &str| {\n+        let mut s = \" \".repeat(max_name_len - x.chars().count());\n+        s.push_str(x);\n+        s\n+    };\n+\n+    println!(\"Lint groups provided by rustc:\\n\");\n+\n+    let print_lint_groups = |lints: Vec<(&'static str, Vec<LintId>)>, all_warnings| {\n+        println!(\"    {}  sub-lints\", padded(\"name\"));\n+        println!(\"    {}  ---------\", padded(\"----\"));\n+\n+        if all_warnings {\n+            println!(\"    {}  all lints that are set to issue warnings\", padded(\"warnings\"));\n+        }\n+\n+        for (name, to) in lints {\n+            let name = name.to_lowercase().replace('_', \"-\");\n+            let desc = to\n+                .into_iter()\n+                .map(|x| x.to_string().replace('_', \"-\"))\n+                .collect::<Vec<String>>()\n+                .join(\", \");\n+            println!(\"    {}  {}\", padded(&name), desc);\n+        }\n+        println!(\"\\n\");\n+    };\n+\n+    print_lint_groups(builtin_groups, true);\n+\n+    match (loaded_plugins, plugin.len(), plugin_groups.len()) {\n+        (false, 0, _) | (false, _, 0) => {\n+            println!(\"Lint tools like Clippy can provide additional lints and lint groups.\");\n+        }\n+        (false, ..) => panic!(\"didn't load lint plugins but got them anyway!\"),\n+        (true, 0, 0) => println!(\"This crate does not load any lint plugins or lint groups.\"),\n+        (true, l, g) => {\n+            if l > 0 {\n+                println!(\"Lint checks provided by plugins loaded by this crate:\\n\");\n+                print_lints(plugin);\n+            }\n+            if g > 0 {\n+                println!(\"Lint groups provided by plugins loaded by this crate:\\n\");\n+                print_lint_groups(plugin_groups, false);\n+            }\n+        }\n+    }\n+}\n+\n+fn describe_debug_flags() {\n+    println!(\"\\nAvailable options:\\n\");\n+    print_flag_list(\"-Z\", config::Z_OPTIONS);\n+}\n+\n+fn describe_codegen_flags() {\n+    println!(\"\\nAvailable codegen options:\\n\");\n+    print_flag_list(\"-C\", config::CG_OPTIONS);\n+}\n+\n+pub fn print_flag_list<T>(\n+    cmdline_opt: &str,\n+    flag_list: &[(&'static str, T, &'static str, &'static str)],\n+) {\n+    let max_len = flag_list.iter().map(|&(name, _, _, _)| name.chars().count()).max().unwrap_or(0);\n+\n+    for &(name, _, _, desc) in flag_list {\n+        println!(\n+            \"    {} {:>width$}=val -- {}\",\n+            cmdline_opt,\n+            name.replace('_', \"-\"),\n+            desc,\n+            width = max_len\n+        );\n+    }\n+}\n+\n+/// Process command line options. Emits messages as appropriate. If compilation\n+/// should continue, returns a getopts::Matches object parsed from args,\n+/// otherwise returns `None`.\n+///\n+/// The compiler's handling of options is a little complicated as it ties into\n+/// our stability story. The current intention of each compiler option is to\n+/// have one of two modes:\n+///\n+/// 1. An option is stable and can be used everywhere.\n+/// 2. An option is unstable, and can only be used on nightly.\n+///\n+/// Like unstable library and language features, however, unstable options have\n+/// always required a form of \"opt in\" to indicate that you're using them. This\n+/// provides the easy ability to scan a code base to check to see if anything\n+/// unstable is being used. Currently, this \"opt in\" is the `-Z` \"zed\" flag.\n+///\n+/// All options behind `-Z` are considered unstable by default. Other top-level\n+/// options can also be considered unstable, and they were unlocked through the\n+/// `-Z unstable-options` flag. Note that `-Z` remains to be the root of\n+/// instability in both cases, though.\n+///\n+/// So with all that in mind, the comments below have some more detail about the\n+/// contortions done here to get things to work out correctly.\n+pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n+    // Throw away the first argument, the name of the binary\n+    let args = &args[1..];\n+\n+    if args.is_empty() {\n+        // user did not write `-v` nor `-Z unstable-options`, so do not\n+        // include that extra information.\n+        let nightly_build =\n+            rustc_feature::UnstableFeatures::from_environment(None).is_nightly_build();\n+        usage(false, false, nightly_build);\n+        return None;\n+    }\n+\n+    // Parse with *all* options defined in the compiler, we don't worry about\n+    // option stability here we just want to parse as much as possible.\n+    let mut options = getopts::Options::new();\n+    for option in config::rustc_optgroups() {\n+        (option.apply)(&mut options);\n+    }\n+    let matches = options.parse(args).unwrap_or_else(|e| {\n+        let msg = match e {\n+            getopts::Fail::UnrecognizedOption(ref opt) => CG_OPTIONS\n+                .iter()\n+                .map(|&(name, ..)| ('C', name))\n+                .chain(Z_OPTIONS.iter().map(|&(name, ..)| ('Z', name)))\n+                .find(|&(_, name)| *opt == name.replace('_', \"-\"))\n+                .map(|(flag, _)| format!(\"{e}. Did you mean `-{flag} {opt}`?\")),\n+            _ => None,\n+        };\n+        early_error(ErrorOutputType::default(), &msg.unwrap_or_else(|| e.to_string()));\n+    });\n+\n+    // For all options we just parsed, we check a few aspects:\n+    //\n+    // * If the option is stable, we're all good\n+    // * If the option wasn't passed, we're all good\n+    // * If `-Z unstable-options` wasn't passed (and we're not a -Z option\n+    //   ourselves), then we require the `-Z unstable-options` flag to unlock\n+    //   this option that was passed.\n+    // * If we're a nightly compiler, then unstable options are now unlocked, so\n+    //   we're good to go.\n+    // * Otherwise, if we're an unstable option then we generate an error\n+    //   (unstable option being used on stable)\n+    nightly_options::check_nightly_options(&matches, &config::rustc_optgroups());\n+\n+    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n+        // Only show unstable options in --help if we accept unstable options.\n+        let unstable_enabled = nightly_options::is_unstable_enabled(&matches);\n+        let nightly_build = nightly_options::match_is_nightly_build(&matches);\n+        usage(matches.opt_present(\"verbose\"), unstable_enabled, nightly_build);\n+        return None;\n+    }\n+\n+    // Handle the special case of -Wall.\n+    let wall = matches.opt_strs(\"W\");\n+    if wall.iter().any(|x| *x == \"all\") {\n+        print_wall_help();\n+        rustc_errors::FatalError.raise();\n+    }\n+\n+    // Don't handle -W help here, because we might first load plugins.\n+    let debug_flags = matches.opt_strs(\"Z\");\n+    if debug_flags.iter().any(|x| *x == \"help\") {\n+        describe_debug_flags();\n+        return None;\n+    }\n+\n+    let cg_flags = matches.opt_strs(\"C\");\n+\n+    if cg_flags.iter().any(|x| *x == \"help\") {\n+        describe_codegen_flags();\n+        return None;\n+    }\n+\n+    if cg_flags.iter().any(|x| *x == \"no-stack-check\") {\n+        early_warn(\n+            ErrorOutputType::default(),\n+            \"the --no-stack-check flag is deprecated and does nothing\",\n+        );\n+    }\n+\n+    if cg_flags.iter().any(|x| *x == \"passes=list\") {\n+        let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n+        get_codegen_backend(&None, backend_name).print_passes();\n+        return None;\n+    }\n+\n+    if matches.opt_present(\"version\") {\n+        version!(\"rustc\", &matches);\n+        return None;\n+    }\n+\n+    Some(matches)\n+}\n+\n+fn parse_crate_attrs<'a>(sess: &'a Session) -> PResult<'a, ast::AttrVec> {\n+    match &sess.io.input {\n+        Input::File(ifile) => rustc_parse::parse_crate_attrs_from_file(ifile, &sess.parse_sess),\n+        Input::Str { name, input } => rustc_parse::parse_crate_attrs_from_source_str(\n+            name.clone(),\n+            input.clone(),\n+            &sess.parse_sess,\n+        ),\n+    }\n+}\n+\n+/// Gets a list of extra command-line flags provided by the user, as strings.\n+///\n+/// This function is used during ICEs to show more information useful for\n+/// debugging, since some ICEs only happens with non-default compiler flags\n+/// (and the users don't always report them).\n+fn extra_compiler_flags() -> Option<(Vec<String>, bool)> {\n+    let mut args = env::args_os().map(|arg| arg.to_string_lossy().to_string()).peekable();\n+\n+    let mut result = Vec::new();\n+    let mut excluded_cargo_defaults = false;\n+    while let Some(arg) = args.next() {\n+        if let Some(a) = ICE_REPORT_COMPILER_FLAGS.iter().find(|a| arg.starts_with(*a)) {\n+            let content = if arg.len() == a.len() {\n+                // A space-separated option, like `-C incremental=foo` or `--crate-type rlib`\n+                match args.next() {\n+                    Some(arg) => arg.to_string(),\n+                    None => continue,\n+                }\n+            } else if arg.get(a.len()..a.len() + 1) == Some(\"=\") {\n+                // An equals option, like `--crate-type=rlib`\n+                arg[a.len() + 1..].to_string()\n+            } else {\n+                // A non-space option, like `-Cincremental=foo`\n+                arg[a.len()..].to_string()\n+            };\n+            let option = content.split_once('=').map(|s| s.0).unwrap_or(&content);\n+            if ICE_REPORT_COMPILER_FLAGS_EXCLUDE.iter().any(|exc| option == *exc) {\n+                excluded_cargo_defaults = true;\n+            } else {\n+                result.push(a.to_string());\n+                match ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE.iter().find(|s| option == **s) {\n+                    Some(s) => result.push(format!(\"{s}=[REDACTED]\")),\n+                    None => result.push(content),\n+                }\n+            }\n+        }\n+    }\n+\n+    if !result.is_empty() { Some((result, excluded_cargo_defaults)) } else { None }\n+}\n+\n+/// Runs a closure and catches unwinds triggered by fatal errors.\n+///\n+/// The compiler currently unwinds with a special sentinel value to abort\n+/// compilation on fatal errors. This function catches that sentinel and turns\n+/// the panic into a `Result` instead.\n+pub fn catch_fatal_errors<F: FnOnce() -> R, R>(f: F) -> Result<R, ErrorGuaranteed> {\n+    catch_unwind(panic::AssertUnwindSafe(f)).map_err(|value| {\n+        if value.is::<rustc_errors::FatalErrorMarker>() {\n+            ErrorGuaranteed::unchecked_claim_error_was_emitted()\n+        } else {\n+            panic::resume_unwind(value);\n+        }\n+    })\n+}\n+\n+/// Variant of `catch_fatal_errors` for the `interface::Result` return type\n+/// that also computes the exit code.\n+pub fn catch_with_exit_code(f: impl FnOnce() -> interface::Result<()>) -> i32 {\n+    let result = catch_fatal_errors(f).and_then(|result| result);\n+    match result {\n+        Ok(()) => EXIT_SUCCESS,\n+        Err(_) => EXIT_FAILURE,\n+    }\n+}\n+\n+static DEFAULT_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> =\n+    LazyLock::new(|| {\n+        let hook = panic::take_hook();\n+        panic::set_hook(Box::new(|info| {\n+            // If the error was caused by a broken pipe then this is not a bug.\n+            // Write the error and return immediately. See #98700.\n+            #[cfg(windows)]\n+            if let Some(msg) = info.payload().downcast_ref::<String>() {\n+                if msg.starts_with(\"failed printing to stdout: \") && msg.ends_with(\"(os error 232)\")\n+                {\n+                    early_error_no_abort(ErrorOutputType::default(), &msg);\n+                    return;\n+                }\n+            };\n+\n+            // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n+            // Don't do this for delayed bugs, which already emit their own more useful backtrace.\n+            if !info.payload().is::<rustc_errors::DelayedBugPanic>() {\n+                (*DEFAULT_HOOK)(info);\n+\n+                // Separate the output with an empty line\n+                eprintln!();\n+            }\n+\n+            // Print the ICE message\n+            report_ice(info, BUG_REPORT_URL);\n+        }));\n+        hook\n+    });\n+\n+/// Prints the ICE message, including query stack, but without backtrace.\n+///\n+/// The message will point the user at `bug_report_url` to report the ICE.\n+///\n+/// When `install_ice_hook` is called, this function will be called as the panic\n+/// hook.\n+pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n+    let fallback_bundle =\n+        rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n+    let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n+        rustc_errors::ColorConfig::Auto,\n+        None,\n+        None,\n+        fallback_bundle,\n+        false,\n+        false,\n+        None,\n+        false,\n+        false,\n+    ));\n+    let handler = rustc_errors::Handler::with_emitter(true, None, emitter);\n+\n+    // a .span_bug or .bug call has already printed what\n+    // it wants to print.\n+    if !info.payload().is::<rustc_errors::ExplicitBug>()\n+        && !info.payload().is::<rustc_errors::DelayedBugPanic>()\n+    {\n+        let mut d = rustc_errors::Diagnostic::new(rustc_errors::Level::Bug, \"unexpected panic\");\n+        handler.emit_diagnostic(&mut d);\n+    }\n+\n+    handler.emit_note(session_diagnostics::Ice);\n+    handler.emit_note(session_diagnostics::IceBugReport { bug_report_url });\n+    handler.emit_note(session_diagnostics::IceVersion {\n+        version: util::version_str!().unwrap_or(\"unknown_version\"),\n+        triple: config::host_triple(),\n+    });\n+\n+    if let Some((flags, excluded_cargo_defaults)) = extra_compiler_flags() {\n+        handler.emit_note(session_diagnostics::IceFlags { flags: flags.join(\" \") });\n+        if excluded_cargo_defaults {\n+            handler.emit_note(session_diagnostics::IceExcludeCargoDefaults);\n+        }\n+    }\n+\n+    // If backtraces are enabled, also print the query stack\n+    let backtrace = env::var_os(\"RUST_BACKTRACE\").map_or(false, |x| &x != \"0\");\n+\n+    let num_frames = if backtrace { None } else { Some(2) };\n+\n+    interface::try_print_query_stack(&handler, num_frames);\n+\n+    #[cfg(windows)]\n+    unsafe {\n+        if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n+            // Trigger a debugger if we crashed during bootstrap\n+            winapi::um::debugapi::DebugBreak();\n+        }\n+    }\n+}\n+\n+/// Installs a panic hook that will print the ICE message on unexpected panics.\n+///\n+/// A custom rustc driver can skip calling this to set up a custom ICE hook.\n+pub fn install_ice_hook() {\n+    // If the user has not explicitly overridden \"RUST_BACKTRACE\", then produce\n+    // full backtraces. When a compiler ICE happens, we want to gather\n+    // as much information as possible to present in the issue opened\n+    // by the user. Compiler developers and other rustc users can\n+    // opt in to less-verbose backtraces by manually setting \"RUST_BACKTRACE\"\n+    // (e.g. `RUST_BACKTRACE=1`)\n+    if std::env::var(\"RUST_BACKTRACE\").is_err() {\n+        std::env::set_var(\"RUST_BACKTRACE\", \"full\");\n+    }\n+    LazyLock::force(&DEFAULT_HOOK);\n+}\n+\n+/// This allows tools to enable rust logging without having to magically match rustc's\n+/// tracing crate version.\n+pub fn init_rustc_env_logger() {\n+    init_rustc_env_logger_with_backtrace_option(&None);\n+}\n+\n+/// This allows tools to enable rust logging without having to magically match rustc's\n+/// tracing crate version. In contrast to `init_rustc_env_logger` it allows you to\n+/// choose a target module you wish to show backtraces along with its logging.\n+pub fn init_rustc_env_logger_with_backtrace_option(backtrace_target: &Option<String>) {\n+    if let Err(error) = rustc_log::init_rustc_env_logger_with_backtrace_option(backtrace_target) {\n+        early_error(ErrorOutputType::default(), &error.to_string());\n+    }\n+}\n+\n+/// This allows tools to enable rust logging without having to magically match rustc's\n+/// tracing crate version. In contrast to `init_rustc_env_logger` it allows you to choose an env var\n+/// other than `RUSTC_LOG`.\n+pub fn init_env_logger(env: &str) {\n+    if let Err(error) = rustc_log::init_env_logger(env) {\n+        early_error(ErrorOutputType::default(), &error.to_string());\n+    }\n+}\n+\n+#[cfg(all(unix, any(target_env = \"gnu\", target_os = \"macos\")))]\n+mod signal_handler {\n+    extern \"C\" {\n+        fn backtrace_symbols_fd(\n+            buffer: *const *mut libc::c_void,\n+            size: libc::c_int,\n+            fd: libc::c_int,\n+        );\n+    }\n+\n+    extern \"C\" fn print_stack_trace(_: libc::c_int) {\n+        const MAX_FRAMES: usize = 256;\n+        static mut STACK_TRACE: [*mut libc::c_void; MAX_FRAMES] =\n+            [std::ptr::null_mut(); MAX_FRAMES];\n+        unsafe {\n+            let depth = libc::backtrace(STACK_TRACE.as_mut_ptr(), MAX_FRAMES as i32);\n+            if depth == 0 {\n+                return;\n+            }\n+            backtrace_symbols_fd(STACK_TRACE.as_ptr(), depth, 2);\n+        }\n+    }\n+\n+    /// When an error signal (such as SIGABRT or SIGSEGV) is delivered to the\n+    /// process, print a stack trace and then exit.\n+    pub(super) fn install() {\n+        unsafe {\n+            const ALT_STACK_SIZE: usize = libc::MINSIGSTKSZ + 64 * 1024;\n+            let mut alt_stack: libc::stack_t = std::mem::zeroed();\n+            alt_stack.ss_sp =\n+                std::alloc::alloc(std::alloc::Layout::from_size_align(ALT_STACK_SIZE, 1).unwrap())\n+                    as *mut libc::c_void;\n+            alt_stack.ss_size = ALT_STACK_SIZE;\n+            libc::sigaltstack(&alt_stack, std::ptr::null_mut());\n+\n+            let mut sa: libc::sigaction = std::mem::zeroed();\n+            sa.sa_sigaction = print_stack_trace as libc::sighandler_t;\n+            sa.sa_flags = libc::SA_NODEFER | libc::SA_RESETHAND | libc::SA_ONSTACK;\n+            libc::sigemptyset(&mut sa.sa_mask);\n+            libc::sigaction(libc::SIGSEGV, &sa, std::ptr::null_mut());\n+        }\n+    }\n+}\n+\n+#[cfg(not(all(unix, any(target_env = \"gnu\", target_os = \"macos\"))))]\n+mod signal_handler {\n+    pub(super) fn install() {}\n+}\n+\n+pub fn main() -> ! {\n+    let start_time = Instant::now();\n+    let start_rss = get_resident_set_size();\n+    signal_handler::install();\n+    let mut callbacks = TimePassesCallbacks::default();\n+    install_ice_hook();\n+    let exit_code = catch_with_exit_code(|| {\n+        let args = env::args_os()\n+            .enumerate()\n+            .map(|(i, arg)| {\n+                arg.into_string().unwrap_or_else(|arg| {\n+                    early_error(\n+                        ErrorOutputType::default(),\n+                        &format!(\"argument {i} is not valid Unicode: {arg:?}\"),\n+                    )\n+                })\n+            })\n+            .collect::<Vec<_>>();\n+        RunCompiler::new(&args, &mut callbacks).run()\n+    });\n+\n+    if callbacks.time_passes {\n+        let end_rss = get_resident_set_size();\n+        print_time_passes_entry(\"total\", start_time.elapsed(), start_rss, end_rss);\n+    }\n+\n+    process::exit(exit_code)\n+}"}, {"sha": "446c6832cb7b607657a23a63e4c628d0123867cc", "filename": "compiler/rustc_driver_impl/src/pretty.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver_impl%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver_impl%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Fpretty.rs?ref=3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "previous_filename": "compiler/rustc_driver/src/pretty.rs"}, {"sha": "638b368f702145586b9ca3e109fa2d261944b56e", "filename": "compiler/rustc_driver_impl/src/session_diagnostics.rs", "status": "renamed", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver_impl%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_driver_impl%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Fsession_diagnostics.rs?ref=3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "patch": "@@ -1,67 +1,67 @@\n use rustc_macros::Diagnostic;\n \n #[derive(Diagnostic)]\n-#[diag(driver_rlink_unable_to_read)]\n+#[diag(driver_impl_rlink_unable_to_read)]\n pub(crate) struct RlinkUnableToRead {\n     pub err: std::io::Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver_rlink_wrong_file_type)]\n+#[diag(driver_impl_rlink_wrong_file_type)]\n pub(crate) struct RLinkWrongFileType;\n \n #[derive(Diagnostic)]\n-#[diag(driver_rlink_empty_version_number)]\n+#[diag(driver_impl_rlink_empty_version_number)]\n pub(crate) struct RLinkEmptyVersionNumber;\n \n #[derive(Diagnostic)]\n-#[diag(driver_rlink_encoding_version_mismatch)]\n+#[diag(driver_impl_rlink_encoding_version_mismatch)]\n pub(crate) struct RLinkEncodingVersionMismatch {\n     pub version_array: String,\n     pub rlink_version: u32,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver_rlink_rustc_version_mismatch)]\n+#[diag(driver_impl_rlink_rustc_version_mismatch)]\n pub(crate) struct RLinkRustcVersionMismatch<'a> {\n     pub rustc_version: String,\n     pub current_version: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver_rlink_no_a_file)]\n+#[diag(driver_impl_rlink_no_a_file)]\n pub(crate) struct RlinkNotAFile;\n \n #[derive(Diagnostic)]\n-#[diag(driver_unpretty_dump_fail)]\n+#[diag(driver_impl_unpretty_dump_fail)]\n pub(crate) struct UnprettyDumpFail {\n     pub path: String,\n     pub err: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver_ice)]\n+#[diag(driver_impl_ice)]\n pub(crate) struct Ice;\n \n #[derive(Diagnostic)]\n-#[diag(driver_ice_bug_report)]\n+#[diag(driver_impl_ice_bug_report)]\n pub(crate) struct IceBugReport<'a> {\n     pub bug_report_url: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver_ice_version)]\n+#[diag(driver_impl_ice_version)]\n pub(crate) struct IceVersion<'a> {\n     pub version: &'a str,\n     pub triple: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver_ice_flags)]\n+#[diag(driver_impl_ice_flags)]\n pub(crate) struct IceFlags {\n     pub flags: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver_ice_exclude_cargo_defaults)]\n+#[diag(driver_impl_ice_exclude_cargo_defaults)]\n pub(crate) struct IceExcludeCargoDefaults;", "previous_filename": "compiler/rustc_driver/src/session_diagnostics.rs"}, {"sha": "f19b1ff6426177c16eb24dd9093bfa268cb21464", "filename": "compiler/rustc_error_messages/locales/en-US/driver.ftl", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3de7d7fb22a579a3d59ddb1c959d1b3da224aafa/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl?ref=3de7d7fb22a579a3d59ddb1c959d1b3da224aafa", "patch": "@@ -1,19 +1,19 @@\n-driver_rlink_unable_to_read = failed to read rlink file: `{$err}`\n+driver_impl_rlink_unable_to_read = failed to read rlink file: `{$err}`\n \n-driver_rlink_wrong_file_type = The input does not look like a .rlink file\n+driver_impl_rlink_wrong_file_type = The input does not look like a .rlink file\n \n-driver_rlink_empty_version_number = The input does not contain version number\n+driver_impl_rlink_empty_version_number = The input does not contain version number\n \n-driver_rlink_encoding_version_mismatch = .rlink file was produced with encoding version `{$version_array}`, but the current version is `{$rlink_version}`\n+driver_impl_rlink_encoding_version_mismatch = .rlink file was produced with encoding version `{$version_array}`, but the current version is `{$rlink_version}`\n \n-driver_rlink_rustc_version_mismatch = .rlink file was produced by rustc version `{$rustc_version}`, but the current version is `{$current_version}`\n+driver_impl_rlink_rustc_version_mismatch = .rlink file was produced by rustc version `{$rustc_version}`, but the current version is `{$current_version}`\n \n-driver_rlink_no_a_file = rlink must be a file\n+driver_impl_rlink_no_a_file = rlink must be a file\n \n-driver_unpretty_dump_fail = pretty-print failed to write `{$path}` due to error `{$err}`\n+driver_impl_unpretty_dump_fail = pretty-print failed to write `{$path}` due to error `{$err}`\n \n-driver_ice = the compiler unexpectedly panicked. this is a bug.\n-driver_ice_bug_report = we would appreciate a bug report: {$bug_report_url}\n-driver_ice_version = rustc {$version} running on {$triple}\n-driver_ice_flags = compiler flags: {$flags}\n-driver_ice_exclude_cargo_defaults = some of the compiler flags provided by cargo are hidden\n+driver_impl_ice = the compiler unexpectedly panicked. this is a bug.\n+driver_impl_ice_bug_report = we would appreciate a bug report: {$bug_report_url}\n+driver_impl_ice_version = rustc {$version} running on {$triple}\n+driver_impl_ice_flags = compiler flags: {$flags}\n+driver_impl_ice_exclude_cargo_defaults = some of the compiler flags provided by cargo are hidden"}]}