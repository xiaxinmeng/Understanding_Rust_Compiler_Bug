{"sha": "8877b81f2cccfbbd6720e9ef81a8238fd188a63e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NzdiODFmMmNjY2ZiYmQ2NzIwZTllZjgxYTgyMzhmZDE4OGE2M2U=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-06-30T17:19:02Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-03T17:55:14Z"}, "message": "Add os::join_paths, make setenv non-utf8 capable\n\nThis commit changes `os` in three ways:\n\n* It adds a `join_paths` function that is the converse to `split_paths`,\n  easing manipulation of the `PATH` environment variable according to\n  platform conventions.\n\n* **Breaking change**: It changes `split_paths` to no longer drop empty paths, since they are\n  meaningful to some shells (where they are synonymous with the current\n  working directory).\n\n* It changes `setenv` to take a `BytesContainer` rather than a `&str`\n  value, since environment variables may have non-utf8 values on some\n  platforms. Since `&str` is a `BytesContainer`, this is *not* a\n  breaking change.\n\nAlong the way, it also refactors the `split_paths` function so that\n`cfg` switches are applied internally (and the function header is given\nonly once). This fixes a bug: the doc comment had an example for only\none platform.\n\n[breaking-change]", "tree": {"sha": "cf51ee49c428ea4f348855fb24372436b37623e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf51ee49c428ea4f348855fb24372436b37623e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8877b81f2cccfbbd6720e9ef81a8238fd188a63e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8877b81f2cccfbbd6720e9ef81a8238fd188a63e", "html_url": "https://github.com/rust-lang/rust/commit/8877b81f2cccfbbd6720e9ef81a8238fd188a63e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8877b81f2cccfbbd6720e9ef81a8238fd188a63e/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "748b9477f8b0c0fdbb3a45a83bf6f26b5b6c3378", "url": "https://api.github.com/repos/rust-lang/rust/commits/748b9477f8b0c0fdbb3a45a83bf6f26b5b6c3378", "html_url": "https://github.com/rust-lang/rust/commit/748b9477f8b0c0fdbb3a45a83bf6f26b5b6c3378"}], "stats": {"total": 207, "additions": 147, "deletions": 60}, "files": [{"sha": "c69209acbdd912785a853be4843987eb4c5ef6c5", "filename": "src/libstd/os.rs", "status": "modified", "additions": 147, "deletions": 60, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/8877b81f2cccfbbd6720e9ef81a8238fd188a63e/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8877b81f2cccfbbd6720e9ef81a8238fd188a63e/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=8877b81f2cccfbbd6720e9ef81a8238fd188a63e", "patch": "@@ -45,7 +45,7 @@ use path::{Path, GenericPath, BytesContainer};\n use ptr::RawPtr;\n use ptr;\n use result::{Err, Ok, Result};\n-use slice::{Vector, ImmutableVector, MutableVector};\n+use slice::{Vector, ImmutableVector, MutableVector, ImmutableEqVector};\n use str::{Str, StrSlice, StrAllocating};\n use str;\n use string::String;\n@@ -398,9 +398,9 @@ pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n ///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n-pub fn setenv(n: &str, v: &str) {\n+pub fn setenv<T: BytesContainer>(n: &str, v: T) {\n     #[cfg(unix)]\n-    fn _setenv(n: &str, v: &str) {\n+    fn _setenv(n: &str, v: &[u8]) {\n         unsafe {\n             with_env_lock(|| {\n                 n.with_c_str(|nbuf| {\n@@ -413,18 +413,20 @@ pub fn setenv(n: &str, v: &str) {\n     }\n \n     #[cfg(windows)]\n-    fn _setenv(n: &str, v: &str) {\n+    fn _setenv(n: &str, v: &[u8]) {\n         let n: Vec<u16> = n.utf16_units().collect();\n         let n = n.append_one(0);\n-        let v: Vec<u16> = v.utf16_units().collect();\n+        let v: Vec<u16> = str::from_utf8(v).unwrap().utf16_units().collect();\n         let v = v.append_one(0);\n+\n         unsafe {\n             with_env_lock(|| {\n                 libc::SetEnvironmentVariableW(n.as_ptr(), v.as_ptr());\n             })\n         }\n     }\n-    _setenv(n, v)\n+\n+    _setenv(n, v.container_as_bytes())\n }\n \n /// Remove a variable from the environment entirely.\n@@ -453,17 +455,15 @@ pub fn unsetenv(n: &str) {\n     _unsetenv(n);\n }\n \n-#[cfg(unix)]\n-/// Parse a string or vector according to the platform's conventions\n-/// for the `PATH` environment variable and return a Vec<Path>.\n-/// Drops empty paths.\n+/// Parses input according to platform conventions for the `PATH`\n+/// environment variable.\n ///\n /// # Example\n /// ```rust\n /// use std::os;\n ///\n /// let key = \"PATH\";\n-/// match os::getenv(key) {\n+/// match os::getenv_as_bytes(key) {\n ///     Some(paths) => {\n ///         for path in os::split_paths(paths).iter() {\n ///             println!(\"'{}'\", path.display());\n@@ -473,57 +473,112 @@ pub fn unsetenv(n: &str) {\n /// }\n /// ```\n pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n-    unparsed.container_as_bytes()\n-            .split(|b| *b == ':' as u8)\n-            .filter(|s| s.len() > 0)\n-            .map(Path::new)\n-            .collect()\n-}\n+    #[cfg(unix)]\n+    fn _split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n+        unparsed.container_as_bytes()\n+                .split(|b| *b == b':')\n+                .map(Path::new)\n+                .collect()\n+    }\n \n-#[cfg(windows)]\n-/// Parse a string or vector according to the platform's conventions\n-/// for the `PATH` environment variable. Drops empty paths.\n-pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n-    // On Windows, the PATH environment variable is semicolon separated.  Double\n-    // quotes are used as a way of introducing literal semicolons (since\n-    // c:\\some;dir is a valid Windows path). Double quotes are not themselves\n-    // permitted in path names, so there is no way to escape a double quote.\n-    // Quoted regions can appear in arbitrary locations, so\n-    //\n-    //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n-    //\n-    // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n-    //\n-    // (The above is based on testing; there is no clear reference available\n-    // for the grammar.)\n-\n-    let mut parsed = Vec::new();\n-    let mut in_progress = Vec::new();\n-    let mut in_quote = false;\n-\n-    for b in unparsed.container_as_bytes().iter() {\n-        match *b as char {\n-            ';' if !in_quote => {\n-                // ignore zero-length path strings\n-                if in_progress.len() > 0 {\n+    #[cfg(windows)]\n+    pub fn _split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n+        // On Windows, the PATH environment variable is semicolon separated.  Double\n+        // quotes are used as a way of introducing literal semicolons (since\n+        // c:\\some;dir is a valid Windows path). Double quotes are not themselves\n+        // permitted in path names, so there is no way to escape a double quote.\n+        // Quoted regions can appear in arbitrary locations, so\n+        //\n+        //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n+        //\n+        // Should parse as [c:\\foo, c:\\some;dir, c:\\bar].\n+        //\n+        // (The above is based on testing; there is no clear reference available\n+        // for the grammar.)\n+\n+        let mut parsed = Vec::new();\n+        let mut in_progress = Vec::new();\n+        let mut in_quote = false;\n+\n+        for b in unparsed.container_as_bytes().iter() {\n+            match *b {\n+                b';' if !in_quote => {\n                     parsed.push(Path::new(in_progress.as_slice()));\n+                    in_progress.truncate(0)\n+                }\n+                b'\"' => {\n+                    in_quote = !in_quote;\n+                }\n+                _  => {\n+                    in_progress.push(*b);\n                 }\n-                in_progress.truncate(0)\n-            }\n-            '\\\"' => {\n-                in_quote = !in_quote;\n             }\n-            _  => {\n-                in_progress.push(*b);\n+        }\n+        parsed.push(Path::new(in_progress));\n+        parsed\n+    }\n+\n+    _split_paths(unparsed)\n+}\n+\n+/// Joins a collection of `Path`s appropriately for the `PATH`\n+/// environment variable.\n+///\n+/// Returns a `Vec<u8>` on success, since `Path`s are not utf-8\n+/// encoded on all platforms.\n+///\n+/// Returns an `Err` (containing an error message) if one of the input\n+/// `Path`s contains an invalid character for constructing the `PATH`\n+/// variable (a double quote on Windows or a colon on Unix).\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::os;\n+/// use std::path::Path;\n+///\n+/// let key = \"PATH\";\n+/// let mut paths = os::getenv_as_bytes(key).map_or(Vec::new(), os::split_paths);\n+/// paths.push(Path::new(\"/home/xyz/bin\"));\n+/// os::setenv(key, os::join_paths(paths.as_slice()).unwrap());\n+/// ```\n+pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n+    #[cfg(windows)]\n+    fn _join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n+        let mut joined = Vec::new();\n+        let sep = b';';\n+\n+        for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n+            if i > 0 { joined.push(sep) }\n+            if path.contains(&b'\"') {\n+                return Err(\"path segment contains `\\\"`\");\n+            } else if path.contains(&sep) {\n+                joined.push(b'\"');\n+                joined.push_all(path);\n+                joined.push(b'\"');\n+            } else {\n+                joined.push_all(path);\n             }\n         }\n+\n+        Ok(joined)\n     }\n \n-    if in_progress.len() > 0 {\n-        parsed.push(Path::new(in_progress));\n+    #[cfg(unix)]\n+    fn _join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n+        let mut joined = Vec::new();\n+        let sep = b':';\n+\n+        for (i, path) in paths.iter().map(|p| p.container_as_bytes()).enumerate() {\n+            if i > 0 { joined.push(sep) }\n+            if path.contains(&sep) { return Err(\"path segment contains separator `:`\") }\n+            joined.push_all(path);\n+        }\n+\n+        Ok(joined)\n     }\n \n-    parsed\n+    _join_paths(paths)\n }\n \n /// A low-level OS in-memory pipe.\n@@ -1767,7 +1822,7 @@ mod tests {\n     use c_str::ToCStr;\n     use option;\n     use os::{env, getcwd, getenv, make_absolute};\n-    use os::{split_paths, setenv, unsetenv};\n+    use os::{split_paths, join_paths, setenv, unsetenv};\n     use os;\n     use rand::Rng;\n     use rand;\n@@ -2032,11 +2087,11 @@ mod tests {\n                 parsed.iter().map(|s| Path::new(*s)).collect()\n         }\n \n-        assert!(check_parse(\"\", []));\n-        assert!(check_parse(r#\"\"\"\"#, []));\n-        assert!(check_parse(\";;\", []));\n+        assert!(check_parse(\"\", [\"\"]));\n+        assert!(check_parse(r#\"\"\"\"#, [\"\"]));\n+        assert!(check_parse(\";;\", [\"\", \"\", \"\"]));\n         assert!(check_parse(r\"c:\\\", [r\"c:\\\"]));\n-        assert!(check_parse(r\"c:\\;\", [r\"c:\\\"]));\n+        assert!(check_parse(r\"c:\\;\", [r\"c:\\\", \"\"]));\n         assert!(check_parse(r\"c:\\;c:\\Program Files\\\",\n                             [r\"c:\\\", r\"c:\\Program Files\\\"]));\n         assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, [r\"c:\\\", r\"c:\\foo\\\"]));\n@@ -2052,12 +2107,44 @@ mod tests {\n                 parsed.iter().map(|s| Path::new(*s)).collect()\n         }\n \n-        assert!(check_parse(\"\", []));\n-        assert!(check_parse(\"::\", []));\n+        assert!(check_parse(\"\", [\"\"]));\n+        assert!(check_parse(\"::\", [\"\", \"\", \"\"]));\n         assert!(check_parse(\"/\", [\"/\"]));\n-        assert!(check_parse(\"/:\", [\"/\"]));\n+        assert!(check_parse(\"/:\", [\"/\", \"\"]));\n         assert!(check_parse(\"/:/usr/local\", [\"/\", \"/usr/local\"]));\n     }\n \n+    #[test]\n+    #[cfg(unix)]\n+    fn join_paths_unix() {\n+        fn test_eq(input: &[&str], output: &str) -> bool {\n+            join_paths(input).unwrap().as_slice() == output.as_bytes()\n+        }\n+\n+        assert!(test_eq([], \"\"));\n+        assert!(test_eq([\"/bin\", \"/usr/bin\", \"/usr/local/bin\"],\n+                        \"/bin:/usr/bin:/usr/local/bin\"));\n+        assert!(test_eq([\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"],\n+                        \":/bin:::/usr/bin:\"));\n+        assert!(join_paths([\"/te:st\"]).is_err());\n+    }\n+\n+    #[test]\n+    #[cfg(windows)]\n+    fn join_paths_windows() {\n+        fn test_eq(input: &[&str], output: &str) -> bool {\n+            join_paths(input).unwrap().as_slice() == output.as_bytes()\n+        }\n+\n+        assert!(test_eq([], \"\"));\n+        assert!(test_eq([r\"c:\\windows\", r\"c:\\\"],\n+                        r\"c:\\windows;c:\\\"));\n+        assert!(test_eq([\"\", r\"c:\\windows\", \"\", \"\", r\"c:\\\", \"\"],\n+                        r\";c:\\windows;;;c:\\;\"));\n+        assert!(test_eq([r\"c:\\te;st\", r\"c:\\\"],\n+                        r#\"\"c:\\te;st\";c:\\\"#));\n+        assert!(join_paths([r#\"c:\\te\"st\"#]).is_err());\n+    }\n+\n     // More recursive_mkdir tests are in extra::tempfile\n }"}]}