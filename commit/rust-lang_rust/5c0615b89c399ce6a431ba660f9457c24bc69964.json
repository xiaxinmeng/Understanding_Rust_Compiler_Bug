{"sha": "5c0615b89c399ce6a431ba660f9457c24bc69964", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMDYxNWI4OWMzOTljZTZhNDMxYmE2NjBmOTQ1N2MyNGJjNjk5NjQ=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-02-16T19:51:43Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-03-04T16:13:50Z"}, "message": "Use early unwraps instead of bubbling up errors just to unwrap in the end", "tree": {"sha": "5b8fa8ae1d7ad45f5cf085b7a81f0690bfc84508", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b8fa8ae1d7ad45f5cf085b7a81f0690bfc84508"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c0615b89c399ce6a431ba660f9457c24bc69964", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c0615b89c399ce6a431ba660f9457c24bc69964", "html_url": "https://github.com/rust-lang/rust/commit/5c0615b89c399ce6a431ba660f9457c24bc69964", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c0615b89c399ce6a431ba660f9457c24bc69964/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9da8fc9c267c08cfdb8cf5b39da14f154d12939", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9da8fc9c267c08cfdb8cf5b39da14f154d12939", "html_url": "https://github.com/rust-lang/rust/commit/a9da8fc9c267c08cfdb8cf5b39da14f154d12939"}], "stats": {"total": 74, "additions": 30, "deletions": 44}, "files": [{"sha": "349c9132842b893947cd5434e4edc2f364d68d47", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c0615b89c399ce6a431ba660f9457c24bc69964/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c0615b89c399ce6a431ba660f9457c24bc69964/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=5c0615b89c399ce6a431ba660f9457c24bc69964", "patch": "@@ -49,36 +49,36 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         constant: Result<ty::Const<'tcx>, ErrorHandled>,\n     ) -> (Bx::Value, Ty<'tcx>) {\n         constant\n-            .and_then(|c| {\n+            .map(|c| {\n                 let field_ty = c.ty.builtin_index().unwrap();\n                 let fields = match c.ty.sty {\n                     ty::Array(_, n) => n.unwrap_usize(bx.tcx()),\n                     ref other => bug!(\"invalid simd shuffle type: {}\", other),\n                 };\n-                let values: Result<Vec<_>, ErrorHandled> = (0..fields).map(|field| {\n+                let values: Vec<_> = (0..fields).map(|field| {\n                     let field = const_field(\n                         bx.tcx(),\n                         ty::ParamEnv::reveal_all(),\n                         None,\n                         mir::Field::new(field as usize),\n                         c,\n-                    )?;\n+                    );\n                     if let Some(prim) = field.val.try_to_scalar() {\n                         let layout = bx.layout_of(field_ty);\n                         let scalar = match layout.abi {\n                             layout::Abi::Scalar(ref x) => x,\n                             _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n                         };\n-                        Ok(bx.scalar_to_backend(\n+                        bx.scalar_to_backend(\n                             prim, scalar,\n                             bx.immediate_backend_type(layout),\n-                        ))\n+                        )\n                     } else {\n                         bug!(\"simd shuffle field {:?}\", field)\n                     }\n                 }).collect();\n-                let llval = bx.const_struct(&values?, false);\n-                Ok((llval, c.ty))\n+                let llval = bx.const_struct(&values, false);\n+                (llval, c.ty)\n             })\n             .unwrap_or_else(|_| {\n                 bx.tcx().sess.span_err("}, {"sha": "ee522570b3634c78e8f38c4044bcf4216d2b86cc", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5c0615b89c399ce6a431ba660f9457c24bc69964/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c0615b89c399ce6a431ba660f9457c24bc69964/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=5c0615b89c399ce6a431ba660f9457c24bc69964", "patch": "@@ -466,45 +466,42 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n }\n \n /// Projects to a field of a (variant of a) const.\n+// this function uses `unwrap` copiously, because an already validated constant must have valid\n+// fields and can thus never fail outside of compiler bugs\n pub fn const_field<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     variant: Option<VariantIdx>,\n     field: mir::Field,\n     value: ty::Const<'tcx>,\n-) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n+) -> ty::Const<'tcx> {\n     trace!(\"const_field: {:?}, {:?}\", field, value);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n-    let result = (|| {\n-        // get the operand again\n-        let op = ecx.const_to_op(value, None)?;\n-        // downcast\n-        let down = match variant {\n-            None => op,\n-            Some(variant) => ecx.operand_downcast(op, variant)?\n-        };\n-        // then project\n-        let field = ecx.operand_field(down, field.index() as u64)?;\n-        // and finally move back to the const world, always normalizing because\n-        // this is not called for statics.\n-        op_to_const(&ecx, field)\n-    })();\n-    result.map_err(|error| {\n-        let err = error_to_const_error(&ecx, error);\n-        err.report_as_error(ecx.tcx, \"could not access field of constant\");\n-        ErrorHandled::Reported\n-    })\n+    // get the operand again\n+    let op = ecx.const_to_op(value, None).unwrap();\n+    // downcast\n+    let down = match variant {\n+        None => op,\n+        Some(variant) => ecx.operand_downcast(op, variant).unwrap(),\n+    };\n+    // then project\n+    let field = ecx.operand_field(down, field.index() as u64).unwrap();\n+    // and finally move back to the const world, always normalizing because\n+    // this is not called for statics.\n+    op_to_const(&ecx, field).unwrap()\n }\n \n+// this function uses `unwrap` copiously, because an already validated constant must have valid\n+// fields and can thus never fail outside of compiler bugs\n pub fn const_variant_index<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     val: ty::Const<'tcx>,\n-) -> EvalResult<'tcx, VariantIdx> {\n+) -> VariantIdx {\n     trace!(\"const_variant_index: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n-    let op = ecx.const_to_op(val, None)?;\n-    Ok(ecx.read_discriminant(op)?.1)\n+    let op = ecx.const_to_op(val, None).unwrap();\n+    ecx.read_discriminant(op).unwrap().1\n }\n \n pub fn error_to_const_error<'a, 'mir, 'tcx>("}, {"sha": "586a3fdb907ee7a1c4841ed4324a20a9128ce4bf", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c0615b89c399ce6a431ba660f9457c24bc69964/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c0615b89c399ce6a431ba660f9457c24bc69964/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=5c0615b89c399ce6a431ba660f9457c24bc69964", "patch": "@@ -440,13 +440,7 @@ impl<'tcx> Constructor<'tcx> {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n             }\n-            &ConstantValue(c) => {\n-                crate::const_eval::const_variant_index(\n-                    cx.tcx,\n-                    cx.param_env,\n-                    c,\n-                ).unwrap()\n-            },\n+            &ConstantValue(c) => crate::const_eval::const_variant_index(cx.tcx, cx.param_env, c),\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n         }\n     }"}, {"sha": "ab54d4c50b5eef07367d74706ddbbc208dd5c052", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c0615b89c399ce6a431ba660f9457c24bc69964/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c0615b89c399ce6a431ba660f9457c24bc69964/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=5c0615b89c399ce6a431ba660f9457c24bc69964", "patch": "@@ -937,10 +937,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n         let adt_subpattern = |i, variant_opt| {\n             let field = Field::new(i);\n-            let val = const_field(\n-                self.tcx, self.param_env,\n-                variant_opt, field, cv,\n-            ).expect(\"field access failed\");\n+            let val = const_field(self.tcx, self.param_env, variant_opt, field, cv);\n             self.const_to_pat(instance, val, id, span)\n         };\n         let adt_subpatterns = |n, variant_opt| {\n@@ -979,9 +976,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 PatternKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n-                let variant_index = const_variant_index(\n-                    self.tcx, self.param_env, cv\n-                ).expect(\"const_variant_index failed\");\n+                let variant_index = const_variant_index(self.tcx, self.param_env, cv);\n                 let subpatterns = adt_subpatterns(\n                     adt_def.variants[variant_index].fields.len(),\n                     Some(variant_index),"}]}