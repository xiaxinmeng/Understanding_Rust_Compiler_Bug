{"sha": "4c012514169b1c26f47e4b2ec9abc72686fd04e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMDEyNTE0MTY5YjFjMjZmNDdlNGIyZWM5YWJjNzI2ODZmZDA0ZTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-07-22T11:46:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-08-29T14:21:54Z"}, "message": "Introduce new inference scheme: variables are now instantiated with at most one type, and region variables are introduced as needed", "tree": {"sha": "ed7f0f78103b0a02ea5d31aea856d50df669c2fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed7f0f78103b0a02ea5d31aea856d50df669c2fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c012514169b1c26f47e4b2ec9abc72686fd04e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c012514169b1c26f47e4b2ec9abc72686fd04e1", "html_url": "https://github.com/rust-lang/rust/commit/4c012514169b1c26f47e4b2ec9abc72686fd04e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c012514169b1c26f47e4b2ec9abc72686fd04e1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6e5797e4130c9925734b0a42b4e8d5a1a23073a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6e5797e4130c9925734b0a42b4e8d5a1a23073a", "html_url": "https://github.com/rust-lang/rust/commit/d6e5797e4130c9925734b0a42b4e8d5a1a23073a"}], "stats": {"total": 1554, "additions": 845, "deletions": 709}, "files": [{"sha": "0c6143ea7337670e1e7dbdc4b073964176311477", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 145, "deletions": 69, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -8,43 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ______________________________________________________________________\n-// Type combining\n+///////////////////////////////////////////////////////////////////////////\n+// # Type combining\n //\n-// There are three type combiners: sub, lub, and glb.  Each implements\n-// the trait `Combine` and contains methods for combining two\n-// instances of various things and yielding a new instance.  These\n-// combiner methods always yield a `result<T>`---failure is propagated\n-// upward using `and_then()` methods.  There is a lot of common code for\n-// these operations, implemented as default methods on the `Combine`\n-// trait.\n+// There are four type combiners: equate, sub, lub, and glb.  Each\n+// implements the trait `Combine` and contains methods for combining\n+// two instances of various things and yielding a new instance.  These\n+// combiner methods always yield a `Result<T>`.  There is a lot of\n+// common code for these operations, implemented as default methods on\n+// the `Combine` trait.\n //\n-// In reality, the sub operation is rather different from lub/glb, but\n-// they are combined into one trait to avoid duplication (they used to\n-// be separate but there were many bugs because there were two copies\n-// of most routines).\n+// Each operation may have side-effects on the inference context,\n+// though these can be unrolled using snapshots. On success, the\n+// LUB/GLB operations return the appropriate bound. The Eq and Sub\n+// operations generally return the first operand.\n //\n-// The differences are:\n-//\n-// - when making two things have a sub relationship, the order of the\n-//   arguments is significant (a <: b) and the return value of the\n-//   combine functions is largely irrelevant.  The important thing is\n-//   whether the action succeeds or fails.  If it succeeds, then side\n-//   effects have been committed into the type variables.\n-//\n-// - for GLB/LUB, the order of arguments is not significant (GLB(a,b) ==\n-//   GLB(b,a)) and the return value is important (it is the GLB).  Of\n-//   course GLB/LUB may also have side effects.\n-//\n-// Contravariance\n+// ## Contravariance\n //\n // When you are relating two things which have a contravariant\n // relationship, you should use `contratys()` or `contraregions()`,\n // rather than inversing the order of arguments!  This is necessary\n // because the order of arguments is not relevant for LUB and GLB.  It\n // is also useful to track which value is the \"expected\" value in\n-// terms of error reporting, although we do not do that properly right\n-// now.\n+// terms of error reporting.\n \n \n use middle::subst;\n@@ -53,14 +39,16 @@ use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n use middle::ty::{IntType, UintType};\n use middle::ty::{BuiltinBounds};\n use middle::ty;\n-use middle::typeck::infer::{ToUres};\n+use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n-use middle::typeck::infer::{InferCtxt, cres, ures};\n-use middle::typeck::infer::{TypeTrace};\n-use util::common::indent;\n+use middle::typeck::infer::{InferCtxt, cres};\n+use middle::typeck::infer::{MiscVariable, TypeTrace};\n+use middle::typeck::infer::type_variable::{RelationDir, EqTo,\n+                                           SubtypeOf, SupertypeOf};\n+use middle::ty_fold::{RegionFolder, TypeFoldable};\n use util::ppaux::Repr;\n \n use std::result;\n@@ -75,6 +63,7 @@ pub trait Combine {\n     fn a_is_expected(&self) -> bool;\n     fn trace(&self) -> TypeTrace;\n \n+    fn equate<'a>(&'a self) -> Equate<'a>;\n     fn sub<'a>(&'a self) -> Sub<'a>;\n     fn lub<'a>(&'a self) -> Lub<'a>;\n     fn glb<'a>(&'a self) -> Glb<'a>;\n@@ -101,7 +90,7 @@ pub trait Combine {\n         try!(result::fold_(as_\n                           .iter()\n                           .zip(bs.iter())\n-                          .map(|(a, b)| eq_tys(self, *a, *b))));\n+                          .map(|(a, b)| self.equate().tys(*a, *b))));\n         Ok(Vec::from_slice(as_))\n     }\n \n@@ -177,10 +166,7 @@ pub trait Combine {\n                 let b_r = b_rs[i];\n                 let variance = variances[i];\n                 let r = match variance {\n-                    ty::Invariant => {\n-                        eq_regions(this, a_r, b_r)\n-                            .and_then(|()| Ok(a_r))\n-                    }\n+                    ty::Invariant => this.equate().regions(a_r, b_r),\n                     ty::Covariant => this.regions(a_r, b_r),\n                     ty::Contravariant => this.contraregions(a_r, b_r),\n                     ty::Bivariant => Ok(a_r),\n@@ -334,34 +320,6 @@ pub fn expected_found<C:Combine,T>(\n     }\n }\n \n-pub fn eq_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> ures {\n-    let suber = this.sub();\n-    this.infcx().try(|| {\n-        suber.tys(a, b).and_then(|_ok| suber.contratys(a, b)).to_ures()\n-    })\n-}\n-\n-pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n-                          -> ures {\n-    debug!(\"eq_regions({}, {})\",\n-            a.repr(this.infcx().tcx),\n-            b.repr(this.infcx().tcx));\n-    let sub = this.sub();\n-    indent(|| {\n-        this.infcx().try(|| {\n-            sub.regions(a, b).and_then(|_r| sub.contraregions(a, b))\n-        }).or_else(|e| {\n-            // substitute a better error, but use the regions\n-            // found in the original error\n-            match e {\n-              ty::terr_regions_does_not_outlive(a1, b1) =>\n-                Err(ty::terr_regions_not_same(a1, b1)),\n-              _ => Err(e)\n-            }\n-        }).to_ures()\n-    })\n-}\n-\n pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n \n     fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<Vec<ty::t> > {\n@@ -453,8 +411,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n         // Relate floating-point variables to other types\n         (&ty::ty_infer(FloatVar(a_id)), &ty::ty_infer(FloatVar(b_id))) => {\n-            try!(this.infcx().simple_vars(this.a_is_expected(),\n-                                            a_id, b_id));\n+            try!(this.infcx().simple_vars(this.a_is_expected(), a_id, b_id));\n             Ok(a)\n         }\n         (&ty::ty_infer(FloatVar(v_id)), &ty::ty_float(v)) => {\n@@ -469,7 +426,8 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       (&ty::ty_bool, _) |\n       (&ty::ty_int(_), _) |\n       (&ty::ty_uint(_), _) |\n-      (&ty::ty_float(_), _) => {\n+      (&ty::ty_float(_), _) |\n+      (&ty::ty_err, _) => {\n         if ty::get(a).sty == ty::get(b).sty {\n             Ok(a)\n         } else {\n@@ -512,7 +470,10 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       (&ty::ty_unboxed_closure(a_id, a_region),\n        &ty::ty_unboxed_closure(b_id, b_region))\n       if a_id == b_id => {\n-          let region = if_ok!(this.regions(a_region, b_region));\n+          // All ty_unboxed_closure types with the same id represent\n+          // the (anonymous) type of the same closure expression. So\n+          // all of their regions should be equated.\n+          let region = try!(this.equate().regions(a_region, b_region));\n           Ok(ty::mk_unboxed_closure(tcx, a_id, region))\n       }\n \n@@ -609,3 +570,118 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n         Ok(ty::mk_mach_float(val))\n     }\n }\n+\n+impl<'f> CombineFields<'f> {\n+    pub fn switch_expected(&self) -> CombineFields<'f> {\n+        CombineFields {\n+            a_is_expected: !self.a_is_expected,\n+            ..(*self).clone()\n+        }\n+    }\n+\n+    fn equate(&self) -> Equate<'f> {\n+        Equate((*self).clone())\n+    }\n+\n+    fn sub(&self) -> Sub<'f> {\n+        Sub((*self).clone())\n+    }\n+\n+    pub fn instantiate(&self,\n+                       a_ty: ty::t,\n+                       dir: RelationDir,\n+                       b_vid: ty::TyVid)\n+                       -> cres<()>\n+    {\n+        let tcx = self.infcx.tcx;\n+        let mut stack = Vec::new();\n+        stack.push((a_ty, dir, b_vid));\n+        loop {\n+            // For each turn of the loop, we extract a tuple\n+            //\n+            //     (a_ty, dir, b_vid)\n+            //\n+            // to relate. Here dir is either SubtypeOf or\n+            // SupertypeOf. The idea is that we should ensure that\n+            // the type `a_ty` is a subtype or supertype (respectively) of the\n+            // type to which `b_vid` is bound.\n+            //\n+            // If `b_vid` has not yet been instantiated with a type\n+            // (which is always true on the first iteration, but not\n+            // necessarily true on later iterations), we will first\n+            // instantiate `b_vid` with a *generalized* version of\n+            // `a_ty`. Generalization introduces other inference\n+            // variables wherever subtyping could occur (at time of\n+            // this writing, this means replacing free regions with\n+            // region variables).\n+            let (a_ty, dir, b_vid) = match stack.pop() {\n+                None => break,\n+                Some(e) => e,\n+            };\n+\n+            debug!(\"instantiate(a_ty={} dir={} b_vid={})\",\n+                   a_ty.repr(tcx),\n+                   dir,\n+                   b_vid.repr(tcx));\n+\n+            // Check whether `vid` has been instantiated yet.  If not,\n+            // make a generalized form of `ty` and instantiate with\n+            // that.\n+            let b_ty = self.infcx.type_variables.borrow().probe(b_vid);\n+            let b_ty = match b_ty {\n+                Some(t) => t, // ...already instantiated.\n+                None => {     // ...not yet instantiated:\n+                    // Generalize type if necessary.\n+                    let generalized_ty = match dir {\n+                        EqTo => a_ty,\n+                        SupertypeOf | SubtypeOf => self.generalize(a_ty)\n+                    };\n+                    debug!(\"instantiate(a_ty={}, dir={}, \\\n+                                        b_vid={}, generalized_ty={})\",\n+                           a_ty.repr(tcx), dir, b_vid.repr(tcx),\n+                           generalized_ty.repr(tcx));\n+                    self.infcx.type_variables\n+                        .borrow_mut()\n+                        .instantiate_and_push(\n+                            b_vid, generalized_ty, &mut stack);\n+                    generalized_ty\n+                }\n+            };\n+\n+            // The original triple was `(a_ty, dir, b_vid)` -- now we have\n+            // resolved `b_vid` to `b_ty`, so apply `(a_ty, dir, b_ty)`:\n+            //\n+            // FIXME: This code is non-ideal because all these subtype\n+            // relations wind up attributed to the same spans. We need\n+            // to associate causes/spans with each of the relations in\n+            // the stack to get this right.\n+            match dir {\n+                EqTo => {\n+                    try!(self.equate().tys(a_ty, b_ty));\n+                }\n+\n+                SubtypeOf => {\n+                    try!(self.sub().tys(a_ty, b_ty));\n+                }\n+\n+                SupertypeOf => {\n+                    try!(self.sub().contratys(a_ty, b_ty));\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn generalize(&self, t: ty::t) -> ty::t {\n+        // FIXME: This is non-ideal because we don't give a very descriptive\n+        // origin for this region variable.\n+\n+        let infcx = self.infcx;\n+        let span = self.trace.origin.span();\n+        t.fold_with(\n+            &mut RegionFolder::regions(\n+                self.infcx.tcx,\n+                |_| infcx.next_region_var(MiscVariable(span))))\n+    }\n+}"}, {"sha": "391027f9c4bf93bc24478247eb1f52dcce25f4c2", "filename": "src/librustc/middle/typeck/infer/equate.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -0,0 +1,149 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty::{BuiltinBounds};\n+use middle::ty;\n+use middle::ty::TyVar;\n+use middle::typeck::infer::combine::*;\n+use middle::typeck::infer::{cres};\n+use middle::typeck::infer::glb::Glb;\n+use middle::typeck::infer::InferCtxt;\n+use middle::typeck::infer::lub::Lub;\n+use middle::typeck::infer::sub::Sub;\n+use middle::typeck::infer::{TypeTrace, Subtype};\n+use middle::typeck::infer::type_variable::{EqTo};\n+use util::ppaux::{Repr};\n+\n+use syntax::ast::{Onceness, FnStyle};\n+\n+pub struct Equate<'f> {\n+    fields: CombineFields<'f>\n+}\n+\n+#[allow(non_snake_case_functions)]\n+pub fn Equate<'f>(cf: CombineFields<'f>) -> Equate<'f> {\n+    Equate { fields: cf }\n+}\n+\n+impl<'f> Combine for Equate<'f> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n+    fn tag(&self) -> String { \"eq\".to_string() }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n+    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n+\n+    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n+\n+    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+        self.tys(a, b)\n+    }\n+\n+    fn contraregions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+        self.regions(a, b)\n+    }\n+\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+        debug!(\"{}.regions({}, {})\",\n+               self.tag(),\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n+        self.infcx().region_vars.make_eqregion(Subtype(self.trace()), a, b);\n+        Ok(a)\n+    }\n+\n+    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n+        debug!(\"mts({} <: {})\",\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n+\n+        if a.mutbl != b.mutbl { return Err(ty::terr_mutability); }\n+        let t = try!(self.tys(a.ty, b.ty));\n+        Ok(ty::mt { mutbl: a.mutbl, ty: t })\n+    }\n+\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n+        if a != b {\n+            Err(ty::terr_fn_style_mismatch(expected_found(self, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n+\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness> {\n+        if a != b {\n+            Err(ty::terr_onceness_mismatch(expected_found(self, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n+\n+    fn builtin_bounds(&self,\n+                      a: BuiltinBounds,\n+                      b: BuiltinBounds)\n+                      -> cres<BuiltinBounds>\n+    {\n+        // More bounds is a subtype of fewer bounds.\n+        //\n+        // e.g., fn:Copy() <: fn(), because the former is a function\n+        // that only closes over copyable things, but the latter is\n+        // any function at all.\n+        if a != b {\n+            Err(ty::terr_builtin_bounds(expected_found(self, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n+\n+    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+        debug!(\"{}.tys({}, {})\", self.tag(),\n+               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n+        if a == b { return Ok(a); }\n+\n+        let infcx = self.fields.infcx;\n+        let a = infcx.type_variables.borrow().replace_if_possible(a);\n+        let b = infcx.type_variables.borrow().replace_if_possible(b);\n+        match (&ty::get(a).sty, &ty::get(b).sty) {\n+            (&ty::ty_bot, &ty::ty_bot) => {\n+                Ok(a)\n+            }\n+\n+            (&ty::ty_bot, _) |\n+            (_, &ty::ty_bot) => {\n+                Err(ty::terr_sorts(expected_found(self, a, b)))\n+            }\n+\n+            (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n+                infcx.type_variables.borrow_mut().relate_vars(a_id, EqTo, b_id);\n+                Ok(a)\n+            }\n+\n+            (&ty::ty_infer(TyVar(a_id)), _) => {\n+                try!(self.fields.instantiate(b, EqTo, a_id));\n+                Ok(a)\n+            }\n+\n+            (_, &ty::ty_infer(TyVar(b_id))) => {\n+                try!(self.fields.instantiate(a, EqTo, b_id));\n+                Ok(a)\n+            }\n+\n+            _ => {\n+                super_tys(self, a, b)\n+            }\n+        }\n+    }\n+\n+    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+        try!(self.sub().fn_sigs(a, b));\n+        self.sub().fn_sigs(b, a)\n+    }\n+}"}, {"sha": "68b8031a04b68a730f389bbff5587673bf9c9c34", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -12,9 +12,9 @@\n use middle::ty::{BuiltinBounds};\n use middle::ty::RegionVid;\n use middle::ty;\n-use middle::typeck::infer::then;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::lattice::*;\n+use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::{cres, InferCtxt};\n@@ -31,7 +31,7 @@ use util::ppaux::Repr;\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'f> {\n-    pub fields: CombineFields<'f>\n+    fields: CombineFields<'f>\n }\n \n #[allow(non_snake_case_functions)]\n@@ -45,6 +45,7 @@ impl<'f> Combine for Glb<'f> {\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n+    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n     fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n     fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n     fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n@@ -58,27 +59,25 @@ impl<'f> Combine for Glb<'f> {\n                mt_to_string(tcx, b));\n \n         match (a.mutbl, b.mutbl) {\n-          // If one side or both is mut, then the GLB must use\n-          // the precise type from the mut side.\n-          (MutMutable, MutMutable) => {\n-            eq_tys(self, a.ty, b.ty).then(|| {\n-                Ok(ty::mt {ty: a.ty, mutbl: MutMutable})\n-            })\n-          }\n-\n-          // If one side or both is immutable, we can use the GLB of\n-          // both sides but mutbl must be `MutImmutable`.\n-          (MutImmutable, MutImmutable) => {\n-            self.tys(a.ty, b.ty).and_then(|t| {\n+            // If one side or both is mut, then the GLB must use\n+            // the precise type from the mut side.\n+            (MutMutable, MutMutable) => {\n+                let t = try!(self.equate().tys(a.ty, b.ty));\n+                Ok(ty::mt {ty: t, mutbl: MutMutable})\n+            }\n+\n+            // If one side or both is immutable, we can use the GLB of\n+            // both sides but mutbl must be `MutImmutable`.\n+            (MutImmutable, MutImmutable) => {\n+                let t = try!(self.tys(a.ty, b.ty));\n                 Ok(ty::mt {ty: t, mutbl: MutImmutable})\n-            })\n-          }\n-\n-          // There is no mutual subtype of these combinations.\n-          (MutMutable, MutImmutable) |\n-          (MutImmutable, MutMutable) => {\n-              Err(ty::terr_mutability)\n-          }\n+            }\n+\n+            // There is no mutual subtype of these combinations.\n+            (MutMutable, MutImmutable) |\n+            (MutImmutable, MutMutable) => {\n+                Err(ty::terr_mutability)\n+            }\n         }\n     }\n "}, {"sha": "f09773d30b5149feb7b91046f6ae46d0c4d0cd52", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 38, "deletions": 458, "changes": 496, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -33,346 +33,55 @@\n \n use middle::ty::{RegionVid, TyVar};\n use middle::ty;\n-use middle::typeck::infer::{ToUres};\n use middle::typeck::infer::*;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n-use middle::typeck::infer::unify::*;\n-use middle::typeck::infer::sub::Sub;\n use util::ppaux::Repr;\n \n use std::collections::HashMap;\n \n-trait LatticeValue : Clone + Repr + PartialEq {\n-    fn sub(cf: CombineFields, a: &Self, b: &Self) -> ures;\n-    fn lub(cf: CombineFields, a: &Self, b: &Self) -> cres<Self>;\n-    fn glb(cf: CombineFields, a: &Self, b: &Self) -> cres<Self>;\n-}\n-\n-pub type LatticeOp<'a, T> =\n-    |cf: CombineFields, a: &T, b: &T|: 'a -> cres<T>;\n-\n-impl LatticeValue for ty::t {\n-    fn sub(cf: CombineFields, a: &ty::t, b: &ty::t) -> ures {\n-        Sub(cf).tys(*a, *b).to_ures()\n-    }\n-\n-    fn lub(cf: CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n-        Lub(cf).tys(*a, *b)\n-    }\n-\n-    fn glb(cf: CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n-        Glb(cf).tys(*a, *b)\n-    }\n-}\n-\n-pub trait CombineFieldsLatticeMethods<T:LatticeValue, K:UnifyKey<Bounds<T>>> {\n-    /// make variable a subtype of variable\n-    fn var_sub_var(&self,\n-                   a_id: K,\n-                   b_id: K)\n-                   -> ures;\n-\n-    /// make variable a subtype of T\n-    fn var_sub_t(&self,\n-                 a_id: K,\n-                 b: T)\n-                 -> ures;\n-\n-    /// make T a subtype of variable\n-    fn t_sub_var(&self,\n-                 a: T,\n-                 b_id: K)\n-                 -> ures;\n-\n-    fn set_var_to_merged_bounds(&self,\n-                                v_id: K,\n-                                a: &Bounds<T>,\n-                                b: &Bounds<T>,\n-                                rank: uint)\n-                                -> ures;\n-}\n-\n-pub trait CombineFieldsLatticeMethods2<T:LatticeValue> {\n-    fn merge_bnd(&self,\n-                 a: &Bound<T>,\n-                 b: &Bound<T>,\n-                 lattice_op: LatticeOp<T>)\n-                 -> cres<Bound<T>>;\n-\n-    fn bnds(&self, a: &Bound<T>, b: &Bound<T>) -> ures;\n-}\n-\n-impl<'f,T:LatticeValue, K:UnifyKey<Bounds<T>>>\n-    CombineFieldsLatticeMethods<T,K> for CombineFields<'f>\n-{\n-    fn var_sub_var(&self,\n-                   a_id: K,\n-                   b_id: K)\n-                   -> ures\n-    {\n-        /*!\n-         * Make one variable a subtype of another variable.  This is a\n-         * subtle and tricky process, as described in detail at the\n-         * top of infer.rs.\n-         */\n-\n-        let tcx = self.infcx.tcx;\n-        let table = UnifyKey::unification_table(self.infcx);\n-\n-        // Need to make sub_id a subtype of sup_id.\n-        let node_a = table.borrow_mut().get(tcx, a_id);\n-        let node_b = table.borrow_mut().get(tcx, b_id);\n-        let a_id = node_a.key.clone();\n-        let b_id = node_b.key.clone();\n-        let a_bounds = node_a.value.clone();\n-        let b_bounds = node_b.value.clone();\n-\n-        debug!(\"vars({}={} <: {}={})\",\n-               a_id, a_bounds.repr(tcx),\n-               b_id, b_bounds.repr(tcx));\n-\n-        if a_id == b_id { return Ok(()); }\n-\n-        // If both A's UB and B's LB have already been bound to types,\n-        // see if we can make those types subtypes.\n-        match (&a_bounds.ub, &b_bounds.lb) {\n-            (&Some(ref a_ub), &Some(ref b_lb)) => {\n-                let r = self.infcx.try(\n-                    || LatticeValue::sub(self.clone(), a_ub, b_lb));\n-                match r {\n-                    Ok(()) => {\n-                        return Ok(());\n-                    }\n-                    Err(_) => { /*fallthrough */ }\n-                }\n-            }\n-            _ => { /*fallthrough*/ }\n-        }\n-\n-        // Otherwise, we need to merge A and B so as to guarantee that\n-        // A remains a subtype of B.  Actually, there are other options,\n-        // but that's the route we choose to take.\n-\n-        let (new_root, new_rank) =\n-            table.borrow_mut().unify(tcx, &node_a, &node_b);\n-        self.set_var_to_merged_bounds(new_root,\n-                                      &a_bounds, &b_bounds,\n-                                      new_rank)\n-    }\n-\n-    /// make variable a subtype of T\n-    fn var_sub_t(&self,\n-                 a_id: K,\n-                 b: T)\n-                 -> ures\n-    {\n-        /*!\n-         * Make a variable (`a_id`) a subtype of the concrete type `b`.\n-         */\n-\n-        let tcx = self.infcx.tcx;\n-        let table = UnifyKey::unification_table(self.infcx);\n-        let node_a = table.borrow_mut().get(tcx, a_id);\n-        let a_id = node_a.key.clone();\n-        let a_bounds = &node_a.value;\n-        let b_bounds = &Bounds { lb: None, ub: Some(b.clone()) };\n-\n-        debug!(\"var_sub_t({}={} <: {})\",\n-               a_id,\n-               a_bounds.repr(self.infcx.tcx),\n-               b.repr(self.infcx.tcx));\n-\n-        self.set_var_to_merged_bounds(\n-            a_id, a_bounds, b_bounds, node_a.rank)\n-    }\n-\n-    fn t_sub_var(&self,\n-                 a: T,\n-                 b_id: K)\n-                 -> ures\n-    {\n-        /*!\n-         * Make a concrete type (`a`) a subtype of the variable `b_id`\n-         */\n-\n-        let tcx = self.infcx.tcx;\n-        let table = UnifyKey::unification_table(self.infcx);\n-        let a_bounds = &Bounds { lb: Some(a.clone()), ub: None };\n-        let node_b = table.borrow_mut().get(tcx, b_id);\n-        let b_id = node_b.key.clone();\n-        let b_bounds = &node_b.value;\n-\n-        debug!(\"t_sub_var({} <: {}={})\",\n-               a.repr(self.infcx.tcx),\n-               b_id,\n-               b_bounds.repr(self.infcx.tcx));\n-\n-        self.set_var_to_merged_bounds(\n-            b_id, a_bounds, b_bounds, node_b.rank)\n-    }\n-\n-    fn set_var_to_merged_bounds(&self,\n-                                v_id: K,\n-                                a: &Bounds<T>,\n-                                b: &Bounds<T>,\n-                                rank: uint)\n-                                -> ures\n-    {\n-        /*!\n-         * Updates the bounds for the variable `v_id` to be the intersection\n-         * of `a` and `b`.  That is, the new bounds for `v_id` will be\n-         * a bounds c such that:\n-         *    c.ub <: a.ub\n-         *    c.ub <: b.ub\n-         *    a.lb <: c.lb\n-         *    b.lb <: c.lb\n-         * If this cannot be achieved, the result is failure.\n-         */\n-\n-        // Think of the two diamonds, we want to find the\n-        // intersection.  There are basically four possibilities (you\n-        // can swap A/B in these pictures):\n-        //\n-        //       A         A\n-        //      / \\       / \\\n-        //     / B \\     / B \\\n-        //    / / \\ \\   / / \\ \\\n-        //   * *   * * * /   * *\n-        //    \\ \\ / /   \\   / /\n-        //     \\ B /   / \\ / /\n-        //      \\ /   *   \\ /\n-        //       A     \\ / A\n-        //              B\n-\n-        let tcx = self.infcx.tcx;\n-        let table = UnifyKey::unification_table(self.infcx);\n-\n-        debug!(\"merge({},{},{})\",\n-               v_id,\n-               a.repr(self.infcx.tcx),\n-               b.repr(self.infcx.tcx));\n-\n-        // First, relate the lower/upper bounds of A and B.\n-        // Note that these relations *must* hold for us\n-        // to be able to merge A and B at all, and relating\n-        // them explicitly gives the type inferencer more\n-        // information and helps to produce tighter bounds\n-        // when necessary.\n-        let () = if_ok!(self.bnds(&a.lb, &b.ub));\n-        let () = if_ok!(self.bnds(&b.lb, &a.ub));\n-        let ub = if_ok!(self.merge_bnd(&a.ub, &b.ub, LatticeValue::glb));\n-        let lb = if_ok!(self.merge_bnd(&a.lb, &b.lb, LatticeValue::lub));\n-        let bounds = Bounds { lb: lb, ub: ub };\n-        debug!(\"merge({}): bounds={}\",\n-               v_id,\n-               bounds.repr(self.infcx.tcx));\n-\n-        // the new bounds must themselves\n-        // be relatable:\n-        let () = if_ok!(self.bnds(&bounds.lb, &bounds.ub));\n-        table.borrow_mut().set(tcx, v_id, Root(bounds, rank));\n-        Ok(())\n-    }\n-}\n-\n-impl<'f,T:LatticeValue>\n-    CombineFieldsLatticeMethods2<T> for CombineFields<'f>\n-{\n-    fn merge_bnd(&self,\n-                 a: &Bound<T>,\n-                 b: &Bound<T>,\n-                 lattice_op: LatticeOp<T>)\n-                 -> cres<Bound<T>>\n-    {\n-        /*!\n-         * Combines two bounds into a more general bound.\n-         */\n-\n-        debug!(\"merge_bnd({},{})\",\n-               a.repr(self.infcx.tcx),\n-               b.repr(self.infcx.tcx));\n-        match (a, b) {\n-            (&None,          &None) => Ok(None),\n-            (&Some(_),       &None) => Ok((*a).clone()),\n-            (&None,          &Some(_)) => Ok((*b).clone()),\n-            (&Some(ref v_a), &Some(ref v_b)) => {\n-                lattice_op(self.clone(), v_a, v_b).and_then(|v| Ok(Some(v)))\n-            }\n-        }\n-    }\n-\n-    fn bnds(&self,\n-            a: &Bound<T>,\n-            b: &Bound<T>)\n-            -> ures\n-    {\n-        debug!(\"bnds({} <: {})\",\n-               a.repr(self.infcx.tcx),\n-               b.repr(self.infcx.tcx));\n-\n-        match (a, b) {\n-            (&None, &None) |\n-            (&Some(_), &None) |\n-            (&None, &Some(_)) => {\n-                Ok(())\n-            }\n-            (&Some(ref t_a), &Some(ref t_b)) => {\n-                LatticeValue::sub(self.clone(), t_a, t_b)\n-            }\n-        }\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Lattice operations on variables\n-//\n-// This is common code used by both LUB and GLB to compute the LUB/GLB\n-// for pairs of variables or for variables and values.\n-\n pub trait LatticeDir {\n-    fn combine_fields<'a>(&'a self) -> CombineFields<'a>;\n-    fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T>;\n-    fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T>;\n-}\n-\n-pub trait TyLatticeDir {\n+    // Relates the bottom type to `t` and returns LUB(t, _|_) or\n+    // GLB(t, _|_) as appropriate.\n     fn ty_bot(&self, t: ty::t) -> cres<ty::t>;\n-}\n \n-impl<'f> LatticeDir for Lub<'f> {\n-    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { self.fields.clone() }\n-    fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.ub.clone() }\n-    fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n-        Bounds { ub: Some(t), ..(*b).clone() }\n-    }\n+    // Relates the type `v` to `a` and `b` such that `v` represents\n+    // the LUB/GLB of `a` and `b` as appropriate.\n+    fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()>;\n }\n \n-impl<'f> TyLatticeDir for Lub<'f> {\n+impl<'a> LatticeDir for Lub<'a> {\n     fn ty_bot(&self, t: ty::t) -> cres<ty::t> {\n         Ok(t)\n     }\n-}\n \n-impl<'f> LatticeDir for Glb<'f> {\n-    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { self.fields.clone() }\n-    fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.lb.clone() }\n-    fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n-        Bounds { lb: Some(t), ..(*b).clone() }\n+    fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()> {\n+        let sub = self.sub();\n+        try!(sub.tys(a, v));\n+        try!(sub.tys(b, v));\n+        Ok(())\n     }\n }\n \n-impl<'f> TyLatticeDir for Glb<'f> {\n-    fn ty_bot(&self, _t: ty::t) -> cres<ty::t> {\n+impl<'a> LatticeDir for Glb<'a> {\n+    fn ty_bot(&self, _: ty::t) -> cres<ty::t> {\n         Ok(ty::mk_bot())\n     }\n+\n+    fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()> {\n+        let sub = self.sub();\n+        try!(sub.tys(v, a));\n+        try!(sub.tys(v, b));\n+        Ok(())\n+    }\n }\n \n-pub fn super_lattice_tys<L:LatticeDir+TyLatticeDir+Combine>(this: &L,\n-                                                            a: ty::t,\n-                                                            b: ty::t)\n-                                                            -> cres<ty::t> {\n+pub fn super_lattice_tys<L:LatticeDir+Combine>(this: &L,\n+                                               a: ty::t,\n+                                               b: ty::t)\n+                                               -> cres<ty::t>\n+{\n     debug!(\"{}.lattice_tys({}, {})\",\n            this.tag(),\n            a.repr(this.infcx().tcx),\n@@ -382,156 +91,27 @@ pub fn super_lattice_tys<L:LatticeDir+TyLatticeDir+Combine>(this: &L,\n         return Ok(a);\n     }\n \n-    let tcx = this.infcx().tcx;\n-\n+    let infcx = this.infcx();\n+    let a = infcx.type_variables.borrow().replace_if_possible(a);\n+    let b = infcx.type_variables.borrow().replace_if_possible(b);\n     match (&ty::get(a).sty, &ty::get(b).sty) {\n-        (&ty::ty_bot, _) => { return this.ty_bot(b); }\n-        (_, &ty::ty_bot) => { return this.ty_bot(a); }\n-\n-        (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n-            let r = if_ok!(lattice_vars(this, a_id, b_id,\n-                                        |x, y| this.tys(*x, *y)));\n-            return match r {\n-                VarResult(v) => Ok(ty::mk_var(tcx, v)),\n-                ValueResult(t) => Ok(t)\n-            };\n-        }\n-\n-        (&ty::ty_infer(TyVar(a_id)), _) => {\n-            return lattice_var_and_t(this, a_id, &b,\n-                                     |x, y| this.tys(*x, *y));\n-        }\n-\n-        (_, &ty::ty_infer(TyVar(b_id))) => {\n-            return lattice_var_and_t(this, b_id, &a,\n-                                     |x, y| this.tys(*x, *y));\n+        (&ty::ty_bot, _) => { this.ty_bot(b) }\n+        (_, &ty::ty_bot) => { this.ty_bot(a) }\n+\n+        (&ty::ty_infer(TyVar(..)), _) |\n+        (_, &ty::ty_infer(TyVar(..))) => {\n+            let v = infcx.next_ty_var();\n+            try!(this.relate_bound(v, a, b));\n+            Ok(v)\n         }\n \n         _ => {\n-            return super_tys(this, a, b);\n-        }\n-    }\n-}\n-\n-pub type LatticeDirOp<'a, T> = |a: &T, b: &T|: 'a -> cres<T>;\n-\n-#[deriving(Clone)]\n-pub enum LatticeVarResult<K,T> {\n-    VarResult(K),\n-    ValueResult(T)\n-}\n-\n-/**\n- * Computes the LUB or GLB of two bounded variables.  These could be any\n- * sort of variables, but in the comments on this function I'll assume\n- * we are doing an LUB on two type variables.\n- *\n- * This computation can be done in one of two ways:\n- *\n- * - If both variables have an upper bound, we may just compute the\n- *   LUB of those bounds and return that, in which case we are\n- *   returning a type.  This is indicated with a `ValueResult` return.\n- *\n- * - If the variables do not both have an upper bound, we will unify\n- *   the variables and return the unified variable, in which case the\n- *   result is a variable.  This is indicated with a `VarResult`\n- *   return. */\n-pub fn lattice_vars<L:LatticeDir+Combine,\n-                    T:LatticeValue,\n-                    K:UnifyKey<Bounds<T>>>(\n-    this: &L,                           // defines whether we want LUB or GLB\n-    a_vid: K,                           // first variable\n-    b_vid: K,                           // second variable\n-    lattice_dir_op: LatticeDirOp<T>)    // LUB or GLB operation on types\n-    -> cres<LatticeVarResult<K,T>>\n-{\n-    let tcx = this.infcx().tcx;\n-    let table = UnifyKey::unification_table(this.infcx());\n-\n-    let node_a = table.borrow_mut().get(tcx, a_vid);\n-    let node_b = table.borrow_mut().get(tcx, b_vid);\n-    let a_vid = node_a.key.clone();\n-    let b_vid = node_b.key.clone();\n-    let a_bounds = &node_a.value;\n-    let b_bounds = &node_b.value;\n-\n-    debug!(\"{}.lattice_vars({}={} <: {}={})\",\n-           this.tag(),\n-           a_vid, a_bounds.repr(tcx),\n-           b_vid, b_bounds.repr(tcx));\n-\n-    // Same variable: the easy case.\n-    if a_vid == b_vid {\n-        return Ok(VarResult(a_vid));\n-    }\n-\n-    // If both A and B have an UB type, then we can just compute the\n-    // LUB of those types:\n-    let (a_bnd, b_bnd) = (this.bnd(a_bounds), this.bnd(b_bounds));\n-    match (a_bnd, b_bnd) {\n-        (Some(ref a_ty), Some(ref b_ty)) => {\n-            match this.infcx().try(|| lattice_dir_op(a_ty, b_ty) ) {\n-                Ok(t) => return Ok(ValueResult(t)),\n-                Err(_) => { /*fallthrough */ }\n-            }\n-        }\n-        _ => {/*fallthrough*/}\n-    }\n-\n-    // Otherwise, we need to merge A and B into one variable.  We can\n-    // then use either variable as an upper bound:\n-    let cf = this.combine_fields();\n-    let () = try!(cf.var_sub_var(a_vid.clone(), b_vid.clone()));\n-    Ok(VarResult(a_vid.clone()))\n-}\n-\n-pub fn lattice_var_and_t<L:LatticeDir+Combine,\n-                         T:LatticeValue,\n-                         K:UnifyKey<Bounds<T>>>(\n-    this: &L,\n-    a_id: K,\n-    b: &T,\n-    lattice_dir_op: LatticeDirOp<T>)\n-    -> cres<T>\n-{\n-    let tcx = this.infcx().tcx;\n-    let table = UnifyKey::unification_table(this.infcx());\n-\n-    let node_a = table.borrow_mut().get(tcx, a_id);\n-    let a_id = node_a.key.clone();\n-    let a_bounds = &node_a.value;\n-\n-    // The comments in this function are written for LUB, but they\n-    // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n-\n-    debug!(\"{}.lattice_var_and_t({}={} <: {})\",\n-           this.tag(),\n-           a_id,\n-           a_bounds.repr(this.infcx().tcx),\n-           b.repr(this.infcx().tcx));\n-\n-    match this.bnd(a_bounds) {\n-        Some(ref a_bnd) => {\n-            // If a has an upper bound, return the LUB(a.ub, b)\n-            debug!(\"bnd=Some({})\", a_bnd.repr(this.infcx().tcx));\n-            lattice_dir_op(a_bnd, b)\n-        }\n-        None => {\n-            // If a does not have an upper bound, make b the upper bound of a\n-            // and then return b.\n-            debug!(\"bnd=None\");\n-            let a_bounds = this.with_bnd(a_bounds, (*b).clone());\n-            let () = try!(this.combine_fields().bnds(&a_bounds.lb,\n-                                                     &a_bounds.ub));\n-            table.borrow_mut().set(tcx,\n-                                   a_id.clone(),\n-                                   Root(a_bounds.clone(), node_a.rank));\n-            Ok((*b).clone())\n+            super_tys(this, a, b)\n         }\n     }\n }\n \n-// ___________________________________________________________________________\n+///////////////////////////////////////////////////////////////////////////\n // Random utility functions used by LUB/GLB when computing LUB/GLB of\n // fn types\n "}, {"sha": "9c6c0763ad45ec8a5389ead7800daa34f8edc306", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -11,8 +11,8 @@\n use middle::ty::{BuiltinBounds};\n use middle::ty::RegionVid;\n use middle::ty;\n-use middle::typeck::infer::then;\n use middle::typeck::infer::combine::*;\n+use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lattice::*;\n use middle::typeck::infer::sub::Sub;\n@@ -30,7 +30,7 @@ use util::ppaux::Repr;\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'f> {\n-    pub fields: CombineFields<'f>\n+    fields: CombineFields<'f>\n }\n \n #[allow(non_snake_case_functions)]\n@@ -44,6 +44,7 @@ impl<'f> Combine for Lub<'f> {\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n+    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n     fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n     fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n     fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n@@ -62,17 +63,15 @@ impl<'f> Combine for Lub<'f> {\n \n         let m = a.mutbl;\n         match m {\n-          MutImmutable => {\n-            self.tys(a.ty, b.ty).and_then(|t| Ok(ty::mt {ty: t, mutbl: m}) )\n-          }\n-\n-          MutMutable => {\n-            self.fields.infcx.try(|| {\n-                eq_tys(self, a.ty, b.ty).then(|| {\n-                    Ok(ty::mt {ty: a.ty, mutbl: m})\n-                })\n-            }).or_else(|e| Err(e))\n-          }\n+            MutImmutable => {\n+                let t = try!(self.tys(a.ty, b.ty));\n+                Ok(ty::mt {ty: t, mutbl: m})\n+            }\n+\n+            MutMutable => {\n+                let t = try!(self.equate().tys(a.ty, b.ty));\n+                Ok(ty::mt {ty: t, mutbl: m})\n+            }\n         }\n     }\n "}, {"sha": "f86857f97f6546db85cadd6156d8e9d3e930638a", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -29,13 +29,14 @@ use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::infer::coercion::Coerce;\n-use middle::typeck::infer::combine::{Combine, CombineFields, eq_tys};\n-use middle::typeck::infer::region_inference::{RegionSnapshot};\n-use middle::typeck::infer::region_inference::{RegionVarBindings};\n+use middle::typeck::infer::combine::{Combine, CombineFields};\n+use middle::typeck::infer::region_inference::{RegionVarBindings,\n+                                              RegionSnapshot};\n use middle::typeck::infer::resolve::{resolver};\n+use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::lub::Lub;\n-use middle::typeck::infer::unify::{UnificationTable, Snapshot};\n+use middle::typeck::infer::unify::{UnificationTable};\n use middle::typeck::infer::error_reporting::ErrorReporting;\n use std::cell::{RefCell};\n use std::collections::HashMap;\n@@ -46,19 +47,20 @@ use syntax::codemap::Span;\n use util::common::indent;\n use util::ppaux::{bound_region_to_string, ty_to_string, trait_ref_to_string, Repr};\n \n-pub mod doc;\n-pub mod macros;\n+pub mod coercion;\n pub mod combine;\n+pub mod doc;\n+pub mod equate;\n+pub mod error_reporting;\n pub mod glb;\n pub mod lattice;\n pub mod lub;\n pub mod region_inference;\n pub mod resolve;\n pub mod sub;\n-pub mod unify;\n-pub mod coercion;\n-pub mod error_reporting;\n pub mod test;\n+pub mod type_variable;\n+pub mod unify;\n \n pub type Bound<T> = Option<T>;\n \n@@ -79,8 +81,7 @@ pub struct InferCtxt<'a> {\n     // We instantiate UnificationTable with bounds<ty::t> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n-    type_unification_table:\n-        RefCell<UnificationTable<ty::TyVid, Bounds<ty::t>>>,\n+    type_variables: RefCell<type_variable::TypeVariableTable>,\n \n     // Map from integral variable to the kind of integer it represents\n     int_unification_table:\n@@ -293,7 +294,7 @@ pub fn fixup_err_to_string(f: fixup_err) -> String {\n pub fn new_infer_ctxt<'a>(tcx: &'a ty::ctxt) -> InferCtxt<'a> {\n     InferCtxt {\n         tcx: tcx,\n-        type_unification_table: RefCell::new(UnificationTable::new()),\n+        type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n         int_unification_table: RefCell::new(UnificationTable::new()),\n         float_unification_table: RefCell::new(UnificationTable::new()),\n         region_vars: RegionVarBindings::new(tcx),\n@@ -395,8 +396,8 @@ pub fn mk_eqty(cx: &InferCtxt,\n             origin: origin,\n             values: Types(expected_found(a_is_expected, a, b))\n         };\n-        let suber = cx.sub(a_is_expected, trace);\n-        eq_tys(&suber, a, b)\n+        try!(cx.equate(a_is_expected, trace).tys(a, b));\n+        Ok(())\n     })\n }\n \n@@ -511,9 +512,9 @@ pub fn uok() -> ures {\n }\n \n pub struct CombinedSnapshot {\n-    type_snapshot: Snapshot<ty::TyVid>,\n-    int_snapshot: Snapshot<ty::IntVid>,\n-    float_snapshot: Snapshot<ty::FloatVid>,\n+    type_snapshot: type_variable::Snapshot,\n+    int_snapshot: unify::Snapshot<ty::IntVid>,\n+    float_snapshot: unify::Snapshot<ty::FloatVid>,\n     region_vars_snapshot: RegionSnapshot,\n }\n \n@@ -525,6 +526,10 @@ impl<'a> InferCtxt<'a> {\n                        trace: trace}\n     }\n \n+    pub fn equate<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Equate<'a> {\n+        Equate(self.combine_fields(a_is_expected, trace))\n+    }\n+\n     pub fn sub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Sub<'a> {\n         Sub(self.combine_fields(a_is_expected, trace))\n     }\n@@ -533,13 +538,9 @@ impl<'a> InferCtxt<'a> {\n         Lub(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn in_snapshot(&self) -> bool {\n-        self.region_vars.in_snapshot()\n-    }\n-\n     fn start_snapshot(&self) -> CombinedSnapshot {\n         CombinedSnapshot {\n-            type_snapshot: self.type_unification_table.borrow_mut().snapshot(),\n+            type_snapshot: self.type_variables.borrow_mut().snapshot(),\n             int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n             region_vars_snapshot: self.region_vars.start_snapshot(),\n@@ -553,7 +554,7 @@ impl<'a> InferCtxt<'a> {\n                                float_snapshot,\n                                region_vars_snapshot } = snapshot;\n \n-        self.type_unification_table\n+        self.type_variables\n             .borrow_mut()\n             .rollback_to(type_snapshot);\n         self.int_unification_table\n@@ -573,7 +574,7 @@ impl<'a> InferCtxt<'a> {\n                                float_snapshot,\n                                region_vars_snapshot } = snapshot;\n \n-        self.type_unification_table\n+        self.type_variables\n             .borrow_mut()\n             .commit(type_snapshot);\n         self.int_unification_table\n@@ -636,9 +637,9 @@ impl<'a> InferCtxt<'a> {\n \n impl<'a> InferCtxt<'a> {\n     pub fn next_ty_var_id(&self) -> TyVid {\n-        self.type_unification_table\n+        self.type_variables\n             .borrow_mut()\n-            .new_key(Bounds { lb: None, ub: None })\n+            .new_var()\n     }\n \n     pub fn next_ty_var(&self) -> ty::t {"}, {"sha": "f34894346f64afbc42e5d7a485267f2d5d65c902", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -234,7 +234,7 @@ impl<'a> RegionVarBindings<'a> {\n         }\n     }\n \n-    pub fn in_snapshot(&self) -> bool {\n+    fn in_snapshot(&self) -> bool {\n         self.undo_log.borrow().len() > 0\n     }\n \n@@ -406,6 +406,18 @@ impl<'a> RegionVarBindings<'a> {\n         }\n     }\n \n+    pub fn make_eqregion(&self,\n+                         origin: SubregionOrigin,\n+                         sub: Region,\n+                         sup: Region) {\n+        if sub != sup {\n+            // Eventually, it would be nice to add direct support for\n+            // equating regions.\n+            self.make_subregion(origin.clone(), sub, sup);\n+            self.make_subregion(origin, sup, sub);\n+        }\n+    }\n+\n     pub fn make_subregion(&self,\n                           origin: SubregionOrigin,\n                           sub: Region,"}, {"sha": "f9742c522dac4a6d0d5ff753467e27f546a01b11", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -48,12 +48,11 @@\n \n \n use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n-use middle::ty::{type_is_bot, IntType, UintType};\n+use middle::ty::{IntType, UintType};\n use middle::ty;\n use middle::ty_fold;\n-use middle::typeck::infer::{Bounds, cyclic_ty, fixup_err, fres, InferCtxt};\n-use middle::typeck::infer::{unresolved_float_ty, unresolved_int_ty};\n-use middle::typeck::infer::{unresolved_ty};\n+use middle::typeck::infer::{cyclic_ty, fixup_err, fres, InferCtxt};\n+use middle::typeck::infer::{unresolved_int_ty,unresolved_float_ty,unresolved_ty};\n use syntax::codemap::Span;\n use util::common::indent;\n use util::ppaux::{Repr, ty_to_string};\n@@ -132,8 +131,8 @@ impl<'a> ResolveState<'a> {\n         assert!(self.v_seen.is_empty());\n         match self.err {\n           None => {\n-            debug!(\"Resolved to {} + {} (modes={:x})\",\n-                   ty_to_string(self.infcx.tcx, rty),\n+            debug!(\"Resolved {} to {} (modes={:x})\",\n+                   ty_to_string(self.infcx.tcx, typ),\n                    ty_to_string(self.infcx.tcx, rty),\n                    self.modes);\n             return Ok(rty);\n@@ -219,21 +218,16 @@ impl<'a> ResolveState<'a> {\n             // tend to carry more restrictions or higher\n             // perf. penalties, so it pays to know more.\n \n-            let node =\n-                self.infcx.type_unification_table.borrow_mut().get(tcx, vid);\n-            let t1 = match node.value {\n-              Bounds { ub:_, lb:Some(t) } if !type_is_bot(t) => {\n-                  self.resolve_type(t)\n-              }\n-              Bounds { ub:Some(t), lb:_ } | Bounds { ub:_, lb:Some(t) } => {\n-                  self.resolve_type(t)\n-              }\n-              Bounds { ub:None, lb:None } => {\n-                if self.should(force_tvar) {\n-                    self.err = Some(unresolved_ty(vid));\n+            let t1 = match self.infcx.type_variables.borrow().probe(vid) {\n+                Some(t) => {\n+                    self.resolve_type(t)\n+                }\n+                None => {\n+                    if self.should(force_tvar) {\n+                        self.err = Some(unresolved_ty(vid));\n+                    }\n+                    ty::mk_var(tcx, vid)\n                 }\n-                ty::mk_var(tcx, vid)\n-              }\n             };\n             self.v_seen.pop().unwrap();\n             return t1;"}, {"sha": "cc3abc279bf34da83a4547fc193764a5d668d0f4", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -15,12 +15,12 @@ use middle::ty::TyVar;\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::{cres, CresCompare};\n+use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::InferCtxt;\n-use middle::typeck::infer::lattice::CombineFieldsLatticeMethods;\n use middle::typeck::infer::lub::Lub;\n-use middle::typeck::infer::then;\n use middle::typeck::infer::{TypeTrace, Subtype};\n+use middle::typeck::infer::type_variable::{SubtypeOf, SupertypeOf};\n use util::common::{indenter};\n use util::ppaux::{bound_region_to_string, Repr};\n \n@@ -43,27 +43,23 @@ impl<'f> Combine for Sub<'f> {\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n+    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n     fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n     fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n     fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        let opp = CombineFields {\n-            a_is_expected: !self.fields.a_is_expected,\n-            ..self.fields.clone()\n-        };\n-        Sub(opp).tys(b, a)\n+        Sub(self.fields.switch_expected()).tys(b, a)\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                     -> cres<ty::Region>\n-    {\n-        let opp = CombineFields {\n-            a_is_expected: !self.fields.a_is_expected,\n-            ..self.fields.clone()\n-        };\n-        Sub(opp).regions(b, a)\n-    }\n+                     -> cres<ty::Region> {\n+                         let opp = CombineFields {\n+                             a_is_expected: !self.fields.a_is_expected,\n+                             ..self.fields.clone()\n+                         };\n+                         Sub(opp).regions(b, a)\n+                     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n@@ -84,16 +80,18 @@ impl<'f> Combine for Sub<'f> {\n         }\n \n         match b.mutbl {\n-          MutMutable => {\n-            // If supertype is mut, subtype must match exactly\n-            // (i.e., invariant if mut):\n-            eq_tys(self, a.ty, b.ty).then(|| Ok(*a))\n-          }\n-          MutImmutable => {\n-            // Otherwise we can be covariant:\n-            self.tys(a.ty, b.ty).and_then(|_t| Ok(*a) )\n-          }\n+            MutMutable => {\n+                // If supertype is mut, subtype must match exactly\n+                // (i.e., invariant if mut):\n+                try!(self.equate().tys(a.ty, b.ty));\n+            }\n+            MutImmutable => {\n+                // Otherwise we can be covariant:\n+                try!(self.tys(a.ty, b.ty));\n+            }\n         }\n+\n+        Ok(*a) // return is meaningless in sub, just return *a\n     }\n \n     fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n@@ -126,14 +124,19 @@ impl<'f> Combine for Sub<'f> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         if a == b { return Ok(a); }\n-        let _indenter = indenter();\n+\n+        let infcx = self.fields.infcx;\n+        let a = infcx.type_variables.borrow().replace_if_possible(a);\n+        let b = infcx.type_variables.borrow().replace_if_possible(b);\n         match (&ty::get(a).sty, &ty::get(b).sty) {\n             (&ty::ty_bot, _) => {\n                 Ok(a)\n             }\n \n             (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n-                if_ok!(self.fields.var_sub_var(a_id, b_id));\n+                infcx.type_variables\n+                    .borrow_mut()\n+                    .relate_vars(a_id, SubtypeOf, b_id);\n                 Ok(a)\n             }\n             // The vec/str check here and below is so that we don't unify\n@@ -145,7 +148,9 @@ impl<'f> Combine for Sub<'f> {\n                 Err(ty::terr_sorts(expected_found(self, a, b)))\n             }\n             (&ty::ty_infer(TyVar(a_id)), _) => {\n-                if_ok!(self.fields.var_sub_t(a_id, b));\n+                try!(self.fields\n+                       .switch_expected()\n+                       .instantiate(b, SupertypeOf, a_id));\n                 Ok(a)\n             }\n \n@@ -154,7 +159,7 @@ impl<'f> Combine for Sub<'f> {\n                 Err(ty::terr_sorts(expected_found(self, a, b)))\n             }\n             (_, &ty::ty_infer(TyVar(b_id))) => {\n-                if_ok!(self.fields.t_sub_var(a, b_id));\n+                try!(self.fields.instantiate(a, SubtypeOf, b_id));\n                 Ok(a)\n             }\n "}, {"sha": "5f67f8a048aa4e48148975db250b758319ab6304", "filename": "src/librustc/middle/typeck/infer/type_variable.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty;\n+use std::mem;\n+use util::snapshot_vec as sv;\n+\n+pub struct TypeVariableTable {\n+    values: sv::SnapshotVec<TypeVariableData,UndoEntry,Delegate>,\n+}\n+\n+struct TypeVariableData {\n+    value: TypeVariableValue\n+}\n+\n+enum TypeVariableValue {\n+    Known(ty::t),\n+    Bounded(Vec<Relation>),\n+}\n+\n+pub struct Snapshot {\n+    snapshot: sv::Snapshot\n+}\n+\n+enum UndoEntry {\n+    // The type of the var was specified.\n+    SpecifyVar(ty::TyVid, Vec<Relation>),\n+    Relate(ty::TyVid, ty::TyVid),\n+}\n+\n+struct Delegate;\n+\n+type Relation = (RelationDir, ty::TyVid);\n+\n+#[deriving(PartialEq,Show)]\n+pub enum RelationDir {\n+    SubtypeOf, SupertypeOf, EqTo\n+}\n+\n+impl RelationDir {\n+    fn opposite(self) -> RelationDir {\n+        match self {\n+            SubtypeOf => SupertypeOf,\n+            SupertypeOf => SubtypeOf,\n+            EqTo => EqTo\n+        }\n+    }\n+}\n+\n+impl TypeVariableTable {\n+    pub fn new() -> TypeVariableTable {\n+        TypeVariableTable { values: sv::SnapshotVec::new(Delegate) }\n+    }\n+\n+    fn relations<'a>(&'a mut self, a: ty::TyVid) -> &'a mut Vec<Relation> {\n+        relations(self.values.get_mut(a.index))\n+    }\n+\n+    pub fn relate_vars(&mut self, a: ty::TyVid, dir: RelationDir, b: ty::TyVid) {\n+        /*!\n+         * Records that `a <: b`, `a :> b`, or `a == b`, depending on `dir`.\n+         *\n+         * Precondition: neither `a` nor `b` are known.\n+         */\n+\n+        if a != b {\n+            self.relations(a).push((dir, b));\n+            self.relations(b).push((dir.opposite(), a));\n+            self.values.record(Relate(a, b));\n+        }\n+    }\n+\n+    pub fn instantiate_and_push(\n+        &mut self,\n+        vid: ty::TyVid,\n+        ty: ty::t,\n+        stack: &mut Vec<(ty::t, RelationDir, ty::TyVid)>)\n+    {\n+        /*!\n+         * Instantiates `vid` with the type `ty` and then pushes an\n+         * entry onto `stack` for each of the relations of `vid` to\n+         * other variables. The relations will have the form `(ty,\n+         * dir, vid1)` where `vid1` is some other variable id.\n+         */\n+\n+        let old_value = {\n+            let value_ptr = &mut self.values.get_mut(vid.index).value;\n+            mem::replace(value_ptr, Known(ty))\n+        };\n+\n+        let relations = match old_value {\n+            Bounded(b) => b,\n+            Known(_) => fail!(\"Asked to instantiate variable that is \\\n+                               already instantiated\")\n+        };\n+\n+        for &(dir, vid) in relations.iter() {\n+            stack.push((ty, dir, vid));\n+        }\n+\n+        self.values.record(SpecifyVar(vid, relations));\n+    }\n+\n+    pub fn new_var(&mut self) -> ty::TyVid {\n+        let index =\n+            self.values.push(\n+                TypeVariableData { value: Bounded(Vec::new()) });\n+        ty::TyVid { index: index }\n+    }\n+\n+    pub fn probe(&self, vid: ty::TyVid) -> Option<ty::t> {\n+        match self.values.get(vid.index).value {\n+            Bounded(..) => None,\n+            Known(t) => Some(t)\n+        }\n+    }\n+\n+    pub fn replace_if_possible(&self, t: ty::t) -> ty::t {\n+        match ty::get(t).sty {\n+            ty::ty_infer(ty::TyVar(v)) => {\n+                match self.probe(v) {\n+                    None => t,\n+                    Some(u) => u\n+                }\n+            }\n+            _ => t,\n+        }\n+    }\n+\n+    pub fn snapshot(&mut self) -> Snapshot {\n+        Snapshot { snapshot: self.values.start_snapshot() }\n+    }\n+\n+    pub fn rollback_to(&mut self, s: Snapshot) {\n+        self.values.rollback_to(s.snapshot);\n+    }\n+\n+    pub fn commit(&mut self, s: Snapshot) {\n+        self.values.commit(s.snapshot);\n+    }\n+}\n+\n+impl sv::SnapshotVecDelegate<TypeVariableData,UndoEntry> for Delegate {\n+    fn reverse(&mut self,\n+               values: &mut Vec<TypeVariableData>,\n+               action: UndoEntry) {\n+        match action {\n+            SpecifyVar(vid, relations) => {\n+                values.get_mut(vid.index).value = Bounded(relations);\n+            }\n+\n+            Relate(a, b) => {\n+                relations(values.get_mut(a.index)).pop();\n+                relations(values.get_mut(b.index)).pop();\n+            }\n+        }\n+    }\n+}\n+\n+fn relations<'a>(v: &'a mut TypeVariableData) -> &'a mut Vec<Relation> {\n+    match v.value {\n+        Known(_) => fail!(\"var_sub_var: variable is known\"),\n+        Bounded(ref mut relations) => relations\n+    }\n+}\n+"}, {"sha": "adf0a25ce4002e5f8069c59e27afe1a4b679abaa", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -12,7 +12,7 @@ use std::kinds::marker;\n \n use middle::ty::{expected_found, IntVarValue};\n use middle::ty;\n-use middle::typeck::infer::{Bounds, uok, ures};\n+use middle::typeck::infer::{uok, ures};\n use middle::typeck::infer::InferCtxt;\n use std::cell::RefCell;\n use std::fmt::Show;\n@@ -23,12 +23,12 @@ use util::snapshot_vec as sv;\n /**\n  * This trait is implemented by any type that can serve as a type\n  * variable. We call such variables *unification keys*. For example,\n- * this trait is implemented by `TyVid`, which represents normal\n- * type variables, and `IntVid`, which represents integral variables.\n+ * this trait is implemented by `IntVid`, which represents integral\n+ * variables.\n  *\n- * Each key type has an associated value type `V`. For example,\n- * for `TyVid`, this is `Bounds<ty::t>`, representing a pair of\n- * upper- and lower-bound types.\n+ * Each key type has an associated value type `V`. For example, for\n+ * `IntVid`, this is `Option<IntVarValue>`, representing some\n+ * (possibly not yet known) sort of integer.\n  *\n  * Implementations of this trait are at the end of this file.\n  */\n@@ -48,11 +48,10 @@ pub trait UnifyKey<V> : Clone + Show + PartialEq + Repr {\n }\n \n /**\n- * Trait for valid types that a type variable can be set to.  Note\n- * that this is typically not the end type that the value will\n- * take on, but rather some wrapper: for example, for normal type\n- * variables, the associated type is not `ty::t` but rather\n- * `Bounds<ty::t>`.\n+ * Trait for valid types that a type variable can be set to. Note that\n+ * this is typically not the end type that the value will take on, but\n+ * rather an `Option` wrapper (where `None` represents a variable\n+ * whose value is not yet set).\n  *\n  * Implementations of this trait are at the end of this file.\n  */\n@@ -109,9 +108,9 @@ pub struct Node<K,V> {\n pub struct Delegate;\n \n // We can't use V:LatticeValue, much as I would like to,\n-// because frequently the pattern is that V=Bounds<U> for some\n+// because frequently the pattern is that V=Option<U> for some\n // other type parameter U, and we have no way to say\n-// Bounds<U>:\n+// Option<U>:LatticeValue.\n \n impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n     pub fn new() -> UnificationTable<K,V> {\n@@ -375,26 +374,6 @@ impl<'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n \n ///////////////////////////////////////////////////////////////////////////\n \n-// General type keys\n-\n-impl UnifyKey<Bounds<ty::t>> for ty::TyVid {\n-    fn index(&self) -> uint { self.index }\n-\n-    fn from_index(i: uint) -> ty::TyVid { ty::TyVid { index: i } }\n-\n-    fn unification_table<'v>(infcx: &'v InferCtxt)\n-        -> &'v RefCell<UnificationTable<ty::TyVid, Bounds<ty::t>>>\n-    {\n-        return &infcx.type_unification_table;\n-    }\n-\n-    fn tag(_: Option<ty::TyVid>) -> &'static str {\n-        \"TyVid\"\n-    }\n-}\n-\n-impl UnifyValue for Bounds<ty::t> { }\n-\n // Integral type keys\n \n impl UnifyKey<Option<IntVarValue>> for ty::IntVid {"}, {"sha": "995ae7b3d44e70632669f9bc53a91942b38de75b", "filename": "src/test/compile-fail/issue-10291.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn test<'x>(x: &'x int) {\n-    drop::< <'z>|&'z int| -> &'z int>(|z| {\n+    drop::< <'z>|&'z int| -> &'z int >(|z| {\n         x\n         //~^ ERROR cannot infer an appropriate lifetime\n     });"}, {"sha": "2d7458944269cb24efe2ed5796c76b944e59fc0c", "filename": "src/test/compile-fail/issue-13482.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -12,7 +12,7 @@ fn main() {\n   let x = [1,2];\n   let y = match x {\n     [] => None,\n-//~^ ERROR expected `[<generic integer #1>, .. 2]`, found a fixed vector pattern of size 0\n+//~^ ERROR expected `[<generic integer #0>, .. 2]`, found a fixed vector pattern of size 0\n     [a,_] => Some(a)\n   };\n }"}, {"sha": "305b1fe2ad7ded015e6c6b79eba5fdf60ded30de", "filename": "src/test/compile-fail/issue-16338.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -12,6 +12,6 @@ use std::raw::Slice;\n \n fn main() {\n     let Slice { data: data, len: len } = \"foo\";\n-    //~^ ERROR mismatched types: expected `&'static str`, found a structure pattern\n+    //~^ ERROR mismatched types: expected `&str`, found a structure pattern\n }\n "}, {"sha": "5d07472afbb2572ea7b1f4b13ed9803304c5a086", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -22,5 +22,5 @@ impl<A> vec_monad<A> for Vec<A> {\n }\n fn main() {\n     [\"hi\"].bind(|x| [x] );\n-    //~^ ERROR type `[&'static str, .. 1]` does not implement any method in scope named `bind`\n+    //~^ ERROR type `[&str, .. 1]` does not implement any method in scope named `bind`\n }"}, {"sha": "6a90fd553560470680b3d956086e15d18af75601", "filename": "src/test/compile-fail/kindck-send-object1.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test which object types are considered sendable. This test\n+// is broken into two parts because some errors occur in distinct\n+// phases in the compiler. See kindck-send-object2.rs as well!\n+\n+fn assert_send<T:Send>() { }\n+trait Dummy { }\n+\n+// careful with object types, who knows what they close over...\n+fn test51<'a>() {\n+    assert_send::<&'a Dummy>(); //~ ERROR does not fulfill the required lifetime\n+}\n+fn test52<'a>() {\n+    assert_send::<&'a Dummy+Send>(); //~ ERROR does not fulfill the required lifetime\n+}\n+\n+// ...unless they are properly bounded\n+fn test60() {\n+    assert_send::<&'static Dummy+Send>();\n+}\n+fn test61() {\n+    assert_send::<Box<Dummy+Send>>();\n+}\n+\n+// closure and object types can have lifetime bounds which make\n+// them not ok\n+fn test_70<'a>() {\n+    assert_send::<proc():'a>(); //~ ERROR does not fulfill the required lifetime\n+}\n+\n+fn test_71<'a>() {\n+    assert_send::<Box<Dummy+'a>>(); //~ ERROR does not fulfill the required lifetime\n+}\n+\n+fn main() { }"}, {"sha": "75006477837c2bd2323e119043b8c48f01a3b564", "filename": "src/test/compile-fail/kindck-send-object2.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object2.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Continue kindck-send-object1.rs.\n+\n+fn assert_send<T:Send>() { }\n+trait Dummy { }\n+\n+fn test50() {\n+    assert_send::<&'static Dummy>(); //~ ERROR does not fulfill `Send`\n+}\n+\n+fn test53() {\n+    assert_send::<Box<Dummy>>(); //~ ERROR does not fulfill `Send`\n+}\n+\n+// ...unless they are properly bounded\n+fn test60() {\n+    assert_send::<&'static Dummy+Send>();\n+}\n+fn test61() {\n+    assert_send::<Box<Dummy+Send>>();\n+}\n+\n+fn main() { }"}, {"sha": "0eed05692b9c5ddf505d96966ff68f812d15187a", "filename": "src/test/compile-fail/kindck-send-owned.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-owned.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test which of the builtin types are considered sendable.\n+\n+fn assert_send<T:Send>() { }\n+\n+// owned content are ok\n+fn test30() { assert_send::<Box<int>>(); }\n+fn test31() { assert_send::<String>(); }\n+fn test32() { assert_send::<Vec<int> >(); }\n+\n+// but not if they own a bad thing\n+fn test40<'a>(_: &'a int) {\n+    assert_send::<Box<&'a int>>(); //~ ERROR does not fulfill the required lifetime\n+}\n+\n+fn main() { }"}, {"sha": "cc46d7f4de9c0ef529ac0b8a9d70eb1edc3d86d7", "filename": "src/test/compile-fail/kindck-send-region-pointers.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-region-pointers.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that borrowed pointers are not sendable unless 'static.\n+\n+fn assert_send<T:Send>() { }\n+\n+// lifetime pointers with 'static lifetime are ok\n+fn test01() { assert_send::<&'static int>(); }\n+fn test02() { assert_send::<&'static str>(); }\n+fn test03() { assert_send::<&'static [int]>(); }\n+\n+// whether or not they are mutable\n+fn test10() { assert_send::<&'static mut int>(); }\n+\n+// otherwise lifetime pointers are not ok\n+fn test20<'a>(_: &'a int) {\n+    assert_send::<&'a int>(); //~ ERROR does not fulfill the required lifetime\n+}\n+fn test21<'a>(_: &'a int) {\n+    assert_send::<&'a str>(); //~ ERROR does not fulfill the required lifetime\n+}\n+fn test22<'a>(_: &'a int) {\n+    assert_send::<&'a [int]>(); //~ ERROR does not fulfill the required lifetime\n+}\n+\n+fn main() { }"}, {"sha": "a9bbfcfa26263c50fba60f3bcab62077bf7b5e0b", "filename": "src/test/compile-fail/kindck-send-unsafe.rs", "status": "renamed", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-unsafe.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n+fn assert_send<T:Send>() { }\n \n-macro_rules! if_ok(\n-    ($inp: expr) => (\n-        match $inp {\n-            Ok(v) => { v }\n-            Err(e) => { return Err(e); }\n-        }\n-    )\n-)\n+// unsafe ptrs are ok unless they point at unsendable things\n+fn test70() {\n+    assert_send::<*mut int>();\n+}\n+fn test71<'a>() {\n+    assert_send::<*mut &'a int>(); //~ ERROR does not fulfill the required lifetime\n+}\n+\n+fn main() {\n+}", "previous_filename": "src/librustc/middle/typeck/infer/macros.rs"}, {"sha": "e13a6b211a5038b7526b532bcb9adde394c2c02f", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -17,12 +17,10 @@ struct a_class<'a> { x:&'a int }\n \n fn a_fn1<'a,'b>(e: an_enum<'a>) -> an_enum<'b> {\n     return e; //~ ERROR mismatched types: expected `an_enum<'b>`, found `an_enum<'a>`\n-    //~^ ERROR cannot infer\n }\n \n fn a_fn3<'a,'b>(e: a_class<'a>) -> a_class<'b> {\n     return e; //~ ERROR mismatched types: expected `a_class<'b>`, found `a_class<'a>`\n-    //~^ ERROR cannot infer\n }\n \n fn main() { }"}, {"sha": "66103eb95888ac941e1cf123c8641d2b0978c584", "filename": "src/test/compile-fail/regions-escape-bound-fn-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -15,7 +15,6 @@ fn with_int(f: |x: &int|) {\n \n fn main() {\n     let mut x = None;\n-         //~^ ERROR lifetime of variable does not enclose its declaration\n-         //~^^ ERROR type of expression contains references that are not valid during the expression\n     with_int(|y| x = Some(y));\n+         //~^ ERROR cannot infer\n }"}, {"sha": "fee84cf9656d1ceaae73f4fb5d02a75c55a63579", "filename": "src/test/compile-fail/regions-escape-bound-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -14,6 +14,6 @@ fn with_int(f: |x: &int|) {\n }\n \n fn main() {\n-    let mut x: Option<&int> = None;   //~ ERROR cannot infer\n-    with_int(|y| x = Some(y));\n+    let mut x: Option<&int> = None;\n+    with_int(|y| x = Some(y));   //~ ERROR cannot infer\n }"}, {"sha": "b73b5e0649ff5a76a6a7afd612c613183786acbc", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -27,7 +27,7 @@ fn with<R:Deref>(f: |x: &int| -> R) -> int {\n }\n \n fn return_it() -> int {\n-    with(|o| o) //~ ERROR cannot infer an appropriate lifetime\n+    with(|o| o) //~ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "8af341e3ace42b9d949319d92199f98008180d8b", "filename": "src/test/compile-fail/regions-infer-at-fn-not-param.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -22,7 +22,6 @@ struct not_parameterized2 {\n \n fn take1<'a>(p: parameterized1) -> parameterized1<'a> { p }\n //~^ ERROR mismatched types\n-//~^^ ERROR cannot infer\n \n fn take3(p: not_parameterized1) -> not_parameterized1 { p }\n fn take4(p: not_parameterized2) -> not_parameterized2 { p }"}, {"sha": "4dd028b78845996e18acfdb6f65d1a0446260bac", "filename": "src/test/compile-fail/regions-infer-contravariance-due-to-decl.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-contravariance-due-to-decl.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -33,7 +33,6 @@ fn use_<'short,'long>(c: Contravariant<'short>,\n     // covariant with respect to its parameter 'a.\n \n     let _: Contravariant<'long> = c; //~ ERROR mismatched types\n-    //~^ ERROR  cannot infer an appropriate lifetime\n }\n \n fn main() {}"}, {"sha": "93c06aecd30ecffdaf5ad5d732071fa44c06f59b", "filename": "src/test/compile-fail/regions-infer-covariance-due-to-decl.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-covariance-due-to-decl.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -30,7 +30,6 @@ fn use_<'short,'long>(c: Covariant<'long>,\n     // contravariant with respect to its parameter 'a.\n \n     let _: Covariant<'short> = c; //~ ERROR mismatched types\n-    //~^ ERROR  cannot infer an appropriate lifetime\n }\n \n fn main() {}"}, {"sha": "b84f13ec37feb44d16654af4e6bf795c965046f3", "filename": "src/test/compile-fail/regions-infer-not-param.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -23,11 +23,9 @@ struct indirect2<'a> {\n }\n \n fn take_direct<'a,'b>(p: direct<'a>) -> direct<'b> { p } //~ ERROR mismatched types\n-//~^ ERROR cannot infer\n \n fn take_indirect1(p: indirect1) -> indirect1 { p }\n \n fn take_indirect2<'a,'b>(p: indirect2<'a>) -> indirect2<'b> { p } //~ ERROR mismatched types\n-//~^ ERROR cannot infer\n \n fn main() {}"}, {"sha": "e862b36dcd1680a2ddd7d8408fd921c13676a125", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -22,18 +22,17 @@ struct c<'a> {\n }\n \n trait set_f<'a> {\n-    fn set_f_ok(&self, b: Gc<b<'a>>);\n-    fn set_f_bad(&self, b: Gc<b>);\n+    fn set_f_ok(&mut self, b: Gc<b<'a>>);\n+    fn set_f_bad(&mut self, b: Gc<b>);\n }\n \n impl<'a> set_f<'a> for c<'a> {\n-    fn set_f_ok(&self, b: Gc<b<'a>>) {\n+    fn set_f_ok(&mut self, b: Gc<b<'a>>) {\n         self.f = b;\n     }\n \n-    fn set_f_bad(&self, b: Gc<b>) {\n+    fn set_f_bad(&mut self, b: Gc<b>) {\n         self.f = b; //~ ERROR mismatched types: expected `Gc<Gc<&'a int>>`, found `Gc<Gc<&int>>`\n-        //~^ ERROR cannot infer\n     }\n }\n "}, {"sha": "783009f6dcbfca4ae240e83f81517911d598d353", "filename": "src/test/compile-fail/regions-reborrow-from-shorter-mut-ref-mut-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -11,7 +11,7 @@\n // Issue #8624. Test for reborrowing with 3 levels, not just two.\n \n fn copy_borrowed_ptr<'a, 'b, 'c>(p: &'a mut &'b mut &'c mut int) -> &'b mut int {\n-    &mut ***p //~ ERROR lifetime of `p` is too short to guarantee its contents\n+    &mut ***p //~ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "6d9b2619171057fd632f836e258d478965f2c584", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -19,8 +19,6 @@ fn with<R>(f: <'a>|x: &'a int| -> R) -> R {\n fn return_it<'a>() -> &'a int {\n     with(|o| o)\n         //~^ ERROR cannot infer\n-        //~^^ ERROR not valid during the expression\n-        //~^^^ ERROR not valid at this point\n }\n \n fn main() {"}, {"sha": "465f4410fbbccb2d05451c0db6240e5433815a9f", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -22,8 +22,6 @@ fn with<R>(f: |x: &int| -> R) -> R {\n fn return_it<'a>() -> &'a int {\n     with(|o| o)\n         //~^ ERROR cannot infer\n-        //~^^ ERROR not valid during the expression\n-        //~^^^ ERROR not valid at this point\n }\n \n fn main() {"}, {"sha": "14ead8da1587b12189c23015e1f09414c5765de3", "filename": "src/test/compile-fail/regions-variance-contravariant-use-covariant-in-second-position.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant-in-second-position.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -33,7 +33,6 @@ fn use_<'short,'long>(c: S<'long, 'short>,\n     // covariant with respect to its parameter 'a.\n \n     let _: S<'long, 'long> = c; //~ ERROR mismatched types\n-    //~^ ERROR  cannot infer an appropriate lifetime\n }\n \n fn main() {}"}, {"sha": "3fc58071d2ce86c421b8e4cb09774224881ee8f4", "filename": "src/test/compile-fail/regions-variance-contravariant-use-covariant.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-contravariant-use-covariant.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -31,7 +31,6 @@ fn use_<'short,'long>(c: Contravariant<'short>,\n     // covariant with respect to its parameter 'a.\n \n     let _: Contravariant<'long> = c; //~ ERROR mismatched types\n-    //~^ ERROR  cannot infer an appropriate lifetime\n }\n \n fn main() {}"}, {"sha": "844c8151a642ae31f59ba28ef922f524da989894", "filename": "src/test/compile-fail/regions-variance-covariant-use-contravariant.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-variance-covariant-use-contravariant.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -31,7 +31,6 @@ fn use_<'short,'long>(c: Covariant<'long>,\n     // contravariant with respect to its parameter 'a.\n \n     let _: Covariant<'short> = c; //~ ERROR mismatched types\n-    //~^ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {}"}, {"sha": "0eacb27a600bd849dc4624b3e3477be93b7d0c41", "filename": "src/test/run-pass/regions-scope-chain-example.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Frun-pass%2Fregions-scope-chain-example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c012514169b1c26f47e4b2ec9abc72686fd04e1/src%2Ftest%2Frun-pass%2Fregions-scope-chain-example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-scope-chain-example.rs?ref=4c012514169b1c26f47e4b2ec9abc72686fd04e1", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is an example where the older inference algorithm failed. The\n+// specifics of why it failed are somewhat, but not entirely, tailed\n+// to the algorithm. Ultimately the problem is that when computing the\n+// mutual supertype of both sides of the `if` it would be faced with a\n+// choice of tightening bounds or unifying variables and it took the\n+// wrong path. The new algorithm avoids this problem and hence this\n+// example typechecks correctly.\n+\n+enum ScopeChain<'a> {\n+    Link(Scope<'a>),\n+    End\n+}\n+\n+type Scope<'a> = &'a ScopeChain<'a>;\n+\n+struct OuterContext;\n+\n+struct Context<'a> {\n+    foo: &'a OuterContext\n+}\n+\n+impl<'a> Context<'a> {\n+    fn foo(&mut self, scope: Scope) {\n+        let link = if 1i < 2 {\n+            let l = Link(scope);\n+            self.take_scope(&l);\n+            l\n+        } else {\n+            Link(scope)\n+        };\n+        self.take_scope(&link);\n+    }\n+\n+    fn take_scope(&mut self, x: Scope) {\n+    }\n+}\n+\n+fn main() { }"}]}