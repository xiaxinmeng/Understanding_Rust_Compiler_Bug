{"sha": "17ab457f21700caad62c3f3fcfeff48f21d2393b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3YWI0NTdmMjE3MDBjYWFkNjJjM2YzZmNmZWZmNDhmMjFkMjM5M2I=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-03T12:16:25Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-11T22:09:00Z"}, "message": "Somewhat complicated way to respect BTreeMap's node length invariant", "tree": {"sha": "23913ff521a3554e7b34165852b2ef0cf26154fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23913ff521a3554e7b34165852b2ef0cf26154fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17ab457f21700caad62c3f3fcfeff48f21d2393b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17ab457f21700caad62c3f3fcfeff48f21d2393b", "html_url": "https://github.com/rust-lang/rust/commit/17ab457f21700caad62c3f3fcfeff48f21d2393b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17ab457f21700caad62c3f3fcfeff48f21d2393b/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "441fd2255763c2aeea616aeac61b2c795a4c5330", "url": "https://api.github.com/repos/rust-lang/rust/commits/441fd2255763c2aeea616aeac61b2c795a4c5330", "html_url": "https://github.com/rust-lang/rust/commit/441fd2255763c2aeea616aeac61b2c795a4c5330"}], "stats": {"total": 81, "additions": 65, "deletions": 16}, "files": [{"sha": "aa959c667accf1a2814eb40fb7b0ec7b81299aed", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 65, "deletions": 16, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/17ab457f21700caad62c3f3fcfeff48f21d2393b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ab457f21700caad62c3f3fcfeff48f21d2393b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=17ab457f21700caad62c3f3fcfeff48f21d2393b", "patch": "@@ -821,6 +821,53 @@ impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, mar\n     }\n }\n \n+enum InsertionPlace {\n+    Left(usize),\n+    Right(usize),\n+}\n+\n+/// Given an edge index where we want to insert into a node filled to capacity,\n+/// computes a sensible KV index of a split point and where to perform the insertion.\n+/// The goal of the split point is for its key and value to end up in a parent node;\n+/// the keys, values and edges to the left of the split point become the left child;\n+/// the keys, values and edges to the right of the split point become the right child.\n+fn splitpoint(edge_idx: usize) -> (usize, InsertionPlace) {\n+    debug_assert!(edge_idx <= CAPACITY);\n+    // Rust issue #74834 tries to explain these symmetric rules.\n+    let middle_kv_idx;\n+    let insertion;\n+    if edge_idx <= B - 2 {\n+        middle_kv_idx = B - 2;\n+        insertion = InsertionPlace::Left(edge_idx);\n+    } else if edge_idx == B - 1 {\n+        middle_kv_idx = B - 1;\n+        insertion = InsertionPlace::Left(edge_idx);\n+    } else if edge_idx == B {\n+        middle_kv_idx = B - 1;\n+        insertion = InsertionPlace::Right(0);\n+    } else {\n+        middle_kv_idx = B;\n+        let new_edge_idx = edge_idx - (B + 1);\n+        insertion = InsertionPlace::Right(new_edge_idx);\n+    }\n+    let mut left_len = middle_kv_idx;\n+    let mut right_len = CAPACITY - middle_kv_idx - 1;\n+    match insertion {\n+        InsertionPlace::Left(edge_idx) => {\n+            debug_assert!(edge_idx <= left_len);\n+            left_len += 1;\n+        }\n+        InsertionPlace::Right(edge_idx) => {\n+            debug_assert!(edge_idx <= right_len);\n+            right_len += 1;\n+        }\n+    }\n+    debug_assert!(left_len >= MIN_LEN);\n+    debug_assert!(right_len >= MIN_LEN);\n+    debug_assert!(left_len + right_len == CAPACITY);\n+    (middle_kv_idx, insertion)\n+}\n+\n impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::Edge> {\n     /// Helps implementations of `insert_fit` for a particular `NodeType`,\n     /// by taking care of leaf data.\n@@ -863,18 +910,20 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n             let kv = unsafe { Handle::new_kv(self.node, self.idx) };\n             (InsertResult::Fit(kv), ptr)\n         } else {\n-            let middle = unsafe { Handle::new_kv(self.node, B) };\n+            let (middle_kv_idx, insertion) = splitpoint(self.idx);\n+            let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let (mut left, k, v, mut right) = middle.split();\n-            let ptr = if self.idx <= B {\n-                unsafe { Handle::new_edge(left.reborrow_mut(), self.idx).insert_fit(key, val) }\n-            } else {\n-                unsafe {\n+            let ptr = match insertion {\n+                InsertionPlace::Left(insert_idx) => unsafe {\n+                    Handle::new_edge(left.reborrow_mut(), insert_idx).insert_fit(key, val)\n+                },\n+                InsertionPlace::Right(insert_idx) => unsafe {\n                     Handle::new_edge(\n                         right.node_as_mut().cast_unchecked::<marker::Leaf>(),\n-                        self.idx - (B + 1),\n+                        insert_idx,\n                     )\n                     .insert_fit(key, val)\n-                }\n+                },\n             };\n             (InsertResult::Split(SplitResult { left: left.forget_type(), k, v, right }), ptr)\n         }\n@@ -936,20 +985,20 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             let kv = unsafe { Handle::new_kv(self.node, self.idx) };\n             InsertResult::Fit(kv)\n         } else {\n-            let middle = unsafe { Handle::new_kv(self.node, B) };\n+            let (middle_kv_idx, insertion) = splitpoint(self.idx);\n+            let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let (mut left, k, v, mut right) = middle.split();\n-            if self.idx <= B {\n-                unsafe {\n-                    Handle::new_edge(left.reborrow_mut(), self.idx).insert_fit(key, val, edge);\n-                }\n-            } else {\n-                unsafe {\n+            match insertion {\n+                InsertionPlace::Left(insert_idx) => unsafe {\n+                    Handle::new_edge(left.reborrow_mut(), insert_idx).insert_fit(key, val, edge);\n+                },\n+                InsertionPlace::Right(insert_idx) => unsafe {\n                     Handle::new_edge(\n                         right.node_as_mut().cast_unchecked::<marker::Internal>(),\n-                        self.idx - (B + 1),\n+                        insert_idx,\n                     )\n                     .insert_fit(key, val, edge);\n-                }\n+                },\n             }\n             InsertResult::Split(SplitResult { left: left.forget_type(), k, v, right })\n         }"}]}