{"sha": "0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZjRlODYwZGExZmI3NTViOWZmZjVkMWIzMGJlZTM5NzQ1MTRlYTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-06T18:02:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-06T18:02:28Z"}, "message": "Replace NOTE with FIXME", "tree": {"sha": "fd3e2913a88bdba052834e9fdbf6deb81ac5fbdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd3e2913a88bdba052834e9fdbf6deb81ac5fbdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "html_url": "https://github.com/rust-lang/rust/commit/0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c50a9d5b664478e533ba1d1d353213d70c8ad589", "url": "https://api.github.com/repos/rust-lang/rust/commits/c50a9d5b664478e533ba1d1d353213d70c8ad589", "html_url": "https://github.com/rust-lang/rust/commit/c50a9d5b664478e533ba1d1d353213d70c8ad589"}], "stats": {"total": 60, "additions": 31, "deletions": 29}, "files": [{"sha": "ba719fe34d719a1c2bd24e4acbdf0d6abdf975e9", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "patch": "@@ -579,7 +579,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n             }\n         }\n \n-        // NOTE inadequare if/when we permit `move a.b`\n+        // FIXME(#4384) inadequare if/when we permit `move a.b`\n \n         // check for a conflicting loan:\n         for opt_loan_path(cmt).each |&lp| {\n@@ -604,7 +604,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         // However, I added it for consistency and lest the system\n         // should change in the future.\n         //\n-        // FIXME(#5074) nested method calls\n+        // FIXME(#6268) nested method calls\n         // self.check_for_conflicting_loans(callee_id);\n     }\n }"}, {"sha": "5f3c5d977fef54bed40cdabcde0f24daf48d8dde", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "patch": "@@ -389,7 +389,7 @@ pub impl GatherLoanCtxt {\n         self.all_loans.push(loan);\n \n         // if loan_gen_scope != borrow_id {\n-            // NOTE handle case where gen_scope is not borrow_id\n+            // FIXME(#6268) Nested method calls\n             //\n             // Typically, the scope of the loan includes the point at\n             // which the loan is originated. This"}, {"sha": "68e70d245f779fab8d399d81a77a81055b42758d", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "patch": "@@ -516,7 +516,7 @@ pub impl BorrowckCtxt {\n                     fmt!(\"%s in an aliasable location\", prefix));\n             }\n             mc::AliasableManaged(ast::m_mutbl) => {\n-                // FIXME(#5074) we should prob do this borrow\n+                // FIXME(#6269) reborrow @mut to &mut\n                 self.tcx.sess.span_err(\n                     span,\n                     fmt!(\"%s in a `@mut` pointer; \\"}, {"sha": "ccb34851046bd9fa120cb1d52a985d4033c6900c", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "patch": "@@ -808,7 +808,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         self.walk_expr(arg0, in_out, loop_scopes);\n         self.walk_exprs(args, in_out, loop_scopes);\n \n-        // FIXME(#5074) nested method calls\n+        // FIXME(#6268) nested method calls\n         // self.merge_with_entry_set(callee_id, in_out);\n         // self.dfcx.apply_gen_kill(callee_id, in_out);\n "}, {"sha": "cdc3aa9fedb7ef57e0f509e7f62a1bfb2edebcad", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "patch": "@@ -393,7 +393,7 @@ pub fn resolve_expr(expr: @ast::expr, cx: Context, visitor: visit::vt<Context>)\n     match expr.node {\n         ast::expr_assign_op(*) | ast::expr_index(*) | ast::expr_binary(*) |\n         ast::expr_unary(*) | ast::expr_call(*) | ast::expr_method_call(*) => {\n-            // FIXME(#5074) Nested method calls\n+            // FIXME(#6268) Nested method calls\n             //\n             // The lifetimes for a call or method call look as follows:\n             //\n@@ -949,7 +949,6 @@ pub fn determine_rp_in_crate(sess: Session,\n         while cx.worklist.len() != 0 {\n             let c_id = cx.worklist.pop();\n             let c_variance = cx.region_paramd_items.get_copy(&c_id);\n-            // NOTE cleanup scopes cause an exaggerated lock here\n             debug!(\"popped %d from worklist\", c_id);\n             match cx.dep_map.find(&c_id) {\n               None => {}"}, {"sha": "34f798ec7a6311d58f431525a8f6f0b19cf50e44", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "patch": "@@ -998,7 +998,7 @@ pub fn find_bcx_for_scope(bcx: block, scope_id: ast::node_id) -> block {\n                 return bcx_sid\n               }\n \n-                // NOTE This is messier than it ought to be and not really right\n+                // FIXME(#6268, #6248) hacky cleanup for nested method calls\n                 Some(NodeInfo { callee_id: Some(id), _ }) if id == scope_id => {\n                     return bcx_sid\n                 }"}, {"sha": "0e8b2e0474661d09de19bb840eeb6463a547fb5e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "patch": "@@ -250,7 +250,8 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n         let tcx = bcx.tcx();\n         let unit_ty = ty::sequence_element_type(tcx, datum.ty);\n-        // NOTE prob need to distinguish \"auto-slice\" from explicit index?\n+\n+        // FIXME(#6272) need to distinguish \"auto-slice\" from explicit index?\n         let (bcx, base, len) =\n             datum.get_vec_base_and_len(bcx, expr.span, expr.id);\n "}, {"sha": "9bbf50397c35a31b6c3dd8aa5224b926726068cd", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "patch": "@@ -75,11 +75,11 @@ fn traverse_def_id(cx: @mut ctx, did: def_id) {\n         Some(&ast_map::node_item(item, _)) => traverse_public_item(cx, item),\n         Some(&ast_map::node_method(_, impl_id, _)) => traverse_def_id(cx, impl_id),\n         Some(&ast_map::node_foreign_item(item, _, _, _)) => {\n-            let cx = &mut *cx; // NOTE reborrow @mut\n+            let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n             cx.rmap.insert(item.id);\n         }\n         Some(&ast_map::node_variant(ref v, _, _)) => {\n-            let cx = &mut *cx; // NOTE reborrow @mut\n+            let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n             cx.rmap.insert(v.node.id);\n         }\n         _ => ()\n@@ -109,7 +109,7 @@ fn traverse_public_item(cx: @mut ctx, item: @item) {\n       item_foreign_mod(ref nm) => {\n           if !traverse_exports(cx, item.id) {\n               for nm.items.each |item| {\n-                  let cx = &mut *cx; // NOTE reborrow @mut\n+                  let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n                   cx.rmap.insert(item.id);\n               }\n           }\n@@ -127,7 +127,7 @@ fn traverse_public_item(cx: @mut ctx, item: @item) {\n                 attr::find_inline_attr(m.attrs) != attr::ia_none\n             {\n                 {\n-                    let cx = &mut *cx; // NOTE reborrow @mut\n+                    let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n                     cx.rmap.insert(m.id);\n                 }\n                 traverse_inline_body(cx, &m.body);\n@@ -136,7 +136,7 @@ fn traverse_public_item(cx: @mut ctx, item: @item) {\n       }\n       item_struct(ref struct_def, _) => {\n         for struct_def.ctor_id.each |&ctor_id| {\n-            let cx = &mut *cx; // NOTE reborrow @mut\n+            let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n             cx.rmap.insert(ctor_id);\n         }\n       }\n@@ -153,7 +153,7 @@ fn traverse_public_item(cx: @mut ctx, item: @item) {\n \n fn traverse_ty<'a>(ty: @Ty, cx: @mut ctx<'a>, v: visit::vt<@mut ctx<'a>>) {\n     {\n-        let cx = &mut *cx; // NOTE reborrow @mut\n+        let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n         if cx.rmap.contains(&ty.id) { return; }\n         cx.rmap.insert(ty.id);\n     }"}, {"sha": "e171765ef6c4ef82d686e9b99b461a2b3f5a8064", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "patch": "@@ -1301,12 +1301,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // Store the type of `f` as the type of the callee\n         let fn_ty = fcx.expr_ty(f);\n \n-        // NOTE here we write the callee type before regions have been\n-        // substituted; in the method case, we write the type after\n-        // regions have been substituted. Methods are correct, but it\n-        // is awkward to deal with this now. Best thing would I think\n-        // be to just have a separate \"callee table\" that contains the\n-        // FnSig and not a general purpose ty::t\n+        // FIXME(#6273) should write callee type AFTER regions have\n+        // been subst'd.  However, it is awkward to deal with this\n+        // now. Best thing would I think be to just have a separate\n+        // \"callee table\" that contains the FnSig and not a general\n+        // purpose ty::t\n         fcx.write_ty(call_expr.callee_id, fn_ty);\n \n         // Extract the function signature from `in_fty`."}, {"sha": "491c7fadb18bd518b871abb0b6829c785d3bed3b", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ef4e860da1fb755b9fff5d1b30bee3974514ea2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=0ef4e860da1fb755b9fff5d1b30bee3974514ea2", "patch": "@@ -157,14 +157,17 @@ pub fn regionck_fn(fcx: @mut FnCtxt, blk: &ast::blk) {\n }\n \n fn regionck_visitor() -> rvt {\n+    // FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n+    // However, right now we run into an issue whereby some free\n+    // regions are not properly related if they appear within the\n+    // types of arguments that must be inferred. This could be\n+    // addressed by deferring the construction of the region\n+    // hierarchy, and in particular the relationships between free\n+    // regions, until regionck, as described in #3238.\n     visit::mk_vt(@visit::Visitor {visit_item: visit_item,\n                                   visit_expr: visit_expr,\n \n-                                  // NOTE this should be visit_pat\n-                                  // but causes errors in formal\n-                                  // arguments in closures due to\n-                                  // #XYZ!\n-                                  //visit_pat: visit_pat,\n+                                  //visit_pat: visit_pat, // (*) see FIXME above\n                                   visit_arm: visit_arm,\n                                   visit_local: visit_local,\n \n@@ -294,7 +297,7 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n                     // Require that the resulting region encompasses\n                     // the current node.\n                     //\n-                    // FIXME(#5074) remove to support nested method calls\n+                    // FIXME(#6268) remove to support nested method calls\n                     constrain_regions_in_type_of_node(\n                         rcx, expr.id, ty::re_scope(expr.id), expr.span);\n                 }\n@@ -374,7 +377,7 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n             // the type of the node expr.id here *before applying\n             // adjustments*.\n             //\n-            // FIXME(#5074) nested method calls requires that this rule change\n+            // FIXME(#6268) nested method calls requires that this rule change\n             let ty0 = rcx.resolve_node_type(expr.id);\n             constrain_regions_in_type(rcx, ty::re_scope(expr.id), expr.span, ty0);\n         }\n@@ -462,7 +465,7 @@ fn constrain_call(rcx: @mut Rcx,\n     // `callee_region` is the scope representing the time in which the\n     // call occurs.\n     //\n-    // FIXME(#5074) to support nested method calls, should be callee_id\n+    // FIXME(#6268) to support nested method calls, should be callee_id\n     let callee_scope = call_expr.id;\n     let callee_region = ty::re_scope(callee_scope);\n "}]}