{"sha": "f463621a90af486c12fe2b1bd961ab773e25c576", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NjM2MjFhOTBhZjQ4NmMxMmZlMmIxYmQ5NjFhYjc3M2UyNWM1NzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-03T08:36:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-03T08:36:58Z"}, "message": "Auto merge of #878 - RalfJung:rustup, r=RalfJung\n\nRustup for error changes", "tree": {"sha": "97a4eae28f1d4a0e5cdc59f68e83756ad386fd93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97a4eae28f1d4a0e5cdc59f68e83756ad386fd93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f463621a90af486c12fe2b1bd961ab773e25c576", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f463621a90af486c12fe2b1bd961ab773e25c576", "html_url": "https://github.com/rust-lang/rust/commit/f463621a90af486c12fe2b1bd961ab773e25c576", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f463621a90af486c12fe2b1bd961ab773e25c576/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "079b53e70ed3cb08a1dcfa31a541e6c674f6429a", "url": "https://api.github.com/repos/rust-lang/rust/commits/079b53e70ed3cb08a1dcfa31a541e6c674f6429a", "html_url": "https://github.com/rust-lang/rust/commit/079b53e70ed3cb08a1dcfa31a541e6c674f6429a"}, {"sha": "312b546026c59549e860cf939bc20f1117f5c93f", "url": "https://api.github.com/repos/rust-lang/rust/commits/312b546026c59549e860cf939bc20f1117f5c93f", "html_url": "https://github.com/rust-lang/rust/commit/312b546026c59549e860cf939bc20f1117f5c93f"}], "stats": {"total": 156, "additions": 78, "deletions": 78}, "files": [{"sha": "8fbf6d7425bb11c036ef4feadc449abd5cf00cc3", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f463621a90af486c12fe2b1bd961ab773e25c576/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/f463621a90af486c12fe2b1bd961ab773e25c576/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=f463621a90af486c12fe2b1bd961ab773e25c576", "patch": "@@ -1 +1 @@\n-8b94e9e9188b65df38a5f1ae723617dc2dfb3155\n+d7270712cb446aad0817040bbca73a8d024f67b0"}, {"sha": "837757c1ad3b5cfdd0395210c0ea0c20d07057f5", "filename": "src/eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=f463621a90af486c12fe2b1bd961ab773e25c576", "patch": "@@ -41,7 +41,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     let main_mir = ecx.load_mir(main_instance.def)?;\n \n     if !main_mir.return_ty().is_unit() || main_mir.arg_count != 0 {\n-        return err!(Unimplemented(\n+        throw_unsup!(Unimplemented(\n             \"miri does not support main functions without `fn()` type signatures\"\n                 .to_owned(),\n         ));\n@@ -60,7 +60,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     let start_mir = ecx.load_mir(start_instance.def)?;\n \n     if start_mir.arg_count != 3 {\n-        return err!(AbiViolation(format!(\n+        throw_unsup!(AbiViolation(format!(\n             \"'start' lang item should have three arguments, but has {}\",\n             start_mir.arg_count\n         )));\n@@ -200,7 +200,7 @@ pub fn eval_main<'tcx>(\n             // Special treatment for some error kinds\n             let msg = match e.kind {\n                 InterpError::Exit(code) => std::process::exit(code),\n-                InterpError::NoMirFor(..) =>\n+                err_unsup!(NoMirFor(..)) =>\n                     format!(\"{}. Did you set `MIRI_SYSROOT` to a Miri-enabled sysroot? You can prepare one with `cargo miri setup`.\", e),\n                 _ => e.to_string()\n             };"}, {"sha": "d29cc021a1b08bdbb9824eba432968bdb0d653a2", "filename": "src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=f463621a90af486c12fe2b1bd961ab773e25c576", "patch": "@@ -42,7 +42,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             })\n             .ok_or_else(|| {\n                 let path = path.iter().map(|&s| s.to_owned()).collect();\n-                InterpError::PathNotFound(path).into()\n+                err_unsup!(PathNotFound(path)).into()\n             })\n     }\n "}, {"sha": "b1e89f3819ae2cad7a8dd3edb2d9cf626c6cd949", "filename": "src/intptrcast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=f463621a90af486c12fe2b1bd961ab773e25c576", "patch": "@@ -43,19 +43,19 @@ impl<'mir, 'tcx> GlobalState {\n         memory: &Memory<'mir, 'tcx, Evaluator<'tcx>>,\n     ) -> InterpResult<'tcx, Pointer<Tag>> {\n         if int == 0 {\n-            return err!(InvalidNullPointerUsage);\n+            throw_unsup!(InvalidNullPointerUsage);\n         }\n \n         let global_state = memory.extra.intptrcast.borrow();\n         \n-        match global_state.int_to_ptr_map.binary_search_by_key(&int, |(addr, _)| *addr) {\n+        Ok(match global_state.int_to_ptr_map.binary_search_by_key(&int, |(addr, _)| *addr) {\n             Ok(pos) => {\n                 let (_, alloc_id) = global_state.int_to_ptr_map[pos];\n                 // `int` is equal to the starting address for an allocation, the offset should be\n                 // zero. The pointer is untagged because it was created from a cast\n-                Ok(Pointer::new_with_tag(alloc_id, Size::from_bytes(0), Tag::Untagged))\n+                Pointer::new_with_tag(alloc_id, Size::from_bytes(0), Tag::Untagged)\n             },\n-            Err(0) => err!(DanglingPointerDeref), \n+            Err(0) => throw_unsup!(DanglingPointerDeref), \n             Err(pos) => {\n                 // This is the largest of the adresses smaller than `int`,\n                 // i.e. the greatest lower bound (glb)\n@@ -65,12 +65,12 @@ impl<'mir, 'tcx> GlobalState {\n                 // If the offset exceeds the size of the allocation, this access is illegal\n                 if offset <= memory.get(alloc_id)?.bytes.len() as u64 {\n                     // This pointer is untagged because it was created from a cast\n-                    Ok(Pointer::new_with_tag(alloc_id, Size::from_bytes(offset), Tag::Untagged))\n+                    Pointer::new_with_tag(alloc_id, Size::from_bytes(offset), Tag::Untagged)\n                 } else {\n-                    err!(DanglingPointerDeref)\n+                    throw_unsup!(DanglingPointerDeref)\n                 } \n             }\n-        }\n+        })\n     }\n \n     pub fn ptr_to_int("}, {"sha": "cdac9fb815cc7685a2722c55a0e0e5fec014d1f1", "filename": "src/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=f463621a90af486c12fe2b1bd961ab773e25c576", "patch": "@@ -247,7 +247,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n                 let data = vec![0; size.bytes() as usize];\n                 Allocation::from_bytes(&data, tcx.data_layout.pointer_align.abi)\n             }\n-            _ => return err!(Unimplemented(\n+            _ => throw_unsup!(Unimplemented(\n                     format!(\"can't access foreign static: {}\", link_name),\n                 )),\n         };"}, {"sha": "dfe58037789c28f0578a07080d1d86a6a7764fd7", "filename": "src/operator.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=f463621a90af486c12fe2b1bd961ab773e25c576", "patch": "@@ -94,7 +94,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         let right = right.to_scalar()?;\n         debug_assert!(left.is_ptr() || right.is_ptr() || bin_op == Offset);\n \n-        match bin_op {\n+        Ok(match bin_op {\n             Offset => {\n                 let pointee_ty = left_layout.ty\n                     .builtin_deref(true)\n@@ -105,7 +105,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                     pointee_ty,\n                     right.to_isize(self)?,\n                 )?;\n-                Ok((ptr, false))\n+                (ptr, false)\n             }\n             // These need both to be pointer, and fail if they are not in the same location\n             Lt | Le | Gt | Ge | Sub if left.is_ptr() && right.is_ptr() => {\n@@ -130,10 +130,10 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                         }\n                         _ => bug!(\"We already established it has to be one of these operators.\"),\n                     };\n-                    Ok((Scalar::from_bool(res), false))\n+                    (Scalar::from_bool(res), false)\n                 } else {\n                     // Both are pointers, but from different allocations.\n-                    err!(InvalidPointerMath)\n+                    throw_unsup!(InvalidPointerMath)\n                 }\n             }\n             Gt | Ge if left.is_ptr() && right.is_bits() => {\n@@ -151,10 +151,10 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                 };\n                 if result {\n                     // Definitely true!\n-                    Ok((Scalar::from_bool(true), false))\n+                    (Scalar::from_bool(true), false)\n                 } else {\n                     // Sorry, can't tell.\n-                    err!(InvalidPointerMath)\n+                    throw_unsup!(InvalidPointerMath)\n                 }\n             }\n             // These work if the left operand is a pointer, and the right an integer\n@@ -165,7 +165,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                     left.to_ptr().expect(\"we checked is_ptr\"),\n                     right.to_bits(self.memory().pointer_size()).expect(\"we checked is_bits\"),\n                     right_layout.abi.is_signed(),\n-                )\n+                )?\n             }\n             // Commutative operators also work if the integer is on the left\n             Add | BitAnd if left.is_bits() && right.is_ptr() => {\n@@ -175,11 +175,11 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                     right.to_ptr().expect(\"we checked is_ptr\"),\n                     left.to_bits(self.memory().pointer_size()).expect(\"we checked is_bits\"),\n                     left_layout.abi.is_signed(),\n-                )\n+                )?\n             }\n             // Nothing else works\n-            _ => err!(InvalidPointerMath),\n-        }\n+            _ => throw_unsup!(InvalidPointerMath),\n+        })\n     }\n \n     fn ptr_eq(\n@@ -248,7 +248,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                     let v = Scalar::from_uint((left.offset.bytes() as u128) & right, ptr_size);\n                     (v, false)\n                 } else {\n-                    return err!(ReadPointerAsBytes);\n+                    throw_unsup!(ReadPointerAsBytes);\n                 }\n             }\n \n@@ -271,7 +271,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                         false,\n                     )\n                 } else {\n-                    return err!(ReadPointerAsBytes);\n+                    throw_unsup!(ReadPointerAsBytes);\n                 }\n             }\n \n@@ -283,7 +283,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                     right,\n                     if signed { \"signed\" } else { \"unsigned\" }\n                 );\n-                return err!(Unimplemented(msg));\n+                throw_unsup!(Unimplemented(msg));\n             }\n         })\n     }\n@@ -298,12 +298,11 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         pointee_ty: Ty<'tcx>,\n         offset: i64,\n     ) -> InterpResult<'tcx, Scalar<Tag>> {\n-        use rustc::mir::interpret::InterpError::Panic;\n         // FIXME: assuming here that type size is less than `i64::max_value()`.\n         let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n         let offset = offset\n             .checked_mul(pointee_size)\n-            .ok_or_else(|| Panic(PanicMessage::Overflow(mir::BinOp::Mul)))?;\n+            .ok_or_else(|| err_panic!(Overflow(mir::BinOp::Mul)))?;\n         // Now let's see what kind of pointer this is.\n         let ptr = if offset == 0 {\n             match ptr {"}, {"sha": "005493096248a33e6bb617f7e76211e2780f4aee", "filename": "src/shims/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fshims%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fshims%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fdlsym.rs?ref=f463621a90af486c12fe2b1bd961ab773e25c576", "patch": "@@ -16,7 +16,7 @@ impl Dlsym {\n             \"getentropy\" => Some(GetEntropy),\n             \"__pthread_get_minstack\" => None,\n             _ =>\n-                return err!(Unimplemented(format!(\n+                throw_unsup!(Unimplemented(format!(\n                     \"Unsupported dlsym: {}\", name\n                 ))),\n         })"}, {"sha": "12baa79916ab6eaebfce1972b2597af770ae0198", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=f463621a90af486c12fe2b1bd961ab773e25c576", "patch": "@@ -128,7 +128,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         dest: Option<PlaceTy<'tcx, Tag>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n-        use rustc::mir::interpret::InterpError::Panic;\n         let this = self.eval_context_mut();\n         let attrs = this.tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n@@ -142,15 +141,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // First: functions that diverge.\n         match link_name {\n             \"__rust_start_panic\" | \"panic_impl\" => {\n-                return err!(MachineError(\"the evaluated program panicked\".to_string()));\n+                throw_unsup!(MachineError(\"the evaluated program panicked\".to_string()));\n             }\n             \"exit\" | \"ExitProcess\" => {\n                 // it's really u32 for ExitProcess, but we have to put it into the `Exit` error variant anyway\n                 let code = this.read_scalar(args[0])?.to_i32()?;\n-                return err!(Exit(code));\n+                return Err(InterpError::Exit(code).into());\n             }\n             _ => if dest.is_none() {\n-                return err!(Unimplemented(\n+                throw_unsup!(Unimplemented(\n                     format!(\"can't call diverging foreign function: {}\", link_name),\n                 ));\n             }\n@@ -168,7 +167,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"calloc\" => {\n                 let items = this.read_scalar(args[0])?.to_usize(this)?;\n                 let len = this.read_scalar(args[1])?.to_usize(this)?;\n-                let size = items.checked_mul(len).ok_or_else(|| Panic(PanicMessage::Overflow(mir::BinOp::Mul)))?;\n+                let size = items.checked_mul(len).ok_or_else(|| err_panic!(Overflow(mir::BinOp::Mul)))?;\n                 let res = this.malloc(size, /*zero_init:*/ true, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n@@ -178,13 +177,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let size = this.read_scalar(args[2])?.to_usize(this)?;\n                 // Align must be power of 2, and also at least ptr-sized (POSIX rules).\n                 if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n+                    throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 /*\n                 FIXME: This check is disabled because rustc violates it.\n                 See <https://github.com/rust-lang/rust/issues/62251>.\n                 if align < this.pointer_size().bytes() {\n-                    return err!(MachineError(format!(\n+                    throw_unsup!(MachineError(format!(\n                         \"posix_memalign: alignment must be at least the size of a pointer, but is {}\",\n                         align,\n                     )));\n@@ -217,10 +216,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let size = this.read_scalar(args[0])?.to_usize(this)?;\n                 let align = this.read_scalar(args[1])?.to_usize(this)?;\n                 if size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n+                    throw_unsup!(HeapAllocZeroBytes);\n                 }\n                 if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n+                    throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 let ptr = this.memory_mut()\n                     .allocate(\n@@ -234,10 +233,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let size = this.read_scalar(args[0])?.to_usize(this)?;\n                 let align = this.read_scalar(args[1])?.to_usize(this)?;\n                 if size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n+                    throw_unsup!(HeapAllocZeroBytes);\n                 }\n                 if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n+                    throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 let ptr = this.memory_mut()\n                     .allocate(\n@@ -256,10 +255,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let old_size = this.read_scalar(args[1])?.to_usize(this)?;\n                 let align = this.read_scalar(args[2])?.to_usize(this)?;\n                 if old_size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n+                    throw_unsup!(HeapAllocZeroBytes);\n                 }\n                 if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n+                    throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 let ptr = this.force_ptr(ptr)?;\n                 this.memory_mut().deallocate(\n@@ -274,10 +273,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let align = this.read_scalar(args[2])?.to_usize(this)?;\n                 let new_size = this.read_scalar(args[3])?.to_usize(this)?;\n                 if old_size == 0 || new_size == 0 {\n-                    return err!(HeapAllocZeroBytes);\n+                    throw_unsup!(HeapAllocZeroBytes);\n                 }\n                 if !align.is_power_of_two() {\n-                    return err!(HeapAllocNonPowerOfTwoAlignment(align));\n+                    throw_unsup!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 let align = Align::from_bytes(align).unwrap();\n                 let new_ptr = this.memory_mut().reallocate(\n@@ -310,7 +309,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         this.write_scalar(Scalar::from_uint(len, dest.layout.size), dest)?;\n                     }\n                     id => {\n-                        return err!(Unimplemented(\n+                        throw_unsup!(Unimplemented(\n                             format!(\"miri does not support syscall ID {}\", id),\n                         ))\n                     }\n@@ -361,10 +360,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let mut args = this.frame().body.args_iter();\n \n                 let arg_local = args.next().ok_or_else(||\n-                    InterpError::AbiViolation(\n+                    err_unsup!(AbiViolation(\n                         \"Argument to __rust_maybe_catch_panic does not take enough arguments.\"\n                             .to_owned(),\n-                    ),\n+                    )),\n                 )?;\n                 let arg_dest = this.local_place(arg_local)?;\n                 this.write_scalar(data, arg_dest)?;\n@@ -633,7 +632,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if let Some(result) = result {\n                     this.write_scalar(result, dest)?;\n                 } else {\n-                    return err!(Unimplemented(\n+                    throw_unsup!(Unimplemented(\n                         format!(\"Unimplemented sysconf name: {}\", name),\n                     ));\n                 }\n@@ -662,14 +661,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // This is `libc::pthread_key_t`.\n                 let key_type = args[0].layout.ty\n                     .builtin_deref(true)\n-                    .ok_or_else(|| InterpError::AbiViolation(\"wrong signature used for `pthread_key_create`: first argument must be a raw pointer.\".to_owned()))?\n+                    .ok_or_else(|| err_unsup!(\n+                        AbiViolation(\"wrong signature used for `pthread_key_create`: first argument must be a raw pointer.\".to_owned())\n+                    ))?\n                     .ty;\n                 let key_layout = this.layout_of(key_type)?;\n \n                 // Create key and write it into the memory where `key_ptr` wants it.\n                 let key = this.machine.tls.create_tls_key(dtor) as u128;\n                 if key_layout.size.bits() < 128 && key >= (1u128 << key_layout.size.bits() as u128) {\n-                    return err!(OutOfTls);\n+                    throw_unsup!(OutOfTls);\n                 }\n \n                 let key_ptr = this.memory().check_ptr_access(key_ptr, key_layout.size, key_layout.align.abi)?\n@@ -728,7 +729,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // We don't support threading. (Also for Windows.)\n             \"pthread_create\" | \"CreateThread\" => {\n-                return err!(Unimplemented(format!(\"Miri does not support threading\")));\n+                throw_unsup!(Unimplemented(format!(\"Miri does not support threading\")));\n             }\n \n             // Stub out calls for condvar, mutex and rwlock, to just return `0`.\n@@ -869,7 +870,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Figure out how large a TLS key actually is. This is `c::DWORD`.\n                 if dest.layout.size.bits() < 128\n                         && key >= (1u128 << dest.layout.size.bits() as u128) {\n-                    return err!(OutOfTls);\n+                    throw_unsup!(OutOfTls);\n                 }\n                 this.write_scalar(Scalar::from_uint(key, dest.layout.size), dest)?;\n             }\n@@ -947,7 +948,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // We can't execute anything else.\n             _ => {\n-                return err!(Unimplemented(\n+                throw_unsup!(Unimplemented(\n                     format!(\"can't call foreign function: {}\", link_name),\n                 ));\n             }"}, {"sha": "71027a65b054549e96dea8e513c28173bd986332", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=f463621a90af486c12fe2b1bd961ab773e25c576", "patch": "@@ -44,7 +44,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"assume\" => {\n                 let cond = this.read_scalar(args[0])?.to_bool()?;\n                 if !cond {\n-                    return err!(AssumptionNotHeld);\n+                    throw_unsup!(AssumptionNotHeld);\n                 }\n             }\n \n@@ -133,7 +133,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"atomic_xsub_relaxed\" => {\n                 let ptr = this.deref_operand(args[0])?;\n                 if !ptr.layout.ty.is_integral() {\n-                    return err!(Unimplemented(format!(\"Atomic arithmetic operations only work on integer types\")));\n+                    throw_unsup!(Unimplemented(format!(\"Atomic arithmetic operations only work on integer types\")));\n                 }\n                 let rhs = this.read_immediate(args[1])?;\n                 let old = this.read_immediate(ptr.into())?;\n@@ -278,11 +278,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if this.binary_op(mir::BinOp::Rem, a, b)?.0.to_bits(dest.layout.size)? != 0 {\n                     // Check if `b` is -1, which is the \"min_value / -1\" case.\n                     let minus1 = Scalar::from_int(-1, dest.layout.size);\n-                    return if b.to_scalar().unwrap() == minus1 {\n-                        err!(Intrinsic(format!(\"exact_div: result of dividing MIN by -1 cannot be represented\")))\n+                    return Err(if b.to_scalar().unwrap() == minus1 {\n+                        err_unsup!(Intrinsic(format!(\"exact_div: result of dividing MIN by -1 cannot be represented\")))\n                     } else {\n-                        err!(Intrinsic(format!(\"exact_div: {:?} cannot be divided by {:?} without remainder\", *a, *b)))\n-                    };\n+                        err_unsup!(Intrinsic(format!(\"exact_div: {:?} cannot be divided by {:?} without remainder\", *a, *b)))\n+                    }.into());\n                 }\n                 this.binop_ignore_overflow(mir::BinOp::Div, a, b, dest)?;\n             },\n@@ -350,7 +350,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let ty = substs.type_at(0);\n                 let layout = this.layout_of(ty)?;\n                 if layout.abi.is_uninhabited() {\n-                    return err!(Intrinsic(format!(\"Trying to instantiate uninhabited type {}\", ty)))\n+                    throw_unsup!(Intrinsic(format!(\"Trying to instantiate uninhabited type {}\", ty)))\n                 }\n             }\n \n@@ -444,7 +444,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let r = this.read_immediate(args[1])?;\n                 let rval = r.to_scalar()?.to_bits(args[1].layout.size)?;\n                 if rval == 0 {\n-                    return err!(Intrinsic(format!(\"Division by 0 in unchecked_div\")));\n+                    throw_unsup!(Intrinsic(format!(\"Division by 0 in unchecked_div\")));\n                 }\n                 this.binop_ignore_overflow(\n                     mir::BinOp::Div,\n@@ -459,7 +459,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let r = this.read_immediate(args[1])?;\n                 let rval = r.to_scalar()?.to_bits(args[1].layout.size)?;\n                 if rval == 0 {\n-                    return err!(Intrinsic(format!(\"Division by 0 in unchecked_rem\")));\n+                    throw_unsup!(Intrinsic(format!(\"Division by 0 in unchecked_rem\")));\n                 }\n                 this.binop_ignore_overflow(\n                     mir::BinOp::Rem,\n@@ -480,7 +480,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 };\n                 let (res, overflowed) = this.binary_op(op, l, r)?;\n                 if overflowed {\n-                    return err!(Intrinsic(format!(\"Overflowing arithmetic in {}\", intrinsic_name.get())));\n+                    throw_unsup!(Intrinsic(format!(\"Overflowing arithmetic in {}\", intrinsic_name.get())));\n                 }\n                 this.write_scalar(res, dest)?;\n             }\n@@ -504,7 +504,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n \n-            name => return err!(Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n+            name => throw_unsup!(Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n         }\n \n         Ok(())"}, {"sha": "145d2b3e78915e3fee8eccc2a5bfdfc0974cc8e1", "filename": "src/shims/tls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=f463621a90af486c12fe2b1bd961ab773e25c576", "patch": "@@ -6,7 +6,7 @@ use rustc_target::abi::LayoutOf;\n use rustc::{ty, ty::layout::HasDataLayout};\n \n use crate::{\n-    InterpResult, InterpError, StackPopCleanup,\n+    InterpResult, StackPopCleanup,\n     MPlaceTy, Scalar, Tag,\n     HelpersEvalContextExt,\n };\n@@ -64,7 +64,7 @@ impl<'tcx> TlsData<'tcx> {\n                 trace!(\"TLS key {} removed\", key);\n                 Ok(())\n             }\n-            None => err!(TlsOutOfBounds),\n+            None => throw_unsup!(TlsOutOfBounds),\n         }\n     }\n \n@@ -78,7 +78,7 @@ impl<'tcx> TlsData<'tcx> {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n                 Ok(data.unwrap_or_else(|| Scalar::ptr_null(cx).into()))\n             }\n-            None => err!(TlsOutOfBounds),\n+            None => throw_unsup!(TlsOutOfBounds),\n         }\n     }\n \n@@ -89,7 +89,7 @@ impl<'tcx> TlsData<'tcx> {\n                 *data = new_data;\n                 Ok(())\n             }\n-            None => err!(TlsOutOfBounds),\n+            None => throw_unsup!(TlsOutOfBounds),\n         }\n     }\n \n@@ -158,7 +158,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 StackPopCleanup::None { cleanup: true },\n             )?;\n             let arg_local = this.frame().body.args_iter().next().ok_or_else(\n-                || InterpError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()),\n+                || err_unsup!(AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned())),\n             )?;\n             let dest = this.local_place(arg_local)?;\n             this.write_scalar(ptr, dest)?;"}, {"sha": "5ef934b9922b3be857e8e9647c7b839a3115b2ae", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f463621a90af486c12fe2b1bd961ab773e25c576/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=f463621a90af486c12fe2b1bd961ab773e25c576", "patch": "@@ -12,7 +12,7 @@ use rustc::hir::{MutMutable, MutImmutable};\n use rustc::mir::RetagKind;\n \n use crate::{\n-    InterpResult, InterpError, HelpersEvalContextExt,\n+    InterpResult, HelpersEvalContextExt,\n     MemoryKind, MiriMemoryKind, RangeMap, AllocId, Pointer, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n \n@@ -273,12 +273,12 @@ impl<'tcx> Stack {\n         if let Some(call) = item.protector {\n             if global.is_active(call) {\n                 if let Some(tag) = tag {\n-                    return err!(MachineError(format!(\n+                    throw_unsup!(MachineError(format!(\n                         \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n                         tag, item\n                     )));\n                 } else {\n-                    return err!(MachineError(format!(\n+                    throw_unsup!(MachineError(format!(\n                         \"deallocating while item is protected: {:?}\", item\n                     )));\n                 }\n@@ -299,10 +299,10 @@ impl<'tcx> Stack {\n \n         // Step 1: Find granting item.\n         let granting_idx = self.find_granting(access, tag)\n-            .ok_or_else(|| InterpError::MachineError(format!(\n+            .ok_or_else(|| err_unsup!(MachineError(format!(\n                 \"no item granting {} to tag {:?} found in borrow stack\",\n                 access, tag,\n-            )))?;\n+            ))))?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n@@ -346,10 +346,10 @@ impl<'tcx> Stack {\n     ) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n         self.find_granting(AccessKind::Write, tag)\n-            .ok_or_else(|| InterpError::MachineError(format!(\n+            .ok_or_else(|| err_unsup!(MachineError(format!(\n                 \"no item granting write access for deallocation to tag {:?} found in borrow stack\",\n                 tag,\n-            )))?;\n+            ))))?;\n \n         // Step 2: Remove all items.  Also checks for protectors.\n         for item in self.borrows.drain(..).rev() {\n@@ -378,9 +378,9 @@ impl<'tcx> Stack {\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n         let granting_idx = self.find_granting(access, derived_from)\n-            .ok_or_else(|| InterpError::MachineError(format!(\n+            .ok_or_else(|| err_unsup!(MachineError(format!(\n                 \"trying to reborrow for {:?}, but parent tag {:?} does not have an appropriate item in the borrow stack\", new.perm, derived_from,\n-            )))?;\n+            ))))?;\n \n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between"}]}