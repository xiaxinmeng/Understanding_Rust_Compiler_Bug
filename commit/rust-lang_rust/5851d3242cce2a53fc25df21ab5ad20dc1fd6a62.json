{"sha": "5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NTFkMzI0MmNjZTJhNTNmYzI1ZGYyMWFiNWFkMjBkYzFmZDZhNjI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-22T10:54:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-29T00:22:14Z"}, "message": "Move checking for moves and initialization of local variables and patterns into\nborrow checker and generalize what moves are allowed. Fixes a nasty\nbug or two in the pattern move checking code. Unifies dataflow code\nused for initialization and other things. First step towards\nonce fns. Everybody wins.\n\nFixes #4384. Fixes #4715. cc once fns (#2202), optimizing local moves (#5016).", "tree": {"sha": "e20309eda47cbc2e59df1d1d132130dc93b7411c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e20309eda47cbc2e59df1d1d132130dc93b7411c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "html_url": "https://github.com/rust-lang/rust/commit/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5676056ae6dd3a10d2c7323375ace3ca2fe1c308", "url": "https://api.github.com/repos/rust-lang/rust/commits/5676056ae6dd3a10d2c7323375ace3ca2fe1c308", "html_url": "https://github.com/rust-lang/rust/commit/5676056ae6dd3a10d2c7323375ace3ca2fe1c308"}], "stats": {"total": 1896, "additions": 1282, "deletions": 614}, "files": [{"sha": "00925a5700ada3d6730f6878f8478a6850ac1e66", "filename": "src/librust/rust.rc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrust%2Frust.rc", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrust%2Frust.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rc?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -152,15 +152,15 @@ fn cmd_help(args: &[~str]) -> ValidUsage {\n     }\n \n     match args {\n-        [command_string] => print_usage(command_string),\n-        _                => Invalid\n+        [ref command_string] => print_usage(copy *command_string),\n+        _                    => Invalid\n     }\n }\n \n fn cmd_test(args: &[~str]) -> ValidUsage {\n     match args {\n-        [filename] => {\n-            let test_exec = Path(filename).filestem().unwrap() + \"test~\";\n+        [ref filename] => {\n+            let test_exec = Path(*filename).filestem().unwrap() + \"test~\";\n             invoke(\"rustc\", &[~\"--test\", filename.to_owned(),\n                               ~\"-o\", test_exec.to_owned()], rustc::main);\n             let exit_code = run::process_status(~\"./\" + test_exec, []);\n@@ -172,8 +172,8 @@ fn cmd_test(args: &[~str]) -> ValidUsage {\n \n fn cmd_run(args: &[~str]) -> ValidUsage {\n     match args {\n-        [filename, ..prog_args] => {\n-            let exec = Path(filename).filestem().unwrap() + \"~\";\n+        [ref filename, ..prog_args] => {\n+            let exec = Path(*filename).filestem().unwrap() + \"~\";\n             invoke(\"rustc\", &[filename.to_owned(), ~\"-o\", exec.to_owned()],\n                    rustc::main);\n             let exit_code = run::process_status(~\"./\"+exec, prog_args);"}, {"sha": "65838f62498dcd2470b9c10f8122a6eec62c1538", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -263,8 +263,8 @@ pub fn compile_rest(sess: Session,\n         time(time_passes, ~\"loop checking\", ||\n              middle::check_loop::check_crate(ty_cx, crate));\n \n-        let middle::moves::MoveMaps {moves_map, variable_moves_map,\n-                                     moved_variables_set, capture_map} =\n+        let middle::moves::MoveMaps {moves_map, moved_variables_set,\n+                                     capture_map} =\n             time(time_passes, ~\"compute moves\", ||\n                  middle::moves::compute_moves(ty_cx, method_map, crate));\n \n@@ -274,7 +274,6 @@ pub fn compile_rest(sess: Session,\n \n         time(time_passes, ~\"liveness checking\", ||\n              middle::liveness::check_crate(ty_cx, method_map,\n-                                           variable_moves_map,\n                                            capture_map, crate));\n \n         let (root_map, write_guard_map) ="}, {"sha": "f2bba4f694a906534b09efacf3eeb6ae1420af40", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 115, "deletions": 114, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -33,20 +33,23 @@ use syntax::codemap::span;\n \n struct CheckLoanCtxt<'self> {\n     bccx: @BorrowckCtxt,\n-    dfcx: &'self LoanDataFlow,\n+    dfcx_loans: &'self LoanDataFlow,\n+    move_data: move_data::FlowedMoveData,\n     all_loans: &'self [Loan],\n     reported: @mut HashSet<ast::node_id>,\n }\n \n pub fn check_loans(bccx: @BorrowckCtxt,\n-                   dfcx: &LoanDataFlow,\n+                   dfcx_loans: &LoanDataFlow,\n+                   move_data: move_data::FlowedMoveData,\n                    all_loans: &[Loan],\n                    body: &ast::blk) {\n     debug!(\"check_loans(body id=%?)\", body.node.id);\n \n     let clcx = @mut CheckLoanCtxt {\n         bccx: bccx,\n-        dfcx: dfcx,\n+        dfcx_loans: dfcx_loans,\n+        move_data: move_data,\n         all_loans: all_loans,\n         reported: @mut HashSet::new(),\n     };\n@@ -62,7 +65,6 @@ pub fn check_loans(bccx: @BorrowckCtxt,\n \n enum MoveError {\n     MoveOk,\n-    MoveFromIllegalCmt(mc::cmt),\n     MoveWhileBorrowed(/*loan*/@LoanPath, /*loan*/span)\n }\n \n@@ -79,7 +81,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         //! are issued for future scopes and thus they may have been\n         //! *issued* but not yet be in effect.\n \n-        for self.dfcx.each_bit_on_entry(scope_id) |loan_index| {\n+        for self.dfcx_loans.each_bit_on_entry(scope_id) |loan_index| {\n             let loan = &self.all_loans[loan_index];\n             if !op(loan) {\n                 return false;\n@@ -131,7 +133,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         //! we encounter `scope_id`.\n \n         let mut result = ~[];\n-        for self.dfcx.each_gen_bit(scope_id) |loan_index| {\n+        for self.dfcx_loans.each_gen_bit(scope_id) |loan_index| {\n             result.push(loan_index);\n         }\n         return result;\n@@ -251,6 +253,29 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         }\n     }\n \n+    fn check_if_path_is_moved(&self,\n+                              id: ast::node_id,\n+                              span: span,\n+                              use_kind: MovedValueUseKind,\n+                              lp: @LoanPath) {\n+        /*!\n+         * Reports an error if `expr` (which should be a path)\n+         * is using a moved/uninitialized value\n+         */\n+\n+        debug!(\"check_if_path_is_moved(id=%?, use_kind=%?, lp=%s)\",\n+               id, use_kind, lp.repr(self.bccx.tcx));\n+        for self.move_data.each_move_of(id, lp) |move, moved_lp| {\n+            self.bccx.report_use_of_moved_value(\n+                span,\n+                use_kind,\n+                lp,\n+                move,\n+                moved_lp);\n+            return;\n+        }\n+    }\n+\n     fn check_assignment(&self, expr: @ast::expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n@@ -261,48 +286,42 @@ pub impl<'self> CheckLoanCtxt<'self> {\n \n         debug!(\"check_assignment(cmt=%s)\", cmt.repr(self.tcx()));\n \n-        // check that the value being assigned is declared as mutable\n-        // and report an error otherwise.\n-        match cmt.mutbl {\n-            mc::McDeclared => {\n-                // OK, but we have to mark arguments as requiring mut\n-                // if they are assigned (other cases are handled by liveness,\n-                // since we need to distinguish local variables assigned\n-                // once vs those assigned multiple times)\n-                match cmt.cat {\n-                    mc::cat_self(*) |\n-                    mc::cat_arg(*) => {\n-                        mark_variable_as_used_mut(self, cmt);\n-                    }\n-                    _ => {}\n+        // Mutable values can be assigned, as long as they obey loans\n+        // and aliasing restrictions:\n+        if cmt.mutbl.is_mutable() {\n+            if check_for_aliasable_mutable_writes(self, expr, cmt) {\n+                if check_for_assignment_to_restricted_or_frozen_location(\n+                    self, expr, cmt)\n+                {\n+                    // Safe, but record for lint pass later:\n+                    mark_variable_as_used_mut(self, cmt);\n                 }\n             }\n-            mc::McInherited => {\n-                // OK, but we may have to add an entry to `used_mut_nodes`\n-                mark_variable_as_used_mut(self, cmt);\n-            }\n-            mc::McReadOnly | mc::McImmutable => {\n-                // Subtle: liveness guarantees that immutable local\n-                // variables are only assigned once, so no need to\n-                // report an error for an assignment to a local\n-                // variable (note also that it is not legal to borrow\n-                // for a local variable before it has been assigned\n-                // for the first time).\n-                if !self.is_local_variable(cmt) {\n-                    self.bccx.span_err(\n-                        expr.span,\n-                        fmt!(\"cannot assign to %s %s\"\n-                             cmt.mutbl.to_user_str(),\n-                             self.bccx.cmt_to_str(cmt)));\n-                }\n+            return;\n+        }\n+\n+        // For immutable local variables, assignments are legal\n+        // if they cannot already have been assigned\n+        if self.is_local_variable(cmt) {\n+            assert!(cmt.mutbl.is_immutable()); // no \"const\" locals\n+            let lp = opt_loan_path(cmt).get();\n+            for self.move_data.each_assignment_of(expr.id, lp) |assign| {\n+                self.bccx.report_reassigned_immutable_variable(\n+                    expr.span,\n+                    lp,\n+                    assign);\n                 return;\n             }\n+            return;\n         }\n \n-        if check_for_aliasable_mutable_writes(self, expr, cmt) {\n-            check_for_assignment_to_restricted_or_frozen_location(\n-                self, expr, cmt);\n-        }\n+        // Otherwise, just a plain error.\n+        self.bccx.span_err(\n+            expr.span,\n+            fmt!(\"cannot assign to %s %s\"\n+                 cmt.mutbl.to_user_str(),\n+                 self.bccx.cmt_to_str(cmt)));\n+        return;\n \n         fn mark_variable_as_used_mut(this: &CheckLoanCtxt,\n                                      cmt: mc::cmt) {\n@@ -538,12 +557,6 @@ pub impl<'self> CheckLoanCtxt<'self> {\n                 let cmt = self.bccx.cat_expr(ex);\n                 match self.analyze_move_out_from_cmt(cmt) {\n                     MoveOk => {}\n-                    MoveFromIllegalCmt(_) => {\n-                        self.bccx.span_err(\n-                            cmt.span,\n-                            fmt!(\"cannot move out of %s\",\n-                                 self.bccx.cmt_to_str(cmt)));\n-                    }\n                     MoveWhileBorrowed(loan_path, loan_span) => {\n                         self.bccx.span_err(\n                             cmt.span,\n@@ -561,29 +574,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n     }\n \n     fn analyze_move_out_from_cmt(&self, cmt: mc::cmt) -> MoveError {\n-        debug!(\"check_move_out_from_cmt(cmt=%s)\", cmt.repr(self.tcx()));\n-\n-        match cmt.cat {\n-            // Rvalues, locals, and arguments can be moved:\n-            mc::cat_rvalue | mc::cat_local(_) |\n-            mc::cat_arg(_) | mc::cat_self(_) => {}\n-\n-            // It seems strange to allow a move out of a static item,\n-            // but what happens in practice is that you have a\n-            // reference to a constant with a type that should be\n-            // moved, like `None::<~int>`.  The type of this constant\n-            // is technically `Option<~int>`, which moves, but we know\n-            // that the content of static items will never actually\n-            // contain allocated pointers, so we can just memcpy it.\n-            mc::cat_static_item => {}\n-\n-            mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {}\n-\n-            // Nothing else.\n-            _ => {\n-                return MoveFromIllegalCmt(cmt);\n-            }\n-        }\n+        debug!(\"analyze_move_out_from_cmt(cmt=%s)\", cmt.repr(self.tcx()));\n \n         // FIXME(#4384) inadequare if/when we permit `move a.b`\n \n@@ -631,54 +622,53 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n \n         visit::fk_anon(*) |\n         visit::fk_fn_block(*) => {\n-            let fty = ty::node_id_to_type(this.tcx(), id);\n-            let fty_sigil = ty::ty_closure_sigil(fty);\n-            check_moves_from_captured_variables(this, id, fty_sigil);\n+            check_captured_variables(this, id, sp);\n         }\n     }\n \n     visit::visit_fn(fk, decl, body, sp, id, this, visitor);\n \n-    fn check_moves_from_captured_variables(this: @mut CheckLoanCtxt,\n-                                           id: ast::node_id,\n-                                           fty_sigil: ast::Sigil) {\n-        match fty_sigil {\n-            ast::ManagedSigil | ast::OwnedSigil => {\n-                let cap_vars = this.bccx.capture_map.get(&id);\n-                for cap_vars.each |cap_var| {\n-                    match cap_var.mode {\n-                        moves::CapRef | moves::CapCopy => { loop; }\n-                        moves::CapMove => { }\n-                    }\n-                    let def_id = ast_util::def_id_of_def(cap_var.def).node;\n-                    let ty = ty::node_id_to_type(this.tcx(), def_id);\n-                    let cmt = this.bccx.cat_def(id, cap_var.span,\n-                                                ty, cap_var.def);\n-                    let move_err = this.analyze_move_out_from_cmt(cmt);\n-                    match move_err {\n-                        MoveOk => {}\n-                        MoveFromIllegalCmt(move_cmt) => {\n-                            this.bccx.span_err(\n-                                cap_var.span,\n-                                fmt!(\"illegal by-move capture of %s\",\n-                                     this.bccx.cmt_to_str(move_cmt)));\n-                        }\n-                        MoveWhileBorrowed(loan_path, loan_span) => {\n-                            this.bccx.span_err(\n-                                cap_var.span,\n-                                fmt!(\"cannot move `%s` into closure \\\n-                                      because it is borrowed\",\n-                                     this.bccx.loan_path_to_str(loan_path)));\n-                            this.bccx.span_note(\n-                                loan_span,\n-                                fmt!(\"borrow of `%s` occurs here\",\n-                                     this.bccx.loan_path_to_str(loan_path)));\n-                        }\n-                    }\n+    fn check_captured_variables(this: @mut CheckLoanCtxt,\n+                                closure_id: ast::node_id,\n+                                span: span) {\n+        let cap_vars = this.bccx.capture_map.get(&closure_id);\n+        for cap_vars.each |cap_var| {\n+            match cap_var.mode {\n+                moves::CapRef | moves::CapCopy => {\n+                    let var_id = ast_util::def_id_of_def(cap_var.def).node;\n+                    let lp = @LpVar(var_id);\n+                    this.check_if_path_is_moved(closure_id, span,\n+                                                MovedInCapture, lp);\n+                }\n+                moves::CapMove => {\n+                    check_by_move_capture(this, closure_id, cap_var);\n+                }\n+            }\n+        }\n+        return;\n+\n+        fn check_by_move_capture(this: @mut CheckLoanCtxt,\n+                                 closure_id: ast::node_id,\n+                                 cap_var: &moves::CaptureVar) {\n+            let var_id = ast_util::def_id_of_def(cap_var.def).node;\n+            let ty = ty::node_id_to_type(this.tcx(), var_id);\n+            let cmt = this.bccx.cat_def(closure_id, cap_var.span,\n+                                        ty, cap_var.def);\n+            let move_err = this.analyze_move_out_from_cmt(cmt);\n+            match move_err {\n+                MoveOk => {}\n+                MoveWhileBorrowed(loan_path, loan_span) => {\n+                    this.bccx.span_err(\n+                        cap_var.span,\n+                        fmt!(\"cannot move `%s` into closure \\\n+                              because it is borrowed\",\n+                             this.bccx.loan_path_to_str(loan_path)));\n+                    this.bccx.span_note(\n+                        loan_span,\n+                        fmt!(\"borrow of `%s` occurs here\",\n+                             this.bccx.loan_path_to_str(loan_path)));\n                 }\n             }\n-\n-            ast::BorrowedSigil => {}\n         }\n     }\n }\n@@ -692,18 +682,29 @@ fn check_loans_in_local<'a>(local: @ast::local,\n fn check_loans_in_expr<'a>(expr: @ast::expr,\n                            this: @mut CheckLoanCtxt<'a>,\n                            vt: visit::vt<@mut CheckLoanCtxt<'a>>) {\n+    visit::visit_expr(expr, this, vt);\n+\n     debug!(\"check_loans_in_expr(expr=%s)\",\n            expr.repr(this.tcx()));\n \n-    visit::visit_expr(expr, this, vt);\n-\n     this.check_for_conflicting_loans(expr.id);\n \n     if this.bccx.moves_map.contains(&expr.id) {\n         this.check_move_out_from_expr(expr);\n     }\n \n     match expr.node {\n+      ast::expr_self |\n+      ast::expr_path(*) => {\n+          if !this.move_data.is_assignee(expr.id) {\n+              let cmt = this.bccx.cat_expr_unadjusted(expr);\n+              debug!(\"path cmt=%s\", cmt.repr(this.tcx()));\n+              for opt_loan_path(cmt).each |&lp| {\n+                  this.check_if_path_is_moved(expr.id, expr.span,\n+                                              MovedInUse, lp);\n+              }\n+          }\n+      }\n       ast::expr_assign(dest, _) |\n       ast::expr_assign_op(_, dest, _) => {\n         this.check_assignment(dest);"}, {"sha": "d32c1873ba053b70a96b0b9bdf1cd421528673e9", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -0,0 +1,164 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Computes moves.\n+ */\n+\n+use core::prelude::*;\n+use mc = middle::mem_categorization;\n+use middle::borrowck::*;\n+use middle::borrowck::move_data::*;\n+use middle::moves;\n+use middle::ty;\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::codemap::span;\n+use util::ppaux::{UserString};\n+\n+pub fn gather_decl(bccx: @BorrowckCtxt,\n+                   move_data: &mut MoveData,\n+                   decl_id: ast::node_id,\n+                   _decl_span: span,\n+                   var_id: ast::node_id) {\n+    let loan_path = @LpVar(var_id);\n+    move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n+}\n+\n+pub fn gather_move_from_expr(bccx: @BorrowckCtxt,\n+                             move_data: &mut MoveData,\n+                             move_expr: @ast::expr,\n+                             cmt: mc::cmt) {\n+    gather_move_from_expr_or_pat(bccx, move_data, move_expr.id,\n+                                 MoveExpr(move_expr), cmt);\n+}\n+\n+pub fn gather_move_from_pat(bccx: @BorrowckCtxt,\n+                            move_data: &mut MoveData,\n+                            move_pat: @ast::pat,\n+                            cmt: mc::cmt) {\n+    gather_move_from_expr_or_pat(bccx, move_data, move_pat.id,\n+                                 MovePat(move_pat), cmt);\n+}\n+\n+fn gather_move_from_expr_or_pat(bccx: @BorrowckCtxt,\n+                                move_data: &mut MoveData,\n+                                move_id: ast::node_id,\n+                                move_kind: MoveKind,\n+                                cmt: mc::cmt) {\n+    if !check_is_legal_to_move_from(bccx, cmt, cmt) {\n+        return;\n+    }\n+\n+    match opt_loan_path(cmt) {\n+        Some(loan_path) => {\n+            move_data.add_move(bccx.tcx, loan_path, move_id, move_kind);\n+        }\n+        None => {\n+            // move from rvalue or unsafe pointer, hence ok\n+        }\n+    }\n+}\n+\n+pub fn gather_captures(bccx: @BorrowckCtxt,\n+                       move_data: &mut MoveData,\n+                       closure_expr: @ast::expr) {\n+    let captured_vars = bccx.capture_map.get(&closure_expr.id);\n+    for captured_vars.each |captured_var| {\n+        match captured_var.mode {\n+            moves::CapMove => {\n+                let fvar_id = ast_util::def_id_of_def(captured_var.def).node;\n+                let loan_path = @LpVar(fvar_id);\n+                move_data.add_move(bccx.tcx, loan_path, closure_expr.id,\n+                                   Captured(closure_expr));\n+            }\n+            moves::CapCopy | moves::CapRef => {}\n+        }\n+    }\n+}\n+\n+pub fn gather_assignment(bccx: @BorrowckCtxt,\n+                         move_data: &mut MoveData,\n+                         assignment_id: ast::node_id,\n+                         assignment_span: span,\n+                         assignee_loan_path: @LoanPath,\n+                         assignee_id: ast::node_id) {\n+    move_data.add_assignment(bccx.tcx,\n+                             assignee_loan_path,\n+                             assignment_id,\n+                             assignment_span,\n+                             assignee_id);\n+}\n+\n+fn check_is_legal_to_move_from(bccx: @BorrowckCtxt,\n+                               cmt0: mc::cmt,\n+                               cmt: mc::cmt) -> bool {\n+    match cmt.cat {\n+        mc::cat_stack_upvar(*) |\n+        mc::cat_implicit_self(*) |\n+        mc::cat_copied_upvar(*) |\n+        mc::cat_deref(_, _, mc::region_ptr(*)) |\n+        mc::cat_deref(_, _, mc::gc_ptr(*)) => {\n+            bccx.span_err(\n+                cmt0.span,\n+                fmt!(\"cannot move out of %s\",\n+                     bccx.cmt_to_str(cmt)));\n+            false\n+        }\n+\n+        // It seems strange to allow a move out of a static item,\n+        // but what happens in practice is that you have a\n+        // reference to a constant with a type that should be\n+        // moved, like `None::<~int>`.  The type of this constant\n+        // is technically `Option<~int>`, which moves, but we know\n+        // that the content of static items will never actually\n+        // contain allocated pointers, so we can just memcpy it.\n+        // Since static items can never have allocated memory,\n+        // this is ok. For now anyhow.\n+        mc::cat_static_item => {\n+            true\n+        }\n+\n+        mc::cat_rvalue(*) |\n+        mc::cat_local(*) |\n+        mc::cat_arg(*) |\n+        mc::cat_self(*) |\n+        mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n+            true\n+        }\n+\n+        mc::cat_downcast(b) |\n+        mc::cat_interior(b, _) => {\n+            match ty::get(b.ty).sty {\n+                ty::ty_struct(did, _) | ty::ty_enum(did, _) => {\n+                    if ty::has_dtor(bccx.tcx, did) {\n+                        bccx.span_err(\n+                            cmt0.span,\n+                            fmt!(\"cannot move out of type `%s`, \\\n+                                  which defines the `Drop` trait\",\n+                                 b.ty.user_string(bccx.tcx)));\n+                        false\n+                    } else {\n+                        check_is_legal_to_move_from(bccx, cmt0, b)\n+                    }\n+                }\n+                _ => {\n+                    check_is_legal_to_move_from(bccx, cmt0, b)\n+                }\n+            }\n+        }\n+\n+        mc::cat_deref(b, _, mc::uniq_ptr(*)) |\n+        mc::cat_discr(b, _) => {\n+            check_is_legal_to_move_from(bccx, cmt0, b)\n+        }\n+    }\n+}\n+"}, {"sha": "893365bdec19581fb4b448fdf742219739c5ca7f", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 72, "deletions": 5, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -19,6 +19,7 @@\n use core::prelude::*;\n \n use middle::borrowck::*;\n+use middle::borrowck::move_data::MoveData;\n use mc = middle::mem_categorization;\n use middle::pat_util;\n use middle::ty::{ty_region};\n@@ -35,6 +36,7 @@ use syntax::visit;\n \n mod lifetime;\n mod restrictions;\n+mod gather_moves;\n \n /// Context used while gathering loans:\n ///\n@@ -65,28 +67,32 @@ mod restrictions;\n struct GatherLoanCtxt {\n     bccx: @BorrowckCtxt,\n     id_range: id_range,\n+    move_data: @mut move_data::MoveData,\n     all_loans: @mut ~[Loan],\n     item_ub: ast::node_id,\n     repeating_ids: ~[ast::node_id]\n }\n \n pub fn gather_loans(bccx: @BorrowckCtxt,\n-                    body: &ast::blk) -> (id_range, @mut ~[Loan]) {\n+                    body: &ast::blk)\n+                    -> (id_range, @mut ~[Loan], @mut move_data::MoveData) {\n     let glcx = @mut GatherLoanCtxt {\n         bccx: bccx,\n         id_range: id_range::max(),\n         all_loans: @mut ~[],\n         item_ub: body.node.id,\n-        repeating_ids: ~[body.node.id]\n+        repeating_ids: ~[body.node.id],\n+        move_data: @mut MoveData::new()\n     };\n     let v = visit::mk_vt(@visit::Visitor {visit_expr: gather_loans_in_expr,\n                                           visit_block: gather_loans_in_block,\n                                           visit_fn: gather_loans_in_fn,\n                                           visit_stmt: add_stmt_to_map,\n                                           visit_pat: add_pat_to_id_range,\n+                                          visit_local: gather_loans_in_local,\n                                           .. *visit::default_visitor()});\n     (v.visit_block)(body, glcx, v);\n-    return (glcx.id_range, glcx.all_loans);\n+    return (glcx.id_range, glcx.all_loans, glcx.move_data);\n }\n \n fn add_pat_to_id_range(p: @ast::pat,\n@@ -130,6 +136,35 @@ fn gather_loans_in_block(blk: &ast::blk,\n     visit::visit_block(blk, this, vt);\n }\n \n+fn gather_loans_in_local(local: @ast::local,\n+                         this: @mut GatherLoanCtxt,\n+                         vt: visit::vt<@mut GatherLoanCtxt>) {\n+    if local.node.init.is_none() {\n+        // Variable declarations without initializers are considered \"moves\":\n+        let tcx = this.bccx.tcx;\n+        do pat_util::pat_bindings(tcx.def_map, local.node.pat) |_, id, span, _| {\n+            gather_moves::gather_decl(this.bccx,\n+                                      this.move_data,\n+                                      id,\n+                                      span,\n+                                      id);\n+        }\n+    } else {\n+        // Variable declarations with initializers are considered \"assigns\":\n+        let tcx = this.bccx.tcx;\n+        do pat_util::pat_bindings(tcx.def_map, local.node.pat) |_, id, span, _| {\n+            gather_moves::gather_assignment(this.bccx,\n+                                            this.move_data,\n+                                            id,\n+                                            span,\n+                                            @LpVar(id),\n+                                            id);\n+        }\n+    }\n+\n+    visit::visit_local(local, this, vt);\n+}\n+\n fn gather_loans_in_expr(ex: @ast::expr,\n                         this: @mut GatherLoanCtxt,\n                         vt: visit::vt<@mut GatherLoanCtxt>) {\n@@ -147,6 +182,13 @@ fn gather_loans_in_expr(ex: @ast::expr,\n         this.guarantee_adjustments(ex, *adjustments);\n     }\n \n+    // If this expression is a move, gather it:\n+    if this.bccx.is_move(ex.id) {\n+        let cmt = this.bccx.cat_expr(ex);\n+        gather_moves::gather_move_from_expr(\n+            this.bccx, this.move_data, ex, cmt);\n+    }\n+\n     // Special checks for various kinds of expressions:\n     match ex.node {\n       ast::expr_addr_of(mutbl, base) => {\n@@ -159,6 +201,23 @@ fn gather_loans_in_expr(ex: @ast::expr,\n         visit::visit_expr(ex, this, vt);\n       }\n \n+      ast::expr_assign(l, _) | ast::expr_assign_op(_, l, _) => {\n+          let l_cmt = this.bccx.cat_expr(l);\n+          match opt_loan_path(l_cmt) {\n+              Some(l_lp) => {\n+                  gather_moves::gather_assignment(this.bccx, this.move_data,\n+                                                  ex.id, ex.span,\n+                                                  l_lp, l.id);\n+              }\n+              None => {\n+                  // This can occur with e.g. `*foo() = 5`.  In such\n+                  // cases, there is no need to check for conflicts\n+                  // with moves etc, just ignore.\n+              }\n+          }\n+          visit::visit_expr(ex, this, vt);\n+      }\n+\n       ast::expr_match(ex_v, ref arms) => {\n         let cmt = this.bccx.cat_expr(ex_v);\n         for arms.each |arm| {\n@@ -203,6 +262,11 @@ fn gather_loans_in_expr(ex: @ast::expr,\n           this.pop_repeating_id(body.node.id);\n       }\n \n+      ast::expr_fn_block(*) => {\n+          gather_moves::gather_captures(this.bccx, this.move_data, ex);\n+          visit::visit_expr(ex, this, vt);\n+      }\n+\n       _ => {\n         visit::visit_expr(ex, this, vt);\n       }\n@@ -558,8 +622,11 @@ pub impl GatherLoanCtxt {\n                     }\n                   }\n                   ast::bind_by_copy | ast::bind_infer => {\n-                    // Nothing to do here; neither copies nor moves induce\n-                    // borrows.\n+                      // No borrows here, but there may be moves\n+                      if self.bccx.is_move(pat.id) {\n+                          gather_moves::gather_move_from_pat(\n+                              self.bccx, self.move_data, pat, cmt);\n+                      }\n                   }\n                 }\n               }"}, {"sha": "4554fde15fad5b1820dfc89d0ef2f2a180e78f4c", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 105, "deletions": 10, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -19,7 +19,7 @@ use middle::moves;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::DataFlowOperator;\n use util::common::stmt_set;\n-use util::ppaux::{note_and_explain_region, Repr};\n+use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n use core::hashmap::{HashSet, HashMap};\n use core::io;\n@@ -46,6 +46,8 @@ pub mod check_loans;\n #[path=\"gather_loans/mod.rs\"]\n pub mod gather_loans;\n \n+pub mod move_data;\n+\n pub struct LoanDataFlowOperator;\n pub type LoanDataFlow = DataFlowContext<LoanDataFlowOperator>;\n \n@@ -121,21 +123,28 @@ fn borrowck_fn(fk: &visit::fn_kind,\n             debug!(\"borrowck_fn(id=%?)\", id);\n \n             // Check the body of fn items.\n-            let (id_range, all_loans) =\n+            let (id_range, all_loans, move_data) =\n                 gather_loans::gather_loans(this, body);\n-            let all_loans: &~[Loan] = &*all_loans; // FIXME(#5074)\n-            let mut dfcx =\n+            let mut loan_dfcx =\n                 DataFlowContext::new(this.tcx,\n                                      this.method_map,\n                                      LoanDataFlowOperator,\n                                      id_range,\n                                      all_loans.len());\n             for all_loans.eachi |loan_idx, loan| {\n-                dfcx.add_gen(loan.gen_scope, loan_idx);\n-                dfcx.add_kill(loan.kill_scope, loan_idx);\n+                loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n+                loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n             }\n-            dfcx.propagate(body);\n-            check_loans::check_loans(this, &dfcx, *all_loans, body);\n+            loan_dfcx.propagate(body);\n+\n+            let flowed_moves = move_data::FlowedMoveData::new(move_data,\n+                                                              this.tcx,\n+                                                              this.method_map,\n+                                                              id_range,\n+                                                              body);\n+\n+            check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n+                                     *all_loans, body);\n         }\n     }\n \n@@ -226,13 +235,13 @@ pub struct Loan {\n     span: span,\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum LoanPath {\n     LpVar(ast::node_id),               // `x` in doc.rs\n     LpExtend(@LoanPath, mc::MutabilityCategory, LoanPathElem)\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum LoanPathElem {\n     LpDeref,                     // `*LV` in doc.rs\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs\n@@ -407,6 +416,11 @@ pub enum AliasableViolationKind {\n     BorrowViolation\n }\n \n+pub enum MovedValueUseKind {\n+    MovedInUse,\n+    MovedInCapture,\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Misc\n \n@@ -419,6 +433,10 @@ pub impl BorrowckCtxt {\n         self.tcx.region_maps.is_subscope_of(r_sub, r_sup)\n     }\n \n+    fn is_move(&self, id: ast::node_id) -> bool {\n+        self.moves_map.contains(&id)\n+    }\n+\n     fn cat_expr(&self, expr: @ast::expr) -> mc::cmt {\n         mc::cat_expr(self.tcx, self.method_map, expr)\n     }\n@@ -478,6 +496,83 @@ pub impl BorrowckCtxt {\n         self.note_and_explain_bckerr(err);\n     }\n \n+    fn report_use_of_moved_value(&self,\n+                                 use_span: span,\n+                                 use_kind: MovedValueUseKind,\n+                                 lp: @LoanPath,\n+                                 move: &move_data::Move,\n+                                 moved_lp: @LoanPath) {\n+        let verb = match use_kind {\n+            MovedInUse => \"use\",\n+            MovedInCapture => \"capture\",\n+        };\n+\n+        match move.kind {\n+            move_data::Declared => {\n+                self.tcx.sess.span_err(\n+                    use_span,\n+                    fmt!(\"%s of possibly uninitialized value: `%s`\",\n+                         verb,\n+                         self.loan_path_to_str(lp)));\n+            }\n+            _ => {\n+                let partially = if lp == moved_lp {\"\"} else {\"partially \"};\n+                self.tcx.sess.span_err(\n+                    use_span,\n+                    fmt!(\"%s of %smoved value: `%s`\",\n+                         verb,\n+                         partially,\n+                         self.loan_path_to_str(lp)));\n+            }\n+        }\n+\n+        match move.kind {\n+            move_data::Declared => {}\n+\n+            move_data::MoveExpr(expr) => {\n+                let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+                self.tcx.sess.span_note(\n+                    expr.span,\n+                    fmt!(\"`%s` moved here because it has type `%s`, \\\n+                          which is moved by default (use `copy` to override)\",\n+                         self.loan_path_to_str(moved_lp),\n+                         expr_ty.user_string(self.tcx)));\n+            }\n+\n+            move_data::MovePat(pat) => {\n+                let pat_ty = ty::node_id_to_type(self.tcx, pat.id);\n+                self.tcx.sess.span_note(\n+                    pat.span,\n+                    fmt!(\"`%s` moved here because it has type `%s`, \\\n+                          which is moved by default (use `ref` to override)\",\n+                         self.loan_path_to_str(moved_lp),\n+                         pat_ty.user_string(self.tcx)));\n+            }\n+\n+            move_data::Captured(expr) => {\n+                self.tcx.sess.span_note(\n+                    expr.span,\n+                    fmt!(\"`%s` moved into closure environment here \\\n+                          because its type is moved by default \\\n+                          (make a copy and capture that instead to override)\",\n+                         self.loan_path_to_str(moved_lp)));\n+            }\n+        }\n+    }\n+\n+    fn report_reassigned_immutable_variable(&self,\n+                                            span: span,\n+                                            lp: @LoanPath,\n+                                            assign: &move_data::Assignment) {\n+        self.tcx.sess.span_err(\n+            span,\n+            fmt!(\"re-assignment of immutable variable `%s`\",\n+                 self.loan_path_to_str(lp)));\n+        self.tcx.sess.span_note(\n+            assign.span,\n+            fmt!(\"prior assignment occurs here\"));\n+    }\n+\n     fn span_err(&self, s: span, m: &str) {\n         self.tcx.sess.span_err(s, m);\n     }"}, {"sha": "84bd7ecb1a167b2336093f4e646542726002749c", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "added", "additions": 568, "deletions": 0, "changes": 568, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -0,0 +1,568 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Data structures used for tracking moves.\n+\n+*/\n+\n+use core::prelude::*;\n+use core::hashmap::{HashMap, HashSet};\n+use middle::borrowck::*;\n+use middle::dataflow::DataFlowContext;\n+use middle::dataflow::DataFlowOperator;\n+use middle::ty;\n+use middle::typeck;\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::codemap::span;\n+use syntax::opt_vec::OptVec;\n+use syntax::opt_vec;\n+use util::ppaux::Repr;\n+\n+pub struct MoveData {\n+    paths: ~[MovePath],\n+    path_map: HashMap<@LoanPath, MovePathIndex>,\n+    moves: ~[Move],\n+    path_assignments: ~[Assignment],\n+    var_assignments: ~[Assignment],\n+    assignee_ids: HashSet<ast::node_id>,\n+}\n+\n+pub struct FlowedMoveData {\n+    move_data: @mut MoveData,\n+    //         ^~~~~~~~~~~~~\n+    // It makes me sad to use @mut here, except that due to\n+    // the visitor design, this is what gather_loans\n+    // must produce.\n+    dfcx_moves: MoveDataFlow,\n+    dfcx_assign: AssignDataFlow\n+}\n+\n+#[deriving(Eq)]\n+pub struct MovePathIndex(uint);\n+\n+static InvalidMovePathIndex: MovePathIndex =\n+    MovePathIndex(uint::max_value);\n+\n+#[deriving(Eq)]\n+pub struct MoveIndex(uint);\n+\n+static InvalidMoveIndex: MoveIndex =\n+    MoveIndex(uint::max_value);\n+\n+#[deriving(Eq)]\n+pub struct VarAssignmentIndex(uint);\n+\n+static InvalidVarAssignmentIndex: VarAssignmentIndex =\n+    VarAssignmentIndex(uint::max_value);\n+\n+pub struct MovePath {\n+    index: MovePathIndex,\n+    loan_path: @LoanPath,\n+    parent: MovePathIndex,\n+    first_move: MoveIndex,\n+    first_child: MovePathIndex,\n+    next_sibling: MovePathIndex,\n+}\n+\n+pub enum MoveKind {\n+    Declared,               // When declared, variables start out \"moved\".\n+    MoveExpr(@ast::expr),   // Expression or binding that moves a variable\n+    MovePat(@ast::pat),     // By-move binding\n+    Captured(@ast::expr),   // Closure creation that moves a value\n+}\n+\n+pub struct Move {\n+    path: MovePathIndex,\n+    id: ast::node_id,\n+    kind: MoveKind,\n+    next_move: MoveIndex,\n+}\n+\n+pub struct Assignment {\n+    path: MovePathIndex,\n+    id: ast::node_id,\n+    span: span,\n+}\n+\n+pub struct MoveDataFlowOperator;\n+pub type MoveDataFlow = DataFlowContext<MoveDataFlowOperator>;\n+\n+pub struct AssignDataFlowOperator;\n+pub type AssignDataFlow = DataFlowContext<AssignDataFlowOperator>;\n+\n+impl MoveData {\n+    pub fn new() -> MoveData {\n+        MoveData {\n+            paths: ~[],\n+            path_map: HashMap::new(),\n+            moves: ~[],\n+            path_assignments: ~[],\n+            var_assignments: ~[],\n+            assignee_ids: HashSet::new(),\n+        }\n+    }\n+\n+    fn path<'a>(&'a self, index: MovePathIndex) -> &'a MovePath {\n+        //! Type safe indexing operator\n+        &self.paths[*index]\n+    }\n+\n+    fn mut_path<'a>(&'a mut self, index: MovePathIndex) -> &'a mut MovePath {\n+        //! Type safe indexing operator\n+        &mut self.paths[*index]\n+    }\n+\n+    fn move<'a>(&'a self, index: MoveIndex) -> &'a Move {\n+        //! Type safe indexing operator\n+        &self.moves[*index]\n+    }\n+\n+    fn is_var_path(&self, index: MovePathIndex) -> bool {\n+        //! True if `index` refers to a variable\n+        self.path(index).parent == InvalidMovePathIndex\n+    }\n+\n+    pub fn move_path(&mut self,\n+                     tcx: ty::ctxt,\n+                     lp: @LoanPath) -> MovePathIndex {\n+        /*!\n+         * Returns the existing move path index for `lp`, if any,\n+         * and otherwise adds a new index for `lp` and any of its\n+         * base paths that do not yet have an index.\n+         */\n+\n+        match self.path_map.find(&lp) {\n+            Some(&index) => {\n+                return index;\n+            }\n+            None => {}\n+        }\n+\n+        let index = match *lp {\n+            LpVar(*) => {\n+                let index = MovePathIndex(self.paths.len());\n+\n+                self.paths.push(MovePath {\n+                    index: index,\n+                    loan_path: lp,\n+                    parent: InvalidMovePathIndex,\n+                    first_move: InvalidMoveIndex,\n+                    first_child: InvalidMovePathIndex,\n+                    next_sibling: InvalidMovePathIndex,\n+                });\n+\n+                index\n+            }\n+\n+            LpExtend(base, _, _) => {\n+                let parent_index = self.move_path(tcx, base);\n+                let index = MovePathIndex(self.paths.len());\n+\n+                let next_sibling = self.path(parent_index).first_child;\n+                self.mut_path(parent_index).first_child = index;\n+\n+                self.paths.push(MovePath {\n+                    index: index,\n+                    loan_path: lp,\n+                    parent: parent_index,\n+                    first_move: InvalidMoveIndex,\n+                    first_child: InvalidMovePathIndex,\n+                    next_sibling: next_sibling,\n+                });\n+\n+                index\n+            }\n+        };\n+\n+        debug!(\"move_path(lp=%s, index=%?)\",\n+               lp.repr(tcx),\n+               index);\n+\n+        assert_eq!(*index, self.paths.len() - 1);\n+        self.path_map.insert(lp, index);\n+        return index;\n+    }\n+\n+    fn existing_move_path(&self,\n+                          lp: @LoanPath)\n+                          -> Option<MovePathIndex> {\n+        self.path_map.find_copy(&lp)\n+    }\n+\n+    fn existing_base_paths(&self,\n+                           lp: @LoanPath)\n+                           -> OptVec<MovePathIndex> {\n+        let mut result = opt_vec::Empty;\n+        self.add_existing_base_paths(lp, &mut result);\n+        result\n+    }\n+\n+    fn add_existing_base_paths(&self,\n+                               lp: @LoanPath,\n+                               result: &mut OptVec<MovePathIndex>) {\n+        /*!\n+         * Adds any existing move path indices for `lp` and any base\n+         * paths of `lp` to `result`, but does not add new move paths\n+         */\n+\n+        match self.path_map.find_copy(&lp) {\n+            Some(index) => {\n+                for self.each_base_path(index) |p| {\n+                    result.push(p);\n+                }\n+            }\n+            None => {\n+                match *lp {\n+                    LpVar(*) => { }\n+                    LpExtend(b, _, _) => {\n+                        self.add_existing_base_paths(b, result);\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    pub fn add_move(&mut self,\n+                    tcx: ty::ctxt,\n+                    lp: @LoanPath,\n+                    id: ast::node_id,\n+                    kind: MoveKind) {\n+        /*!\n+         * Adds a new move entry for a move of `lp` that occurs at\n+         * location `id` with kind `kind`.\n+         */\n+\n+        debug!(\"add_move(lp=%s, id=%?, kind=%?)\",\n+               lp.repr(tcx),\n+               id,\n+               kind);\n+\n+        let path_index = self.move_path(tcx, lp);\n+        let move_index = MoveIndex(self.moves.len());\n+\n+        let next_move = self.path(path_index).first_move;\n+        self.mut_path(path_index).first_move = move_index;\n+\n+        self.moves.push(Move {\n+            path: path_index,\n+            id: id,\n+            kind: kind,\n+            next_move: next_move\n+        });\n+    }\n+\n+    pub fn add_assignment(&mut self,\n+                          tcx: ty::ctxt,\n+                          lp: @LoanPath,\n+                          assign_id: ast::node_id,\n+                          span: span,\n+                          assignee_id: ast::node_id) {\n+        /*!\n+         * Adds a new record for an assignment to `lp` that occurs at\n+         * location `id` with the given `span`.\n+         */\n+\n+        debug!(\"add_assignment(lp=%s, assign_id=%?, assignee_id=%?\",\n+               lp.repr(tcx), assign_id, assignee_id);\n+\n+        let path_index = self.move_path(tcx, lp);\n+\n+        self.assignee_ids.insert(assignee_id);\n+\n+        let assignment = Assignment {\n+            path: path_index,\n+            id: assign_id,\n+            span: span,\n+        };\n+\n+        if self.is_var_path(path_index) {\n+            debug!(\"add_assignment[var](lp=%s, assignment=%u, path_index=%?)\",\n+                   lp.repr(tcx), self.var_assignments.len(), path_index);\n+\n+            self.var_assignments.push(assignment);\n+        } else {\n+            debug!(\"add_assignment[path](lp=%s, path_index=%?)\",\n+                   lp.repr(tcx), path_index);\n+\n+            self.path_assignments.push(assignment);\n+        }\n+    }\n+\n+    fn add_gen_kills(&self,\n+                     tcx: ty::ctxt,\n+                     dfcx_moves: &mut MoveDataFlow,\n+                     dfcx_assign: &mut AssignDataFlow) {\n+        /*!\n+         * Adds the gen/kills for the various moves and\n+         * assignments into the provided data flow contexts.\n+         * Moves are generated by moves and killed by assignments and\n+         * scoping. Assignments are generated by assignment to variables and\n+         * killed by scoping. See `doc.rs` for more details.\n+         */\n+\n+        for self.moves.eachi |i, move| {\n+            dfcx_moves.add_gen(move.id, i);\n+        }\n+\n+        for self.var_assignments.eachi |i, assignment| {\n+            dfcx_assign.add_gen(assignment.id, i);\n+            self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n+        }\n+\n+        for self.path_assignments.each |assignment| {\n+            self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n+        }\n+\n+        // Kill all moves related to a variable `x` when it goes out\n+        // of scope:\n+        for self.paths.each |path| {\n+            match *path.loan_path {\n+                LpVar(id) => {\n+                    let kill_id = tcx.region_maps.encl_scope(id);\n+                    let path = *self.path_map.get(&path.loan_path);\n+                    self.kill_moves(path, kill_id, dfcx_moves);\n+                }\n+                LpExtend(*) => {}\n+            }\n+        }\n+\n+        // Kill all assignments when the variable goes out of scope:\n+        for self.var_assignments.eachi |assignment_index, assignment| {\n+            match *self.path(assignment.path).loan_path {\n+                LpVar(id) => {\n+                    let kill_id = tcx.region_maps.encl_scope(id);\n+                    dfcx_assign.add_kill(kill_id, assignment_index);\n+                }\n+                LpExtend(*) => {\n+                    tcx.sess.bug(\"Var assignment for non var path\");\n+                }\n+            }\n+        }\n+    }\n+\n+    fn each_base_path(&self,\n+                      index: MovePathIndex,\n+                      f: &fn(MovePathIndex) -> bool)\n+                      -> bool {\n+        let mut p = index;\n+        while p != InvalidMovePathIndex {\n+            if !f(p) {\n+                return false;\n+            }\n+            p = self.path(p).parent;\n+        }\n+        return true;\n+    }\n+\n+    fn each_extending_path(&self,\n+                           index: MovePathIndex,\n+                           f: &fn(MovePathIndex) -> bool) -> bool {\n+        if !f(index) {\n+            return false;\n+        }\n+\n+        let mut p = self.path(index).first_child;\n+        while p != InvalidMovePathIndex {\n+            if !self.each_extending_path(p, f) {\n+                return false;\n+            }\n+            p = self.path(p).next_sibling;\n+        }\n+\n+        return true;\n+    }\n+\n+    fn each_applicable_move(&self,\n+                            index0: MovePathIndex,\n+                            f: &fn(MoveIndex) -> bool) -> bool {\n+        for self.each_extending_path(index0) |index| {\n+            let mut p = self.path(index).first_move;\n+            while p != InvalidMoveIndex {\n+                if !f(p) {\n+                    return false;\n+                }\n+                p = self.move(p).next_move;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    fn kill_moves(&self,\n+                  path: MovePathIndex,\n+                  kill_id: ast::node_id,\n+                  dfcx_moves: &mut MoveDataFlow) {\n+        for self.each_applicable_move(path) |move_index| {\n+            dfcx_moves.add_kill(kill_id, *move_index);\n+        }\n+    }\n+}\n+\n+impl FlowedMoveData {\n+    pub fn new(move_data: @mut MoveData,\n+               tcx: ty::ctxt,\n+               method_map: typeck::method_map,\n+               id_range: ast_util::id_range,\n+               body: &ast::blk)\n+               -> FlowedMoveData\n+    {\n+        let mut dfcx_moves =\n+            DataFlowContext::new(tcx,\n+                                 method_map,\n+                                 MoveDataFlowOperator,\n+                                 id_range,\n+                                 move_data.moves.len());\n+        let mut dfcx_assign =\n+            DataFlowContext::new(tcx,\n+                                 method_map,\n+                                 AssignDataFlowOperator,\n+                                 id_range,\n+                                 move_data.var_assignments.len());\n+        move_data.add_gen_kills(tcx, &mut dfcx_moves, &mut dfcx_assign);\n+        dfcx_moves.propagate(body);\n+        dfcx_assign.propagate(body);\n+        FlowedMoveData {\n+            move_data: move_data,\n+            dfcx_moves: dfcx_moves,\n+            dfcx_assign: dfcx_assign,\n+        }\n+    }\n+\n+    pub fn each_move_of(&self,\n+                        id: ast::node_id,\n+                        loan_path: @LoanPath,\n+                        f: &fn(&Move, @LoanPath) -> bool)\n+                        -> bool {\n+        /*!\n+         * Iterates through each move of `loan_path` (or some base path\n+         * of `loan_path`) that *may* have occurred on entry to `id` without\n+         * an intervening assignment. In other words, any moves that\n+         * would invalidate a reference to `loan_path` at location `id`.\n+         */\n+\n+        // Bad scenarios:\n+        //\n+        // 1. Move of `a.b.c`, use of `a.b.c`\n+        // 2. Move of `a.b.c`, use of `a.b.c.d`\n+        // 3. Move of `a.b.c`, use of `a` or `a.b`\n+        //\n+        // OK scenario:\n+        //\n+        // 4. move of `a.b.c`, use of `a.b.d`\n+\n+        let base_indices = self.move_data.existing_base_paths(loan_path);\n+        if base_indices.is_empty() {\n+            return true;\n+        }\n+\n+        let opt_loan_path_index = self.move_data.existing_move_path(loan_path);\n+\n+        for self.dfcx_moves.each_bit_on_entry(id) |index| {\n+            let move = &self.move_data.moves[index];\n+            let moved_path = move.path;\n+            if base_indices.contains(&moved_path) {\n+                // Scenario 1 or 2: `loan_path` or some base path of\n+                // `loan_path` was moved.\n+                if !f(move, self.move_data.path(moved_path).loan_path) {\n+                    return false;\n+                }\n+                loop;\n+            }\n+\n+            for opt_loan_path_index.each |&loan_path_index| {\n+                for self.move_data.each_base_path(moved_path) |p| {\n+                    if p == loan_path_index {\n+                        // Scenario 3: some extension of `loan_path`\n+                        // was moved\n+                        if !f(move, self.move_data.path(moved_path).loan_path) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    pub fn is_assignee(&self,\n+                       id: ast::node_id)\n+                       -> bool {\n+        //! True if `id` is the id of the LHS of an assignment\n+\n+        self.move_data.assignee_ids.contains(&id)\n+    }\n+\n+    pub fn each_assignment_of(&self,\n+                              id: ast::node_id,\n+                              loan_path: @LoanPath,\n+                              f: &fn(&Assignment) -> bool)\n+                              -> bool {\n+        /*!\n+         * Iterates through every assignment to `loan_path` that\n+         * may have occurred on entry to `id`. `loan_path` must be\n+         * a single variable.\n+         */\n+\n+        let loan_path_index = {\n+            match self.move_data.existing_move_path(loan_path) {\n+                Some(i) => i,\n+                None => {\n+                    // if there were any assignments, it'd have an index\n+                    return true;\n+                }\n+            }\n+        };\n+\n+        for self.dfcx_assign.each_bit_on_entry(id) |index| {\n+            let assignment = &self.move_data.var_assignments[index];\n+            if assignment.path == loan_path_index && !f(assignment) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n+\n+impl DataFlowOperator for MoveDataFlowOperator {\n+    #[inline(always)]\n+    fn initial_value(&self) -> bool {\n+        false // no loans in scope by default\n+    }\n+\n+    #[inline(always)]\n+    fn join(&self, succ: uint, pred: uint) -> uint {\n+        succ | pred // moves from both preds are in scope\n+    }\n+\n+    #[inline(always)]\n+    fn walk_closures(&self) -> bool {\n+        true\n+    }\n+}\n+\n+impl DataFlowOperator for AssignDataFlowOperator {\n+    #[inline(always)]\n+    fn initial_value(&self) -> bool {\n+        false // no assignments in scope by default\n+    }\n+\n+    #[inline(always)]\n+    fn join(&self, succ: uint, pred: uint) -> uint {\n+        succ | pred // moves from both preds are in scope\n+    }\n+\n+    #[inline(always)]\n+    fn walk_closures(&self) -> bool {\n+        true\n+    }\n+}"}, {"sha": "748ae83a60c570e32b25192641fe6af68bf6fdd9", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 62, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -866,7 +866,7 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n \n     if !any_by_move { return; } // pointless micro-optimization\n     for pats.each |pat| {\n-        do walk_pat(*pat) |p| {\n+        for walk_pat(*pat) |p| {\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n                     pat_ident(_, _, sub) => {\n@@ -884,66 +884,5 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n                 }\n             }\n         }\n-\n-        // Now check to ensure that any move binding is not behind an\n-        // @ or &, or within a struct with a destructor.  This is\n-        // always illegal.\n-        let vt = visit::mk_vt(@visit::Visitor {\n-            visit_pat: |pat, (behind_bad_pointer, behind_dtor_struct): (bool, bool), v| {\n-                match pat.node {\n-                    pat_ident(_, _, sub) => {\n-                        debug!(\"(check legality of move) checking pat \\\n-                                ident with behind_bad_pointer %? and behind_dtor_struct %?\",\n-                               behind_bad_pointer, behind_dtor_struct);\n-\n-                        if behind_bad_pointer || behind_dtor_struct &&\n-                            cx.moves_map.contains(&pat.id)\n-                        {\n-                            let msg = if behind_bad_pointer {\n-                                \"by-move pattern bindings may not occur behind @ or & bindings\"\n-                            } else {\n-                                \"cannot bind by-move within struct (it has a destructor)\"\n-                            };\n-                            cx.tcx.sess.span_err(pat.span, msg);\n-                        }\n-\n-                        match sub {\n-                            None => {}\n-                            Some(subpat) => {\n-                                (v.visit_pat)(subpat,\n-                                              (behind_bad_pointer, behind_dtor_struct),\n-                                              v);\n-                            }\n-                        }\n-                    }\n-\n-                    pat_box(subpat) | pat_region(subpat) => {\n-                        (v.visit_pat)(subpat, (true, behind_dtor_struct), v);\n-                    }\n-\n-                    pat_struct(_, ref fields, _) => {\n-                        let behind_dtor_struct = behind_dtor_struct ||\n-                            (match cx.tcx.def_map.find(&pat.id) {\n-                                Some(&def_struct(id)) => {\n-                                    ty::has_dtor(cx.tcx, id)\n-                                }\n-                                _ => false\n-                            });\n-                        debug!(\"(check legality of move) checking pat \\\n-                                struct with behind_bad_pointer %? and behind_dtor_struct %?\",\n-                               behind_bad_pointer, behind_dtor_struct);\n-\n-                        for fields.each |fld| {\n-                            (v.visit_pat)(fld.pat, (behind_bad_pointer,\n-                                                    behind_dtor_struct), v)\n-                        }\n-                    }\n-\n-                    _ => visit::visit_pat(pat, (behind_bad_pointer, behind_dtor_struct), v)\n-                }\n-            },\n-            .. *visit::default_visitor::<(bool, bool)>()\n-        });\n-        (vt.visit_pat)(*pat, (false, false), vt);\n     }\n }"}, {"sha": "e0806359c5d092a656b54456b6f439980a043653", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -651,10 +651,10 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_struct(_, ref fields, with_expr) => {\n-                self.walk_opt_expr(with_expr, in_out, loop_scopes);\n                 for fields.each |field| {\n                     self.walk_expr(field.node.expr, in_out, loop_scopes);\n                 }\n+                self.walk_opt_expr(with_expr, in_out, loop_scopes);\n             }\n \n             ast::expr_call(f, ref args, _) => {\n@@ -826,7 +826,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         debug!(\"DataFlowContext::walk_pat(pat=%s, in_out=%s)\",\n                pat.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n \n-        do ast_util::walk_pat(pat) |p| {\n+        for ast_util::walk_pat(pat) |p| {\n             debug!(\"  p.id=%? in_out=%s\", p.id, bits_to_str(reslice(in_out)));\n             self.merge_with_entry_set(p.id, in_out);\n             self.dfcx.apply_gen_kill(p.id, in_out);"}, {"sha": "4897d6c87dec191e3935b5c1f0ad0d7bdee11f22", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 180, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -109,7 +109,6 @@ use middle::pat_util;\n use middle::ty;\n use middle::typeck;\n use middle::moves;\n-use util::ppaux::ty_to_str;\n \n use core::cast::transmute;\n use core::hashmap::HashMap;\n@@ -146,7 +145,6 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n-                   variable_moves_map: moves::VariableMovesMap,\n                    capture_map: moves::CaptureMap,\n                    crate: @crate) {\n     let visitor = visit::mk_vt(@visit::Visitor {\n@@ -159,7 +157,6 @@ pub fn check_crate(tcx: ty::ctxt,\n \n     let initial_maps = @mut IrMaps(tcx,\n                                    method_map,\n-                                   variable_moves_map,\n                                    capture_map);\n     visit::visit_crate(crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n@@ -229,7 +226,6 @@ enum VarKind {\n struct IrMaps {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n-    variable_moves_map: moves::VariableMovesMap,\n     capture_map: moves::CaptureMap,\n \n     num_live_nodes: uint,\n@@ -243,13 +239,11 @@ struct IrMaps {\n \n fn IrMaps(tcx: ty::ctxt,\n           method_map: typeck::method_map,\n-          variable_moves_map: moves::VariableMovesMap,\n           capture_map: moves::CaptureMap)\n        -> IrMaps {\n     IrMaps {\n         tcx: tcx,\n         method_map: method_map,\n-        variable_moves_map: variable_moves_map,\n         capture_map: capture_map,\n         num_live_nodes: 0,\n         num_vars: 0,\n@@ -349,7 +343,6 @@ fn visit_fn(fk: &visit::fn_kind,\n     // swap in a new set of IR maps for this function body:\n     let fn_maps = @mut IrMaps(this.tcx,\n                               this.method_map,\n-                              this.variable_moves_map,\n                               this.capture_map);\n \n     unsafe {\n@@ -1399,11 +1392,7 @@ pub impl Liveness {\n fn check_local(local: @local, this: @Liveness, vt: vt<@Liveness>) {\n     match local.node.init {\n       Some(_) => {\n-\n-        // Initializer:\n         this.warn_about_unused_or_dead_vars_in_pat(local.node.pat);\n-        this.check_for_reassignments_in_pat(local.node.pat,\n-                                            local.node.is_mutbl);\n       }\n       None => {\n \n@@ -1438,35 +1427,6 @@ fn check_arm(arm: &arm, this: @Liveness, vt: vt<@Liveness>) {\n \n fn check_expr(expr: @expr, this: @Liveness, vt: vt<@Liveness>) {\n     match expr.node {\n-      expr_path(_) | expr_self => {\n-        for this.variable_from_def_map(expr.id, expr.span).each |var| {\n-            let ln = this.live_node(expr.id, expr.span);\n-\n-            match this.ir.variable_moves_map.find(&expr.id) {\n-                None => {}\n-                Some(&entire_expr) => {\n-                    debug!(\"(checking expr) is a move: `%s`\",\n-                           expr_to_str(expr, this.tcx.sess.intr()));\n-                    this.check_move_from_var(ln, *var, entire_expr);\n-                }\n-            }\n-        }\n-\n-        visit::visit_expr(expr, this, vt);\n-      }\n-\n-      expr_fn_block(*) => {\n-        let caps = this.ir.captures(expr);\n-        for caps.each |cap| {\n-            let var = this.variable(cap.var_nid, expr.span);\n-            if cap.is_move {\n-                this.check_move_from_var(cap.ln, var, expr);\n-            }\n-        }\n-\n-        visit::visit_expr(expr, this, vt);\n-      }\n-\n       expr_assign(l, r) => {\n         this.check_lvalue(l, vt);\n         (vt.visit_expr)(r, this, vt);\n@@ -1507,7 +1467,7 @@ fn check_expr(expr: @expr, this: @Liveness, vt: vt<@Liveness>) {\n       expr_cast(*) | expr_unary(*) | expr_ret(*) | expr_break(*) |\n       expr_again(*) | expr_lit(_) | expr_block(*) |\n       expr_mac(*) | expr_addr_of(*) | expr_struct(*) | expr_repeat(*) |\n-      expr_paren(*) => {\n+      expr_paren(*) | expr_fn_block(*) | expr_path(*) | expr_self(*) => {\n         visit::visit_expr(expr, this, vt);\n       }\n     }\n@@ -1547,43 +1507,17 @@ pub impl Liveness {\n         }\n     }\n \n-    fn check_move_from_var(&self,\n-                           ln: LiveNode,\n-                           var: Variable,\n-                           move_expr: @expr) {\n-        /*!\n-         * Checks whether `var` is live on entry to any of the\n-         * successors of `ln`.  If it is, report an error.\n-         * `move_expr` is the expression which caused the variable\n-         * to be moved.\n-         *\n-         * Note that `move_expr` is not necessarily a reference to the\n-         * variable.  It might be an expression like `x.f` which could\n-         * cause a move of the variable `x`, or a closure creation.\n-         */\n-\n-        debug!(\"check_move_from_var(%s, %s)\",\n-               ln.to_str(), var.to_str());\n-\n-        match self.live_on_exit(ln, var) {\n-          None => {}\n-          Some(lnk) => self.report_illegal_move(lnk, var, move_expr)\n-        }\n-    }\n-\n     fn check_lvalue(@self, expr: @expr, vt: vt<@Liveness>) {\n         match expr.node {\n           expr_path(_) => {\n             match self.tcx.def_map.get_copy(&expr.id) {\n-              def_local(nid, mutbl) => {\n+              def_local(nid, _) => {\n                 // Assignment to an immutable variable or argument: only legal\n                 // if there is no later assignment. If this local is actually\n                 // mutable, then check for a reassignment to flag the mutability\n                 // as being used.\n                 let ln = self.live_node(expr.id, expr.span);\n                 let var = self.variable(nid, expr.span);\n-                self.check_for_reassignment(ln, var, expr.span,\n-                                            if mutbl {Some(nid)} else {None});\n                 self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n               }\n               def => {\n@@ -1607,118 +1541,6 @@ pub impl Liveness {\n        }\n     }\n \n-    fn check_for_reassignments_in_pat(&self, pat: @pat, mutbl: bool) {\n-        do self.pat_bindings(pat) |ln, var, sp, id| {\n-            self.check_for_reassignment(ln, var, sp,\n-                                        if mutbl {Some(id)} else {None});\n-        }\n-    }\n-\n-    fn check_for_reassignment(&self, ln: LiveNode, var: Variable,\n-                              orig_span: span, mutbl: Option<node_id>) {\n-        match self.assigned_on_exit(ln, var) {\n-          Some(ExprNode(span)) => {\n-            match mutbl {\n-              Some(id) => { self.tcx.used_mut_nodes.insert(id); }\n-              None => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"re-assignment of immutable variable\");\n-                self.tcx.sess.span_note(\n-                    orig_span,\n-                    \"prior assignment occurs here\");\n-              }\n-            }\n-          }\n-          Some(lnk) => {\n-            self.tcx.sess.span_bug(\n-                orig_span,\n-                fmt!(\"illegal writer: %?\", lnk));\n-          }\n-          None => {}\n-        }\n-    }\n-\n-    fn report_illegal_move(&self, lnk: LiveNodeKind,\n-                           var: Variable,\n-                           move_expr: @expr) {\n-        // the only time that it is possible to have a moved variable\n-        // used by ExitNode would be arguments or fields in a ctor.\n-        // we give a slightly different error message in those cases.\n-        if lnk == ExitNode {\n-            // FIXME #4715: this seems like it should be reported in the\n-            // borrow checker\n-            let vk = self.ir.var_kinds[*var];\n-            match vk {\n-              Arg(_, name) => {\n-                self.tcx.sess.span_err(\n-                    move_expr.span,\n-                    fmt!(\"illegal move from argument `%s`, which is not \\\n-                          copy or move mode\", *self.tcx.sess.str_of(name)));\n-                return;\n-              }\n-              Local(*) | ImplicitRet => {\n-                self.tcx.sess.span_bug(\n-                    move_expr.span,\n-                    fmt!(\"illegal reader (%?) for `%?`\",\n-                         lnk, vk));\n-              }\n-            }\n-        }\n-\n-        match move_expr.node {\n-            expr_fn_block(*) => {\n-                self.report_illegal_read(\n-                    move_expr.span, lnk, var, MovedValue);\n-                let name = self.ir.variable_name(var);\n-                self.tcx.sess.span_note(\n-                    move_expr.span,\n-                    fmt!(\"`%s` moved into closure environment here \\\n-                          because its type is moved by default\",\n-                         *name));\n-            }\n-            expr_path(*) => {\n-                self.report_illegal_read(\n-                    move_expr.span, lnk, var, MovedValue);\n-                self.report_move_location(\n-                    move_expr, var, \"\", \"it\");\n-            }\n-            expr_field(*) => {\n-                self.report_illegal_read(\n-                    move_expr.span, lnk, var, PartiallyMovedValue);\n-                self.report_move_location(\n-                    move_expr, var, \"field of \", \"the field\");\n-            }\n-            expr_index(*) => {\n-                self.report_illegal_read(\n-                    move_expr.span, lnk, var, PartiallyMovedValue);\n-                self.report_move_location(\n-                    move_expr, var, \"element of \", \"the element\");\n-            }\n-            _ => {\n-                self.report_illegal_read(\n-                    move_expr.span, lnk, var, PartiallyMovedValue);\n-                self.report_move_location(\n-                    move_expr, var, \"subcomponent of \", \"the subcomponent\");\n-            }\n-        };\n-    }\n-\n-    fn report_move_location(&self,\n-                            move_expr: @expr,\n-                            var: Variable,\n-                            expr_descr: &str,\n-                            pronoun: &str) {\n-        let move_expr_ty = ty::expr_ty(self.tcx, move_expr);\n-        let name = self.ir.variable_name(var);\n-        self.tcx.sess.span_note(\n-            move_expr.span,\n-            fmt!(\"%s`%s` moved here because %s has type %s, \\\n-                  which is moved by default (use `copy` to override)\",\n-                 expr_descr, *name, pronoun,\n-                 ty_to_str(self.tcx, move_expr_ty)));\n-    }\n-\n     fn report_illegal_read(&self,\n                            chk_span: span,\n                            lnk: LiveNodeKind,"}, {"sha": "0d335559747249d48500e00d170fe16b7645f3ff", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -93,19 +93,26 @@ pub enum ptr_kind {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n-    InteriorElement(ty::t),    // ty::t is the type of the vec/str\n+    InteriorElement(ElementKind),\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum FieldName {\n     NamedField(ast::ident),\n     PositionalField(uint)\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n+pub enum ElementKind {\n+    VecElement,\n+    StrElement,\n+    OtherElement,\n+}\n+\n+#[deriving(Eq, IterBytes)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n     McReadOnly,  // Read-only (`const`)\n@@ -192,7 +199,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n \n         ty::ty_evec(_, ty::vstore_fixed(_)) |\n         ty::ty_estr(ty::vstore_fixed(_)) => {\n-            Some(deref_interior(InteriorElement(t)))\n+            Some(deref_interior(InteriorElement(element_kind(t))))\n         }\n \n         _ => None\n@@ -749,7 +756,7 @@ pub impl mem_categorization_ctxt {\n             @cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n-                cat:cat_interior(of_cmt, InteriorElement(vec_ty)),\n+                cat:cat_interior(of_cmt, InteriorElement(element_kind(vec_ty))),\n                 mutbl:mutbl,\n                 ty:mt.ty\n             }\n@@ -993,12 +1000,14 @@ pub impl mem_categorization_ctxt {\n           cat_interior(_, InteriorField(PositionalField(_))) => {\n               ~\"anonymous field\"\n           }\n-          cat_interior(_, InteriorElement(t)) => {\n-            match ty::get(t).sty {\n-              ty::ty_evec(*) => ~\"vec content\",\n-              ty::ty_estr(*) => ~\"str content\",\n-              _ => ~\"indexed content\"\n-            }\n+          cat_interior(_, InteriorElement(VecElement)) => {\n+              ~\"vec content\"\n+          }\n+          cat_interior(_, InteriorElement(StrElement)) => {\n+              ~\"str content\"\n+          }\n+          cat_interior(_, InteriorElement(OtherElement)) => {\n+              ~\"indexed content\"\n           }\n           cat_stack_upvar(_) => {\n               ~\"captured outer variable\"\n@@ -1193,3 +1202,11 @@ impl Repr for InteriorKind {\n         }\n     }\n }\n+\n+fn element_kind(t: ty::t) -> ElementKind {\n+    match ty::get(t).sty {\n+        ty::ty_evec(*) => VecElement,\n+        ty::ty_estr(*) => StrElement,\n+        _ => OtherElement\n+    }\n+}"}, {"sha": "159f7707dd38368f34a4b20aeadc345b60e918b7", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 56, "deletions": 128, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -88,32 +88,32 @@ Similar reasoning can be applied to `let` expressions:\n \n ## Output\n \n-The pass results in the struct `MoveMaps` which contains two sets,\n-`moves_map` and `variable_moves_map`, and one map, `capture_map`.\n-\n-`moves_map` is a set containing the id of every *outermost\n-expression* or *binding* that is moved.  Note that `moves_map` only\n-contains the *outermost expressions* that are moved.  Therefore, if\n-you have a use of `x.b`, as in the example `y` above, the\n-expression `x.b` would be in the `moves_map` but not `x`.  The\n-reason for this is that, for most purposes, it's only the outermost\n-expression that is needed.  The borrow checker and trans, for\n-example, only care about the outermost expressions that are moved.\n-It is more efficient therefore just to store those entries.\n-\n-In the case of the liveness pass, however, we need to know which\n-*variable references* are moved (see the Enforcement of Moves\n-section below for more details).  That is, for the `x.b`\n-expression, liveness only cares about the `x`.  For this purpose,\n-we have a second map, `variable_moves_map`, that contains the ids\n-of all variable references which is moved.\n-\n-The `capture_map` maps from the node_id of a closure expression to an\n-array of `CaptureVar` structs detailing which variables are captured\n-and how (by ref, by copy, by move).\n+The pass results in the struct `MoveMaps` which contains several\n+maps:\n+\n+`moves_map` is a set containing the id of every *outermost expression* or\n+*binding* that causes a move.  Note that `moves_map` only contains the *outermost\n+expressions* that are moved.  Therefore, if you have a use of `x.b`,\n+as in the example `y` above, the expression `x.b` would be in the\n+`moves_map` but not `x`.  The reason for this is that, for most\n+purposes, it's only the outermost expression that is needed.  The\n+borrow checker and trans, for example, only care about the outermost\n+expressions that are moved.  It is more efficient therefore just to\n+store those entries.\n+\n+Sometimes though we want to know the variables that are moved (in\n+particular in the borrow checker). For these cases, the set\n+`moved_variables_set` just collects the ids of variables that are\n+moved.\n+\n+Finally, the `capture_map` maps from the node_id of a closure\n+expression to an array of `CaptureVar` structs detailing which\n+variables are captured and how (by ref, by copy, by move).\n \n ## Enforcement of Moves\n \n+FIXME out of date\n+\n The enforcement of moves is somewhat complicated because it is divided\n amongst the liveness and borrowck modules. In general, the borrow\n checker is responsible for guaranteeing that *only owned data is\n@@ -136,12 +136,8 @@ invalidated.\n In more concrete terms, the `moves_map` generated from this example\n would contain both the expression `x.b` (1) and the expression `x`\n (2).  Note that it would not contain `x` (1), because `moves_map` only\n-contains the outermost expressions that are moved.  However,\n-`moves_map` is not used by liveness.  It uses the\n-`variable_moves_map`, which would contain both references to `x`: (1)\n-and (2).  Therefore, after computing which variables are live where,\n-liveness will see that the reference (1) to `x` is both present in\n-`variable_moves_map` and that `x` is live and report an error.\n+contains the outermost expressions that are moved.  However, the id of\n+`x` would be present in the `moved_variables_set`.\n \n Now let's look at another illegal example, but one where liveness would\n not catch the error:\n@@ -213,14 +209,14 @@ use middle::freevars;\n use middle::ty;\n use middle::typeck::{method_map};\n use util::ppaux;\n+use util::ppaux::Repr;\n use util::common::indenter;\n \n use core::hashmap::{HashSet, HashMap};\n use syntax::ast::*;\n use syntax::ast_util;\n use syntax::visit;\n use syntax::visit::vt;\n-use syntax::print::pprust;\n use syntax::codemap::span;\n \n #[deriving(Encodable, Decodable)]\n@@ -241,11 +237,6 @@ pub type CaptureMap = @mut HashMap<node_id, @[CaptureVar]>;\n \n pub type MovesMap = @mut HashSet<node_id>;\n \n-/**\n- * For each variable which will be moved, links to the\n- * expression */\n-pub type VariableMovesMap = @mut HashMap<node_id, @expr>;\n-\n /**\n  * Set of variable node-ids that are moved.\n  *\n@@ -257,7 +248,6 @@ pub type MovedVariablesSet = @mut HashSet<node_id>;\n /** See the section Output on the module comment for explanation. */\n pub struct MoveMaps {\n     moves_map: MovesMap,\n-    variable_moves_map: VariableMovesMap,\n     moved_variables_set: MovedVariablesSet,\n     capture_map: CaptureMap\n }\n@@ -269,9 +259,8 @@ struct VisitContext {\n }\n \n enum UseMode {\n-    MoveInWhole,         // Move the entire value.\n-    MoveInPart(@expr),   // Some subcomponent will be moved\n-    Read                 // Read no matter what the type.\n+    Move,        // This value or something owned by it is moved.\n+    Read         // Read no matter what the type.\n }\n \n pub fn compute_moves(tcx: ty::ctxt,\n@@ -287,7 +276,6 @@ pub fn compute_moves(tcx: ty::ctxt,\n         method_map: method_map,\n         move_maps: MoveMaps {\n             moves_map: @mut HashSet::new(),\n-            variable_moves_map: @mut HashMap::new(),\n             capture_map: @mut HashMap::new(),\n             moved_variables_set: @mut HashSet::new()\n         }\n@@ -317,21 +305,6 @@ fn compute_modes_for_expr(expr: @expr,\n     cx.consume_expr(expr, v);\n }\n \n-pub impl UseMode {\n-    fn component_mode(&self, expr: @expr) -> UseMode {\n-        /*!\n-         *\n-         * Assuming that `self` is the mode for an expression E,\n-         * returns the appropriate mode to use for a subexpression of E.\n-         */\n-\n-        match *self {\n-            Read | MoveInPart(_) => *self,\n-            MoveInWhole => MoveInPart(expr)\n-        }\n-    }\n-}\n-\n pub impl VisitContext {\n     fn consume_exprs(&self,\n                      exprs: &[@expr],\n@@ -347,26 +320,27 @@ pub impl VisitContext {\n                     visitor: vt<VisitContext>)\n     {\n         /*!\n-         *\n          * Indicates that the value of `expr` will be consumed,\n          * meaning either copied or moved depending on its type.\n          */\n \n-        debug!(\"consume_expr(expr=%?/%s)\",\n-               expr.id,\n-               pprust::expr_to_str(expr, self.tcx.sess.intr()));\n+        debug!(\"consume_expr(expr=%s)\",\n+               expr.repr(self.tcx));\n \n         let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-        let mode = self.consume_mode_for_ty(expr_ty);\n-        self.use_expr(expr, mode, visitor);\n+        if ty::type_moves_by_default(self.tcx, expr_ty) {\n+            self.move_maps.moves_map.insert(expr.id);\n+            self.use_expr(expr, Move, visitor);\n+        } else {\n+            self.use_expr(expr, Read, visitor);\n+        };\n     }\n \n     fn consume_block(&self,\n                      blk: &blk,\n                      visitor: vt<VisitContext>)\n     {\n         /*!\n-         *\n          * Indicates that the value of `blk` will be consumed,\n          * meaning either copied or moved depending on its type.\n          */\n@@ -382,76 +356,42 @@ pub impl VisitContext {\n         }\n     }\n \n-    fn consume_mode_for_ty(&self, ty: ty::t) -> UseMode {\n-        /*!\n-         *\n-         * Selects the appropriate `UseMode` to consume a value with\n-         * the type `ty`.  This will be `MoveEntireMode` if `ty` is\n-         * not implicitly copyable.\n-         */\n-\n-        let result = if ty::type_moves_by_default(self.tcx, ty) {\n-            MoveInWhole\n-        } else {\n-            Read\n-        };\n-\n-        debug!(\"consume_mode_for_ty(ty=%s) = %?\",\n-               ppaux::ty_to_str(self.tcx, ty), result);\n-\n-        return result;\n-    }\n-\n     fn use_expr(&self,\n                 expr: @expr,\n                 expr_mode: UseMode,\n                 visitor: vt<VisitContext>)\n     {\n         /*!\n-         *\n          * Indicates that `expr` is used with a given mode.  This will\n          * in turn trigger calls to the subcomponents of `expr`.\n          */\n \n-        debug!(\"use_expr(expr=%?/%s, mode=%?)\",\n-               expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()),\n+        debug!(\"use_expr(expr=%s, mode=%?)\",\n+               expr.repr(self.tcx),\n                expr_mode);\n \n-        match expr_mode {\n-            MoveInWhole => { self.move_maps.moves_map.insert(expr.id); }\n-            MoveInPart(_) | Read => {}\n-        }\n-\n         // `expr_mode` refers to the post-adjustment value.  If one of\n         // those adjustments is to take a reference, then it's only\n         // reading the underlying expression, not moving it.\n         let comp_mode = match self.tcx.adjustments.find(&expr.id) {\n             Some(&@ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n                     autoref: Some(_), _})) => Read,\n-            _ => expr_mode.component_mode(expr)\n+            _ => expr_mode\n         };\n \n         debug!(\"comp_mode = %?\", comp_mode);\n \n         match expr.node {\n             expr_path(*) | expr_self => {\n                 match comp_mode {\n-                    MoveInPart(entire_expr) => {\n-                        self.move_maps.variable_moves_map.insert(\n-                            expr.id, entire_expr);\n-\n+                    Move => {\n                         let def = self.tcx.def_map.get_copy(&expr.id);\n                         for moved_variable_node_id_from_def(def).each |&id| {\n                             self.move_maps.moved_variables_set.insert(id);\n                         }\n                     }\n                     Read => {}\n-                    MoveInWhole => {\n-                        self.tcx.sess.span_bug(\n-                            expr.span,\n-                            \"Component mode can never be MoveInWhole\");\n-                    }\n                 }\n             }\n \n@@ -546,19 +486,10 @@ pub impl VisitContext {\n                     self.consume_arm(arm, visitor);\n                 }\n \n-                let by_move_bindings_present =\n-                    self.arms_have_by_move_bindings(\n-                        self.move_maps.moves_map, *arms);\n-\n-                if by_move_bindings_present {\n-                    // If one of the arms moves a value out of the\n-                    // discriminant, then the discriminant itself is\n-                    // moved.\n-                    self.consume_expr(discr, visitor);\n-                } else {\n-                    // Otherwise, the discriminant is merely read.\n-                    self.use_expr(discr, Read, visitor);\n-                }\n+                // The discriminant may, in fact, be partially moved\n+                // if there are by-move bindings, but borrowck deals\n+                // with that itself.\n+                self.use_expr(discr, Read, visitor);\n             }\n \n             expr_copy(base) => {\n@@ -719,18 +650,17 @@ pub impl VisitContext {\n          */\n \n         do pat_bindings(self.tcx.def_map, pat) |bm, id, _span, _path| {\n-            let mode = match bm {\n-                bind_by_copy => Read,\n-                bind_by_ref(_) => Read,\n+            let binding_moves = match bm {\n+                bind_by_copy => false,\n+                bind_by_ref(_) => false,\n                 bind_infer => {\n                     let pat_ty = ty::node_id_to_type(self.tcx, id);\n-                    self.consume_mode_for_ty(pat_ty)\n+                    ty::type_moves_by_default(self.tcx, pat_ty)\n                 }\n             };\n \n-            match mode {\n-                MoveInWhole => { self.move_maps.moves_map.insert(id); }\n-                MoveInPart(_) | Read => {}\n+            if binding_moves {\n+                self.move_maps.moves_map.insert(id);\n             }\n         }\n     }\n@@ -759,20 +689,18 @@ pub impl VisitContext {\n \n     fn arms_have_by_move_bindings(&self,\n                                   moves_map: MovesMap,\n-                                  arms: &[arm]) -> bool\n+                                  arms: &[arm]) -> Option<@pat>\n     {\n         for arms.each |arm| {\n-            for arm.pats.each |pat| {\n-                let mut found = false;\n-                do pat_bindings(self.tcx.def_map, *pat) |_, node_id, _, _| {\n-                    if moves_map.contains(&node_id) {\n-                        found = true;\n+            for arm.pats.each |&pat| {\n+                for ast_util::walk_pat(pat) |p| {\n+                    if moves_map.contains(&p.id) {\n+                        return Some(p);\n                     }\n                 }\n-                if found { return true; }\n             }\n         }\n-        return false;\n+        return None;\n     }\n \n     fn compute_captures(&self, fn_expr_id: node_id) -> @[CaptureVar] {"}, {"sha": "1237e9fb4a26a690dd23f00a78e2dbce233f2691", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -72,8 +72,8 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n }\n \n pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n-                it: &fn(binding_mode, node_id, span, @Path)) {\n-    do walk_pat(pat) |p| {\n+                    it: &fn(binding_mode, node_id, span, @Path)) {\n+    for walk_pat(pat) |p| {\n         match p.node {\n           pat_ident(binding_mode, pth, _) if pat_is_binding(dm, p) => {\n             it(binding_mode, p.id, p.span, pth);"}, {"sha": "979d04e18c3408c957ff14e60992b6b207a1f2ef", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -4151,7 +4151,7 @@ pub impl Resolver {\n                        bindings_list: Option<@mut HashMap<ident,node_id>>,\n                        visitor: ResolveVisitor) {\n         let pat_id = pattern.id;\n-        do walk_pat(pattern) |pattern| {\n+        for walk_pat(pattern) |pattern| {\n             match pattern.node {\n                 pat_ident(binding_mode, path, _)\n                         if !path.global && path.idents.len() == 1 => {"}, {"sha": "8edae63cea92649bee448116095a1b8b708e3e4b", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -157,8 +157,8 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n                              None);\n                     fcx.write_error(pat.id);\n                     kind_name = \"[error]\";\n-                    arg_types = (copy subpats).get_or_default(~[]).map(|_|\n-                                                                       ty::mk_err());\n+                    arg_types = (copy *subpats).get_or_default(~[]).map(|_|\n+                                                                        ty::mk_err());\n                 }\n             }\n         }\n@@ -199,8 +199,8 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n                     None);\n             fcx.write_error(pat.id);\n             kind_name = \"[error]\";\n-            arg_types = (copy subpats).get_or_default(~[]).map(|_|\n-                                                               ty::mk_err());\n+            arg_types = (copy *subpats).get_or_default(~[]).map(|_|\n+                                                                ty::mk_err());\n         }\n     }\n "}, {"sha": "8694c0e356eb182582af5a46553695fe8c0a7d04", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -801,3 +801,9 @@ impl UserString for ty::TraitRef {\n         }\n     }\n }\n+\n+impl UserString for ty::t {\n+    fn user_string(&self, tcx: ctxt) -> ~str {\n+        ty_to_str(tcx, *self)\n+    }\n+}"}, {"sha": "289aa33f67c37cd4a6dda7a605c814a9abad56c6", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -74,7 +74,7 @@ fn build_mod_index(\n ) -> doc::Index {\n     doc::Index {\n         entries: doc.items.map(|doc| {\n-            item_to_entry(copy *doc, copy config)\n+            item_to_entry(copy *doc, &config)\n         })\n     }\n }\n@@ -85,14 +85,14 @@ fn build_nmod_index(\n ) -> doc::Index {\n     doc::Index {\n         entries: doc.fns.map(|doc| {\n-            item_to_entry(doc::FnTag(copy *doc), copy config)\n+            item_to_entry(doc::FnTag(copy *doc), &config)\n         })\n     }\n }\n \n fn item_to_entry(\n     doc: doc::ItemTag,\n-    config: config::Config\n+    config: &config::Config\n ) -> doc::IndexEntry {\n     let link = match doc {\n       doc::ModTag(_) | doc::NmodTag(_)\n@@ -222,13 +222,13 @@ mod test {\n             config::DocPerCrate,\n             ~\"mod a { } fn b() { }\"\n         );\n-        assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+        assert!(doc.cratemod().index.get().entries[0] == doc::IndexEntry {\n             kind: ~\"Module\",\n             name: ~\"a\",\n             brief: None,\n             link: ~\"#module-a\"\n         });\n-        assert!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n+        assert!(doc.cratemod().index.get().entries[1] == doc::IndexEntry {\n             kind: ~\"Function\",\n             name: ~\"b\",\n             brief: None,\n@@ -242,13 +242,13 @@ mod test {\n             config::DocPerMod,\n             ~\"mod a { } fn b() { }\"\n         );\n-        assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+        assert!(doc.cratemod().index.get().entries[0] == doc::IndexEntry {\n             kind: ~\"Module\",\n             name: ~\"a\",\n             brief: None,\n             link: ~\"a.html\"\n         });\n-        assert!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n+        assert!(doc.cratemod().index.get().entries[1] == doc::IndexEntry {\n             kind: ~\"Function\",\n             name: ~\"b\",\n             brief: None,\n@@ -262,7 +262,7 @@ mod test {\n             config::DocPerMod,\n             ~\"#[doc = \\\"test\\\"] mod a { }\"\n         );\n-        assert!((&doc.cratemod().index).get().entries[0].brief\n+        assert!(doc.cratemod().index.get().entries[0].brief\n                 == Some(~\"test\"));\n     }\n \n@@ -272,7 +272,7 @@ mod test {\n             config::DocPerCrate,\n             ~\"extern { fn b(); }\"\n         );\n-        assert!((&doc.cratemod().nmods()[0].index).get().entries[0]\n+        assert!(doc.cratemod().nmods()[0].index.get().entries[0]\n                 == doc::IndexEntry {\n                     kind: ~\"Function\",\n                     name: ~\"b\","}, {"sha": "a3ad8d8d04de3413bad36958debf7d431f163f35", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -181,12 +181,12 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n         }\n         &doc::ImplTag(ref doc) => {\n             assert!(doc.self_ty.is_some());\n-            let bounds = if (&doc.bounds_str).is_some() {\n-                fmt!(\" where %s\", (&doc.bounds_str).get())\n+            let bounds = if doc.bounds_str.is_some() {\n+                fmt!(\" where %s\", *doc.bounds_str.get_ref())\n             } else {\n                 ~\"\"\n             };\n-            let self_ty = (&doc.self_ty).get();\n+            let self_ty = doc.self_ty.get_ref();\n             let mut trait_part = ~\"\";\n             for doc.trait_types.eachi |i, trait_type| {\n                 if i == 0 {\n@@ -196,7 +196,7 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n                 }\n                 trait_part += *trait_type;\n             }\n-            fmt!(\"%s for %s%s\", trait_part, self_ty, bounds)\n+            fmt!(\"%s for %s%s\", trait_part, *self_ty, bounds)\n         }\n         _ => {\n             doc.name()\n@@ -208,17 +208,17 @@ pub fn header_text(doc: doc::ItemTag) -> ~str {\n     match &doc {\n         &doc::ImplTag(ref ImplDoc) => {\n             let header_kind = header_kind(copy doc);\n-            let bounds = if (&ImplDoc.bounds_str).is_some() {\n-                fmt!(\" where `%s`\", (&ImplDoc.bounds_str).get())\n+            let bounds = if ImplDoc.bounds_str.is_some() {\n+                fmt!(\" where `%s`\", *ImplDoc.bounds_str.get_ref())\n             } else {\n                 ~\"\"\n             };\n             let desc = if ImplDoc.trait_types.is_empty() {\n-                fmt!(\"for `%s`%s\", (&ImplDoc.self_ty).get(), bounds)\n+                fmt!(\"for `%s`%s\", *ImplDoc.self_ty.get_ref(), bounds)\n             } else {\n                 fmt!(\"of `%s` for `%s`%s\",\n                      ImplDoc.trait_types[0],\n-                     (&ImplDoc.self_ty).get(),\n+                     *ImplDoc.self_ty.get_ref(),\n                      bounds)\n             };\n             return fmt!(\"%s %s\", header_kind, desc);\n@@ -295,7 +295,7 @@ fn write_mod_contents(\n ) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     if doc.index.is_some() {\n-        write_index(ctxt, (&doc.index).get());\n+        write_index(ctxt, doc.index.get_ref());\n     }\n \n     for doc.items.each |itemTag| {\n@@ -340,7 +340,7 @@ fn item_header_lvl(doc: &doc::ItemTag) -> Hlvl {\n     }\n }\n \n-fn write_index(ctxt: &Ctxt, index: doc::Index) {\n+fn write_index(ctxt: &Ctxt, index: &doc::Index) {\n     if vec::is_empty(index.entries) {\n         return;\n     }\n@@ -353,7 +353,7 @@ fn write_index(ctxt: &Ctxt, index: doc::Index) {\n         let id = copy entry.link;\n         if entry.brief.is_some() {\n             ctxt.w.put_line(fmt!(\"* [%s](%s) - %s\",\n-                                 header, id, (&entry.brief).get()));\n+                                 header, id, *entry.brief.get_ref()));\n         } else {\n             ctxt.w.put_line(fmt!(\"* [%s](%s)\", header, id));\n         }\n@@ -366,7 +366,7 @@ fn write_index(ctxt: &Ctxt, index: doc::Index) {\n fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     if doc.index.is_some() {\n-        write_index(ctxt, (&doc.index).get());\n+        write_index(ctxt, doc.index.get_ref());\n     }\n \n     for doc.fns.each |FnDoc| {\n@@ -450,17 +450,17 @@ fn write_variants(\n \n fn write_variant(ctxt: &Ctxt, doc: doc::VariantDoc) {\n     assert!(doc.sig.is_some());\n-    let sig = (&doc.sig).get();\n+    let sig = doc.sig.get_ref();\n \n     // space out list items so they all end up within paragraph elements\n     ctxt.w.put_line(~\"\");\n \n     match copy doc.desc {\n         Some(desc) => {\n-            ctxt.w.put_line(list_item_indent(fmt!(\"* `%s` - %s\", sig, desc)));\n+            ctxt.w.put_line(list_item_indent(fmt!(\"* `%s` - %s\", *sig, desc)));\n         }\n         None => {\n-            ctxt.w.put_line(fmt!(\"* `%s`\", sig));\n+            ctxt.w.put_line(fmt!(\"* `%s`\", *sig));\n         }\n     }\n }"}, {"sha": "973326b10dce8bfa11a5ae20bce4b5bb04c6f9cd", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -59,20 +59,20 @@ pub fn make_writer_factory(config: config::Config) -> WriterFactory {\n \n fn markdown_writer_factory(config: config::Config) -> WriterFactory {\n     let result: ~fn(page: doc::Page) -> Writer = |page| {\n-        markdown_writer(copy config, page)\n+        markdown_writer(&config, page)\n     };\n     result\n }\n \n fn pandoc_writer_factory(config: config::Config) -> WriterFactory {\n     let result: ~fn(doc::Page) -> Writer = |page| {\n-        pandoc_writer(copy config, page)\n+        pandoc_writer(&config, page)\n     };\n     result\n }\n \n fn markdown_writer(\n-    config: config::Config,\n+    config: &config::Config,\n     page: doc::Page\n ) -> Writer {\n     let filename = make_local_filename(config, page);\n@@ -82,11 +82,11 @@ fn markdown_writer(\n }\n \n fn pandoc_writer(\n-    config: config::Config,\n+    config: &config::Config,\n     page: doc::Page\n ) -> Writer {\n     assert!(config.pandoc_cmd.is_some());\n-    let pandoc_cmd = (&config.pandoc_cmd).get();\n+    let pandoc_cmd = copy *config.pandoc_cmd.get_ref();\n     let filename = make_local_filename(config, page);\n \n     let pandoc_args = ~[\n@@ -136,15 +136,15 @@ fn generic_writer(process: ~fn(markdown: ~str)) -> Writer {\n }\n \n pub fn make_local_filename(\n-    config: config::Config,\n+    config: &config::Config,\n     page: doc::Page\n ) -> Path {\n-    let filename = make_filename(copy config, page);\n+    let filename = make_filename(config, page);\n     config.output_dir.push_rel(&filename)\n }\n \n pub fn make_filename(\n-    config: config::Config,\n+    config: &config::Config,\n     page: doc::Page\n ) -> Path {\n     let filename = {\n@@ -247,7 +247,7 @@ mod test {\n         };\n         let doc = mk_doc(~\"test\", ~\"\");\n         let page = doc::CratePage(doc.CrateDoc());\n-        let filename = make_local_filename(config, page);\n+        let filename = make_local_filename(&config, page);\n         assert_eq!(filename.to_str(), ~\"output/dir/test.md\");\n     }\n \n@@ -261,7 +261,7 @@ mod test {\n         };\n         let doc = mk_doc(~\"\", ~\"\");\n         let page = doc::CratePage(doc.CrateDoc());\n-        let filename = make_local_filename(config, page);\n+        let filename = make_local_filename(&config, page);\n         assert_eq!(filename.to_str(), ~\"output/dir/index.html\");\n     }\n \n@@ -276,7 +276,7 @@ mod test {\n         let doc = mk_doc(~\"\", ~\"mod a { mod b { } }\");\n         let modb = copy doc.cratemod().mods()[0].mods()[0];\n         let page = doc::ItemPage(doc::ModTag(modb));\n-        let filename = make_local_filename(config, page);\n+        let filename = make_local_filename(&config, page);\n         assert_eq!(filename, Path(\"output/dir/a_b.html\"));\n     }\n }"}, {"sha": "ed069b5ed56033bd9c0bc751ad3df7fcfe6a0766", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -113,7 +113,7 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n         match parse_header(copy *line) {\n           Some(header) => {\n             if current_section.is_some() {\n-                sections += [(&current_section).get()];\n+                sections += [copy *current_section.get_ref()];\n             }\n             current_section = Some(doc::Section {\n                 header: header,"}, {"sha": "716784c51c513db9cec00664094ac254ad28b539", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -434,14 +434,14 @@ mod test {\n     #[test]\n     fn should_add_struct_defs() {\n         let doc = mk_doc(~\"struct S { field: () }\");\n-        assert!((&doc.cratemod().structs()[0].sig).get().contains(\n+        assert!(doc.cratemod().structs()[0].sig.get().contains(\n             \"struct S {\"));\n     }\n \n     #[test]\n     fn should_not_serialize_struct_attrs() {\n         // All we care about are the fields\n         let doc = mk_doc(~\"#[wut] struct S { field: () }\");\n-        assert!(!(&doc.cratemod().structs()[0].sig).get().contains(\"wut\"));\n+        assert!(!doc.cratemod().structs()[0].sig.get().contains(\"wut\"));\n     }\n }"}, {"sha": "ba56d544880683ddfd54abb1bb19eb59089532ba", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -527,36 +527,31 @@ pub fn is_item_impl(item: @ast::item) -> bool {\n     }\n }\n \n-pub fn walk_pat(pat: @pat, it: &fn(@pat)) {\n-    it(pat);\n+pub fn walk_pat(pat: @pat, it: &fn(@pat) -> bool) -> bool {\n+    if !it(pat) {\n+        return false;\n+    }\n+\n     match pat.node {\n         pat_ident(_, _, Some(p)) => walk_pat(p, it),\n         pat_struct(_, ref fields, _) => {\n-            for fields.each |f| {\n-                walk_pat(f.pat, it)\n-            }\n+            fields.each(|f| walk_pat(f.pat, it))\n         }\n         pat_enum(_, Some(ref s)) | pat_tup(ref s) => {\n-            for s.each |p| {\n-                walk_pat(*p, it)\n-            }\n+            s.each(|&p| walk_pat(p, it))\n         }\n         pat_box(s) | pat_uniq(s) | pat_region(s) => {\n             walk_pat(s, it)\n         }\n         pat_vec(ref before, ref slice, ref after) => {\n-            for before.each |p| {\n-                walk_pat(*p, it)\n-            }\n-            for slice.each |p| {\n-                walk_pat(*p, it)\n-            }\n-            for after.each |p| {\n-                walk_pat(*p, it)\n-            }\n+            before.each(|&p| walk_pat(p, it)) &&\n+                slice.each(|&p| walk_pat(p, it)) &&\n+                after.each(|&p| walk_pat(p, it))\n         }\n         pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _, _) |\n-        pat_enum(_, _) => { }\n+        pat_enum(_, _) => {\n+            true\n+        }\n     }\n }\n "}, {"sha": "0efde1df6c22be30d0a18cccad62a9f85ba916f8", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -7,8 +7,7 @@ fn main() {\n     //~^ ERROR cannot move `foo`\n \n     let bar = ~3;\n-    let _g = || {\n+    let _g = || { //~ ERROR capture of moved value\n         let _h: @fn() -> int = || *bar;\n-        //~^ ERROR illegal by-move capture\n     };\n }"}, {"sha": "dec976e0a6068007ca2cfae60cff80420acc5964", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -0,0 +1,31 @@\n+// Test that we do not permit moves from &[] matched by a vec pattern.\n+\n+struct Foo {\n+    string: ~str\n+}\n+\n+pub fn main() {\n+    let x = [\n+        Foo { string: ~\"foo\" },\n+        Foo { string: ~\"bar\" },\n+        Foo { string: ~\"baz\" }\n+    ];\n+    match x {\n+        [first, ..tail] => {\n+            match tail {\n+                [Foo { string: a }, Foo { string: b }] => {\n+                    //~^ ERROR cannot move out of dereference of & pointer\n+                    //~^^ ERROR cannot move out of dereference of & pointer\n+                }\n+                _ => {\n+                    ::std::util::unreachable();\n+                }\n+            }\n+            let z = copy tail[0];\n+            debug!(fmt!(\"%?\", z));\n+        }\n+        _ => {\n+            ::std::util::unreachable();\n+        }\n+    }\n+}"}, {"sha": "a67a12f9d0f7337bd7b00f366d36e85eb55d5d15", "filename": "src/test/compile-fail/borrowck-unary-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -10,7 +10,7 @@\n \n fn foo(x: ~int) -> int {\n     let y = &*x;\n-    free(x); //~ ERROR cannot move out of `*x` because it is borrowed\n+    free(x); //~ ERROR cannot move out of `x` because it is borrowed\n     *y\n }\n "}, {"sha": "dc42e28ec2523d5708f67bf8f965c6902d741825", "filename": "src/test/compile-fail/by-move-pattern-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     let s = S { x: Bar(~\"hello\") };\n     match &s.x {\n         &Foo => {}\n-        &Bar(identifier) => f(copy identifier)  //~ ERROR by-move pattern bindings may not occur\n+        &Bar(identifier) => f(copy identifier)  //~ ERROR cannot move\n     };\n     match &s.x {\n         &Foo => {}"}, {"sha": "478a56c03010aa4a909aa70bf442648886e5033f", "filename": "src/test/compile-fail/disallowed-deconstructing-destructing-struct-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -23,6 +23,6 @@ fn main() {\n \n     match x {\n         X { x: y } => error!(\"contents: %s\", y)\n-        //~^ ERROR cannot bind by-move within struct\n+        //~^ ERROR cannot move out of type `X`, which defines the `Drop` trait\n     }\n }"}, {"sha": "92f2e5ea689c182d6f9e13871ae0b8770f6cea2c", "filename": "src/test/compile-fail/issue-2590.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -18,7 +18,7 @@ trait parse {\n \n impl parse for parser {\n     fn parse(&self) -> ~[int] {\n-        self.tokens //~ ERROR cannot move out of field\n+        self.tokens //~ ERROR cannot move out of dereference of & pointer\n     }\n }\n "}, {"sha": "6fe59f0ca52d1776917e635631855bf0b1aa66bd", "filename": "src/test/compile-fail/liveness-move-in-loop.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -16,10 +16,7 @@ fn main() {\n         loop {\n             loop {\n                 loop {\n-// tjc: Not sure why it prints the same error twice\n                     x = y; //~ ERROR use of moved value\n-                    //~^ ERROR use of moved value\n-\n                     copy x;\n                 }\n             }"}, {"sha": "26e82dd3673431349b9de60ecf86ba1600740dfb", "filename": "src/test/compile-fail/liveness-move-in-while.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -13,10 +13,8 @@ fn main() {\n     let y: ~int = ~42;\n     let mut x: ~int;\n     loop {\n-        debug!(y);\n-// tjc: not sure why it prints the same error twice\n+        debug!(y); //~ ERROR use of moved value: `y`\n         while true { while true { while true { x = y; copy x; } } }\n         //~^ ERROR use of moved value: `y`\n-        //~^^ ERROR use of moved value: `y`\n     }\n }"}, {"sha": "1a2beedff9306e9684f7b2142a714f8641e5553a", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -7,13 +7,13 @@ fn touch<A>(_a: &A) {}\n \n fn f10() {\n     let x = Foo { f: ~\"hi\", y: 3 };\n-    consume(x.f); //~ NOTE field of `x` moved here\n+    consume(x.f); //~ NOTE `x.f` moved here\n     touch(&x.y); //~ ERROR use of partially moved value: `x`\n }\n \n fn f20() {\n     let x = ~[~\"hi\"];\n-    consume(x[0]); //~ NOTE element of `x` moved here\n+    consume(x[0]); //~ NOTE `(*x)[]` moved here\n     touch(&x[0]); //~ ERROR use of partially moved value: `x`\n }\n "}, {"sha": "ca58097b555e1d5a777939af64a1904d5774a2f1", "filename": "src/test/compile-fail/moves-based-on-type-block-bad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -16,9 +16,9 @@ fn main() {\n     let s = S { x: ~Bar(~42) };\n     loop {\n         do f(&s) |hellothere| {\n-            match hellothere.x {    //~ ERROR cannot move out\n+            match hellothere.x {\n                 ~Foo(_) => {}\n-                ~Bar(x) => io::println(x.to_str()),\n+                ~Bar(x) => io::println(x.to_str()), //~ ERROR cannot move out\n                 ~Baz => {}\n             }\n         }"}, {"sha": "40ee37fae78a82d434be6c582805ccdc1bfc6a75", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -86,7 +86,7 @@ fn f110() {\n }\n \n fn f120() {\n-    let x = ~[~\"hi\", ~\"ho\"];\n+    let mut x = ~[~\"hi\", ~\"ho\"];\n     vec::swap(x, 0, 1);\n     touch(&x[0]);\n     touch(&x[1]);"}, {"sha": "42944a206b360bb5d4bc2d6265dd7e766ec8fc2d", "filename": "src/test/compile-fail/moves-based-on-type-match-bindings.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -0,0 +1,19 @@\n+// Tests that bindings to move-by-default values trigger moves of the\n+// discriminant. Also tests that the compiler explains the move in\n+// terms of the binding, not the discriminant.\n+\n+struct Foo<A> { f: A }\n+fn guard(_s: ~str) -> bool {fail!()}\n+fn touch<A>(_a: &A) {}\n+\n+fn f10() {\n+    let x = Foo {f: ~\"hi\"};\n+\n+    let y = match x {\n+        Foo {f} => {} //~ NOTE moved here\n+    };\n+\n+    touch(&x); //~ ERROR use of partially moved value: `x`\n+}\n+\n+fn main() {}"}, {"sha": "c9e5144557acceead68bd17148f5b5f338445ec7", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -15,12 +15,12 @@ fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let arc_v = arc::ARC(v);\n \n-    do task::spawn() { //~ NOTE `arc_v` moved into closure environment here\n+    do task::spawn() {\n         let v = arc_v.get();\n         assert_eq!(v[3], 4);\n     };\n \n     assert_eq!((arc_v.get())[2], 3); //~ ERROR use of moved value: `arc_v`\n \n-    info!(arc_v);\n+    info!(arc_v); //~ ERROR use of moved value: `arc_v`\n }"}, {"sha": "da8e0c9f2b697cad84ce5fa58e2b6d5e9167649f", "filename": "src/test/compile-fail/use-after-move-self-based-on-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -9,7 +9,7 @@ impl Drop for S {\n pub impl S {\n     fn foo(self) -> int {\n         self.bar();\n-        return self.x;  //~ ERROR use of partially moved value\n+        return self.x;  //~ ERROR use of moved value: `self`\n     }\n \n     fn bar(self) {}"}, {"sha": "37db40d14365eca8bfb4f9b1cc5fd301cdfae1b0", "filename": "src/test/compile-fail/use-after-move-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -5,7 +5,7 @@ struct S {\n pub impl S {\n     fn foo(self) -> int {\n         self.bar();\n-        return *self.x;  //~ ERROR use of partially moved value\n+        return *self.x;  //~ ERROR use of moved value: `self`\n     }\n \n     fn bar(self) {}"}, {"sha": "c74fd4a68e719807a438726931ea2ecdc1f7a103", "filename": "src/test/run-pass/borrowck-unary-move-2.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Frun-pass%2Fborrowck-unary-move-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Frun-pass%2Fborrowck-unary-move-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-unary-move-2.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -28,5 +28,5 @@ struct wrapper(noncopyable);\n \n fn main() {\n     let x1 = wrapper(noncopyable());\n-    let _x2 = *x1; //~ ERROR cannot move out\n+    let _x2 = *x1;\n }", "previous_filename": "src/test/compile-fail/borrowck-unary-move-2.rs"}, {"sha": "b6485348a51848cecef8be85450ef62d70645aeb", "filename": "src/test/run-pass/move-out-of-field.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -0,0 +1,23 @@\n+use std::str;\n+\n+struct StringBuffer {\n+    s: ~str\n+}\n+\n+impl StringBuffer {\n+    pub fn append(&mut self, v: &str) {\n+        str::push_str(&mut self.s, v);\n+    }\n+}\n+\n+fn to_str(sb: StringBuffer) -> ~str {\n+    sb.s\n+}\n+\n+fn main() {\n+    let mut sb = StringBuffer {s: ~\"\"};\n+    sb.append(\"Hello, \");\n+    sb.append(\"World!\");\n+    let str = to_str(sb);\n+    assert_eq!(str, ~\"Hello, World!\");\n+}\n\\ No newline at end of file"}, {"sha": "05a6dee06cc87bf582a53ae900de8c4e5ac03723", "filename": "src/test/run-pass/vec-matching-fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -4,8 +4,8 @@ fn foldl<T, U: Copy+Clone>(\n     function: &fn(partial: U, element: &T) -> U\n ) -> U {\n     match values {\n-        [head, ..tail] =>\n-            foldl(tail, function(initial, &head), function),\n+        [ref head, ..tail] =>\n+            foldl(tail, function(initial, head), function),\n         [] => initial.clone()\n     }\n }\n@@ -16,8 +16,8 @@ fn foldr<T, U: Copy+Clone>(\n     function: &fn(element: &T, partial: U) -> U\n ) -> U {\n     match values {\n-        [..head, tail] =>\n-            foldr(head, function(&tail, initial), function),\n+        [..head, ref tail] =>\n+            foldr(head, function(tail, initial), function),\n         [] => initial.clone()\n     }\n }"}, {"sha": "6e1a47ad2dfd38c21f9b734ced837235f08daa8b", "filename": "src/test/run-pass/vec-tail-matching.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5851d3242cce2a53fc25df21ab5ad20dc1fd6a62/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs?ref=5851d3242cce2a53fc25df21ab5ad20dc1fd6a62", "patch": "@@ -19,9 +19,9 @@ pub fn main() {\n                 [Foo { _ }, _, Foo { _ }, ..tail] => {\n                     ::std::util::unreachable();\n                 }\n-                [Foo { string: a }, Foo { string: b }] => {\n-                    assert_eq!(a, ~\"bar\");\n-                    assert_eq!(b, ~\"baz\");\n+                [Foo { string: ref a }, Foo { string: ref b }] => {\n+                    assert_eq!(\"bar\", a.slice(0, a.len()));\n+                    assert_eq!(\"baz\", b.slice(0, b.len()));\n                 }\n                 _ => {\n                     ::std::util::unreachable();"}]}