{"sha": "f7a7092d691aea5c254412d9fd4b3f76a355f11f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3YTcwOTJkNjkxYWVhNWMyNTQ0MTJkOWZkNGIzZjc2YTM1NWYxMWY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-12T12:26:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-12T12:26:40Z"}, "message": "Merge #2712\n\n2712: Supporting extend selection inside macro calls r=edwin0cheng a=edwin0cheng\n\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "3859596dbf00aad31e4487072ba9ed73a149e60b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3859596dbf00aad31e4487072ba9ed73a149e60b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7a7092d691aea5c254412d9fd4b3f76a355f11f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeGxCACRBK7hj4Ov3rIwAAdHIIAKjUlTaaEAwzFMDhZPx/g15v\niQnDXNsgsZtVmpwBf8u8grelx9HI0QDDh0nh0dylBQKw/yV14hwih/uEzkoZiubL\nJ+ct8eEgahqcYXv7PADMNDIhdj8YXrSKF3q22Dogkx+ofGo/PMqtZBthkRdDNZU7\n4lxPWoW5MG7Hy71lYSrL0+zgwmg/9wGAenkWJFFutl10KNn8nM1tUTgfnXT3ZPpU\nm0o56m9IA4rNYCMKVmE2BQCOP6+VZxcSuWyybx0q3aIWj8nxejq5w04aujSCnkAX\n7NTf3sm5rmNWKHCnOsRIcdA0fwlWja4xMMVKDUjBi4XyKGhEHUxadqguFwGQ50s=\n=5sYM\n-----END PGP SIGNATURE-----\n", "payload": "tree 3859596dbf00aad31e4487072ba9ed73a149e60b\nparent 8bb2a50ce6adda4d3d8dfb66cd67d302ec108d45\nparent 0593da9a36667e7780b62c6e2403497e7262bafe\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1578832000 +0000\ncommitter GitHub <noreply@github.com> 1578832000 +0000\n\nMerge #2712\n\n2712: Supporting extend selection inside macro calls r=edwin0cheng a=edwin0cheng\n\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7a7092d691aea5c254412d9fd4b3f76a355f11f", "html_url": "https://github.com/rust-lang/rust/commit/f7a7092d691aea5c254412d9fd4b3f76a355f11f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7a7092d691aea5c254412d9fd4b3f76a355f11f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bb2a50ce6adda4d3d8dfb66cd67d302ec108d45", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb2a50ce6adda4d3d8dfb66cd67d302ec108d45", "html_url": "https://github.com/rust-lang/rust/commit/8bb2a50ce6adda4d3d8dfb66cd67d302ec108d45"}, {"sha": "0593da9a36667e7780b62c6e2403497e7262bafe", "url": "https://api.github.com/repos/rust-lang/rust/commits/0593da9a36667e7780b62c6e2403497e7262bafe", "html_url": "https://github.com/rust-lang/rust/commit/0593da9a36667e7780b62c6e2403497e7262bafe"}], "stats": {"total": 168, "additions": 153, "deletions": 15}, "files": [{"sha": "70b6fde82f27a899ba61d3902f8b2f864b136967", "filename": "crates/ra_ide/src/extend_selection.rs", "status": "modified", "additions": 153, "deletions": 15, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/f7a7092d691aea5c254412d9fd4b3f76a355f11f/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7a7092d691aea5c254412d9fd4b3f76a355f11f/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs?ref=f7a7092d691aea5c254412d9fd4b3f76a355f11f", "patch": "@@ -4,20 +4,27 @@ use ra_db::SourceDatabase;\n use ra_syntax::{\n     algo::find_covering_element,\n     ast::{self, AstNode, AstToken},\n-    Direction, NodeOrToken,\n+    Direction, NodeOrToken, SyntaxElement,\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxToken, TextRange, TextUnit, TokenAtOffset, T,\n };\n \n-use crate::{db::RootDatabase, FileRange};\n+use crate::{db::RootDatabase, expand::descend_into_macros, FileId, FileRange};\n+use hir::db::AstDatabase;\n+use std::iter::successors;\n \n-// FIXME: restore macro support\n pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRange {\n-    let parse = db.parse(frange.file_id);\n-    try_extend_selection(parse.tree().syntax(), frange.range).unwrap_or(frange.range)\n+    let src = db.parse(frange.file_id).tree();\n+    try_extend_selection(db, src.syntax(), frange).unwrap_or(frange.range)\n }\n \n-fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange> {\n+fn try_extend_selection(\n+    db: &RootDatabase,\n+    root: &SyntaxNode,\n+    frange: FileRange,\n+) -> Option<TextRange> {\n+    let range = frange.range;\n+\n     let string_kinds = [COMMENT, STRING, RAW_STRING, BYTE_STRING, RAW_BYTE_STRING];\n     let list_kinds = [\n         RECORD_FIELD_PAT_LIST,\n@@ -72,12 +79,21 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n         }\n         NodeOrToken::Node(node) => node,\n     };\n+\n+    // if we are in single token_tree, we maybe live in macro or attr\n+    if node.kind() == TOKEN_TREE {\n+        if let Some(macro_call) = node.ancestors().find_map(ast::MacroCall::cast) {\n+            if let Some(range) = extend_tokens_from_range(db, frange.file_id, macro_call, range) {\n+                return Some(range);\n+            }\n+        }\n+    }\n+\n     if node.text_range() != range {\n         return Some(node.text_range());\n     }\n \n-    // Using shallowest node with same range allows us to traverse siblings.\n-    let node = node.ancestors().take_while(|n| n.text_range() == node.text_range()).last().unwrap();\n+    let node = shallowest_node(&node.into()).unwrap();\n \n     if node.parent().map(|n| list_kinds.contains(&n.kind())) == Some(true) {\n         if let Some(range) = extend_list_item(&node) {\n@@ -88,6 +104,94 @@ fn try_extend_selection(root: &SyntaxNode, range: TextRange) -> Option<TextRange\n     node.parent().map(|it| it.text_range())\n }\n \n+fn extend_tokens_from_range(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    macro_call: ast::MacroCall,\n+    original_range: TextRange,\n+) -> Option<TextRange> {\n+    let src = find_covering_element(&macro_call.syntax(), original_range);\n+    let (first_token, last_token) = match src {\n+        NodeOrToken::Node(it) => (it.first_token()?, it.last_token()?),\n+        NodeOrToken::Token(it) => (it.clone(), it),\n+    };\n+\n+    let mut first_token = skip_whitespace(first_token, Direction::Next)?;\n+    let mut last_token = skip_whitespace(last_token, Direction::Prev)?;\n+\n+    while !first_token.text_range().is_subrange(&original_range) {\n+        first_token = skip_whitespace(first_token.next_token()?, Direction::Next)?;\n+    }\n+    while !last_token.text_range().is_subrange(&original_range) {\n+        last_token = skip_whitespace(last_token.prev_token()?, Direction::Prev)?;\n+    }\n+\n+    // compute original mapped token range\n+    let expanded = {\n+        let first_node = descend_into_macros(db, file_id, first_token.clone());\n+        let first_node = first_node.map(|it| it.text_range());\n+\n+        let last_node = descend_into_macros(db, file_id, last_token.clone());\n+        if last_node.file_id == file_id.into() || first_node.file_id != last_node.file_id {\n+            return None;\n+        }\n+        first_node.map(|it| union_range(it, last_node.value.text_range()))\n+    };\n+\n+    // Compute parent node range\n+    let src = db.parse_or_expand(expanded.file_id)?;\n+    let parent = shallowest_node(&find_covering_element(&src, expanded.value))?.parent()?;\n+\n+    let validate = |token: SyntaxToken| {\n+        let node = descend_into_macros(db, file_id, token.clone());\n+        if node.file_id == expanded.file_id\n+            && node.value.text_range().is_subrange(&parent.text_range())\n+        {\n+            Some(token)\n+        } else {\n+            None\n+        }\n+    };\n+\n+    // Find the first and last text range under expanded parent\n+    let first = successors(Some(first_token), |token| {\n+        validate(skip_whitespace(token.prev_token()?, Direction::Prev)?)\n+    })\n+    .last()?;\n+    let last = successors(Some(last_token), |token| {\n+        validate(skip_whitespace(token.next_token()?, Direction::Next)?)\n+    })\n+    .last()?;\n+\n+    let range = union_range(first.text_range(), last.text_range());\n+    if original_range.is_subrange(&range) && original_range != range {\n+        Some(range)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn skip_whitespace(mut token: SyntaxToken, direction: Direction) -> Option<SyntaxToken> {\n+    while token.kind() == WHITESPACE {\n+        token = match direction {\n+            Direction::Next => token.next_token()?,\n+            Direction::Prev => token.prev_token()?,\n+        }\n+    }\n+    Some(token)\n+}\n+\n+fn union_range(range: TextRange, r: TextRange) -> TextRange {\n+    let start = range.start().min(r.start());\n+    let end = range.end().max(r.end());\n+    TextRange::from_to(start, end)\n+}\n+\n+/// Find the shallowest node with same range, which allows us to traverse siblings.\n+fn shallowest_node(node: &SyntaxElement) -> Option<SyntaxNode> {\n+    node.ancestors().take_while(|n| n.text_range() == node.text_range()).last()\n+}\n+\n fn extend_single_word_in_comment_or_string(\n     leaf: &SyntaxToken,\n     offset: TextUnit,\n@@ -227,18 +331,19 @@ fn adj_comments(comment: &ast::Comment, dir: Direction) -> ast::Comment {\n \n #[cfg(test)]\n mod tests {\n-    use ra_syntax::{AstNode, SourceFile};\n-    use test_utils::extract_offset;\n-\n     use super::*;\n+    use crate::mock_analysis::single_file;\n+    use test_utils::extract_offset;\n \n     fn do_check(before: &str, afters: &[&str]) {\n         let (cursor, before) = extract_offset(before);\n-        let parse = SourceFile::parse(&before);\n-        let mut range = TextRange::offset_len(cursor, 0.into());\n+        let (analysis, file_id) = single_file(&before);\n+        let range = TextRange::offset_len(cursor, 0.into());\n+        let mut frange = FileRange { file_id: file_id, range };\n+\n         for &after in afters {\n-            range = try_extend_selection(parse.tree().syntax(), range).unwrap();\n-            let actual = &before[range];\n+            frange.range = analysis.extend_selection(frange).unwrap();\n+            let actual = &before[frange.range];\n             assert_eq!(after, actual);\n         }\n     }\n@@ -503,4 +608,37 @@ fn main() { let var = (\n             ],\n         );\n     }\n+\n+    #[test]\n+    fn extend_selection_inside_macros() {\n+        do_check(\n+            r#\"macro_rules! foo { ($item:item) => {$item} }\n+                foo!{fn hello(na<|>me:usize){}}\"#,\n+            &[\n+                \"name\",\n+                \"name:usize\",\n+                \"(name:usize)\",\n+                \"fn hello(name:usize){}\",\n+                \"{fn hello(name:usize){}}\",\n+                \"foo!{fn hello(name:usize){}}\",\n+            ],\n+        );\n+    }\n+\n+    #[test]\n+    fn extend_selection_inside_recur_macros() {\n+        do_check(\n+            r#\" macro_rules! foo2 { ($item:item) => {$item} }\n+                macro_rules! foo { ($item:item) => {foo2!($item);} }\n+                foo!{fn hello(na<|>me:usize){}}\"#,\n+            &[\n+                \"name\",\n+                \"name:usize\",\n+                \"(name:usize)\",\n+                \"fn hello(name:usize){}\",\n+                \"{fn hello(name:usize){}}\",\n+                \"foo!{fn hello(name:usize){}}\",\n+            ],\n+        );\n+    }\n }"}]}