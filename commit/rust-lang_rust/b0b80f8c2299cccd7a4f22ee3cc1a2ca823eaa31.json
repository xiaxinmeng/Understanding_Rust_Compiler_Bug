{"sha": "b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYjgwZjhjMjI5OWNjY2Q3YTRmMjJlZTNjYzFhMmNhODIzZWFhMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-26T14:14:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-26T14:14:15Z"}, "message": "Auto merge of #45380 - dotdash:arg_copies, r=arielb1\n\nAvoid unnecessary copies of arguments that are simple bindings\n\nInitially MIR differentiated between arguments and locals, which\nintroduced a need to add extra copies assigning the argument to a\nlocal, even for simple bindings. This differentiation no longer exists,\nbut we're still creating those copies, bloating the MIR and LLVM IR we\nemit.\n\nAdditionally, the current approach means that we create debug info for\nboth the incoming argument (marking it as an argument), and then\nimmediately shadow it a local that goes by the same name. This can be\nconfusing when using e.g. \"info args\" in gdb, or when e.g. a debugger\nwith a GUI displays the function arguments separately from the local\nvariables, especially when the binding is mutable, because the argument\ndoesn't change, while the local variable does.", "tree": {"sha": "011c1b2fa731579f0a7079e3415f1e08d35c06bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/011c1b2fa731579f0a7079e3415f1e08d35c06bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "html_url": "https://github.com/rust-lang/rust/commit/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0febe71449008fd35ccc762b0a42d106aa8e4f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0febe71449008fd35ccc762b0a42d106aa8e4f7", "html_url": "https://github.com/rust-lang/rust/commit/e0febe71449008fd35ccc762b0a42d106aa8e4f7"}, {"sha": "8ad7c284d793250edffe0e85f6cc898585496283", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ad7c284d793250edffe0e85f6cc898585496283", "html_url": "https://github.com/rust-lang/rust/commit/8ad7c284d793250edffe0e85f6cc898585496283"}], "stats": {"total": 267, "additions": 145, "deletions": 122}, "files": [{"sha": "f5a3c1989cf839cd43e7e494fce9a09967575195", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -650,7 +650,9 @@ pub enum TerminatorKind<'tcx> {\n     Call {\n         /// The function that\u2019s being called\n         func: Operand<'tcx>,\n-        /// Arguments the function is called with\n+        /// Arguments the function is called with. These are owned by the callee, which is free to\n+        /// modify them. This is important as \"by-value\" arguments might be passed by-reference at\n+        /// the ABI level.\n         args: Vec<Operand<'tcx>>,\n         /// Destination for the return value. If some, the call is converging.\n         destination: Option<(Lvalue<'tcx>, BasicBlock)>,"}, {"sha": "280e1c81966361b347f6f6044b7dc31e2c598b37", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -247,7 +247,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 } else {\n                     let args: Vec<_> =\n                         args.into_iter()\n-                            .map(|arg| unpack!(block = this.as_local_operand(block, arg)))\n+                            .map(|arg| {\n+                                let scope = this.local_scope();\n+                                // Function arguments are owned by the callee, so we need as_temp()\n+                                // instead of as_operand() to enforce copies\n+                                let operand = unpack!(block = this.as_temp(block, scope, arg));\n+                                Operand::Consume(Lvalue::Local(operand))\n+                            })\n                             .collect();\n \n                     let success = this.cfg.start_new_block();"}, {"sha": "b2f0ff57b62d6bfb18df24eacd972ae9c28011d3", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -21,6 +21,7 @@ use rustc::mir::visit::{MutVisitor, Lookup};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeMap;\n+use rustc_const_eval::pattern::{BindingMode, PatternKind};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use shim;\n use std::mem;\n@@ -571,13 +572,24 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // Bind the argument patterns\n         for (index, &(ty, pattern)) in arguments.iter().enumerate() {\n             // Function arguments always get the first Local indices after the return pointer\n-            let lvalue = Lvalue::Local(Local::new(index + 1));\n+            let local = Local::new(index + 1);\n+            let lvalue = Lvalue::Local(local);\n \n             if let Some(pattern) = pattern {\n                 let pattern = self.hir.pattern_from_hir(pattern);\n-                scope = self.declare_bindings(scope, ast_body.span,\n-                                              LintLevel::Inherited, &pattern);\n-                unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n+\n+                match *pattern.kind {\n+                    // Don't introduce extra copies for simple bindings\n+                    PatternKind::Binding { mutability, var, mode: BindingMode::ByValue, .. } => {\n+                        self.local_decls[local].mutability = mutability;\n+                        self.var_indices.insert(var, local);\n+                    }\n+                    _ => {\n+                        scope = self.declare_bindings(scope, ast_body.span,\n+                                                      LintLevel::Inherited, &pattern);\n+                        unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n+                    }\n+                }\n             }\n \n             // Make sure we drop (parts of) the argument even when not matched on."}, {"sha": "b366d5579c3d108cc6f3c70d45e038c5ce4cd5b8", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -112,6 +112,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn set_value_name(&self, value: ValueRef, name: &str) {\n+        let cname = CString::new(name.as_bytes()).unwrap();\n+        unsafe {\n+            llvm::LLVMSetValueName(value, cname.as_ptr());\n+        }\n+    }\n+\n     pub fn position_before(&self, insn: ValueRef) {\n         unsafe {\n             llvm::LLVMPositionBuilderBefore(self.llbuilder, insn);"}, {"sha": "00815be278ee0e845c14caacb1199e68078e101e", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -64,11 +64,18 @@ struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a> {\n \n impl<'mir, 'a, 'tcx> LocalAnalyzer<'mir, 'a, 'tcx> {\n     fn new(mircx: &'mir MirContext<'a, 'tcx>) -> LocalAnalyzer<'mir, 'a, 'tcx> {\n-        LocalAnalyzer {\n+        let mut analyzer = LocalAnalyzer {\n             cx: mircx,\n             lvalue_locals: BitVector::new(mircx.mir.local_decls.len()),\n             seen_assigned: BitVector::new(mircx.mir.local_decls.len())\n+        };\n+\n+        // Arguments get assigned to by means of the function being called\n+        for idx in 0..mircx.mir.arg_count {\n+            analyzer.seen_assigned.insert(idx + 1);\n         }\n+\n+        analyzer\n     }\n \n     fn mark_as_lvalue(&mut self, local: mir::Local) {"}, {"sha": "59da80035fd36eb6eb13bdd63ba33b6be9dce030", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -386,6 +386,12 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         let arg_decl = &mir.local_decls[local];\n         let arg_ty = mircx.monomorphize(&arg_decl.ty);\n \n+        let name = if let Some(name) = arg_decl.name {\n+            name.as_str().to_string()\n+        } else {\n+            format!(\"arg{}\", arg_index)\n+        };\n+\n         if Some(local) == mir.spread_arg {\n             // This argument (e.g. the last argument in the \"rust-call\" ABI)\n             // is a tuple that was spread at the ABI level and now we have\n@@ -397,7 +403,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let lvalue = LvalueRef::alloca(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+            let lvalue = LvalueRef::alloca(bcx, arg_ty, &name);\n             for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n                 let (dst, _) = lvalue.trans_field_ptr(bcx, i);\n                 let arg = &mircx.fn_ty.args[idx];\n@@ -444,6 +450,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 llarg_idx += 1;\n             }\n             let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+            bcx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n             llarg\n         } else if !lvalue_locals.contains(local.index()) &&\n@@ -481,10 +488,13 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 let meta_llty = type_of::unsized_info_ty(bcx.ccx, pointee);\n \n                 let llarg = bcx.pointercast(llarg, data_llty.ptr_to());\n+                bcx.set_value_name(llarg, &(name.clone() + \".ptr\"));\n                 let llmeta = bcx.pointercast(llmeta, meta_llty);\n+                bcx.set_value_name(llmeta, &(name + \".meta\"));\n \n                 OperandValue::Pair(llarg, llmeta)\n             } else {\n+                bcx.set_value_name(llarg, &name);\n                 OperandValue::Immediate(llarg)\n             };\n             let operand = OperandRef {\n@@ -493,7 +503,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             };\n             return LocalRef::Operand(Some(operand.unpack_if_pair(bcx)));\n         } else {\n-            let lltemp = LvalueRef::alloca(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+            let lltemp = LvalueRef::alloca(bcx, arg_ty, &name);\n             if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n                 // we pass fat pointers as two words, but we want to\n                 // represent them internally as a pointer to two words,"}, {"sha": "bd85e303143485915a7531378f64ee2f8decbd6b", "filename": "src/test/codegen/adjustments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fcodegen%2Fadjustments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fcodegen%2Fadjustments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fadjustments.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -13,7 +13,7 @@\n #![crate_type = \"lib\"]\n \n // Hack to get the correct size for the length part in slices\n-// CHECK: @helper([[USIZE:i[0-9]+]])\n+// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n #[no_mangle]\n fn helper(_: usize) {\n }\n@@ -23,9 +23,9 @@ fn helper(_: usize) {\n pub fn no_op_slice_adjustment(x: &[u8]) -> &[u8] {\n     // We used to generate an extra alloca and memcpy for the block's trailing expression value, so\n     // check that we copy directly to the return value slot\n-// CHECK: %2 = insertvalue { i8*, [[USIZE]] } undef, i8* %0, 0\n-// CHECK: %3 = insertvalue { i8*, [[USIZE]] } %2, [[USIZE]] %1, 1\n-// CHECK: ret { i8*, [[USIZE]] } %3\n+// CHECK: %0 = insertvalue { i8*, [[USIZE]] } undef, i8* %x.ptr, 0\n+// CHECK: %1 = insertvalue { i8*, [[USIZE]] } %0, [[USIZE]] %x.meta, 1\n+// CHECK: ret { i8*, [[USIZE]] } %1\n     { x }\n }\n "}, {"sha": "ba81e2d6046e8932503b41b0101cb9698a9048fa", "filename": "src/test/codegen/align-struct.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fcodegen%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fcodegen%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falign-struct.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -42,7 +42,6 @@ pub fn align64(i : i32) -> Align64 {\n #[no_mangle]\n pub fn nested64(a: Align64, b: i32, c: i32, d: i8) -> Nested64 {\n // CHECK: %n64 = alloca %Nested64, align 64\n-// CHECK: %a = alloca %Align64, align 64\n     let n64 = Nested64 { a, b, c, d };\n     n64\n }\n@@ -51,7 +50,6 @@ pub fn nested64(a: Align64, b: i32, c: i32, d: i8) -> Nested64 {\n #[no_mangle]\n pub fn enum64(a: Align64) -> Enum64 {\n // CHECK: %e64 = alloca %Enum64, align 64\n-// CHECK: %a = alloca %Align64, align 64\n     let e64 = Enum64::A(a);\n     e64\n }"}, {"sha": "cc13d4a7b68d29572ff0bba14c99fdf6b63909b9", "filename": "src/test/codegen/fastcall-inreg.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -60,27 +60,27 @@\n #![crate_type = \"lib\"]\n \n mod tests {\n-    // CHECK: @f1(i32 inreg, i32 inreg, i32)\n+    // CHECK: @f1(i32 inreg %arg0, i32 inreg %arg1, i32 %arg2)\n     #[no_mangle]\n     extern \"fastcall\" fn f1(_: i32, _: i32, _: i32) {}\n \n-    // CHECK: @f2(i32* inreg, i32* inreg, i32*)\n+    // CHECK: @f2(i32* inreg %arg0, i32* inreg %arg1, i32* %arg2)\n     #[no_mangle]\n     extern \"fastcall\" fn f2(_: *const i32, _: *const i32, _: *const i32) {}\n \n-    // CHECK: @f3(float, i32 inreg, i32 inreg, i32)\n+    // CHECK: @f3(float %arg0, i32 inreg %arg1, i32 inreg %arg2, i32 %arg3)\n     #[no_mangle]\n     extern \"fastcall\" fn f3(_: f32, _: i32, _: i32, _: i32) {}\n \n-    // CHECK: @f4(i32 inreg, float, i32 inreg, i32)\n+    // CHECK: @f4(i32 inreg %arg0, float %arg1, i32 inreg %arg2, i32 %arg3)\n     #[no_mangle]\n     extern \"fastcall\" fn f4(_: i32, _: f32, _: i32, _: i32) {}\n \n-    // CHECK: @f5(i64, i32)\n+    // CHECK: @f5(i64 %arg0, i32 %arg1)\n     #[no_mangle]\n     extern \"fastcall\" fn f5(_: i64, _: i32) {}\n \n-    // CHECK: @f6(i1 inreg zeroext, i32 inreg, i32)\n+    // CHECK: @f6(i1 inreg zeroext %arg0, i32 inreg %arg1, i32 %arg2)\n     #[no_mangle]\n     extern \"fastcall\" fn f6(_: bool, _: i32, _: i32) {}\n }"}, {"sha": "d4c7fe9e80a1c7d1be448240fecd376c551ab1cf", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -21,62 +21,62 @@ pub struct UnsafeInner {\n   _field: std::cell::UnsafeCell<i16>,\n }\n \n-// CHECK: zeroext i1 @boolean(i1 zeroext)\n+// CHECK: zeroext i1 @boolean(i1 zeroext %x)\n #[no_mangle]\n pub fn boolean(x: bool) -> bool {\n   x\n }\n \n-// CHECK: @readonly_borrow(i32* noalias readonly dereferenceable(4))\n+// CHECK: @readonly_borrow(i32* noalias readonly dereferenceable(4) %arg0)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn readonly_borrow(_: &i32) {\n }\n \n-// CHECK: @static_borrow(i32* noalias readonly dereferenceable(4))\n+// CHECK: @static_borrow(i32* noalias readonly dereferenceable(4) %arg0)\n // static borrow may be captured\n #[no_mangle]\n pub fn static_borrow(_: &'static i32) {\n }\n \n-// CHECK: @named_borrow(i32* noalias readonly dereferenceable(4))\n+// CHECK: @named_borrow(i32* noalias readonly dereferenceable(4) %arg0)\n // borrow with named lifetime may be captured\n #[no_mangle]\n pub fn named_borrow<'r>(_: &'r i32) {\n }\n \n-// CHECK: @unsafe_borrow(%UnsafeInner* dereferenceable(2))\n+// CHECK: @unsafe_borrow(%UnsafeInner* dereferenceable(2) %arg0)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_borrow(_: &UnsafeInner) {\n }\n \n-// CHECK: @mutable_unsafe_borrow(%UnsafeInner* dereferenceable(2))\n+// CHECK: @mutable_unsafe_borrow(%UnsafeInner* dereferenceable(2) %arg0)\n // ... unless this is a mutable borrow, those never alias\n // ... except that there's this LLVM bug that forces us to not use noalias, see #29485\n #[no_mangle]\n pub fn mutable_unsafe_borrow(_: &mut UnsafeInner) {\n }\n \n-// CHECK: @mutable_borrow(i32* dereferenceable(4))\n+// CHECK: @mutable_borrow(i32* dereferenceable(4) %arg0)\n // FIXME #25759 This should also have `nocapture`\n // ... there's this LLVM bug that forces us to not use noalias, see #29485\n #[no_mangle]\n pub fn mutable_borrow(_: &mut i32) {\n }\n \n-// CHECK: @indirect_struct(%S* noalias nocapture dereferenceable(32))\n+// CHECK: @indirect_struct(%S* noalias nocapture dereferenceable(32) %arg0)\n #[no_mangle]\n pub fn indirect_struct(_: S) {\n }\n \n-// CHECK: @borrowed_struct(%S* noalias readonly dereferenceable(32))\n+// CHECK: @borrowed_struct(%S* noalias readonly dereferenceable(32) %arg0)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn borrowed_struct(_: &S) {\n }\n \n-// CHECK: noalias dereferenceable(4) i32* @_box(i32* noalias dereferenceable(4))\n+// CHECK: noalias dereferenceable(4) i32* @_box(i32* noalias dereferenceable(4) %x)\n #[no_mangle]\n pub fn _box(x: Box<i32>) -> Box<i32> {\n   x\n@@ -91,31 +91,31 @@ pub fn struct_return() -> S {\n }\n \n // Hack to get the correct size for the length part in slices\n-// CHECK: @helper([[USIZE:i[0-9]+]])\n+// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n #[no_mangle]\n fn helper(_: usize) {\n }\n \n-// CHECK: @slice(i8* noalias nonnull readonly, [[USIZE]])\n+// CHECK: @slice(i8* noalias nonnull readonly %arg0.ptr, [[USIZE]] %arg0.meta)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n fn slice(_: &[u8]) {\n }\n \n-// CHECK: @mutable_slice(i8* nonnull, [[USIZE]])\n+// CHECK: @mutable_slice(i8* nonnull %arg0.ptr, [[USIZE]] %arg0.meta)\n // FIXME #25759 This should also have `nocapture`\n // ... there's this LLVM bug that forces us to not use noalias, see #29485\n #[no_mangle]\n fn mutable_slice(_: &mut [u8]) {\n }\n \n-// CHECK: @unsafe_slice(%UnsafeInner* nonnull, [[USIZE]])\n+// CHECK: @unsafe_slice(%UnsafeInner* nonnull %arg0.ptr, [[USIZE]] %arg0.meta)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_slice(_: &[UnsafeInner]) {\n }\n \n-// CHECK: @str(i8* noalias nonnull readonly, [[USIZE]])\n+// CHECK: @str(i8* noalias nonnull readonly %arg0.ptr, [[USIZE]] %arg0.meta)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n fn str(_: &[u8]) {\n@@ -132,7 +132,7 @@ fn trait_borrow(_: &Drop) {\n fn trait_box(_: Box<Drop>) {\n }\n \n-// CHECK: { i16*, [[USIZE]] } @return_slice(i16* noalias nonnull readonly, [[USIZE]])\n+// CHECK: { i16*, [[USIZE]] } @return_slice(i16* noalias nonnull readonly %x.ptr, [[USIZE]] %x.meta)\n #[no_mangle]\n fn return_slice(x: &[u16]) -> &[u16] {\n   x"}, {"sha": "e2371d614876253a71a5809e4c67c8b9fb391cfb", "filename": "src/test/codegen/move-val-init.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fcodegen%2Fmove-val-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fcodegen%2Fmove-val-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmove-val-init.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -24,6 +24,6 @@ pub struct Big {\n // CHECK-LABEL: @test_mvi\n #[no_mangle]\n pub unsafe fn test_mvi(target: *mut Big, make_big: fn() -> Big) {\n-    // CHECK: call void %1(%Big*{{[^%]*}} %0)\n+    // CHECK: call void %make_big(%Big*{{[^%]*}} %target)\n     move_val_init(target, make_big());\n }"}, {"sha": "fd1a14020d8102188522ce16f706feed7038d7d1", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -13,7 +13,7 @@\n #![crate_type = \"lib\"]\n \n // Hack to get the correct size for the length part in slices\n-// CHECK: @helper([[USIZE:i[0-9]+]])\n+// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n #[no_mangle]\n fn helper(_: usize) {\n }\n@@ -24,9 +24,9 @@ pub fn ref_dst(s: &[u8]) {\n     // We used to generate an extra alloca and memcpy to ref the dst, so check that we copy\n     // directly to the alloca for \"x\"\n // CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %x, i32 0, i32 0\n-// CHECK: store i8* %0, i8** [[X0]]\n+// CHECK: store i8* %s.ptr, i8** [[X0]]\n // CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %x, i32 0, i32 1\n-// CHECK: store [[USIZE]] %1, [[USIZE]]* [[X1]]\n+// CHECK: store [[USIZE]] %s.meta, [[USIZE]]* [[X1]]\n \n     let x = &*s;\n     &x; // keep variable in an alloca"}, {"sha": "08f5038fb186e466598d07bf01ab759b7ca5c61a", "filename": "src/test/codegen/stores.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fcodegen%2Fstores.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fcodegen%2Fstores.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstores.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -25,9 +25,9 @@ pub struct Bytes {\n #[no_mangle]\n pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n // CHECK: [[TMP:%.+]] = alloca i32\n-// CHECK: %arg1 = alloca [4 x i8]\n-// CHECK: store i32 %1, i32* [[TMP]]\n-// CHECK: [[Y8:%[0-9]+]] = bitcast [4 x i8]* %arg1 to i8*\n+// CHECK: %y = alloca [4 x i8]\n+// CHECK: store i32 %0, i32* [[TMP]]\n+// CHECK: [[Y8:%[0-9]+]] = bitcast [4 x i8]* %y to i8*\n // CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*\n // CHECK: call void @llvm.memcpy.{{.*}}(i8* [[Y8]], i8* [[TMP8]], i{{[0-9]+}} 4, i32 1, i1 false)\n     *x = y;\n@@ -39,9 +39,9 @@ pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n #[no_mangle]\n pub fn small_struct_alignment(x: &mut Bytes, y: Bytes) {\n // CHECK: [[TMP:%.+]] = alloca i32\n-// CHECK: %arg1 = alloca %Bytes\n-// CHECK: store i32 %1, i32* [[TMP]]\n-// CHECK: [[Y8:%[0-9]+]] = bitcast %Bytes* %arg1 to i8*\n+// CHECK: %y = alloca %Bytes\n+// CHECK: store i32 %0, i32* [[TMP]]\n+// CHECK: [[Y8:%[0-9]+]] = bitcast %Bytes* %y to i8*\n // CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*\n // CHECK: call void @llvm.memcpy.{{.*}}(i8* [[Y8]], i8* [[TMP8]], i{{[0-9]+}} 4, i32 1, i1 false)\n     *x = y;"}, {"sha": "a45e7f21023bf54564d6959a86a72927815d7661", "filename": "src/test/mir-opt/copy_propagation.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fcopy_propagation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fcopy_propagation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -19,13 +19,12 @@ fn main() { }\n // START rustc.node4.CopyPropagation.before.mir\n //  bb0: {\n //      ...\n-//      _2 = _1;\n+//      _3 = _1;\n //      ...\n-//      _4 = _2;\n-//      _3 = _4;\n+//      _2 = _3;\n //      ...\n-//      _5 = _3;\n-//      _0 = _5;\n+//      _4 = _2;\n+//      _0 = _4;\n //      ...\n //      return;\n //  }"}, {"sha": "9fe17a277a759385859727c7abf104abd1e864ee", "filename": "src/test/mir-opt/deaggregator_test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -26,8 +26,7 @@ fn main() {}\n //     ...\n //     _2 = _1;\n //     ...\n-//     _3 = _2;\n-//     _0 = Baz { x: _3, y: const 0f32, z: const false };\n+//     _0 = Baz { x: _2, y: const 0f32, z: const false };\n //     ...\n //     return;\n // }\n@@ -37,8 +36,7 @@ fn main() {}\n //     ...\n //     _2 = _1;\n //     ...\n-//     _3 = _2;\n-//     (_0.0: usize) = _3;\n+//     (_0.0: usize) = _2;\n //     (_0.1: f32) = const 0f32;\n //     (_0.2: bool) = const false;\n //     ..."}, {"sha": "d2c713b320f53134002fad58dc0303a398b4c02a", "filename": "src/test/mir-opt/deaggregator_test_enum.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -30,10 +30,7 @@ fn main() {\n // bb0: {\n //     StorageLive(_2);\n //     _2 = _1;\n-//     StorageLive(_3);\n-//     _3 = _2;\n-//     _0 = Baz::Foo { x: _3 };\n-//     StorageDead(_3);\n+//     _0 = Baz::Foo { x: _2 };\n //     StorageDead(_2);\n //     return;\n // }\n@@ -42,11 +39,8 @@ fn main() {\n // bb0: {\n //     StorageLive(_2);\n //     _2 = _1;\n-//     StorageLive(_3);\n-//     _3 = _2;\n-//     ((_0 as Foo).0: usize) = _3;\n+//     ((_0 as Foo).0: usize) = _2;\n //     discriminant(_0) = 1;\n-//     StorageDead(_3);\n //     StorageDead(_2);\n //     return;\n // }"}, {"sha": "2780f11b9e6409382910060c09663f998345e2d1", "filename": "src/test/mir-opt/deaggregator_test_enum_2.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -28,35 +28,35 @@ fn main() {}\n // END RUST SOURCE\n // START rustc.node12.Deaggregator.before.mir\n //  bb1: {\n-//      StorageLive(_6);\n-//      _6 = _4;\n-//      _0 = Foo::A(_6,);\n-//      StorageDead(_6);\n+//      StorageLive(_4);\n+//      _4 = _2;\n+//      _0 = Foo::A(_4,);\n+//      StorageDead(_4);\n //      goto -> bb3;\n //  }\n //  bb2: {\n-//      StorageLive(_7);\n-//      _7 = _4;\n-//      _0 = Foo::B(_7,);\n-//      StorageDead(_7);\n+//      StorageLive(_5);\n+//      _5 = _2;\n+//      _0 = Foo::B(_5,);\n+//      StorageDead(_5);\n //      goto -> bb3;\n //  }\n // END rustc.node12.Deaggregator.before.mir\n // START rustc.node12.Deaggregator.after.mir\n //  bb1: {\n-//      StorageLive(_6);\n-//      _6 = _4;\n-//      ((_0 as A).0: i32) = _6;\n+//      StorageLive(_4);\n+//      _4 = _2;\n+//      ((_0 as A).0: i32) = _4;\n //      discriminant(_0) = 0;\n-//      StorageDead(_6);\n+//      StorageDead(_4);\n //      goto -> bb3;\n //  }\n //  bb2: {\n-//      StorageLive(_7);\n-//      _7 = _4;\n-//      ((_0 as B).0: i32) = _7;\n+//      StorageLive(_5);\n+//      _5 = _2;\n+//      ((_0 as B).0: i32) = _5;\n //      discriminant(_0) = 1;\n-//      StorageDead(_7);\n+//      StorageDead(_5);\n //      goto -> bb3;\n //  }\n // END rustc.node12.Deaggregator.after.mir"}, {"sha": "ede3b2e6e299d0be7f7a61e8f45804707fb79c6f", "filename": "src/test/mir-opt/deaggregator_test_multiple.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_multiple.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -25,33 +25,31 @@ fn main() { }\n // START rustc.node10.Deaggregator.before.mir\n // bb0: {\n //     ...\n-//     _2 = _1;\n+//     _3 = _1;\n //     ...\n-//     _4 = _2;\n-//     _3 = Foo::A(_4,);\n+//     _2 = Foo::A(_3,);\n //     ...\n-//     _6 = _2;\n-//     _5 = Foo::A(_6,);\n+//     _5 = _1;\n+//     _4 = Foo::A(_5,);\n //     ...\n-//     _0 = [_3, _5];\n+//     _0 = [_2, _4];\n //     ...\n //     return;\n // }\n // END rustc.node10.Deaggregator.before.mir\n // START rustc.node10.Deaggregator.after.mir\n // bb0: {\n //     ...\n-//     _2 = _1;\n+//     _3 = _1;\n //     ...\n-//     _4 = _2;\n-//     ((_3 as A).0: i32) = _4;\n-//     discriminant(_3) = 0;\n+//     ((_2 as A).0: i32) = _3;\n+//     discriminant(_2) = 0;\n //     ...\n-//     _6 = _2;\n-//     ((_5 as A).0: i32) = _6;\n-//     discriminant(_5) = 0;\n+//     _5 = _1;\n+//     ((_4 as A).0: i32) = _5;\n+//     discriminant(_4) = 0;\n //     ...\n-//     _0 = [_3, _5];\n+//     _0 = [_2, _4];\n //     ...\n //     return;\n // }"}, {"sha": "53454c0cc9ae6adc4ba58bf08636fed0d51a5431", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -64,17 +64,14 @@ fn main() {\n //     bb0: {\n //         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(50)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[317d]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n //         StorageLive(_3);\n-//         _3 = _2;\n+//         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 }))), [(*_2): i32]);\n+//         _3 = &ReErased (*_2);\n+//         Validate(Acquire, [(*_3): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 })) (imm)]);\n //         StorageLive(_4);\n-//         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 }))), [(*_3): i32]);\n-//         _4 = &ReErased (*_3);\n-//         Validate(Acquire, [(*_4): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 })) (imm)]);\n-//         StorageLive(_5);\n-//         _5 = (*_4);\n-//         _0 = _5;\n-//         StorageDead(_5);\n-//         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 })));\n+//         _4 = (*_3);\n+//         _0 = _4;\n //         StorageDead(_4);\n+//         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 })));\n //         StorageDead(_3);\n //         return;\n //     }"}, {"sha": "042edca82a650a103a0b0d5603fff516cb321b61", "filename": "src/test/mir-opt/validate_4.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -53,10 +53,7 @@ fn main() {\n //     bb0: {\n //         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_4[317d]::write_42[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(22)], _2: *mut i32]);\n //         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_4[317d]::write_42[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(22)], _2: *mut i32]);\n-//         StorageLive(_3);\n-//         _3 = _2;\n-//         (*_3) = const 23i32;\n-//         StorageDead(_3);\n+//         (*_2) = const 23i32;\n //         return;\n //     }\n // }\n@@ -68,11 +65,11 @@ fn main() {\n //         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:4) => validate_4[317d]::test[0] }, BrAnon(0)) mut i32]);\n //         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:4) => validate_4[317d]::test[0] }, BrAnon(0)) mut i32]);\n //         ...\n-//         _3 = const write_42(_4) -> bb1;\n+//         _2 = const write_42(_3) -> bb1;\n //     }\n //     bb1: {\n-//         Validate(Acquire, [_3: bool]);\n-//         Validate(Release, [_3: bool]);\n+//         Validate(Acquire, [_2: bool]);\n+//         Validate(Release, [_2: bool]);\n //         ...\n //     }\n // }\n@@ -85,7 +82,7 @@ fn main() {\n //         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n //         StorageLive(_3);\n //         ...\n-//         _0 = const write_42(_4) -> bb1;\n+//         _0 = const write_42(_3) -> bb1;\n //     }\n //     ...\n // }"}, {"sha": "fc849c5aee33b3a0c4ccf28016145588f42223d7", "filename": "src/test/mir-opt/validate_5.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=b0b80f8c2299cccd7a4f22ee3cc1a2ca823eaa31", "patch": "@@ -39,8 +39,8 @@ fn main() {\n //     bb0: {\n //         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(0:4) => validate_5[317d]::test[0] }, BrAnon(0)) mut i32]);\n //         ...\n-//         Validate(Release, [_3: bool, _4: *mut i32]);\n-//         _3 = const write_42(_4) -> bb1;\n+//         Validate(Release, [_2: bool, _3: *mut i32]);\n+//         _2 = const write_42(_3) -> bb1;\n //     }\n //     ...\n // }\n@@ -51,17 +51,15 @@ fn main() {\n //     bb0: {\n //         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(46)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[317d]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n //         StorageLive(_3);\n-//         _3 = _2;\n //         StorageLive(_4);\n-//         StorageLive(_5);\n-//         Validate(Suspend(ReScope(Node(ItemLocalId(9)))), [(*_3): i32]);\n-//         _5 = &ReErased mut (*_3);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(9)))]);\n-//         _4 = _5 as *mut i32 (Misc);\n+//         Validate(Suspend(ReScope(Node(ItemLocalId(9)))), [(*_2): i32]);\n+//         _4 = &ReErased mut (*_2);\n+//         Validate(Acquire, [(*_4): i32/ReScope(Node(ItemLocalId(9)))]);\n+//         _3 = _4 as *mut i32 (Misc);\n //         EndRegion(ReScope(Node(ItemLocalId(9))));\n-//         StorageDead(_5);\n-//         Validate(Release, [_0: bool, _4: *mut i32]);\n-//         _0 = const write_42(_4) -> bb1;\n+//         StorageDead(_4);\n+//         Validate(Release, [_0: bool, _3: *mut i32]);\n+//         _0 = const write_42(_3) -> bb1;\n //     }\n //     ...\n // }"}]}