{"sha": "cd07efd264949d27a2117e99e7e61c48cd522530", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkMDdlZmQyNjQ5NDlkMjdhMjExN2U5OWU3ZTYxYzQ4Y2Q1MjI1MzA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T16:34:49Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T19:50:28Z"}, "message": "rollup merge of #19873: drewm1980/master\n\nIn US english, \"that\" is used in restrictive clauses in place of\n\"which\", and often affects the meaning of sentences.\n\nIn UK english and many dialects, no distinction is\nmade.\n\nWhile Rust devs want to avoid unproductive pedanticism, it is worth at\nleast being uniform in documentation such as:\n\nhttp://doc.rust-lang.org/std/iter/index.html\n\nand also in cases where correct usage of US english clarifies the\nsentence.", "tree": {"sha": "796c0c6c923b577f8efbebf4333d726b058a0a37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/796c0c6c923b577f8efbebf4333d726b058a0a37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd07efd264949d27a2117e99e7e61c48cd522530", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd07efd264949d27a2117e99e7e61c48cd522530", "html_url": "https://github.com/rust-lang/rust/commit/cd07efd264949d27a2117e99e7e61c48cd522530", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd07efd264949d27a2117e99e7e61c48cd522530/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "272f20394c605ad7d57cbbdf1638cd29b62f8717", "url": "https://api.github.com/repos/rust-lang/rust/commits/272f20394c605ad7d57cbbdf1638cd29b62f8717", "html_url": "https://github.com/rust-lang/rust/commit/272f20394c605ad7d57cbbdf1638cd29b62f8717"}, {"sha": "8fcc832198e86c4f3ff2912c5cfc91dc0896098b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fcc832198e86c4f3ff2912c5cfc91dc0896098b", "html_url": "https://github.com/rust-lang/rust/commit/8fcc832198e86c4f3ff2912c5cfc91dc0896098b"}], "stats": {"total": 82, "additions": 41, "deletions": 41}, "files": [{"sha": "2f62c745b90df76ab39ae51229702ea9f4386a0e", "filename": "src/doc/guide.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd07efd264949d27a2117e99e7e61c48cd522530/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd07efd264949d27a2117e99e7e61c48cd522530/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=cd07efd264949d27a2117e99e7e61c48cd522530", "patch": "@@ -4439,7 +4439,7 @@ for i in range(0u, nums.len()) {\n ```\n \n This is strictly worse than using an actual iterator. The `.iter()` method on\n-vectors returns an iterator which iterates through a reference to each element\n+vectors returns an iterator that iterates through a reference to each element\n of the vector in turn. So write this:\n \n ```{rust}"}, {"sha": "2ad43eb7c7429b57caf49bf27a6e5b3c7b1b7e4e", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd07efd264949d27a2117e99e7e61c48cd522530/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd07efd264949d27a2117e99e7e61c48cd522530/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=cd07efd264949d27a2117e99e7e61c48cd522530", "patch": "@@ -375,7 +375,7 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Returns a front-to-back iterator which returns mutable references.\n+    /// Returns a front-to-back iterator that returns mutable references.\n     ///\n     /// # Examples\n     ///"}, {"sha": "7e0380e8785a634fa6dd527cb1bce9b5025f5dff", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cd07efd264949d27a2117e99e7e61c48cd522530/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd07efd264949d27a2117e99e7e61c48cd522530/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=cd07efd264949d27a2117e99e7e61c48cd522530", "patch": "@@ -110,8 +110,8 @@ pub trait Iterator<A> {\n #[unstable = \"new convention for extension traits\"]\n /// An extension trait providing numerous methods applicable to all iterators.\n pub trait IteratorExt<A>: Iterator<A> {\n-    /// Chain this iterator with another, returning a new iterator which will\n-    /// finish iterating over the current iterator, and then it will iterate\n+    /// Chain this iterator with another, returning a new iterator that will\n+    /// finish iterating over the current iterator, and then iterate\n     /// over the other specified iterator.\n     ///\n     /// # Example\n@@ -130,7 +130,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Chain{a: self, b: other, flag: false}\n     }\n \n-    /// Creates an iterator which iterates over both this and the specified\n+    /// Creates an iterator that iterates over both this and the specified\n     /// iterators simultaneously, yielding the two elements as pairs. When\n     /// either iterator returns None, all further invocations of next() will\n     /// return None.\n@@ -151,7 +151,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Zip{a: self, b: other}\n     }\n \n-    /// Creates a new iterator which will apply the specified function to each\n+    /// Creates a new iterator that will apply the specified function to each\n     /// element returned by the first, yielding the mapped element instead.\n     ///\n     /// # Example\n@@ -169,8 +169,8 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Map{iter: self, f: f}\n     }\n \n-    /// Creates an iterator which applies the predicate to each element returned\n-    /// by this iterator. Only elements which have the predicate evaluate to\n+    /// Creates an iterator that applies the predicate to each element returned\n+    /// by this iterator. Only elements that have the predicate evaluate to\n     /// `true` will be yielded.\n     ///\n     /// # Example\n@@ -187,7 +187,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Filter{iter: self, predicate: predicate}\n     }\n \n-    /// Creates an iterator which both filters and maps elements.\n+    /// Creates an iterator that both filters and maps elements.\n     /// If the specified function returns None, the element is skipped.\n     /// Otherwise the option is unwrapped and the new value is yielded.\n     ///\n@@ -205,7 +205,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n         FilterMap { iter: self, f: f }\n     }\n \n-    /// Creates an iterator which yields a pair of the value returned by this\n+    /// Creates an iterator that yields a pair of the value returned by this\n     /// iterator plus the current index of iteration.\n     ///\n     /// # Example\n@@ -248,7 +248,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Peekable{iter: self, peeked: None}\n     }\n \n-    /// Creates an iterator which invokes the predicate on elements until it\n+    /// Creates an iterator that invokes the predicate on elements until it\n     /// returns false. Once the predicate returns false, all further elements are\n     /// yielded.\n     ///\n@@ -268,7 +268,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n         SkipWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n-    /// Creates an iterator which yields elements so long as the predicate\n+    /// Creates an iterator that yields elements so long as the predicate\n     /// returns true. After the predicate returns false for the first time, no\n     /// further elements will be yielded.\n     ///\n@@ -287,8 +287,8 @@ pub trait IteratorExt<A>: Iterator<A> {\n         TakeWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n-    /// Creates an iterator which skips the first `n` elements of this iterator,\n-    /// and then it yields all further items.\n+    /// Creates an iterator that skips the first `n` elements of this iterator,\n+    /// and then yields all further items.\n     ///\n     /// # Example\n     ///\n@@ -305,8 +305,8 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Skip{iter: self, n: n}\n     }\n \n-    /// Creates an iterator which yields the first `n` elements of this\n-    /// iterator, and then it will always return None.\n+    /// Creates an iterator that yields the first `n` elements of this\n+    /// iterator, and then will always return None.\n     ///\n     /// # Example\n     ///\n@@ -324,7 +324,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n         Take{iter: self, n: n}\n     }\n \n-    /// Creates a new iterator which behaves in a similar fashion to fold.\n+    /// Creates a new iterator that behaves in a similar fashion to fold.\n     /// There is a state which is passed between each iteration and can be\n     /// mutated as necessary. The yielded values from the closure are yielded\n     /// from the Scan instance when not None.\n@@ -1223,7 +1223,7 @@ impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T>\n     }\n }\n \n-/// An iterator which strings two iterators together\n+/// An iterator that strings two iterators together\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n@@ -1297,7 +1297,7 @@ for Chain<T, U> {\n     }\n }\n \n-/// An iterator which iterates two other iterators simultaneously\n+/// An iterator that iterates two other iterators simultaneously\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n@@ -1380,7 +1380,7 @@ RandomAccessIterator<(A, B)> for Zip<T, U> {\n     }\n }\n \n-/// An iterator which maps the values of `iter` with `f`\n+/// An iterator that maps the values of `iter` with `f`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n pub struct Map<A, B, I: Iterator<A>, F: FnMut(A) -> B> {\n@@ -1454,7 +1454,7 @@ impl<A, B, I, F> RandomAccessIterator<B> for Map<A, B, I, F> where\n     }\n }\n \n-/// An iterator which filters the elements of `iter` with `predicate`\n+/// An iterator that filters the elements of `iter` with `predicate`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n pub struct Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n@@ -1512,7 +1512,7 @@ impl<A, I, P> DoubleEndedIterator<A> for Filter<A, I, P> where\n     }\n }\n \n-/// An iterator which uses `f` to both filter and map elements from `iter`\n+/// An iterator that uses `f` to both filter and map elements from `iter`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n pub struct FilterMap<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> Option<B> {\n@@ -1573,7 +1573,7 @@ impl<A, B, I, F> DoubleEndedIterator<B> for FilterMap<A, B, I, F> where\n     }\n }\n \n-/// An iterator which yields the current count and the element during iteration\n+/// An iterator that yields the current count and the element during iteration\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n@@ -1687,7 +1687,7 @@ impl<'a, A, T: Iterator<A>> Peekable<A, T> {\n     }\n }\n \n-/// An iterator which rejects elements while `predicate` is true\n+/// An iterator that rejects elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n pub struct SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n@@ -1730,7 +1730,7 @@ impl<A, I, P> Iterator<A> for SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(\n     }\n }\n \n-/// An iterator which only accepts elements while `predicate` is true\n+/// An iterator that only accepts elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n pub struct TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n@@ -1781,7 +1781,7 @@ impl<A, I, P> Iterator<A> for TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(\n     }\n }\n \n-/// An iterator which skips over `n` elements of `iter`.\n+/// An iterator that skips over `n` elements of `iter`.\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n@@ -1849,7 +1849,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Skip<T> {\n     }\n }\n \n-/// An iterator which only iterates over the first `n` iterations of `iter`.\n+/// An iterator that only iterates over the first `n` iterations of `iter`.\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n@@ -2186,7 +2186,7 @@ impl<A, I, F> RandomAccessIterator<A> for Inspect<A, I, F> where\n     }\n }\n \n-/// An iterator which passes mutable state to a closure and yields the result.\n+/// An iterator that passes mutable state to a closure and yields the result.\n ///\n /// # Example: The Fibonacci Sequence\n ///"}, {"sha": "dfcdad481a91abf1c59d9ccb410c6df4b1c804a6", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd07efd264949d27a2117e99e7e61c48cd522530/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd07efd264949d27a2117e99e7e61c48cd522530/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=cd07efd264949d27a2117e99e7e61c48cd522530", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -185,7 +185,7 @@ pub trait Rng {\n         Rand::rand(self)\n     }\n \n-    /// Return an iterator which will yield an infinite number of randomly\n+    /// Return an iterator that will yield an infinite number of randomly\n     /// generated items.\n     ///\n     /// # Example"}, {"sha": "72ddbe19f54b210b3b07dc20a207cc94fb9aeb3c", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd07efd264949d27a2117e99e7e61c48cd522530/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd07efd264949d27a2117e99e7e61c48cd522530/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=cd07efd264949d27a2117e99e7e61c48cd522530", "patch": "@@ -81,7 +81,7 @@\n //! Shared usage:\n //!\n //! ```\n-//! // Create a shared channel which can be sent along from many tasks\n+//! // Create a shared channel that can be sent along from many tasks\n //! // where tx is the sending half (tx for transmission), and rx is the receiving\n //! // half (rx for receiving).\n //! let (tx, rx) = channel();\n@@ -176,7 +176,7 @@\n // The choice of implementation of all channels is to be built on lock-free data\n // structures. The channels themselves are then consequently also lock-free data\n // structures. As always with lock-free code, this is a very \"here be dragons\"\n-// territory, especially because I'm unaware of any academic papers which have\n+// territory, especially because I'm unaware of any academic papers that have\n // gone into great length about channels of these flavors.\n //\n // ## Flavors of channels\n@@ -190,7 +190,7 @@\n //              They contain as few atomics as possible and involve one and\n //              exactly one allocation.\n // * Streams - these channels are optimized for the non-shared use case. They\n-//             use a different concurrent queue which is more tailored for this\n+//             use a different concurrent queue that is more tailored for this\n //             use case. The initial allocation of this flavor of channel is not\n //             optimized.\n // * Shared - this is the most general form of channel that this module offers,\n@@ -205,7 +205,7 @@\n // shared and concurrent queue holding all of the actual data.\n //\n // With two flavors of channels, two flavors of queues are also used. We have\n-// chosen to use queues from a well-known author which are abbreviated as SPSC\n+// chosen to use queues from a well-known author that are abbreviated as SPSC\n // and MPSC (single producer, single consumer and multiple producer, single\n // consumer). SPSC queues are used for streams while MPSC queues are used for\n // shared channels.\n@@ -309,7 +309,7 @@\n //\n // Sadly this current implementation requires multiple allocations, so I have\n // seen the throughput of select() be much worse than it should be. I do not\n-// believe that there is anything fundamental which needs to change about these\n+// believe that there is anything fundamental that needs to change about these\n // channels, however, in order to support a more efficient select().\n //\n // # Conclusion\n@@ -910,7 +910,7 @@ impl<T: Send> Receiver<T> {\n         }\n     }\n \n-    /// Returns an iterator which will block waiting for messages, but never\n+    /// Returns an iterator that will block waiting for messages, but never\n     /// `panic!`. It will return `None` when the channel has hung up.\n     #[unstable]\n     pub fn iter<'a>(&'a self) -> Messages<'a, T> {"}, {"sha": "f8df7e9b1f3b266dbedde79fbe1dcf2c7b43c7e0", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd07efd264949d27a2117e99e7e61c48cd522530/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd07efd264949d27a2117e99e7e61c48cd522530/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=cd07efd264949d27a2117e99e7e61c48cd522530", "patch": "@@ -200,7 +200,7 @@ impl File {\n              .update_desc(\"couldn't create file\")\n     }\n \n-    /// Returns the original path which was used to open this file.\n+    /// Returns the original path that was used to open this file.\n     pub fn path<'a>(&'a self) -> &'a Path {\n         &self.path\n     }\n@@ -215,7 +215,7 @@ impl File {\n     }\n \n     /// This function is similar to `fsync`, except that it may not synchronize\n-    /// file metadata to the filesystem. This is intended for use case which\n+    /// file metadata to the filesystem. This is intended for use cases that\n     /// must synchronize content, but don't need the metadata on disk. The goal\n     /// of this method is to reduce disk operations.\n     pub fn datasync(&mut self) -> IoResult<()> {\n@@ -456,7 +456,7 @@ pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n /// # Error\n ///\n /// This function will return an error on failure. Failure conditions include\n-/// reading a file that does not exist or reading a file which is not a symlink.\n+/// reading a file that does not exist or reading a file that is not a symlink.\n pub fn readlink(path: &Path) -> IoResult<Path> {\n     fs_imp::readlink(path)\n            .update_err(\"couldn't resolve symlink for path\", |e|\n@@ -546,7 +546,7 @@ pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n                        |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n-/// Returns an iterator which will recursively walk the directory structure\n+/// Returns an iterator that will recursively walk the directory structure\n /// rooted at `path`. The path given will not be iterated over, and this will\n /// perform iteration in some top-down order.  The contents of unreadable\n /// subdirectories are ignored.\n@@ -557,7 +557,7 @@ pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n     })\n }\n \n-/// An iterator which walks over a directory\n+/// An iterator that walks over a directory\n pub struct Directories {\n     stack: Vec<Path>,\n }"}]}