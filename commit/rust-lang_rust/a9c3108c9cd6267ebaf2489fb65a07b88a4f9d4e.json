{"sha": "a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YzMxMDhjOWNkNjI2N2ViYWYyNDg5ZmI2NWEwN2I4OGE0ZjlkNGU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-22T07:03:36Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-22T07:18:48Z"}, "message": "Change defaults and update tests and source\n\nNew defaults are `Tabbed` for `chain_indent` and `chain_base_indent`, and `5` for `closure_block_indent_threshold`.", "tree": {"sha": "c9eb80274f8382daa8d5bd27605525af09a79598", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9eb80274f8382daa8d5bd27605525af09a79598"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "html_url": "https://github.com/rust-lang/rust/commit/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9761cf71d8384db2a75c7595b082dd7764575851", "url": "https://api.github.com/repos/rust-lang/rust/commits/9761cf71d8384db2a75c7595b082dd7764575851", "html_url": "https://github.com/rust-lang/rust/commit/9761cf71d8384db2a75c7595b082dd7764575851"}], "stats": {"total": 676, "additions": 323, "deletions": 353}, "files": [{"sha": "909d62b20f87ed261eab7e44910f4659fa1f3bf9", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -98,14 +98,14 @@ fn format_crate(verbosity: Verbosity) -> Result<ExitStatus, std::io::Error> {\n \n     // Currently only bin and lib files get formatted\n     let files: Vec<_> = targets.into_iter()\n-                               .filter(|t| t.kind.is_lib() | t.kind.is_bin())\n-                               .inspect(|t| {\n-                                   if verbosity == Verbosity::Verbose {\n-                                       println!(\"[{:?}] {:?}\", t.kind, t.path)\n-                                   }\n-                               })\n-                               .map(|t| t.path)\n-                               .collect();\n+        .filter(|t| t.kind.is_lib() | t.kind.is_bin())\n+        .inspect(|t| {\n+            if verbosity == Verbosity::Verbose {\n+                println!(\"[{:?}] {:?}\", t.kind, t.path)\n+            }\n+        })\n+        .map(|t| t.path)\n+        .collect();\n \n     format_files(&files, &get_fmt_args(), verbosity)\n }"}, {"sha": "2105a962997773534ef54f36f411250cad639b78", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -298,13 +298,13 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n \n     // Read the config_path and convert to parent dir if a file is provided.\n     let config_path: Option<PathBuf> = matches.opt_str(\"config-path\")\n-                                              .map(PathBuf::from)\n-                                              .and_then(|dir| {\n-                                                  if dir.is_file() {\n-                                                      return dir.parent().map(|v| v.into());\n-                                                  }\n-                                                  Some(dir)\n-                                              });\n+        .map(PathBuf::from)\n+        .and_then(|dir| {\n+            if dir.is_file() {\n+                return dir.parent().map(|v| v.into());\n+            }\n+            Some(dir)\n+        });\n \n     // if no file argument is supplied, read from stdin\n     if matches.free.is_empty() {"}, {"sha": "255db49386c7283ca8c74d4f0c59c65e821caa8b", "filename": "src/chains.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -132,15 +132,9 @@ pub fn rewrite_chain(expr: &ast::Expr,\n \n     let max_width = try_opt!((width + offset.width()).checked_sub(indent.width()));\n     let mut rewrites = try_opt!(subexpr_list.iter()\n-                                            .rev()\n-                                            .map(|e| {\n-                                                rewrite_chain_subexpr(e,\n-                                                                      total_span,\n-                                                                      context,\n-                                                                      max_width,\n-                                                                      indent)\n-                                            })\n-                                            .collect::<Option<Vec<_>>>());\n+        .rev()\n+        .map(|e| rewrite_chain_subexpr(e, total_span, context, max_width, indent))\n+        .collect::<Option<Vec<_>>>());\n \n     // Total of all items excluding the last.\n     let almost_total = rewrites[..rewrites.len() - 1]\n@@ -367,8 +361,8 @@ fn rewrite_method_call(method_name: ast::Ident,\n         (args[0].span.hi, String::new())\n     } else {\n         let type_list: Vec<_> = try_opt!(types.iter()\n-                                              .map(|ty| ty.rewrite(context, width, offset))\n-                                              .collect());\n+            .map(|ty| ty.rewrite(context, width, offset))\n+            .collect());\n \n         (types.last().unwrap().span.hi, format!(\"::<{}>\", type_list.join(\", \")))\n     };"}, {"sha": "991faa3c9c8ef1be898f7abd3e25088ee5989e68", "filename": "src/comment.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -70,24 +70,24 @@ pub fn rewrite_comment(orig: &str,\n     let line_breaks = s.chars().filter(|&c| c == '\\n').count();\n \n     let lines = s.lines()\n-                 .enumerate()\n-                 .map(|(i, mut line)| {\n-                     line = line.trim();\n-                     // Drop old closer.\n-                     if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n-                         line = &line[..(line.len() - 2)];\n-                     }\n-\n-                     line.trim_right()\n-                 })\n-                 .map(left_trim_comment_line)\n-                 .map(|line| {\n-                     if line_breaks == 0 {\n-                         line.trim_left()\n-                     } else {\n-                         line\n-                     }\n-                 });\n+        .enumerate()\n+        .map(|(i, mut line)| {\n+            line = line.trim();\n+            // Drop old closer.\n+            if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n+                line = &line[..(line.len() - 2)];\n+            }\n+\n+            line.trim_right()\n+        })\n+        .map(left_trim_comment_line)\n+        .map(|line| {\n+            if line_breaks == 0 {\n+                line.trim_left()\n+            } else {\n+                line\n+            }\n+        });\n \n     let mut result = opener.to_owned();\n     for line in lines {\n@@ -538,7 +538,7 @@ fn changed_comment_content(orig: &str, new: &str) -> bool {\n     let code_comment_content = |code| {\n         let slices = UngroupedCommentCodeSlices::new(code);\n         slices.filter(|&(ref kind, _, _)| *kind == CodeCharKind::Comment)\n-              .flat_map(|(_, _, s)| CommentReducer::new(s))\n+            .flat_map(|(_, _, s)| CommentReducer::new(s))\n     };\n     let res = code_comment_content(orig).ne(code_comment_content(new));\n     debug!(\"comment::changed_comment_content: {}\\norig: '{}'\\nnew: '{}'\\nraw_old: {}\\nraw_new: {}\","}, {"sha": "333835b66cdc0ec72d39a342115e2afab582869f", "filename": "src/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -375,8 +375,8 @@ create_config! {\n         \"Report all, none or unnumbered occurrences of TODO in source file comments\";\n     report_fixme: ReportTactic, ReportTactic::Never,\n         \"Report all, none or unnumbered occurrences of FIXME in source file comments\";\n-    chain_base_indent: BlockIndentStyle, BlockIndentStyle::Visual, \"Indent on chain base\";\n-    chain_indent: BlockIndentStyle, BlockIndentStyle::Visual, \"Indentation of chain\";\n+    chain_base_indent: BlockIndentStyle, BlockIndentStyle::Tabbed, \"Indent on chain base\";\n+    chain_indent: BlockIndentStyle, BlockIndentStyle::Tabbed, \"Indentation of chain\";\n     chains_overflow_last: bool, true, \"Allow last call in method chain to break the line\";\n     reorder_imports: bool, false, \"Reorder import statements alphabetically\";\n     single_line_if_else: bool, false, \"Put else on same line as closing brace for if statements\";\n@@ -390,8 +390,8 @@ create_config! {\n     match_block_trailing_comma: bool, false,\n         \"Put a trailing comma after a block based match arm (non-block arms are not affected)\";\n     match_wildcard_trailing_comma: bool, true, \"Put a trailing comma after a wildcard arm\";\n-    closure_block_indent_threshold: isize, -1, \"How many lines a closure must have before it is \\\n-                                                block indented. -1 means never use block indent.\";\n+    closure_block_indent_threshold: isize, 5, \"How many lines a closure must have before it is \\\n+                                               block indented. -1 means never use block indent.\";\n     write_mode: WriteMode, WriteMode::Replace,\n         \"What Write Mode to use when none is supplied: Replace, Overwrite, Display, Diff, Coverage\";\n }"}, {"sha": "c2d5115ba754bd95b872969b7cff32e301ce432f", "filename": "src/expr.rs", "status": "modified", "additions": 56, "deletions": 64, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -283,12 +283,11 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n                              |item| item.rewrite(&inner_context, max_item_width, offset),\n                              span.lo,\n                              span.hi)\n-                    .collect::<Vec<_>>();\n+        .collect::<Vec<_>>();\n \n     let has_long_item = try_opt!(items.iter()\n-                                      .map(|li| li.item.as_ref().map(|s| s.len() > 10))\n-                                      .fold(Some(false),\n-                                            |acc, x| acc.and_then(|y| x.map(|x| x || y))));\n+        .map(|li| li.item.as_ref().map(|s| s.len() > 10))\n+        .fold(Some(false), |acc, x| acc.and_then(|y| x.map(|x| x || y))));\n \n     let tactic = if has_long_item || items.iter().any(ListItem::is_multiline) {\n         definitive_tactic(&items, ListTactic::HorizontalVertical, max_item_width)\n@@ -410,8 +409,8 @@ fn rewrite_closure(capture: ast::CaptureBy,\n     if try_single_line && !force_block {\n         let must_preserve_braces =\n             !classify::expr_requires_semi_to_be_stmt(left_most_sub_expr(inner_block.expr\n-                                                                                   .as_ref()\n-                                                                                   .unwrap()));\n+                .as_ref()\n+                .unwrap()));\n         if !(must_preserve_braces && had_braces) &&\n            (must_preserve_braces || !prefix.contains('\\n')) {\n             // If we got here, then we can try to format without braces.\n@@ -523,9 +522,9 @@ impl Rewrite for ast::Block {\n \n                 if is_simple_block(self, context.codemap) && prefix.len() < width {\n                     let body = self.expr\n-                                   .as_ref()\n-                                   .unwrap()\n-                                   .rewrite(context, width - prefix.len(), offset);\n+                        .as_ref()\n+                        .unwrap()\n+                        .rewrite(context, width - prefix.len(), offset);\n                     if let Some(ref expr_str) = body {\n                         let result = format!(\"{}{{ {} }}\", prefix, expr_str);\n                         if result.len() <= width && !result.contains('\\n') {\n@@ -568,9 +567,9 @@ impl Rewrite for ast::Stmt {\n                 };\n \n                 ex.rewrite(context,\n-                           context.config.max_width - offset.width() - suffix.len(),\n-                           offset)\n-                  .map(|s| s + suffix)\n+                             context.config.max_width - offset.width() - suffix.len(),\n+                             offset)\n+                    .map(|s| s + suffix)\n             }\n             ast::StmtKind::Mac(..) => None,\n         };\n@@ -805,8 +804,8 @@ fn rewrite_if_else(context: &RewriteContext,\n                                                             width);\n \n         let after_else = mk_sp(context.codemap\n-                                      .span_after(mk_sp(if_block.span.hi, else_block.span.lo),\n-                                                  \"else\"),\n+                                   .span_after(mk_sp(if_block.span.hi, else_block.span.lo),\n+                                               \"else\"),\n                                else_block.span.lo);\n         let after_else_comment = extract_comment(after_else, &context, offset, width);\n \n@@ -822,9 +821,9 @@ fn rewrite_if_else(context: &RewriteContext,\n         try_opt!(write!(&mut result,\n                         \"{}else{}\",\n                         between_if_else_block_comment.as_ref()\n-                                                     .map_or(between_sep, |str| &**str),\n+                            .map_or(between_sep, |str| &**str),\n                         after_else_comment.as_ref().map_or(after_sep, |str| &**str))\n-                     .ok());\n+            .ok());\n         result.push_str(&&try_opt!(rewrite));\n     }\n \n@@ -968,7 +967,7 @@ fn rewrite_match(context: &RewriteContext,\n     let arm_indent_str = arm_indent.to_string(context.config);\n \n     let open_brace_pos = context.codemap\n-                                .span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])), \"{\");\n+        .span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])), \"{\");\n \n     for (i, arm) in arms.iter().enumerate() {\n         // Make sure we get the stuff between arms.\n@@ -1073,8 +1072,8 @@ impl Rewrite for ast::Arm {\n         // 5 = ` => {`\n         let pat_budget = try_opt!(width.checked_sub(5));\n         let pat_strs = try_opt!(pats.iter()\n-                                    .map(|p| p.rewrite(context, pat_budget, offset))\n-                                    .collect::<Option<Vec<_>>>());\n+            .map(|p| p.rewrite(context, pat_budget, offset))\n+            .collect::<Option<Vec<_>>>());\n \n         let all_simple = pat_strs.iter().all(|p| pat_is_simple(&p));\n         let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n@@ -1445,7 +1444,7 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n \n     let tactic = definitive_tactic(&item_vec,\n                                    ListTactic::LimitedHorizontalVertical(context.config\n-                                                                                .fn_call_width),\n+                                       .fn_call_width),\n                                    remaining_width);\n \n     // Replace the stub with the full overflowing last argument if the rewrite\n@@ -1525,52 +1524,46 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n     };\n \n     let field_iter = fields.into_iter()\n-                           .map(StructLitField::Regular)\n-                           .chain(base.into_iter().map(StructLitField::Base));\n+        .map(StructLitField::Regular)\n+        .chain(base.into_iter().map(StructLitField::Base));\n \n     let inner_context = &RewriteContext { block_indent: indent, ..*context };\n \n     let items = itemize_list(context.codemap,\n                              field_iter,\n                              \"}\",\n                              |item| {\n-                                 match *item {\n-                                     StructLitField::Regular(ref field) => field.span.lo,\n-                                     StructLitField::Base(ref expr) => {\n-                                         let last_field_hi = fields.last().map_or(span.lo,\n-                                                                                  |field| {\n-                                                                                      field.span.hi\n-                                                                                  });\n-                                         let snippet = context.snippet(mk_sp(last_field_hi,\n-                                                                             expr.span.lo));\n-                                         let pos = snippet.find_uncommented(\"..\").unwrap();\n-                                         last_field_hi + BytePos(pos as u32)\n-                                     }\n-                                 }\n-                             },\n+        match *item {\n+            StructLitField::Regular(ref field) => field.span.lo,\n+            StructLitField::Base(ref expr) => {\n+                let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n+                let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n+                let pos = snippet.find_uncommented(\"..\").unwrap();\n+                last_field_hi + BytePos(pos as u32)\n+            }\n+        }\n+    },\n                              |item| {\n                                  match *item {\n                                      StructLitField::Regular(ref field) => field.span.hi,\n                                      StructLitField::Base(ref expr) => expr.span.hi,\n                                  }\n                              },\n                              |item| {\n-                                 match *item {\n-                                     StructLitField::Regular(ref field) => {\n-                                         rewrite_field(inner_context,\n-                                                       &field,\n-                                                       v_budget.checked_sub(1).unwrap_or(0),\n-                                                       indent)\n-                                     }\n-                                     StructLitField::Base(ref expr) => {\n-                                         // 2 = ..\n-                                         expr.rewrite(inner_context,\n-                                                      try_opt!(v_budget.checked_sub(2)),\n-                                                      indent + 2)\n-                                             .map(|s| format!(\"..{}\", s))\n-                                     }\n-                                 }\n-                             },\n+        match *item {\n+            StructLitField::Regular(ref field) => {\n+                rewrite_field(inner_context,\n+                              &field,\n+                              v_budget.checked_sub(1).unwrap_or(0),\n+                              indent)\n+            }\n+            StructLitField::Base(ref expr) => {\n+                // 2 = ..\n+                expr.rewrite(inner_context, try_opt!(v_budget.checked_sub(2)), indent + 2)\n+                    .map(|s| format!(\"..{}\", s))\n+            }\n+        }\n+    },\n                              context.codemap.span_after(span, \"{\"),\n                              span.hi);\n     let item_vec = items.collect::<Vec<_>>();\n@@ -1617,8 +1610,8 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n \n     let format_on_newline = || {\n         let inner_indent = context.block_indent\n-                                  .block_indent(context.config)\n-                                  .to_string(context.config);\n+            .block_indent(context.config)\n+            .to_string(context.config);\n         let outer_indent = context.block_indent.to_string(context.config);\n         Some(format!(\"{} {{\\n{}{}\\n{}}}\",\n                      path_str,\n@@ -1656,8 +1649,8 @@ fn rewrite_field(context: &RewriteContext,\n             let expr_offset = offset.block_indent(&context.config);\n             let expr = field.expr.rewrite(context,\n                                           try_opt!(context.config\n-                                                          .max_width\n-                                                          .checked_sub(expr_offset.width())),\n+                                              .max_width\n+                                              .checked_sub(expr_offset.width())),\n                                           expr_offset);\n             expr.map(|s| format!(\"{}:\\n{}{}\", name, expr_offset.to_string(&context.config), s))\n         }\n@@ -1690,9 +1683,8 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n                              |item| item.span().hi,\n                              |item| {\n                                  let inner_width = try_opt!(context.config\n-                                                                   .max_width\n-                                                                   .checked_sub(indent.width() +\n-                                                                                1));\n+                                     .max_width\n+                                     .checked_sub(indent.width() + 1));\n                                  item.rewrite(context, inner_width, indent)\n                              },\n                              list_lo,\n@@ -1750,8 +1742,8 @@ fn rewrite_binary_op(context: &RewriteContext,\n \n     // Re-evaluate the lhs because we have more space now:\n     let budget = try_opt!(context.config\n-                                 .max_width\n-                                 .checked_sub(offset.width() + 1 + operator_str.len()));\n+        .max_width\n+        .checked_sub(offset.width() + 1 + operator_str.len()));\n     Some(format!(\"{} {}\\n{}{}\",\n                  try_opt!(lhs.rewrite(context, budget, offset)),\n                  operator_str,\n@@ -1766,9 +1758,9 @@ pub fn rewrite_unary_prefix<R: Rewrite>(context: &RewriteContext,\n                                         offset: Indent)\n                                         -> Option<String> {\n     rewrite.rewrite(context,\n-                    try_opt!(width.checked_sub(prefix.len())),\n-                    offset + prefix.len())\n-           .map(|r| format!(\"{}{}\", prefix, r))\n+                 try_opt!(width.checked_sub(prefix.len())),\n+                 offset + prefix.len())\n+        .map(|r| format!(\"{}{}\", prefix, r))\n }\n \n fn rewrite_unary_op(context: &RewriteContext,"}, {"sha": "5ded7c2c5e8f723dc15b63569587d50f62f3d897", "filename": "src/items.rs", "status": "modified", "additions": 71, "deletions": 79, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -277,10 +277,10 @@ impl<'a> FmtVisitor<'a> {\n                     };\n \n                     e.rewrite(&self.get_context(),\n-                              self.config.max_width - self.block_indent.width(),\n-                              self.block_indent)\n-                     .map(|s| s + suffix)\n-                     .or_else(|| Some(self.snippet(e.span)))\n+                                 self.config.max_width - self.block_indent.width(),\n+                                 self.block_indent)\n+                        .map(|s| s + suffix)\n+                        .or_else(|| Some(self.snippet(e.span)))\n                 } else if let Some(ref stmt) = block.stmts.first() {\n                     stmt.rewrite(&self.get_context(),\n                                  self.config.max_width - self.block_indent.width(),\n@@ -321,7 +321,7 @@ impl<'a> FmtVisitor<'a> {\n                                            self.block_indent,\n                                            self.block_indent.block_indent(self.config),\n                                            mk_sp(span.lo, body_start))\n-                               .unwrap();\n+            .unwrap();\n         self.buffer.push_str(&generics_str);\n \n         self.last_pos = body_start;\n@@ -359,12 +359,12 @@ impl<'a> FmtVisitor<'a> {\n                                  enum_def.variants.iter(),\n                                  \"}\",\n                                  |f| {\n-                                     if !f.node.attrs.is_empty() {\n-                                         f.node.attrs[0].span.lo\n-                                     } else {\n-                                         f.span.lo\n-                                     }\n-                                 },\n+            if !f.node.attrs.is_empty() {\n+                f.node.attrs[0].span.lo\n+            } else {\n+                f.span.lo\n+            }\n+        },\n                                  |f| f.span.hi,\n                                  |f| self.format_variant(f),\n                                  body_lo,\n@@ -397,10 +397,10 @@ impl<'a> FmtVisitor<'a> {\n \n         let indent = self.block_indent;\n         let mut result = try_opt!(field.node\n-                                       .attrs\n-                                       .rewrite(&self.get_context(),\n-                                                self.config.max_width - indent.width(),\n-                                                indent));\n+            .attrs\n+            .rewrite(&self.get_context(),\n+                     self.config.max_width - indent.width(),\n+                     indent));\n         if !result.is_empty() {\n             result.push('\\n');\n             result.push_str(&indent.to_string(self.config));\n@@ -666,8 +666,8 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         };\n \n         let where_budget = try_opt!(context.config\n-                                           .max_width\n-                                           .checked_sub(last_line_width(&result)));\n+            .max_width\n+            .checked_sub(last_line_width(&result)));\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n                                                              context.config,\n@@ -803,13 +803,13 @@ fn format_struct_struct(context: &RewriteContext,\n                              fields.iter(),\n                              \"}\",\n                              |field| {\n-                                 // Include attributes and doc comments, if present\n-                                 if !field.node.attrs.is_empty() {\n-                                     field.node.attrs[0].span.lo\n-                                 } else {\n-                                     field.span.lo\n-                                 }\n-                             },\n+        // Include attributes and doc comments, if present\n+        if !field.node.attrs.is_empty() {\n+            field.node.attrs[0].span.lo\n+        } else {\n+            field.span.lo\n+        }\n+    },\n                              |field| field.node.ty.span.hi,\n                              |field| field.rewrite(context, item_budget, item_indent),\n                              context.codemap.span_after(span, \"{\"),\n@@ -864,8 +864,8 @@ fn format_tuple_struct(context: &RewriteContext,\n             result.push_str(&generics_str);\n \n             let where_budget = try_opt!(context.config\n-                                               .max_width\n-                                               .checked_sub(last_line_width(&result)));\n+                .max_width\n+                .checked_sub(last_line_width(&result)));\n             try_opt!(rewrite_where_clause(context,\n                                           &generics.where_clause,\n                                           context.config,\n@@ -889,13 +889,13 @@ fn format_tuple_struct(context: &RewriteContext,\n                              fields.iter(),\n                              \")\",\n                              |field| {\n-                                 // Include attributes and doc comments, if present\n-                                 if !field.node.attrs.is_empty() {\n-                                     field.node.attrs[0].span.lo\n-                                 } else {\n-                                     field.span.lo\n-                                 }\n-                             },\n+        // Include attributes and doc comments, if present\n+        if !field.node.attrs.is_empty() {\n+            field.node.attrs[0].span.lo\n+        } else {\n+            field.span.lo\n+        }\n+    },\n                              |field| field.node.ty.span.hi,\n                              |field| field.rewrite(context, item_budget, item_indent),\n                              context.codemap.span_after(span, \"(\"),\n@@ -946,8 +946,8 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n     result.push_str(&generics_str);\n \n     let where_budget = try_opt!(context.config\n-                                       .max_width\n-                                       .checked_sub(last_line_width(&result)));\n+        .max_width\n+        .checked_sub(last_line_width(&result)));\n     let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                          &generics.where_clause,\n                                                          context.config,\n@@ -965,26 +965,25 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n     // This checked_sub may fail as the extra space after '=' is not taken into account\n     // In that case the budget is set to 0 which will make ty.rewrite retry on a new line\n     let budget = context.config\n-                        .max_width\n-                        .checked_sub(indent.width() + line_width + \";\".len())\n-                        .unwrap_or(0);\n+        .max_width\n+        .checked_sub(indent.width() + line_width + \";\".len())\n+        .unwrap_or(0);\n     let type_indent = indent + line_width;\n     // Try to fit the type on the same line\n     let ty_str = try_opt!(ty.rewrite(context, budget, type_indent)\n-                            .or_else(|| {\n-                                // The line was too short, try to put the type on the next line\n-\n-                                // Remove the space after '='\n-                                result.pop();\n-                                let type_indent = indent.block_indent(context.config);\n-                                result.push('\\n');\n-                                result.push_str(&type_indent.to_string(context.config));\n-                                let budget = try_opt!(context.config\n-                                                             .max_width\n-                                                             .checked_sub(type_indent.width() +\n-                                                                          \";\".len()));\n-                                ty.rewrite(context, budget, type_indent)\n-                            }));\n+        .or_else(|| {\n+            // The line was too short, try to put the type on the next line\n+\n+            // Remove the space after '='\n+            result.pop();\n+            let type_indent = indent.block_indent(context.config);\n+            result.push('\\n');\n+            result.push_str(&type_indent.to_string(context.config));\n+            let budget = try_opt!(context.config\n+                .max_width\n+                .checked_sub(type_indent.width() + \";\".len()));\n+            ty.rewrite(context, budget, type_indent)\n+        }));\n     result.push_str(&ty_str);\n     result.push_str(\";\");\n     Some(result)\n@@ -1006,10 +1005,8 @@ impl Rewrite for ast::StructField {\n             ast::StructFieldKind::UnnamedField(vis) => format_visibility(vis),\n         };\n         let mut attr_str = try_opt!(self.node\n-                                        .attrs\n-                                        .rewrite(context,\n-                                                 context.config.max_width - offset.width(),\n-                                                 offset));\n+            .attrs\n+            .rewrite(context, context.config.max_width - offset.width(), offset));\n         if !attr_str.is_empty() {\n             attr_str.push('\\n');\n             attr_str.push_str(&offset.to_string(context.config));\n@@ -1069,11 +1066,9 @@ pub fn rewrite_associated_type(ident: ast::Ident,\n     let type_bounds_str = if let Some(ty_param_bounds) = ty_param_bounds_opt {\n         let bounds: &[_] = &ty_param_bounds.as_slice();\n         let bound_str = bounds.iter()\n-                              .filter_map(|ty_bound| {\n-                                  ty_bound.rewrite(context, context.config.max_width, indent)\n-                              })\n-                              .collect::<Vec<String>>()\n-                              .join(\" + \");\n+            .filter_map(|ty_bound| ty_bound.rewrite(context, context.config.max_width, indent))\n+            .collect::<Vec<String>>()\n+            .join(\" + \");\n         if bounds.len() > 0 {\n             format!(\": {}\", bound_str)\n         } else {\n@@ -1287,7 +1282,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n     // Note that if the width and indent really matter, we'll re-layout the\n     // return type later anyway.\n     let ret_str = try_opt!(fd.output\n-                             .rewrite(&context, context.config.max_width - indent.width(), indent));\n+        .rewrite(&context, context.config.max_width - indent.width(), indent));\n \n     let multi_line_ret_str = ret_str.contains('\\n');\n     let ret_str_len = if multi_line_ret_str {\n@@ -1332,8 +1327,8 @@ fn rewrite_fn_base(context: &RewriteContext,\n \n     // A conservative estimation, to goal is to be over all parens in generics\n     let args_start = generics.ty_params\n-                             .last()\n-                             .map_or(span.lo, |tp| end_typaram(tp));\n+        .last()\n+        .map_or(span.lo, |tp| end_typaram(tp));\n     let args_span = mk_sp(context.codemap.span_after(mk_sp(args_start, span.hi), \"(\"),\n                           span_for_return(&fd.output).lo);\n     let arg_str = try_opt!(rewrite_args(context,\n@@ -1408,7 +1403,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n \n             let budget = try_opt!(context.config.max_width.checked_sub(ret_indent.width()));\n             let ret_str = try_opt!(fd.output\n-                                     .rewrite(context, budget, ret_indent));\n+                .rewrite(context, budget, ret_indent));\n             result.push_str(&ret_str);\n         } else {\n             result.push_str(&ret_str);\n@@ -1477,21 +1472,18 @@ fn rewrite_args(context: &RewriteContext,\n                 variadic: bool)\n                 -> Option<String> {\n     let mut arg_item_strs = try_opt!(args.iter()\n-                                         .map(|arg| {\n-                                             arg.rewrite(&context, multi_line_budget, arg_indent)\n-                                         })\n-                                         .collect::<Option<Vec<_>>>());\n+        .map(|arg| arg.rewrite(&context, multi_line_budget, arg_indent))\n+        .collect::<Option<Vec<_>>>());\n \n     // Account for sugary self.\n     // FIXME: the comment for the self argument is dropped. This is blocked\n     // on rust issue #27522.\n-    let min_args = explicit_self.and_then(|explicit_self| {\n-                                    rewrite_explicit_self(explicit_self, args, context)\n-                                })\n-                                .map_or(1, |self_str| {\n-                                    arg_item_strs[0] = self_str;\n-                                    2\n-                                });\n+    let min_args =\n+        explicit_self.and_then(|explicit_self| rewrite_explicit_self(explicit_self, args, context))\n+            .map_or(1, |self_str| {\n+                arg_item_strs[0] = self_str;\n+                2\n+            });\n \n     // Comments between args.\n     let mut arg_items = Vec::new();\n@@ -1722,9 +1714,9 @@ fn rewrite_trait_bounds(context: &RewriteContext,\n     }\n \n     let bound_str = bounds.iter()\n-                          .filter_map(|ty_bound| ty_bound.rewrite(&context, width, indent))\n-                          .collect::<Vec<String>>()\n-                          .join(\" + \");\n+        .filter_map(|ty_bound| ty_bound.rewrite(&context, width, indent))\n+        .collect::<Vec<String>>()\n+        .join(\" + \");\n \n     let mut result = String::new();\n     result.push_str(\": \");"}, {"sha": "f966e41ce99a019b7d03f9a1558c9997010d907c", "filename": "src/lists.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -160,8 +160,8 @@ pub fn definitive_tactic<I, T>(items: I, tactic: ListTactic, width: usize) -> De\n           T: AsRef<ListItem>\n {\n     let pre_line_comments = items.clone()\n-                                 .into_iter()\n-                                 .any(|item| item.as_ref().has_line_pre_comment());\n+        .into_iter()\n+        .any(|item| item.as_ref().has_line_pre_comment());\n \n     let limit = match tactic {\n         _ if pre_line_comments => return DefinitiveListTactic::Vertical,\n@@ -353,9 +353,8 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n             let mut new_lines = false;\n             // Pre-comment\n             let pre_snippet = self.codemap\n-                                  .span_to_snippet(codemap::mk_sp(self.prev_span_end,\n-                                                                  (self.get_lo)(&item)))\n-                                  .unwrap();\n+                .span_to_snippet(codemap::mk_sp(self.prev_span_end, (self.get_lo)(&item)))\n+                .unwrap();\n             let trimmed_pre_snippet = pre_snippet.trim();\n             let pre_comment = if !trimmed_pre_snippet.is_empty() {\n                 Some(trimmed_pre_snippet.to_owned())\n@@ -369,9 +368,8 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n                 None => self.next_span_start,\n             };\n             let post_snippet = self.codemap\n-                                   .span_to_snippet(codemap::mk_sp((self.get_hi)(&item),\n-                                                                   next_start))\n-                                   .unwrap();\n+                .span_to_snippet(codemap::mk_sp((self.get_hi)(&item), next_start))\n+                .unwrap();\n \n             let comment_end = match self.inner.peek() {\n                 Some(..) => {\n@@ -413,7 +411,7 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n                 // From the end of the first line of comments.\n                 let test_snippet = &test_snippet[first_newline..];\n                 let first = test_snippet.find(|c: char| !c.is_whitespace())\n-                                        .unwrap_or(test_snippet.len());\n+                    .unwrap_or(test_snippet.len());\n                 // From the end of the first line of comments to the next non-whitespace char.\n                 let test_snippet = &test_snippet[..first];\n \n@@ -494,8 +492,8 @@ fn calculate_width<I, T>(items: I) -> (usize, usize)\n           T: AsRef<ListItem>\n {\n     items.into_iter()\n-         .map(|item| total_item_width(item.as_ref()))\n-         .fold((0, 0), |acc, l| (acc.0 + 1, acc.1 + l))\n+        .map(|item| total_item_width(item.as_ref()))\n+        .fold((0, 0), |acc, l| (acc.0 + 1, acc.1 + l))\n }\n \n fn total_item_width(item: &ListItem) -> usize {"}, {"sha": "13e1164487a6666b7ad40edd5815f6b696dae2d3", "filename": "src/macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -112,8 +112,9 @@ pub fn rewrite_macro(mac: &ast::Mac,\n             // Format macro invocation as array literal.\n             let extra_offset = macro_name.len();\n             let rewrite = try_opt!(rewrite_array(expr_vec.iter().map(|x| &**x),\n-                                                 mk_sp(context.codemap.span_after(mac.span,\n-                                                                  original_style.opener()),\n+                                                 mk_sp(context.codemap\n+                                                           .span_after(mac.span,\n+                                                                       original_style.opener()),\n                                                        mac.span.hi - BytePos(1)),\n                                                  context,\n                                                  try_opt!(width.checked_sub(extra_offset)),"}, {"sha": "2191a7812b1917306ba19e090c77b204543ac689", "filename": "src/missed_spans.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -93,14 +93,14 @@ impl<'a> FmtVisitor<'a> {\n \n         fn replace_chars(string: &str) -> String {\n             string.chars()\n-                  .map(|ch| {\n-                      if ch.is_whitespace() {\n-                          ch\n-                      } else {\n-                          'X'\n-                      }\n-                  })\n-                  .collect()\n+                .map(|ch| {\n+                    if ch.is_whitespace() {\n+                        ch\n+                    } else {\n+                        'X'\n+                    }\n+                })\n+                .collect()\n         }\n \n         let replaced = match self.config.write_mode {\n@@ -134,7 +134,7 @@ impl<'a> FmtVisitor<'a> {\n                                                           comment_width,\n                                                           self.block_indent,\n                                                           self.config)\n-                                              .unwrap());\n+                        .unwrap());\n \n                     last_wspace = None;\n                     line_start = offset + subslice.len();"}, {"sha": "ba3621fc6d523fb1c110095e24f9e8bb436272c9", "filename": "src/patterns.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -103,15 +103,14 @@ impl Rewrite for Pat {\n             PatKind::Vec(ref prefix, ref slice_pat, ref suffix) => {\n                 // Rewrite all the sub-patterns.\n                 let prefix = prefix.iter().map(|p| p.rewrite(context, width, offset));\n-                let slice_pat = slice_pat.as_ref().map(|p| {\n-                    Some(format!(\"{}..\", try_opt!(p.rewrite(context, width, offset))))\n-                });\n+                let slice_pat = slice_pat.as_ref()\n+                    .map(|p| Some(format!(\"{}..\", try_opt!(p.rewrite(context, width, offset)))));\n                 let suffix = suffix.iter().map(|p| p.rewrite(context, width, offset));\n \n                 // Munge them together.\n                 let pats: Option<Vec<String>> = prefix.chain(slice_pat.into_iter())\n-                                                      .chain(suffix)\n-                                                      .collect();\n+                    .chain(suffix)\n+                    .collect();\n \n                 // Check that all the rewrites succeeded, and if not return None.\n                 let pats = try_opt!(pats);"}, {"sha": "e90e24f7af2190476da763578924d6f24952ef6e", "filename": "src/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -42,8 +42,8 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     // `cur_start` is the position in `orig` of the start of the current line.\n     let mut cur_start = 0;\n     let mut result = String::with_capacity(stripped_str.len()\n-                                                       .checked_next_power_of_two()\n-                                                       .unwrap_or(usize::max_value()));\n+        .checked_next_power_of_two()\n+        .unwrap_or(usize::max_value()));\n     result.push_str(fmt.opener);\n \n     let ender_length = fmt.line_end.len();"}, {"sha": "a1d449f32492c5d8c38721eb7e83337eedc3300f", "filename": "src/types.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -176,11 +176,11 @@ fn rewrite_segment(expr_context: bool,\n                                                          !data.types.is_empty() ||\n                                                          !data.bindings.is_empty() => {\n             let param_list = data.lifetimes\n-                                 .iter()\n-                                 .map(SegmentParam::LifeTime)\n-                                 .chain(data.types.iter().map(|x| SegmentParam::Type(&*x)))\n-                                 .chain(data.bindings.iter().map(|x| SegmentParam::Binding(&*x)))\n-                                 .collect::<Vec<_>>();\n+                .iter()\n+                .map(SegmentParam::LifeTime)\n+                .chain(data.types.iter().map(|x| SegmentParam::Type(&*x)))\n+                .chain(data.bindings.iter().map(|x| SegmentParam::Binding(&*x)))\n+                .collect::<Vec<_>>();\n \n             let next_span_lo = param_list.last().unwrap().get_span().hi + BytePos(1);\n             let list_lo = context.codemap.span_after(codemap::mk_sp(*span_lo, span_hi), \"<\");\n@@ -270,7 +270,7 @@ fn format_function_type<'a, I>(inputs: I,\n                              // FIXME Would be nice to avoid this allocation,\n                              // but I couldn't get the types to work out.\n                              inputs.map(|i| ArgumentKind::Regular(Box::new(i)))\n-                                   .chain(variadic_arg),\n+                                 .chain(variadic_arg),\n                              \")\",\n                              |arg| {\n                                  match *arg {\n@@ -285,13 +285,11 @@ fn format_function_type<'a, I>(inputs: I,\n                                  }\n                              },\n                              |arg| {\n-                                 match *arg {\n-                                     ArgumentKind::Regular(ref ty) => {\n-                                         ty.rewrite(context, budget, offset)\n-                                     }\n-                                     ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n-                                 }\n-                             },\n+        match *arg {\n+            ArgumentKind::Regular(ref ty) => ty.rewrite(context, budget, offset),\n+            ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n+        }\n+    },\n                              list_lo,\n                              span.hi);\n \n@@ -408,8 +406,8 @@ fn rewrite_bounded_lifetime<'b, I>(lt: &ast::Lifetime,\n         Some(result)\n     } else {\n         let appendix: Vec<_> = try_opt!(bounds.into_iter()\n-                                              .map(|b| b.rewrite(context, width, offset))\n-                                              .collect());\n+            .map(|b| b.rewrite(context, width, offset))\n+            .collect());\n         let result = format!(\"{}: {}\", result, appendix.join(\" + \"));\n         wrap_str(result, context.config.max_width, width, offset)\n     }\n@@ -442,8 +440,8 @@ impl Rewrite for ast::Lifetime {\n impl Rewrite for ast::TyParamBounds {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let strs: Vec<_> = try_opt!(self.iter()\n-                                        .map(|b| b.rewrite(context, width, offset))\n-                                        .collect());\n+            .map(|b| b.rewrite(context, width, offset))\n+            .collect());\n         wrap_str(strs.join(\" + \"), context.config.max_width, width, offset)\n     }\n }\n@@ -456,10 +454,10 @@ impl Rewrite for ast::TyParam {\n             result.push_str(\": \");\n \n             let bounds = try_opt!(self.bounds\n-                                      .iter()\n-                                      .map(|ty_bound| ty_bound.rewrite(context, width, offset))\n-                                      .collect::<Option<Vec<_>>>())\n-                             .join(\" + \");\n+                    .iter()\n+                    .map(|ty_bound| ty_bound.rewrite(context, width, offset))\n+                    .collect::<Option<Vec<_>>>())\n+                .join(\" + \");\n \n             result.push_str(&bounds);\n         }\n@@ -483,15 +481,15 @@ impl Rewrite for ast::PolyTraitRef {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         if !self.bound_lifetimes.is_empty() {\n             let lifetime_str = try_opt!(self.bound_lifetimes\n-                                            .iter()\n-                                            .map(|lt| lt.rewrite(context, width, offset))\n-                                            .collect::<Option<Vec<_>>>())\n-                                   .join(\", \");\n+                    .iter()\n+                    .map(|lt| lt.rewrite(context, width, offset))\n+                    .collect::<Option<Vec<_>>>())\n+                .join(\", \");\n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;\n             let max_path_width = try_opt!(width.checked_sub(extra_offset));\n             let path_str = try_opt!(self.trait_ref\n-                                        .rewrite(context, max_path_width, offset + extra_offset));\n+                .rewrite(context, max_path_width, offset + extra_offset));\n \n             Some(format!(\"for<{}> {}\", lifetime_str, path_str))\n         } else {\n@@ -545,9 +543,8 @@ impl Rewrite for ast::Ty {\n                         format!(\"&{} {}{}\",\n                                 lt_str,\n                                 mut_str,\n-                                try_opt!(mt.ty.rewrite(context,\n-                                                       budget,\n-                                                       offset + 2 + mut_len + lt_len)))\n+                                try_opt!(mt.ty\n+                                    .rewrite(context, budget, offset + 2 + mut_len + lt_len)))\n                     }\n                     None => {\n                         let budget = try_opt!(width.checked_sub(1 + mut_len));"}, {"sha": "da690f1e8ead67cc036518913cffb311dce910e6", "filename": "src/utils.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -142,14 +142,14 @@ pub fn contains_skip(attrs: &[Attribute]) -> bool {\n #[inline]\n pub fn end_typaram(typaram: &ast::TyParam) -> BytePos {\n     typaram.bounds\n-           .last()\n-           .map_or(typaram.span, |bound| {\n-               match *bound {\n-                   ast::RegionTyParamBound(ref lt) => lt.span,\n-                   ast::TraitTyParamBound(ref prt, _) => prt.span,\n-               }\n-           })\n-           .hi\n+        .last()\n+        .map_or(typaram.span, |bound| {\n+            match *bound {\n+                ast::RegionTyParamBound(ref lt) => lt.span,\n+                ast::TraitTyParamBound(ref prt, _) => prt.span,\n+            }\n+        })\n+        .hi\n }\n \n #[inline]"}, {"sha": "8fba02de2d1d4a05b43ce449704894464c23af73", "filename": "src/visitor.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -86,9 +86,9 @@ impl<'a> FmtVisitor<'a> {\n         if let Some(ref e) = b.expr {\n             self.format_missing_with_indent(e.span.lo);\n             let rewrite = e.rewrite(&self.get_context(),\n-                                    self.config.max_width - self.block_indent.width(),\n-                                    self.block_indent)\n-                           .unwrap_or_else(|| self.snippet(e.span));\n+                         self.config.max_width - self.block_indent.width(),\n+                         self.block_indent)\n+                .unwrap_or_else(|| self.snippet(e.span));\n \n             self.buffer.push_str(&rewrite);\n             self.last_pos = e.span.hi;\n@@ -436,9 +436,9 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         let outers: Vec<_> = attrs.iter()\n-                                  .filter(|a| a.node.style == ast::AttrStyle::Outer)\n-                                  .cloned()\n-                                  .collect();\n+            .filter(|a| a.node.style == ast::AttrStyle::Outer)\n+            .cloned()\n+            .collect();\n         if outers.is_empty() {\n             return false;\n         }\n@@ -447,9 +447,9 @@ impl<'a> FmtVisitor<'a> {\n         self.format_missing_with_indent(first.span.lo);\n \n         let rewrite = outers.rewrite(&self.get_context(),\n-                                     self.config.max_width - self.block_indent.width(),\n-                                     self.block_indent)\n-                            .unwrap();\n+                     self.config.max_width - self.block_indent.width(),\n+                     self.block_indent)\n+            .unwrap();\n         self.buffer.push_str(&rewrite);\n         let last = outers.last().unwrap();\n         self.last_pos = last.span.hi;"}, {"sha": "1af9c0f3462f8c13d00d416f3e4396ef87363fd6", "filename": "tests/system.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -85,7 +85,7 @@ fn assert_output(source: &str, expected_filename: &str) {\n     let mut expected_file = fs::File::open(&expected_filename).expect(\"Couldn't open target\");\n     let mut expected_text = String::new();\n     expected_file.read_to_string(&mut expected_text)\n-                 .expect(\"Failed reading target\");\n+        .expect(\"Failed reading target\");\n \n     let compare = make_diff(&expected_text, &output, DIFF_CONTEXT_SIZE);\n     if compare.len() > 0 {\n@@ -267,15 +267,15 @@ fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n         .expect(\"Failed creating pattern 2\");\n \n     reader.lines()\n-          .map(|line| line.expect(\"Failed getting line\"))\n-          .take_while(|line| line_regex.is_match(&line))\n-          .filter_map(|line| {\n-              regex.captures_iter(&line).next().map(|capture| {\n-                  (capture.at(1).expect(\"Couldn't unwrap capture\").to_owned(),\n-                   capture.at(2).expect(\"Couldn't unwrap capture\").to_owned())\n-              })\n-          })\n-          .collect()\n+        .map(|line| line.expect(\"Failed getting line\"))\n+        .take_while(|line| line_regex.is_match(&line))\n+        .filter_map(|line| {\n+            regex.captures_iter(&line).next().map(|capture| {\n+                (capture.at(1).expect(\"Couldn't unwrap capture\").to_owned(),\n+                 capture.at(2).expect(\"Couldn't unwrap capture\").to_owned())\n+            })\n+        })\n+        .collect()\n }\n \n // Compare output to input."}, {"sha": "2c78fbd91219a12904d2a7052bc2138da1a4b6ba", "filename": "tests/target/chains-no-overflow.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/tests%2Ftarget%2Fchains-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/tests%2Ftarget%2Fchains-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-no-overflow.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -3,16 +3,16 @@\n \n fn main() {\n     bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n-                       .ddddddddddddddddddddddddddd();\n+        .ddddddddddddddddddddddddddd();\n \n     bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n-                       .ddddddddddddddddddddddddddd\n-                       .eeeeeeee();\n+        .ddddddddddddddddddddddddddd\n+        .eeeeeeee();\n \n     x().y(|| match cond() {\n-           true => (),\n-           false => (),\n-       });\n+            true => (),\n+            false => (),\n+        });\n \n     loong_func()\n         .quux(move || if true {\n@@ -24,19 +24,17 @@ fn main() {\n     fffffffffffffffffffffffffffffffffff(a,\n                                         {\n                                             SCRIPT_TASK_ROOT.with(|root| {\n-                                                                *root.borrow_mut() =\n-                                                                    Some(&script_task);\n-                                                            });\n+                                                    *root.borrow_mut() = Some(&script_task);\n+                                                });\n                                         });\n \n     let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx.map(|x| x + 5)\n-                                                                          .map(|x| x / 2)\n-                                                                          .fold(0,\n-                                                                                |acc, x| acc + x);\n+        .map(|x| x / 2)\n+        .fold(0, |acc, x| acc + x);\n \n     aaaaaaaaaaaaaaaa.map(|x| {\n-                        x += 1;\n-                        x\n-                    })\n-                    .filter(some_mod::some_filter)\n+            x += 1;\n+            x\n+        })\n+        .filter(some_mod::some_filter)\n }"}, {"sha": "c11070913d9e9634b127d9f3c038b04ebc4b0c98", "filename": "tests/target/chains-no-overlow-2.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/tests%2Ftarget%2Fchains-no-overlow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/tests%2Ftarget%2Fchains-no-overlow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-no-overlow-2.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -2,15 +2,15 @@\n \n fn main() {\n     reader.lines()\n-          .map(|line| line.expect(\"Failed getting line\"))\n-          .take_while(|line| line_regex.is_match(&line))\n-          .filter_map(|line| {\n-              regex.captures_iter(&line)\n-                   .next()\n-                   .map(|capture| {\n-                       (capture.at(1).expect(\"Couldn\\'t unwrap capture\").to_owned(),\n-                        capture.at(2).expect(\"Couldn\\'t unwrap capture\").to_owned())\n-                   })\n-          })\n-          .collect();\n+        .map(|line| line.expect(\"Failed getting line\"))\n+        .take_while(|line| line_regex.is_match(&line))\n+        .filter_map(|line| {\n+            regex.captures_iter(&line)\n+                .next()\n+                .map(|capture| {\n+                    (capture.at(1).expect(\"Couldn\\'t unwrap capture\").to_owned(),\n+                     capture.at(2).expect(\"Couldn\\'t unwrap capture\").to_owned())\n+                })\n+        })\n+        .collect();\n }"}, {"sha": "aacdb8e93e151f0fcdbce36aaee9009b6afb8038", "filename": "tests/target/chains.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -3,16 +3,16 @@\n fn main() {\n     // Don't put chains on a single line if it wasn't so in source.\n     let a = b.c\n-             .d\n-             .1\n-             .foo(|x| x + 1);\n+        .d\n+        .1\n+        .foo(|x| x + 1);\n \n     bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n-                       .ddddddddddddddddddddddddddd();\n+        .ddddddddddddddddddddddddddd();\n \n     bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n-                       .ddddddddddddddddddddddddddd\n-                       .eeeeeeee();\n+        .ddddddddddddddddddddddddddd\n+        .eeeeeeee();\n \n     // Test case where first chain element isn't a path, but is shorter than\n     // the size of a tab.\n@@ -49,15 +49,14 @@ fn main() {\n     });\n \n     let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx.map(|x| x + 5)\n-                                                                          .map(|x| x / 2)\n-                                                                          .fold(0,\n-                                                                                |acc, x| acc + x);\n+        .map(|x| x / 2)\n+        .fold(0, |acc, x| acc + x);\n \n     aaaaaaaaaaaaaaaa.map(|x| {\n-                        x += 1;\n-                        x\n-                    })\n-                    .filter(some_mod::some_filter)\n+            x += 1;\n+            x\n+        })\n+        .filter(some_mod::some_filter)\n }\n \n fn floaters() {\n@@ -67,39 +66,39 @@ fn floaters() {\n     };\n \n     let x = Foo {\n-                field1: val1,\n-                field2: val2,\n-            }\n-            .method_call()\n-            .method_call();\n+            field1: val1,\n+            field2: val2,\n+        }\n+        .method_call()\n+        .method_call();\n \n     let y = if cond {\n-                val1\n-            } else {\n-                val2\n-            }\n-            .method_call();\n+            val1\n+        } else {\n+            val2\n+        }\n+        .method_call();\n \n     {\n         match x {\n             PushParam => {\n                 // params are 1-indexed\n                 stack.push(mparams[match cur.to_digit(10) {\n-                               Some(d) => d as usize - 1,\n-                               None => return Err(\"bad param number\".to_owned()),\n-                           }]\n-                           .clone());\n+                        Some(d) => d as usize - 1,\n+                        None => return Err(\"bad param number\".to_owned()),\n+                    }]\n+                    .clone());\n             }\n         }\n     }\n \n     if cond {\n-        some();\n-    } else {\n-        none();\n-    }\n-    .bar()\n-    .baz();\n+            some();\n+        } else {\n+            none();\n+        }\n+        .bar()\n+        .baz();\n \n     Foo { x: val }\n         .baz(|| {\n@@ -108,25 +107,25 @@ fn floaters() {\n         .quux();\n \n     Foo {\n-        y: i_am_multi_line,\n-        z: ok,\n-    }\n-    .baz(|| {\n-        // force multiline\n-    })\n-    .quux();\n+            y: i_am_multi_line,\n+            z: ok,\n+        }\n+        .baz(|| {\n+            // force multiline\n+        })\n+        .quux();\n \n     a +\n     match x {\n-        true => \"yay!\",\n-        false => \"boo!\",\n-    }\n-    .bar()\n+            true => \"yay!\",\n+            false => \"boo!\",\n+        }\n+        .bar()\n }\n \n fn is_replaced_content() -> bool {\n     constellat.send(ConstellationMsg::ViewportConstrained(self.id, constraints))\n-              .unwrap();\n+        .unwrap();\n }\n \n fn issue587() {"}, {"sha": "0914959ceb104e8ec33155f39b23d7fb1ebcb3dd", "filename": "tests/target/hard-tabs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/tests%2Ftarget%2Fhard-tabs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/tests%2Ftarget%2Fhard-tabs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fhard-tabs.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -88,8 +88,8 @@ fn main() {\n \t\t});\n \t});\n \ta.b\n-\t .c\n-\t .d();\n+\t\t.c\n+\t\t.d();\n \n \tx().y(|| {\n \t\tmatch cond() {"}, {"sha": "e4efd86b7f9e62c2771cf3534a4710af4cdd7ba6", "filename": "tests/target/long_field_access.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/tests%2Ftarget%2Flong_field_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e/tests%2Ftarget%2Flong_field_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Flong_field_access.rs?ref=a9c3108c9cd6267ebaf2489fb65a07b88a4f9d4e", "patch": "@@ -1,4 +1,4 @@\n fn f() {\n-    block_flow.base.stacking_relative_position_of_display_port =\n-        self.base.stacking_relative_position_of_display_port;\n+    block_flow.base.stacking_relative_position_of_display_port = self.base\n+        .stacking_relative_position_of_display_port;\n }"}]}