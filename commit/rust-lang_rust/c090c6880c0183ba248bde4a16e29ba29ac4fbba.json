{"sha": "c090c6880c0183ba248bde4a16e29ba29ac4fbba", "node_id": "C_kwDOAAsO6NoAKGMwOTBjNjg4MGMwMTgzYmEyNDhiZGU0YTE2ZTI5YmEyOWFjNGZiYmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-01T17:47:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-01T17:47:12Z"}, "message": "Auto merge of #105125 - matthiaskrgr:rollup-fr0snmj, r=matthiaskrgr\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #105078 (Fix `expr_to_spanned_string` ICE)\n - #105087 (Extract llvm datalayout parsing out of spec module)\n - #105088 (rustdoc: remove redundant CSS `div.desc { display: block }`)\n - #105106 (Fix ICE from #105101)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "1555cb75b5510b53b9084d6f7ec626a31f6ee24a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1555cb75b5510b53b9084d6f7ec626a31f6ee24a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c090c6880c0183ba248bde4a16e29ba29ac4fbba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c090c6880c0183ba248bde4a16e29ba29ac4fbba", "html_url": "https://github.com/rust-lang/rust/commit/c090c6880c0183ba248bde4a16e29ba29ac4fbba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c090c6880c0183ba248bde4a16e29ba29ac4fbba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "367ecffe5297260f11e71881125a5589c8cb5350", "url": "https://api.github.com/repos/rust-lang/rust/commits/367ecffe5297260f11e71881125a5589c8cb5350", "html_url": "https://github.com/rust-lang/rust/commit/367ecffe5297260f11e71881125a5589c8cb5350"}, {"sha": "ee9eaa695c22de6ffa1edadc4b98b0c0e2e258f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee9eaa695c22de6ffa1edadc4b98b0c0e2e258f8", "html_url": "https://github.com/rust-lang/rust/commit/ee9eaa695c22de6ffa1edadc4b98b0c0e2e258f8"}], "stats": {"total": 256, "additions": 156, "deletions": 100}, "files": [{"sha": "85693259cd0153eb02fbb6b0b8424a9fe69a7124", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c090c6880c0183ba248bde4a16e29ba29ac4fbba/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c090c6880c0183ba248bde4a16e29ba29ac4fbba/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=c090c6880c0183ba248bde4a16e29ba29ac4fbba", "patch": "@@ -211,6 +211,102 @@ pub enum TargetDataLayoutErrors<'a> {\n }\n \n impl TargetDataLayout {\n+    /// Parse data layout from an [llvm data layout string](https://llvm.org/docs/LangRef.html#data-layout)\n+    ///\n+    /// This function doesn't fill `c_enum_min_size` and it will always be `I32` since it can not be\n+    /// determined from llvm string.\n+    pub fn parse_from_llvm_datalayout_string<'a>(\n+        input: &'a str,\n+    ) -> Result<TargetDataLayout, TargetDataLayoutErrors<'a>> {\n+        // Parse an address space index from a string.\n+        let parse_address_space = |s: &'a str, cause: &'a str| {\n+            s.parse::<u32>().map(AddressSpace).map_err(|err| {\n+                TargetDataLayoutErrors::InvalidAddressSpace { addr_space: s, cause, err }\n+            })\n+        };\n+\n+        // Parse a bit count from a string.\n+        let parse_bits = |s: &'a str, kind: &'a str, cause: &'a str| {\n+            s.parse::<u64>().map_err(|err| TargetDataLayoutErrors::InvalidBits {\n+                kind,\n+                bit: s,\n+                cause,\n+                err,\n+            })\n+        };\n+\n+        // Parse a size string.\n+        let size = |s: &'a str, cause: &'a str| parse_bits(s, \"size\", cause).map(Size::from_bits);\n+\n+        // Parse an alignment string.\n+        let align = |s: &[&'a str], cause: &'a str| {\n+            if s.is_empty() {\n+                return Err(TargetDataLayoutErrors::MissingAlignment { cause });\n+            }\n+            let align_from_bits = |bits| {\n+                Align::from_bits(bits)\n+                    .map_err(|err| TargetDataLayoutErrors::InvalidAlignment { cause, err })\n+            };\n+            let abi = parse_bits(s[0], \"alignment\", cause)?;\n+            let pref = s.get(1).map_or(Ok(abi), |pref| parse_bits(pref, \"alignment\", cause))?;\n+            Ok(AbiAndPrefAlign { abi: align_from_bits(abi)?, pref: align_from_bits(pref)? })\n+        };\n+\n+        let mut dl = TargetDataLayout::default();\n+        let mut i128_align_src = 64;\n+        for spec in input.split('-') {\n+            let spec_parts = spec.split(':').collect::<Vec<_>>();\n+\n+            match &*spec_parts {\n+                [\"e\"] => dl.endian = Endian::Little,\n+                [\"E\"] => dl.endian = Endian::Big,\n+                [p] if p.starts_with('P') => {\n+                    dl.instruction_address_space = parse_address_space(&p[1..], \"P\")?\n+                }\n+                [\"a\", ref a @ ..] => dl.aggregate_align = align(a, \"a\")?,\n+                [\"f32\", ref a @ ..] => dl.f32_align = align(a, \"f32\")?,\n+                [\"f64\", ref a @ ..] => dl.f64_align = align(a, \"f64\")?,\n+                [p @ \"p\", s, ref a @ ..] | [p @ \"p0\", s, ref a @ ..] => {\n+                    dl.pointer_size = size(s, p)?;\n+                    dl.pointer_align = align(a, p)?;\n+                }\n+                [s, ref a @ ..] if s.starts_with('i') => {\n+                    let Ok(bits) = s[1..].parse::<u64>() else {\n+                        size(&s[1..], \"i\")?; // For the user error.\n+                        continue;\n+                    };\n+                    let a = align(a, s)?;\n+                    match bits {\n+                        1 => dl.i1_align = a,\n+                        8 => dl.i8_align = a,\n+                        16 => dl.i16_align = a,\n+                        32 => dl.i32_align = a,\n+                        64 => dl.i64_align = a,\n+                        _ => {}\n+                    }\n+                    if bits >= i128_align_src && bits <= 128 {\n+                        // Default alignment for i128 is decided by taking the alignment of\n+                        // largest-sized i{64..=128}.\n+                        i128_align_src = bits;\n+                        dl.i128_align = a;\n+                    }\n+                }\n+                [s, ref a @ ..] if s.starts_with('v') => {\n+                    let v_size = size(&s[1..], \"v\")?;\n+                    let a = align(a, s)?;\n+                    if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {\n+                        v.1 = a;\n+                        continue;\n+                    }\n+                    // No existing entry, add a new one.\n+                    dl.vector_align.push((v_size, a));\n+                }\n+                _ => {} // Ignore everything else.\n+            }\n+        }\n+        Ok(dl)\n+    }\n+\n     /// Returns exclusive upper bound on object size.\n     ///\n     /// The theoretical maximum object size is defined as the maximum positive `isize` value."}, {"sha": "e88d2e409c63b0c95e1e900a7bac12d5e14c4081", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c090c6880c0183ba248bde4a16e29ba29ac4fbba/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c090c6880c0183ba248bde4a16e29ba29ac4fbba/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=c090c6880c0183ba248bde4a16e29ba29ac4fbba", "patch": "@@ -145,7 +145,7 @@ fn extract_default_variant<'a>(\n                 let suggestion = default_variants\n                     .iter()\n                     .filter_map(|v| {\n-                        if v.ident == variant.ident {\n+                        if v.span == variant.span {\n                             None\n                         } else {\n                             Some((cx.sess.find_by_name(&v.attrs, kw::Default)?.span, String::new()))"}, {"sha": "13e2d1ebbe7869530fc7e514d3884e3f6dd55926", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c090c6880c0183ba248bde4a16e29ba29ac4fbba/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c090c6880c0183ba248bde4a16e29ba29ac4fbba/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=c090c6880c0183ba248bde4a16e29ba29ac4fbba", "patch": "@@ -16,6 +16,7 @@ use rustc_errors::{\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics};\n use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n+use rustc_session::errors::report_lit_error;\n use rustc_session::{parse::ParseSess, Limit, Session};\n use rustc_span::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_span::edition::Edition;\n@@ -1245,7 +1246,10 @@ pub fn expr_to_spanned_string<'a>(\n                 Some((err, true))\n             }\n             Ok(ast::LitKind::Err) => None,\n-            Err(_) => None,\n+            Err(err) => {\n+                report_lit_error(&cx.sess.parse_sess, err, token_lit, expr.span);\n+                None\n+            }\n             _ => Some((cx.struct_span_err(expr.span, err_msg), false)),\n         },\n         ast::ExprKind::Err => None,"}, {"sha": "9aa8a06c6d36e3d39c5b51f0d2afee2712a300cc", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c090c6880c0183ba248bde4a16e29ba29ac4fbba/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c090c6880c0183ba248bde4a16e29ba29ac4fbba/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=c090c6880c0183ba248bde4a16e29ba29ac4fbba", "patch": "@@ -197,12 +197,12 @@ pub enum UnleashedFeatureHelp {\n \n #[derive(Diagnostic)]\n #[diag(session_invalid_literal_suffix)]\n-pub(crate) struct InvalidLiteralSuffix {\n+pub(crate) struct InvalidLiteralSuffix<'a> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n     // FIXME(#100717)\n-    pub kind: String,\n+    pub kind: &'a str,\n     pub suffix: Symbol,\n }\n \n@@ -311,11 +311,7 @@ pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span:\n         LitError::LexerError => {}\n         LitError::InvalidSuffix => {\n             if let Some(suffix) = suffix {\n-                sess.emit_err(InvalidLiteralSuffix {\n-                    span,\n-                    kind: format!(\"{}\", kind.descr()),\n-                    suffix,\n-                });\n+                sess.emit_err(InvalidLiteralSuffix { span, kind: kind.descr(), suffix });\n             }\n         }\n         LitError::InvalidIntSuffix => {"}, {"sha": "78315afa759561080a7f479c8e595d5046a2c975", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 2, "deletions": 90, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c090c6880c0183ba248bde4a16e29ba29ac4fbba/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c090c6880c0183ba248bde4a16e29ba29ac4fbba/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=c090c6880c0183ba248bde4a16e29ba29ac4fbba", "patch": "@@ -35,10 +35,7 @@\n //! to the list specified by the target, rather than replace.\n \n use crate::abi::call::Conv;\n-use crate::abi::{\n-    AbiAndPrefAlign, AddressSpace, Align, Endian, Integer, Size, TargetDataLayout,\n-    TargetDataLayoutErrors,\n-};\n+use crate::abi::{Endian, Integer, Size, TargetDataLayout, TargetDataLayoutErrors};\n use crate::json::{Json, ToJson};\n use crate::spec::abi::{lookup as lookup_abi, Abi};\n use crate::spec::crt_objects::{CrtObjects, LinkSelfContainedDefault};\n@@ -1322,92 +1319,7 @@ pub struct Target {\n \n impl Target {\n     pub fn parse_data_layout<'a>(&'a self) -> Result<TargetDataLayout, TargetDataLayoutErrors<'a>> {\n-        // Parse an address space index from a string.\n-        let parse_address_space = |s: &'a str, cause: &'a str| {\n-            s.parse::<u32>().map(AddressSpace).map_err(|err| {\n-                TargetDataLayoutErrors::InvalidAddressSpace { addr_space: s, cause, err }\n-            })\n-        };\n-\n-        // Parse a bit count from a string.\n-        let parse_bits = |s: &'a str, kind: &'a str, cause: &'a str| {\n-            s.parse::<u64>().map_err(|err| TargetDataLayoutErrors::InvalidBits {\n-                kind,\n-                bit: s,\n-                cause,\n-                err,\n-            })\n-        };\n-\n-        // Parse a size string.\n-        let size = |s: &'a str, cause: &'a str| parse_bits(s, \"size\", cause).map(Size::from_bits);\n-\n-        // Parse an alignment string.\n-        let align = |s: &[&'a str], cause: &'a str| {\n-            if s.is_empty() {\n-                return Err(TargetDataLayoutErrors::MissingAlignment { cause });\n-            }\n-            let align_from_bits = |bits| {\n-                Align::from_bits(bits)\n-                    .map_err(|err| TargetDataLayoutErrors::InvalidAlignment { cause, err })\n-            };\n-            let abi = parse_bits(s[0], \"alignment\", cause)?;\n-            let pref = s.get(1).map_or(Ok(abi), |pref| parse_bits(pref, \"alignment\", cause))?;\n-            Ok(AbiAndPrefAlign { abi: align_from_bits(abi)?, pref: align_from_bits(pref)? })\n-        };\n-\n-        let mut dl = TargetDataLayout::default();\n-        let mut i128_align_src = 64;\n-        for spec in self.data_layout.split('-') {\n-            let spec_parts = spec.split(':').collect::<Vec<_>>();\n-\n-            match &*spec_parts {\n-                [\"e\"] => dl.endian = Endian::Little,\n-                [\"E\"] => dl.endian = Endian::Big,\n-                [p] if p.starts_with('P') => {\n-                    dl.instruction_address_space = parse_address_space(&p[1..], \"P\")?\n-                }\n-                [\"a\", ref a @ ..] => dl.aggregate_align = align(a, \"a\")?,\n-                [\"f32\", ref a @ ..] => dl.f32_align = align(a, \"f32\")?,\n-                [\"f64\", ref a @ ..] => dl.f64_align = align(a, \"f64\")?,\n-                [p @ \"p\", s, ref a @ ..] | [p @ \"p0\", s, ref a @ ..] => {\n-                    dl.pointer_size = size(s, p)?;\n-                    dl.pointer_align = align(a, p)?;\n-                }\n-                [s, ref a @ ..] if s.starts_with('i') => {\n-                    let Ok(bits) = s[1..].parse::<u64>() else {\n-                        size(&s[1..], \"i\")?; // For the user error.\n-                        continue;\n-                    };\n-                    let a = align(a, s)?;\n-                    match bits {\n-                        1 => dl.i1_align = a,\n-                        8 => dl.i8_align = a,\n-                        16 => dl.i16_align = a,\n-                        32 => dl.i32_align = a,\n-                        64 => dl.i64_align = a,\n-                        _ => {}\n-                    }\n-                    if bits >= i128_align_src && bits <= 128 {\n-                        // Default alignment for i128 is decided by taking the alignment of\n-                        // largest-sized i{64..=128}.\n-                        i128_align_src = bits;\n-                        dl.i128_align = a;\n-                    }\n-                }\n-                [s, ref a @ ..] if s.starts_with('v') => {\n-                    let v_size = size(&s[1..], \"v\")?;\n-                    let a = align(a, s)?;\n-                    if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {\n-                        v.1 = a;\n-                        continue;\n-                    }\n-                    // No existing entry, add a new one.\n-                    dl.vector_align.push((v_size, a));\n-                }\n-                _ => {} // Ignore everything else.\n-            }\n-        }\n+        let mut dl = TargetDataLayout::parse_from_llvm_datalayout_string(&self.data_layout)?;\n \n         // Perform consistency checks against the Target information.\n         if dl.endian != self.endian {"}, {"sha": "7e41d80f5460f499f60e1a823757ac4c1eb38e38", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c090c6880c0183ba248bde4a16e29ba29ac4fbba/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/c090c6880c0183ba248bde4a16e29ba29ac4fbba/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=c090c6880c0183ba248bde4a16e29ba29ac4fbba", "patch": "@@ -894,7 +894,6 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \twhite-space: nowrap;\n \ttext-overflow: ellipsis;\n \toverflow: hidden;\n-\tdisplay: block;\n }\n \n .search-results a:hover,"}, {"sha": "1a377feb91948aecf12cda6f987e2b5d0caa2346", "filename": "src/test/ui/deriving/issue-105101.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c090c6880c0183ba248bde4a16e29ba29ac4fbba/src%2Ftest%2Fui%2Fderiving%2Fissue-105101.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c090c6880c0183ba248bde4a16e29ba29ac4fbba/src%2Ftest%2Fui%2Fderiving%2Fissue-105101.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fissue-105101.rs?ref=c090c6880c0183ba248bde4a16e29ba29ac4fbba", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags: --crate-type=lib\n+\n+#[derive(Default)] //~ ERROR multiple declared defaults\n+enum E {\n+    #[default]\n+    A,\n+    #[default]\n+    A, //~ ERROR defined multiple times\n+}"}, {"sha": "0f6f67043f32fdb378b459b4e18b215ee2ca2b08", "filename": "src/test/ui/deriving/issue-105101.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c090c6880c0183ba248bde4a16e29ba29ac4fbba/src%2Ftest%2Fui%2Fderiving%2Fissue-105101.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c090c6880c0183ba248bde4a16e29ba29ac4fbba/src%2Ftest%2Fui%2Fderiving%2Fissue-105101.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fissue-105101.stderr?ref=c090c6880c0183ba248bde4a16e29ba29ac4fbba", "patch": "@@ -0,0 +1,29 @@\n+error: multiple declared defaults\n+  --> $DIR/issue-105101.rs:3:10\n+   |\n+LL | #[derive(Default)]\n+   |          ^^^^^^^\n+...\n+LL |     A,\n+   |     - first default\n+LL |     #[default]\n+LL |     A,\n+   |     - additional default\n+   |\n+   = note: only one variant can be default\n+   = note: this error originates in the derive macro `Default` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0428]: the name `A` is defined multiple times\n+  --> $DIR/issue-105101.rs:8:5\n+   |\n+LL |     A,\n+   |     - previous definition of the type `A` here\n+LL |     #[default]\n+LL |     A,\n+   |     ^ `A` redefined here\n+   |\n+   = note: `A` must be defined only once in the type namespace of this enum\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0428`."}, {"sha": "da12c381464e1d4b7faac1d1de43084e785718e6", "filename": "src/test/ui/macros/issue-105011.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c090c6880c0183ba248bde4a16e29ba29ac4fbba/src%2Ftest%2Fui%2Fmacros%2Fissue-105011.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c090c6880c0183ba248bde4a16e29ba29ac4fbba/src%2Ftest%2Fui%2Fmacros%2Fissue-105011.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-105011.rs?ref=c090c6880c0183ba248bde4a16e29ba29ac4fbba", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    println!(\"\"y); //~ ERROR suffixes on string literals are invalid\n+}"}, {"sha": "e898af7faa30aeb4072552dfe20d789ce41de156", "filename": "src/test/ui/macros/issue-105011.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c090c6880c0183ba248bde4a16e29ba29ac4fbba/src%2Ftest%2Fui%2Fmacros%2Fissue-105011.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c090c6880c0183ba248bde4a16e29ba29ac4fbba/src%2Ftest%2Fui%2Fmacros%2Fissue-105011.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-105011.stderr?ref=c090c6880c0183ba248bde4a16e29ba29ac4fbba", "patch": "@@ -0,0 +1,8 @@\n+error: suffixes on string literals are invalid\n+  --> $DIR/issue-105011.rs:2:14\n+   |\n+LL |     println!(\"\"y);\n+   |              ^^^ invalid suffix `y`\n+\n+error: aborting due to previous error\n+"}]}