{"sha": "8fe73f1166c0d3765cabb26680b82175ec4429cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZTczZjExNjZjMGQzNzY1Y2FiYjI2NjgwYjgyMTc1ZWM0NDI5Y2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-06T23:41:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-06T23:41:05Z"}, "message": "auto merge of #16291 : nham/rust/byte_literals, r=alexcrichton\n\nThis replaces many instances chars being casted to u8 with byte literals.", "tree": {"sha": "966974cfdd23237b4efb972dd9ce8c30a7cfca63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/966974cfdd23237b4efb972dd9ce8c30a7cfca63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fe73f1166c0d3765cabb26680b82175ec4429cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fe73f1166c0d3765cabb26680b82175ec4429cd", "html_url": "https://github.com/rust-lang/rust/commit/8fe73f1166c0d3765cabb26680b82175ec4429cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fe73f1166c0d3765cabb26680b82175ec4429cd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9308d1ff0b32598e791a0a68f68cf7e09a07f22", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9308d1ff0b32598e791a0a68f68cf7e09a07f22", "html_url": "https://github.com/rust-lang/rust/commit/b9308d1ff0b32598e791a0a68f68cf7e09a07f22"}, {"sha": "96d1712511400be7956e0902e0b4bb32ad7ee34d", "url": "https://api.github.com/repos/rust-lang/rust/commits/96d1712511400be7956e0902e0b4bb32ad7ee34d", "html_url": "https://github.com/rust-lang/rust/commit/96d1712511400be7956e0902e0b4bb32ad7ee34d"}], "stats": {"total": 265, "additions": 131, "deletions": 134}, "files": [{"sha": "270b76fd57fc95cd5949349be4d7c52e6fbaa1de", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -1457,7 +1457,7 @@ mod tests {\n             109\n         ];\n         assert_eq!(\"\".as_bytes(), &[]);\n-        assert_eq!(\"abc\".as_bytes(), &['a' as u8, 'b' as u8, 'c' as u8]);\n+        assert_eq!(\"abc\".as_bytes(), b\"abc\");\n         assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v.as_slice());\n     }\n \n@@ -1475,11 +1475,11 @@ mod tests {\n     fn test_as_ptr() {\n         let buf = \"hello\".as_ptr();\n         unsafe {\n-            assert_eq!(*buf.offset(0), 'h' as u8);\n-            assert_eq!(*buf.offset(1), 'e' as u8);\n-            assert_eq!(*buf.offset(2), 'l' as u8);\n-            assert_eq!(*buf.offset(3), 'l' as u8);\n-            assert_eq!(*buf.offset(4), 'o' as u8);\n+            assert_eq!(*buf.offset(0), b'h');\n+            assert_eq!(*buf.offset(1), b'e');\n+            assert_eq!(*buf.offset(2), b'l');\n+            assert_eq!(*buf.offset(3), b'l');\n+            assert_eq!(*buf.offset(4), b'o');\n         }\n     }\n "}, {"sha": "9465fea6dcbee1180669fb8bfd4775e522aebe6f", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -1040,7 +1040,7 @@ mod tests {\n     fn test_push_bytes() {\n         let mut s = String::from_str(\"ABC\");\n         unsafe {\n-            s.push_bytes([ 'D' as u8 ]);\n+            s.push_bytes([b'D']);\n         }\n         assert_eq!(s.as_slice(), \"ABCD\");\n     }"}, {"sha": "88702e59e30d165833278b3a5851930aa6f2e0ec", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -198,11 +198,11 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n     // Decide what sign to put in front\n     match sign {\n         SignNeg | SignAll if neg => {\n-            buf[end] = '-' as u8;\n+            buf[end] = b'-';\n             end += 1;\n         }\n         SignAll => {\n-            buf[end] = '+' as u8;\n+            buf[end] = b'+';\n             end += 1;\n         }\n         _ => ()\n@@ -218,7 +218,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n     // Now emit the fractional part, if any\n     deccum = num.fract();\n     if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n-        buf[end] = '.' as u8;\n+        buf[end] = b'.';\n         end += 1;\n         let mut dig = 0u;\n \n@@ -269,8 +269,8 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n                     // If reached left end of number, have to\n                     // insert additional digit:\n                     if i < 0\n-                    || buf[i as uint] == '-' as u8\n-                    || buf[i as uint] == '+' as u8 {\n+                    || buf[i as uint] == b'-'\n+                    || buf[i as uint] == b'+' {\n                         for j in range(i as uint + 1, end).rev() {\n                             buf[j + 1] = buf[j];\n                         }\n@@ -280,7 +280,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n                     }\n \n                     // Skip the '.'\n-                    if buf[i as uint] == '.' as u8 { i -= 1; continue; }\n+                    if buf[i as uint] == b'.' { i -= 1; continue; }\n \n                     // Either increment the digit,\n                     // or set to 0 if max and carry the 1.\n@@ -306,14 +306,14 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n         let mut i = buf_max_i;\n \n         // discover trailing zeros of fractional part\n-        while i > start_fractional_digits && buf[i] == '0' as u8 {\n+        while i > start_fractional_digits && buf[i] == b'0' {\n             i -= 1;\n         }\n \n         // Only attempt to truncate digits if buf has fractional digits\n         if i >= start_fractional_digits {\n             // If buf ends with '.', cut that too.\n-            if buf[i] == '.' as u8 { i -= 1 }\n+            if buf[i] == b'.' { i -= 1 }\n \n             // only resize buf if we actually remove digits\n             if i < buf_max_i {\n@@ -323,7 +323,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n     } // If exact and trailing '.', just cut that\n     else {\n         let max_i = end - 1;\n-        if buf[max_i] == '.' as u8 {\n+        if buf[max_i] == b'.' {\n             end = max_i;\n         }\n     }"}, {"sha": "99920dc7881901cc2a0eb7324b544337ef235f98", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -104,13 +104,13 @@ macro_rules! radix {\n     }\n }\n \n-radix!(Binary,    2, \"0b\", x @  0 .. 2 => '0' as u8 + x)\n-radix!(Octal,     8, \"0o\", x @  0 .. 7 => '0' as u8 + x)\n-radix!(Decimal,  10, \"\",   x @  0 .. 9 => '0' as u8 + x)\n-radix!(LowerHex, 16, \"0x\", x @  0 .. 9 => '0' as u8 + x,\n-                           x @ 10 ..15 => 'a' as u8 + (x - 10))\n-radix!(UpperHex, 16, \"0x\", x @  0 .. 9 => '0' as u8 + x,\n-                           x @ 10 ..15 => 'A' as u8 + (x - 10))\n+radix!(Binary,    2, \"0b\", x @  0 .. 2 => b'0' + x)\n+radix!(Octal,     8, \"0o\", x @  0 .. 7 => b'0' + x)\n+radix!(Decimal,  10, \"\",   x @  0 .. 9 => b'0' + x)\n+radix!(LowerHex, 16, \"0x\", x @  0 .. 9 => b'0' + x,\n+                           x @ 10 ..15 => b'a' + (x - 10))\n+radix!(UpperHex, 16, \"0x\", x @  0 .. 9 => b'0' + x,\n+                           x @ 10 ..15 => b'A' + (x - 10))\n \n /// A radix with in the range of `2..36`.\n #[deriving(Clone, PartialEq)]\n@@ -129,8 +129,8 @@ impl GenericRadix for Radix {\n     fn base(&self) -> u8 { self.base }\n     fn digit(&self, x: u8) -> u8 {\n         match x {\n-            x @  0 ..9 => '0' as u8 + x,\n-            x if x < self.base() => 'a' as u8 + (x - 10),\n+            x @  0 ..9 => b'0' + x,\n+            x if x < self.base() => b'a' + (x - 10),\n             x => fail!(\"number not in the range 0..{}: {}\", self.base() - 1, x),\n         }\n     }"}, {"sha": "5eb463687904c41b34119f3b0b85ca5daeba3324", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -1755,7 +1755,7 @@ impl<'a> StrSlice<'a> for &'a str {\n     fn lines_any(&self) -> AnyLines<'a> {\n         self.lines().map(|line| {\n             let l = line.len();\n-            if l > 0 && line.as_bytes()[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n+            if l > 0 && line.as_bytes()[l - 1] == b'\\r' { line.slice(0, l - 1) }\n             else { line }\n         })\n     }"}, {"sha": "b85097e6623dc9d83dd5f7061b61999bcb32e32c", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -165,11 +165,11 @@ impl<'a> ReprVisitor<'a> {\n     }\n \n     pub fn write_escaped_slice(&mut self, slice: &str) -> bool {\n-        try!(self, self.writer.write(['\"' as u8]));\n+        try!(self, self.writer.write([b'\"']));\n         for ch in slice.chars() {\n             if !self.write_escaped_char(ch, true) { return false }\n         }\n-        try!(self, self.writer.write(['\"' as u8]));\n+        try!(self, self.writer.write([b'\"']));\n         true\n     }\n \n@@ -188,7 +188,7 @@ impl<'a> ReprVisitor<'a> {\n                            inner: *const TyDesc) -> bool {\n         let mut p = ptr as *const u8;\n         let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n-        try!(self, self.writer.write(['[' as u8]));\n+        try!(self, self.writer.write([b'[']));\n         let mut first = true;\n         let mut left = len;\n         // unit structs have 0 size, and don't loop forever.\n@@ -203,7 +203,7 @@ impl<'a> ReprVisitor<'a> {\n             p = align(unsafe { p.offset(sz as int) as uint }, al) as *const u8;\n             left -= dec;\n         }\n-        try!(self, self.writer.write([']' as u8]));\n+        try!(self, self.writer.write([b']']));\n         true\n     }\n \n@@ -263,9 +263,9 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_char(&mut self) -> bool {\n         self.get::<char>(|this, &ch| {\n-            try!(this, this.writer.write(['\\'' as u8]));\n+            try!(this, this.writer.write([b'\\'']));\n             if !this.write_escaped_char(ch, false) { return false }\n-            try!(this, this.writer.write(['\\'' as u8]));\n+            try!(this, this.writer.write([b'\\'']));\n             true\n         })\n     }\n@@ -310,7 +310,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     fn visit_rptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n-        try!(self, self.writer.write(['&' as u8]));\n+        try!(self, self.writer.write([b'&']));\n         self.write_mut_qualifier(mtbl);\n         self.get::<*const u8>(|this, p| {\n             this.visit_ptr_inner(*p, inner)\n@@ -319,7 +319,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         self.get::<raw::Slice<()>>(|this, s| {\n-            try!(this, this.writer.write(['&' as u8]));\n+            try!(this, this.writer.write([b'&']));\n             this.write_mut_qualifier(mtbl);\n             let size = unsafe {\n                 if (*inner).size == 0 { 1 } else { (*inner).size }\n@@ -338,7 +338,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_enter_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write(['{' as u8]));\n+        try!(self, self.writer.write([b'{']));\n         true\n     }\n \n@@ -356,7 +356,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_leave_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write(['}' as u8]));\n+        try!(self, self.writer.write([b'}']));\n         true\n     }\n \n@@ -365,9 +365,9 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         try!(self, self.writer.write(name.as_bytes()));\n         if n_fields != 0 {\n             if named_fields {\n-                try!(self, self.writer.write(['{' as u8]));\n+                try!(self, self.writer.write([b'{']));\n             } else {\n-                try!(self, self.writer.write(['(' as u8]));\n+                try!(self, self.writer.write([b'(']));\n             }\n         }\n         true\n@@ -390,17 +390,17 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                          _sz: uint, _align: uint) -> bool {\n         if n_fields != 0 {\n             if named_fields {\n-                try!(self, self.writer.write(['}' as u8]));\n+                try!(self, self.writer.write([b'}']));\n             } else {\n-                try!(self, self.writer.write([')' as u8]));\n+                try!(self, self.writer.write([b')']));\n             }\n         }\n         true\n     }\n \n     fn visit_enter_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write(['(' as u8]));\n+        try!(self, self.writer.write([b'(']));\n         true\n     }\n \n@@ -415,9 +415,9 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_leave_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n         if _n_fields == 1 {\n-            try!(self, self.writer.write([',' as u8]));\n+            try!(self, self.writer.write([b',']));\n         }\n-        try!(self, self.writer.write([')' as u8]));\n+        try!(self, self.writer.write([b')']));\n         true\n     }\n \n@@ -455,7 +455,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         if write {\n             try!(self, self.writer.write(name.as_bytes()));\n             if n_fields > 0 {\n-                try!(self, self.writer.write(['(' as u8]));\n+                try!(self, self.writer.write([b'(']));\n             }\n         }\n         true\n@@ -487,7 +487,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if n_fields > 0 {\n-                    try!(self, self.writer.write([')' as u8]));\n+                    try!(self, self.writer.write([b')']));\n                 }\n             }\n             _ => ()"}, {"sha": "6339dc5844620fd208e65ee2abdd1490053e1fe1", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -372,7 +372,7 @@ impl Matches {\n }\n \n fn is_arg(arg: &str) -> bool {\n-    arg.len() > 1 && arg.as_bytes()[0] == '-' as u8\n+    arg.len() > 1 && arg.as_bytes()[0] == b'-'\n }\n \n fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n@@ -555,7 +555,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n         } else {\n             let mut names;\n             let mut i_arg = None;\n-            if cur.as_bytes()[1] == '-' as u8 {\n+            if cur.as_bytes()[1] == b'-' {\n                 let tail = cur.as_slice().slice(2, curlen);\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {"}, {"sha": "3a5f7649201cb6ce0f50493aef765f05b785a400", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -1376,7 +1376,7 @@ impl BigInt {\n         if buf.is_empty() { return None; }\n         let mut sign  = Plus;\n         let mut start = 0;\n-        if buf[0] == ('-' as u8) {\n+        if buf[0] == b'-' {\n             sign  = Minus;\n             start = 1;\n         }"}, {"sha": "4bd9d1a8666c0949f28707294c4b28bf01c8a25e", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -159,7 +159,7 @@ fn gen_text(n: uint) -> String {\n                        .collect::<Vec<u8>>();\n     for (i, b) in bytes.mut_iter().enumerate() {\n         if i % 20 == 0 {\n-            *b = '\\n' as u8\n+            *b = b'\\n'\n         }\n     }\n     String::from_utf8(bytes).unwrap()"}, {"sha": "f85f3a43974b9a9435799616b39c99131a1e9b6c", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -89,8 +89,8 @@ impl<'a> ToBase64 for &'a [u8] {\n             match config.line_length {\n                 Some(line_length) =>\n                     if cur_length >= line_length {\n-                        v.push('\\r' as u8);\n-                        v.push('\\n' as u8);\n+                        v.push(b'\\r');\n+                        v.push(b'\\n');\n                         cur_length = 0;\n                     },\n                 None => ()\n@@ -114,8 +114,8 @@ impl<'a> ToBase64 for &'a [u8] {\n             match config.line_length {\n                 Some(line_length) =>\n                     if cur_length >= line_length {\n-                        v.push('\\r' as u8);\n-                        v.push('\\n' as u8);\n+                        v.push(b'\\r');\n+                        v.push(b'\\n');\n                     },\n                 None => ()\n             }\n@@ -130,8 +130,8 @@ impl<'a> ToBase64 for &'a [u8] {\n                 v.push(bytes[((n >> 18) & 63) as uint]);\n                 v.push(bytes[((n >> 12) & 63) as uint]);\n                 if config.pad {\n-                    v.push('=' as u8);\n-                    v.push('=' as u8);\n+                    v.push(b'=');\n+                    v.push(b'=');\n                 }\n             }\n             2 => {\n@@ -141,7 +141,7 @@ impl<'a> ToBase64 for &'a [u8] {\n                 v.push(bytes[((n >> 12) & 63) as uint]);\n                 v.push(bytes[((n >> 6 ) & 63) as uint]);\n                 if config.pad {\n-                    v.push('=' as u8);\n+                    v.push(b'=');\n                 }\n             }\n             _ => fail!(\"Algebra is broken, please alert the math police\")"}, {"sha": "f33ecb5f19bc82422c1d98b769225d60e97810c6", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -112,11 +112,11 @@ impl<'a> FromHex for &'a str {\n         for (idx, byte) in self.bytes().enumerate() {\n             buf <<= 4;\n \n-            match byte as char {\n-                'A'..'F' => buf |= byte - ('A' as u8) + 10,\n-                'a'..'f' => buf |= byte - ('a' as u8) + 10,\n-                '0'..'9' => buf |= byte - ('0' as u8),\n-                ' '|'\\r'|'\\n'|'\\t' => {\n+            match byte {\n+                b'A'..b'F' => buf |= byte - b'A' + 10,\n+                b'a'..b'f' => buf |= byte - b'a' + 10,\n+                b'0'..b'9' => buf |= byte - b'0',\n+                b' '|b'\\r'|b'\\n'|b'\\t' => {\n                     buf >>= 4;\n                     continue\n                 }"}, {"sha": "e8352dcd40cdc29fcfc9099e4706990de89c85dd", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -119,7 +119,7 @@ impl Ascii {\n     /// Check if the character is a space or horizontal tab\n     #[inline]\n     pub fn is_blank(&self) -> bool {\n-        self.chr == ' ' as u8 || self.chr == '\\t' as u8\n+        self.chr == b' ' || self.chr == b'\\t'\n     }\n \n     /// Check if the character is a control character\n@@ -150,7 +150,7 @@ impl Ascii {\n     /// Checks if the character is lowercase\n     #[inline]\n     pub fn is_lowercase(&self) -> bool {\n-        (self.chr - 'a' as u8) < 26\n+        (self.chr - b'a') < 26\n     }\n \n     #[inline]\n@@ -163,7 +163,7 @@ impl Ascii {\n     /// Checks if the character is uppercase\n     #[inline]\n     pub fn is_uppercase(&self) -> bool {\n-        (self.chr - 'A' as u8) < 26\n+        (self.chr - b'A') < 26\n     }\n \n     /// Checks if the character is punctuation\n@@ -175,7 +175,7 @@ impl Ascii {\n     /// Checks if the character is a valid hex digit\n     #[inline]\n     pub fn is_hex(&self) -> bool {\n-        self.is_digit() || ((self.chr | 32u8) - 'a' as u8) < 6\n+        self.is_digit() || ((self.chr | 32u8) - b'a') < 6\n     }\n }\n \n@@ -792,13 +792,13 @@ mod tests {\n \n     #[test]\n     fn test_to_string() {\n-        let s = Ascii{ chr: 't' as u8 }.to_string();\n+        let s = Ascii{ chr: b't' }.to_string();\n         assert_eq!(s, \"t\".to_string());\n     }\n \n     #[test]\n     fn test_show() {\n-        let c = Ascii { chr: 't' as u8 };\n+        let c = Ascii { chr: b't' };\n         assert_eq!(format!(\"{}\", c), \"t\".to_string());\n     }\n }"}, {"sha": "1ac37458e2493acd1b6f0f95b274187933d7a227", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -114,7 +114,7 @@ impl DynamicLibrary {\n     }\n \n     fn separator() -> u8 {\n-        if cfg!(windows) {';' as u8} else {':' as u8}\n+        if cfg!(windows) {b';'} else {b':'}\n     }\n \n     /// Returns the current search path for dynamic libraries being used by this"}, {"sha": "71ec524211824dcad77dc4d52f01ce1a293d5be8", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -248,7 +248,7 @@ impl<W: Writer> LineBufferedWriter<W> {\n \n impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        match buf.iter().rposition(|&b| b == '\\n' as u8) {\n+        match buf.iter().rposition(|&b| b == b'\\n') {\n             Some(i) => {\n                 try!(self.inner.write(buf.slice_to(i + 1)));\n                 try!(self.inner.flush());\n@@ -524,15 +524,15 @@ mod test {\n         assert_eq!(writer.get_ref().get_ref(), &[]);\n         writer.flush().unwrap();\n         assert_eq!(writer.get_ref().get_ref(), &[0, 1]);\n-        writer.write([0, '\\n' as u8, 1, '\\n' as u8, 2]).unwrap();\n+        writer.write([0, b'\\n', 1, b'\\n', 2]).unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n-                   &[0, 1, 0, '\\n' as u8, 1, '\\n' as u8]);\n+                   &[0, 1, 0, b'\\n', 1, b'\\n']);\n         writer.flush().unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n-                   &[0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2]);\n-        writer.write([3, '\\n' as u8]).unwrap();\n+                   &[0, 1, 0, b'\\n', 1, b'\\n', 2]);\n+        writer.write([3, b'\\n']).unwrap();\n         assert_eq!(writer.get_ref().get_ref(),\n-            &[0, 1, 0, '\\n' as u8, 1, '\\n' as u8, 2, 3, '\\n' as u8]);\n+            &[0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n']);\n     }\n \n     #[test]\n@@ -579,7 +579,7 @@ mod test {\n \n     #[test]\n     fn test_chars() {\n-        let buf = [195u8, 159u8, 'a' as u8];\n+        let buf = [195u8, 159u8, b'a'];\n         let mut reader = BufferedReader::with_capacity(1, BufReader::new(buf));\n         let mut it = reader.chars();\n         assert_eq!(it.next(), Some(Ok('\u00df')));"}, {"sha": "6a4172d5c3526fd195ecafb4292bda2d15bdc39d", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -1241,8 +1241,8 @@ mod test {\n         let mut cur = [0u8, .. 2];\n         for f in files {\n             let stem = f.filestem_str().unwrap();\n-            let root = stem.as_bytes()[0] - ('0' as u8);\n-            let name = stem.as_bytes()[1] - ('0' as u8);\n+            let root = stem.as_bytes()[0] - b'0';\n+            let name = stem.as_bytes()[1] - b'0';\n             assert!(cur[root as uint] < name);\n             cur[root as uint] = name;\n         }"}, {"sha": "d098f9a6479146016bfab81ee7d1c53e82580ca2", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -1103,7 +1103,7 @@ pub trait Writer {\n     /// that the `write` method is used specifically instead.\n     #[inline]\n     fn write_line(&mut self, s: &str) -> IoResult<()> {\n-        self.write_str(s).and_then(|()| self.write(['\\n' as u8]))\n+        self.write_str(s).and_then(|()| self.write([b'\\n']))\n     }\n \n     /// Write a single char, encoded as UTF-8.\n@@ -1442,7 +1442,7 @@ pub trait Buffer: Reader {\n     /// Additionally, this function can fail if the line of input read is not a\n     /// valid UTF-8 sequence of bytes.\n     fn read_line(&mut self) -> IoResult<String> {\n-        self.read_until('\\n' as u8).and_then(|line|\n+        self.read_until(b'\\n').and_then(|line|\n             match String::from_utf8(line) {\n                 Ok(s)  => Ok(s),\n                 Err(_) => Err(standard_error(InvalidInput)),"}, {"sha": "0f864c7be5e274e5a1b754e74bea8e5b6e8d1267", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -161,12 +161,12 @@ impl<'a> Parser<'a> {\n         fn parse_digit(c: char, radix: u8) -> Option<u8> {\n             let c = c as u8;\n             // assuming radix is either 10 or 16\n-            if c >= '0' as u8 && c <= '9' as u8 {\n-                Some(c - '0' as u8)\n-            } else if radix > 10 && c >= 'a' as u8 && c < 'a' as u8 + (radix - 10) {\n-                Some(c - 'a' as u8 + 10)\n-            } else if radix > 10 && c >= 'A' as u8 && c < 'A' as u8 + (radix - 10) {\n-                Some(c - 'A' as u8 + 10)\n+            if c >= b'0' && c <= b'9' {\n+                Some(c - b'0')\n+            } else if radix > 10 && c >= b'a' && c < b'a' + (radix - 10) {\n+                Some(c - b'a' + 10)\n+            } else if radix > 10 && c >= b'A' && c < b'A' + (radix - 10) {\n+                Some(c - b'A' + 10)\n             } else {\n                 None\n             }"}, {"sha": "e0201b650716a5304a2203509d0746e67fd6d8ef", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -239,7 +239,7 @@ pub fn print(s: &str) {\n /// `\\n` character is printed to the console after the string.\n pub fn println(s: &str) {\n     with_task_stdout(|io| {\n-        io.write(s.as_bytes()).and_then(|()| io.write(['\\n' as u8]))\n+        io.write(s.as_bytes()).and_then(|()| io.write([b'\\n']))\n     })\n }\n "}, {"sha": "3184c151bd2c74e9c138344a5da481862f133d6a", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -502,7 +502,7 @@ pub mod builtin {\n     ///\n     /// ```\n     /// let rust = bytes!(\"r\", 'u', \"st\", 255);\n-    /// assert_eq!(rust[1], 'u' as u8);\n+    /// assert_eq!(rust[1], b'u');\n     /// assert_eq!(rust[4], 255);\n     /// ```\n     #[macro_export]"}, {"sha": "37378518dc8e123b98688ab042bb73734dd94462", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -138,12 +138,10 @@ impl_NumStrConv_Integer!(u64)\n \n \n // Special value strings as [u8] consts.\n-static INF_BUF:          [u8, ..3] = ['i' as u8, 'n' as u8, 'f' as u8];\n-static POS_INF_BUF: [u8, ..4] = ['+' as u8, 'i' as u8, 'n' as u8,\n-                                      'f' as u8];\n-static NEG_INF_BUF: [u8, ..4] = ['-' as u8, 'i' as u8, 'n' as u8,\n-                                      'f' as u8];\n-static NAN_BUF:          [u8, ..3] = ['N' as u8, 'a' as u8, 'N' as u8];\n+static INF_BUF:     [u8, ..3] = [b'i', b'n', b'f'];\n+static POS_INF_BUF: [u8, ..4] = [b'+', b'i', b'n', b'f'];\n+static NEG_INF_BUF: [u8, ..4] = [b'-', b'i', b'n', b'f'];\n+static NAN_BUF:     [u8, ..3] = [b'N', b'a', b'N'];\n \n /**\n  * Converts an integral number to its string representation as a byte vector.\n@@ -201,8 +199,8 @@ pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f:\n             current_digit_signed\n         };\n         buf[cur] = match current_digit.to_u8().unwrap() {\n-            i @ 0..9 => '0' as u8 + i,\n-            i        => 'a' as u8 + (i - 10),\n+            i @ 0..9 => b'0' + i,\n+            i        => b'a' + (i - 10),\n         };\n         cur += 1;\n \n@@ -213,8 +211,8 @@ pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f:\n \n     // Decide what sign to put in front\n     match sign {\n-        SignNeg | SignAll if neg => { f('-' as u8); }\n-        SignAll => { f('+' as u8); }\n+        SignNeg | SignAll if neg => { f(b'-'); }\n+        SignAll => { f(b'+'); }\n         _ => ()\n     }\n \n@@ -350,10 +348,10 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n     // Decide what sign to put in front\n     match sign {\n         SignNeg | SignAll if neg => {\n-            buf.push('-' as u8);\n+            buf.push(b'-');\n         }\n         SignAll => {\n-            buf.push('+' as u8);\n+            buf.push(b'+');\n         }\n         _ => ()\n     }\n@@ -368,7 +366,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n     // Now emit the fractional part, if any\n     deccum = num.fract();\n     if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n-        buf.push('.' as u8);\n+        buf.push(b'.');\n         let mut dig = 0u;\n \n         // calculate new digits while\n@@ -415,14 +413,14 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n                     // If reached left end of number, have to\n                     // insert additional digit:\n                     if i < 0\n-                    || *buf.get(i as uint) == '-' as u8\n-                    || *buf.get(i as uint) == '+' as u8 {\n+                    || *buf.get(i as uint) == b'-'\n+                    || *buf.get(i as uint) == b'+' {\n                         buf.insert((i + 1) as uint, value2ascii(1));\n                         break;\n                     }\n \n                     // Skip the '.'\n-                    if *buf.get(i as uint) == '.' as u8 { i -= 1; continue; }\n+                    if *buf.get(i as uint) == b'.' { i -= 1; continue; }\n \n                     // Either increment the digit,\n                     // or set to 0 if max and carry the 1.\n@@ -448,14 +446,14 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n         let mut i = buf_max_i;\n \n         // discover trailing zeros of fractional part\n-        while i > start_fractional_digits && *buf.get(i) == '0' as u8 {\n+        while i > start_fractional_digits && *buf.get(i) == b'0' {\n             i -= 1;\n         }\n \n         // Only attempt to truncate digits if buf has fractional digits\n         if i >= start_fractional_digits {\n             // If buf ends with '.', cut that too.\n-            if *buf.get(i) == '.' as u8 { i -= 1 }\n+            if *buf.get(i) == b'.' { i -= 1 }\n \n             // only resize buf if we actually remove digits\n             if i < buf_max_i {\n@@ -465,7 +463,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n     } // If exact and trailing '.', just cut that\n     else {\n         let max_i = buf.len() - 1;\n-        if *buf.get(max_i) == '.' as u8 {\n+        if *buf.get(max_i) == b'.' {\n             buf = Vec::from_slice(buf.slice(0, max_i));\n         }\n     }"}, {"sha": "85445e49139352e706f437ca5309af01d20bcfe8", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -293,7 +293,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n         fn env_convert(input: Vec<Vec<u8>>) -> Vec<(Vec<u8>, Vec<u8>)> {\n             let mut pairs = Vec::new();\n             for p in input.iter() {\n-                let mut it = p.as_slice().splitn(1, |b| *b == '=' as u8);\n+                let mut it = p.as_slice().splitn(1, |b| *b == b'=');\n                 let key = Vec::from_slice(it.next().unwrap());\n                 let val = Vec::from_slice(it.next().unwrap_or(&[]));\n                 pairs.push((key, val));"}, {"sha": "d290a5f8c63c758d12113b5ddf923e844f118838", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -351,7 +351,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         match self.filename() {\n             None => None,\n             Some(name) => Some({\n-                let dot = '.' as u8;\n+                let dot = b'.';\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => name,\n                     Some(1) if name == b\"..\" => name,\n@@ -398,7 +398,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         match self.filename() {\n             None => None,\n             Some(name) => {\n-                let dot = '.' as u8;\n+                let dot = b'.';\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => None,\n                     Some(1) if name == b\"..\" => None,\n@@ -474,7 +474,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n         assert!(!contains_nul(&extension));\n \n         let val = self.filename().and_then(|name| {\n-            let dot = '.' as u8;\n+            let dot = b'.';\n             let extlen = extension.container_as_bytes().len();\n             match (name.rposition_elem(&dot), extlen) {\n                 (None, 0) | (Some(0), 0) => None,"}, {"sha": "9a4bc11f5c03a8fd78eef3204c11e497d8937561", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -237,7 +237,7 @@ impl GenericPath for Path {\n         match self.sepidx {\n             None if b\".\" == self.repr.as_slice() => false,\n             None => {\n-                self.repr = vec!['.' as u8];\n+                self.repr = vec![b'.'];\n                 self.sepidx = None;\n                 true\n             }"}, {"sha": "c3a217bf940f3a3b716b0e4cb6f89f3a4d103fb3", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -737,12 +737,12 @@ impl Path {\n             let mut comps = comps;\n             match (comps.is_some(),prefix) {\n                 (false, Some(DiskPrefix)) => {\n-                    if s.as_bytes()[0] >= 'a' as u8 && s.as_bytes()[0] <= 'z' as u8 {\n+                    if s.as_bytes()[0] >= b'a' && s.as_bytes()[0] <= b'z' {\n                         comps = Some(vec![]);\n                     }\n                 }\n                 (false, Some(VerbatimDiskPrefix)) => {\n-                    if s.as_bytes()[4] >= 'a' as u8 && s.as_bytes()[0] <= 'z' as u8 {\n+                    if s.as_bytes()[4] >= b'a' && s.as_bytes()[0] <= b'z' {\n                         comps = Some(vec![]);\n                     }\n                 }\n@@ -1010,7 +1010,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             } else {\n                 // \\\\?\\path\n                 let idx = path.find('\\\\');\n-                if idx == Some(2) && path.as_bytes()[1] == ':' as u8 {\n+                if idx == Some(2) && path.as_bytes()[1] == b':' {\n                     let c = path.as_bytes()[0];\n                     if c.is_ascii() && (c as char).is_alphabetic() {\n                         // \\\\?\\C:\\ path\n@@ -1033,7 +1033,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             }\n             _ => ()\n         }\n-    } else if path.len() > 1 && path.as_bytes()[1] == ':' as u8 {\n+    } else if path.len() > 1 && path.as_bytes()[1] == b':' {\n         // C:\n         let c = path.as_bytes()[0];\n         if c.is_ascii() && (c as char).is_alphabetic() {"}, {"sha": "625c03ec13db941025fa6940cd4e6a059ef4a675", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -1131,8 +1131,8 @@ impl<'a> StringReader<'a> {\n \n     fn read_one_line_comment(&mut self) -> String {\n         let val = self.read_to_eol();\n-        assert!((val.as_bytes()[0] == '/' as u8 && val.as_bytes()[1] == '/' as u8)\n-             || (val.as_bytes()[0] == '#' as u8 && val.as_bytes()[1] == '!' as u8));\n+        assert!((val.as_bytes()[0] == b'/' && val.as_bytes()[1] == b'/')\n+             || (val.as_bytes()[0] == b'#' && val.as_bytes()[1] == b'!'));\n         return val;\n     }\n "}, {"sha": "fdbe6eeadfd8a0fee4231f6a079d63b86597a35b", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fe73f1166c0d3765cabb26680b82175ec4429cd/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=8fe73f1166c0d3765cabb26680b82175ec4429cd", "patch": "@@ -301,12 +301,12 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             SetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n                     if stack.len() > 0 {\n-                        let idx = (cur as u8) - ('A' as u8);\n+                        let idx = (cur as u8) - b'A';\n                         vars.sta[idx as uint] = stack.pop().unwrap();\n                     } else { return Err(\"stack is empty\".to_string()) }\n                 } else if cur >= 'a' && cur <= 'z' {\n                     if stack.len() > 0 {\n-                        let idx = (cur as u8) - ('a' as u8);\n+                        let idx = (cur as u8) - b'a';\n                         vars.dyn[idx as uint] = stack.pop().unwrap();\n                     } else { return Err(\"stack is empty\".to_string()) }\n                 } else {\n@@ -315,10 +315,10 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             GetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n-                    let idx = (cur as u8) - ('A' as u8);\n+                    let idx = (cur as u8) - b'A';\n                     stack.push(vars.sta[idx as uint].clone());\n                 } else if cur >= 'a' && cur <= 'z' {\n-                    let idx = (cur as u8) - ('a' as u8);\n+                    let idx = (cur as u8) - b'a';\n                     stack.push(vars.dyn[idx as uint].clone());\n                 } else {\n                     return Err(\"bad variable name in %g\".to_string());\n@@ -505,26 +505,25 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n             if flags.precision > s.len() {\n                 let mut s_ = Vec::with_capacity(flags.precision);\n                 let n = flags.precision - s.len();\n-                s_.grow(n, &('0' as u8));\n+                s_.grow(n, &b'0');\n                 s_.push_all_move(s);\n                 s = s_;\n             }\n             assert!(!s.is_empty(), \"string conversion produced empty result\");\n             match op {\n                 FormatDigit => {\n-                    if flags.space && !(s[0] == '-' as u8 ||\n-                                        s[0] == '+' as u8) {\n-                        s.insert(0, ' ' as u8);\n+                    if flags.space && !(s[0] == b'-' || s[0] == b'+' ) {\n+                        s.insert(0, b' ');\n                     }\n                 }\n                 FormatOctal => {\n-                    if flags.alternate && s[0] != '0' as u8 {\n-                        s.insert(0, '0' as u8);\n+                    if flags.alternate && s[0] != b'0' {\n+                        s.insert(0, b'0');\n                     }\n                 }\n                 FormatHex => {\n                     if flags.alternate {\n-                        let s_ = replace(&mut s, vec!('0' as u8, 'x' as u8));\n+                        let s_ = replace(&mut s, vec!(b'0', b'x'));\n                         s.push_all_move(s_);\n                     }\n                 }\n@@ -536,7 +535,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                          .move_iter()\n                          .collect();\n                     if flags.alternate {\n-                        let s_ = replace(&mut s, vec!('0' as u8, 'X' as u8));\n+                        let s_ = replace(&mut s, vec!(b'0', b'X'));\n                         s.push_all_move(s_);\n                     }\n                 }\n@@ -563,10 +562,10 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n     if flags.width > s.len() {\n         let n = flags.width - s.len();\n         if flags.left {\n-            s.grow(n, &(' ' as u8));\n+            s.grow(n, &b' ');\n         } else {\n             let mut s_ = Vec::with_capacity(flags.width);\n-            s_.grow(n, &(' ' as u8));\n+            s_.grow(n, &b' ');\n             s_.push_all_move(s);\n             s = s_;\n         }\n@@ -655,15 +654,15 @@ mod test {\n             let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), vec!('0' as u8 + bs[0]));\n+            assert_eq!(res.unwrap(), vec!(b'0' + bs[0]));\n             let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), vec!('0' as u8 + bs[1]));\n+            assert_eq!(res.unwrap(), vec!(b'0' + bs[1]));\n             let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n             let res = expand(s.as_bytes(), [], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), vec!('0' as u8 + bs[2]));\n+            assert_eq!(res.unwrap(), vec!(b'0' + bs[2]));\n         }\n     }\n "}]}