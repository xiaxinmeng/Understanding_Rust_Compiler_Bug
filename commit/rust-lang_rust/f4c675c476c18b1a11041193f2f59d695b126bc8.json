{"sha": "f4c675c476c18b1a11041193f2f59d695b126bc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YzY3NWM0NzZjMThiMWExMTA0MTE5M2YyZjU5ZDY5NWIxMjZiYzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-19T16:07:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-19T16:07:59Z"}, "message": "Auto merge of #69402 - GuillaumeGomez:extend-search, r=kinnison\n\nExtend search\n\nI realized that when looking for \"struct:String\" in the rustdoc search for example, the \"in arguments\" and \"returned\" tabs were always empty. After some investigation, I realized it was because we only provided the name, and not the type, making it impossible to pass the \"type filtering\" check.\n\nTo resolve this, I added the type alongside the name. Note for the future: we could improve this by instead only registering the path id and use the path dictionary directly. The only problem with that solution (which I already tested) is that it becomes complicated for types in other crates. It'd force us to handle both case with an id and a case with `(name, type)`. I found the current PR big enough to not want to provide it directly. However, I think this is definitely worth it to make it work this way in the future.\n\nAbout the two tests I added: they don't have much interest except checking that we actually have something returned in the search in the cases of a type filtering with and without literal search.\n\nI also had to update a bit the test script to add the new locally global (haha) variable I created (`NO_TYPE_FILTER`). I added this variable to make the code easier to read than just \"-1\".\n\nr? @kinnison\n\ncc @ollie27", "tree": {"sha": "3c580c133578103d99dcac7fa7c9d44ae28db73d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c580c133578103d99dcac7fa7c9d44ae28db73d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4c675c476c18b1a11041193f2f59d695b126bc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4c675c476c18b1a11041193f2f59d695b126bc8", "html_url": "https://github.com/rust-lang/rust/commit/f4c675c476c18b1a11041193f2f59d695b126bc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4c675c476c18b1a11041193f2f59d695b126bc8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "260228963211e6497eb0089f4417f89f80f50f0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/260228963211e6497eb0089f4417f89f80f50f0b", "html_url": "https://github.com/rust-lang/rust/commit/260228963211e6497eb0089f4417f89f80f50f0b"}, {"sha": "9b852136109f3d29f87504c4f38a0e97d1bc2b06", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b852136109f3d29f87504c4f38a0e97d1bc2b06", "html_url": "https://github.com/rust-lang/rust/commit/9b852136109f3d29f87504c4f38a0e97d1bc2b06"}], "stats": {"total": 345, "additions": 237, "deletions": 108}, "files": [{"sha": "e69d4ddc2d01b4f97276daea97faecd768dc8082", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f4c675c476c18b1a11041193f2f59d695b126bc8", "patch": "@@ -1078,6 +1078,26 @@ impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n     }\n }\n \n+impl Clean<TypeKind> for hir::def::DefKind {\n+    fn clean(&self, _: &DocContext<'_>) -> TypeKind {\n+        match *self {\n+            hir::def::DefKind::Mod => TypeKind::Module,\n+            hir::def::DefKind::Struct => TypeKind::Struct,\n+            hir::def::DefKind::Union => TypeKind::Union,\n+            hir::def::DefKind::Enum => TypeKind::Enum,\n+            hir::def::DefKind::Trait => TypeKind::Trait,\n+            hir::def::DefKind::TyAlias => TypeKind::Typedef,\n+            hir::def::DefKind::ForeignTy => TypeKind::Foreign,\n+            hir::def::DefKind::TraitAlias => TypeKind::TraitAlias,\n+            hir::def::DefKind::Fn => TypeKind::Function,\n+            hir::def::DefKind::Const => TypeKind::Const,\n+            hir::def::DefKind::Static => TypeKind::Static,\n+            hir::def::DefKind::Macro(_) => TypeKind::Macro,\n+            _ => TypeKind::Foreign,\n+        }\n+    }\n+}\n+\n impl Clean<Item> for hir::TraitItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let inner = match self.kind {"}, {"sha": "73f2c399e56982bc67a2312044bc59d86dc69d3a", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=f4c675c476c18b1a11041193f2f59d695b126bc8", "patch": "@@ -836,26 +836,26 @@ pub struct Method {\n     pub decl: FnDecl,\n     pub header: hir::FnHeader,\n     pub defaultness: Option<hir::Defaultness>,\n-    pub all_types: Vec<Type>,\n-    pub ret_types: Vec<Type>,\n+    pub all_types: Vec<(Type, TypeKind)>,\n+    pub ret_types: Vec<(Type, TypeKind)>,\n }\n \n #[derive(Clone, Debug)]\n pub struct TyMethod {\n     pub header: hir::FnHeader,\n     pub decl: FnDecl,\n     pub generics: Generics,\n-    pub all_types: Vec<Type>,\n-    pub ret_types: Vec<Type>,\n+    pub all_types: Vec<(Type, TypeKind)>,\n+    pub ret_types: Vec<(Type, TypeKind)>,\n }\n \n #[derive(Clone, Debug)]\n pub struct Function {\n     pub decl: FnDecl,\n     pub generics: Generics,\n     pub header: hir::FnHeader,\n-    pub all_types: Vec<Type>,\n-    pub ret_types: Vec<Type>,\n+    pub all_types: Vec<(Type, TypeKind)>,\n+    pub ret_types: Vec<(Type, TypeKind)>,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -1042,7 +1042,7 @@ pub enum PrimitiveType {\n     Never,\n }\n \n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Copy, Debug)]\n pub enum TypeKind {\n     Enum,\n     Function,"}, {"sha": "b54af499187097e5b22e3e860f705f44ab15dab3", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=f4c675c476c18b1a11041193f2f59d695b126bc8", "patch": "@@ -184,7 +184,7 @@ pub fn get_real_types(\n     arg: &Type,\n     cx: &DocContext<'_>,\n     recurse: i32,\n-) -> FxHashSet<Type> {\n+) -> FxHashSet<(Type, TypeKind)> {\n     let arg_s = arg.print().to_string();\n     let mut res = FxHashSet::default();\n     if recurse >= 10 {\n@@ -209,7 +209,11 @@ pub fn get_real_types(\n                                 if !adds.is_empty() {\n                                     res.extend(adds);\n                                 } else if !ty.is_full_generic() {\n-                                    res.insert(ty);\n+                                    if let Some(did) = ty.def_id() {\n+                                        if let Some(kind) = cx.tcx.def_kind(did).clean(cx) {\n+                                            res.insert((ty, kind));\n+                                        }\n+                                    }\n                                 }\n                             }\n                         }\n@@ -225,22 +229,32 @@ pub fn get_real_types(\n                     if !adds.is_empty() {\n                         res.extend(adds);\n                     } else if !ty.is_full_generic() {\n-                        res.insert(ty.clone());\n+                        if let Some(did) = ty.def_id() {\n+                            if let Some(kind) = cx.tcx.def_kind(did).clean(cx) {\n+                                res.insert((ty.clone(), kind));\n+                            }\n+                        }\n                     }\n                 }\n             }\n         }\n     } else {\n-        res.insert(arg.clone());\n+        if let Some(did) = arg.def_id() {\n+            if let Some(kind) = cx.tcx.def_kind(did).clean(cx) {\n+                res.insert((arg.clone(), kind));\n+            }\n+        }\n         if let Some(gens) = arg.generics() {\n             for gen in gens.iter() {\n                 if gen.is_full_generic() {\n                     let adds = get_real_types(generics, gen, cx, recurse + 1);\n                     if !adds.is_empty() {\n                         res.extend(adds);\n                     }\n-                } else {\n-                    res.insert(gen.clone());\n+                } else if let Some(did) = gen.def_id() {\n+                    if let Some(kind) = cx.tcx.def_kind(did).clean(cx) {\n+                        res.insert((gen.clone(), kind));\n+                    }\n                 }\n             }\n         }\n@@ -256,7 +270,7 @@ pub fn get_all_types(\n     generics: &Generics,\n     decl: &FnDecl,\n     cx: &DocContext<'_>,\n-) -> (Vec<Type>, Vec<Type>) {\n+) -> (Vec<(Type, TypeKind)>, Vec<(Type, TypeKind)>) {\n     let mut all_types = FxHashSet::default();\n     for arg in decl.inputs.values.iter() {\n         if arg.type_.is_self_type() {\n@@ -266,15 +280,23 @@ pub fn get_all_types(\n         if !args.is_empty() {\n             all_types.extend(args);\n         } else {\n-            all_types.insert(arg.type_.clone());\n+            if let Some(did) = arg.type_.def_id() {\n+                if let Some(kind) = cx.tcx.def_kind(did).clean(cx) {\n+                    all_types.insert((arg.type_.clone(), kind));\n+                }\n+            }\n         }\n     }\n \n     let ret_types = match decl.output {\n         FnRetTy::Return(ref return_type) => {\n             let mut ret = get_real_types(generics, &return_type, cx, 0);\n             if ret.is_empty() {\n-                ret.insert(return_type.clone());\n+                if let Some(did) = return_type.def_id() {\n+                    if let Some(kind) = cx.tcx.def_kind(did).clean(cx) {\n+                        ret.insert((return_type.clone(), kind));\n+                    }\n+                }\n             }\n             ret.into_iter().collect()\n         }"}, {"sha": "eb7a367acf439cb41ec7704f0f16d2260d690354", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f4c675c476c18b1a11041193f2f59d695b126bc8", "patch": "@@ -58,7 +58,7 @@ use rustc_span::symbol::{sym, Symbol};\n use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n \n-use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy};\n+use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, TypeKind};\n use crate::config::{OutputFormat, RenderOptions};\n use crate::docfs::{DocFS, ErrorStorage, PathError};\n use crate::doctree;\n@@ -302,19 +302,25 @@ impl Serialize for IndexItem {\n \n /// A type used for the search index.\n #[derive(Debug)]\n-struct Type {\n+struct RenderType {\n+    ty: Option<DefId>,\n+    idx: Option<usize>,\n     name: Option<String>,\n-    generics: Option<Vec<String>>,\n+    generics: Option<Vec<Generic>>,\n }\n \n-impl Serialize for Type {\n+impl Serialize for RenderType {\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n     where\n         S: Serializer,\n     {\n         if let Some(name) = &self.name {\n             let mut seq = serializer.serialize_seq(None)?;\n-            seq.serialize_element(&name)?;\n+            if let Some(id) = self.idx {\n+                seq.serialize_element(&id)?;\n+            } else {\n+                seq.serialize_element(&name)?;\n+            }\n             if let Some(generics) = &self.generics {\n                 seq.serialize_element(&generics)?;\n             }\n@@ -325,11 +331,32 @@ impl Serialize for Type {\n     }\n }\n \n+/// A type used for the search index.\n+#[derive(Debug)]\n+struct Generic {\n+    name: String,\n+    defid: Option<DefId>,\n+    idx: Option<usize>,\n+}\n+\n+impl Serialize for Generic {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        if let Some(id) = self.idx {\n+            serializer.serialize_some(&id)\n+        } else {\n+            serializer.serialize_some(&self.name)\n+        }\n+    }\n+}\n+\n /// Full type of functions/methods in the search index.\n #[derive(Debug)]\n struct IndexItemFunctionType {\n-    inputs: Vec<Type>,\n-    output: Option<Vec<Type>>,\n+    inputs: Vec<TypeWithKind>,\n+    output: Option<Vec<TypeWithKind>>,\n }\n \n impl Serialize for IndexItemFunctionType {\n@@ -340,8 +367,8 @@ impl Serialize for IndexItemFunctionType {\n         // If we couldn't figure out a type, just write `null`.\n         let mut iter = self.inputs.iter();\n         if match self.output {\n-            Some(ref output) => iter.chain(output.iter()).any(|ref i| i.name.is_none()),\n-            None => iter.any(|ref i| i.name.is_none()),\n+            Some(ref output) => iter.chain(output.iter()).any(|ref i| i.ty.name.is_none()),\n+            None => iter.any(|ref i| i.ty.name.is_none()),\n         } {\n             serializer.serialize_none()\n         } else {\n@@ -359,6 +386,31 @@ impl Serialize for IndexItemFunctionType {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct TypeWithKind {\n+    ty: RenderType,\n+    kind: TypeKind,\n+}\n+\n+impl From<(RenderType, TypeKind)> for TypeWithKind {\n+    fn from(x: (RenderType, TypeKind)) -> TypeWithKind {\n+        TypeWithKind { ty: x.0, kind: x.1 }\n+    }\n+}\n+\n+impl Serialize for TypeWithKind {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        let mut seq = serializer.serialize_seq(None)?;\n+        seq.serialize_element(&self.ty.name)?;\n+        let x: ItemType = self.kind.into();\n+        seq.serialize_element(&x)?;\n+        seq.end()\n+    }\n+}\n+\n thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_DEPTH: Cell<usize> = Cell::new(0));\n "}, {"sha": "ed0de2b311955874864e05babb5645f9f128540d", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=f4c675c476c18b1a11041193f2f59d695b126bc8", "patch": "@@ -12,7 +12,7 @@ use std::path::{Path, PathBuf};\n use serde::Serialize;\n \n use super::{plain_summary_line, shorten, Impl, IndexItem, IndexItemFunctionType, ItemType};\n-use super::{RenderInfo, Type};\n+use super::{Generic, RenderInfo, RenderType, TypeWithKind};\n \n /// Indicates where an external crate can be found.\n pub enum ExternalLocation {\n@@ -588,17 +588,20 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let mut lastpathid = 0usize;\n \n     for item in search_index {\n-        item.parent_idx = item.parent.map(|defid| {\n+        item.parent_idx = item.parent.and_then(|defid| {\n             if defid_to_pathid.contains_key(&defid) {\n-                *defid_to_pathid.get(&defid).expect(\"no pathid\")\n+                defid_to_pathid.get(&defid).map(|x| *x)\n             } else {\n                 let pathid = lastpathid;\n                 defid_to_pathid.insert(defid, pathid);\n                 lastpathid += 1;\n \n-                let &(ref fqp, short) = paths.get(&defid).unwrap();\n-                crate_paths.push((short, fqp.last().unwrap().clone()));\n-                pathid\n+                if let Some(&(ref fqp, short)) = paths.get(&defid) {\n+                    crate_paths.push((short, fqp.last().unwrap().clone()));\n+                    Some(pathid)\n+                } else {\n+                    None\n+                }\n             }\n         });\n \n@@ -647,20 +650,25 @@ fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n         _ => return None,\n     };\n \n-    let inputs =\n-        all_types.iter().map(|arg| get_index_type(&arg)).filter(|a| a.name.is_some()).collect();\n+    let inputs = all_types\n+        .iter()\n+        .map(|(ty, kind)| TypeWithKind::from((get_index_type(&ty), *kind)))\n+        .filter(|a| a.ty.name.is_some())\n+        .collect();\n     let output = ret_types\n         .iter()\n-        .map(|arg| get_index_type(&arg))\n-        .filter(|a| a.name.is_some())\n+        .map(|(ty, kind)| TypeWithKind::from((get_index_type(&ty), *kind)))\n+        .filter(|a| a.ty.name.is_some())\n         .collect::<Vec<_>>();\n     let output = if output.is_empty() { None } else { Some(output) };\n \n     Some(IndexItemFunctionType { inputs, output })\n }\n \n-fn get_index_type(clean_type: &clean::Type) -> Type {\n-    let t = Type {\n+fn get_index_type(clean_type: &clean::Type) -> RenderType {\n+    let t = RenderType {\n+        ty: clean_type.def_id(),\n+        idx: None,\n         name: get_index_type_name(clean_type, true).map(|s| s.to_ascii_lowercase()),\n         generics: get_generics(clean_type),\n     };\n@@ -685,12 +693,17 @@ fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option\n     }\n }\n \n-fn get_generics(clean_type: &clean::Type) -> Option<Vec<String>> {\n+fn get_generics(clean_type: &clean::Type) -> Option<Vec<Generic>> {\n     clean_type.generics().and_then(|types| {\n         let r = types\n             .iter()\n-            .filter_map(|t| get_index_type_name(t, false))\n-            .map(|s| s.to_ascii_lowercase())\n+            .filter_map(|t| {\n+                if let Some(name) = get_index_type_name(t, false) {\n+                    Some(Generic { name: name.to_ascii_lowercase(), defid: t.def_id(), idx: None })\n+                } else {\n+                    None\n+                }\n+            })\n             .collect::<Vec<_>>();\n         if r.is_empty() { None } else { Some(r) }\n     })"}, {"sha": "3f12fb893a440596248d307ab5970c4af663a6e2", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 66, "deletions": 64, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=f4c675c476c18b1a11041193f2f59d695b126bc8", "patch": "@@ -523,13 +523,14 @@ function getSearchElement() {\n     }\n \n     function initSearch(rawSearchIndex) {\n-        var currentResults, index, searchIndex;\n         var MAX_LEV_DISTANCE = 3;\n         var MAX_RESULTS = 200;\n         var GENERICS_DATA = 1;\n         var NAME = 0;\n         var INPUTS_DATA = 0;\n         var OUTPUT_DATA = 1;\n+        var NO_TYPE_FILTER = -1;\n+        var currentResults, index, searchIndex;\n         var params = getQueryStringParams();\n \n         // Populate search bar with query string search term when provided,\n@@ -556,7 +557,7 @@ function getSearchElement() {\n                         return i;\n                     }\n                 }\n-                return -1;\n+                return NO_TYPE_FILTER;\n             }\n \n             var valLower = query.query.toLowerCase(),\n@@ -719,6 +720,13 @@ function getSearchElement() {\n                 };\n             }\n \n+            function getObjectFromId(id) {\n+                if (typeof id === \"number\") {\n+                    return searchIndex[id];\n+                }\n+                return {'name': id};\n+            }\n+\n             function checkGenerics(obj, val) {\n                 // The names match, but we need to be sure that all generics kinda\n                 // match as well.\n@@ -735,8 +743,10 @@ function getSearchElement() {\n                         for (var y = 0; y < vlength; ++y) {\n                             var lev = { pos: -1, lev: MAX_LEV_DISTANCE + 1};\n                             var elength = elems.length;\n+                            var firstGeneric = getObjectFromId(val.generics[y]).name;\n                             for (var x = 0; x < elength; ++x) {\n-                                var tmp_lev = levenshtein(elems[x], val.generics[y]);\n+                                var tmp_lev = levenshtein(getObjectFromId(elems[x]).name,\n+                                                          firstGeneric);\n                                 if (tmp_lev < lev.lev) {\n                                     lev.lev = tmp_lev;\n                                     lev.pos = x;\n@@ -771,8 +781,9 @@ function getSearchElement() {\n \n                                 for (var y = 0; allFound === true && y < val.generics.length; ++y) {\n                                     allFound = false;\n+                                    var firstGeneric = getObjectFromId(val.generics[y]).name;\n                                     for (x = 0; allFound === false && x < elems.length; ++x) {\n-                                        allFound = elems[x] === val.generics[y];\n+                                        allFound = getObjectFromId(elems[x]).name === firstGeneric;\n                                     }\n                                     if (allFound === true) {\n                                         elems.splice(x - 1, 1);\n@@ -829,16 +840,22 @@ function getSearchElement() {\n                 return lev_distance + 1;\n             }\n \n-            function findArg(obj, val, literalSearch) {\n+            function findArg(obj, val, literalSearch, typeFilter) {\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n \n-                if (obj && obj.type && obj.type[INPUTS_DATA] &&\n-                      obj.type[INPUTS_DATA].length > 0) {\n+                if (obj && obj.type && obj.type[INPUTS_DATA] && obj.type[INPUTS_DATA].length > 0) {\n                     var length = obj.type[INPUTS_DATA].length;\n                     for (var i = 0; i < length; i++) {\n-                        var tmp = checkType(obj.type[INPUTS_DATA][i], val, literalSearch);\n-                        if (literalSearch === true && tmp === true) {\n-                            return true;\n+                        var tmp = obj.type[INPUTS_DATA][i];\n+                        if (typePassesFilter(typeFilter, tmp[1]) === false) {\n+                            continue;\n+                        }\n+                        tmp = checkType(tmp, val, literalSearch);\n+                        if (literalSearch === true) {\n+                            if (tmp === true) {\n+                                return true;\n+                            }\n+                            continue;\n                         }\n                         lev_distance = Math.min(tmp, lev_distance);\n                         if (lev_distance === 0) {\n@@ -849,20 +866,20 @@ function getSearchElement() {\n                 return literalSearch === true ? false : lev_distance;\n             }\n \n-            function checkReturned(obj, val, literalSearch) {\n+            function checkReturned(obj, val, literalSearch, typeFilter) {\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n \n                 if (obj && obj.type && obj.type.length > OUTPUT_DATA) {\n                     var ret = obj.type[OUTPUT_DATA];\n-                    if (!obj.type[OUTPUT_DATA].length) {\n+                    if (typeof ret[0] === \"string\") {\n                         ret = [ret];\n                     }\n                     for (var x = 0; x < ret.length; ++x) {\n-                        var r = ret[x];\n-                        if (typeof r === \"string\") {\n-                            r = [r];\n+                        var tmp = ret[x];\n+                        if (typePassesFilter(typeFilter, tmp[1]) === false) {\n+                            continue;\n                         }\n-                        var tmp = checkType(r, val, literalSearch);\n+                        tmp = checkType(tmp, val, literalSearch);\n                         if (literalSearch === true) {\n                             if (tmp === true) {\n                                 return true;\n@@ -917,7 +934,7 @@ function getSearchElement() {\n \n             function typePassesFilter(filter, type) {\n                 // No filter\n-                if (filter < 0) return true;\n+                if (filter <= NO_TYPE_FILTER) return true;\n \n                 // Exact match\n                 if (filter === type) return true;\n@@ -926,11 +943,13 @@ function getSearchElement() {\n                 var name = itemTypes[type];\n                 switch (itemTypes[filter]) {\n                     case \"constant\":\n-                        return (name == \"associatedconstant\");\n+                        return name === \"associatedconstant\";\n                     case \"fn\":\n-                        return (name == \"method\" || name == \"tymethod\");\n+                        return name === \"method\" || name === \"tymethod\";\n                     case \"type\":\n-                        return (name == \"primitive\" || name == \"keyword\");\n+                        return name === \"primitive\" || name === \"associatedtype\";\n+                    case \"trait\":\n+                        return name === \"traitalias\";\n                 }\n \n                 // No match\n@@ -959,42 +978,33 @@ function getSearchElement() {\n                     if (filterCrates !== undefined && searchIndex[i].crate !== filterCrates) {\n                         continue;\n                     }\n-                    in_args = findArg(searchIndex[i], val, true);\n-                    returned = checkReturned(searchIndex[i], val, true);\n+                    in_args = findArg(searchIndex[i], val, true, typeFilter);\n+                    returned = checkReturned(searchIndex[i], val, true, typeFilter);\n                     ty = searchIndex[i];\n                     fullId = generateId(ty);\n \n-                    if (searchWords[i] === val.name) {\n-                        // filter type: ... queries\n-                        if (typePassesFilter(typeFilter, searchIndex[i].ty) &&\n-                            results[fullId] === undefined)\n-                        {\n-                            results[fullId] = {id: i, index: -1};\n-                        }\n-                    } else if ((in_args === true || returned === true) &&\n-                               typePassesFilter(typeFilter, searchIndex[i].ty)) {\n-                        if (in_args === true || returned === true) {\n-                            if (in_args === true) {\n-                                results_in_args[fullId] = {\n-                                    id: i,\n-                                    index: -1,\n-                                    dontValidate: true,\n-                                };\n-                            }\n-                            if (returned === true) {\n-                                results_returned[fullId] = {\n-                                    id: i,\n-                                    index: -1,\n-                                    dontValidate: true,\n-                                };\n-                            }\n-                        } else {\n-                            results[fullId] = {\n-                                id: i,\n-                                index: -1,\n-                                dontValidate: true,\n-                            };\n-                        }\n+                    if (searchWords[i] === val.name\n+                        && typePassesFilter(typeFilter, searchIndex[i].ty)\n+                        && results[fullId] === undefined) {\n+                        results[fullId] = {\n+                            id: i,\n+                            index: -1,\n+                            dontValidate: true,\n+                        };\n+                    }\n+                    if (in_args === true && results_in_args[fullId] === undefined) {\n+                        results_in_args[fullId] = {\n+                            id: i,\n+                            index: -1,\n+                            dontValidate: true,\n+                        };\n+                    }\n+                    if (returned === true && results_returned[fullId] === undefined) {\n+                        results_returned[fullId] = {\n+                            id: i,\n+                            index: -1,\n+                            dontValidate: true,\n+                        };\n                     }\n                 }\n                 query.inputs = [val];\n@@ -1025,7 +1035,7 @@ function getSearchElement() {\n \n                     // allow searching for void (no output) functions as well\n                     var typeOutput = type.length > OUTPUT_DATA ? type[OUTPUT_DATA].name : \"\";\n-                    returned = checkReturned(ty, output, true);\n+                    returned = checkReturned(ty, output, true, NO_TYPE_FILTER);\n                     if (output.name === \"*\" || returned === true) {\n                         in_args = false;\n                         var is_module = false;\n@@ -1126,16 +1136,8 @@ function getSearchElement() {\n                             lev += 1;\n                         }\n                     }\n-                    if ((in_args = findArg(ty, valGenerics)) <= MAX_LEV_DISTANCE) {\n-                        if (typePassesFilter(typeFilter, ty.ty) === false) {\n-                            in_args = MAX_LEV_DISTANCE + 1;\n-                        }\n-                    }\n-                    if ((returned = checkReturned(ty, valGenerics)) <= MAX_LEV_DISTANCE) {\n-                        if (typePassesFilter(typeFilter, ty.ty) === false) {\n-                            returned = MAX_LEV_DISTANCE + 1;\n-                        }\n-                    }\n+                    in_args = findArg(ty, valGenerics, false, typeFilter);\n+                    returned = checkReturned(ty, valGenerics, false, typeFilter);\n \n                     lev += lev_add;\n                     if (lev > 0 && val.length > 3 && searchWords[j].indexOf(val) > -1) {"}, {"sha": "c7c347240b751db16dbfea556e6db2986545a779", "filename": "src/test/rustdoc-js-std/return-specific-literal.js", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Ftest%2Frustdoc-js-std%2Freturn-specific-literal.js", "raw_url": "https://github.com/rust-lang/rust/raw/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Ftest%2Frustdoc-js-std%2Freturn-specific-literal.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Freturn-specific-literal.js?ref=f4c675c476c18b1a11041193f2f59d695b126bc8", "patch": "@@ -0,0 +1,10 @@\n+const QUERY = 'struct:\"string\"';\n+\n+const EXPECTED = {\n+    'in_args': [\n+        { 'path': 'std::string::String', 'name': 'ne' },\n+    ],\n+    'returned': [\n+        { 'path': 'std::string::String', 'name': 'add' },\n+    ],\n+};"}, {"sha": "d9a910553b8de8e777b2444aa038bab4cc8f2c22", "filename": "src/test/rustdoc-js-std/return-specific.js", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Ftest%2Frustdoc-js-std%2Freturn-specific.js", "raw_url": "https://github.com/rust-lang/rust/raw/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Ftest%2Frustdoc-js-std%2Freturn-specific.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Freturn-specific.js?ref=f4c675c476c18b1a11041193f2f59d695b126bc8", "patch": "@@ -0,0 +1,10 @@\n+const QUERY = 'struct:string';\n+\n+const EXPECTED = {\n+    'in_args': [\n+        { 'path': 'std::string::String', 'name': 'ne' },\n+    ],\n+    'returned': [\n+        { 'path': 'std::string::String', 'name': 'add' },\n+    ],\n+};"}, {"sha": "08930ff1227970b3ba1ef965cf0b4a8924b5399b", "filename": "src/tools/rustdoc-js-std/tester.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Ftools%2Frustdoc-js-std%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Ftools%2Frustdoc-js-std%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js-std%2Ftester.js?ref=f4c675c476c18b1a11041193f2f59d695b126bc8", "patch": "@@ -263,7 +263,7 @@ function main(argv) {\n     finalJS = \"\";\n \n     var arraysToLoad = [\"itemTypes\"];\n-    var variablesToLoad = [\"MAX_LEV_DISTANCE\", \"MAX_RESULTS\",\n+    var variablesToLoad = [\"MAX_LEV_DISTANCE\", \"MAX_RESULTS\", \"NO_TYPE_FILTER\",\n                            \"GENERICS_DATA\", \"NAME\", \"INPUTS_DATA\", \"OUTPUT_DATA\",\n                            \"TY_PRIMITIVE\", \"TY_KEYWORD\",\n                            \"levenshtein_row2\"];\n@@ -336,7 +336,7 @@ function main(argv) {\n             console.log(\"OK\");\n         }\n     });\n-    return errors;\n+    return errors > 0 ? 1 : 0;\n }\n \n process.exit(main(process.argv));"}, {"sha": "143e1a7480d3da3aa5836940c3f79fc86cf2c076", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/f4c675c476c18b1a11041193f2f59d695b126bc8/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=f4c675c476c18b1a11041193f2f59d695b126bc8", "patch": "@@ -231,7 +231,7 @@ function load_files(out_folder, crate) {\n     finalJS = \"\";\n \n     var arraysToLoad = [\"itemTypes\"];\n-    var variablesToLoad = [\"MAX_LEV_DISTANCE\", \"MAX_RESULTS\",\n+    var variablesToLoad = [\"MAX_LEV_DISTANCE\", \"MAX_RESULTS\", \"NO_TYPE_FILTER\",\n                            \"GENERICS_DATA\", \"NAME\", \"INPUTS_DATA\", \"OUTPUT_DATA\",\n                            \"TY_PRIMITIVE\", \"TY_KEYWORD\",\n                            \"levenshtein_row2\"];\n@@ -328,7 +328,7 @@ function main(argv) {\n             console.log(\"OK\");\n         }\n     }\n-    return errors;\n+    return errors > 0 ? 1 : 0;\n }\n \n process.exit(main(process.argv));"}]}