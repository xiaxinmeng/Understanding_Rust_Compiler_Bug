{"sha": "aeb765b299640ee0674d2c01df600c296af7d691", "node_id": "C_kwDOAAsO6NoAKGFlYjc2NWIyOTk2NDBlZTA2NzRkMmMwMWRmNjAwYzI5NmFmN2Q2OTE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-04-27T02:59:50Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-05-30T20:52:40Z"}, "message": "better enum suggestions", "tree": {"sha": "d24a65fe3728fe13bd4f8def0297c14f8af18980", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d24a65fe3728fe13bd4f8def0297c14f8af18980"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aeb765b299640ee0674d2c01df600c296af7d691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aeb765b299640ee0674d2c01df600c296af7d691", "html_url": "https://github.com/rust-lang/rust/commit/aeb765b299640ee0674d2c01df600c296af7d691", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aeb765b299640ee0674d2c01df600c296af7d691/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a8d2e3856c0c75c71998b6c85937203839b946d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8d2e3856c0c75c71998b6c85937203839b946d", "html_url": "https://github.com/rust-lang/rust/commit/4a8d2e3856c0c75c71998b6c85937203839b946d"}], "stats": {"total": 366, "additions": 314, "deletions": 52}, "files": [{"sha": "b5fd3eb44628cb33a9af306e1cfd7208b52b93bc", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 163, "deletions": 52, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/aeb765b299640ee0674d2c01df600c296af7d691/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb765b299640ee0674d2c01df600c296af7d691/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=aeb765b299640ee0674d2c01df600c296af7d691", "patch": "@@ -978,45 +978,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     label_span_not_found(&mut err);\n                 }\n \n-                if let SelfSource::MethodCall(expr) = source\n-                    && let Some((fields, substs)) = self.get_field_candidates(span, actual)\n-                {\n-                    let call_expr =\n-                        self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n-                    for candidate_field in fields.iter() {\n-                        if let Some(field_path) = self.check_for_nested_field_satisfying(\n-                            span,\n-                            &|_, field_ty| {\n-                                self.lookup_probe(\n-                                    span,\n-                                    item_name,\n-                                    field_ty,\n-                                    call_expr,\n-                                    ProbeScope::AllTraits,\n-                                )\n-                                .is_ok()\n-                            },\n-                            candidate_field,\n-                            substs,\n-                            vec![],\n-                            self.tcx.parent_module(expr.hir_id).to_def_id(),\n-                        ) {\n-                            let field_path_str = field_path\n-                                .iter()\n-                                .map(|id| id.name.to_ident_string())\n-                                .collect::<Vec<String>>()\n-                                .join(\".\");\n-                            debug!(\"field_path_str: {:?}\", field_path_str);\n+                self.check_for_field_method(&mut err, source, span, actual, item_name);\n \n-                            err.span_suggestion_verbose(\n-                                item_name.span.shrink_to_lo(),\n-                                \"one of the expressions' fields has a method of the same name\",\n-                                format!(\"{field_path_str}.\"),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                    }\n-                }\n+                self.check_for_unwrap_self(&mut err, source, span, actual, item_name);\n \n                 bound_spans.sort();\n                 bound_spans.dedup();\n@@ -1343,6 +1307,157 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n+    fn check_for_field_method(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        source: SelfSource<'tcx>,\n+        span: Span,\n+        actual: Ty<'tcx>,\n+        item_name: Ident,\n+    ) {\n+        if let SelfSource::MethodCall(expr) = source\n+            && let Some((fields, substs)) = self.get_field_candidates(span, actual)\n+        {\n+            let call_expr = self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n+            for candidate_field in fields.iter() {\n+                if let Some(field_path) = self.check_for_nested_field_satisfying(\n+                    span,\n+                    &|_, field_ty| {\n+                        self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            field_ty,\n+                            call_expr,\n+                            ProbeScope::AllTraits,\n+                        )\n+                        .is_ok()\n+                    },\n+                    candidate_field,\n+                    substs,\n+                    vec![],\n+                    self.tcx.parent_module(expr.hir_id).to_def_id(),\n+                ) {\n+                    let field_path_str = field_path\n+                        .iter()\n+                        .map(|id| id.name.to_ident_string())\n+                        .collect::<Vec<String>>()\n+                        .join(\".\");\n+                    debug!(\"field_path_str: {:?}\", field_path_str);\n+\n+                    err.span_suggestion_verbose(\n+                        item_name.span.shrink_to_lo(),\n+                        \"one of the expressions' fields has a method of the same name\",\n+                        format!(\"{field_path_str}.\"),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_for_unwrap_self(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+        source: SelfSource<'tcx>,\n+        span: Span,\n+        actual: Ty<'tcx>,\n+        item_name: Ident,\n+    ) {\n+        let tcx = self.tcx;\n+        let SelfSource::MethodCall(expr) = source else { return; };\n+        let call_expr = tcx.hir().expect_expr(tcx.hir().get_parent_node(expr.hir_id));\n+\n+        let ty::Adt(kind, substs) = actual.kind() else { return; };\n+        if !kind.is_enum() {\n+            return;\n+        }\n+\n+        let matching_variants: Vec<_> = kind\n+            .variants()\n+            .iter()\n+            .filter_map(|variant| {\n+                let [field] = &variant.fields[..] else { return None; };\n+                let field_ty = field.ty(tcx, substs);\n+\n+                // Skip `_`, since that'll just lead to ambiguity.\n+                if matches!(self.resolve_vars_if_possible(field_ty).kind(), ty::Infer(_)) {\n+                    return None;\n+                }\n+\n+                if let Ok(pick) =\n+                    self.lookup_probe(span, item_name, field_ty, call_expr, ProbeScope::AllTraits)\n+                {\n+                    Some((variant, field, pick))\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect();\n+\n+        let ret_ty_matches = |diagnostic_item| {\n+            if let Some(ret_ty) = self\n+                .ret_coercion\n+                .as_ref()\n+                .map(|c| self.resolve_vars_if_possible(c.borrow().expected_ty()))\n+                && let ty::Adt(kind, _) = ret_ty.kind()\n+                && tcx.get_diagnostic_item(diagnostic_item) == Some(kind.did())\n+            {\n+                true\n+            } else {\n+                false\n+            }\n+        };\n+\n+        match &matching_variants[..] {\n+            [(_, field, pick)] if Some(kind.did()) == tcx.get_diagnostic_item(sym::Result) => {\n+                let self_ty = field.ty(tcx, substs);\n+                err.span_note(\n+                    tcx.def_span(pick.item.def_id),\n+                    &format!(\"the method `{item_name}` exists on the type `{self_ty}`\"),\n+                );\n+                if ret_ty_matches(sym::Result) {\n+                    err.span_suggestion_verbose(\n+                        expr.span.shrink_to_hi(),\n+                        format!(\"use the `?` operator to extract the `{self_ty}` value, propagating a `Result::Err` value to the caller\"),\n+                        \"?\".to_owned(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    err.span_suggestion_verbose(\n+                        expr.span.shrink_to_hi(),\n+                        format!(\"consider using `Result::expect` to unwrap the `{self_ty}` value, panicking if the value is an `Err`\"),\n+                        \".expect(\\\"REASON\\\")\".to_owned(),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+            }\n+            [(_, field, pick)] if Some(kind.did()) == tcx.get_diagnostic_item(sym::Option) => {\n+                let self_ty = field.ty(tcx, substs);\n+                err.span_note(\n+                    tcx.def_span(pick.item.def_id),\n+                    &format!(\"the method `{item_name}` exists on the type `{self_ty}`\"),\n+                );\n+                if ret_ty_matches(sym::Option) {\n+                    err.span_suggestion_verbose(\n+                        expr.span.shrink_to_hi(),\n+                        format!(\"use the `?` operator to extract the `{self_ty}` value, propagating a `None` to the caller\"),\n+                        \"?\".to_owned(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    err.span_suggestion_verbose(\n+                        expr.span.shrink_to_hi(),\n+                        format!(\"consider using `Option::expect` to unwrap the `{self_ty}` value, panicking if the value is `None`\"),\n+                        \".expect(\\\"REASON\\\")\".to_owned(),\n+                        Applicability::HasPlaceholders,\n+                    );\n+                }\n+            }\n+            // FIXME(compiler-errors): Support suggestions for other matching enum variants\n+            _ => {}\n+        }\n+    }\n+\n     pub(crate) fn note_unmet_impls_on_type(\n         &self,\n         err: &mut Diagnostic,\n@@ -1662,13 +1777,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (self.tcx.mk_mut_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&mut \"),\n                 (self.tcx.mk_imm_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&\"),\n             ] {\n-                match self.lookup_probe(\n-                    span,\n-                    item_name,\n-                    *rcvr_ty,\n-                    rcvr,\n-                    crate::check::method::probe::ProbeScope::AllTraits,\n-                ) {\n+                match self.lookup_probe(span, item_name, *rcvr_ty, rcvr, ProbeScope::AllTraits) {\n                     Ok(pick) => {\n                         // If the method is defined for the receiver we have, it likely wasn't `use`d.\n                         // We point at the method, but we just skip the rest of the check for arbitrary\n@@ -1700,13 +1809,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Arc), \"Arc::new\"),\n                     (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Rc), \"Rc::new\"),\n                 ] {\n-                    if let Some(new_rcvr_t) = *rcvr_ty && let Ok(pick) = self.lookup_probe(\n-                        span,\n-                        item_name,\n-                        new_rcvr_t,\n-                        rcvr,\n-                        crate::check::method::probe::ProbeScope::AllTraits,\n-                    ) {\n+                    if let Some(new_rcvr_t) = *rcvr_ty\n+                        && let Ok(pick) = self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            new_rcvr_t,\n+                            rcvr,\n+                            ProbeScope::AllTraits,\n+                        )\n+                    {\n                         debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n                         let did = Some(pick.item.container.id());\n                         // We don't want to suggest a container type when the missing"}, {"sha": "990f7900f22324600c3acfd3373da132769cd2a2", "filename": "src/test/ui/suggestions/enum-method-probe.fixed", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aeb765b299640ee0674d2c01df600c296af7d691/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/aeb765b299640ee0674d2c01df600c296af7d691/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.fixed?ref=aeb765b299640ee0674d2c01df600c296af7d691", "patch": "@@ -0,0 +1,42 @@\n+// run-rustfix\n+#![allow(unused)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn get(&self) -> u8 {\n+        42\n+    }\n+}\n+\n+fn test_result_in_result() -> Result<(), ()> {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res?.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP use the `?` operator\n+    Ok(())\n+}\n+\n+fn test_result_in_plain() {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.expect(\"REASON\").get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is an `Err`\n+}\n+\n+fn test_option_in_option() -> Option<()> {\n+    let res: Option<_> = Some(Foo);\n+    res?.get();\n+    //~^ ERROR no method named `get` found for enum `Option` in the current scope\n+    //~| HELP use the `?` operator\n+    Some(())\n+}\n+\n+fn test_option_in_plain() {\n+    let res: Option<_> = Some(Foo);\n+    res.expect(\"REASON\").get();\n+    //~^ ERROR no method named `get` found for enum `Option` in the current scope\n+    //~| HELP consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is `None`\n+}\n+\n+fn main() {}"}, {"sha": "6270fa9fea598387c0c931df66c4d693307447dd", "filename": "src/test/ui/suggestions/enum-method-probe.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aeb765b299640ee0674d2c01df600c296af7d691/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeb765b299640ee0674d2c01df600c296af7d691/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.rs?ref=aeb765b299640ee0674d2c01df600c296af7d691", "patch": "@@ -0,0 +1,42 @@\n+// run-rustfix\n+#![allow(unused)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn get(&self) -> u8 {\n+        42\n+    }\n+}\n+\n+fn test_result_in_result() -> Result<(), ()> {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP use the `?` operator\n+    Ok(())\n+}\n+\n+fn test_result_in_plain() {\n+    let res: Result<_, ()> = Ok(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Result` in the current scope\n+    //~| HELP consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is an `Err`\n+}\n+\n+fn test_option_in_option() -> Option<()> {\n+    let res: Option<_> = Some(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Option` in the current scope\n+    //~| HELP use the `?` operator\n+    Some(())\n+}\n+\n+fn test_option_in_plain() {\n+    let res: Option<_> = Some(Foo);\n+    res.get();\n+    //~^ ERROR no method named `get` found for enum `Option` in the current scope\n+    //~| HELP consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is `None`\n+}\n+\n+fn main() {}"}, {"sha": "4af1775f66bf90390b703ffada72397325f05c7e", "filename": "src/test/ui/suggestions/enum-method-probe.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/aeb765b299640ee0674d2c01df600c296af7d691/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aeb765b299640ee0674d2c01df600c296af7d691/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fenum-method-probe.stderr?ref=aeb765b299640ee0674d2c01df600c296af7d691", "patch": "@@ -0,0 +1,67 @@\n+error[E0599]: no method named `get` found for enum `Result` in the current scope\n+  --> $DIR/enum-method-probe.rs:14:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Result<Foo, ()>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:7:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: use the `?` operator to extract the `Foo` value, propagating a `Result::Err` value to the caller\n+   |\n+LL |     res?.get();\n+   |        +\n+\n+error[E0599]: no method named `get` found for enum `Result` in the current scope\n+  --> $DIR/enum-method-probe.rs:22:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Result<Foo, ()>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:7:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: consider using `Result::expect` to unwrap the `Foo` value, panicking if the value is an `Err`\n+   |\n+LL |     res.expect(\"REASON\").get();\n+   |        +++++++++++++++++\n+\n+error[E0599]: no method named `get` found for enum `Option` in the current scope\n+  --> $DIR/enum-method-probe.rs:29:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Option<Foo>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:7:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: use the `?` operator to extract the `Foo` value, propagating a `None` to the caller\n+   |\n+LL |     res?.get();\n+   |        +\n+\n+error[E0599]: no method named `get` found for enum `Option` in the current scope\n+  --> $DIR/enum-method-probe.rs:37:9\n+   |\n+LL |     res.get();\n+   |         ^^^ method not found in `Option<Foo>`\n+   |\n+note: the method `get` exists on the type `Foo`\n+  --> $DIR/enum-method-probe.rs:7:5\n+   |\n+LL |     fn get(&self) -> u8 {\n+   |     ^^^^^^^^^^^^^^^^^^^\n+help: consider using `Option::expect` to unwrap the `Foo` value, panicking if the value is `None`\n+   |\n+LL |     res.expect(\"REASON\").get();\n+   |        +++++++++++++++++\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}]}