{"sha": "3ae6b80ab11c427d210894f61335b098beaaf2ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhZTZiODBhYjExYzQyN2QyMTA4OTRmNjEzMzViMDk4YmVhYWYyYmE=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-07T13:10:52Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-07T13:10:52Z"}, "message": "Remove Pointer's repr field and make it Copy.\n\nThis required refactoring throughout and math operators have been temporarily\ncommented out.", "tree": {"sha": "4a8a5254eff72ad54a014054cbef739e1a450c76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a8a5254eff72ad54a014054cbef739e1a450c76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ae6b80ab11c427d210894f61335b098beaaf2ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ae6b80ab11c427d210894f61335b098beaaf2ba", "html_url": "https://github.com/rust-lang/rust/commit/3ae6b80ab11c427d210894f61335b098beaaf2ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ae6b80ab11c427d210894f61335b098beaaf2ba/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d6cd1f420462e980c10354bb72b64d0a3745a2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d6cd1f420462e980c10354bb72b64d0a3745a2e", "html_url": "https://github.com/rust-lang/rust/commit/6d6cd1f420462e980c10354bb72b64d0a3745a2e"}], "stats": {"total": 263, "additions": 135, "deletions": 128}, "files": [{"sha": "c08ef00612b278c8847c6f6d72cac1e95653873f", "filename": "src/interpreter.rs", "status": "modified", "additions": 105, "deletions": 97, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/3ae6b80ab11c427d210894f61335b098beaaf2ba/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae6b80ab11c427d210894f61335b098beaaf2ba/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=3ae6b80ab11c427d210894f61335b098beaaf2ba", "patch": "@@ -57,8 +57,10 @@ impl fmt::Display for EvalError {\n // }\n \n /// A stack frame.\n-#[derive(Debug)]\n-struct Frame {\n+struct Frame<'a, 'tcx: 'a> {\n+    /// The MIR for the fucntion called on this frame.\n+    mir: &'a Mir<'tcx>,\n+\n     /// A pointer for writing the return value of the current call, if it's not a diverging call.\n     return_ptr: Option<Pointer>,\n \n@@ -74,28 +76,28 @@ struct Frame {\n     temp_offset: usize,\n }\n \n-impl Frame {\n+impl<'a, 'tcx: 'a> Frame<'a, 'tcx> {\n     fn arg_ptr(&self, i: u32) -> Pointer {\n-        self.locals[i as usize].clone()\n+        self.locals[i as usize]\n     }\n \n     fn var_ptr(&self, i: u32) -> Pointer {\n-        self.locals[self.var_offset + i as usize].clone()\n+        self.locals[self.var_offset + i as usize]\n     }\n \n     fn temp_ptr(&self, i: u32) -> Pointer {\n-        self.locals[self.temp_offset + i as usize].clone()\n+        self.locals[self.temp_offset + i as usize]\n     }\n }\n \n struct Interpreter<'a, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n     mir_map: &'a MirMap<'tcx>,\n     memory: memory::Memory,\n-    stack: Vec<Frame>,\n+    stack: Vec<Frame<'a, 'tcx>>,\n }\n \n-impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n+impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n     fn new(tcx: &'a TyCtxt<'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n         Interpreter {\n             tcx: tcx,\n@@ -105,27 +107,29 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         }\n     }\n \n-    fn push_stack_frame(&mut self, mir: &Mir, args: &[&mir::Operand], return_ptr: Option<Pointer>)\n-        -> EvalResult<()>\n-    {\n+    fn push_stack_frame(&mut self, mir: &'a Mir<'tcx>, args: &[&mir::Operand<'tcx>],\n+                        return_ptr: Option<Pointer>) -> EvalResult<()> {\n         let num_args = mir.arg_decls.len();\n         let num_vars = mir.var_decls.len();\n+        let num_temps = mir.temp_decls.len();\n         assert_eq!(args.len(), num_args);\n \n-        let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n-        let var_tys = mir.var_decls.iter().map(|v| v.ty);\n-        let temp_tys = mir.temp_decls.iter().map(|t| t.ty);\n-\n-        let locals: Vec<Pointer> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n-            self.memory.allocate(Repr::from_ty(ty))\n-        }).collect();\n+        let mut locals = Vec::with_capacity(num_args + num_vars + num_temps);\n \n-        for (dest, operand) in locals[..num_args].iter().zip(args) {\n-            let src = try!(self.operand_to_ptr(operand));\n-            try!(self.memory.copy(&src, dest, dest.repr.size()));\n+        for (arg_decl, arg_operand) in mir.arg_decls.iter().zip(args) {\n+            let repr = Repr::from_ty(arg_decl.ty);\n+            let dest = self.memory.allocate(&repr);\n+            let src = try!(self.operand_to_ptr(arg_operand));\n+            try!(self.memory.copy(src, dest, repr.size()));\n+            locals.push(dest);\n         }\n \n-        self.stack.push(Frame { \n+        let var_tys = mir.var_decls.iter().map(|v| v.ty);\n+        let temp_tys = mir.temp_decls.iter().map(|t| t.ty);\n+        locals.extend(var_tys.chain(temp_tys).map(|ty| self.memory.allocate(&Repr::from_ty(ty))));\n+\n+        self.stack.push(Frame {\n+            mir: mir,\n             return_ptr: return_ptr,\n             locals: locals,\n             var_offset: num_args,\n@@ -140,9 +144,8 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         // TODO(tsion): Deallocate local variables.\n     }\n \n-    fn call(&mut self, mir: &Mir, args: &[&mir::Operand], return_ptr: Option<Pointer>)\n-        -> EvalResult<()>\n-    {\n+    fn call(&mut self, mir: &'a Mir<'tcx>, args: &[&mir::Operand<'tcx>],\n+            return_ptr: Option<Pointer>) -> EvalResult<()> {\n         try!(self.push_stack_frame(mir, args, return_ptr));\n         let mut current_block = mir::START_BLOCK;\n \n@@ -153,8 +156,7 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n             for stmt in &block_data.statements {\n                 if TRACE_EXECUTION { println!(\"{:?}\", stmt); }\n                 let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n-                let ptr = try!(self.lvalue_to_ptr(lvalue));\n-                try!(self.eval_rvalue_into(rvalue, &ptr));\n+                try!(self.eval_assignment(lvalue, rvalue));\n             }\n \n             if TRACE_EXECUTION { println!(\"{:?}\", block_data.terminator()); }\n@@ -167,7 +169,7 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n \n                 If { ref cond, targets: (then_target, else_target) } => {\n                     let cond_ptr = try!(self.operand_to_ptr(cond));\n-                    let cond = try!(self.memory.read_bool(&cond_ptr));\n+                    let cond = try!(self.memory.read_bool(cond_ptr));\n                     current_block = if cond { then_target } else { else_target };\n                 }\n \n@@ -232,15 +234,15 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn lvalue_to_ptr(&self, lvalue: &mir::Lvalue) -> EvalResult<Pointer> {\n-        let frame = self.stack.last().expect(\"no call frames exists\");\n+    fn lvalue_to_ptr(&self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<Pointer> {\n+        let frame = self.current_frame();\n \n         use rustc::mir::repr::Lvalue::*;\n         let ptr = match *lvalue {\n-            ReturnPointer => frame.return_ptr.clone()\n-                .expect(\"ReturnPointer used in a function with no return value\"),\n-            Arg(i)  => frame.arg_ptr(i),\n-            Var(i)  => frame.var_ptr(i),\n+            ReturnPointer =>\n+                frame.return_ptr.expect(\"ReturnPointer used in a function with no return value\"),\n+            Arg(i) => frame.arg_ptr(i),\n+            Var(i) => frame.var_ptr(i),\n             Temp(i) => frame.temp_ptr(i),\n             ref l => panic!(\"can't handle lvalue: {:?}\", l),\n         };\n@@ -283,75 +285,79 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         // }\n     }\n \n-    fn eval_binary_op(&mut self, bin_op: mir::BinOp, left: Pointer, right: Pointer, dest: &Pointer)\n-            -> EvalResult<()> {\n-        use rustc::mir::repr::BinOp::*;\n-        match (&left.repr, &right.repr, &dest.repr) {\n-            (&Repr::Int, &Repr::Int, &Repr::Int) => {\n-                let l = try!(self.memory.read_int(&left));\n-                let r = try!(self.memory.read_int(&right));\n-                let n = match bin_op {\n-                    Add    => l + r,\n-                    Sub    => l - r,\n-                    Mul    => l * r,\n-                    Div    => l / r,\n-                    Rem    => l % r,\n-                    BitXor => l ^ r,\n-                    BitAnd => l & r,\n-                    BitOr  => l | r,\n-                    Shl    => l << r,\n-                    Shr    => l >> r,\n-                    _      => unimplemented!(),\n-                    // Eq     => Value::Bool(l == r),\n-                    // Lt     => Value::Bool(l < r),\n-                    // Le     => Value::Bool(l <= r),\n-                    // Ne     => Value::Bool(l != r),\n-                    // Ge     => Value::Bool(l >= r),\n-                    // Gt     => Value::Bool(l > r),\n-                };\n-                self.memory.write_int(dest, n)\n-            }\n-            (l, r, o) =>\n-                panic!(\"unhandled binary operation: {:?}({:?}, {:?}) into {:?}\", bin_op, l, r, o),\n-        }\n-    }\n+    // fn eval_binary_op(&mut self, bin_op: mir::BinOp, left: Pointer, right: Pointer, dest: Pointer)\n+    //         -> EvalResult<()> {\n+    //     use rustc::mir::repr::BinOp::*;\n+    //     match (&left.repr, &right.repr, &dest.repr) {\n+    //         (&Repr::Int, &Repr::Int, &Repr::Int) => {\n+    //             let l = try!(self.memory.read_int(left));\n+    //             let r = try!(self.memory.read_int(right));\n+    //             let n = match bin_op {\n+    //                 Add    => l + r,\n+    //                 Sub    => l - r,\n+    //                 Mul    => l * r,\n+    //                 Div    => l / r,\n+    //                 Rem    => l % r,\n+    //                 BitXor => l ^ r,\n+    //                 BitAnd => l & r,\n+    //                 BitOr  => l | r,\n+    //                 Shl    => l << r,\n+    //                 Shr    => l >> r,\n+    //                 _      => unimplemented!(),\n+    //                 // Eq     => Value::Bool(l == r),\n+    //                 // Lt     => Value::Bool(l < r),\n+    //                 // Le     => Value::Bool(l <= r),\n+    //                 // Ne     => Value::Bool(l != r),\n+    //                 // Ge     => Value::Bool(l >= r),\n+    //                 // Gt     => Value::Bool(l > r),\n+    //             };\n+    //             self.memory.write_int(dest, n)\n+    //         }\n+    //         (l, r, o) =>\n+    //             panic!(\"unhandled binary operation: {:?}({:?}, {:?}) into {:?}\", bin_op, l, r, o),\n+    //     }\n+    // }\n+\n+    fn eval_assignment(&mut self, lvalue: &mir::Lvalue<'tcx>, rvalue: &mir::Rvalue<'tcx>)\n+        -> EvalResult<()>\n+    {\n+        let dest = try!(self.lvalue_to_ptr(lvalue));\n+        let dest_ty = self.current_frame().mir.lvalue_ty(self.tcx, lvalue).to_ty(self.tcx);\n+        let dest_repr = Repr::from_ty(dest_ty);\n \n-    fn eval_rvalue_into(&mut self, rvalue: &mir::Rvalue, dest: &Pointer) -> EvalResult<()> {\n         use rustc::mir::repr::Rvalue::*;\n         match *rvalue {\n             Use(ref operand) => {\n                 let src = try!(self.operand_to_ptr(operand));\n-                try!(self.memory.copy(&src, dest, src.repr.size()));\n+                self.memory.copy(src, dest, dest_repr.size())\n             }\n \n-            BinaryOp(bin_op, ref left, ref right) => {\n-                let left_ptr = try!(self.operand_to_ptr(left));\n-                let right_ptr = try!(self.operand_to_ptr(right));\n-                try!(self.eval_binary_op(bin_op, left_ptr, right_ptr, dest));\n-            }\n-\n-            UnaryOp(un_op, ref operand) => {\n-                let ptr = try!(self.operand_to_ptr(operand));\n-                let m = try!(self.memory.read_int(&ptr));\n-                let n = match (un_op, ptr.repr) {\n-                    (mir::UnOp::Not, Repr::Int) => !m,\n-                    (mir::UnOp::Neg, Repr::Int) => -m,\n-                    (_, ref p) => panic!(\"unhandled binary operation: {:?}({:?})\", un_op, p),\n-                };\n-                try!(self.memory.write_int(dest, n));\n-            }\n+            // BinaryOp(bin_op, ref left, ref right) =>\n+            //     self.eval_binary_op(lvalue, bin_op, left, right),\n+\n+            // UnaryOp(un_op, ref operand) => {\n+            //     let ptr = try!(self.operand_to_ptr(operand));\n+            //     let m = try!(self.memory.read_int(ptr));\n+            //     let n = match (un_op, ptr.repr) {\n+            //         (mir::UnOp::Not, Repr::Int) => !m,\n+            //         (mir::UnOp::Neg, Repr::Int) => -m,\n+            //         (_, ref p) => panic!(\"unhandled binary operation: {:?}({:?})\", un_op, p),\n+            //     };\n+            //     self.memory.write_int(dest, n)\n+            // }\n \n             Aggregate(mir::AggregateKind::Tuple, ref operands) => {\n-                match dest.repr {\n+                match dest_repr {\n                     Repr::Aggregate { ref fields, .. } => {\n                         for (field, operand) in fields.iter().zip(operands) {\n                             let src = try!(self.operand_to_ptr(operand));\n-                            try!(self.memory.copy(&src, &dest.offset(field.offset), src.repr.size()));\n+                            try!(self.memory.copy(src, dest.offset(field.offset),\n+                                                  field.repr.size()));\n                         }\n+                        Ok(())\n                     }\n \n-                    _ => panic!(\"attempted to write tuple rvalue '{:?}' into non-aggregate pointer '{:?}'\",\n-                                rvalue, dest)\n+                    _ => unimplemented!(),\n                 }\n             }\n \n@@ -379,11 +385,9 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n \n             ref r => panic!(\"can't handle rvalue: {:?}\", r),\n         }\n-\n-        Ok(())\n     }\n \n-    fn operand_to_ptr(&mut self, op: &mir::Operand) -> EvalResult<Pointer> {\n+    fn operand_to_ptr(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<Pointer> {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n             Consume(ref lvalue) => self.lvalue_to_ptr(lvalue),\n@@ -407,16 +411,16 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         match *const_val {\n             Float(_f) => unimplemented!(),\n             Int(n) => {\n-                let ptr = self.memory.allocate(Repr::Int);\n-                try!(self.memory.write_int(&ptr, n));\n+                let ptr = self.memory.allocate(&Repr::Int);\n+                try!(self.memory.write_int(ptr, n));\n                 Ok(ptr)\n             }\n             Uint(_u)          => unimplemented!(),\n             Str(ref _s)       => unimplemented!(),\n             ByteStr(ref _bs)  => unimplemented!(),\n             Bool(b) => {\n-                let ptr = self.memory.allocate(Repr::Bool);\n-                try!(self.memory.write_bool(&ptr, b));\n+                let ptr = self.memory.allocate(&Repr::Bool);\n+                try!(self.memory.write_bool(ptr, b));\n                 Ok(ptr)\n             },\n             Struct(_node_id)  => unimplemented!(),\n@@ -426,6 +430,10 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n             Repeat(_, _)      => unimplemented!(),\n         }\n     }\n+\n+    fn current_frame(&self) -> &Frame<'a, 'tcx> {\n+        self.stack.last().expect(\"no call frames exist\")\n+    }\n }\n \n pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>) {\n@@ -438,10 +446,10 @@ pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>)\n \n                 let mut miri = Interpreter::new(tcx, mir_map);\n                 let return_ptr = match mir.return_ty {\n-                    ty::FnConverging(ty) => Some(miri.memory.allocate(Repr::from_ty(ty))),\n+                    ty::FnConverging(ty) => Some(miri.memory.allocate(&Repr::from_ty(ty))),\n                     ty::FnDiverging => None,\n                 };\n-                miri.call(mir, &[], return_ptr.clone()).unwrap();\n+                miri.call(mir, &[], return_ptr).unwrap();\n \n                 if let Some(ret) = return_ptr {\n                     println!(\"Returned: {:?}\\n\", miri.memory.get(ret.alloc_id).unwrap());"}, {"sha": "e6d3f5096fad530fa1bed8a43606510840d55ce7", "filename": "src/memory.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ae6b80ab11c427d210894f61335b098beaaf2ba/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae6b80ab11c427d210894f61335b098beaaf2ba/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=3ae6b80ab11c427d210894f61335b098beaaf2ba", "patch": "@@ -21,11 +21,10 @@ pub struct Allocation {\n     // TODO(tsion): undef mask\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct Pointer {\n     pub alloc_id: AllocId,\n     pub offset: usize,\n-    pub repr: Repr,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -57,11 +56,10 @@ impl Memory {\n         id\n     }\n \n-    pub fn allocate(&mut self, repr: Repr) -> Pointer {\n+    pub fn allocate(&mut self, repr: &Repr) -> Pointer {\n         Pointer {\n             alloc_id: self.allocate_raw(repr.size()),\n             offset: 0,\n-            repr: repr,\n         }\n     }\n \n@@ -73,19 +71,19 @@ impl Memory {\n         self.alloc_map.get_mut(&id.0).ok_or(EvalError::DanglingPointerDeref)\n     }\n \n-    fn get_bytes(&self, ptr: &Pointer, size: usize) -> EvalResult<&[u8]> {\n+    fn get_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<&[u8]> {\n         let alloc = try!(self.get(ptr.alloc_id));\n         try!(alloc.check_bytes(ptr.offset, ptr.offset + size));\n         Ok(&alloc.bytes[ptr.offset..ptr.offset + size])\n     }\n \n-    fn get_bytes_mut(&mut self, ptr: &Pointer, size: usize) -> EvalResult<&mut [u8]> {\n+    fn get_bytes_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<&mut [u8]> {\n         let alloc = try!(self.get_mut(ptr.alloc_id));\n         try!(alloc.check_bytes(ptr.offset, ptr.offset + size));\n         Ok(&mut alloc.bytes[ptr.offset..ptr.offset + size])\n     }\n \n-    pub fn copy(&mut self, src: &Pointer, dest: &Pointer, size: usize) -> EvalResult<()> {\n+    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n         let src_bytes = try!(self.get_bytes_mut(src, size)).as_mut_ptr();\n         let dest_bytes = try!(self.get_bytes_mut(dest, size)).as_mut_ptr();\n \n@@ -103,17 +101,17 @@ impl Memory {\n         Ok(())\n     }\n \n-    pub fn read_int(&self, ptr: &Pointer) -> EvalResult<i64> {\n+    pub fn read_int(&self, ptr: Pointer) -> EvalResult<i64> {\n         self.get_bytes(ptr, Repr::Int.size()).map(byteorder::NativeEndian::read_i64)\n     }\n \n-    pub fn write_int(&mut self, ptr: &Pointer, n: i64) -> EvalResult<()> {\n+    pub fn write_int(&mut self, ptr: Pointer, n: i64) -> EvalResult<()> {\n         let bytes = try!(self.get_bytes_mut(ptr, Repr::Int.size()));\n         byteorder::NativeEndian::write_i64(bytes, n);\n         Ok(())\n     }\n \n-    pub fn read_bool(&self, ptr: &Pointer) -> EvalResult<bool> {\n+    pub fn read_bool(&self, ptr: Pointer) -> EvalResult<bool> {\n         let bytes = try!(self.get_bytes(ptr, 1));\n         match bytes[0] {\n             0 => Ok(false),\n@@ -122,7 +120,7 @@ impl Memory {\n         }\n     }\n \n-    pub fn write_bool(&mut self, ptr: &Pointer, b: bool) -> EvalResult<()> {\n+    pub fn write_bool(&mut self, ptr: Pointer, b: bool) -> EvalResult<()> {\n         let bytes = try!(self.get_bytes_mut(ptr, 1));\n         bytes[0] = b as u8;\n         Ok(())\n@@ -140,8 +138,9 @@ impl Allocation {\n }\n \n impl Pointer {\n-    pub fn offset(&self, i: usize) -> Self {\n-        Pointer { offset: self.offset + i, ..self.clone() }\n+    pub fn offset(self, i: usize) -> Self {\n+        // TODO(tsion): Check for offset out of bounds.\n+        Pointer { offset: self.offset + i, ..self }\n     }\n }\n "}, {"sha": "64b56b01e171f66e8bddd0c0b4ad041561ad4cc9", "filename": "test/new_values.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3ae6b80ab11c427d210894f61335b098beaaf2ba/test%2Fnew_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae6b80ab11c427d210894f61335b098beaaf2ba/test%2Fnew_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fnew_values.rs?ref=3ae6b80ab11c427d210894f61335b098beaaf2ba", "patch": "@@ -6,15 +6,15 @@ fn ret() -> i32 {\n     1\n }\n \n-#[miri_run]\n-fn neg() -> i32 {\n-    -1\n-}\n+// #[miri_run]\n+// fn neg() -> i32 {\n+//     -1\n+// }\n \n-#[miri_run]\n-fn add() -> i32 {\n-    1 + 2\n-}\n+// #[miri_run]\n+// fn add() -> i32 {\n+//     1 + 2\n+// }\n \n #[miri_run]\n fn empty() {}\n@@ -34,17 +34,17 @@ fn tuple_5() -> (i32, i32, i32, i32, i32) {\n     (1, 2, 3, 4, 5)\n }\n \n-#[miri_run]\n-fn indirect_add() -> i32 {\n-    let x = 1;\n-    let y = 2;\n-    x + y\n-}\n+// #[miri_run]\n+// fn indirect_add() -> i32 {\n+//     let x = 1;\n+//     let y = 2;\n+//     x + y\n+// }\n \n-#[miri_run]\n-fn arith() -> i32 {\n-    3*3 + 4*4\n-}\n+// #[miri_run]\n+// fn arith() -> i32 {\n+//     3*3 + 4*4\n+// }\n \n #[miri_run]\n fn boolean() -> bool {"}]}