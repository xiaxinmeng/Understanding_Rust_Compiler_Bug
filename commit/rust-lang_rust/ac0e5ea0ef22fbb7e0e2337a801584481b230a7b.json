{"sha": "ac0e5ea0ef22fbb7e0e2337a801584481b230a7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMGU1ZWEwZWYyMmZiYjdlMGUyMzM3YTgwMTU4NDQ4MWIyMzBhN2I=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-08-10T20:21:51Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-08-15T22:35:28Z"}, "message": "Implement an untyped version of the AST, with a coversion back to the typed AST..", "tree": {"sha": "ce536d87ff9e0b656dcef39ed2e0046254555178", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce536d87ff9e0b656dcef39ed2e0046254555178"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac0e5ea0ef22fbb7e0e2337a801584481b230a7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac0e5ea0ef22fbb7e0e2337a801584481b230a7b", "html_url": "https://github.com/rust-lang/rust/commit/ac0e5ea0ef22fbb7e0e2337a801584481b230a7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac0e5ea0ef22fbb7e0e2337a801584481b230a7b/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebb16e6a25da9694dabe19ecea24baeb7007ba1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebb16e6a25da9694dabe19ecea24baeb7007ba1f", "html_url": "https://github.com/rust-lang/rust/commit/ebb16e6a25da9694dabe19ecea24baeb7007ba1f"}], "stats": {"total": 817, "additions": 817, "deletions": 0}, "files": [{"sha": "839e01a62f561216570d86bbb9632e183751a7df", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac0e5ea0ef22fbb7e0e2337a801584481b230a7b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac0e5ea0ef22fbb7e0e2337a801584481b230a7b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=ac0e5ea0ef22fbb7e0e2337a801584481b230a7b", "patch": "@@ -113,6 +113,7 @@ fn ty_param_kinds_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n     let no_kinds: [ast::kind] = ~[];\n     alt defn {\n       ast::def_arg(id) {\n+\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n         ret {kinds: no_kinds, ty: typ};"}, {"sha": "4ae7ef38f8d713bd1e516569e74a812d08b591f1", "filename": "src/comp/syntax/untyped_ast.rs", "status": "added", "additions": 816, "deletions": 0, "changes": 816, "blob_url": "https://github.com/rust-lang/rust/blob/ac0e5ea0ef22fbb7e0e2337a801584481b230a7b/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac0e5ea0ef22fbb7e0e2337a801584481b230a7b/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs?ref=ac0e5ea0ef22fbb7e0e2337a801584481b230a7b", "patch": "@@ -0,0 +1,816 @@\n+import std::ivec;\n+import std::ivec::map;\n+import std::option;\n+import std::option::some;\n+import std::option::none;\n+\n+import ast::*;\n+import codemap::span;\n+import codemap::filename;\n+\n+tag ast_node {\n+    branch(node_name, option::t[span], (@ast_node)[]);\n+    i_seq((@ast_node)[]);\n+    i_opt(option::t[@ast_node]);\n+    l_bool(bool);\n+    l_ident(ident);\n+    l_fn_ident(fn_ident);\n+    l_path(path); //doesn't have to be a leaf, but is effectively atomic\n+    l_crate_num(crate_num);\n+    l_node_id(node_id);\n+    l_def_id(def_id);\n+    l_ty_param(ty_param);\n+    l_mutability(mutability);\n+    l__auth(_auth); //singleton, but needed for uniformity\n+    l_proto(proto);\n+    l_binop(binop);\n+    // moving this to node_name would make the macro system able to abstract\n+    // over @/@mutable, but that poses parsing problems.\n+    l_unop(unop);\n+    l_mode(mode); //same here\n+    l_init_op(init_op);\n+    l_inlineness(inlineness);\n+    l_native_abi(native_abi);\n+    l_str(str);\n+    l_char(char);\n+    l_int(int);\n+    l_uint(uint);\n+    l_spawn_dom;\n+    l_check_mode;\n+    l_seq_kind;\n+    l_ty_mach;\n+    l_purity;\n+    l_controlflow;\n+    l_attr_style;\n+\n+    // these could be avoided, at the cost of making #br_* more convoluted\n+    l_optional_filename(option::t[filename]);\n+    l_optional_string(option::t[str]);\n+    l_seq_ident(ident[]);\n+    l_seq_ty_param(ty_param[]);\n+\n+}\n+\n+\n+tag node_name {\n+    n_crate_cfg;\n+    n_crate;\n+\n+    //crate_directive:\n+    n_cdir_src_mod;\n+    n_cdir_dir_mod;\n+    n_cdir_view_item;\n+    n_cdir_syntax;\n+    n_cdir_auth;\n+\n+    //meta_item:\n+    n_meta_word;\n+    n_meta_list;\n+    n_meta_name_value;\n+\n+    n_blk;\n+\n+    //pat: (be sure to add node_id)\n+    n_pat_wild;\n+    n_pat_bind;\n+    n_pat_lit;\n+    n_pat_tag;\n+    n_pat_rec;\n+    n_pat_box;\n+\n+    n_field_pat;\n+    //stmt:\n+    n_stmt_decl;\n+    n_stmt_expr;\n+    n_stmt_crate_directive;\n+\n+    n_initializer;\n+    n_local;\n+\n+    //decl:\n+    n_decl_local;\n+    n_decl_item;\n+\n+    n_arm;\n+    //n_elt; //not used\n+    n_field;\n+    //expr: (be sure to add node_id)\n+    n_expr_vec;\n+    n_expr_rec;\n+    n_expr_call;\n+    n_expr_self_method;\n+    n_expr_bind;\n+    n_expr_spawn;\n+    n_expr_binary;\n+    n_expr_unary;\n+    n_expr_lit;\n+    n_expr_cast;\n+    n_expr_if;\n+    n_expr_ternary;\n+    n_expr_while;\n+    n_expr_for;\n+    n_expr_for_each;\n+    n_expr_do_while;\n+    n_expr_alt;\n+    n_expr_fn;\n+    n_expr_block;\n+    n_expr_move;\n+    n_expr_assign;\n+    n_expr_swap;\n+    n_expr_assign_op;\n+    n_expr_send;\n+    n_expr_recv;\n+    n_expr_field;\n+    n_expr_index;\n+    n_expr_path;\n+    n_expr_fail;\n+    n_expr_break;\n+    n_expr_cont;\n+    n_expr_ret;\n+    n_expr_put;\n+    n_expr_be;\n+    n_expr_log;\n+    n_expr_assert;\n+    n_expr_check;\n+    n_expr_if_check;\n+    n_expr_port;\n+    n_expr_chan;\n+    n_expr_anon_obj;\n+    n_expr_mac;\n+\n+    /*\n+    n_mac_invoc; //must be expanded away\n+    n_embed_type; //must be expanded away\n+    n_embed_bloc; //must be expanded away\n+    n_ellipsis; //must be expanded away\n+    */\n+\n+    //lit:\n+    n_lit_str;\n+    n_lit_char;\n+    n_lit_int;\n+    n_lit_uint;\n+    n_lit_mach_int;\n+    n_lit_float;\n+    n_lit_mach_float;\n+    n_lit_nil;\n+    n_lit_bool;\n+\n+    n_mt;\n+    n_ty_field;\n+    n_ty_arg;\n+    n_ty_method;\n+\n+    //ty:\n+    n_ty_nil;\n+    //ty_bot; //\"there is no syntax for this type\"\n+    n_ty_bool;\n+    n_ty_int;\n+    n_ty_uint;\n+    n_ty_float;\n+    n_ty_machine;\n+    n_ty_char;\n+    n_ty_str;\n+    n_ty_istr;\n+    n_ty_box;\n+    n_ty_vec;\n+    n_ty_ivec;\n+    n_ty_ptr;\n+    n_ty_task;\n+    n_ty_port;\n+    n_ty_chan;\n+    n_ty_rec;\n+    n_ty_fn;\n+    n_ty_obj;\n+    n_ty_path;\n+    n_ty_type;\n+    n_ty_constr;\n+    //n_ty_mac; //should be expanded away\n+\n+    //carg_* and constr are a little funny, since they're type-parametric\n+    //constr_arg:\n+    n_carg_base;\n+    n_carg_ident;\n+    n_carg_lit;\n+\n+    n_constr;\n+    //ack, there's a type and tag with the same name:\n+    n_ty_constr_theactualconstraint;\n+    n_arg;\n+    n_fn_decl;\n+    n__fn;\n+    n_method;\n+    n_obj_field;\n+    n_anon_obj_field;\n+    n__obj;\n+    n_anon_obj;\n+    n__mod;\n+    n_native_mod;\n+    n_variant_arg;\n+    n_variant;\n+\n+    //view_item: (it might be necessary to restrict the generation of these)\n+    n_view_item_use;\n+    n_view_item_import;\n+    n_view_item_import_glob;\n+    n_view_item_export;\n+\n+    //n_obj_def_ids; //not used\n+    n_attribute;\n+\n+    //special case; has ident, attrs, node_id, and span\n+    n_item;\n+    //item_:\n+    n_item_const;\n+    n_item_fn;\n+    n_item_mod;\n+    n_item_native_mod;\n+    n_item_ty;\n+    n_item_tag;\n+    n_item_obj;\n+    n_item_res;\n+\n+    //special case; has ident, attrs, node_id, and span\n+    n_native_item;\n+    //native_item_:\n+    n_native_item_ty;\n+    n_native_item_fn;\n+}\n+\n+type ctx = {\n+    ff: ff,\n+    sess: driver::session::session, //maybe remove\n+    next_id: fn() -> node_id\n+};\n+\n+/** Type of failure function: to be invoked if typification fails.\n+    It's hopefully a bug for this to be invoked without a span. */\n+type ff = fn(sp: option::t[span], msg: str) -> !;\n+\n+fn dummy() {\n+\n+    // arguments explicitly structured here (instead of writing `args, ...`)\n+    // to make error messages easier to deal with.\n+    #macro[[#br_alt[val, ctx, [[tagname, n_tagname, [elt, ...]],\n+                              more_tags, ...]],\n+            #br_alt_gen[do_span, val, ctx, [[tagname, n_tagname, [elt, ...]],\n+                                           more_tags, ...]]]];\n+    #macro[[#br_alt_no_span[val, ctx,\n+                            [[tagname, n_tagname, [elt, ...]],\n+                             more_tags, ...]],\n+            #br_alt_gen[do_not_span, val, ctx,\n+                        [[tagname, n_tagname, [elt, ...]], more_tags, ...]]]];\n+\n+    // the silly `n_tagname` will be replacable with an invocation of\n+    // #concat_idents after subtitution into arbitrary AST nodes works\n+    #macro[[#br_alt_gen[possibly_span, val, ctx,\n+                        [[tagname, n_tagname, [elt, ...]], more_tags, ...]],\n+            alt val {\n+              branch(n_tagname., sp, chldrn) {\n+                #possibly_span[sp, #br_alt_core[ctx, sp, tagname,\n+                                                chldrn, 0u, [elt, ...], []]]\n+              }\n+              //replace this explicit recursion with `...`, once it works\n+              //over all kinds of AST nodes.\n+              _ { #br_alt_gen[possibly_span, val, ctx, [more_tags, ...]] }\n+            }\n+           ],\n+           [#br_alt_gen[possibly_span, val, ctx, []],\n+            alt val {\n+              branch(_, sp, _) {\n+                ctx.ff(sp, \"expected \" + #ident_to_str[tagname])\n+              }\n+              _ { ctx.ff(none, \"expected \" + #ident_to_str[tagname]) }\n+            }\n+           ]];\n+\n+    // this wackiness is just because we need indices\n+    #macro[[#br_alt_core[ctx, sp, ctor, kids, offset, [h, more_hs, ...],\n+                         [accum, ...]],\n+            #br_alt_core[ctx, sp, ctor, kids, offset+1u, [more_hs, ...],\n+                         [accum, ...,\n+                          #extract_elt[ctx, sp, kids, offset, h]]]],\n+           [#br_alt_core[ctx, sp, ctor, kids, offset, [], [accum, ...]],\n+            ctor(accum, ...)]];\n+\n+\n+\n+    #macro[[#br_rec[args, ...], #br_rec_gen[do_span, args, ...]]];\n+    #macro[[#br_rec_no_span[args, ...], #br_rec_gen[do_not_span, args, ...]]];\n+\n+\n+    #macro[[#br_rec_gen[possibly_span, val, ctx, tagname, n_tagname, fields],\n+            alt val {\n+              branch(n_tagname., sp, chldrn) {\n+                #possibly_span[sp, #br_rec_core[ctx, sp, chldrn, fields]]\n+              }\n+              branch(_, sp, _) {\n+                ctx.ff(sp, \"expected \" + #ident_to_str[tagname])\n+              }\n+              _ { ctx.ff(option::none, \"expected \" + #ident_to_str[tagname]) }\n+            }]];\n+\n+    #macro[[#do_span[sp, node_val],\n+            {node: node_val,\n+             span: alt sp {\n+               some(s) { s }\n+               none. { ctx.ff(none, \"needed a span\"); }\n+             }\n+            }]];\n+    #macro[[#do_not_span[sp, node_val], node_val]];\n+\n+\n+    //this abomination can go away when `...` works properly over\n+    //all kinds of AST nodes.\n+    #macro[[#br_rec_core[ctx, sp, kids, [[f0, fh0]]],\n+            {f0: #extract_elt[ctx, sp, kids, 0u, fh0]}],\n+           [#br_rec_core[ctx, sp, kids, [[f0, fh0], [f1, fh1]]],\n+            {f0: #extract_elt[ctx, sp, kids, 0u, fh0],\n+             f1: #extract_elt[ctx, sp, kids, 1u, fh1]}],\n+           [#br_rec_core[ctx, sp, kids, [[f0, fh0], [f1, fh1], [f2, fh2]]],\n+            {f0: #extract_elt[ctx, sp, kids, 0u, fh0],\n+             f1: #extract_elt[ctx, sp, kids, 1u, fh1],\n+             f2: #extract_elt[ctx, sp, kids, 2u, fh2]}],\n+           [#br_rec_core[ctx, sp, kids,\n+                         [[f0, fh0], [f1, fh1], [f2, fh2], [f3, fh3]]],\n+            {f0: #extract_elt[ctx, sp, kids, 0u, fh0],\n+             f1: #extract_elt[ctx, sp, kids, 1u, fh1],\n+             f2: #extract_elt[ctx, sp, kids, 2u, fh2],\n+             f3: #extract_elt[ctx, sp, kids, 3u, fh3]}],\n+           [#br_rec_core[ctx, sp, kids,\n+                         [[f0, fh0], [f1, fh1], [f2, fh2], [f3, fh3],\n+                          [f4, fh4]]],\n+            {f0: #extract_elt[ctx, sp, kids, 0u, fh0],\n+             f1: #extract_elt[ctx, sp, kids, 1u, fh1],\n+             f2: #extract_elt[ctx, sp, kids, 2u, fh2],\n+             f3: #extract_elt[ctx, sp, kids, 3u, fh3],\n+             f4: #extract_elt[ctx, sp, kids, 4u, fh4]}],\n+           [#br_rec_core[ctx, sp, kids,\n+                         [[f0, fh0], [f1, fh1], [f2, fh2], [f3, fh3],\n+                          [f4, fh4], [f5, fh5]]],\n+            {f0: #extract_elt[ctx, sp, kids, 0u, fh0],\n+             f1: #extract_elt[ctx, sp, kids, 1u, fh1],\n+             f2: #extract_elt[ctx, sp, kids, 2u, fh2],\n+             f3: #extract_elt[ctx, sp, kids, 3u, fh3],\n+             f4: #extract_elt[ctx, sp, kids, 4u, fh4],\n+             f5: #extract_elt[ctx, sp, kids, 5u, fh5]}]];\n+\n+    #macro[ //keywords would make these two nicer:\n+        [#extract_elt[ctx, sp, elts, idx, []], ctx.next_id()],\n+        [#extract_elt[ctx, cp, elts, idx, [[]]], sp],\n+        [#extract_elt[ctx, sp, elts, idx, [leaf_destructure]],\n+         alt *elts.(idx) {\n+           leaf_destructure(x) { x }\n+           _ {\n+             ctx.ff(sp, #fmt[\"expected %s in position %u\",\n+                             #ident_to_str[leaf_destructure], idx])\n+           }\n+         }],\n+        [#extract_elt[ctx, sp, elts, idx, extract_fn],\n+         extract_fn(ctx, elts.(idx))]];\n+}\n+\n+fn seq_cv[T](conversion: fn (&ctx, &@ast_node) -> T)\n+    -> fn (&ctx, @ast_node) -> T[] {\n+    ret lambda(ctx: &ctx, ut: @ast_node) -> T[] {\n+        ret alt *ut {\n+          i_seq(uts) { map(bind conversion(ctx, _), uts) }\n+          branch(_, sp, _) {\n+            ctx.ff(sp, \"expected a sequence, found a branch\");\n+          }\n+          _ { ctx.ff(none, \"expected a sequence\"); }\n+        }\n+    }\n+}\n+\n+fn opt_cv[T](conversion: fn (&ctx, &@ast_node) -> T)\n+    -> fn (&ctx, @ast_node) -> option::t[T] {\n+    ret lambda(ctx: &ctx, ut: @ast_node) -> option::t[T] {\n+        ret alt *ut {\n+          i_opt(ut_maybe) { option::map(bind conversion(ctx, _), ut_maybe) }\n+          branch(_, sp, _) {\n+            ctx.ff(sp, \"expected a sequence, found a branch\");\n+          }\n+          _ { ctx.ff(none, \"expected a sequence\"); }\n+        }\n+    }\n+}\n+\n+\n+// expect leaf/branch fn \u00d7 scalar/vec/option\n+\n+fn cv_crate(ctx: &ctx, ut: &@ast_node) -> @crate {\n+    ret @#br_rec[*ut, ctx, crate, n_crate,\n+                 [[directives, seq_cv(cv_crate_directive)],\n+                  [module, cv__mod],\n+                  [attrs, seq_cv(cv_attribute)],\n+                  [config, cv_crate_cfg]]];\n+}\n+\n+fn cv_crate_cfg(ctx: &ctx, ut: &@ast_node) -> crate_cfg {\n+    ret alt *ut {\n+      branch(n_crate_cfg., _, meta_items) {\n+        ivec::map(bind cv_meta_item(ctx,_), meta_items)\n+      }\n+      branch(_, sp, _) { ctx.ff(sp,\"Invalid crate_cfg\") }\n+    };\n+}\n+\n+fn cv_crate_directive(ctx: &ctx, ut: &@ast_node) -> @crate_directive {\n+    ret @#br_alt[*ut, ctx,\n+                 [[cdir_src_mod, n_cdir_src_mod,\n+                   [[l_ident], [l_optional_filename], seq_cv(cv_attribute)]],\n+                  [cdir_dir_mod, n_cdir_dir_mod,\n+                   [[l_ident], [l_optional_filename],\n+                    seq_cv(cv_crate_directive),\n+                    seq_cv(cv_attribute)]],\n+                  [cdir_view_item, n_cdir_view_item, [cv_view_item]],\n+                  [cdir_syntax, n_cdir_syntax,       [[l_path]]],\n+                  [cdir_auth, n_cdir_auth,           [[l_path], [l__auth]]]]];\n+}\n+\n+fn cv_meta_item(ctx: &ctx, ut: &@ast_node) -> @meta_item {\n+    ret @#br_alt[*ut, ctx,\n+                 [[meta_word, n_meta_word,             [[l_ident]]],\n+                  [meta_list, n_meta_list,\n+                   [[l_ident], seq_cv(cv_meta_item)]],\n+                  [meta_name_value, n_meta_name_value, [[l_ident], cv_lit]]]];\n+}\n+\n+fn cv_blk(ctx: &ctx, ut: &@ast_node) -> blk {\n+    ret #br_rec[*ut, ctx, blk, n_blk,\n+                [[stmts, seq_cv(cv_stmt)],\n+                 [expr,  opt_cv(cv_stmt)],\n+                 [id,    [l_node_id]]]];\n+}\n+\n+fn cv_pat(ctx: &ctx, ut: &@ast_node) -> @pat {\n+    ret @{id: ctx.next_id(),\n+          node: #br_alt_no_span\n+              [*ut, ctx,\n+               [[pat_wild, n_pat_wild, []],\n+                [pat_bind, n_pat_bind, [[l_ident]]],\n+                [pat_tag, n_pat_tag,   [[l_ident], seq_cv(cv_pat)]],\n+                [pat_rec, n_pat_rec,   [seq_cv(cv_field_pat),\n+                                        [l_bool]]],\n+                [pat_box, n_pat_box,   [cv_pat]]]],\n+          span: alt *ut {\n+            branch(_,some(sp),_) { sp }\n+            none. { ctx.ff(\"pat needs a span\"); }\n+          }\n+         }\n+}\n+\n+fn cv_field_pat(ctx: &ctx, ut: &@ast_node) -> field_pat {\n+    ret #br_rec[*ut, ctx, field_pat, n_field_pat,\n+                [[ident, [l_ident]], [pat, cv_pat]]];\n+}\n+\n+fn cv_stmt(ctx: &ctx, ut: &@ast_node) -> @stmt {\n+    ret @#br_alt[*ut, ctx,\n+                 [[stmt_decl, n_stmt_decl, [cv_decl, []]],\n+                  [stmt_expr, n_stmt_expr, [cv_expr, []]],\n+                  [stmt_crate_directive, n_stmt_crate_directive,\n+                   [cv_crate_directive]]]];\n+}\n+\n+fn cv_initializer(ctx: &ctx, ut: &@ast_node) -> initializer {\n+    ret #br_rec[*ut, ctx, initializer, n_initializer,\n+               [[op,   [l_init_op]],\n+                [expr, cv_expr]]];\n+}\n+\n+fn cv_local(ctx: &ctx, ut: &@ast_node) -> @local {\n+    ret @#br_rec[*ut, ctx, local, n_local,\n+                 [[ty,   opt_cv(cv_ty)],\n+                  [pat,  cv_pat],\n+                  [init, opt_cv(cv_initializer)],\n+                  [id,   []]]]\n+}\n+\n+fn cv_decl(ctx: &ctx, ut: &@ast_node) -> @decl {\n+    ret @#br_alt[*ut, ctx,\n+                 [[decl_local, n_decl_local, [cv_local]],\n+                  [decl_item, n_decl_item, [cv_item]]]];\n+}\n+\n+fn cv_arm(ctx: &ctx, ut: &@ast_node) -> arm {\n+    ret #br_rec[*ut, ctx, arm, n_arm,\n+                [[pats, seq_cv(cv_pat)],\n+                 [body, cv_blk]]];\n+}\n+\n+fn cv_field(ctx: &ctx, ut: &@ast_node) -> field {\n+    ret #br_rec[*ut, ctx, field, n_field,\n+                [[mut,   [l_mutability]],\n+                 [ident, [l_ident]],\n+                 [expr,  cv_expr]]];\n+}\n+\n+fn cv_expr(ctx: &ctx, ut: &@ast_node) -> @expr {\n+    ret @{id: ctx.next_id(),\n+          node: #br_alt_no_span\n+              [*ut, ctx,\n+               [[expr_vec, n_expr_vec,\n+                 [seq_cv(cv_expr), [l_mutability], [l_seq_kind]]],\n+                [expr_rec, n_expr_rec,\n+                 [seq_cv(cv_field), opt_cv(cv_expr)]],\n+                [expr_call, n_expr_call,\n+                 [cv_expr, seq_cv(cv_expr)]],\n+                [expr_self_method, n_expr_self_method, [[l_ident]]],\n+                [expr_bind, n_expr_bind,\n+                 [cv_expr, seq_cv(opt_cv(cv_expr))]],\n+                [expr_spawn, n_expr_spawn,\n+                 [[l_spawn_dom], [l_optional_string], cv_expr,\n+                  seq_cv(cv_expr)]],\n+                [expr_binary, n_expr_binary, [[l_binop], cv_expr, cv_expr]],\n+                [expr_unary, n_expr_unary, [[l_unop], cv_expr]],\n+                [expr_lit, n_expr_lit, [cv_lit]],\n+                [expr_cast, n_expr_cast, [cv_expr, cv_ty]],\n+                [expr_if, n_expr_if, [cv_expr, cv_blk, opt_cv(cv_expr)]],\n+                [expr_ternary, n_expr_ternary, [cv_expr, cv_expr, cv_expr]],\n+                [expr_while, n_expr_while, [cv_expr, cv_blk]],\n+                [expr_for, n_expr_for, [cv_local, cv_expr, cv_blk]],\n+                [expr_for_each, n_expr_for_each, [cv_local, cv_expr, cv_blk]],\n+                [expr_do_while, n_expr_do_while, [cv_blk, cv_expr]],\n+                [expr_alt, n_expr_alt, [cv_expr, seq_cv(cv_arm)]],\n+                [expr_fn, n_expr_fn, [cv__fn]],\n+                [expr_block, n_expr_block, [cv_expr]],\n+                [expr_move, n_expr_move, [cv_expr, cv_expr]],\n+                [expr_assign, n_expr_assign, [cv_expr, cv_expr]],\n+                [expr_swap, n_expr_swap, [cv_expr, cv_expr]],\n+                [expr_assign_op, n_expr_assign_op,\n+                 [[l_binop], cv_expr, cv_expr]],\n+                [expr_send, n_expr_send, [cv_expr, cv_expr]],\n+                [expr_recv, n_expr_recv, [cv_expr, cv_expr]],\n+                [expr_field, n_expr_field, [cv_expr, [l_ident]]],\n+                [expr_index, n_expr_index, [cv_expr, cv_expr]],\n+                [expr_path, n_expr_path, [[l_path]]],\n+                [expr_fail, n_expr_fail, [opt_cv(cv_expr)]],\n+                [expr_break, n_expr_break, []],\n+                [expr_cont, n_expr_cont, []],\n+                [expr_ret, n_expr_ret, [opt_cv(cv_expr)]],\n+                [expr_put, n_expr_put, [opt_cv(cv_expr)]],\n+                [expr_be, n_expr_be, [cv_expr]],\n+                [expr_log, n_expr_log, [cv_expr]],\n+                [expr_assert, n_expr_assert, [cv_expr]],\n+                [expr_check, n_expr_check, [cv_expr]],\n+                [expr_if_check, n_expr_if_check,\n+                 [cv_expr, cv_blk, opt_cv(cv_expr)]],\n+                [expr_port, n_expr_port, [opt_cv(cv_ty)]],\n+                [expr_chan, n_expr_chan, [cv_expr]],\n+                [expr_anon_obj, n_expr_anon_obj, [cv_anon_obj]]]\n+              ],\n+          span: alt *ut {\n+            branch(_,some(sp),_) { sp }\n+            none. { ctx.ff(\"pat needs a span\"); }\n+          }\n+         }\n+}\n+\n+\n+fn cv_lit(ctx: &ctx, ut: &@ast_node) -> @lit {\n+    ret @#br_alt[*ut, ctx,\n+                 [[lit_str, n_lit_str, [[l_str], [l_seq_kind]]],\n+                  [lit_char, n_lit_char, [[l_char]]],\n+                  [lit_int, n_lit_int, [[l_int]]],\n+                  [lit_uint, n_lit_uint, [[l_uint]]],\n+                  [lit_mach_int, n_lit_mach_int, [[l_ty_mach], [l_int]]],\n+                  [lit_float, n_lit_float, [[l_str]]],\n+                  [lit_mach_float, n_lit_mach_float, [[l_ty_mach], [l_str]]],\n+                  [lit_nil, n_lit_nil, []],\n+                  [lit_bool, n_lit_bool, [[l_bool]]]]];\n+}\n+\n+fn cv_mt(ctx: &ctx, ut: &@ast_node) -> mt {\n+    ret #br_rec_no_span[*ut, ctx, mt, n_mt,\n+                        [[ty, cv_ty], [mut, [l_mutability]]]];\n+}\n+\n+fn cv_ty_field(ctx: &ctx, ut: &@ast_node) -> ty_field {\n+    ret #br_rec[*ut, ctx, ty_field, n_ty_field,\n+                [[ident, [l_ident]], [mt, cv_mt]]];\n+}\n+\n+fn cv_ty_arg(ctx: &ctx, ut: &@ast_node) -> ty_arg {\n+    ret #br_rec[*ut, ctx, ty_arg, n_ty_arg,\n+                [[mode, [l_mode]], [ty, cv_ty]]];\n+}\n+\n+fn cv_ty_method(ctx: &ctx, ut: &@ast_node) -> ty_method {\n+    ret #br_rec[*ut, ctx, ty_method, n_ty_method,\n+                [[proto, [l_proto]],\n+                 [ident, [l_ident]],\n+                 [inputs, seq_cv(cv_ty_arg)],\n+                 [output, cv_ty],\n+                 [cf, [l_controlflow]],\n+                 [constrs, seq_cv(cv_constr)]]];\n+}\n+\n+fn cv_ty(ctx: &ctx, ut: &@ast_node) -> @ty {\n+    ret @#br_alt[*ut, ctx,\n+                 [[ty_nil, n_ty_nil, []],\n+                  [ty_bool, n_ty_bool, []],\n+                  [ty_int, n_ty_int, []],\n+                  [ty_uint, n_ty_uint, []],\n+                  [ty_float, n_ty_float, []],\n+                  [ty_machine, n_ty_machine, [[l_ty_mach]]],\n+                  [ty_char, n_ty_char, []],\n+                  [ty_str, n_ty_str, []],\n+                  [ty_istr, n_ty_istr, []],\n+                  [ty_box, n_ty_box, [cv_mt]],\n+                  [ty_vec, n_ty_vec, [cv_mt]],\n+                  [ty_ivec, n_ty_ivec, [cv_mt]],\n+                  [ty_ptr, n_ty_ptr, [cv_mt]],\n+                  [ty_task, n_ty_task, []],\n+                  [ty_port, n_ty_port, [cv_ty]],\n+                  [ty_chan, n_ty_chan, [cv_ty]],\n+                  [ty_rec, n_ty_rec, [seq_cv(cv_ty_field)]],\n+                  [ty_fn, n_ty_fn,\n+                   [[l_proto], seq_cv(cv_arg), cv_ty, [l_controlflow],\n+                    seq_cv(cv_constr)]],\n+                  [ty_obj, n_ty_obj, [seq_cv(cv_ty_method)]],\n+                  [ty_path, n_ty_path, [[l_path], [] /*node_id*/]],\n+                  [ty_type, n_ty_type, []],\n+                  [ty_constr, n_ty_constr, [cv_ty, seq_cv(cv_constr)]]]]\n+}\n+\n+/* these four are expanded from the type-parametric code in ast.rs */\n+\n+fn cv_carg_uint(ctx: &ctx, ut: &@ast_node) -> constr_arg_general_[uint] {\n+    ret #br_alt[*ut, ctx,\n+                [[carg_base, n_carg_base, []],\n+                 [carg_ident, n_carg_ident, [[l_uint]]],\n+                 [carg_lit, n_carg_lit, [cv_lit]]]];\n+}\n+fn cv_carg_path(ctx: &ctx, ut: &@ast_node) -> constr_arg_general_[path] {\n+    ret #br_alt[*ut, ctx,\n+                [[carg_base, n_carg_base, []],\n+                 [carg_ident, n_carg_ident, [[l_path]]],\n+                 [carg_lit, n_carg_lit, [cv_lit]]]];\n+}\n+\n+fn cv_constr(ctx: &ctx, ut: &@ast_node) -> @constr {\n+    ret @#br_rec[*ut, ctx, constr, n_constr,\n+                 [[path, [l_path]],\n+                  [args, cv_carg_uint],\n+                  [id, [] /*node_id*/]]];\n+}\n+fn cv_typed_constr(ctx: &ctx, ut: &@ast_node) -> @ty_constr {\n+    ret @#br_rec[*ut, ctx, ty_constr, n_ty_constr_theactualconstraint,\n+                 [[path, [l_path]],\n+                  [args, cv_carg_path],\n+                  [id, [] /*node_id*/]]];\n+}\n+\n+\n+fn cv_arg(ctx: &ctx, ut: &@ast_node) -> arg {\n+    ret #br_rec_no_span[*ut, ctx, arg, n_arg,\n+                        [[mode, [l_mode]],\n+                         [ty, cv_ty],\n+                         [ident, [l_ident]],\n+                         [id, [] /*node_id*/]]];\n+}\n+\n+fn cv_fn_decl(ctx: &ctx, ut: &@ast_node) -> fn_decl {\n+    ret #br_rec_no_span[*ut, ctx, fn_decl, n_fn_decl,\n+                        [[inputs, seq_cv(cv_arg)],\n+                         [output, cv_ty],\n+                         [il, [l_inlineness]],\n+                         [cf, [l_controlflow]],\n+                         [constraints, seq_cv(cv_constr)]]];\n+}\n+\n+fn cv__fn(ctx: &ctx, ut: &@ast_node) -> _fn {\n+    ret #br_rec_no_span[*ut, ctx, _fn, n__fn,\n+                        [[decl, cv_fn_decl],\n+                         [proto, [l_proto]],\n+                         [body, cv_blk]]];\n+}\n+\n+fn cv_method(ctx: &ctx, ut: &@ast_node) -> @method {\n+    ret @#br_rec[*ut, ctx, method, n_method,\n+                 [[ident, [l_ident]],\n+                  [meth, cv__fn],\n+                  [id, [] /*node_id*/]]];\n+}\n+\n+fn cv_obj_field(ctx: &ctx, ut: &@ast_node) -> obj_field {\n+    ret #br_rec[*ut, ctx, obj_field, n_obj_field,\n+                [[mut, [l_mutability]],\n+                 [ty, cv_ty],\n+                 [ident, [l_ident]],\n+                 [id, [] /*node_id*/]]];\n+}\n+\n+fn cv_anon_obj_field(ctx: &ctx, ut: &@ast_node) -> anon_obj_field {\n+    ret #br_rec[*ut, ctx, anon_obj_field, n_anon_obj_field,\n+                [[mut, [l_mutability]],\n+                 [ty, cv_ty],\n+                 [expr, cv_expr],\n+                 [ident, [l_ident]],\n+                 [id, [] /*node_id*/]]];\n+}\n+\n+fn cv__obj(ctx: &ctx, ut: &@ast_node) ->  _obj {\n+    ret #br_rec_no_span[*ut, ctx, _obj, n__obj,\n+                        [[fields, seq_cv(cv_obj_field)],\n+                         [methods, seq_cv(cv_method)]]];\n+}\n+\n+fn cv_anon_obj(ctx: &ctx, ut: &@ast_node) ->  anon_obj {\n+    ret #br_rec_no_span[*ut, ctx, anon_obj, n_anon_obj,\n+                        [[fields, opt_cv(seq_cv(cv_anon_obj_field))],\n+                         [methods, seq_cv(cv_method)],\n+                         [inner_obj, opt_cv(cv_expr)]]];\n+}\n+\n+fn cv__mod(ctx: &ctx, ut: &@ast_node) -> _mod {\n+    ret #br_rec_no_span[*ut, ctx, _mod, n__mod,\n+                        [[view_items, seq_cv(cv_view_item)],\n+                         [items, seq_cv(cv_item)]]];\n+}\n+\n+fn cv_native_mod(ctx: &ctx, ut: &@ast_node) -> native_mod {\n+    ret #br_rec_no_span[*ut, ctx, native_mod, n_native_mod,\n+                        [[native_name, [l_str]],\n+                         [abi, [l_native_abi]],\n+                         [view_items, seq_cv(cv_view_item)],\n+                         [items, seq_cv(cv_item)]]];\n+}\n+\n+fn cv_variant_arg(ctx: &ctx, ut: &@ast_node) -> variant_arg {\n+    ret #br_rec_no_span[*ut, ctx, variant_arg, n_variant_arg,\n+                        [[ty, cv_ty],\n+                         [id, [] /*node_id*/]]];\n+}\n+\n+fn cv_variant(ctx: &ctx, ut: &@ast_node) -> variant {\n+    ret #br_rec[*ut, ctx, variant, n_variant,\n+                [[name, [l_str]],\n+                 [args, seq_cv(cv_variant_arg)],\n+                 [id, [] /*node_id*/]]];\n+}\n+\n+fn cv_view_item(ctx: &ctx, ut: &@ast_node) -> @view_item {\n+    ret @#br_alt[*ut, ctx,\n+                 [[view_item_use, n_view_item_use,\n+                   [[l_ident], seq_cv(cv_meta_item), [] /*node_id*/]],\n+                  [view_item_import, n_view_item_import,\n+                   [[l_ident], [l_seq_ident], []]],\n+                  [view_item_import_glob, n_view_item_import_glob,\n+                   [[l_seq_ident], []]],\n+                  [view_item_export, n_view_item_export,\n+                   [[l_ident], []]]]];\n+}\n+\n+fn cv_attribute(ctx: &ctx, ut: &@ast_node) -> attribute {\n+    ret #br_rec[*ut, ctx, attribute, n_attribute,\n+                [[style, [l_attr_style]],\n+                 [value, cv_meta_item]]];\n+}\n+\n+/* item and native_item have large enough wrappers that their underscored\n+   components get separate handling */\n+\n+fn cv_item(ctx: &ctx, ut: &@ast_node) -> @item {\n+    ret @#br_rec[*ut, ctx, item, n_item,\n+                 [[ident, [l_ident]],\n+                  [attrs, seq_cv(cv_attribute)],\n+                  [id, [] /*node_id*/],\n+                  [node, cv_item_],\n+                  [span, [[]] /*span*/]]];\n+}\n+\n+fn cv_item_(ctx: &ctx, ut: &@ast_node) -> item_ {\n+    ret #br_alt_no_span[*ut, ctx,\n+                        [[item_const, n_item_const, [cv_ty, cv_expr]],\n+                         [item_fn, n_item_fn, [cv__fn, [l_seq_ty_param]]],\n+                         [item_mod, n_item_mod, [cv__mod]],\n+                         [item_native_mod, n_item_native_mod,\n+                          [cv_native_mod]],\n+                         [item_ty, n_item_ty, [cv_ty, [l_seq_ty_param]]],\n+                         [item_tag, n_item_tag,\n+                          [seq_cv(cv_variant), [l_seq_ty_param]]],\n+                         [item_obj, n_item_obj,\n+                          [cv__obj, [l_seq_ty_param], [] /*node_id*/]],\n+                         [item_res, n_item_res,\n+                          [cv__fn, [] /*node_id*/, [l_seq_ty_param],\n+                           [] /*node_id*/]]]];\n+}\n+\n+fn cv_native_item(ctx: &ctx, ut: &@ast_node) -> @native_item {\n+    ret @#br_rec[*ut, ctx, native_item, n_native_item,\n+                 [[ident, [l_ident]],\n+                  [attrs, seq_cv(cv_attribute)],\n+                  [node, cv_native_item_],\n+                  [id, [] /*node_id*/],\n+                  [span, [[]] /*span*/]]];\n+}\n+\n+fn cv_native_item_(ctx: &ctx, ut: &@ast_node) -> native_item_ {\n+    ret #br_alt[*ut, ctx,\n+                [[native_item_ty, n_native_item_ty, []],\n+                 [native_item_fn, n_native_item_fn,\n+                  [[l_optional_string], cv_fn_decl, [l_seq_ty_param]]]]];\n+}"}]}