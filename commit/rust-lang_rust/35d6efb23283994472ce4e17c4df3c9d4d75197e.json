{"sha": "35d6efb23283994472ce4e17c4df3c9d4d75197e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZDZlZmIyMzI4Mzk5NDQ3MmNlNGUxN2M0ZGYzYzlkNGQ3NTE5N2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-02-01T21:08:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-02-01T21:08:34Z"}, "message": "Use the per-tree state to detect and permit DAGs (but not cyclic graphs)", "tree": {"sha": "a1f5ecb64066051a7f098299119d47ebc6a292fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1f5ecb64066051a7f098299119d47ebc6a292fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35d6efb23283994472ce4e17c4df3c9d4d75197e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35d6efb23283994472ce4e17c4df3c9d4d75197e", "html_url": "https://github.com/rust-lang/rust/commit/35d6efb23283994472ce4e17c4df3c9d4d75197e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35d6efb23283994472ce4e17c4df3c9d4d75197e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37815fde39fc828318621f1c047ffd353621f026", "url": "https://api.github.com/repos/rust-lang/rust/commits/37815fde39fc828318621f1c047ffd353621f026", "html_url": "https://github.com/rust-lang/rust/commit/37815fde39fc828318621f1c047ffd353621f026"}], "stats": {"total": 121, "additions": 80, "deletions": 41}, "files": [{"sha": "bb411e76e929bbe935377b9bf08d9c33b9279579", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 80, "deletions": 41, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/35d6efb23283994472ce4e17c4df3c9d4d75197e/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35d6efb23283994472ce4e17c4df3c9d4d75197e/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=35d6efb23283994472ce4e17c4df3c9d4d75197e", "patch": "@@ -36,6 +36,7 @@ pub struct GlobalFulfilledPredicates<'tcx> {\n     dep_graph: DepGraph,\n }\n \n+#[derive(Debug)]\n pub struct LocalFulfilledPredicates<'tcx> {\n     set: FnvHashSet<ty::Predicate<'tcx>>\n }\n@@ -66,7 +67,8 @@ pub struct FulfillmentContext<'tcx> {\n \n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n-    predicates: ObligationForest<PendingPredicateObligation<'tcx>, ()>,\n+    predicates: ObligationForest<PendingPredicateObligation<'tcx>,\n+                                 LocalFulfilledPredicates<'tcx>>,\n \n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n@@ -192,7 +194,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             obligation: obligation,\n             stalled_on: vec![]\n         };\n-        self.predicates.push_tree(obligation, ());\n+        self.predicates.push_tree(obligation, LocalFulfilledPredicates::new());\n     }\n \n     pub fn region_obligations(&self,\n@@ -278,7 +280,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             let outcome = {\n                 let region_obligations = &mut self.region_obligations;\n                 self.predicates.process_obligations(\n-                    |obligation, _tree, backtrace| process_predicate(selcx,\n+                    |obligation, tree, backtrace| process_predicate(selcx,\n+                                                                     tree,\n                                                                      obligation,\n                                                                      backtrace,\n                                                                      region_obligations))\n@@ -315,61 +318,97 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n /// Like `process_predicate1`, but wrap result into a pending predicate.\n fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+                              tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n                               pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-                              backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n+                              mut backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n                               -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n                                         FulfillmentErrorCode<'tcx>>\n {\n-    match process_predicate1(selcx, pending_obligation, backtrace, region_obligations) {\n+    match process_predicate1(selcx, pending_obligation, backtrace.clone(), region_obligations) {\n         Ok(Some(v)) => {\n-            // FIXME(#30977) the right thing to do here, I think, is to permit\n-            // DAGs. That is, we should detect whenever this predicate\n-            // has appeared somewhere in the current tree./ If it's a\n-            // parent, that's a cycle, and we should either error out\n-            // or consider it ok. But if it's NOT a parent, we can\n-            // ignore it, since it will be proven (or not) separately.\n-            // However, this is a touch tricky, so I'm doing something\n-            // a bit hackier for now so that the `huge-struct.rs` passes.\n+            // FIXME(#30977) The code below is designed to detect (and\n+            // permit) DAGs, while still ensuring that the reasoning\n+            // is acyclic. However, it does a few things\n+            // suboptimally. For example, it refreshes type variables\n+            // a lot, probably more than needed, but also less than\n+            // you might want.\n+            //\n+            //   - more than needed: I want to be very sure we don't\n+            //     accidentally treat a cycle as a DAG, so I am\n+            //     refreshing type variables as we walk the ancestors;\n+            //     but we are going to repeat this a lot, which is\n+            //     sort of silly, and it would be nicer to refresh\n+            //     them *in place* so that later predicate processing\n+            //     can benefit from the same work;\n+            //   - less than you might want: we only add items in the cache here,\n+            //     but maybe we learn more about type variables and could add them into\n+            //     the cache later on.\n \n             let tcx = selcx.tcx();\n \n-            let retain_vec: Vec<_> = {\n-                let mut dedup = FnvHashSet();\n-                v.iter()\n-                 .map(|o| {\n+            // Compute a little FnvHashSet for the ancestors. We only\n+            // do this the first time that we care.\n+            let mut cache = None;\n+            let mut is_ancestor = |predicate: &ty::Predicate<'tcx>| {\n+                if cache.is_none() {\n+                    let mut c = FnvHashSet();\n+                    for ancestor in backtrace.by_ref() {\n+                        // Ugh. This just feels ridiculously\n+                        // inefficient.  But we need to compare\n+                        // predicates without being concerned about\n+                        // the vagaries of type inference, so for now\n+                        // just ensure that they are always\n+                        // up-to-date. (I suppose we could just use a\n+                        // snapshot and check if they are unifiable?)\n+                        let resolved_predicate =\n+                            selcx.infcx().resolve_type_vars_if_possible(\n+                                &ancestor.obligation.predicate);\n+                        c.insert(resolved_predicate);\n+                    }\n+                    cache = Some(c);\n+                }\n+\n+                cache.as_ref().unwrap().contains(predicate)\n+            };\n+\n+            let pending_predicate_obligations: Vec<_> =\n+                v.into_iter()\n+                 .filter_map(|obligation| {\n+                     // Probably silly, but remove any inference\n+                     // variables. This is actually crucial to the\n+                     // ancestor check below, but it's not clear that\n+                     // it makes sense to ALWAYS do it.\n+                     let obligation = selcx.infcx().resolve_type_vars_if_possible(&obligation);\n+\n                      // Screen out obligations that we know globally\n                      // are true. This should really be the DAG check\n                      // mentioned above.\n-                     if tcx.fulfilled_predicates.borrow().check_duplicate(&o.predicate) {\n-                         return false;\n+                     if tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n+                         return None;\n                      }\n \n-                     // If we see two siblings that are exactly the\n-                     // same, no need to add them twice.\n-                     if !dedup.insert(&o.predicate) {\n-                         return false;\n+                     // Check whether this obligation appears somewhere else in the tree.\n+                     if tree_cache.is_duplicate_or_add(&obligation.predicate) {\n+                         // If the obligation appears as a parent,\n+                         // allow it, because that is a cycle.\n+                         // Otherwise though we can just ignore\n+                         // it. Note that we have to be careful around\n+                         // inference variables here -- for the\n+                         // purposes of the ancestor check, we retain\n+                         // the invariant that all type variables are\n+                         // fully refreshed.\n+                         if !(&mut is_ancestor)(&obligation.predicate) {\n+                             return None;\n+                         }\n                      }\n \n-                     true\n-                 })\n-                 .collect()\n-            };\n-\n-            let pending_predicate_obligations =\n-                v.into_iter()\n-                 .zip(retain_vec)\n-                 .flat_map(|(o, retain)| {\n-                     if retain {\n-                         Some(PendingPredicateObligation {\n-                             obligation: o,\n-                             stalled_on: vec![]\n-                         })\n-                     } else {\n-                         None\n-                     }\n+                     Some(PendingPredicateObligation {\n+                         obligation: obligation,\n+                         stalled_on: vec![]\n+                     })\n                  })\n-                .collect();\n+                 .collect();\n \n             Ok(Some(pending_predicate_obligations))\n         }"}]}