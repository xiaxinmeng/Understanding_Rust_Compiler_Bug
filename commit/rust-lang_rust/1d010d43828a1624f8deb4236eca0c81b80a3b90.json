{"sha": "1d010d43828a1624f8deb4236eca0c81b80a3b90", "node_id": "C_kwDOAAsO6NoAKDFkMDEwZDQzODI4YTE2MjRmOGRlYjQyMzZlY2EwYzgxYjgwYTNiOTA", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-31T12:06:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-31T12:06:42Z"}, "message": "Rollup merge of #99844 - bjorn3:archive_builder_interface_refactor, r=nagisa\n\nIntroduce an ArchiveBuilderBuilder\n\nThis avoids monomorphizing all linker code for each codegen backend and will allow passing in extra information to the archive builder from the codegen backend. I'm going to use this in https://github.com/rust-lang/rust/pull/97485 to allow passing in the right function to extract symbols from object files to a generic archive builder to be used by cg_llvm, cg_clif and cg_gcc.", "tree": {"sha": "ffe89275bb3ce3ea27b50f9c0ee56ea72b8f58c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffe89275bb3ce3ea27b50f9c0ee56ea72b8f58c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d010d43828a1624f8deb4236eca0c81b80a3b90", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi5nBSCRBK7hj4Ov3rIwAA2O8IAA4BQ4d7p+mQnb9Mue1spRcM\nWF2d5h3b4acRfNDSMRELpnVV4LxMIL/UhO+8bq/Ws/IxmDlYHMKasp+IhQeJkPBj\n1d9AqVcj+q+S4fWQKzbh5NWFctO05g/szkCwjqZv2Ydo93Yvl31D/0zU+odxJxV9\n6OfWPVeBBgKtJk16+dVuZCSya4ktXaS8pVOQaTOw1nDmChUu640xZh2edYfqBHg4\n6mBQm+eHhB0h6dwMsUBhsYKpMJm04qzMHPZFBMqp0pwJhJEARnZ1TgrzikVwaqS/\nlGMLLzPaLLqooD9bwCs006gEfrp816w/8q4mgc+/VilUW1smaRuXuwakfUslJKo=\n=5PFR\n-----END PGP SIGNATURE-----\n", "payload": "tree ffe89275bb3ce3ea27b50f9c0ee56ea72b8f58c2\nparent 2c14bc3b550b30353a1031334739bf903daa288e\nparent 7c6c7e8785fa553baf43ea82382a97ec01466b9b\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1659269202 +0530\ncommitter GitHub <noreply@github.com> 1659269202 +0530\n\nRollup merge of #99844 - bjorn3:archive_builder_interface_refactor, r=nagisa\n\nIntroduce an ArchiveBuilderBuilder\n\nThis avoids monomorphizing all linker code for each codegen backend and will allow passing in extra information to the archive builder from the codegen backend. I'm going to use this in https://github.com/rust-lang/rust/pull/97485 to allow passing in the right function to extract symbols from object files to a generic archive builder to be used by cg_llvm, cg_clif and cg_gcc.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d010d43828a1624f8deb4236eca0c81b80a3b90", "html_url": "https://github.com/rust-lang/rust/commit/1d010d43828a1624f8deb4236eca0c81b80a3b90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d010d43828a1624f8deb4236eca0c81b80a3b90/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c14bc3b550b30353a1031334739bf903daa288e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c14bc3b550b30353a1031334739bf903daa288e", "html_url": "https://github.com/rust-lang/rust/commit/2c14bc3b550b30353a1031334739bf903daa288e"}, {"sha": "7c6c7e8785fa553baf43ea82382a97ec01466b9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c6c7e8785fa553baf43ea82382a97ec01466b9b", "html_url": "https://github.com/rust-lang/rust/commit/7c6c7e8785fa553baf43ea82382a97ec01466b9b"}], "stats": {"total": 415, "additions": 218, "deletions": 197}, "files": [{"sha": "b4c790961707900f839ad4977a89d5e725cf9f69", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=1d010d43828a1624f8deb4236eca0c81b80a3b90", "patch": "@@ -5,7 +5,7 @@ use std::fs::File;\n use std::io::{self, Read, Seek};\n use std::path::{Path, PathBuf};\n \n-use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n+use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use rustc_session::Session;\n \n use object::read::archive::ArchiveFile;\n@@ -17,9 +17,34 @@ enum ArchiveEntry {\n     File(PathBuf),\n }\n \n+pub(crate) struct ArArchiveBuilderBuilder;\n+\n+impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n+    fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n+        Box::new(ArArchiveBuilder {\n+            sess,\n+            use_gnu_style_archive: sess.target.archive_format == \"gnu\",\n+            // FIXME fix builtin ranlib on macOS\n+            no_builtin_ranlib: sess.target.is_like_osx,\n+\n+            src_archives: vec![],\n+            entries: vec![],\n+        })\n+    }\n+\n+    fn create_dll_import_lib(\n+        &self,\n+        _sess: &Session,\n+        _lib_name: &str,\n+        _dll_imports: &[rustc_session::cstore::DllImport],\n+        _tmpdir: &Path,\n+    ) -> PathBuf {\n+        bug!(\"creating dll imports is not supported\");\n+    }\n+}\n+\n pub(crate) struct ArArchiveBuilder<'a> {\n     sess: &'a Session,\n-    dst: PathBuf,\n     use_gnu_style_archive: bool,\n     no_builtin_ranlib: bool,\n \n@@ -30,30 +55,18 @@ pub(crate) struct ArArchiveBuilder<'a> {\n }\n \n impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn new(sess: &'a Session, output: &Path) -> Self {\n-        ArArchiveBuilder {\n-            sess,\n-            dst: output.to_path_buf(),\n-            use_gnu_style_archive: sess.target.archive_format == \"gnu\",\n-            // FIXME fix builtin ranlib on macOS\n-            no_builtin_ranlib: sess.target.is_like_osx,\n-\n-            src_archives: vec![],\n-            entries: vec![],\n-        }\n-    }\n-\n     fn add_file(&mut self, file: &Path) {\n         self.entries.push((\n             file.file_name().unwrap().to_str().unwrap().to_string().into_bytes(),\n             ArchiveEntry::File(file.to_owned()),\n         ));\n     }\n \n-    fn add_archive<F>(&mut self, archive_path: &Path, mut skip: F) -> std::io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static,\n-    {\n+    fn add_archive(\n+        &mut self,\n+        archive_path: &Path,\n+        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n+    ) -> std::io::Result<()> {\n         let read_cache = ReadCache::new(std::fs::File::open(&archive_path)?);\n         let archive = ArchiveFile::parse(&read_cache).unwrap();\n         let archive_index = self.src_archives.len();\n@@ -74,7 +87,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         Ok(())\n     }\n \n-    fn build(mut self) -> bool {\n+    fn build(mut self: Box<Self>, output: &Path) -> bool {\n         enum BuilderKind {\n             Bsd(ar::Builder<File>),\n             Gnu(ar::GnuBuilder<File>),\n@@ -163,7 +176,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         let mut builder = if self.use_gnu_style_archive {\n             BuilderKind::Gnu(\n                 ar::GnuBuilder::new(\n-                    File::create(&self.dst).unwrap_or_else(|err| {\n+                    File::create(output).unwrap_or_else(|err| {\n                         sess.fatal(&format!(\n                             \"error opening destination during archive building: {}\",\n                             err\n@@ -178,7 +191,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         } else {\n             BuilderKind::Bsd(\n                 ar::Builder::new(\n-                    File::create(&self.dst).unwrap_or_else(|err| {\n+                    File::create(output).unwrap_or_else(|err| {\n                         sess.fatal(&format!(\n                             \"error opening destination during archive building: {}\",\n                             err\n@@ -209,7 +222,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n             // Run ranlib to be able to link the archive\n             let status = std::process::Command::new(ranlib)\n-                .arg(self.dst)\n+                .arg(output)\n                 .status()\n                 .expect(\"Couldn't run ranlib\");\n \n@@ -220,17 +233,4 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n         any_members\n     }\n-\n-    fn sess(&self) -> &Session {\n-        self.sess\n-    }\n-\n-    fn create_dll_import_lib(\n-        _sess: &Session,\n-        _lib_name: &str,\n-        _dll_imports: &[rustc_session::cstore::DllImport],\n-        _tmpdir: &Path,\n-    ) -> PathBuf {\n-        bug!(\"creating dll imports is not supported\");\n-    }\n }"}, {"sha": "bb0793b1deb2e8e75262648ebc89ab6b1d1e76e5", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=1d010d43828a1624f8deb4236eca0c81b80a3b90", "patch": "@@ -226,7 +226,7 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     ) -> Result<(), ErrorGuaranteed> {\n         use rustc_codegen_ssa::back::link::link_binary;\n \n-        link_binary::<crate::archive::ArArchiveBuilder<'_>>(sess, &codegen_results, outputs)\n+        link_binary(sess, &crate::archive::ArArchiveBuilderBuilder, &codegen_results, outputs)\n     }\n }\n "}, {"sha": "f863abdcc97ec12739924bc026ac9d8e1849b928", "filename": "compiler/rustc_codegen_gcc/src/archive.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs?ref=1d010d43828a1624f8deb4236eca0c81b80a3b90", "patch": "@@ -1,14 +1,13 @@\n use std::fs::File;\n use std::path::{Path, PathBuf};\n \n-use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n+use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use rustc_session::Session;\n \n use rustc_session::cstore::DllImport;\n \n struct ArchiveConfig<'a> {\n     sess: &'a Session,\n-    dst: PathBuf,\n     use_native_ar: bool,\n     use_gnu_style_archive: bool,\n }\n@@ -22,42 +21,56 @@ enum ArchiveEntry {\n     File(PathBuf),\n }\n \n-pub struct ArArchiveBuilder<'a> {\n-    config: ArchiveConfig<'a>,\n-    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n-    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n-    // the end of an archive for linkers to not get confused.\n-    entries: Vec<(String, ArchiveEntry)>,\n-}\n+pub struct ArArchiveBuilderBuilder;\n \n-impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn new(sess: &'a Session, output: &Path) -> Self {\n+impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n+    fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n         let config = ArchiveConfig {\n             sess,\n-            dst: output.to_path_buf(),\n             use_native_ar: false,\n             // FIXME test for linux and System V derivatives instead\n             use_gnu_style_archive: sess.target.options.archive_format == \"gnu\",\n         };\n \n-        ArArchiveBuilder {\n+        Box::new(ArArchiveBuilder {\n             config,\n             src_archives: vec![],\n             entries: vec![],\n-        }\n+        })\n+    }\n+\n+    fn create_dll_import_lib(\n+        &self,\n+        _sess: &Session,\n+        _lib_name: &str,\n+        _dll_imports: &[DllImport],\n+        _tmpdir: &Path,\n+    ) -> PathBuf {\n+        unimplemented!();\n     }\n+}\n \n+pub struct ArArchiveBuilder<'a> {\n+    config: ArchiveConfig<'a>,\n+    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n+    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n+    // the end of an archive for linkers to not get confused.\n+    entries: Vec<(String, ArchiveEntry)>,\n+}\n+\n+impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     fn add_file(&mut self, file: &Path) {\n         self.entries.push((\n             file.file_name().unwrap().to_str().unwrap().to_string(),\n             ArchiveEntry::File(file.to_owned()),\n         ));\n     }\n \n-    fn add_archive<F>(&mut self, archive_path: &Path, mut skip: F) -> std::io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static,\n-    {\n+    fn add_archive(\n+        &mut self,\n+        archive_path: &Path,\n+        mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n+    ) -> std::io::Result<()> {\n         let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n         let archive_index = self.src_archives.len();\n \n@@ -77,7 +90,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         Ok(())\n     }\n \n-    fn build(mut self) -> bool {\n+    fn build(mut self: Box<Self>, output: &Path) -> bool {\n         use std::process::Command;\n \n         fn add_file_using_ar(archive: &Path, file: &Path) {\n@@ -97,17 +110,17 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         }\n \n         let mut builder = if self.config.use_native_ar {\n-            BuilderKind::NativeAr(&self.config.dst)\n+            BuilderKind::NativeAr(output)\n         } else if self.config.use_gnu_style_archive {\n             BuilderKind::Gnu(ar::GnuBuilder::new(\n-                File::create(&self.config.dst).unwrap(),\n+                File::create(output).unwrap(),\n                 self.entries\n                     .iter()\n                     .map(|(name, _)| name.as_bytes().to_vec())\n                     .collect(),\n             ))\n         } else {\n-            BuilderKind::Bsd(ar::Builder::new(File::create(&self.config.dst).unwrap()))\n+            BuilderKind::Bsd(ar::Builder::new(File::create(output).unwrap()))\n         };\n \n         let any_members = !self.entries.is_empty();\n@@ -164,28 +177,13 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         std::mem::drop(builder);\n \n         // Run ranlib to be able to link the archive\n-        let status = std::process::Command::new(\"ranlib\")\n-            .arg(self.config.dst)\n-            .status()\n-            .expect(\"Couldn't run ranlib\");\n+        let status =\n+            std::process::Command::new(\"ranlib\").arg(output).status().expect(\"Couldn't run ranlib\");\n \n         if !status.success() {\n             self.config.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n         }\n \n         any_members\n     }\n-\n-    fn sess(&self) -> &Session {\n-        self.config.sess\n-    }\n-\n-    fn create_dll_import_lib(\n-        _sess: &Session,\n-        _lib_name: &str,\n-        _dll_imports: &[DllImport],\n-        _tmpdir: &Path,\n-    ) -> PathBuf {\n-        unimplemented!();\n-    }\n }"}, {"sha": "8a206c0368fcb0ec2c7e5ad9bdecac3b99e87c16", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=1d010d43828a1624f8deb4236eca0c81b80a3b90", "patch": "@@ -133,8 +133,9 @@ impl CodegenBackend for GccCodegenBackend {\n     fn link(&self, sess: &Session, codegen_results: CodegenResults, outputs: &OutputFilenames) -> Result<(), ErrorGuaranteed> {\n         use rustc_codegen_ssa::back::link::link_binary;\n \n-        link_binary::<crate::archive::ArArchiveBuilder<'_>>(\n+        link_binary(\n             sess,\n+            &crate::archive::ArArchiveBuilderBuilder,\n             &codegen_results,\n             outputs,\n         )"}, {"sha": "27039cda253825f5fca016bd63e5c9c398d63988", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=1d010d43828a1624f8deb4236eca0c81b80a3b90", "patch": "@@ -10,15 +10,14 @@ use std::str;\n \n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind, LLVMMachineType, LLVMRustCOFFShortExport};\n-use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n+use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use rustc_session::cstore::{DllCallingConvention, DllImport};\n use rustc_session::Session;\n \n /// Helper for adding many files to an archive.\n #[must_use = \"must call build() to finish building the archive\"]\n pub struct LlvmArchiveBuilder<'a> {\n     sess: &'a Session,\n-    dst: PathBuf,\n     additions: Vec<Addition>,\n }\n \n@@ -54,16 +53,11 @@ fn llvm_machine_type(cpu: &str) -> LLVMMachineType {\n }\n \n impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n-    /// Creates a new static archive, ready for modifying the archive specified\n-    /// by `config`.\n-    fn new(sess: &'a Session, output: &Path) -> LlvmArchiveBuilder<'a> {\n-        LlvmArchiveBuilder { sess, dst: output.to_path_buf(), additions: Vec::new() }\n-    }\n-\n-    fn add_archive<F>(&mut self, archive: &Path, skip: F) -> io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static,\n-    {\n+    fn add_archive(\n+        &mut self,\n+        archive: &Path,\n+        skip: Box<dyn FnMut(&str) -> bool + 'static>,\n+    ) -> io::Result<()> {\n         let archive_ro = match ArchiveRO::open(archive) {\n             Ok(ar) => ar,\n             Err(e) => return Err(io::Error::new(io::ErrorKind::Other, e)),\n@@ -88,18 +82,23 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n \n     /// Combine the provided files, rlibs, and native libraries into a single\n     /// `Archive`.\n-    fn build(mut self) -> bool {\n-        match self.build_with_llvm() {\n+    fn build(mut self: Box<Self>, output: &Path) -> bool {\n+        match self.build_with_llvm(output) {\n             Ok(any_members) => any_members,\n             Err(e) => self.sess.fatal(&format!(\"failed to build archive: {}\", e)),\n         }\n     }\n+}\n+\n+pub struct LlvmArchiveBuilderBuilder;\n \n-    fn sess(&self) -> &Session {\n-        self.sess\n+impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n+    fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n+        Box::new(LlvmArchiveBuilder { sess, additions: Vec::new() })\n     }\n \n     fn create_dll_import_lib(\n+        &self,\n         sess: &Session,\n         lib_name: &str,\n         dll_imports: &[DllImport],\n@@ -241,7 +240,7 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n }\n \n impl<'a> LlvmArchiveBuilder<'a> {\n-    fn build_with_llvm(&mut self) -> io::Result<bool> {\n+    fn build_with_llvm(&mut self, output: &Path) -> io::Result<bool> {\n         let kind = &*self.sess.target.archive_format;\n         let kind = kind.parse::<ArchiveKind>().map_err(|_| kind).unwrap_or_else(|kind| {\n             self.sess.fatal(&format!(\"Don't know how to build archive of type: {}\", kind))\n@@ -251,7 +250,7 @@ impl<'a> LlvmArchiveBuilder<'a> {\n         let mut strings = Vec::new();\n         let mut members = Vec::new();\n \n-        let dst = CString::new(self.dst.to_str().unwrap())?;\n+        let dst = CString::new(output.to_str().unwrap())?;\n \n         unsafe {\n             for addition in &mut additions {"}, {"sha": "eeb1ed61f288f9245a9b497794c25d294da72d9e", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=1d010d43828a1624f8deb4236eca0c81b80a3b90", "patch": "@@ -370,12 +370,12 @@ impl CodegenBackend for LlvmCodegenBackend {\n         codegen_results: CodegenResults,\n         outputs: &OutputFilenames,\n     ) -> Result<(), ErrorGuaranteed> {\n-        use crate::back::archive::LlvmArchiveBuilder;\n+        use crate::back::archive::LlvmArchiveBuilderBuilder;\n         use rustc_codegen_ssa::back::link::link_binary;\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        link_binary::<LlvmArchiveBuilder<'_>>(sess, &codegen_results, outputs)\n+        link_binary(sess, &LlvmArchiveBuilderBuilder, &codegen_results, outputs)\n     }\n }\n "}, {"sha": "0d2aa483d3d4a03c45d6a3d3b53b69b4ff691a5f", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=1d010d43828a1624f8deb4236eca0c81b80a3b90", "patch": "@@ -1,4 +1,3 @@\n-use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_session::cstore::DllImport;\n use rustc_session::Session;\n \n@@ -40,48 +39,31 @@ pub(super) fn find_library(\n     ));\n }\n \n-pub trait ArchiveBuilder<'a> {\n-    fn new(sess: &'a Session, output: &Path) -> Self;\n-\n-    fn add_file(&mut self, path: &Path);\n-\n-    fn add_archive<F>(&mut self, archive: &Path, skip: F) -> io::Result<()>\n-    where\n-        F: FnMut(&str) -> bool + 'static;\n-\n-    fn build(self) -> bool;\n-\n-    fn sess(&self) -> &Session;\n+pub trait ArchiveBuilderBuilder {\n+    fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a>;\n \n     /// Creates a DLL Import Library <https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-creation#creating-an-import-library>.\n     /// and returns the path on disk to that import library.\n     /// This functions doesn't take `self` so that it can be called from\n     /// `linker_with_args`, which is specialized on `ArchiveBuilder` but\n     /// doesn't take or create an instance of that type.\n     fn create_dll_import_lib(\n+        &self,\n         sess: &Session,\n         lib_name: &str,\n         dll_imports: &[DllImport],\n         tmpdir: &Path,\n     ) -> PathBuf;\n+}\n \n-    /// Creates a DLL Import Library <https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-creation#creating-an-import-library>\n-    /// and adds it to the current compilation's set of archives.\n-    fn inject_dll_import_lib(\n+pub trait ArchiveBuilder<'a> {\n+    fn add_file(&mut self, path: &Path);\n+\n+    fn add_archive(\n         &mut self,\n-        lib_name: &str,\n-        dll_imports: &[DllImport],\n-        tmpdir: &MaybeTempDir,\n-    ) {\n-        let output_path =\n-            Self::create_dll_import_lib(self.sess(), lib_name, dll_imports, tmpdir.as_ref());\n+        archive: &Path,\n+        skip: Box<dyn FnMut(&str) -> bool + 'static>,\n+    ) -> io::Result<()>;\n \n-        self.add_archive(&output_path, |_| false).unwrap_or_else(|e| {\n-            self.sess().fatal(&format!(\n-                \"failed to add native library {}: {}\",\n-                output_path.display(),\n-                e\n-            ));\n-        });\n-    }\n+    fn build(self: Box<Self>, output: &Path) -> bool;\n }"}, {"sha": "13a7b6be947ec9e4c443fbcdf0542a1a76810e59", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 111, "deletions": 70, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d010d43828a1624f8deb4236eca0c81b80a3b90/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=1d010d43828a1624f8deb4236eca0c81b80a3b90", "patch": "@@ -24,7 +24,7 @@ use rustc_target::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor, SplitDebuginfo};\n use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, SanitizerSet, Target};\n \n-use super::archive::{find_library, ArchiveBuilder};\n+use super::archive::{find_library, ArchiveBuilder, ArchiveBuilderBuilder};\n use super::command::Command;\n use super::linker::{self, Linker};\n use super::metadata::{create_rmeta_file, MetadataPosition};\n@@ -56,8 +56,9 @@ pub fn ensure_removed(diag_handler: &Handler, path: &Path) {\n \n /// Performs the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n-pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n+pub fn link_binary<'a>(\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n     outputs: &OutputFilenames,\n ) -> Result<(), ErrorGuaranteed> {\n@@ -101,21 +102,29 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n             match crate_type {\n                 CrateType::Rlib => {\n                     let _timer = sess.timer(\"link_rlib\");\n-                    link_rlib::<B>(\n+                    info!(\"preparing rlib to {:?}\", out_filename);\n+                    link_rlib(\n                         sess,\n+                        archive_builder_builder,\n                         codegen_results,\n                         RlibFlavor::Normal,\n-                        &out_filename,\n                         &path,\n                     )?\n-                    .build();\n+                    .build(&out_filename);\n                 }\n                 CrateType::Staticlib => {\n-                    link_staticlib::<B>(sess, codegen_results, &out_filename, &path)?;\n+                    link_staticlib(\n+                        sess,\n+                        archive_builder_builder,\n+                        codegen_results,\n+                        &out_filename,\n+                        &path,\n+                    )?;\n                 }\n                 _ => {\n-                    link_natively::<B>(\n+                    link_natively(\n                         sess,\n+                        archive_builder_builder,\n                         crate_type,\n                         &out_filename,\n                         codegen_results,\n@@ -245,18 +254,16 @@ pub fn each_linked_rlib(\n /// the object file of the crate, but it also contains all of the object files from native\n /// libraries. This is done by unzipping native libraries and inserting all of the contents into\n /// this archive.\n-fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n+fn link_rlib<'a>(\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n     flavor: RlibFlavor,\n-    out_filename: &Path,\n     tmpdir: &MaybeTempDir,\n-) -> Result<B, ErrorGuaranteed> {\n-    info!(\"preparing rlib to {:?}\", out_filename);\n-\n+) -> Result<Box<dyn ArchiveBuilder<'a> + 'a>, ErrorGuaranteed> {\n     let lib_search_paths = archive_search_paths(sess);\n \n-    let mut ab = <B as ArchiveBuilder>::new(sess, out_filename);\n+    let mut ab = archive_builder_builder.new_archive_builder(sess);\n \n     let trailing_metadata = match flavor {\n         RlibFlavor::Normal => {\n@@ -342,7 +349,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n         if let Some(name) = lib.name {\n             let location =\n                 find_library(name.as_str(), lib.verbatim.unwrap_or(false), &lib_search_paths, sess);\n-            ab.add_archive(&location, |_| false).unwrap_or_else(|e| {\n+            ab.add_archive(&location, Box::new(|_| false)).unwrap_or_else(|e| {\n                 sess.fatal(&format!(\n                     \"failed to add native library {}: {}\",\n                     location.to_string_lossy(),\n@@ -355,7 +362,16 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n     for (raw_dylib_name, raw_dylib_imports) in\n         collate_raw_dylibs(sess, &codegen_results.crate_info.used_libraries)?\n     {\n-        ab.inject_dll_import_lib(&raw_dylib_name, &raw_dylib_imports, tmpdir);\n+        let output_path = archive_builder_builder.create_dll_import_lib(\n+            sess,\n+            &raw_dylib_name,\n+            &raw_dylib_imports,\n+            tmpdir.as_ref(),\n+        );\n+\n+        ab.add_archive(&output_path, Box::new(|_| false)).unwrap_or_else(|e| {\n+            sess.fatal(&format!(\"failed to add native library {}: {}\", output_path.display(), e));\n+        });\n     }\n \n     if let Some(trailing_metadata) = trailing_metadata {\n@@ -446,14 +462,21 @@ fn collate_raw_dylibs(\n ///\n /// There's no need to include metadata in a static archive, so ensure to not link in the metadata\n /// object file (and also don't prepare the archive with a metadata file).\n-fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n+fn link_staticlib<'a>(\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n     out_filename: &Path,\n     tempdir: &MaybeTempDir,\n ) -> Result<(), ErrorGuaranteed> {\n-    let mut ab =\n-        link_rlib::<B>(sess, codegen_results, RlibFlavor::StaticlibBase, out_filename, tempdir)?;\n+    info!(\"preparing staticlib to {:?}\", out_filename);\n+    let mut ab = link_rlib(\n+        sess,\n+        archive_builder_builder,\n+        codegen_results,\n+        RlibFlavor::StaticlibBase,\n+        tempdir,\n+    )?;\n     let mut all_native_libs = vec![];\n \n     let res = each_linked_rlib(&codegen_results.crate_info, &mut |cnum, path| {\n@@ -487,26 +510,29 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n         // might be also an extra name suffix\n         let obj_start = name.as_str().to_owned();\n \n-        ab.add_archive(path, move |fname: &str| {\n-            // Ignore metadata files, no matter the name.\n-            if fname == METADATA_FILENAME {\n-                return true;\n-            }\n+        ab.add_archive(\n+            path,\n+            Box::new(move |fname: &str| {\n+                // Ignore metadata files, no matter the name.\n+                if fname == METADATA_FILENAME {\n+                    return true;\n+                }\n \n-            // Don't include Rust objects if LTO is enabled\n-            if lto && looks_like_rust_object_file(fname) {\n-                return true;\n-            }\n+                // Don't include Rust objects if LTO is enabled\n+                if lto && looks_like_rust_object_file(fname) {\n+                    return true;\n+                }\n \n-            // Otherwise if this is *not* a rust object and we're skipping\n-            // objects then skip this file\n-            if skip_object_files && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\")) {\n-                return true;\n-            }\n+                // Otherwise if this is *not* a rust object and we're skipping\n+                // objects then skip this file\n+                if skip_object_files && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\")) {\n+                    return true;\n+                }\n \n-            // ok, don't skip this\n-            false\n-        })\n+                // ok, don't skip this\n+                false\n+            }),\n+        )\n         .unwrap();\n \n         all_native_libs.extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n@@ -515,7 +541,7 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n         sess.fatal(&e);\n     }\n \n-    ab.build();\n+    ab.build(out_filename);\n \n     if !all_native_libs.is_empty() {\n         if sess.opts.prints.contains(&PrintRequest::NativeStaticLibs) {\n@@ -645,19 +671,21 @@ fn link_dwarf_object<'a>(\n ///\n /// This will invoke the system linker/cc to create the resulting file. This links to all upstream\n /// files as well.\n-fn link_natively<'a, B: ArchiveBuilder<'a>>(\n+fn link_natively<'a>(\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     crate_type: CrateType,\n     out_filename: &Path,\n     codegen_results: &CodegenResults,\n     tmpdir: &Path,\n ) -> Result<(), ErrorGuaranteed> {\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n     let (linker_path, flavor) = linker_and_flavor(sess);\n-    let mut cmd = linker_with_args::<B>(\n+    let mut cmd = linker_with_args(\n         &linker_path,\n         flavor,\n         sess,\n+        archive_builder_builder,\n         crate_type,\n         tmpdir,\n         out_filename,\n@@ -1844,10 +1872,11 @@ fn add_rpath_args(\n /// to the linking process as a whole.\n /// Order-independent options may still override each other in order-dependent fashion,\n /// e.g `--foo=yes --foo=no` may be equivalent to `--foo=no`.\n-fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n+fn linker_with_args<'a>(\n     path: &Path,\n     flavor: LinkerFlavor,\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     crate_type: CrateType,\n     tmpdir: &Path,\n     out_filename: &Path,\n@@ -1948,7 +1977,14 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // Upstream rust libraries and their non-bundled static libraries\n-    add_upstream_rust_crates::<B>(cmd, sess, codegen_results, crate_type, tmpdir);\n+    add_upstream_rust_crates(\n+        cmd,\n+        sess,\n+        archive_builder_builder,\n+        codegen_results,\n+        crate_type,\n+        tmpdir,\n+    );\n \n     // Upstream dynamic native libraries linked with `#[link]` attributes at and `-l`\n     // command line options.\n@@ -1963,7 +1999,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     for (raw_dylib_name, raw_dylib_imports) in\n         collate_raw_dylibs(sess, &codegen_results.crate_info.used_libraries)?\n     {\n-        cmd.add_object(&B::create_dll_import_lib(\n+        cmd.add_object(&archive_builder_builder.create_dll_import_lib(\n             sess,\n             &raw_dylib_name,\n             &raw_dylib_imports,\n@@ -2256,9 +2292,10 @@ fn add_local_native_libraries(\n ///\n /// Rust crates are not considered at all when creating an rlib output. All dependencies will be\n /// linked when producing the final output (instead of the intermediate rlib version).\n-fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n+fn add_upstream_rust_crates<'a>(\n     cmd: &mut dyn Linker,\n     sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n     crate_type: CrateType,\n     tmpdir: &Path,\n@@ -2347,7 +2384,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let src = &codegen_results.crate_info.used_crate_source[&cnum];\n         match data[cnum.as_usize() - 1] {\n             _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n-                add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, cnum);\n+                add_static_crate(cmd, sess, archive_builder_builder, codegen_results, tmpdir, cnum);\n             }\n             // compiler-builtins are always placed last to ensure that they're\n             // linked correctly.\n@@ -2357,7 +2394,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n             }\n             Linkage::NotLinked | Linkage::IncludedFromDylib => {}\n             Linkage::Static => {\n-                add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, cnum);\n+                add_static_crate(cmd, sess, archive_builder_builder, codegen_results, tmpdir, cnum);\n \n                 // Link static native libs with \"-bundle\" modifier only if the crate they originate from\n                 // is being linked statically to the current crate.  If it's linked dynamically\n@@ -2431,7 +2468,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n     // is used)\n     if let Some(cnum) = compiler_builtins {\n-        add_static_crate::<B>(cmd, sess, codegen_results, tmpdir, cnum);\n+        add_static_crate(cmd, sess, archive_builder_builder, codegen_results, tmpdir, cnum);\n     }\n \n     // Converts a library file-stem into a cc -l argument\n@@ -2457,9 +2494,10 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     // Note, however, that if we're not doing LTO we can just pass the rlib\n     // blindly to the linker (fast) because it's fine if it's not actually\n     // included as we're at the end of the dependency chain.\n-    fn add_static_crate<'a, B: ArchiveBuilder<'a>>(\n+    fn add_static_crate<'a>(\n         cmd: &mut dyn Linker,\n         sess: &'a Session,\n+        archive_builder_builder: &dyn ArchiveBuilderBuilder,\n         codegen_results: &CodegenResults,\n         tmpdir: &Path,\n         cnum: CrateNum,\n@@ -2499,38 +2537,41 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n             let is_builtins = sess.target.no_builtins\n                 || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n \n-            let mut archive = <B as ArchiveBuilder>::new(sess, &dst);\n-            if let Err(e) = archive.add_archive(cratepath, move |f| {\n-                if f == METADATA_FILENAME {\n-                    return true;\n-                }\n+            let mut archive = archive_builder_builder.new_archive_builder(sess);\n+            if let Err(e) = archive.add_archive(\n+                cratepath,\n+                Box::new(move |f| {\n+                    if f == METADATA_FILENAME {\n+                        return true;\n+                    }\n \n-                let canonical = f.replace('-', \"_\");\n+                    let canonical = f.replace('-', \"_\");\n \n-                let is_rust_object =\n-                    canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n+                    let is_rust_object =\n+                        canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n \n-                // If we've been requested to skip all native object files\n-                // (those not generated by the rust compiler) then we can skip\n-                // this file. See above for why we may want to do this.\n-                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n+                    // If we've been requested to skip all native object files\n+                    // (those not generated by the rust compiler) then we can skip\n+                    // this file. See above for why we may want to do this.\n+                    let skip_because_cfg_say_so = skip_native && !is_rust_object;\n \n-                // If we're performing LTO and this is a rust-generated object\n-                // file, then we don't need the object file as it's part of the\n-                // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n-                // though, so we let that object file slide.\n-                let skip_because_lto =\n-                    upstream_rust_objects_already_included && is_rust_object && is_builtins;\n+                    // If we're performing LTO and this is a rust-generated object\n+                    // file, then we don't need the object file as it's part of the\n+                    // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n+                    // though, so we let that object file slide.\n+                    let skip_because_lto =\n+                        upstream_rust_objects_already_included && is_rust_object && is_builtins;\n \n-                if skip_because_cfg_say_so || skip_because_lto {\n-                    return true;\n-                }\n+                    if skip_because_cfg_say_so || skip_because_lto {\n+                        return true;\n+                    }\n \n-                false\n-            }) {\n+                    false\n+                }),\n+            ) {\n                 sess.fatal(&format!(\"failed to build archive from rlib: {}\", e));\n             }\n-            if archive.build() {\n+            if archive.build(&dst) {\n                 link_upstream(&dst);\n             }\n         });"}]}