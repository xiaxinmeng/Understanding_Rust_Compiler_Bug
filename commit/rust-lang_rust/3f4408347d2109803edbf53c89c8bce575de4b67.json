{"sha": "3f4408347d2109803edbf53c89c8bce575de4b67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNDQwODM0N2QyMTA5ODAzZWRiZjUzYzg5YzhiY2U1NzVkZTRiNjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-27T19:51:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-27T19:51:49Z"}, "message": "Auto merge of #37350 - srinivasreddy:meta_2, r=nrc\n\nrun rustfmt on librustc_metadata folder", "tree": {"sha": "408edd0f2d340a7eb53535818167101b5aa26bfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/408edd0f2d340a7eb53535818167101b5aa26bfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f4408347d2109803edbf53c89c8bce575de4b67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f4408347d2109803edbf53c89c8bce575de4b67", "html_url": "https://github.com/rust-lang/rust/commit/3f4408347d2109803edbf53c89c8bce575de4b67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f4408347d2109803edbf53c89c8bce575de4b67/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07436946b6ee6345509b73c6e4dafb38b6a243f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/07436946b6ee6345509b73c6e4dafb38b6a243f1", "html_url": "https://github.com/rust-lang/rust/commit/07436946b6ee6345509b73c6e4dafb38b6a243f1"}, {"sha": "892a05d694960c30a5568b173a25a4ed9f56c283", "url": "https://api.github.com/repos/rust-lang/rust/commits/892a05d694960c30a5568b173a25a4ed9f56c283", "html_url": "https://github.com/rust-lang/rust/commit/892a05d694960c30a5568b173a25a4ed9f56c283"}], "stats": {"total": 705, "additions": 363, "deletions": 342}, "files": [{"sha": "8d2646560f5953a0c4363d1453db4d5ca2caeac6", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 149, "deletions": 169, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/3f4408347d2109803edbf53c89c8bce575de4b67/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4408347d2109803edbf53c89c8bce575de4b67/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=3f4408347d2109803edbf53c89c8bce575de4b67", "patch": "@@ -117,7 +117,8 @@ impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> SpecializedEncoder<ty::GenericPredicates<'tcx>> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, predicates: &ty::GenericPredicates<'tcx>)\n+    fn specialized_encode(&mut self,\n+                          predicates: &ty::GenericPredicates<'tcx>)\n                           -> Result<(), Self::Error> {\n         predicates.parent.encode(self)?;\n         predicates.predicates.len().encode(self)?;\n@@ -142,13 +143,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         r\n     }\n \n-    fn emit_lazy_distance(&mut self, position: usize, min_size: usize)\n+    fn emit_lazy_distance(&mut self,\n+                          position: usize,\n+                          min_size: usize)\n                           -> Result<(), <Self as Encoder>::Error> {\n         let min_end = position + min_size;\n         let distance = match self.lazy_state {\n-            LazyState::NoNode => {\n-                bug!(\"emit_lazy_distance: outside of a metadata node\")\n-            }\n+            LazyState::NoNode => bug!(\"emit_lazy_distance: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n                 assert!(min_end <= start);\n                 start - min_end\n@@ -172,7 +173,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n-    where I: IntoIterator<Item=T>, T: Encodable {\n+        where I: IntoIterator<Item = T>,\n+              T: Encodable\n+    {\n         self.emit_node(|ecx, pos| {\n             let len = iter.into_iter().map(|value| value.encode(ecx).unwrap()).count();\n \n@@ -182,7 +185,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn lazy_seq_ref<'b, I, T>(&mut self, iter: I) -> LazySeq<T>\n-    where I: IntoIterator<Item=&'b T>, T: 'b + Encodable {\n+        where I: IntoIterator<Item = &'b T>,\n+              T: 'b + Encodable\n+    {\n         self.emit_node(|ecx, pos| {\n             let len = iter.into_iter().map(|value| value.encode(ecx).unwrap()).count();\n \n@@ -192,11 +197,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     /// Encode the given value or a previously cached shorthand.\n-    fn encode_with_shorthand<T, U, M>(&mut self, value: &T, variant: &U, map: M)\n+    fn encode_with_shorthand<T, U, M>(&mut self,\n+                                      value: &T,\n+                                      variant: &U,\n+                                      map: M)\n                                       -> Result<(), <Self as Encoder>::Error>\n-    where M: for<'b> Fn(&'b mut Self) -> &'b mut FnvHashMap<T, usize>,\n-          T: Clone + Eq + Hash,\n-          U: Encodable {\n+        where M: for<'b> Fn(&'b mut Self) -> &'b mut FnvHashMap<T, usize>,\n+              T: Clone + Eq + Hash,\n+              U: Encodable\n+    {\n         let existing_shorthand = map(self).get(value).cloned();\n         if let Some(shorthand) = existing_shorthand {\n             return self.emit_usize(shorthand);\n@@ -208,9 +217,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         // The shorthand encoding uses the same usize as the\n         // discriminant, with an offset so they can't conflict.\n-        let discriminant = unsafe {\n-            intrinsics::discriminant_value(variant)\n-        };\n+        let discriminant = unsafe { intrinsics::discriminant_value(variant) };\n         assert!(discriminant < SHORTHAND_OFFSET as u64);\n         let shorthand = start + SHORTHAND_OFFSET;\n \n@@ -250,8 +257,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     /// the right to access any information in the adt-def (including,\n     /// e.g., the length of the various vectors).\n     fn encode_enum_variant_info(&mut self,\n-                                (enum_did, Untracked(index)):\n-                                (DefId, Untracked<usize>)) -> Entry<'tcx> {\n+                                (enum_did, Untracked(index)): (DefId, Untracked<usize>))\n+                                -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def = tcx.lookup_adt_def(enum_did);\n         let variant = &def.variants[index];\n@@ -260,7 +267,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             disr: variant.disr_val.to_u64_unchecked(),\n-            struct_ctor: None\n+            struct_ctor: None,\n         };\n \n         let enum_id = tcx.map.as_local_node_id(enum_did).unwrap();\n@@ -285,24 +292,23 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: None\n+            mir: None,\n         }\n     }\n \n     fn encode_info_for_mod(&mut self,\n-                           FromId(id, (md, attrs, vis)):\n-                           FromId<(&hir::Mod, &[ast::Attribute], &hir::Visibility)>)\n+                           FromId(id, (md, attrs, vis)): FromId<(&hir::Mod,\n+                                                                 &[ast::Attribute],\n+                                                                 &hir::Visibility)>)\n                            -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def_id = tcx.map.local_def_id(id);\n \n         let data = ModData {\n             reexports: match self.reexports.get(&id) {\n-                Some(exports) if *vis == hir::Public => {\n-                    self.lazy_seq_ref(exports)\n-                }\n-                _ => LazySeq::empty()\n-            }\n+                Some(exports) if *vis == hir::Public => self.lazy_seq_ref(exports),\n+                _ => LazySeq::empty(),\n+            },\n         };\n \n         Entry {\n@@ -353,8 +359,7 @@ impl Visibility for ty::Visibility {\n }\n \n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n-    fn encode_fields(&mut self,\n-                     adt_def_id: DefId) {\n+    fn encode_fields(&mut self, adt_def_id: DefId) {\n         let def = self.tcx.lookup_adt_def(adt_def_id);\n         for (variant_index, variant) in def.variants.iter().enumerate() {\n             for (field_index, field) in variant.fields.iter().enumerate() {\n@@ -374,8 +379,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     /// the adt-def (including, e.g., the length of the various\n     /// vectors).\n     fn encode_field(&mut self,\n-                    (adt_def_id, Untracked((variant_index, field_index))):\n-                    (DefId, Untracked<(usize, usize)>)) -> Entry<'tcx> {\n+                    (adt_def_id, Untracked((variant_index, field_index))): (DefId,\n+                                                                            Untracked<(usize,\n+                                                                                       usize)>))\n+                    -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let variant = &tcx.lookup_adt_def(adt_def_id).variants[variant_index];\n         let field = &variant.fields[field_index];\n@@ -400,19 +407,18 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: None\n+            mir: None,\n         }\n     }\n \n-    fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId))\n-                          -> Entry<'tcx> {\n+    fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId)) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let variant = tcx.lookup_adt_def(adt_def_id).struct_variant();\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             disr: variant.disr_val.to_u64_unchecked(),\n-            struct_ctor: Some(def_id.index)\n+            struct_ctor: Some(def_id.index),\n         };\n \n         let struct_id = tcx.map.as_local_node_id(adt_def_id).unwrap();\n@@ -434,7 +440,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: None\n+            mir: None,\n         }\n     }\n \n@@ -469,21 +475,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let fn_data = if let hir::MethodTraitItem(ref sig, _) = ast_item.node {\n                     FnData {\n                         constness: hir::Constness::NotConst,\n-                        arg_names: self.encode_fn_arg_names(&sig.decl)\n+                        arg_names: self.encode_fn_arg_names(&sig.decl),\n                     }\n                 } else {\n                     bug!()\n                 };\n                 let data = MethodData {\n                     fn_data: fn_data,\n                     container: container(method_ty.has_body),\n-                    explicit_self: self.lazy(&method_ty.explicit_self)\n+                    explicit_self: self.lazy(&method_ty.explicit_self),\n                 };\n                 EntryKind::Method(self.lazy(&data))\n             }\n-            ty::TypeTraitItem(_) => {\n-                EntryKind::AssociatedType(container(false))\n-            }\n+            ty::TypeTraitItem(_) => EntryKind::AssociatedType(container(false)),\n         };\n \n         Entry {\n@@ -497,9 +501,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             ty: match trait_item {\n                 ty::ConstTraitItem(_) |\n-                ty::MethodTraitItem(_) => {\n-                    Some(self.encode_item_type(def_id))\n-                }\n+                ty::MethodTraitItem(_) => Some(self.encode_item_type(def_id)),\n                 ty::TypeTraitItem(ref associated_type) => {\n                     associated_type.ty.map(|ty| self.lazy(&ty))\n                 }\n@@ -515,7 +517,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             } else {\n                 None\n             },\n-            mir: self.encode_mir(def_id)\n+            mir: self.encode_mir(def_id),\n         }\n     }\n \n@@ -527,32 +529,28 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let container = match ast_item.defaultness {\n             hir::Defaultness::Default => AssociatedContainer::ImplDefault,\n-            hir::Defaultness::Final => AssociatedContainer::ImplFinal\n+            hir::Defaultness::Final => AssociatedContainer::ImplFinal,\n         };\n \n         let kind = match impl_item {\n-            ty::ConstTraitItem(_) => {\n-                EntryKind::AssociatedConst(container)\n-            }\n+            ty::ConstTraitItem(_) => EntryKind::AssociatedConst(container),\n             ty::MethodTraitItem(ref method_ty) => {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n                     FnData {\n                         constness: sig.constness,\n-                        arg_names: self.encode_fn_arg_names(&sig.decl)\n+                        arg_names: self.encode_fn_arg_names(&sig.decl),\n                     }\n                 } else {\n                     bug!()\n                 };\n                 let data = MethodData {\n                     fn_data: fn_data,\n                     container: container,\n-                    explicit_self: self.lazy(&method_ty.explicit_self)\n+                    explicit_self: self.lazy(&method_ty.explicit_self),\n                 };\n                 EntryKind::Method(self.lazy(&data))\n             }\n-            ty::TypeTraitItem(_) => {\n-                EntryKind::AssociatedType(container)\n-            }\n+            ty::TypeTraitItem(_) => EntryKind::AssociatedType(container),\n         };\n \n         let (ast, mir) = if let ty::ConstTraitItem(_) = impl_item {\n@@ -578,9 +576,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             ty: match impl_item {\n                 ty::ConstTraitItem(_) |\n-                ty::MethodTraitItem(_) => {\n-                    Some(self.encode_item_type(def_id))\n-                }\n+                ty::MethodTraitItem(_) => Some(self.encode_item_type(def_id)),\n                 ty::TypeTraitItem(ref associated_type) => {\n                     associated_type.ty.map(|ty| self.lazy(&ty))\n                 }\n@@ -595,11 +591,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             } else {\n                 None\n             },\n-            mir: if mir {\n-                self.encode_mir(def_id)\n-            } else {\n-                None\n-            }\n+            mir: if mir { self.encode_mir(def_id) } else { None },\n         }\n     }\n \n@@ -638,8 +630,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(&depr))\n     }\n \n-    fn encode_info_for_item(&mut self,\n-                            (def_id, item): (DefId, &hir::Item)) -> Entry<'tcx> {\n+    fn encode_info_for_item(&mut self, (def_id, item): (DefId, &hir::Item)) -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n         debug!(\"encoding info for item at {}\",\n@@ -652,7 +643,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemFn(ref decl, _, constness, ..) => {\n                 let data = FnData {\n                     constness: constness,\n-                    arg_names: self.encode_fn_arg_names(&decl)\n+                    arg_names: self.encode_fn_arg_names(&decl),\n                 };\n \n                 EntryKind::Fn(self.lazy(&data))\n@@ -666,9 +657,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemStruct(ref struct_def, _) => {\n                 let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n-                /* Encode def_ids for each field and method\n-                for methods, write all the stuff get_trait_method\n-                needs to know*/\n+                // Encode def_ids for each field and method\n+                // for methods, write all the stuff get_trait_method\n+                // needs to know\n                 let struct_ctor = if !struct_def.is_struct() {\n                     Some(tcx.map.local_def_id(struct_def.id()).index)\n                 } else {\n@@ -677,7 +668,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     disr: variant.disr_val.to_u64_unchecked(),\n-                    struct_ctor: struct_ctor\n+                    struct_ctor: struct_ctor,\n                 }))\n             }\n             hir::ItemUnion(..) => {\n@@ -686,15 +677,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 EntryKind::Union(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     disr: variant.disr_val.to_u64_unchecked(),\n-                    struct_ctor: None\n+                    struct_ctor: None,\n                 }))\n             }\n             hir::ItemDefaultImpl(..) => {\n                 let data = ImplData {\n                     polarity: hir::ImplPolarity::Positive,\n                     parent_impl: None,\n                     coerce_unsized_kind: None,\n-                    trait_ref: tcx.impl_trait_ref(def_id).map(|trait_ref| self.lazy(&trait_ref))\n+                    trait_ref: tcx.impl_trait_ref(def_id).map(|trait_ref| self.lazy(&trait_ref)),\n                 };\n \n                 EntryKind::DefaultImpl(self.lazy(&data))\n@@ -716,9 +707,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let data = ImplData {\n                     polarity: polarity,\n                     parent_impl: parent,\n-                    coerce_unsized_kind: tcx.custom_coerce_unsized_kinds.borrow()\n-                                            .get(&def_id).cloned(),\n-                    trait_ref: trait_ref.map(|trait_ref| self.lazy(&trait_ref))\n+                    coerce_unsized_kind: tcx.custom_coerce_unsized_kinds\n+                        .borrow()\n+                        .get(&def_id)\n+                        .cloned(),\n+                    trait_ref: trait_ref.map(|trait_ref| self.lazy(&trait_ref)),\n                 };\n \n                 EntryKind::Impl(self.lazy(&data))\n@@ -730,14 +723,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     paren_sugar: trait_def.paren_sugar,\n                     has_default_impl: tcx.trait_has_default_impl(def_id),\n                     trait_ref: self.lazy(&trait_def.trait_ref),\n-                    super_predicates: self.lazy(&tcx.lookup_super_predicates(def_id))\n+                    super_predicates: self.lazy(&tcx.lookup_super_predicates(def_id)),\n                 };\n \n                 EntryKind::Trait(self.lazy(&data))\n             }\n-            hir::ItemExternCrate(_) | hir::ItemUse(_) => {\n-                bug!(\"cannot encode info for item {:?}\", item)\n-            }\n+            hir::ItemExternCrate(_) |\n+            hir::ItemUse(_) => bug!(\"cannot encode info for item {:?}\", item),\n         };\n \n         Entry {\n@@ -747,9 +739,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             attributes: self.encode_attributes(&item.attrs),\n             children: match item.node {\n                 hir::ItemForeignMod(ref fm) => {\n-                    self.lazy_seq(fm.items.iter().map(|foreign_item| {\n-                        tcx.map.local_def_id(foreign_item.id).index\n-                    }))\n+                    self.lazy_seq(fm.items\n+                        .iter()\n+                        .map(|foreign_item| tcx.map.local_def_id(foreign_item.id).index))\n                 }\n                 hir::ItemEnum(..) => {\n                     let def = self.tcx.lookup_adt_def(def_id);\n@@ -773,7 +765,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         def_id.index\n                     }))\n                 }\n-                _ => LazySeq::empty()\n+                _ => LazySeq::empty(),\n             },\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n@@ -786,20 +778,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n-                hir::ItemImpl(..) => {\n-                    Some(self.encode_item_type(def_id))\n-                }\n-                _ => None\n+                hir::ItemImpl(..) => Some(self.encode_item_type(def_id)),\n+                _ => None,\n             },\n             inherent_impls: self.encode_inherent_implementations(def_id),\n             variances: match item.node {\n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n-                hir::ItemTrait(..) => {\n-                    self.encode_item_variances(def_id)\n-                }\n-                _ => LazySeq::empty()\n+                hir::ItemTrait(..) => self.encode_item_variances(def_id),\n+                _ => LazySeq::empty(),\n             },\n             generics: match item.node {\n                 hir::ItemStatic(..) |\n@@ -810,10 +798,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n                 hir::ItemImpl(..) |\n-                hir::ItemTrait(..) => {\n-                    Some(self.encode_generics(def_id))\n-                }\n-                _ => None\n+                hir::ItemTrait(..) => Some(self.encode_generics(def_id)),\n+                _ => None,\n             },\n             predicates: match item.node {\n                 hir::ItemStatic(..) |\n@@ -824,23 +810,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n                 hir::ItemImpl(..) |\n-                hir::ItemTrait(..) => {\n-                    Some(self.encode_predicates(def_id))\n-                }\n-                _ => None\n+                hir::ItemTrait(..) => Some(self.encode_predicates(def_id)),\n+                _ => None,\n             },\n \n             ast: match item.node {\n                 hir::ItemConst(..) |\n                 hir::ItemFn(_, _, hir::Constness::Const, ..) => {\n                     Some(self.encode_inlined_item(InlinedItemRef::Item(def_id, item)))\n                 }\n-                _ => None\n+                _ => None,\n             },\n             mir: match item.node {\n-                hir::ItemConst(..) => {\n-                    self.encode_mir(def_id)\n-                }\n+                hir::ItemConst(..) => self.encode_mir(def_id),\n                 hir::ItemFn(_, _, constness, _, ref generics, _) => {\n                     let tps_len = generics.ty_params.len();\n                     let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n@@ -850,8 +832,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         None\n                     }\n                 }\n-                _ => None\n-            }\n+                _ => None,\n+            },\n         }\n     }\n }\n@@ -861,8 +843,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     /// encode some sub-items. Usually we want some info from the item\n     /// so it's easier to do that here then to wait until we would encounter\n     /// normally in the visitor walk.\n-    fn encode_addl_info_for_item(&mut self,\n-                                 item: &hir::Item) {\n+    fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n         let def_id = self.tcx.map.local_def_id(item.id);\n         match item.node {\n             hir::ItemStatic(..) |\n@@ -930,12 +911,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ForeignItemFn(ref fndecl, _) => {\n                 let data = FnData {\n                     constness: hir::Constness::NotConst,\n-                    arg_names: self.encode_fn_arg_names(&fndecl)\n+                    arg_names: self.encode_fn_arg_names(&fndecl),\n                 };\n                 EntryKind::ForeignFn(self.lazy(&data))\n             }\n             hir::ForeignItemStatic(_, true) => EntryKind::ForeignMutStatic,\n-            hir::ForeignItemStatic(_, false) => EntryKind::ForeignImmStatic\n+            hir::ForeignItemStatic(_, false) => EntryKind::ForeignImmStatic,\n         };\n \n         Entry {\n@@ -954,7 +935,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: None\n+            mir: None,\n         }\n     }\n }\n@@ -972,10 +953,9 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         intravisit::walk_item(self, item);\n         let def_id = self.index.tcx.map.local_def_id(item.id);\n         match item.node {\n-            hir::ItemExternCrate(_) | hir::ItemUse(_) => (), // ignore these\n-            _ => self.index.record(def_id,\n-                                   EncodeContext::encode_info_for_item,\n-                                   (def_id, item)),\n+            hir::ItemExternCrate(_) |\n+            hir::ItemUse(_) => (), // ignore these\n+            _ => self.index.record(def_id, EncodeContext::encode_info_for_item, (def_id, item)),\n         }\n         self.index.encode_addl_info_for_item(item);\n     }\n@@ -996,21 +976,17 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyImplTrait(_) = ty.node {\n             let def_id = self.tcx.map.local_def_id(ty.id);\n-            self.record(def_id,\n-                        EncodeContext::encode_info_for_anon_ty,\n-                        def_id);\n+            self.record(def_id, EncodeContext::encode_info_for_anon_ty, def_id);\n         }\n     }\n \n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprClosure(..) => {\n                 let def_id = self.tcx.map.local_def_id(expr.id);\n-                self.record(def_id,\n-                            EncodeContext::encode_info_for_closure,\n-                            def_id);\n+                self.record(def_id, EncodeContext::encode_info_for_closure, def_id);\n             }\n-            _ => { }\n+            _ => {}\n         }\n     }\n }\n@@ -1033,7 +1009,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: Some(self.encode_predicates(def_id)),\n \n             ast: None,\n-            mir: None\n+            mir: None,\n         }\n     }\n \n@@ -1042,7 +1018,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = ClosureData {\n             kind: tcx.closure_kind(def_id),\n-            ty: self.lazy(&tcx.tables.borrow().closure_tys[&def_id])\n+            ty: self.lazy(&tcx.tables.borrow().closure_tys[&def_id]),\n         };\n \n         Entry {\n@@ -1061,7 +1037,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             predicates: None,\n \n             ast: None,\n-            mir: self.encode_mir(def_id)\n+            mir: self.encode_mir(def_id),\n         }\n     }\n \n@@ -1071,9 +1047,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         index.record(DefId::local(CRATE_DEF_INDEX),\n                      EncodeContext::encode_info_for_mod,\n                      FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n-        let mut visitor = EncodeVisitor {\n-            index: index,\n-        };\n+        let mut visitor = EncodeVisitor { index: index };\n         krate.visit_all_items(&mut visitor);\n         visitor.index.into_items()\n     }\n@@ -1083,8 +1057,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n-        fn get_ordered_deps(cstore: &cstore::CStore)\n-                            -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n+        fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n             // Pull the cnums and name,vers,hash out of cstore\n             let mut deps = Vec::new();\n             cstore.iter_crate_data(|cnum, val| {\n@@ -1113,13 +1086,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             CrateDep {\n                 name: syntax::parse::token::intern(dep.name()),\n                 hash: dep.hash(),\n-                explicitly_linked: dep.explicitly_linked.get()\n+                explicitly_linked: dep.explicitly_linked.get(),\n             }\n         }))\n     }\n \n-    fn encode_lang_items(&mut self)\n-                         -> (LazySeq<(DefIndex, usize)>, LazySeq<lang_items::LangItem>) {\n+    fn encode_lang_items(&mut self) -> (LazySeq<(DefIndex, usize)>, LazySeq<lang_items::LangItem>) {\n         let tcx = self.tcx;\n         let lang_items = tcx.lang_items.items().iter();\n         (self.lazy_seq(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n@@ -1129,31 +1101,32 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n             }\n             None\n-        })), self.lazy_seq_ref(&tcx.lang_items.missing))\n+        })),\n+         self.lazy_seq_ref(&tcx.lang_items.missing))\n     }\n \n     fn encode_native_libraries(&mut self) -> LazySeq<(NativeLibraryKind, String)> {\n         let used_libraries = self.tcx.sess.cstore.used_libraries();\n         self.lazy_seq(used_libraries.into_iter().filter_map(|(lib, kind)| {\n             match kind {\n                 cstore::NativeStatic => None, // these libraries are not propagated\n-                cstore::NativeFramework | cstore::NativeUnknown => {\n-                    Some((kind, lib))\n-                }\n+                cstore::NativeFramework | cstore::NativeUnknown => Some((kind, lib)),\n             }\n         }))\n     }\n \n     fn encode_codemap(&mut self) -> LazySeq<syntax_pos::FileMap> {\n         let codemap = self.tcx.sess.codemap();\n         let all_filemaps = codemap.files.borrow();\n-        self.lazy_seq_ref(all_filemaps.iter().filter(|filemap| {\n-            // No need to export empty filemaps, as they can't contain spans\n-            // that need translation.\n-            // Also no need to re-export imported filemaps, as any downstream\n-            // crate will import them from their original source.\n-            !filemap.lines.borrow().is_empty() && !filemap.is_imported()\n-        }).map(|filemap| &**filemap))\n+        self.lazy_seq_ref(all_filemaps.iter()\n+            .filter(|filemap| {\n+                // No need to export empty filemaps, as they can't contain spans\n+                // that need translation.\n+                // Also no need to re-export imported filemaps, as any downstream\n+                // crate will import them from their original source.\n+                !filemap.lines.borrow().is_empty() && !filemap.is_imported()\n+            })\n+            .map(|filemap| &**filemap))\n     }\n \n     /// Serialize the text of the exported macros\n@@ -1164,23 +1137,24 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 name: def.name,\n                 attrs: def.attrs.to_vec(),\n                 span: def.span,\n-                body: ::syntax::print::pprust::tts_to_string(&def.body)\n+                body: ::syntax::print::pprust::tts_to_string(&def.body),\n             }\n         }))\n     }\n }\n \n-struct ImplVisitor<'a, 'tcx:'a> {\n+struct ImplVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    impls: FnvHashMap<DefId, Vec<DefIndex>>\n+    impls: FnvHashMap<DefId, Vec<DefIndex>>,\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemImpl(..) = item.node {\n             let impl_id = self.tcx.map.local_def_id(item.id);\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n-                self.impls.entry(trait_ref.def_id)\n+                self.impls\n+                    .entry(trait_ref.def_id)\n                     .or_insert(vec![])\n                     .push(impl_id.index);\n             }\n@@ -1193,16 +1167,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_impls(&mut self) -> LazySeq<TraitImpls> {\n         let mut visitor = ImplVisitor {\n             tcx: self.tcx,\n-            impls: FnvHashMap()\n+            impls: FnvHashMap(),\n         };\n         self.tcx.map.krate().visit_all_items(&mut visitor);\n \n-        let all_impls: Vec<_> = visitor.impls.into_iter().map(|(trait_def_id, impls)| {\n-            TraitImpls {\n-                trait_id: (trait_def_id.krate.as_u32(), trait_def_id.index),\n-                impls: self.lazy_seq(impls)\n-            }\n-        }).collect();\n+        let all_impls: Vec<_> = visitor.impls\n+            .into_iter()\n+            .map(|(trait_def_id, impls)| {\n+                TraitImpls {\n+                    trait_id: (trait_def_id.krate.as_u32(), trait_def_id.index),\n+                    impls: self.lazy_seq(impls),\n+                }\n+            })\n+            .collect();\n \n         self.lazy_seq(all_impls)\n     }\n@@ -1232,7 +1209,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     }\n                 }))\n             }\n-            None => LazySeq::empty()\n+            None => LazySeq::empty(),\n         }\n     }\n \n@@ -1291,9 +1268,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hash: link_meta.crate_hash,\n             disambiguator: tcx.sess.local_crate_disambiguator().to_string(),\n             panic_strategy: tcx.sess.panic_strategy(),\n-            plugin_registrar_fn: tcx.sess.plugin_registrar_fn.get().map(|id| {\n-                tcx.map.local_def_id(id).index\n-            }),\n+            plugin_registrar_fn: tcx.sess\n+                .plugin_registrar_fn\n+                .get()\n+                .map(|id| tcx.map.local_def_id(id).index),\n             macro_derive_registrar: if is_proc_macro {\n                 let id = tcx.sess.derive_registrar_fn.get().unwrap();\n                 Some(tcx.map.local_def_id(id).index)\n@@ -1369,34 +1347,36 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  reexports: &def::ExportMap,\n                                  link_meta: &LinkMeta,\n                                  reachable: &NodeSet,\n-                                 mir_map: &MirMap<'tcx>) -> Vec<u8> {\n+                                 mir_map: &MirMap<'tcx>)\n+                                 -> Vec<u8> {\n     let mut cursor = Cursor::new(vec![]);\n     cursor.write_all(METADATA_HEADER).unwrap();\n \n     // Will be filed with the root position after encoding everything.\n     cursor.write_all(&[0, 0, 0, 0]).unwrap();\n \n     let root = EncodeContext {\n-        opaque: opaque::Encoder::new(&mut cursor),\n-        tcx: tcx,\n-        reexports: reexports,\n-        link_meta: link_meta,\n-        cstore: cstore,\n-        reachable: reachable,\n-        mir_map: mir_map,\n-        lazy_state: LazyState::NoNode,\n-        type_shorthands: Default::default(),\n-        predicate_shorthands: Default::default()\n-    }.encode_crate_root();\n+            opaque: opaque::Encoder::new(&mut cursor),\n+            tcx: tcx,\n+            reexports: reexports,\n+            link_meta: link_meta,\n+            cstore: cstore,\n+            reachable: reachable,\n+            mir_map: mir_map,\n+            lazy_state: LazyState::NoNode,\n+            type_shorthands: Default::default(),\n+            predicate_shorthands: Default::default(),\n+        }\n+        .encode_crate_root();\n     let mut result = cursor.into_inner();\n \n     // Encode the root position.\n     let header = METADATA_HEADER.len();\n     let pos = root.position;\n     result[header + 0] = (pos >> 24) as u8;\n     result[header + 1] = (pos >> 16) as u8;\n-    result[header + 2] = (pos >>  8) as u8;\n-    result[header + 3] = (pos >>  0) as u8;\n+    result[header + 2] = (pos >> 8) as u8;\n+    result[header + 3] = (pos >> 0) as u8;\n \n     result\n }"}, {"sha": "53e6988c756c947d33dee83c6ab4c4bef33f1c42", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f4408347d2109803edbf53c89c8bce575de4b67/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4408347d2109803edbf53c89c8bce575de4b67/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=3f4408347d2109803edbf53c89c8bce575de4b67", "patch": "@@ -28,9 +28,7 @@ pub struct Index {\n \n impl Index {\n     pub fn new(max_index: usize) -> Index {\n-        Index {\n-            positions: vec![u32::MAX; max_index]\n-        }\n+        Index { positions: vec![u32::MAX; max_index] }\n     }\n \n     pub fn record(&mut self, def_id: DefId, entry: Lazy<Entry>) {\n@@ -46,7 +44,9 @@ impl Index {\n \n         assert!(self.positions[item] == u32::MAX,\n                 \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n-                item, self.positions[item], position);\n+                item,\n+                self.positions[item],\n+                position);\n \n         self.positions[item] = position.to_le();\n     }\n@@ -67,7 +67,8 @@ impl<'tcx> LazySeq<Index> {\n         let index = def_index.as_usize();\n \n         debug!(\"Index::lookup: index={:?} words.len={:?}\",\n-               index, words.len());\n+               index,\n+               words.len());\n \n         let position = u32::from_le(words[index]);\n         if position == u32::MAX {\n@@ -79,8 +80,9 @@ impl<'tcx> LazySeq<Index> {\n         }\n     }\n \n-    pub fn iter_enumerated<'a>(&self, bytes: &'a [u8])\n-                               -> impl Iterator<Item=(DefIndex, Lazy<Entry<'tcx>>)> + 'a {\n+    pub fn iter_enumerated<'a>(&self,\n+                               bytes: &'a [u8])\n+                               -> impl Iterator<Item = (DefIndex, Lazy<Entry<'tcx>>)> + 'a {\n         let words = &bytes_to_words(&bytes[self.position..])[..self.len];\n         words.iter().enumerate().filter_map(|(index, &position)| {\n             if position == u32::MAX {"}, {"sha": "9938e20d1861d83a799a39762ba8d3fa4983c8cd", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f4408347d2109803edbf53c89c8bce575de4b67/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4408347d2109803edbf53c89c8bce575de4b67/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=3f4408347d2109803edbf53c89c8bce575de4b67", "patch": "@@ -138,11 +138,11 @@ pub trait DepGraphRead {\n }\n \n impl DepGraphRead for DefId {\n-    fn read(&self, _tcx: TyCtxt) { }\n+    fn read(&self, _tcx: TyCtxt) {}\n }\n \n impl DepGraphRead for ast::NodeId {\n-    fn read(&self, _tcx: TyCtxt) { }\n+    fn read(&self, _tcx: TyCtxt) {}\n }\n \n impl<T> DepGraphRead for Option<T>\n@@ -179,8 +179,8 @@ macro_rules! read_tuple {\n         }\n     }\n }\n-read_tuple!(A,B);\n-read_tuple!(A,B,C);\n+read_tuple!(A, B);\n+read_tuple!(A, B, C);\n \n macro_rules! read_hir {\n     ($t:ty) => {\n@@ -208,7 +208,7 @@ read_hir!(hir::ForeignItem);\n pub struct Untracked<T>(pub T);\n \n impl<T> DepGraphRead for Untracked<T> {\n-    fn read(&self, _tcx: TyCtxt) { }\n+    fn read(&self, _tcx: TyCtxt) {}\n }\n \n /// Newtype that can be used to package up misc data extracted from a"}, {"sha": "ef81dbd7f29ec79975f4d34db7269721b53506fe", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f4408347d2109803edbf53c89c8bce575de4b67/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4408347d2109803edbf53c89c8bce575de4b67/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=3f4408347d2109803edbf53c89c8bce575de4b67", "patch": "@@ -30,8 +30,10 @@\n #![feature(specialization)]\n #![feature(staged_api)]\n \n-#[macro_use] extern crate log;\n-#[macro_use] extern crate syntax;\n+#[macro_use]\n+extern crate log;\n+#[macro_use]\n+extern crate syntax;\n extern crate syntax_pos;\n extern crate flate;\n extern crate serialize as rustc_serialize; // used by deriving"}, {"sha": "0461d7ec061d4010bb206f50ccc2367e8af8e7c0", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 164, "deletions": 125, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/3f4408347d2109803edbf53c89c8bce575de4b67/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4408347d2109803edbf53c89c8bce575de4b67/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=3f4408347d2109803edbf53c89c8bce575de4b67", "patch": "@@ -273,33 +273,33 @@ pub struct ArchiveMetadata {\n pub struct CratePaths {\n     pub ident: String,\n     pub dylib: Option<PathBuf>,\n-    pub rlib: Option<PathBuf>\n+    pub rlib: Option<PathBuf>,\n }\n \n pub const METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n \n #[derive(Copy, Clone, PartialEq)]\n enum CrateFlavor {\n     Rlib,\n-    Dylib\n+    Dylib,\n }\n \n impl fmt::Display for CrateFlavor {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(match *self {\n             CrateFlavor::Rlib => \"rlib\",\n-            CrateFlavor::Dylib => \"dylib\"\n+            CrateFlavor::Dylib => \"dylib\",\n         })\n     }\n }\n \n impl CratePaths {\n     fn paths(&self) -> Vec<PathBuf> {\n         match (&self.dylib, &self.rlib) {\n-            (&None,    &None)              => vec!(),\n+            (&None, &None) => vec![],\n             (&Some(ref p), &None) |\n-            (&None, &Some(ref p))          => vec!(p.clone()),\n-            (&Some(ref p1), &Some(ref p2)) => vec!(p1.clone(), p2.clone()),\n+            (&None, &Some(ref p)) => vec![p.clone()],\n+            (&Some(ref p1), &Some(ref p2)) => vec![p1.clone(), p2.clone()],\n         }\n     }\n }\n@@ -316,53 +316,72 @@ impl<'a> Context<'a> {\n     pub fn report_errs(&mut self) -> ! {\n         let add = match self.root {\n             &None => String::new(),\n-            &Some(ref r) => format!(\" which `{}` depends on\",\n-                                    r.ident)\n+            &Some(ref r) => format!(\" which `{}` depends on\", r.ident),\n         };\n         let mut err = if !self.rejected_via_hash.is_empty() {\n-            struct_span_err!(self.sess, self.span, E0460,\n+            struct_span_err!(self.sess,\n+                             self.span,\n+                             E0460,\n                              \"found possibly newer version of crate `{}`{}\",\n-                             self.ident, add)\n+                             self.ident,\n+                             add)\n         } else if !self.rejected_via_triple.is_empty() {\n-            struct_span_err!(self.sess, self.span, E0461,\n+            struct_span_err!(self.sess,\n+                             self.span,\n+                             E0461,\n                              \"couldn't find crate `{}` with expected target triple {}{}\",\n-                             self.ident, self.triple, add)\n+                             self.ident,\n+                             self.triple,\n+                             add)\n         } else if !self.rejected_via_kind.is_empty() {\n-            struct_span_err!(self.sess, self.span, E0462,\n+            struct_span_err!(self.sess,\n+                             self.span,\n+                             E0462,\n                              \"found staticlib `{}` instead of rlib or dylib{}\",\n-                             self.ident, add)\n+                             self.ident,\n+                             add)\n         } else if !self.rejected_via_version.is_empty() {\n-            struct_span_err!(self.sess, self.span, E0514,\n+            struct_span_err!(self.sess,\n+                             self.span,\n+                             E0514,\n                              \"found crate `{}` compiled by an incompatible version of rustc{}\",\n-                             self.ident, add)\n+                             self.ident,\n+                             add)\n         } else {\n-            let mut err = struct_span_err!(self.sess, self.span, E0463,\n+            let mut err = struct_span_err!(self.sess,\n+                                           self.span,\n+                                           E0463,\n                                            \"can't find crate for `{}`{}\",\n-                                           self.ident, add);\n+                                           self.ident,\n+                                           add);\n             err.span_label(self.span, &format!(\"can't find crate\"));\n             err\n         };\n \n         if !self.rejected_via_triple.is_empty() {\n             let mismatches = self.rejected_via_triple.iter();\n-            for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n+            for (i, &CrateMismatch { ref path, ref got }) in mismatches.enumerate() {\n                 err.note(&format!(\"crate `{}`, path #{}, triple {}: {}\",\n-                                  self.ident, i+1, got, path.display()));\n+                                  self.ident,\n+                                  i + 1,\n+                                  got,\n+                                  path.display()));\n             }\n         }\n         if !self.rejected_via_hash.is_empty() {\n             err.note(\"perhaps that crate needs to be recompiled?\");\n             let mismatches = self.rejected_via_hash.iter();\n-            for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n-                err.note(&format!(\"crate `{}` path #{}: {}\",\n-                                  self.ident, i+1, path.display()));\n+            for (i, &CrateMismatch { ref path, .. }) in mismatches.enumerate() {\n+                err.note(&format!(\"crate `{}` path #{}: {}\", self.ident, i + 1, path.display()));\n             }\n             match self.root {\n                 &None => {}\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n                         err.note(&format!(\"crate `{}` path #{}: {}\",\n-                                          r.ident, i+1, path.display()));\n+                                          r.ident,\n+                                          i + 1,\n+                                          path.display()));\n                     }\n                 }\n             }\n@@ -371,8 +390,7 @@ impl<'a> Context<'a> {\n             err.help(\"please recompile that crate using --crate-type lib\");\n             let mismatches = self.rejected_via_kind.iter();\n             for (i, &CrateMismatch { ref path, .. }) in mismatches.enumerate() {\n-                err.note(&format!(\"crate `{}` path #{}: {}\",\n-                                  self.ident, i+1, path.display()));\n+                err.note(&format!(\"crate `{}` path #{}: {}\", self.ident, i + 1, path.display()));\n             }\n         }\n         if !self.rejected_via_version.is_empty() {\n@@ -381,7 +399,10 @@ impl<'a> Context<'a> {\n             let mismatches = self.rejected_via_version.iter();\n             for (i, &CrateMismatch { ref path, ref got }) in mismatches.enumerate() {\n                 err.note(&format!(\"crate `{}` path #{}: {} compiled by {:?}\",\n-                                  self.ident, i+1, path.display(), got));\n+                                  self.ident,\n+                                  i + 1,\n+                                  path.display(),\n+                                  got));\n             }\n         }\n \n@@ -410,7 +431,7 @@ impl<'a> Context<'a> {\n         let staticlib_prefix = format!(\"{}{}\", staticpair.0, self.crate_name);\n \n         let mut candidates = FnvHashMap();\n-        let mut staticlibs = vec!();\n+        let mut staticlibs = vec![];\n \n         // First, find all possible candidate rlibs and dylibs purely based on\n         // the name of the files themselves. We're trying to match against an\n@@ -430,38 +451,36 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            let (hash, rlib) = if file.starts_with(&rlib_prefix[..]) &&\n-                                  file.ends_with(\".rlib\") {\n-                (&file[(rlib_prefix.len()) .. (file.len() - \".rlib\".len())],\n-                 true)\n+            let (hash, rlib) = if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rlib\") {\n+                (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], true)\n             } else if file.starts_with(&dylib_prefix) &&\n-                      file.ends_with(&dypair.1) {\n-                (&file[(dylib_prefix.len()) .. (file.len() - dypair.1.len())],\n-                 false)\n+                                         file.ends_with(&dypair.1) {\n+                (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], false)\n             } else {\n-                if file.starts_with(&staticlib_prefix[..]) &&\n-                   file.ends_with(&staticpair.1) {\n+                if file.starts_with(&staticlib_prefix[..]) && file.ends_with(&staticpair.1) {\n                     staticlibs.push(CrateMismatch {\n                         path: path.to_path_buf(),\n-                        got: \"static\".to_string()\n+                        got: \"static\".to_string(),\n                     });\n                 }\n-                return FileDoesntMatch\n+                return FileDoesntMatch;\n             };\n             info!(\"lib candidate: {}\", path.display());\n \n             let hash_str = hash.to_string();\n             let slot = candidates.entry(hash_str)\n-                                 .or_insert_with(|| (FnvHashMap(), FnvHashMap()));\n+                .or_insert_with(|| (FnvHashMap(), FnvHashMap()));\n             let (ref mut rlibs, ref mut dylibs) = *slot;\n-            fs::canonicalize(path).map(|p| {\n-                if rlib {\n-                    rlibs.insert(p, kind);\n-                } else {\n-                    dylibs.insert(p, kind);\n-                }\n-                FileMatches\n-            }).unwrap_or(FileDoesntMatch)\n+            fs::canonicalize(path)\n+                .map(|p| {\n+                    if rlib {\n+                        rlibs.insert(p, kind);\n+                    } else {\n+                        dylibs.insert(p, kind);\n+                    }\n+                    FileMatches\n+                })\n+                .unwrap_or(FileDoesntMatch)\n         });\n         self.rejected_via_kind.extend(staticlibs);\n \n@@ -479,11 +498,12 @@ impl<'a> Context<'a> {\n             let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n             let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n             if let Some((h, m)) = slot {\n-                libraries.insert(h, Library {\n-                    dylib: dylib,\n-                    rlib: rlib,\n-                    metadata: m,\n-                });\n+                libraries.insert(h,\n+                                 Library {\n+                                     dylib: dylib,\n+                                     rlib: rlib,\n+                                     metadata: m,\n+                                 });\n             }\n         }\n \n@@ -494,7 +514,9 @@ impl<'a> Context<'a> {\n             0 => None,\n             1 => Some(libraries.into_iter().next().unwrap().1),\n             _ => {\n-                let mut err = struct_span_err!(self.sess, self.span, E0464,\n+                let mut err = struct_span_err!(self.sess,\n+                                               self.span,\n+                                               E0464,\n                                                \"multiple matching crates for `{}`\",\n                                                self.crate_name);\n                 err.note(\"candidates:\");\n@@ -521,8 +543,11 @@ impl<'a> Context<'a> {\n     // read the metadata from it if `*slot` is `None`. If the metadata couldn't\n     // be read, it is assumed that the file isn't a valid rust library (no\n     // errors are emitted).\n-    fn extract_one(&mut self, m: FnvHashMap<PathBuf, PathKind>, flavor: CrateFlavor,\n-                   slot: &mut Option<(Svh, MetadataBlob)>) -> Option<(PathBuf, PathKind)> {\n+    fn extract_one(&mut self,\n+                   m: FnvHashMap<PathBuf, PathKind>,\n+                   flavor: CrateFlavor,\n+                   slot: &mut Option<(Svh, MetadataBlob)>)\n+                   -> Option<(PathBuf, PathKind)> {\n         let mut ret: Option<(PathBuf, PathKind)> = None;\n         let mut error = 0;\n \n@@ -532,9 +557,9 @@ impl<'a> Context<'a> {\n             //                read both, but reading dylib metadata is quite\n             //                slow.\n             if m.is_empty() {\n-                return None\n+                return None;\n             } else if m.len() == 1 {\n-                return Some(m.into_iter().next().unwrap())\n+                return Some(m.into_iter().next().unwrap());\n             }\n         }\n \n@@ -547,23 +572,28 @@ impl<'a> Context<'a> {\n                         (h, blob)\n                     } else {\n                         info!(\"metadata mismatch\");\n-                        continue\n+                        continue;\n                     }\n                 }\n                 Err(err) => {\n                     info!(\"no metadata found: {}\", err);\n-                    continue\n+                    continue;\n                 }\n             };\n             // If we see multiple hashes, emit an error about duplicate candidates.\n             if slot.as_ref().map_or(false, |s| s.0 != hash) {\n-                let mut e = struct_span_err!(self.sess, self.span, E0465,\n+                let mut e = struct_span_err!(self.sess,\n+                                             self.span,\n+                                             E0465,\n                                              \"multiple {} candidates for `{}` found\",\n-                                             flavor, self.crate_name);\n+                                             flavor,\n+                                             self.crate_name);\n                 e.span_note(self.span,\n                             &format!(r\"candidate #1: {}\",\n-                                     ret.as_ref().unwrap().0\n-                                        .display()));\n+                                     ret.as_ref()\n+                                         .unwrap()\n+                                         .0\n+                                         .display()));\n                 if let Some(ref mut e) = err {\n                     e.emit();\n                 }\n@@ -574,9 +604,10 @@ impl<'a> Context<'a> {\n             if error > 0 {\n                 error += 1;\n                 err.as_mut().unwrap().span_note(self.span,\n-                                                &format!(r\"candidate #{}: {}\", error,\n+                                                &format!(r\"candidate #{}: {}\",\n+                                                         error,\n                                                          lib.display()));\n-                continue\n+                continue;\n             }\n             *slot = Some((hash, metadata));\n             ret = Some((lib, kind));\n@@ -595,37 +626,39 @@ impl<'a> Context<'a> {\n         let rustc_version = rustc_version();\n         if root.rustc_version != rustc_version {\n             info!(\"Rejecting via version: expected {} got {}\",\n-                  rustc_version, root.rustc_version);\n+                  rustc_version,\n+                  root.rustc_version);\n             self.rejected_via_version.push(CrateMismatch {\n                 path: libpath.to_path_buf(),\n-                got: root.rustc_version\n+                got: root.rustc_version,\n             });\n             return None;\n         }\n \n         if self.should_match_name {\n             if self.crate_name != root.name {\n-                info!(\"Rejecting via crate name\"); return None;\n+                info!(\"Rejecting via crate name\");\n+                return None;\n             }\n         }\n \n         if root.triple != self.triple {\n             info!(\"Rejecting via crate triple: expected {} got {}\",\n-                  self.triple, root.triple);\n+                  self.triple,\n+                  root.triple);\n             self.rejected_via_triple.push(CrateMismatch {\n                 path: libpath.to_path_buf(),\n-                got: root.triple\n+                got: root.triple,\n             });\n             return None;\n         }\n \n         if let Some(myhash) = self.hash {\n             if *myhash != root.hash {\n-                info!(\"Rejecting via hash: expected {} got {}\",\n-                      *myhash, root.hash);\n+                info!(\"Rejecting via hash: expected {} got {}\", *myhash, root.hash);\n                 self.rejected_via_hash.push(CrateMismatch {\n                     path: libpath.to_path_buf(),\n-                    got: myhash.to_string()\n+                    got: myhash.to_string(),\n                 });\n                 return None;\n             }\n@@ -649,8 +682,8 @@ impl<'a> Context<'a> {\n         (t.options.staticlib_prefix.clone(), t.options.staticlib_suffix.clone())\n     }\n \n-    fn find_commandline_library<'b, LOCS> (&mut self, locs: LOCS) -> Option<Library>\n-        where LOCS: Iterator<Item=&'b String>\n+    fn find_commandline_library<'b, LOCS>(&mut self, locs: LOCS) -> Option<Library>\n+        where LOCS: Iterator<Item = &'b String>\n     {\n         // First, filter out all libraries that look suspicious. We only accept\n         // files which actually exist that have the correct naming scheme for\n@@ -663,30 +696,33 @@ impl<'a> Context<'a> {\n             let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n-                                     self.crate_name, loc.display()));\n+                                      self.crate_name,\n+                                      loc.display()));\n                     return false;\n                 }\n                 let file = match loc.file_name().and_then(|s| s.to_str()) {\n                     Some(file) => file,\n                     None => {\n                         sess.err(&format!(\"extern location for {} is not a file: {}\",\n-                                         self.crate_name, loc.display()));\n+                                          self.crate_name,\n+                                          loc.display()));\n                         return false;\n                     }\n                 };\n                 if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n-                    return true\n+                    return true;\n                 } else {\n                     let (ref prefix, ref suffix) = dylibname;\n-                    if file.starts_with(&prefix[..]) &&\n-                       file.ends_with(&suffix[..]) {\n-                        return true\n+                    if file.starts_with(&prefix[..]) && file.ends_with(&suffix[..]) {\n+                        return true;\n                     }\n                 }\n                 sess.struct_err(&format!(\"extern location for {} is of an unknown type: {}\",\n-                                         self.crate_name, loc.display()))\n+                                         self.crate_name,\n+                                         loc.display()))\n                     .help(&format!(\"file name should be lib*.rlib or {}*.{}\",\n-                                   dylibname.0, dylibname.1))\n+                                   dylibname.0,\n+                                   dylibname.1))\n                     .emit();\n                 false\n             });\n@@ -695,11 +731,9 @@ impl<'a> Context<'a> {\n             // there's at most one rlib and at most one dylib.\n             for loc in locs {\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n-                    rlibs.insert(fs::canonicalize(&loc).unwrap(),\n-                                 PathKind::ExternFlag);\n+                    rlibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 } else {\n-                    dylibs.insert(fs::canonicalize(&loc).unwrap(),\n-                                  PathKind::ExternFlag);\n+                    dylibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 }\n             }\n         };\n@@ -709,13 +743,17 @@ impl<'a> Context<'a> {\n         let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n         let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n \n-        if rlib.is_none() && dylib.is_none() { return None }\n+        if rlib.is_none() && dylib.is_none() {\n+            return None;\n+        }\n         match slot {\n-            Some((_, metadata)) => Some(Library {\n-                dylib: dylib,\n-                rlib: rlib,\n-                metadata: metadata,\n-            }),\n+            Some((_, metadata)) => {\n+                Some(Library {\n+                    dylib: dylib,\n+                    rlib: rlib,\n+                    metadata: metadata,\n+                })\n+            }\n             None => None,\n         }\n     }\n@@ -728,9 +766,9 @@ pub fn note_crate_name(err: &mut DiagnosticBuilder, name: &str) {\n impl ArchiveMetadata {\n     fn new(ar: ArchiveRO) -> Option<ArchiveMetadata> {\n         let data = {\n-            let section = ar.iter().filter_map(|s| s.ok()).find(|sect| {\n-                sect.name() == Some(METADATA_FILENAME)\n-            });\n+            let section = ar.iter()\n+                .filter_map(|s| s.ok())\n+                .find(|sect| sect.name() == Some(METADATA_FILENAME));\n             match section {\n                 Some(s) => s.data() as *const [u8],\n                 None => {\n@@ -746,12 +784,14 @@ impl ArchiveMetadata {\n         })\n     }\n \n-    pub fn as_slice<'a>(&'a self) -> &'a [u8] { unsafe { &*self.data } }\n+    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n+        unsafe { &*self.data }\n+    }\n }\n \n-fn verify_decompressed_encoding_version(blob: &MetadataBlob, filename: &Path)\n-                                        -> Result<(), String>\n-{\n+fn verify_decompressed_encoding_version(blob: &MetadataBlob,\n+                                        filename: &Path)\n+                                        -> Result<(), String> {\n     if !blob.is_compatible() {\n         Err((format!(\"incompatible metadata version found: '{}'\",\n                      filename.display())))\n@@ -761,16 +801,21 @@ fn verify_decompressed_encoding_version(blob: &MetadataBlob, filename: &Path)\n }\n \n // Just a small wrapper to time how long reading metadata takes.\n-fn get_metadata_section(target: &Target, flavor: CrateFlavor, filename: &Path)\n+fn get_metadata_section(target: &Target,\n+                        flavor: CrateFlavor,\n+                        filename: &Path)\n                         -> Result<MetadataBlob, String> {\n     let start = Instant::now();\n     let ret = get_metadata_section_imp(target, flavor, filename);\n-    info!(\"reading {:?} => {:?}\", filename.file_name().unwrap(),\n+    info!(\"reading {:?} => {:?}\",\n+          filename.file_name().unwrap(),\n           start.elapsed());\n-    return ret\n+    return ret;\n }\n \n-fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Path)\n+fn get_metadata_section_imp(target: &Target,\n+                            flavor: CrateFlavor,\n+                            filename: &Path)\n                             -> Result<MetadataBlob, String> {\n     if !filename.exists() {\n         return Err(format!(\"no such file: '{}'\", filename.display()));\n@@ -783,13 +828,11 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n             Some(ar) => ar,\n             None => {\n                 debug!(\"llvm didn't like `{}`\", filename.display());\n-                return Err(format!(\"failed to read rlib metadata: '{}'\",\n-                                   filename.display()));\n+                return Err(format!(\"failed to read rlib metadata: '{}'\", filename.display()));\n             }\n         };\n         return match ArchiveMetadata::new(archive).map(|ar| MetadataBlob::Archive(ar)) {\n-            None => Err(format!(\"failed to read rlib metadata: '{}'\",\n-                                filename.display())),\n+            None => Err(format!(\"failed to read rlib metadata: '{}'\", filename.display())),\n             Some(blob) => {\n                 verify_decompressed_encoding_version(&blob, filename)?;\n                 Ok(blob)\n@@ -800,31 +843,27 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n         let buf = common::path2cstr(filename);\n         let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n         if mb as isize == 0 {\n-            return Err(format!(\"error reading library: '{}'\",\n-                               filename.display()))\n+            return Err(format!(\"error reading library: '{}'\", filename.display()));\n         }\n         let of = match ObjectFile::new(mb) {\n             Some(of) => of,\n             _ => {\n-                return Err((format!(\"provided path not an object file: '{}'\",\n-                                    filename.display())))\n+                return Err((format!(\"provided path not an object file: '{}'\", filename.display())))\n             }\n         };\n         let si = mk_section_iter(of.llof);\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let mut name_buf = ptr::null();\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = slice::from_raw_parts(name_buf as *const u8,\n-                                             name_len as usize).to_vec();\n+            let name = slice::from_raw_parts(name_buf as *const u8, name_len as usize).to_vec();\n             let name = String::from_utf8(name).unwrap();\n             debug!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(target) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n                 let cvbuf: *const u8 = cbuf as *const u8;\n                 let vlen = METADATA_HEADER.len();\n-                debug!(\"checking {} bytes of metadata-version stamp\",\n-                       vlen);\n+                debug!(\"checking {} bytes of metadata-version stamp\", vlen);\n                 let minsz = cmp::min(vlen, csz);\n                 let buf0 = slice::from_raw_parts(cvbuf, minsz);\n                 let version_ok = buf0 == METADATA_HEADER;\n@@ -834,8 +873,7 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n                 }\n \n                 let cvbuf1 = cvbuf.offset(vlen as isize);\n-                debug!(\"inflating {} bytes of compressed metadata\",\n-                       csz - vlen);\n+                debug!(\"inflating {} bytes of compressed metadata\", csz - vlen);\n                 let bytes = slice::from_raw_parts(cvbuf1, csz - vlen);\n                 match flate::inflate_bytes(bytes) {\n                     Ok(inflated) => {\n@@ -879,14 +917,15 @@ pub fn read_meta_section_name(_target: &Target) -> &'static str {\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-pub fn list_file_metadata(target: &Target, path: &Path,\n-                          out: &mut io::Write) -> io::Result<()> {\n+pub fn list_file_metadata(target: &Target, path: &Path, out: &mut io::Write) -> io::Result<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n-    let flavor = if filename.ends_with(\".rlib\") { CrateFlavor::Rlib } else { CrateFlavor::Dylib };\n+    let flavor = if filename.ends_with(\".rlib\") {\n+        CrateFlavor::Rlib\n+    } else {\n+        CrateFlavor::Dylib\n+    };\n     match get_metadata_section(target, flavor, path) {\n         Ok(metadata) => metadata.list_crate_metadata(out),\n-        Err(msg) => {\n-            write!(out, \"{}\\n\", msg)\n-        }\n+        Err(msg) => write!(out, \"{}\\n\", msg),\n     }\n }"}, {"sha": "4174a2ef47d335f732809f75fcd387ffbd4a274e", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3f4408347d2109803edbf53c89c8bce575de4b67/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4408347d2109803edbf53c89c8bce575de4b67/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=3f4408347d2109803edbf53c89c8bce575de4b67", "patch": "@@ -27,7 +27,8 @@ use syntax_pos::{self, Span};\n use std::marker::PhantomData;\n \n pub fn rustc_version() -> String {\n-    format!(\"rustc {}\", option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n+    format!(\"rustc {}\",\n+            option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n }\n \n /// Metadata encoding version.\n@@ -41,11 +42,8 @@ pub const METADATA_VERSION: u8 = 3;\n /// as a length of 0 by old compilers.\n ///\n /// This header is followed by the position of the `CrateRoot`.\n-pub const METADATA_HEADER: &'static [u8; 12] = &[\n-    0, 0, 0, 0,\n-    b'r', b'u', b's', b't',\n-    0, 0, 0, METADATA_VERSION\n-];\n+pub const METADATA_HEADER: &'static [u8; 12] =\n+    &[0, 0, 0, 0, b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n /// The shorthand encoding uses an enum's variant index `usize`\n /// and is offset by this value so it never matches a real variant.\n@@ -70,14 +68,14 @@ pub const SHORTHAND_OFFSET: usize = 0x80;\n #[must_use]\n pub struct Lazy<T> {\n     pub position: usize,\n-    _marker: PhantomData<T>\n+    _marker: PhantomData<T>,\n }\n \n impl<T> Lazy<T> {\n     pub fn with_position(position: usize) -> Lazy<T> {\n         Lazy {\n             position: position,\n-            _marker: PhantomData\n+            _marker: PhantomData,\n         }\n     }\n \n@@ -90,7 +88,9 @@ impl<T> Lazy<T> {\n \n impl<T> Copy for Lazy<T> {}\n impl<T> Clone for Lazy<T> {\n-    fn clone(&self) -> Self { *self }\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n }\n \n impl<T> serialize::UseSpecializedEncodable for Lazy<T> {}\n@@ -112,7 +112,7 @@ impl<T> serialize::UseSpecializedDecodable for Lazy<T> {}\n pub struct LazySeq<T> {\n     pub len: usize,\n     pub position: usize,\n-    _marker: PhantomData<T>\n+    _marker: PhantomData<T>,\n }\n \n impl<T> LazySeq<T> {\n@@ -124,7 +124,7 @@ impl<T> LazySeq<T> {\n         LazySeq {\n             len: len,\n             position: position,\n-            _marker: PhantomData\n+            _marker: PhantomData,\n         }\n     }\n \n@@ -136,7 +136,9 @@ impl<T> LazySeq<T> {\n \n impl<T> Copy for LazySeq<T> {}\n impl<T> Clone for LazySeq<T> {\n-    fn clone(&self) -> Self { *self }\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n }\n \n impl<T> serialize::UseSpecializedEncodable for LazySeq<T> {}\n@@ -155,7 +157,7 @@ pub enum LazyState {\n     /// Inside a metadata node, with a previous `Lazy` or `LazySeq`.\n     /// The position is a conservative estimate of where that\n     /// previous `Lazy` / `LazySeq` would end (see their comments).\n-    Previous(usize)\n+    Previous(usize),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -185,21 +187,21 @@ pub struct CrateRoot {\n pub struct CrateDep {\n     pub name: ast::Name,\n     pub hash: hir::svh::Svh,\n-    pub explicitly_linked: bool\n+    pub explicitly_linked: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitImpls {\n     pub trait_id: (u32, DefIndex),\n-    pub impls: LazySeq<DefIndex>\n+    pub impls: LazySeq<DefIndex>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct MacroDef {\n     pub name: ast::Name,\n     pub attrs: Vec<ast::Attribute>,\n     pub span: Span,\n-    pub body: String\n+    pub body: String,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -219,7 +221,7 @@ pub struct Entry<'tcx> {\n     pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     pub ast: Option<Lazy<astencode::Ast<'tcx>>>,\n-    pub mir: Option<Lazy<mir::repr::Mir<'tcx>>>\n+    pub mir: Option<Lazy<mir::repr::Mir<'tcx>>>,\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n@@ -245,18 +247,18 @@ pub enum EntryKind<'tcx> {\n     DefaultImpl(Lazy<ImplData<'tcx>>),\n     Method(Lazy<MethodData<'tcx>>),\n     AssociatedType(AssociatedContainer),\n-    AssociatedConst(AssociatedContainer)\n+    AssociatedConst(AssociatedContainer),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ModData {\n-    pub reexports: LazySeq<def::Export>\n+    pub reexports: LazySeq<def::Export>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData {\n     pub constness: hir::Constness,\n-    pub arg_names: LazySeq<ast::Name>\n+    pub arg_names: LazySeq<ast::Name>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -266,7 +268,7 @@ pub struct VariantData {\n \n     /// If this is a struct's only variant, this\n     /// is the index of the \"struct ctor\" item.\n-    pub struct_ctor: Option<DefIndex>\n+    pub struct_ctor: Option<DefIndex>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -275,15 +277,15 @@ pub struct TraitData<'tcx> {\n     pub paren_sugar: bool,\n     pub has_default_impl: bool,\n     pub trait_ref: Lazy<ty::TraitRef<'tcx>>,\n-    pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>\n+    pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ImplData<'tcx> {\n     pub polarity: hir::ImplPolarity,\n     pub parent_impl: Option<DefId>,\n     pub coerce_unsized_kind: Option<ty::adjustment::CustomCoerceUnsized>,\n-    pub trait_ref: Option<Lazy<ty::TraitRef<'tcx>>>\n+    pub trait_ref: Option<Lazy<ty::TraitRef<'tcx>>>,\n }\n \n /// Describes whether the container of an associated item\n@@ -294,21 +296,17 @@ pub enum AssociatedContainer {\n     TraitRequired,\n     TraitWithDefault,\n     ImplDefault,\n-    ImplFinal\n+    ImplFinal,\n }\n \n impl AssociatedContainer {\n     pub fn with_def_id(&self, def_id: DefId) -> ty::ImplOrTraitItemContainer {\n         match *self {\n             AssociatedContainer::TraitRequired |\n-            AssociatedContainer::TraitWithDefault => {\n-                ty::TraitContainer(def_id)\n-            }\n+            AssociatedContainer::TraitWithDefault => ty::TraitContainer(def_id),\n \n             AssociatedContainer::ImplDefault |\n-            AssociatedContainer::ImplFinal => {\n-                ty::ImplContainer(def_id)\n-            }\n+            AssociatedContainer::ImplFinal => ty::ImplContainer(def_id),\n         }\n     }\n \n@@ -318,7 +316,7 @@ impl AssociatedContainer {\n \n             AssociatedContainer::TraitWithDefault |\n             AssociatedContainer::ImplDefault |\n-            AssociatedContainer::ImplFinal => true\n+            AssociatedContainer::ImplFinal => true,\n         }\n     }\n \n@@ -328,7 +326,7 @@ impl AssociatedContainer {\n             AssociatedContainer::TraitWithDefault |\n             AssociatedContainer::ImplDefault => hir::Defaultness::Default,\n \n-            AssociatedContainer::ImplFinal => hir::Defaultness::Final\n+            AssociatedContainer::ImplFinal => hir::Defaultness::Final,\n         }\n     }\n }\n@@ -337,11 +335,11 @@ impl AssociatedContainer {\n pub struct MethodData<'tcx> {\n     pub fn_data: FnData,\n     pub container: AssociatedContainer,\n-    pub explicit_self: Lazy<ty::ExplicitSelfCategory<'tcx>>\n+    pub explicit_self: Lazy<ty::ExplicitSelfCategory<'tcx>>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ClosureData<'tcx> {\n     pub kind: ty::ClosureKind,\n-    pub ty: Lazy<ty::ClosureTy<'tcx>>\n+    pub ty: Lazy<ty::ClosureTy<'tcx>>,\n }"}]}