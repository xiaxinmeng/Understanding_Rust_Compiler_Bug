{"sha": "c2024306874475b649f28145c75e124a247ee113", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMDI0MzA2ODc0NDc1YjY0OWYyODE0NWM3NWUxMjRhMjQ3ZWUxMTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-20T10:18:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-20T10:18:45Z"}, "message": "auto merge of #5435 : nikomatsakis/rust/issue-4846-refactor-self_info, r=nikomatsakis\n\nRefactor the self-info so that the def-id is carried in ty_self()and the fn_ctxt doesn't need any self_info field at all. Pull out explicit self transformation into `check_method`. Step towards fixing `fn(&self)` to have a distinct lifetime. (cc #4846) \r\n\r\nr? @catamorphism", "tree": {"sha": "256a5a9a391fe8a717bda0532b5d1405a99c284f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/256a5a9a391fe8a717bda0532b5d1405a99c284f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2024306874475b649f28145c75e124a247ee113", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2024306874475b649f28145c75e124a247ee113", "html_url": "https://github.com/rust-lang/rust/commit/c2024306874475b649f28145c75e124a247ee113", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2024306874475b649f28145c75e124a247ee113/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db4dc1ffe29045361c34abab8d810d2c717b82e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/db4dc1ffe29045361c34abab8d810d2c717b82e0", "html_url": "https://github.com/rust-lang/rust/commit/db4dc1ffe29045361c34abab8d810d2c717b82e0"}, {"sha": "ad70c748c35958f8afdc70cf67054dd1968e4b78", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad70c748c35958f8afdc70cf67054dd1968e4b78", "html_url": "https://github.com/rust-lang/rust/commit/ad70c748c35958f8afdc70cf67054dd1968e4b78"}], "stats": {"total": 139, "additions": 53, "deletions": 86}, "files": [{"sha": "f12cc140d8ab9d7713876e050d14b580cb876e95", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=c2024306874475b649f28145c75e124a247ee113", "patch": "@@ -289,7 +289,8 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n         return ty::mk_param(st.tcx, parse_int(st) as uint, did);\n       }\n       's' => {\n-        return ty::mk_self(st.tcx);\n+        let did = parse_def(st, TypeParameter, conv);\n+        return ty::mk_self(st.tcx, did);\n       }\n       '@' => return ty::mk_box(st.tcx, parse_mt(st, conv)),\n       '~' => return ty::mk_uniq(st.tcx, parse_mt(st, conv)),"}, {"sha": "880d01d1cdb506d87b306f1f45e644b4eea1bf95", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=c2024306874475b649f28145c75e124a247ee113", "patch": "@@ -312,8 +312,10 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, +st: ty::sty) {\n         w.write_char('|');\n         w.write_str(uint::to_str(id));\n       }\n-      ty::ty_self => {\n+      ty::ty_self(did) => {\n         w.write_char('s');\n+        w.write_str((cx.ds)(did));\n+        w.write_char('|');\n       }\n       ty::ty_type => w.write_char('Y'),\n       ty::ty_opaque_closure_ptr(p) => {"}, {"sha": "41e63cc878e13fd54a5b1b640f4ea94f7c6ca2aa", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=c2024306874475b649f28145c75e124a247ee113", "patch": "@@ -297,7 +297,7 @@ pub impl Reflector {\n               let extra = ~[self.c_uint(p.idx)];\n               self.visit(~\"param\", extra)\n           }\n-          ty::ty_self => self.leaf(~\"self\"),\n+          ty::ty_self(*) => self.leaf(~\"self\"),\n           ty::ty_type => self.leaf(~\"type\"),\n           ty::ty_opaque_box => self.leaf(~\"opaque_box\"),\n           ty::ty_opaque_closure_ptr(ck) => {"}, {"sha": "a7bec5547c4a3d494f1dc1a9893e84c1566ddcb4", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=c2024306874475b649f28145c75e124a247ee113", "patch": "@@ -144,7 +144,7 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n             T_struct(adt::sizing_fields_of(cx, repr))\n         }\n \n-        ty::ty_self | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n+        ty::ty_self(_) | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n             cx.tcx.sess.bug(\n                 fmt!(\"fictitious type %? in sizing_type_of()\",\n                      ty::get(t).sty))\n@@ -251,7 +251,7 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n                                               did,\n                                               /*bad*/ copy substs.tps))\n       }\n-      ty::ty_self => cx.tcx.sess.unimpl(~\"type_of: ty_self\"),\n+      ty::ty_self(*) => cx.tcx.sess.unimpl(~\"type_of: ty_self\"),\n       ty::ty_infer(*) => cx.tcx.sess.bug(~\"type_of with ty_infer\"),\n       ty::ty_param(*) => cx.tcx.sess.bug(~\"type_of with ty_param\"),\n       ty::ty_err(*) => cx.tcx.sess.bug(~\"type_of with ty_err\")"}, {"sha": "e50fd7b10cc4dc4901a06000e235d42caf2d2ba0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c2024306874475b649f28145c75e124a247ee113", "patch": "@@ -522,7 +522,8 @@ pub enum sty {\n     ty_tup(~[t]),\n \n     ty_param(param_ty), // type parameter\n-    ty_self, // special, implicit `self` type parameter\n+    ty_self(def_id), /* special, implicit `self` type parameter;\n+                      * def_id is the id of the trait */\n \n     ty_infer(InferTy), // something used only during inference/typeck\n     ty_err, // Also only used during inference/typeck, to represent\n@@ -897,7 +898,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n       &ty_err => flags |= has_ty_err as uint,\n       &ty_param(_) => flags |= has_params as uint,\n       &ty_infer(_) => flags |= needs_infer as uint,\n-      &ty_self => flags |= has_self as uint,\n+      &ty_self(_) => flags |= has_self as uint,\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) |\n       &ty_trait(_, ref substs, _) => {\n         flags |= sflags(substs);\n@@ -1082,7 +1083,7 @@ pub fn mk_float_var(cx: ctxt, v: FloatVid) -> t { mk_infer(cx, FloatVar(v)) }\n \n pub fn mk_infer(cx: ctxt, +it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n \n-pub fn mk_self(cx: ctxt) -> t { mk_t(cx, ty_self) }\n+pub fn mk_self(cx: ctxt, did: ast::def_id) -> t { mk_t(cx, ty_self(did)) }\n \n pub fn mk_param(cx: ctxt, n: uint, k: def_id) -> t {\n     mk_t(cx, ty_param(param_ty { idx: n, def_id: k }))\n@@ -1163,7 +1164,7 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n     if !f(ty) { return; }\n     match get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_estr(_) | ty_type | ty_opaque_box | ty_self |\n+      ty_estr(_) | ty_type | ty_opaque_box | ty_self(_) |\n       ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) | ty_err => {\n       }\n       ty_box(ref tm) | ty_evec(ref tm, _) | ty_unboxed_vec(ref tm) |\n@@ -1250,7 +1251,7 @@ fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n         }\n         ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n         ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) | ty_err |\n-        ty_opaque_box | ty_infer(_) | ty_param(*) | ty_self => {\n+        ty_opaque_box | ty_infer(_) | ty_param(*) | ty_self(_) => {\n             /*bad*/copy *sty\n         }\n     }\n@@ -1362,7 +1363,7 @@ pub fn subst_tps(cx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n     if self_ty_opt.is_none() && !tbox_has_flag(tb, has_params) { return typ; }\n     match tb.sty {\n         ty_param(p) => tps[p.idx],\n-        ty_self => {\n+        ty_self(_) => {\n             match self_ty_opt {\n                 None => cx.sess.bug(~\"ty_self unexpected here\"),\n                 Some(self_ty) => {\n@@ -1424,7 +1425,7 @@ pub fn subst(cx: ctxt,\n         if !tbox_has_flag(tb, needs_subst) { return typ; }\n         match tb.sty {\n           ty_param(p) => substs.tps[p.idx],\n-          ty_self => substs.self_ty.get(),\n+          ty_self(_) => substs.self_ty.get(),\n           _ => {\n             fold_regions_and_ty(\n                 cx, typ,\n@@ -2002,7 +2003,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                     cx, cx.ty_param_bounds.get(&p.def_id.node))\n             }\n \n-            ty_self => {\n+            ty_self(_) => {\n                 // Currently, self is not bounded, so we must assume the\n                 // worst.  But in the future we should examine the super\n                 // traits.\n@@ -2159,7 +2160,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                     v.args.foldl(0, |s, a| *s + type_size(cx, *a))))\n           }\n \n-          ty_param(_) | ty_self => {\n+          ty_param(_) | ty_self(_) => {\n             1\n           }\n \n@@ -2220,7 +2221,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           ty_infer(_) |\n           ty_err |\n           ty_param(_) |\n-          ty_self |\n+          ty_self(_) |\n           ty_type |\n           ty_opaque_box |\n           ty_opaque_closure_ptr(_) |\n@@ -2655,7 +2656,7 @@ impl to_bytes::IterBytes for sty {\n           ty_bare_fn(ref ft) =>\n           to_bytes::iter_bytes_2(&12u8, ft, lsb0, f),\n \n-          ty_self => 13u8.iter_bytes(lsb0, f),\n+          ty_self(ref did) => to_bytes::iter_bytes_2(&13u8, did, lsb0, f),\n \n           ty_infer(ref v) =>\n           to_bytes::iter_bytes_2(&14u8, v, lsb0, f),\n@@ -3341,7 +3342,7 @@ pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_infer(IntVar(_)) => ~\"integral variable\",\n       ty_infer(FloatVar(_)) => ~\"floating-point variable\",\n       ty_param(_) => ~\"type parameter\",\n-      ty_self => ~\"self\",\n+      ty_self(_) => ~\"self\",\n       ty_err => ~\"type error\"\n     }\n }"}, {"sha": "e259fdaf400e4e4607b1ffb5bf56c7e391bf1076", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=c2024306874475b649f28145c75e124a247ee113", "patch": "@@ -64,7 +64,7 @@ use middle::typeck::{CrateCtxt, write_substs_to_tcx, write_ty_to_tcx};\n \n use core::result;\n use core::vec;\n-use syntax::ast;\n+use syntax::{ast, ast_util};\n use syntax::codemap::span;\n use syntax::print::pprust::{lifetime_to_str, path_to_str};\n use syntax::parse::token::special_idents;\n@@ -400,12 +400,13 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n             ty::mk_param(tcx, n, id)\n           }\n-          ast::def_self_ty(_) => {\n+          ast::def_self_ty(id) => {\n             // n.b.: resolve guarantees that the self type only appears in a\n             // trait, which we rely upon in various places when creating\n             // substs\n             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-            ty::mk_self(tcx)\n+            let did = ast_util::local_def(id);\n+            ty::mk_self(tcx, did)\n           }\n           _ => {\n             tcx.sess.span_fatal(ast_ty.span,"}, {"sha": "cb626dc85e0ae290ebe8e21303e5d8e7a00f2b51", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=c2024306874475b649f28145c75e124a247ee113", "patch": "@@ -307,12 +307,9 @@ pub impl LookupContext/&self {\n                         self_ty, did, substs, store);\n                     self.push_inherent_impl_candidates_for_type(did);\n                 }\n-                ty_self => {\n+                ty_self(self_did) => {\n                     // Call is of the form \"self.foo()\" and appears in one\n                     // of a trait's default method implementations.\n-                    let self_did = self.fcx.self_info.expect(\n-                        ~\"self_impl_def_id is undefined (`self` may not \\\n-                          be in scope here\").def_id;\n                     let substs = substs {\n                         self_r: None,\n                         self_ty: None,\n@@ -932,7 +929,7 @@ pub impl LookupContext/&self {\n             ty_bare_fn(*) | ty_box(*) | ty_uniq(*) | ty_rptr(*) |\n             ty_infer(IntVar(_)) |\n             ty_infer(FloatVar(_)) |\n-            ty_self | ty_param(*) | ty_nil | ty_bot | ty_bool |\n+            ty_self(_) | ty_param(*) | ty_nil | ty_bot | ty_bool |\n             ty_int(*) | ty_uint(*) |\n             ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_struct(*) | ty_tup(*) |\n             ty_estr(*) | ty_evec(*) | ty_trait(*) | ty_closure(*) => {"}, {"sha": "472e042d128412353c94187812b4785a2fabd64a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 44, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c2024306874475b649f28145c75e124a247ee113", "patch": "@@ -144,8 +144,7 @@ pub mod method;\n pub struct SelfInfo {\n     self_ty: ty::t,\n     self_id: ast::node_id,\n-    def_id: ast::def_id,\n-    explicit_self: ast::self_ty\n+    span: span\n }\n \n /// Fields that are part of a `FnCtxt` which are inherited by\n@@ -183,9 +182,6 @@ pub struct FnCtxt {\n     // with any nested functions that capture the environment\n     // (and with any functions whose environment is being captured).\n \n-    // Refers to whichever `self` is in scope, even this FnCtxt is\n-    // for a nested closure that captures `self`\n-    self_info: Option<SelfInfo>,\n     ret_ty: ty::t,\n     // Used by loop bodies that return from the outer function\n     indirect_ret_ty: Option<ty::t>,\n@@ -236,7 +232,6 @@ pub fn blank_fn_ctxt(ccx: @mut CrateCtxt,\n // It's kind of a kludge to manufacture a fake function context\n // and statement context, but we might as well do write the code only once\n     @mut FnCtxt {\n-        self_info: None,\n         ret_ty: rty,\n         indirect_ret_ty: None,\n         purity: ast::pure_fn,\n@@ -332,7 +327,6 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         };\n \n         @mut FnCtxt {\n-            self_info: self_info,\n             ret_ty: ret_ty,\n             indirect_ret_ty: indirect_ret_ty,\n             purity: purity,\n@@ -344,25 +338,6 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         }\n     };\n \n-    // Update the SelfInfo to contain an accurate self type (taking\n-    // into account explicit self).\n-    let self_info = do self_info.chain_ref |self_info| {\n-        // If the self type is sty_static, we don't have a self ty.\n-        if self_info.explicit_self.node == ast::sty_static {\n-            None\n-        } else  {\n-            let in_scope_regions = fcx.in_scope_regions;\n-            let self_region = in_scope_regions.find(ty::br_self);\n-            let ty = method::transform_self_type_for_method(\n-                fcx.tcx(),\n-                self_region,\n-                self_info.self_ty,\n-                self_info.explicit_self.node,\n-                TransformTypeNormally);\n-            Some(SelfInfo { self_ty: ty,.. *self_info })\n-        }\n-    };\n-\n     gather_locals(fcx, decl, body, arg_tys, self_info);\n     check_block(fcx, body);\n \n@@ -500,20 +475,25 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n \n pub fn check_method(ccx: @mut CrateCtxt,\n                     method: @ast::method,\n-                    self_ty: ty::t,\n-                    self_impl_def_id: ast::def_id) {\n-    let self_info = SelfInfo {\n-        self_ty: self_ty,\n-        self_id: method.self_id,\n-        def_id: self_impl_def_id,\n-        explicit_self: method.self_ty\n+                    self_ty: ty::t)\n+{\n+    let self_info = if method.self_ty.node == ast::sty_static {None} else {\n+        let ty = method::transform_self_type_for_method(\n+            ccx.tcx,\n+            Some(ty::re_bound(ty::br_self)),\n+            self_ty,\n+            method.self_ty.node,\n+            TransformTypeNormally);\n+        Some(SelfInfo {self_ty: ty, self_id: method.self_id,\n+                       span: method.self_ty.span})\n     };\n+\n     check_bare_fn(\n         ccx,\n         &method.decl,\n         &method.body,\n         method.id,\n-        Some(self_info)\n+        self_info\n     );\n }\n \n@@ -550,11 +530,7 @@ pub fn check_struct(ccx: @mut CrateCtxt,\n         let class_t = SelfInfo {\n             self_ty: self_ty,\n             self_id: dtor.node.self_id,\n-            def_id: local_def(id),\n-            explicit_self: spanned {\n-                node: ast::sty_by_ref,\n-                span: codemap::dummy_sp()\n-            }\n+            span: dtor.span,\n         };\n         // typecheck the dtor\n         let dtor_dec = ast_util::dtor_dec();\n@@ -594,7 +570,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n                *ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         let self_ty = ccx.to_ty(&rscope::type_rscope(rp), ty);\n         for ms.each |m| {\n-            check_method(ccx, *m, self_ty, local_def(it.id));\n+            check_method(ccx, *m, self_ty);\n         }\n       }\n       ast::item_trait(_, _, ref trait_methods) => {\n@@ -605,7 +581,8 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n                 // bodies to check.\n               }\n               provided(m) => {\n-                check_method(ccx, m, ty::mk_self(ccx.tcx), local_def(it.id));\n+                let self_ty = ty::mk_self(ccx.tcx, local_def(it.id));\n+                check_method(ccx, m, self_ty);\n               }\n             }\n         }\n@@ -1699,9 +1676,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             ty::determine_inherited_purity(copy fcx.purity, purity,\n                                            fn_ty.sigil);\n \n-        // We inherit the same self info as the enclosing scope,\n-        // since the function we're checking might capture `self`\n-        check_fn(fcx.ccx, fcx.self_info, inherited_purity,\n+        check_fn(fcx.ccx, None, inherited_purity,\n                  &fn_ty.sig, decl, body, fn_kind,\n                  fcx.in_scope_regions, fcx.inh);\n     }"}, {"sha": "c78a91b95e4bb74ed06120ca988d11337eef01a5", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=c2024306874475b649f28145c75e124a247ee113", "patch": "@@ -40,18 +40,8 @@ pub fn replace_bound_regions_in_fn_sig(\n \n     let mut all_tys = ty::tys_in_fn_sig(fn_sig);\n \n-    match self_info {\n-      Some(SelfInfo {\n-            explicit_self: codemap::spanned {\n-                node: ast::sty_region(_, m),\n-                // FIXME(#4846) ------^ Use this lifetime instead of self\n-                _}, _}) => {\n-        let region = ty::re_bound(ty::br_self);\n-        let ty = ty::mk_rptr(tcx, region,\n-                             ty::mt { ty: ty::mk_self(tcx), mutbl: m });\n-        all_tys.push(ty);\n-      }\n-      _ => {}\n+    for self_info.each |self_info| {\n+        all_tys.push(self_info.self_ty);\n     }\n \n     for self_ty.each |t| { all_tys.push(*t) }"}, {"sha": "18f232379169f6bacf7c03aa1874e670d087b76b", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=c2024306874475b649f28145c75e124a247ee113", "patch": "@@ -283,8 +283,8 @@ pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n     let visit = mk_visitor();\n     (visit.visit_block)(blk, wbcx, visit);\n     for self_info.each |self_info| {\n-        if self_info.explicit_self.node == ast::sty_static { break; }\n-        resolve_type_vars_for_node(wbcx, self_info.explicit_self.span,\n+        resolve_type_vars_for_node(wbcx,\n+                                   self_info.span,\n                                    self_info.self_id);\n     }\n     for decl.inputs.each |arg| {"}, {"sha": "d4bf95bb8bba03f985fc57f51379a8ea8678819d", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=c2024306874475b649f28145c75e124a247ee113", "patch": "@@ -94,7 +94,7 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n \n         ty_nil | ty_bot | ty_bool | ty_int(*) | ty_uint(*) | ty_float(*) |\n         ty_estr(*) | ty_evec(*) | ty_bare_fn(*) | ty_closure(*) | ty_tup(*) |\n-        ty_infer(*) | ty_param(*) | ty_self | ty_type | ty_opaque_box |\n+        ty_infer(*) | ty_param(*) | ty_self(*) | ty_type | ty_opaque_box |\n         ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) | ty_err | ty_box(_) |\n         ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {\n             debug!(\"(getting base type) no base type; found %?\","}, {"sha": "c332d3ac6744dc04936ae2c5e148d0070a3e0f88", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2024306874475b649f28145c75e124a247ee113/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c2024306874475b649f28145c75e124a247ee113", "patch": "@@ -443,7 +443,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                    str::from_bytes(~[('a' as u8) + (id as u8)]))\n           }\n       }\n-      ty_self => ~\"self\",\n+      ty_self(*) => ~\"self\",\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path, cx.sess.intr());"}, {"sha": "22ec88cd45625fe3baa031054aaa910b12e18c3a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2024306874475b649f28145c75e124a247ee113/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2024306874475b649f28145c75e124a247ee113/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c2024306874475b649f28145c75e124a247ee113", "patch": "@@ -185,7 +185,7 @@ pub enum def {\n                       /* trait */  Option<def_id>,\n                       purity),\n     def_self(node_id, bool /* is_implicit */),\n-    def_self_ty(node_id),\n+    def_self_ty(/* trait id */ node_id),\n     def_mod(def_id),\n     def_foreign_mod(def_id),\n     def_const(def_id),"}]}