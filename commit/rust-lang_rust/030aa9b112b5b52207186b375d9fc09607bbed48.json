{"sha": "030aa9b112b5b52207186b375d9fc09607bbed48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMGFhOWIxMTJiNWI1MjIwNzE4NmIzNzVkOWZjMDk2MDdiYmVkNDg=", "commit": {"author": {"name": "Michael Lamparski", "email": "diagonaldevice@gmail.com", "date": "2018-04-30T11:37:29Z"}, "committer": {"name": "Michael Lamparski", "email": "diagonaldevice@gmail.com", "date": "2018-04-30T15:53:51Z"}, "message": "revise macro in slice tests", "tree": {"sha": "ed935eca4d42c66999a084659023cd79e31ebf31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed935eca4d42c66999a084659023cd79e31ebf31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/030aa9b112b5b52207186b375d9fc09607bbed48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/030aa9b112b5b52207186b375d9fc09607bbed48", "html_url": "https://github.com/rust-lang/rust/commit/030aa9b112b5b52207186b375d9fc09607bbed48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/030aa9b112b5b52207186b375d9fc09607bbed48/comments", "author": {"login": "ExpHP", "id": 1411280, "node_id": "MDQ6VXNlcjE0MTEyODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1411280?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ExpHP", "html_url": "https://github.com/ExpHP", "followers_url": "https://api.github.com/users/ExpHP/followers", "following_url": "https://api.github.com/users/ExpHP/following{/other_user}", "gists_url": "https://api.github.com/users/ExpHP/gists{/gist_id}", "starred_url": "https://api.github.com/users/ExpHP/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ExpHP/subscriptions", "organizations_url": "https://api.github.com/users/ExpHP/orgs", "repos_url": "https://api.github.com/users/ExpHP/repos", "events_url": "https://api.github.com/users/ExpHP/events{/privacy}", "received_events_url": "https://api.github.com/users/ExpHP/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ExpHP", "id": 1411280, "node_id": "MDQ6VXNlcjE0MTEyODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1411280?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ExpHP", "html_url": "https://github.com/ExpHP", "followers_url": "https://api.github.com/users/ExpHP/followers", "following_url": "https://api.github.com/users/ExpHP/following{/other_user}", "gists_url": "https://api.github.com/users/ExpHP/gists{/gist_id}", "starred_url": "https://api.github.com/users/ExpHP/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ExpHP/subscriptions", "organizations_url": "https://api.github.com/users/ExpHP/orgs", "repos_url": "https://api.github.com/users/ExpHP/repos", "events_url": "https://api.github.com/users/ExpHP/events{/privacy}", "received_events_url": "https://api.github.com/users/ExpHP/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02b3da1200df47ea7343dd2cd960b8afe983ac9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/02b3da1200df47ea7343dd2cd960b8afe983ac9c", "html_url": "https://github.com/rust-lang/rust/commit/02b3da1200df47ea7343dd2cd960b8afe983ac9c"}], "stats": {"total": 154, "additions": 62, "deletions": 92}, "files": [{"sha": "d2bda65de55629fc48233622b8e55304459e492c", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 62, "deletions": 92, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/030aa9b112b5b52207186b375d9fc09607bbed48/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030aa9b112b5b52207186b375d9fc09607bbed48/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=030aa9b112b5b52207186b375d9fc09607bbed48", "patch": "@@ -376,9 +376,12 @@ fn test_windows_zip() {\n     assert_eq!(res, [14, 18, 22, 26]);\n }\n \n+// The current implementation of SliceIndex fails to handle methods\n+// orthogonally from range types; therefore, it is worth testing\n+// all of the indexing operations on each input.\n mod slice_index {\n-    // Test a slicing operation that should succeed,\n-    // testing it on all of the indexing methods.\n+    // This checks all six indexing methods, given an input range that\n+    // should succeed. (it is NOT suitable for testing invalid inputs)\n     macro_rules! assert_range_eq {\n         ($arr:expr, $range:expr, $expected:expr)\n         => {\n@@ -423,7 +426,7 @@ mod slice_index {\n     // because if it can't, then what are we even doing here?\n     //\n     // (Be aware this only demonstrates the ability to detect bugs\n-    //  in the FIRST method it calls, as the macro is not designed\n+    //  in the FIRST method that panics, as the macro is not designed\n     //  to be used in `should_panic`)\n     #[test]\n     #[should_panic(expected = \"out of range\")]\n@@ -446,30 +449,29 @@ mod slice_index {\n     // and `None` test cases for get/get_mut.\n     macro_rules! panic_cases {\n         ($(\n-            mod $case_name:ident {\n-                let DATA: $Data: ty = $data:expr;\n+            // each test case needs a unique name to namespace the tests\n+            in mod $case_name:ident {\n+                data: $data:expr;\n \n                 // optional:\n                 //\n-                // a similar input for which DATA[input] succeeds, and the corresponding\n-                // output as an array.  This helps validate \"critical points\" where an\n-                // input range straddles the boundary between valid and invalid.\n+                // one or more similar inputs for which data[input] succeeds,\n+                // and the corresponding output as an array.  This helps validate\n+                // \"critical points\" where an input range straddles the boundary\n+                // between valid and invalid.\n                 // (such as the input `len..len`, which is just barely valid)\n                 $(\n-                    let GOOD_INPUT = $good:expr;\n-                    let GOOD_OUTPUT = $output:expr;\n+                    good: data[$good:expr] == $output:expr;\n                 )*\n \n-                let BAD_INPUT = $bad:expr;\n-                const EXPECT_MSG = $expect_msg:expr;\n-\n-                !!generate_tests!!\n+                bad: data[$bad:expr];\n+                message: $expect_msg:expr;\n             }\n         )*) => {$(\n             mod $case_name {\n                 #[test]\n                 fn pass() {\n-                    let mut v: $Data = $data;\n+                    let mut v = $data;\n \n                     $( assert_range_eq!($data, $good, $output); )*\n \n@@ -487,15 +489,15 @@ mod slice_index {\n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n                 fn index_fail() {\n-                    let v: $Data = $data;\n+                    let v = $data;\n                     let v: &[_] = &v;\n                     let _v = &v[$bad];\n                 }\n \n                 #[test]\n                 #[should_panic(expected = $expect_msg)]\n                 fn index_mut_fail() {\n-                    let mut v: $Data = $data;\n+                    let mut v = $data;\n                     let v: &mut [_] = &mut v;\n                     let _v = &mut v[$bad];\n                 }\n@@ -516,112 +518,80 @@ mod slice_index {\n     }\n \n     panic_cases! {\n-        mod rangefrom_len {\n-            let DATA: [i32; 6] = [0, 1, 2, 3, 4, 5];\n-\n-            let GOOD_INPUT = 6..;\n-            let GOOD_OUTPUT = [];\n+        in mod rangefrom_len {\n+            data: [0, 1, 2, 3, 4, 5];\n \n-            let BAD_INPUT = 7..;\n-            const EXPECT_MSG = \"but ends at\"; // perhaps not ideal\n-\n-            !!generate_tests!!\n+            good: data[6..] == [];\n+            bad: data[7..];\n+            message: \"but ends at\"; // perhaps not ideal\n         }\n \n-        mod rangeto_len {\n-            let DATA: [i32; 6] = [0, 1, 2, 3, 4, 5];\n-\n-            let GOOD_INPUT = ..6;\n-            let GOOD_OUTPUT = [0, 1, 2, 3, 4, 5];\n+        in mod rangeto_len {\n+            data: [0, 1, 2, 3, 4, 5];\n \n-            let BAD_INPUT = ..7;\n-            const EXPECT_MSG = \"out of range\";\n-\n-            !!generate_tests!!\n+            good: data[..6] == [0, 1, 2, 3, 4, 5];\n+            bad: data[..7];\n+            message: \"out of range\";\n         }\n \n-        mod rangetoinclusive_len {\n-            let DATA: [i32; 6] = [0, 1, 2, 3, 4, 5];\n-\n-            let GOOD_INPUT = ..=5;\n-            let GOOD_OUTPUT = [0, 1, 2, 3, 4, 5];\n+        in mod rangetoinclusive_len {\n+            data: [0, 1, 2, 3, 4, 5];\n \n-            let BAD_INPUT = ..=6;\n-            const EXPECT_MSG = \"out of range\";\n-\n-            !!generate_tests!!\n+            good: data[..=5] == [0, 1, 2, 3, 4, 5];\n+            bad: data[..=6];\n+            message: \"out of range\";\n         }\n \n-        mod range_len_len {\n-            let DATA: [i32; 6] = [0, 1, 2, 3, 4, 5];\n-\n-            let GOOD_INPUT = 6..6;\n-            let GOOD_OUTPUT = [];\n+        in mod range_len_len {\n+            data: [0, 1, 2, 3, 4, 5];\n \n-            let BAD_INPUT = 7..7;\n-            const EXPECT_MSG = \"out of range\";\n-\n-            !!generate_tests!!\n+            good: data[6..6] == [];\n+            bad: data[7..7];\n+            message: \"out of range\";\n         }\n \n-        mod rangeinclusive_len_len{\n-            let DATA: [i32; 6] = [0, 1, 2, 3, 4, 5];\n-\n-            let GOOD_INPUT = 6..=5;\n-            let GOOD_OUTPUT = [];\n-\n-            let BAD_INPUT = 7..=6;\n-            const EXPECT_MSG = \"out of range\";\n+        in mod rangeinclusive_len_len {\n+            data: [0, 1, 2, 3, 4, 5];\n \n-            !!generate_tests!!\n+            good: data[6..=5] == [];\n+            bad: data[7..=6];\n+            message: \"out of range\";\n         }\n     }\n \n     panic_cases! {\n-        mod range_neg_width {\n-            let DATA: [i32; 6] = [0, 1, 2, 3, 4, 5];\n-\n-            let GOOD_INPUT = 4..4;\n-            let GOOD_OUTPUT = [];\n-\n-            let BAD_INPUT = 4..3;\n-            const EXPECT_MSG = \"but ends at\";\n+        in mod range_neg_width {\n+            data: [0, 1, 2, 3, 4, 5];\n \n-            !!generate_tests!!\n+            good: data[4..4] == [];\n+            bad: data[4..3];\n+            message: \"but ends at\";\n         }\n \n-        mod rangeinclusive_neg_width {\n-            let DATA: [i32; 6] = [0, 1, 2, 3, 4, 5];\n+        in mod rangeinclusive_neg_width {\n+            data: [0, 1, 2, 3, 4, 5];\n \n-            let GOOD_INPUT = 4..=3;\n-            let GOOD_OUTPUT = [];\n-\n-            let BAD_INPUT = 4..=2;\n-            const EXPECT_MSG = \"but ends at\";\n-\n-            !!generate_tests!!\n+            good: data[4..=3] == [];\n+            bad: data[4..=2];\n+            message: \"but ends at\";\n         }\n     }\n \n     panic_cases! {\n-        mod rangeinclusive_overflow {\n-            let DATA: [i32; 2] = [0, 1];\n+        in mod rangeinclusive_overflow {\n+            data: [0, 1];\n \n             // note: using 0 specifically ensures that the result of overflowing is 0..0,\n             //       so that `get` doesn't simply return None for the wrong reason.\n-            let BAD_INPUT = 0 ..= ::std::usize::MAX;\n-            const EXPECT_MSG = \"maximum usize\";\n-\n-            !!generate_tests!!\n+            bad: data[0 ..= ::std::usize::MAX];\n+            message: \"maximum usize\";\n         }\n \n-        mod rangetoinclusive_overflow {\n-            let DATA: [i32; 2] = [0, 1];\n-\n-            let BAD_INPUT = ..= ::std::usize::MAX;\n-            const EXPECT_MSG = \"maximum usize\";\n+        in mod rangetoinclusive_overflow {\n+            data: [0, 1];\n \n-            !!generate_tests!!\n+            bad: data[..= ::std::usize::MAX];\n+            message: \"maximum usize\";\n         }\n     } // panic_cases!\n }"}]}