{"sha": "d889957dab5ee0778f9dd64faeafc8872645efed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ODk5NTdkYWI1ZWUwNzc4ZjlkZDY0ZmFlYWZjODg3MjY0NWVmZWQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-02-10T22:28:17Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-03-22T20:16:38Z"}, "message": "rustc: Add a `#[wasm_import_module]` attribute\n\nThis commit adds a new attribute to the Rust compiler specific to the wasm\ntarget (and no other targets). The `#[wasm_import_module]` attribute is used to\nspecify the module that a name is imported from, and is used like so:\n\n    #[wasm_import_module = \"./foo.js\"]\n    extern {\n        fn some_js_function();\n    }\n\nHere the import of the symbol `some_js_function` is tagged with the `./foo.js`\nmodule in the wasm output file. Wasm-the-format includes two fields on all\nimports, a module and a field. The field is the symbol name (`some_js_function`\nabove) and the module has historically unconditionally been `\"env\"`. I'm not\nsure if this `\"env\"` convention has asm.js or LLVM roots, but regardless we'd\nlike the ability to configure it!\n\nThe proposed ES module integration with wasm (aka a wasm module is \"just another\nES module\") requires that the import module of wasm imports is interpreted as an\nES module import, meaning that you'll need to encode paths, NPM packages, etc.\nAs a result, we'll need this to be something other than `\"env\"`!\n\nUnfortunately neither our version of LLVM nor LLD supports custom import modules\n(aka anything not `\"env\"`). My hope is that by the time LLVM 7 is released both\nwill have support, but in the meantime this commit adds some primitive\nencoding/decoding of wasm files to the compiler. This way rustc postprocesses\nthe wasm module that LLVM emits to ensure it's got all the imports we'd like to\nhave in it.\n\nEventually I'd ideally like to unconditionally require this attribute to be\nplaced on all `extern { ... }` blocks. For now though it seemed prudent to add\nit as an unstable attribute, so for now it's not required (as that'd force usage\nof a feature gate). Hopefully it doesn't take too long to \"stabilize\" this!\n\ncc rust-lang-nursery/rust-wasm#29", "tree": {"sha": "3ae2c5ad215487df8a5449fa79dc04559814eba0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ae2c5ad215487df8a5449fa79dc04559814eba0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d889957dab5ee0778f9dd64faeafc8872645efed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d889957dab5ee0778f9dd64faeafc8872645efed", "html_url": "https://github.com/rust-lang/rust/commit/d889957dab5ee0778f9dd64faeafc8872645efed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d889957dab5ee0778f9dd64faeafc8872645efed/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7df6f4161cdc13a19216b5f1087081f490f06cdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7df6f4161cdc13a19216b5f1087081f490f06cdb", "html_url": "https://github.com/rust-lang/rust/commit/7df6f4161cdc13a19216b5f1087081f490f06cdb"}], "stats": {"total": 728, "additions": 653, "deletions": 75}, "files": [{"sha": "6c0ec1ad9d4e14879bf787dd3823a5a36d503539", "filename": "src/ci/docker/wasm32-unknown/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -26,6 +26,7 @@ ENV RUST_CONFIGURE_ARGS \\\n   --set rust.lld\n \n ENV SCRIPT python2.7 /checkout/x.py test --target $TARGETS \\\n+  src/test/run-make \\\n   src/test/ui \\\n   src/test/run-pass \\\n   src/test/compile-fail \\"}, {"sha": "8bcec79d99f17be3ce33a24d9c61309347bd4bbb", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -593,6 +593,7 @@ define_dep_nodes!( <'tcx>\n     [] ImplementationsOfTrait { krate: CrateNum, trait_id: DefId },\n     [] AllTraitImplementations(CrateNum),\n \n+    [] DllimportForeignItems(CrateNum),\n     [] IsDllimportForeignItem(DefId),\n     [] IsStaticallyIncludedForeignItem(DefId),\n     [] NativeLibraryKind(DefId),\n@@ -655,6 +656,8 @@ define_dep_nodes!( <'tcx>\n     [input] Features,\n \n     [] ProgramClausesFor(DefId),\n+    [] WasmImportModuleMap(CrateNum),\n+    [] ForeignModules(CrateNum),\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "9b2647ad4db2bce2a39eab7cd97d9d4f9a2c9ca1", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -26,6 +26,7 @@ enum Target {\n     Union,\n     Enum,\n     Const,\n+    ForeignMod,\n     Other,\n }\n \n@@ -37,6 +38,7 @@ impl Target {\n             hir::ItemUnion(..) => Target::Union,\n             hir::ItemEnum(..) => Target::Enum,\n             hir::ItemConst(..) => Target::Const,\n+            hir::ItemForeignMod(..) => Target::ForeignMod,\n             _ => Target::Other,\n         }\n     }\n@@ -57,25 +59,42 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n                 .emit();\n         }\n \n+        let mut has_wasm_import_module = false;\n         for attr in &item.attrs {\n-            if let Some(name) = attr.name() {\n-                if name == \"inline\" {\n-                    self.check_inline(attr, item, target)\n+            if attr.check_name(\"inline\") {\n+                self.check_inline(attr, item, target)\n+            } else if attr.check_name(\"wasm_import_module\") {\n+                has_wasm_import_module = true;\n+                if attr.value_str().is_none() {\n+                    self.tcx.sess.span_err(attr.span, \"\\\n+                        must be of the form #[wasm_import_module = \\\"...\\\"]\");\n+                }\n+                if target != Target::ForeignMod {\n+                    self.tcx.sess.span_err(attr.span, \"\\\n+                        must only be attached to foreign modules\");\n+                }\n+            } else if attr.check_name(\"wasm_custom_section\") {\n+                if target != Target::Const {\n+                    self.tcx.sess.span_err(attr.span, \"only allowed on consts\");\n                 }\n \n-                if name == \"wasm_custom_section\" {\n-                    if target != Target::Const {\n-                        self.tcx.sess.span_err(attr.span, \"only allowed on consts\");\n-                    }\n-\n-                    if attr.value_str().is_none() {\n-                        self.tcx.sess.span_err(attr.span, \"must be of the form \\\n-                            #[wasm_custom_section = \\\"foo\\\"]\");\n-                    }\n+                if attr.value_str().is_none() {\n+                    self.tcx.sess.span_err(attr.span, \"must be of the form \\\n+                        #[wasm_custom_section = \\\"foo\\\"]\");\n                 }\n             }\n         }\n \n+        if target == Target::ForeignMod &&\n+            !has_wasm_import_module &&\n+            self.tcx.sess.target.target.arch == \"wasm32\" &&\n+            false // FIXME: eventually enable this warning when stable\n+        {\n+            self.tcx.sess.span_warn(item.span, \"\\\n+                must have a #[wasm_import_module = \\\"...\\\"] attribute, this \\\n+                will become a hard error before too long\");\n+        }\n+\n         self.check_repr(item, target);\n     }\n "}, {"sha": "0071850e1052b5a77292d68d50e34c1a64ca6e89", "filename": "src/librustc/ich/impls_cstore.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_cstore.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -33,7 +33,12 @@ impl_stable_hash_for!(struct middle::cstore::NativeLibrary {\n     kind,\n     name,\n     cfg,\n-    foreign_items\n+    foreign_module\n+});\n+\n+impl_stable_hash_for!(struct middle::cstore::ForeignModule {\n+    foreign_items,\n+    def_id\n });\n \n impl_stable_hash_for!(enum middle::cstore::LinkagePreference {"}, {"sha": "add9b621596b63219db2d406dab8020c0a4bb13a", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -132,7 +132,13 @@ pub struct NativeLibrary {\n     pub kind: NativeLibraryKind,\n     pub name: Symbol,\n     pub cfg: Option<ast::MetaItem>,\n+    pub foreign_module: Option<DefId>,\n+}\n+\n+#[derive(Clone, Hash, RustcEncodable, RustcDecodable)]\n+pub struct ForeignModule {\n     pub foreign_items: Vec<DefId>,\n+    pub def_id: DefId,\n }\n \n pub enum LoadedMacro {"}, {"sha": "7565e90df986f49d5d43297345b7434e5ea682f8", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -430,6 +430,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::native_libraries<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::foreign_modules<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the foreign modules of a linked crate\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::plugin_registrar_fn<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up the plugin registrar for a crate\")\n@@ -705,6 +711,18 @@ impl<'tcx> QueryDescription<'tcx> for queries::program_clauses_for<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::wasm_import_module_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"wasm import module map\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription<'tcx> for queries::dllimport_foreign_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"wasm import module map\")\n+    }\n+}\n+\n macro_rules! impl_disk_cacheable_query(\n     ($query_name:ident, |$key:tt| $cond:expr) => {\n         impl<'tcx> QueryDescription<'tcx> for queries::$query_name<'tcx> {"}, {"sha": "c16ad0d8ca1401d6536d9e6c81f836b191611540", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -18,7 +18,7 @@ use infer::canonical::{Canonical, QueryResult};\n use lint;\n use middle::borrowck::BorrowCheckResult;\n use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary,\n-                     ExternBodyNestedBodies};\n+                     ExternBodyNestedBodies, ForeignModule};\n use middle::cstore::{NativeLibraryKind, DepKind, CrateSource, ExternConstBody};\n use middle::privacy::AccessLevels;\n use middle::reachable::ReachableSet;\n@@ -320,6 +320,9 @@ define_maps! { <'tcx>\n \n \n     [] fn native_libraries: NativeLibraries(CrateNum) -> Lrc<Vec<NativeLibrary>>,\n+\n+    [] fn foreign_modules: ForeignModules(CrateNum) -> Lrc<Vec<ForeignModule>>,\n+\n     [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,\n     [] fn derive_registrar_fn: DeriveRegistrarFn(CrateNum) -> Option<DefId>,\n     [] fn crate_disambiguator: CrateDisambiguator(CrateNum) -> CrateDisambiguator,\n@@ -331,6 +334,8 @@ define_maps! { <'tcx>\n     [] fn all_trait_implementations: AllTraitImplementations(CrateNum)\n         -> Lrc<Vec<DefId>>,\n \n+    [] fn dllimport_foreign_items: DllimportForeignItems(CrateNum)\n+        -> Lrc<FxHashSet<DefId>>,\n     [] fn is_dllimport_foreign_item: IsDllimportForeignItem(DefId) -> bool,\n     [] fn is_statically_included_foreign_item: IsStaticallyIncludedForeignItem(DefId) -> bool,\n     [] fn native_library_kind: NativeLibraryKind(DefId)\n@@ -426,6 +431,8 @@ define_maps! { <'tcx>\n     [] fn program_clauses_for: ProgramClausesFor(DefId) -> Lrc<Vec<Clause<'tcx>>>,\n \n     [] fn wasm_custom_sections: WasmCustomSections(CrateNum) -> Lrc<Vec<DefId>>,\n+    [] fn wasm_import_module_map: WasmImportModuleMap(CrateNum)\n+        -> Lrc<FxHashMap<DefId, String>>,\n }\n \n //////////////////////////////////////////////////////////////////////"}, {"sha": "46106d8ec0e9141c6ceeb781b807a44e0b8cf846", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -886,6 +886,9 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n             force!(all_trait_implementations, krate!());\n         }\n \n+        DepKind::DllimportForeignItems => {\n+            force!(dllimport_foreign_items, krate!());\n+        }\n         DepKind::IsDllimportForeignItem => {\n             force!(is_dllimport_foreign_item, def_id!());\n         }\n@@ -941,6 +944,8 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n \n         DepKind::ProgramClausesFor => { force!(program_clauses_for, def_id!()); }\n         DepKind::WasmCustomSections => { force!(wasm_custom_sections, krate!()); }\n+        DepKind::WasmImportModuleMap => { force!(wasm_import_module_map, krate!()); }\n+        DepKind::ForeignModules => { force!(foreign_modules, krate!()); }\n     }\n \n     true"}, {"sha": "baaf57c890898948f96dc69d704fb6d8663abf4e", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -12,7 +12,6 @@\n \n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use locator::{self, CratePaths};\n-use native_libs::relevant_lib;\n use schema::CrateRoot;\n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n \n@@ -230,7 +229,7 @@ impl<'a> CrateLoader<'a> {\n             .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n             .collect();\n \n-        let mut cmeta = cstore::CrateMetadata {\n+        let cmeta = cstore::CrateMetadata {\n             name,\n             extern_crate: Lock::new(None),\n             def_path_table: Lrc::new(def_path_table),\n@@ -250,25 +249,8 @@ impl<'a> CrateLoader<'a> {\n                 rlib,\n                 rmeta,\n             },\n-            // Initialize this with an empty set. The field is populated below\n-            // after we were able to deserialize its contents.\n-            dllimport_foreign_items: FxHashSet(),\n         };\n \n-        let dllimports: FxHashSet<_> = cmeta\n-            .root\n-            .native_libraries\n-            .decode((&cmeta, self.sess))\n-            .filter(|lib| relevant_lib(self.sess, lib) &&\n-                          lib.kind == cstore::NativeLibraryKind::NativeUnknown)\n-            .flat_map(|lib| {\n-                assert!(lib.foreign_items.iter().all(|def_id| def_id.krate == cnum));\n-                lib.foreign_items.into_iter().map(|def_id| def_id.index)\n-            })\n-            .collect();\n-\n-        cmeta.dllimport_foreign_items = dllimports;\n-\n         let cmeta = Lrc::new(cmeta);\n         self.cstore.set_crate_data(cnum, cmeta.clone());\n         (cnum, cmeta)"}, {"sha": "53986f074100561bff2588f1832a3ff7e3756da7", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -20,7 +20,7 @@ use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n use rustc::session::{Session, CrateDisambiguator};\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n+use rustc::util::nodemap::{FxHashMap, NodeMap};\n \n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n use syntax::{ast, attr};\n@@ -30,7 +30,7 @@ use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind, LinkagePreference};\n pub use rustc::middle::cstore::NativeLibraryKind::*;\n-pub use rustc::middle::cstore::{CrateSource, LibSource};\n+pub use rustc::middle::cstore::{CrateSource, LibSource, ForeignModule};\n \n pub use cstore_impl::{provide, provide_extern};\n \n@@ -84,8 +84,6 @@ pub struct CrateMetadata {\n     pub source: CrateSource,\n \n     pub proc_macros: Option<Vec<(ast::Name, Lrc<SyntaxExtension>)>>,\n-    // Foreign items imported from a dylib (Windows only)\n-    pub dllimport_foreign_items: FxHashSet<DefIndex>,\n }\n \n pub struct CStore {"}, {"sha": "e911a03bbe2b5bfc74206f35eb9d69b81dd57afc", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -12,6 +12,7 @@ use cstore;\n use encoder;\n use link_args;\n use native_libs;\n+use foreign_modules;\n use schema;\n \n use rustc::ty::maps::QueryConfig;\n@@ -197,6 +198,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         Lrc::new(reachable_non_generics)\n     }\n     native_libraries => { Lrc::new(cdata.get_native_libraries(tcx.sess)) }\n+    foreign_modules => { Lrc::new(cdata.get_foreign_modules(tcx.sess)) }\n     plugin_registrar_fn => {\n         cdata.root.plugin_registrar_fn.map(|index| {\n             DefId { krate: def_id.krate, index }\n@@ -224,9 +226,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         Lrc::new(result)\n     }\n \n-    is_dllimport_foreign_item => {\n-        cdata.is_dllimport_foreign_item(def_id.index)\n-    }\n     visibility => { cdata.get_visibility(def_id.index) }\n     dep_kind => {\n         let r = *cdata.dep_kind.lock();\n@@ -306,13 +305,28 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n             tcx.native_libraries(id.krate)\n                 .iter()\n                 .filter(|lib| native_libs::relevant_lib(&tcx.sess, lib))\n-                .find(|l| l.foreign_items.contains(&id))\n+                .find(|lib| {\n+                    let fm_id = match lib.foreign_module {\n+                        Some(id) => id,\n+                        None => return false,\n+                    };\n+                    tcx.foreign_modules(id.krate)\n+                        .iter()\n+                        .find(|m| m.def_id == fm_id)\n+                        .expect(\"failed to find foreign module\")\n+                        .foreign_items\n+                        .contains(&id)\n+                })\n                 .map(|l| l.kind)\n         },\n         native_libraries: |tcx, cnum| {\n             assert_eq!(cnum, LOCAL_CRATE);\n             Lrc::new(native_libs::collect(tcx))\n         },\n+        foreign_modules: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            Lrc::new(foreign_modules::collect(tcx))\n+        },\n         link_args: |tcx, cnum| {\n             assert_eq!(cnum, LOCAL_CRATE);\n             Lrc::new(link_args::collect(tcx))"}, {"sha": "e72f9ddd82abeba704fd53058307bad80d5bc682", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -10,7 +10,7 @@\n \n // Decoding metadata from a single crate's metadata\n \n-use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n+use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule};\n use schema::*;\n \n use rustc_data_structures::sync::{Lrc, ReadGuard};\n@@ -1031,6 +1031,10 @@ impl<'a, 'tcx> CrateMetadata {\n         self.root.native_libraries.decode((self, sess)).collect()\n     }\n \n+    pub fn get_foreign_modules(&self, sess: &Session) -> Vec<ForeignModule> {\n+        self.root.foreign_modules.decode((self, sess)).collect()\n+    }\n+\n     pub fn get_dylib_dependency_formats(&self) -> Vec<(CrateNum, LinkagePreference)> {\n         self.root\n             .dylib_dependency_formats\n@@ -1103,10 +1107,6 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn is_dllimport_foreign_item(&self, id: DefIndex) -> bool {\n-        self.dllimport_foreign_items.contains(&id)\n-    }\n-\n     pub fn fn_sig(&self,\n                   id: DefIndex,\n                   tcx: TyCtxt<'a, 'tcx, 'tcx>)"}, {"sha": "39de1ec852ec41cf51f7604714ca4107016b9277", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -14,7 +14,7 @@ use isolated_encoder::IsolatedEncoder;\n use schema::*;\n \n use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary,\n-                            EncodedMetadata};\n+                            EncodedMetadata, ForeignModule};\n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LocalDefId, LOCAL_CRATE};\n use rustc::hir::map::definitions::DefPathTable;\n@@ -412,6 +412,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             ());\n         let native_lib_bytes = self.position() - i;\n \n+        let foreign_modules = self.tracked(\n+            IsolatedEncoder::encode_foreign_modules,\n+            ());\n+\n         // Encode codemap\n         i = self.position();\n         let codemap = self.encode_codemap();\n@@ -480,6 +484,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             lang_items,\n             lang_items_missing,\n             native_libraries,\n+            foreign_modules,\n             codemap,\n             def_path_table,\n             impls,\n@@ -1337,6 +1342,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         self.lazy_seq(used_libraries.iter().cloned())\n     }\n \n+    fn encode_foreign_modules(&mut self, _: ()) -> LazySeq<ForeignModule> {\n+        let foreign_modules = self.tcx.foreign_modules(LOCAL_CRATE);\n+        self.lazy_seq(foreign_modules.iter().cloned())\n+    }\n+\n     fn encode_crate_deps(&mut self, _: ()) -> LazySeq<CrateDep> {\n         let crates = self.tcx.crates();\n "}, {"sha": "c44d891b7f39a406d321f04f466347edaac30834", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir;\n+use rustc::middle::cstore::ForeignModule;\n+use rustc::ty::TyCtxt;\n+\n+pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<ForeignModule> {\n+    let mut collector = Collector {\n+        tcx,\n+        modules: Vec::new(),\n+    };\n+    tcx.hir.krate().visit_all_item_likes(&mut collector);\n+    return collector.modules\n+}\n+\n+struct Collector<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    modules: Vec<ForeignModule>,\n+}\n+\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n+    fn visit_item(&mut self, it: &'tcx hir::Item) {\n+        let fm = match it.node {\n+            hir::ItemForeignMod(ref fm) => fm,\n+            _ => return,\n+        };\n+\n+        let foreign_items = fm.items.iter()\n+            .map(|it| self.tcx.hir.local_def_id(it.id))\n+            .collect();\n+        self.modules.push(ForeignModule {\n+            foreign_items,\n+            def_id: self.tcx.hir.local_def_id(it.id),\n+        });\n+    }\n+\n+    fn visit_trait_item(&mut self, _it: &'tcx hir::TraitItem) {}\n+    fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem) {}\n+}"}, {"sha": "8509966744948be24f7d09127f72773a0bdc0122", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -56,6 +56,7 @@ mod isolated_encoder;\n mod schema;\n mod native_libs;\n mod link_args;\n+mod foreign_modules;\n \n pub mod creader;\n pub mod cstore;"}, {"sha": "4bb6d8fb87cf5b490b2c3622ba6c1bedbf999a1b", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -105,14 +105,11 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n             } else {\n                 None\n             };\n-            let foreign_items = fm.items.iter()\n-                .map(|it| self.tcx.hir.local_def_id(it.id))\n-                .collect();\n             let lib = NativeLibrary {\n                 name: n,\n                 kind,\n                 cfg,\n-                foreign_items,\n+                foreign_module: Some(self.tcx.hir.local_def_id(it.id)),\n             };\n             self.register_native_lib(Some(m.span), lib);\n         }\n@@ -218,7 +215,7 @@ impl<'a, 'tcx> Collector<'a, 'tcx> {\n                     name: Symbol::intern(new_name.unwrap_or(name)),\n                     kind: if let Some(k) = kind { k } else { cstore::NativeUnknown },\n                     cfg: None,\n-                    foreign_items: Vec::new(),\n+                    foreign_module: None,\n                 };\n                 self.register_native_lib(None, lib);\n             }"}, {"sha": "983279452970172a46940016f1455717922218d9", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -15,8 +15,8 @@ use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId, CrateNum};\n use rustc::ich::StableHashingContext;\n-use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n+use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary, ForeignModule};\n use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::session::CrateDisambiguator;\n@@ -200,6 +200,7 @@ pub struct CrateRoot {\n     pub lang_items: LazySeq<(DefIndex, usize)>,\n     pub lang_items_missing: LazySeq<lang_items::LangItem>,\n     pub native_libraries: LazySeq<NativeLibrary>,\n+    pub foreign_modules: LazySeq<ForeignModule>,\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: LazySeq<TraitImpls>,"}, {"sha": "df78ccdd2298a2be450437365982aa9fbdd121e1", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -18,6 +18,7 @@ use rustc::session::config::Sanitizer;\n use rustc::ty::TyCtxt;\n use rustc::ty::maps::Providers;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::fx::FxHashMap;\n \n use llvm::{self, Attribute, ValueRef};\n use llvm::AttributePlace::Function;\n@@ -141,6 +142,20 @@ pub fn from_fn_attrs(cx: &CodegenCx, llfn: ValueRef, id: DefId) {\n             llfn, llvm::AttributePlace::Function,\n             cstr(\"target-features\\0\"), &val);\n     }\n+\n+    // Note that currently the `wasm-import-module` doesn't do anything, but\n+    // eventually LLVM 7 should read this and ferry the appropriate import\n+    // module to the output file.\n+    if cx.tcx.sess.target.target.arch == \"wasm32\" {\n+        if let Some(module) = wasm_import_module(cx.tcx, id) {\n+            llvm::AddFunctionAttrStringValue(\n+                llfn,\n+                llvm::AttributePlace::Function,\n+                cstr(\"wasm-import-module\\0\"),\n+                &module,\n+            );\n+        }\n+    }\n }\n \n fn cstr(s: &'static str) -> &CStr {\n@@ -170,6 +185,8 @@ pub fn provide(providers: &mut Providers) {\n         tcx.hir.krate().visit_all_item_likes(&mut finder);\n         Lrc::new(finder.list)\n     };\n+\n+    provide_extern(providers);\n }\n \n struct WasmSectionFinder<'a, 'tcx: 'a> {\n@@ -192,3 +209,32 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for WasmSectionFinder<'a, 'tcx> {\n \n     fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) {}\n }\n+\n+pub fn provide_extern(providers: &mut Providers) {\n+    providers.wasm_import_module_map = |tcx, cnum| {\n+        let mut ret = FxHashMap();\n+        for lib in tcx.foreign_modules(cnum).iter() {\n+            let attrs = tcx.get_attrs(lib.def_id);\n+            let mut module = None;\n+            for attr in attrs.iter().filter(|a| a.check_name(\"wasm_import_module\")) {\n+                module = attr.value_str();\n+            }\n+            let module = match module {\n+                Some(s) => s,\n+                None => continue,\n+            };\n+            for id in lib.foreign_items.iter() {\n+                assert_eq!(id.krate, cnum);\n+                ret.insert(*id, module.to_string());\n+            }\n+        }\n+\n+        Lrc::new(ret)\n+    }\n+}\n+\n+fn wasm_import_module(tcx: TyCtxt, id: DefId) -> Option<CString> {\n+    tcx.wasm_import_module_map(id.krate)\n+        .get(&id)\n+        .map(|s| CString::new(&s[..]).unwrap())\n+}"}, {"sha": "542cdc5baad32ba94b902466cdade37561c8e5cc", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -813,6 +813,7 @@ fn link_natively(sess: &Session,\n     }\n \n     if sess.opts.target_triple == \"wasm32-unknown-unknown\" {\n+        wasm::rewrite_imports(&out_filename, &trans.crate_info.wasm_imports);\n         wasm::add_custom_sections(&out_filename,\n                                   &trans.crate_info.wasm_custom_sections);\n     }"}, {"sha": "d6d386c9fbe77d74cd3468c1aed99fdf985c1704", "filename": "src/librustc_trans/back/wasm.rs", "status": "modified", "additions": 233, "deletions": 16, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_trans%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_trans%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwasm.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -8,37 +8,254 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::collections::BTreeMap;\n use std::fs;\n use std::path::Path;\n-use std::collections::BTreeMap;\n+use std::str;\n \n+use rustc_data_structures::fx::FxHashMap;\n use serialize::leb128;\n \n+// https://webassembly.github.io/spec/core/binary/modules.html#binary-importsec\n+const WASM_IMPORT_SECTION_ID: u8 = 2;\n+\n+const WASM_EXTERNAL_KIND_FUNCTION: u8 = 0;\n+const WASM_EXTERNAL_KIND_TABLE: u8 = 1;\n+const WASM_EXTERNAL_KIND_MEMORY: u8 = 2;\n+const WASM_EXTERNAL_KIND_GLOBAL: u8 = 3;\n+\n+/// Append all the custom sections listed in `sections` to the wasm binary\n+/// specified at `path`.\n+///\n+/// LLVM 6 which we're using right now doesn't have the ability to create custom\n+/// sections in wasm files nor does LLD have the ability to merge these sections\n+/// into one larger section when linking. It's expected that this will\n+/// eventually get implemented, however!\n+///\n+/// Until that time though this is a custom implementation in rustc to append\n+/// all sections to a wasm file to the finished product that LLD produces.\n+///\n+/// Support for this is landing in LLVM in https://reviews.llvm.org/D43097,\n+/// although after that support will need to be in LLD as well.\n pub fn add_custom_sections(path: &Path, sections: &BTreeMap<String, Vec<u8>>) {\n-    let mut wasm = fs::read(path).expect(\"failed to read wasm output\");\n+    if sections.len() == 0 {\n+        return\n+    }\n+\n+    let wasm = fs::read(path).expect(\"failed to read wasm output\");\n \n     // see https://webassembly.github.io/spec/core/binary/modules.html#custom-section\n+    let mut wasm = WasmEncoder { data: wasm };\n     for (section, bytes) in sections {\n         // write the `id` identifier, 0 for a custom section\n-        let len = wasm.len();\n-        leb128::write_u32_leb128(&mut wasm, len, 0);\n+        wasm.byte(0);\n \n         // figure out how long our name descriptor will be\n-        let mut name = Vec::new();\n-        leb128::write_u32_leb128(&mut name, 0, section.len() as u32);\n-        name.extend_from_slice(section.as_bytes());\n+        let mut name = WasmEncoder::new();\n+        name.str(section);\n+\n+        // write the length of the payload followed by all its contents\n+        wasm.u32((bytes.len() + name.data.len()) as u32);\n+        wasm.data.extend_from_slice(&name.data);\n+        wasm.data.extend_from_slice(bytes);\n+    }\n+\n+    fs::write(path, &wasm.data).expect(\"failed to write wasm output\");\n+}\n+\n+/// Rewrite the module imports are listed from in a wasm module given the field\n+/// name to module name mapping in `import_map`.\n+///\n+/// LLVM 6 which we're using right now doesn't have the ability to configure the\n+/// module a wasm symbol is import from. Rather all imported symbols come from\n+/// the bland `\"env\"` module unconditionally. Furthermore we'd *also* need\n+/// support in LLD for preserving these import modules, which it unfortunately\n+/// currently does not.\n+///\n+/// This function is intended as a hack for now where we manually rewrite the\n+/// wasm output by LLVM to have the correct import modules listed. The\n+/// `#[wasm_import_module]` attribute in Rust translates to the module that each\n+/// symbol is imported from, so here we manually go through the wasm file,\n+/// decode it, rewrite imports, and then rewrite the wasm module.\n+///\n+/// Support for this was added to LLVM in\n+/// https://github.com/llvm-mirror/llvm/commit/0f32e1365, although support still\n+/// needs to be added (AFAIK at the time of this writing) to LLD\n+pub fn rewrite_imports(path: &Path, import_map: &FxHashMap<String, String>) {\n+    if import_map.len() == 0 {\n+        return\n+    }\n+\n+    let wasm = fs::read(path).expect(\"failed to read wasm output\");\n+    let mut ret = WasmEncoder::new();\n+    ret.data.extend(&wasm[..8]);\n+\n+    // skip the 8 byte wasm/version header\n+    for (id, raw) in WasmSections(WasmDecoder::new(&wasm[8..])) {\n+        ret.byte(id);\n+        if id == WASM_IMPORT_SECTION_ID {\n+            info!(\"rewriting import section\");\n+            let data = rewrite_import_section(\n+                &mut WasmDecoder::new(raw),\n+                import_map,\n+            );\n+            ret.bytes(&data);\n+        } else {\n+            info!(\"carry forward section {}, {} bytes long\", id, raw.len());\n+            ret.bytes(raw);\n+        }\n+    }\n+\n+    fs::write(path, &ret.data).expect(\"failed to write wasm output\");\n+\n+    fn rewrite_import_section(\n+        wasm: &mut WasmDecoder,\n+        import_map: &FxHashMap<String, String>,\n+    )\n+        -> Vec<u8>\n+    {\n+        let mut dst = WasmEncoder::new();\n+        let n = wasm.u32();\n+        dst.u32(n);\n+        info!(\"rewriting {} imports\", n);\n+        for _ in 0..n {\n+            rewrite_import_entry(wasm, &mut dst, import_map);\n+        }\n+        return dst.data\n+    }\n+\n+    fn rewrite_import_entry(wasm: &mut WasmDecoder,\n+                            dst: &mut WasmEncoder,\n+                            import_map: &FxHashMap<String, String>) {\n+        // More info about the binary format here is available at:\n+        // https://webassembly.github.io/spec/core/binary/modules.html#import-section\n+        //\n+        // Note that you can also find the whole point of existence of this\n+        // function here, where we map the `module` name to a different one if\n+        // we've got one listed.\n+        let module = wasm.str();\n+        let field = wasm.str();\n+        let new_module = if module == \"env\" {\n+            import_map.get(field).map(|s| &**s).unwrap_or(module)\n+        } else {\n+            module\n+        };\n+        info!(\"import rewrite ({} => {}) / {}\", module, new_module, field);\n+        dst.str(new_module);\n+        dst.str(field);\n+        let kind = wasm.byte();\n+        dst.byte(kind);\n+        match kind {\n+            WASM_EXTERNAL_KIND_FUNCTION => dst.u32(wasm.u32()),\n+            WASM_EXTERNAL_KIND_TABLE => {\n+                dst.byte(wasm.byte()); // element_type\n+                dst.limits(wasm.limits());\n+            }\n+            WASM_EXTERNAL_KIND_MEMORY => dst.limits(wasm.limits()),\n+            WASM_EXTERNAL_KIND_GLOBAL => {\n+                dst.byte(wasm.byte()); // content_type\n+                dst.bool(wasm.bool()); // mutable\n+            }\n+            b => panic!(\"unknown kind: {}\", b),\n+        }\n+    }\n+}\n \n-        // write the length of the payload\n-        let len = wasm.len();\n-        let total_len = bytes.len() + name.len();\n-        leb128::write_u32_leb128(&mut wasm, len, total_len as u32);\n+struct WasmSections<'a>(WasmDecoder<'a>);\n \n-        // write out the name section\n-        wasm.extend(name);\n+impl<'a> Iterator for WasmSections<'a> {\n+    type Item = (u8, &'a [u8]);\n \n-        // and now the payload itself\n-        wasm.extend_from_slice(bytes);\n+    fn next(&mut self) -> Option<(u8, &'a [u8])> {\n+        if self.0.data.len() == 0 {\n+            return None\n+        }\n+\n+        // see https://webassembly.github.io/spec/core/binary/modules.html#sections\n+        let id = self.0.byte();\n+        let section_len = self.0.u32();\n+        info!(\"new section {} / {} bytes\", id, section_len);\n+        let section = self.0.skip(section_len as usize);\n+        Some((id, section))\n     }\n+}\n+\n+struct WasmDecoder<'a> {\n+    data: &'a [u8],\n+}\n \n-    fs::write(path, &wasm).expect(\"failed to write wasm output\");\n+impl<'a> WasmDecoder<'a> {\n+    fn new(data: &'a [u8]) -> WasmDecoder<'a> {\n+        WasmDecoder { data }\n+    }\n+\n+    fn byte(&mut self) -> u8 {\n+        self.skip(1)[0]\n+    }\n+\n+    fn u32(&mut self) -> u32 {\n+        let (n, l1) = leb128::read_u32_leb128(self.data);\n+        self.data = &self.data[l1..];\n+        return n\n+    }\n+\n+    fn skip(&mut self, amt: usize) -> &'a [u8] {\n+        let (data, rest) = self.data.split_at(amt);\n+        self.data = rest;\n+        data\n+    }\n+\n+    fn str(&mut self) -> &'a str {\n+        let len = self.u32();\n+        str::from_utf8(self.skip(len as usize)).unwrap()\n+    }\n+\n+    fn bool(&mut self) -> bool {\n+        self.byte() == 1\n+    }\n+\n+    fn limits(&mut self) -> (u32, Option<u32>) {\n+        let has_max = self.bool();\n+        (self.u32(), if has_max { Some(self.u32()) } else { None })\n+    }\n+}\n+\n+struct WasmEncoder {\n+    data: Vec<u8>,\n+}\n+\n+impl WasmEncoder {\n+    fn new() -> WasmEncoder {\n+        WasmEncoder { data: Vec::new() }\n+    }\n+\n+    fn u32(&mut self, val: u32) {\n+        let at = self.data.len();\n+        leb128::write_u32_leb128(&mut self.data, at, val);\n+    }\n+\n+    fn byte(&mut self, val: u8) {\n+        self.data.push(val);\n+    }\n+\n+    fn bytes(&mut self, val: &[u8]) {\n+        self.u32(val.len() as u32);\n+        self.data.extend_from_slice(val);\n+    }\n+\n+    fn str(&mut self, val: &str) {\n+        self.bytes(val.as_bytes())\n+    }\n+\n+    fn bool(&mut self, b: bool) {\n+        self.byte(b as u8);\n+    }\n+\n+    fn limits(&mut self, limits: (u32, Option<u32>)) {\n+        self.bool(limits.1.is_some());\n+        self.u32(limits.0);\n+        if let Some(c) = limits.1 {\n+            self.u32(c);\n+        }\n+    }\n }"}, {"sha": "56eece9f31e7ee135c8e82c10be44a9da58aa008", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -72,6 +72,7 @@ use type_::Type;\n use type_of::LayoutLlvmExt;\n use rustc::util::nodemap::{FxHashMap, FxHashSet, DefIdSet};\n use CrateInfo;\n+use rustc_data_structures::sync::Lrc;\n \n use std::any::Any;\n use std::collections::BTreeMap;\n@@ -1072,21 +1073,23 @@ impl CrateInfo {\n             used_crates_static: cstore::used_crates(tcx, LinkagePreference::RequireStatic),\n             used_crate_source: FxHashMap(),\n             wasm_custom_sections: BTreeMap::new(),\n+            wasm_imports: FxHashMap(),\n         };\n \n-        let load_wasm_sections = tcx.sess.crate_types.borrow()\n+        let load_wasm_items = tcx.sess.crate_types.borrow()\n             .iter()\n             .any(|c| *c != config::CrateTypeRlib) &&\n             tcx.sess.opts.target_triple == \"wasm32-unknown-unknown\";\n \n-        if load_wasm_sections {\n+        if load_wasm_items {\n             info!(\"attempting to load all wasm sections\");\n             for &id in tcx.wasm_custom_sections(LOCAL_CRATE).iter() {\n                 let (name, contents) = fetch_wasm_section(tcx, id);\n                 info.wasm_custom_sections.entry(name)\n                     .or_insert(Vec::new())\n                     .extend(contents);\n             }\n+            info.load_wasm_imports(tcx, LOCAL_CRATE);\n         }\n \n         for &cnum in tcx.crates().iter() {\n@@ -1108,19 +1111,27 @@ impl CrateInfo {\n             if tcx.is_no_builtins(cnum) {\n                 info.is_no_builtins.insert(cnum);\n             }\n-            if load_wasm_sections {\n+            if load_wasm_items {\n                 for &id in tcx.wasm_custom_sections(cnum).iter() {\n                     let (name, contents) = fetch_wasm_section(tcx, id);\n                     info.wasm_custom_sections.entry(name)\n                         .or_insert(Vec::new())\n                         .extend(contents);\n                 }\n+                info.load_wasm_imports(tcx, cnum);\n             }\n         }\n \n-\n         return info\n     }\n+\n+    fn load_wasm_imports(&mut self, tcx: TyCtxt, cnum: CrateNum) {\n+        for (&id, module) in tcx.wasm_import_module_map(cnum).iter() {\n+            let instance = Instance::mono(tcx, id);\n+            let import_name = tcx.symbol_name(instance);\n+            self.wasm_imports.insert(import_name.to_string(), module.clone());\n+        }\n+    }\n }\n \n fn is_translated_item(tcx: TyCtxt, id: DefId) -> bool {\n@@ -1248,6 +1259,39 @@ pub fn provide(providers: &mut Providers) {\n             .expect(&format!(\"failed to find cgu with name {:?}\", name))\n     };\n     providers.compile_codegen_unit = compile_codegen_unit;\n+\n+    provide_extern(providers);\n+}\n+\n+pub fn provide_extern(providers: &mut Providers) {\n+    providers.dllimport_foreign_items = |tcx, krate| {\n+        let module_map = tcx.foreign_modules(krate);\n+        let module_map = module_map.iter()\n+            .map(|lib| (lib.def_id, lib))\n+            .collect::<FxHashMap<_, _>>();\n+\n+        let dllimports = tcx.native_libraries(krate)\n+            .iter()\n+            .filter(|lib| {\n+                if lib.kind != cstore::NativeLibraryKind::NativeUnknown {\n+                    return false\n+                }\n+                let cfg = match lib.cfg {\n+                    Some(ref cfg) => cfg,\n+                    None => return true,\n+                };\n+                attr::cfg_matches(cfg, &tcx.sess.parse_sess, None)\n+            })\n+            .filter_map(|lib| lib.foreign_module)\n+            .map(|id| &module_map[&id])\n+            .flat_map(|module| module.foreign_items.iter().cloned())\n+            .collect();\n+        Lrc::new(dllimports)\n+    };\n+\n+    providers.is_dllimport_foreign_item = |tcx, def_id| {\n+        tcx.dllimport_foreign_items(def_id.krate).contains(&def_id)\n+    };\n }\n \n pub fn linkage_to_llvm(linkage: Linkage) -> llvm::Linkage {"}, {"sha": "9f654c8ab29c0683fb97a99c72a46e27a81ded49", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -216,6 +216,8 @@ impl TransCrate for LlvmTransCrate {\n \n     fn provide_extern(&self, providers: &mut ty::maps::Providers) {\n         back::symbol_export::provide_extern(providers);\n+        base::provide_extern(providers);\n+        attributes::provide_extern(providers);\n     }\n \n     fn trans_crate<'a, 'tcx>(\n@@ -403,6 +405,7 @@ struct CrateInfo {\n     used_crates_static: Vec<(CrateNum, LibSource)>,\n     used_crates_dynamic: Vec<(CrateNum, LibSource)>,\n     wasm_custom_sections: BTreeMap<String, Vec<u8>>,\n+    wasm_imports: FxHashMap<String, String>,\n }\n \n __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }"}, {"sha": "270cee26948e31944342b0b9fb55d2f2a5f6e312", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -454,6 +454,9 @@ declare_features! (\n \n     // The #[wasm_custom_section] attribute\n     (active, wasm_custom_section, \"1.26.0\", None, None),\n+\n+    // The #![wasm_import_module] attribute\n+    (active, wasm_import_module, \"1.26.0\", None, None),\n );\n \n declare_features! (\n@@ -920,6 +923,10 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n         \"the `#[no_debug]` attribute was an experimental feature that has been \\\n          deprecated due to lack of demand\",\n         cfg_fn!(no_debug))),\n+    (\"wasm_import_module\", Normal, Gated(Stability::Unstable,\n+                                 \"wasm_import_module\",\n+                                 \"experimental attribute\",\n+                                 cfg_fn!(wasm_import_module))),\n     (\"omit_gdb_pretty_printer_section\", Whitelisted, Gated(Stability::Unstable,\n                                                        \"omit_gdb_pretty_printer_section\",\n                                                        \"the `#[omit_gdb_pretty_printer_section]` \\"}, {"sha": "e7a4cfc344efb6738457a9d8185abf4e8e0a434b", "filename": "src/test/run-make/wasm-custom-section/foo.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Frun-make%2Fwasm-custom-section%2Ffoo.js", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Frun-make%2Fwasm-custom-section%2Ffoo.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-custom-section%2Ffoo.js?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -43,4 +43,4 @@ assert.strictEqual(section[1], 6);\n assert.strictEqual(section[2], 1);\n assert.strictEqual(section[3], 2);\n \n-process.exit(1);\n+process.exit(0);"}, {"sha": "399951e516314846d80b2e04f6835f889fa57eeb", "filename": "src/test/run-make/wasm-import-module/Makefile", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Frun-make%2Fwasm-import-module%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Frun-make%2Fwasm-import-module%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-import-module%2FMakefile?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -0,0 +1,10 @@\n+-include ../../run-make-fulldeps/tools.mk\n+\n+ifeq ($(TARGET),wasm32-unknown-unknown)\n+all:\n+\t$(RUSTC) foo.rs --target wasm32-unknown-unknown\n+\t$(RUSTC) bar.rs -C lto -O --target wasm32-unknown-unknown\n+\t$(NODE) foo.js $(TMPDIR)/bar.wasm\n+else\n+all:\n+endif"}, {"sha": "9e659223c651c8835a16ebbf302da480647784c4", "filename": "src/test/run-make/wasm-import-module/bar.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Frun-make%2Fwasm-import-module%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Frun-make%2Fwasm-import-module%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-import-module%2Fbar.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"cdylib\"]\n+#![feature(wasm_import_module)]\n+#![deny(warnings)]\n+\n+extern crate foo;\n+\n+#[wasm_import_module = \"./me\"]\n+extern {\n+    #[link_name = \"me_in_dep\"]\n+    fn dep();\n+}\n+\n+#[no_mangle]\n+pub extern fn foo() {\n+    unsafe {\n+        foo::dep();\n+        dep();\n+    }\n+}"}, {"sha": "369962e55b1eb68f5b6ff73e7b48635e7d417e02", "filename": "src/test/run-make/wasm-import-module/foo.js", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Frun-make%2Fwasm-import-module%2Ffoo.js", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Frun-make%2Fwasm-import-module%2Ffoo.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-import-module%2Ffoo.js?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const fs = require('fs');\n+const process = require('process');\n+const assert = require('assert');\n+const buffer = fs.readFileSync(process.argv[2]);\n+\n+let m = new WebAssembly.Module(buffer);\n+let imports = WebAssembly.Module.imports(m);\n+console.log('imports', imports);\n+assert.strictEqual(imports.length, 2);\n+\n+assert.strictEqual(imports[0].kind, 'function');\n+assert.strictEqual(imports[1].kind, 'function');\n+\n+let modules = [imports[0].module, imports[1].module];\n+modules.sort();\n+\n+assert.strictEqual(modules[0], './dep');\n+assert.strictEqual(modules[1], './me');"}, {"sha": "bcd2ca70befaa4d30793b02747bc496acd820db4", "filename": "src/test/run-make/wasm-import-module/foo.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Frun-make%2Fwasm-import-module%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Frun-make%2Fwasm-import-module%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fwasm-import-module%2Ffoo.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+#![feature(wasm_import_module)]\n+#![deny(warnings)]\n+\n+#[wasm_import_module = \"./dep\"]\n+extern {\n+    pub fn dep();\n+}"}, {"sha": "1b4415539f44923fb0c2e9e2d0c63b8d475e654b", "filename": "src/test/ui/feature-gate-wasm_custom_section.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Fui%2Ffeature-gate-wasm_custom_section.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Fui%2Ffeature-gate-wasm_custom_section.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-wasm_custom_section.stderr?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -8,4 +8,4 @@ LL | #[wasm_custom_section = \"foo\"] //~ ERROR: attribute is currently unstable\n \n error: aborting due to previous error\n \n-If you want more information on this error, try using \"rustc --explain E0658\"\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "c5898a9c12697a4dbcb51a064986459464b7bc9e", "filename": "src/test/ui/feature-gate-wasm_import_module.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_module.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[wasm_import_module = \"test\"] //~ ERROR: experimental\n+extern {\n+}\n+\n+fn main() {}"}, {"sha": "bae5fa9d5956cd922c8ff24bb33242ef4918986c", "filename": "src/test/ui/feature-gate-wasm_import_module.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-wasm_import_module.stderr?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: experimental attribute\n+  --> $DIR/feature-gate-wasm_import_module.rs:11:1\n+   |\n+LL | #[wasm_import_module = \"test\"] //~ ERROR: experimental\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(wasm_import_module)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "0b743d9e486b6aa79eb89b0eba01ea8764405d8e", "filename": "src/test/ui/wasm-import-module.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Fui%2Fwasm-import-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Fui%2Fwasm-import-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwasm-import-module.rs?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(wasm_import_module)]\n+\n+#[wasm_import_module] //~ ERROR: must be of the form\n+extern {}\n+\n+#[wasm_import_module = \"foo\"] //~ ERROR: must only be attached to\n+fn foo() {}\n+\n+fn main() {}\n+"}, {"sha": "bf301ce5269a7f7f103e856ab2a972e0de7c9501", "filename": "src/test/ui/wasm-import-module.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Fui%2Fwasm-import-module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d889957dab5ee0778f9dd64faeafc8872645efed/src%2Ftest%2Fui%2Fwasm-import-module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwasm-import-module.stderr?ref=d889957dab5ee0778f9dd64faeafc8872645efed", "patch": "@@ -0,0 +1,14 @@\n+error: must be of the form #[wasm_import_module = \"...\"]\n+  --> $DIR/wasm-import-module.rs:13:1\n+   |\n+LL | #[wasm_import_module] //~ ERROR: must be of the form\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: must only be attached to foreign modules\n+  --> $DIR/wasm-import-module.rs:16:1\n+   |\n+LL | #[wasm_import_module = \"foo\"] //~ ERROR: must only be attached to\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}]}