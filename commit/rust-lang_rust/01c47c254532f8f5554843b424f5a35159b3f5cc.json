{"sha": "01c47c254532f8f5554843b424f5a35159b3f5cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxYzQ3YzI1NDUzMmY4ZjU1NTQ4NDNiNDI0ZjVhMzUxNTliM2Y1Y2M=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-11-29T20:00:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-11-30T15:14:10Z"}, "message": "rustc: Tweak the `isExported` callback for ThinLTO\n\nPreviously we were too eagerly exporting almost all symbols used in ThinLTO\nwhich can cause a whole host of problems downstream! This commit instead fixes\nthis error by aligning more closely with `lib/LTO/LTO.cpp` in LLVM's codebase\nwhich is to only change the linkage of summaries which are computed as dead.\n\nCloses #46374", "tree": {"sha": "eb33b2e54dba93114f91996b9366269887fdba43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb33b2e54dba93114f91996b9366269887fdba43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01c47c254532f8f5554843b424f5a35159b3f5cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01c47c254532f8f5554843b424f5a35159b3f5cc", "html_url": "https://github.com/rust-lang/rust/commit/01c47c254532f8f5554843b424f5a35159b3f5cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01c47c254532f8f5554843b424f5a35159b3f5cc/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fa202d23b4c8c81b8ac6cf89cf843d35854d437", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fa202d23b4c8c81b8ac6cf89cf843d35854d437", "html_url": "https://github.com/rust-lang/rust/commit/4fa202d23b4c8c81b8ac6cf89cf843d35854d437"}], "stats": {"total": 110, "additions": 23, "deletions": 87}, "files": [{"sha": "1e52ad571b8ecd072f44c20f2816830378bafc8c", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 23, "deletions": 87, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/01c47c254532f8f5554843b424f5a35159b3f5cc/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/01c47c254532f8f5554843b424f5a35159b3f5cc/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=01c47c254532f8f5554843b424f5a35159b3f5cc", "patch": "@@ -11,6 +11,7 @@\n #include <stdio.h>\n \n #include <vector>\n+#include <set>\n \n #include \"rustllvm.h\"\n \n@@ -885,86 +886,6 @@ getFirstDefinitionForLinker(const GlobalValueSummaryList &GVSummaryList) {\n   return FirstDefForLinker->get();\n }\n \n-// This is a helper function we added that isn't present in LLVM's source.\n-//\n-// The way LTO works in Rust is that we typically have a number of symbols that\n-// we know ahead of time need to be preserved. We want to ensure that ThinLTO\n-// doesn't accidentally internalize any of these and otherwise is always\n-// ready to keep them linking correctly.\n-//\n-// This function will recursively walk the `GUID` provided and all of its\n-// references, as specified in the `Index`. In other words, we're taking a\n-// `GUID` as input, adding it to `Preserved`, and then taking all `GUID`\n-// items that the input references and recursing.\n-static void\n-addPreservedGUID(const ModuleSummaryIndex &Index,\n-                 DenseSet<GlobalValue::GUID> &Preserved,\n-                 GlobalValue::GUID GUID) {\n-  if (Preserved.count(GUID))\n-    return;\n-  Preserved.insert(GUID);\n-\n-#if LLVM_VERSION_GE(5, 0)\n-  auto Info = Index.getValueInfo(GUID);\n-  if (!Info) {\n-    return;\n-  }\n-  for (auto &Summary : Info.getSummaryList()) {\n-    for (auto &Ref : Summary->refs()) {\n-      addPreservedGUID(Index, Preserved, Ref.getGUID());\n-    }\n-\n-    GlobalValueSummary *GVSummary = Summary.get();\n-    if (isa<FunctionSummary>(GVSummary)) {\n-      auto *FS = cast<FunctionSummary>(GVSummary);\n-      for (auto &Call: FS->calls()) {\n-        addPreservedGUID(Index, Preserved, Call.first.getGUID());\n-      }\n-      for (auto &GUID: FS->type_tests()) {\n-        addPreservedGUID(Index, Preserved, GUID);\n-      }\n-    }\n-    if (isa<AliasSummary>(GVSummary)) {\n-      auto *AS = cast<AliasSummary>(GVSummary);\n-      auto GUID = AS->getAliasee().getOriginalName();\n-      addPreservedGUID(Index, Preserved, GUID);\n-    }\n-  }\n-#else\n-  auto SummaryList = Index.findGlobalValueSummaryList(GUID);\n-  if (SummaryList == Index.end())\n-    return;\n-  for (auto &Summary : SummaryList->second) {\n-    for (auto &Ref : Summary->refs()) {\n-      if (Ref.isGUID()) {\n-        addPreservedGUID(Index, Preserved, Ref.getGUID());\n-      } else {\n-        auto Value = Ref.getValue();\n-        addPreservedGUID(Index, Preserved, Value->getGUID());\n-      }\n-    }\n-\n-    if (auto *FS = dyn_cast<FunctionSummary>(Summary.get())) {\n-      for (auto &Call: FS->calls()) {\n-        if (Call.first.isGUID()) {\n-          addPreservedGUID(Index, Preserved, Call.first.getGUID());\n-        } else {\n-          auto Value = Call.first.getValue();\n-          addPreservedGUID(Index, Preserved, Value->getGUID());\n-        }\n-      }\n-      for (auto &GUID: FS->type_tests()) {\n-        addPreservedGUID(Index, Preserved, GUID);\n-      }\n-    }\n-    if (auto *AS = dyn_cast<AliasSummary>(Summary.get())) {\n-      auto GUID = AS->getAliasee().getOriginalName();\n-      addPreservedGUID(Index, Preserved, GUID);\n-    }\n-  }\n-#endif\n-}\n-\n // The main entry point for creating the global ThinLTO analysis. The structure\n // here is basically the same as before threads are spawned in the `run`\n // function of `lib/LTO/ThinLTOCodeGenerator.cpp`.\n@@ -1004,12 +925,10 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n   Ret->Index.collectDefinedGVSummariesPerModule(Ret->ModuleToDefinedGVSummaries);\n \n   // Convert the preserved symbols set from string to GUID, this is then needed\n-  // for internalization. We use `addPreservedGUID` to include any transitively\n-  // used symbol as well.\n+  // for internalization.\n   for (int i = 0; i < num_symbols; i++) {\n-    addPreservedGUID(Ret->Index,\n-                     Ret->GUIDPreservedSymbols,\n-                     GlobalValue::getGUID(preserved_symbols[i]));\n+    auto GUID = GlobalValue::getGUID(preserved_symbols[i]);\n+    Ret->GUIDPreservedSymbols.insert(GUID);\n   }\n \n   // Collect the import/export lists for all modules from the call-graph in the\n@@ -1038,7 +957,8 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n   // Resolve LinkOnce/Weak symbols, this has to be computed early be cause it\n   // impacts the caching.\n   //\n-  // This is copied from `lib/LTO/ThinLTOCodeGenerator.cpp`\n+  // This is copied from `lib/LTO/ThinLTOCodeGenerator.cpp` with some of this\n+  // being lifted from `lib/LTO/LTO.cpp` as well\n   StringMap<std::map<GlobalValue::GUID, GlobalValue::LinkageTypes>> ResolvedODR;\n   DenseMap<GlobalValue::GUID, const GlobalValueSummary *> PrevailingCopy;\n   for (auto &I : Ret->Index) {\n@@ -1062,11 +982,27 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n     ResolvedODR[ModuleIdentifier][GUID] = NewLinkage;\n   };\n   thinLTOResolveWeakForLinkerInIndex(Ret->Index, isPrevailing, recordNewLinkage);\n+\n+  // Here we calculate an `ExportedGUIDs` set for use in the `isExported`\n+  // callback below. This callback below will dictate the linkage for all\n+  // summaries in the index, and we basically just only want to ensure that dead\n+  // symbols are internalized. Otherwise everything that's already external\n+  // linkage will stay as external, and internal will stay as internal.\n+  std::set<GlobalValue::GUID> ExportedGUIDs;\n+  for (auto &List : Ret->Index) {\n+    for (auto &GVS: List.second) {\n+      if (!GlobalValue::isExternalLinkage(GVS->linkage()))\n+        continue;\n+      auto GUID = GVS->getOriginalName();\n+      if (!DeadSymbols.count(GUID))\n+        ExportedGUIDs.insert(GUID);\n+    }\n+  }\n   auto isExported = [&](StringRef ModuleIdentifier, GlobalValue::GUID GUID) {\n     const auto &ExportList = Ret->ExportLists.find(ModuleIdentifier);\n     return (ExportList != Ret->ExportLists.end() &&\n       ExportList->second.count(GUID)) ||\n-      Ret->GUIDPreservedSymbols.count(GUID);\n+      ExportedGUIDs.count(GUID);\n   };\n   thinLTOInternalizeAndPromoteInIndex(Ret->Index, isExported);\n "}]}