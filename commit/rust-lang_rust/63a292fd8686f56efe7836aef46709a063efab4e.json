{"sha": "63a292fd8686f56efe7836aef46709a063efab4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzYTI5MmZkODY4NmY1NmVmZTc4MzZhZWY0NjcwOWEwNjNlZmFiNGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-20T13:45:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-20T13:45:51Z"}, "message": "auto merge of #5434 : apasel422/rust/deriving, r=nikomatsakis\n\nThis is the first step in refactoring the deriving code in libsyntax. No code is changed, just rearranged.", "tree": {"sha": "18d2da888a1c14d637900649ff426631f0178390", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18d2da888a1c14d637900649ff426631f0178390"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63a292fd8686f56efe7836aef46709a063efab4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63a292fd8686f56efe7836aef46709a063efab4e", "html_url": "https://github.com/rust-lang/rust/commit/63a292fd8686f56efe7836aef46709a063efab4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63a292fd8686f56efe7836aef46709a063efab4e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2024306874475b649f28145c75e124a247ee113", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2024306874475b649f28145c75e124a247ee113", "html_url": "https://github.com/rust-lang/rust/commit/c2024306874475b649f28145c75e124a247ee113"}, {"sha": "3042321b3bf6bc9435c274f278798871959ce58b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3042321b3bf6bc9435c274f278798871959ce58b", "html_url": "https://github.com/rust-lang/rust/commit/3042321b3bf6bc9435c274f278798871959ce58b"}], "stats": {"total": 2629, "additions": 1358, "deletions": 1271}, "files": [{"sha": "447ca71dc6b9fa77bd1622c0150cfe0df0aee9c3", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63a292fd8686f56efe7836aef46709a063efab4e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63a292fd8686f56efe7836aef46709a063efab4e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=63a292fd8686f56efe7836aef46709a063efab4e", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -153,13 +153,13 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                                 ext::deriving::expand_meta_deriving)));\n     syntax_expanders.insert(@~\"deriving_eq\",\n                             @SE(ItemDecorator(\n-                                ext::deriving::expand_deriving_eq)));\n+                                ext::deriving::eq::expand_deriving_eq)));\n     syntax_expanders.insert(@~\"deriving_iter_bytes\",\n                             @SE(ItemDecorator(\n-                                ext::deriving::expand_deriving_iter_bytes)));\n+                                ext::deriving::iter_bytes::expand_deriving_iter_bytes)));\n     syntax_expanders.insert(@~\"deriving_clone\",\n                             @SE(ItemDecorator(\n-                                ext::deriving::expand_deriving_clone)));\n+                                ext::deriving::clone::expand_deriving_clone)));\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(@~\"quote_tokens\","}, {"sha": "a6165e50c854585eda567ee3c7699650fe26dd53", "filename": "src/libsyntax/ext/deriving.rs", "status": "removed", "additions": 0, "deletions": 1267, "changes": 1267, "blob_url": "https://github.com/rust-lang/rust/blob/c2024306874475b649f28145c75e124a247ee113/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2024306874475b649f28145c75e124a247ee113/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=c2024306874475b649f28145c75e124a247ee113", "patch": "@@ -1,1267 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// The compiler code necessary to implement the #[deriving_eq] and\n-/// #[deriving_iter_bytes] extensions.\n-\n-use core::prelude::*;\n-\n-use ast;\n-use ast::{TraitTyParamBound, Ty, and, bind_by_ref, binop, deref, enum_def};\n-use ast::{enum_variant_kind, expr, expr_match, ident, impure_fn, item, item_};\n-use ast::{item_enum, item_impl, item_struct, Generics};\n-use ast::{m_imm, meta_item, method};\n-use ast::{named_field, or, pat, pat_ident, pat_wild, public, pure_fn};\n-use ast::{stmt, struct_def, struct_variant_kind};\n-use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, TyParam};\n-use ast::{TyParamBound, ty_path, ty_rptr, unnamed_field, variant};\n-use ext::base::ext_ctxt;\n-use ext::build;\n-use codemap::{span, spanned};\n-use parse::token::special_idents::clownshoes_extensions;\n-use ast_util;\n-use opt_vec;\n-\n-use core::uint;\n-\n-enum Junction {\n-    Conjunction,\n-    Disjunction,\n-}\n-\n-pub impl Junction {\n-    fn to_binop(self) -> binop {\n-        match self {\n-            Conjunction => and,\n-            Disjunction => or,\n-        }\n-    }\n-}\n-\n-type ExpandDerivingStructDefFn = &'self fn(@ext_ctxt,\n-                                          span,\n-                                          x: &struct_def,\n-                                          ident,\n-                                          y: &Generics) -> @item;\n-type ExpandDerivingEnumDefFn = &'self fn(@ext_ctxt,\n-                                        span,\n-                                        x: &enum_def,\n-                                        ident,\n-                                        y: &Generics) -> @item;\n-\n-pub fn expand_meta_deriving(cx: @ext_ctxt,\n-                            _span: span,\n-                            mitem: @meta_item,\n-                            in_items: ~[@item])\n-                         -> ~[@item] {\n-    use ast::{meta_list, meta_name_value, meta_word};\n-\n-    match mitem.node {\n-        meta_name_value(_, l) => {\n-            cx.span_err(l.span, ~\"unexpected value in `deriving`\");\n-            in_items\n-        }\n-        meta_word(_) | meta_list(_, []) => {\n-            cx.span_warn(mitem.span, ~\"empty trait list in `deriving`\");\n-            in_items\n-        }\n-        meta_list(_, titems) => {\n-            do titems.foldr(in_items) |&titem, in_items| {\n-                match titem.node {\n-                    meta_name_value(tname, _) |\n-                    meta_list(tname, _) |\n-                    meta_word(tname) => {\n-                        match *tname {\n-                            ~\"Clone\" => expand_deriving_clone(cx,\n-                                titem.span, titem, in_items),\n-                            ~\"Eq\" => expand_deriving_eq(cx, titem.span,\n-                                titem, in_items),\n-                            ~\"IterBytes\" => expand_deriving_iter_bytes(cx,\n-                                titem.span, titem, in_items),\n-                            tname => {\n-                                cx.span_err(titem.span, fmt!(\"unknown \\\n-                                    `deriving` trait: `%s`\", tname));\n-                                in_items\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub fn expand_deriving_eq(cx: @ext_ctxt,\n-                          span: span,\n-                          _mitem: @meta_item,\n-                          in_items: ~[@item])\n-                       -> ~[@item] {\n-    expand_deriving(cx,\n-                    span,\n-                    in_items,\n-                    expand_deriving_eq_struct_def,\n-                    expand_deriving_eq_enum_def)\n-}\n-\n-pub fn expand_deriving_iter_bytes(cx: @ext_ctxt,\n-                                  span: span,\n-                                  _mitem: @meta_item,\n-                                  in_items: ~[@item])\n-                               -> ~[@item] {\n-    expand_deriving(cx,\n-                    span,\n-                    in_items,\n-                    expand_deriving_iter_bytes_struct_def,\n-                    expand_deriving_iter_bytes_enum_def)\n-}\n-\n-pub fn expand_deriving_clone(cx: @ext_ctxt,\n-                             span: span,\n-                             _: @meta_item,\n-                             in_items: ~[@item])\n-                          -> ~[@item] {\n-    expand_deriving(cx,\n-                    span,\n-                    in_items,\n-                    expand_deriving_clone_struct_def,\n-                    expand_deriving_clone_enum_def)\n-}\n-\n-fn expand_deriving(cx: @ext_ctxt,\n-                   span: span,\n-                   in_items: ~[@item],\n-                   expand_deriving_struct_def: ExpandDerivingStructDefFn,\n-                   expand_deriving_enum_def: ExpandDerivingEnumDefFn)\n-                -> ~[@item] {\n-    let mut result = ~[];\n-    for in_items.each |item| {\n-        result.push(copy *item);\n-        match item.node {\n-            item_struct(struct_def, ref generics) => {\n-                result.push(expand_deriving_struct_def(cx,\n-                                                       span,\n-                                                       struct_def,\n-                                                       item.ident,\n-                                                       generics));\n-            }\n-            item_enum(ref enum_definition, ref generics) => {\n-                result.push(expand_deriving_enum_def(cx,\n-                                                     span,\n-                                                     enum_definition,\n-                                                     item.ident,\n-                                                     generics));\n-            }\n-            _ => ()\n-        }\n-    }\n-    result\n-}\n-\n-fn create_impl_item(cx: @ext_ctxt, span: span, +item: item_) -> @item {\n-    @ast::item {\n-        ident: clownshoes_extensions,\n-        attrs: ~[],\n-        id: cx.next_id(),\n-        node: item,\n-        vis: public,\n-        span: span,\n-    }\n-}\n-\n-/// Creates a method from the given expression, the signature of which\n-/// conforms to the `eq` or `ne` method.\n-fn create_eq_method(cx: @ext_ctxt,\n-                    span: span,\n-                    method_ident: ident,\n-                    type_ident: ident,\n-                    generics: &Generics,\n-                    body: @expr)\n-                 -> @method {\n-    // Create the type of the `other` parameter.\n-    let arg_path_type = create_self_type_with_params(cx,\n-                                                     span,\n-                                                     type_ident,\n-                                                     generics);\n-    let arg_type = ty_rptr(\n-        None,\n-        ast::mt { ty: arg_path_type, mutbl: m_imm }\n-    );\n-    let arg_type = @ast::Ty {\n-        id: cx.next_id(),\n-        node: arg_type,\n-        span: span,\n-    };\n-\n-    // Create the `other` parameter.\n-    let other_ident = cx.ident_of(~\"__other\");\n-    let arg = build::mk_arg(cx, span, other_ident, arg_type);\n-\n-    // Create the type of the return value.\n-    let bool_ident = cx.ident_of(~\"bool\");\n-    let output_type = build::mk_raw_path(span, ~[ bool_ident ]);\n-    let output_type = ty_path(output_type, cx.next_id());\n-    let output_type = @ast::Ty {\n-        id: cx.next_id(),\n-        node: output_type,\n-        span: span,\n-    };\n-\n-    // Create the function declaration.\n-    let fn_decl = build::mk_fn_decl(~[ arg ], output_type);\n-\n-    // Create the body block.\n-    let body_block = build::mk_simple_block(cx, span, body);\n-\n-    // Create the method.\n-    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public\n-    }\n-}\n-\n-fn create_self_type_with_params(cx: @ext_ctxt,\n-                                span: span,\n-                                type_ident: ident,\n-                                generics: &Generics)\n-                             -> @Ty {\n-    // Create the type parameters on the `self` path.\n-    let mut self_ty_params = ~[];\n-    for generics.ty_params.each |ty_param| {\n-        let self_ty_param = build::mk_simple_ty_path(cx,\n-                                                     span,\n-                                                     ty_param.ident);\n-        self_ty_params.push(self_ty_param);\n-    }\n-\n-    // Create the type of `self`.\n-    let self_type = build::mk_raw_path_(span,\n-                                        ~[ type_ident ],\n-                                        self_ty_params);\n-    let self_type = ty_path(self_type, cx.next_id());\n-    @ast::Ty { id: cx.next_id(), node: self_type, span: span }\n-}\n-\n-fn create_derived_impl(cx: @ext_ctxt,\n-                       span: span,\n-                       type_ident: ident,\n-                       generics: &Generics,\n-                       methods: &[@method],\n-                       trait_path: &[ident])\n-                    -> @item {\n-    /*!\n-     *\n-     * Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n-     * 'z, A, ..., Z>`, creates an impl like:\n-     *\n-     *      impl<'a, ..., 'z, A:Tr, ..., Z: Tr> Tr for T<A, ..., Z> { ... }\n-     *\n-     * FIXME(#5090): Remove code duplication between this and the\n-     * code in auto_encode.rs\n-     */\n-\n-    // Copy the lifetimes\n-    let impl_lifetimes = generics.lifetimes.map(|l| {\n-        build::mk_lifetime(cx, l.span, l.ident)\n-    });\n-\n-    // Create the type parameters.\n-    let impl_ty_params = generics.ty_params.map(|ty_param| {\n-        let bound = build::mk_ty_path_global(cx,\n-                                             span,\n-                                             trait_path.map(|x| *x));\n-        let bounds = @opt_vec::with(TraitTyParamBound(bound));\n-        build::mk_ty_param(cx, ty_param.ident, bounds)\n-    });\n-\n-    // Create the reference to the trait.\n-    let trait_path = ast::path {\n-        span: span,\n-        global: true,\n-        idents: trait_path.map(|x| *x),\n-        rp: None,\n-        types: ~[]\n-    };\n-    let trait_path = @trait_path;\n-    let trait_ref = ast::trait_ref {\n-        path: trait_path,\n-        ref_id: cx.next_id()\n-    };\n-    let trait_ref = @trait_ref;\n-\n-    // Create the type of `self`.\n-    let self_type = create_self_type_with_params(cx,\n-                                                 span,\n-                                                 type_ident,\n-                                                 generics);\n-\n-    // Create the impl item.\n-    let impl_item = item_impl(Generics {lifetimes: impl_lifetimes,\n-                                        ty_params: impl_ty_params},\n-                              Some(trait_ref),\n-                              self_type,\n-                              methods.map(|x| *x));\n-    return create_impl_item(cx, span, impl_item);\n-}\n-\n-fn create_derived_eq_impl(cx: @ext_ctxt,\n-                          span: span,\n-                          type_ident: ident,\n-                          generics: &Generics,\n-                          eq_method: @method,\n-                          ne_method: @method)\n-                       -> @item {\n-    let methods = [ eq_method, ne_method ];\n-    let trait_path = [\n-        cx.ident_of(~\"core\"),\n-        cx.ident_of(~\"cmp\"),\n-        cx.ident_of(~\"Eq\")\n-    ];\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n-}\n-\n-fn create_derived_iter_bytes_impl(cx: @ext_ctxt,\n-                                  span: span,\n-                                  type_ident: ident,\n-                                  generics: &Generics,\n-                                  method: @method)\n-                               -> @item {\n-    let methods = [ method ];\n-    let trait_path = [\n-        cx.ident_of(~\"core\"),\n-        cx.ident_of(~\"to_bytes\"),\n-        cx.ident_of(~\"IterBytes\")\n-    ];\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n-}\n-\n-fn create_derived_clone_impl(cx: @ext_ctxt,\n-                             span: span,\n-                             type_ident: ident,\n-                             generics: &Generics,\n-                             method: @method)\n-                          -> @item {\n-    let methods = [ method ];\n-    let trait_path = [\n-        cx.ident_of(~\"core\"),\n-        cx.ident_of(~\"clone\"),\n-        cx.ident_of(~\"Clone\"),\n-    ];\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n-}\n-\n-// Creates a method from the given set of statements conforming to the\n-// signature of the `iter_bytes` method.\n-fn create_iter_bytes_method(cx: @ext_ctxt,\n-                            span: span,\n-                            +statements: ~[@stmt])\n-                         -> @method {\n-    // Create the `lsb0` parameter.\n-    let bool_ident = cx.ident_of(~\"bool\");\n-    let lsb0_arg_type = build::mk_simple_ty_path(cx, span, bool_ident);\n-    let lsb0_ident = cx.ident_of(~\"__lsb0\");\n-    let lsb0_arg = build::mk_arg(cx, span, lsb0_ident, lsb0_arg_type);\n-\n-    // Create the `f` parameter.\n-    let core_ident = cx.ident_of(~\"core\");\n-    let to_bytes_ident = cx.ident_of(~\"to_bytes\");\n-    let cb_ident = cx.ident_of(~\"Cb\");\n-    let core_to_bytes_cb_ident = ~[ core_ident, to_bytes_ident, cb_ident ];\n-    let f_arg_type = build::mk_ty_path(cx, span, core_to_bytes_cb_ident);\n-    let f_ident = cx.ident_of(~\"__f\");\n-    let f_arg = build::mk_arg(cx, span, f_ident, f_arg_type);\n-\n-    // Create the type of the return value.\n-    let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n-\n-    // Create the function declaration.\n-    let inputs = ~[ lsb0_arg, f_arg ];\n-    let fn_decl = build::mk_fn_decl(inputs, output_type);\n-\n-    // Create the body block.\n-    let body_block = build::mk_block_(cx, span, statements);\n-\n-    // Create the method.\n-    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n-    let method_ident = cx.ident_of(~\"iter_bytes\");\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public\n-    }\n-}\n-\n-// Creates a method from the given expression conforming to the signature of\n-// the `clone` method.\n-fn create_clone_method(cx: @ext_ctxt,\n-                       span: span,\n-                       +type_ident: ast::ident,\n-                       generics: &Generics,\n-                       expr: @ast::expr)\n-                    -> @method {\n-    // Create the type parameters of the return value.\n-    let mut output_ty_params = ~[];\n-    for generics.ty_params.each |ty_param| {\n-        let path = build::mk_ty_path(cx, span, ~[ ty_param.ident ]);\n-        output_ty_params.push(path);\n-    }\n-\n-    // Create the type of the return value.\n-    let output_type_path = build::mk_raw_path_(span,\n-                                               ~[ type_ident ],\n-                                               output_ty_params);\n-    let output_type = ast::ty_path(output_type_path, cx.next_id());\n-    let output_type = @ast::Ty {\n-        id: cx.next_id(),\n-        node: output_type,\n-        span: span\n-    };\n-\n-    // Create the function declaration.\n-    let fn_decl = build::mk_fn_decl(~[], output_type);\n-\n-    // Create the body block.\n-    let body_block = build::mk_simple_block(cx, span, expr);\n-\n-    // Create the self type and method identifier.\n-    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n-    let method_ident = cx.ident_of(~\"clone\");\n-\n-    // Create the method.\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        self_ty: self_ty,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public,\n-    }\n-}\n-\n-fn create_subpatterns(cx: @ext_ctxt,\n-                      span: span,\n-                      prefix: ~str,\n-                      n: uint)\n-                   -> ~[@pat] {\n-    let mut subpats = ~[];\n-    for uint::range(0, n) |_i| {\n-        // Create the subidentifier.\n-        let index = subpats.len().to_str();\n-        let ident = cx.ident_of(prefix + index);\n-\n-        // Create the subpattern.\n-        let subpath = build::mk_raw_path(span, ~[ ident ]);\n-        let subpat = pat_ident(bind_by_ref(m_imm), subpath, None);\n-        let subpat = build::mk_pat(cx, span, subpat);\n-        subpats.push(subpat);\n-    }\n-    return subpats;\n-}\n-\n-fn is_struct_tuple(struct_def: &struct_def) -> bool {\n-    struct_def.fields.len() > 0 && struct_def.fields.all(|f| {\n-        match f.node.kind {\n-            named_field(*) => false,\n-            unnamed_field => true\n-        }\n-    })\n-}\n-\n-fn create_enum_variant_pattern(cx: @ext_ctxt,\n-                               span: span,\n-                               variant: &variant,\n-                               prefix: ~str)\n-                            -> @pat {\n-    let variant_ident = variant.node.name;\n-    match variant.node.kind {\n-        tuple_variant_kind(ref variant_args) => {\n-            if variant_args.len() == 0 {\n-                return build::mk_pat_ident_with_binding_mode(\n-                    cx, span, variant_ident, ast::bind_infer);\n-            }\n-\n-            let matching_path = build::mk_raw_path(span, ~[ variant_ident ]);\n-            let subpats = create_subpatterns(cx,\n-                                             span,\n-                                             prefix,\n-                                             variant_args.len());\n-\n-            return build::mk_pat_enum(cx, span, matching_path, subpats);\n-        }\n-        struct_variant_kind(struct_def) => {\n-            let matching_path = build::mk_raw_path(span, ~[ variant_ident ]);\n-            let subpats = create_subpatterns(cx,\n-                                             span,\n-                                             prefix,\n-                                             struct_def.fields.len());\n-\n-            let field_pats = do struct_def.fields.mapi |i, struct_field| {\n-                let ident = match struct_field.node.kind {\n-                    named_field(ident, _, _) => ident,\n-                    unnamed_field => {\n-                        cx.span_bug(span, ~\"unexpected unnamed field\");\n-                    }\n-                };\n-                ast::field_pat { ident: ident, pat: subpats[i] }\n-            };\n-\n-            build::mk_pat_struct(cx, span, matching_path, field_pats)\n-        }\n-        enum_variant_kind(*) => {\n-            cx.span_unimpl(span, ~\"enum variants for `deriving`\");\n-        }\n-    }\n-}\n-\n-fn call_substructure_eq_method(cx: @ext_ctxt,\n-                               span: span,\n-                               self_field: @expr,\n-                               other_field_ref: @expr,\n-                               method_ident: ident,\n-                               junction: Junction,\n-                               chain_expr: &mut Option<@expr>) {\n-    // Call the substructure method.\n-    let self_method = build::mk_access_(cx, span, self_field, method_ident);\n-    let self_call = build::mk_call_(cx,\n-                                    span,\n-                                    self_method,\n-                                    ~[ other_field_ref ]);\n-\n-    // Connect to the outer expression if necessary.\n-    *chain_expr = match *chain_expr {\n-        None => Some(self_call),\n-        Some(copy old_outer_expr) => {\n-            let binop = junction.to_binop();\n-            let chain_expr = build::mk_binary(cx,\n-                                              span,\n-                                              binop,\n-                                              old_outer_expr,\n-                                              self_call);\n-            Some(chain_expr)\n-        }\n-    };\n-}\n-\n-fn finish_eq_chain_expr(cx: @ext_ctxt,\n-                        span: span,\n-                        chain_expr: Option<@expr>,\n-                        junction: Junction)\n-                     -> @expr {\n-    match chain_expr {\n-        None => {\n-            match junction {\n-                Conjunction => build::mk_bool(cx, span, true),\n-                Disjunction => build::mk_bool(cx, span, false),\n-            }\n-        }\n-        Some(ref outer_expr) => *outer_expr,\n-    }\n-}\n-\n-fn call_substructure_iter_bytes_method(cx: @ext_ctxt,\n-                                       span: span,\n-                                       self_field: @expr)\n-                                    -> @stmt {\n-    // Gather up the parameters we want to chain along.\n-    let lsb0_ident = cx.ident_of(~\"__lsb0\");\n-    let f_ident = cx.ident_of(~\"__f\");\n-    let lsb0_expr = build::mk_path(cx, span, ~[ lsb0_ident ]);\n-    let f_expr = build::mk_path(cx, span, ~[ f_ident ]);\n-\n-    // Call the substructure method.\n-    let iter_bytes_ident = cx.ident_of(~\"iter_bytes\");\n-    let self_method = build::mk_access_(cx,\n-                                        span,\n-                                        self_field,\n-                                        iter_bytes_ident);\n-    let self_call = build::mk_call_(cx,\n-                                    span,\n-                                    self_method,\n-                                    ~[ lsb0_expr, f_expr ]);\n-\n-    // Create a statement out of this expression.\n-    build::mk_stmt(cx, span, self_call)\n-}\n-\n-fn call_substructure_clone_method(cx: @ext_ctxt,\n-                                  span: span,\n-                                  self_field: @expr)\n-                               -> @expr {\n-    // Call the substructure method.\n-    let clone_ident = cx.ident_of(~\"clone\");\n-    let self_method = build::mk_access_(cx, span, self_field, clone_ident);\n-    build::mk_call_(cx, span, self_method, ~[])\n-}\n-\n-fn variant_arg_count(cx: @ext_ctxt, span: span, variant: &variant) -> uint {\n-    match variant.node.kind {\n-        tuple_variant_kind(ref args) => args.len(),\n-        struct_variant_kind(ref struct_def) => struct_def.fields.len(),\n-        enum_variant_kind(*) => {\n-            cx.span_bug(span, ~\"variant_arg_count: enum variants deprecated\")\n-        }\n-    }\n-}\n-\n-fn expand_deriving_eq_struct_def(cx: @ext_ctxt,\n-                                 span: span,\n-                                 struct_def: &struct_def,\n-                                 type_ident: ident,\n-                                 generics: &Generics)\n-                              -> @item {\n-    // Create the methods.\n-    let eq_ident = cx.ident_of(~\"eq\");\n-    let ne_ident = cx.ident_of(~\"ne\");\n-\n-    let derive_struct_fn = if is_struct_tuple(struct_def) {\n-        expand_deriving_eq_struct_tuple_method\n-    } else {\n-        expand_deriving_eq_struct_method\n-    };\n-\n-    let eq_method = derive_struct_fn(cx,\n-                                     span,\n-                                     struct_def,\n-                                     eq_ident,\n-                                     type_ident,\n-                                     generics,\n-                                     Conjunction);\n-    let ne_method = derive_struct_fn(cx,\n-                                     span,\n-                                     struct_def,\n-                                     ne_ident,\n-                                     type_ident,\n-                                     generics,\n-                                     Disjunction);\n-\n-    // Create the implementation.\n-    return create_derived_eq_impl(cx,\n-                                  span,\n-                                  type_ident,\n-                                  generics,\n-                                  eq_method,\n-                                  ne_method);\n-}\n-\n-fn expand_deriving_eq_enum_def(cx: @ext_ctxt,\n-                               span: span,\n-                               enum_definition: &enum_def,\n-                               type_ident: ident,\n-                               generics: &Generics)\n-                            -> @item {\n-    // Create the methods.\n-    let eq_ident = cx.ident_of(~\"eq\");\n-    let ne_ident = cx.ident_of(~\"ne\");\n-    let eq_method = expand_deriving_eq_enum_method(cx,\n-                                                   span,\n-                                                   enum_definition,\n-                                                   eq_ident,\n-                                                   type_ident,\n-                                                   generics,\n-                                                   Conjunction);\n-    let ne_method = expand_deriving_eq_enum_method(cx,\n-                                                   span,\n-                                                   enum_definition,\n-                                                   ne_ident,\n-                                                   type_ident,\n-                                                   generics,\n-                                                   Disjunction);\n-\n-    // Create the implementation.\n-    return create_derived_eq_impl(cx,\n-                                  span,\n-                                  type_ident,\n-                                  generics,\n-                                  eq_method,\n-                                  ne_method);\n-}\n-\n-fn expand_deriving_iter_bytes_struct_def(cx: @ext_ctxt,\n-                                         span: span,\n-                                         struct_def: &struct_def,\n-                                         type_ident: ident,\n-                                         generics: &Generics)\n-                                      -> @item {\n-    // Create the method.\n-    let method = expand_deriving_iter_bytes_struct_method(cx,\n-                                                          span,\n-                                                          struct_def);\n-\n-    // Create the implementation.\n-    return create_derived_iter_bytes_impl(cx,\n-                                          span,\n-                                          type_ident,\n-                                          generics,\n-                                          method);\n-}\n-\n-fn expand_deriving_iter_bytes_enum_def(cx: @ext_ctxt,\n-                                       span: span,\n-                                       enum_definition: &enum_def,\n-                                       type_ident: ident,\n-                                       generics: &Generics)\n-                                    -> @item {\n-    // Create the method.\n-    let method = expand_deriving_iter_bytes_enum_method(cx,\n-                                                        span,\n-                                                        enum_definition);\n-\n-    // Create the implementation.\n-    return create_derived_iter_bytes_impl(cx,\n-                                          span,\n-                                          type_ident,\n-                                          generics,\n-                                          method);\n-}\n-\n-fn expand_deriving_clone_struct_def(cx: @ext_ctxt,\n-                                    span: span,\n-                                    struct_def: &struct_def,\n-                                    type_ident: ident,\n-                                    generics: &Generics)\n-                                 -> @item {\n-    // Create the method.\n-    let method = if !is_struct_tuple(struct_def) {\n-        expand_deriving_clone_struct_method(cx,\n-                                            span,\n-                                            struct_def,\n-                                            type_ident,\n-                                            generics)\n-    } else {\n-        expand_deriving_clone_tuple_struct_method(cx,\n-                                                  span,\n-                                                  struct_def,\n-                                                  type_ident,\n-                                                  generics)\n-    };\n-\n-    // Create the implementation.\n-    create_derived_clone_impl(cx, span, type_ident, generics, method)\n-}\n-\n-fn expand_deriving_clone_enum_def(cx: @ext_ctxt,\n-                                  span: span,\n-                                  enum_definition: &enum_def,\n-                                  type_ident: ident,\n-                                  generics: &Generics)\n-                               -> @item {\n-    // Create the method.\n-    let method = expand_deriving_clone_enum_method(cx,\n-                                                   span,\n-                                                   enum_definition,\n-                                                   type_ident,\n-                                                   generics);\n-\n-    // Create the implementation.\n-    create_derived_clone_impl(cx, span, type_ident, generics, method)\n-}\n-\n-fn expand_deriving_eq_struct_method(cx: @ext_ctxt,\n-                                    span: span,\n-                                    struct_def: &struct_def,\n-                                    method_ident: ident,\n-                                    type_ident: ident,\n-                                    generics: &Generics,\n-                                    junction: Junction)\n-                                 -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-    let other_ident = cx.ident_of(~\"__other\");\n-\n-    // Create the body of the method.\n-    let mut outer_expr = None;\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _, _) => {\n-                // Create the accessor for the other field.\n-                let other_field = build::mk_access(cx,\n-                                                   span,\n-                                                   ~[ other_ident ],\n-                                                   ident);\n-                let other_field_ref = build::mk_addr_of(cx,\n-                                                        span,\n-                                                        other_field);\n-\n-                // Create the accessor for this field.\n-                let self_field = build::mk_access(cx,\n-                                                  span,\n-                                                  ~[ self_ident ],\n-                                                  ident);\n-\n-                // Call the substructure method.\n-                call_substructure_eq_method(cx,\n-                                            span,\n-                                            self_field,\n-                                            other_field_ref,\n-                                            method_ident,\n-                                            junction,\n-                                            &mut outer_expr);\n-            }\n-            unnamed_field => {\n-                cx.span_unimpl(span, ~\"unnamed fields with `deriving_eq`\");\n-            }\n-        }\n-    }\n-\n-    // Create the method itself.\n-    let body = finish_eq_chain_expr(cx, span, outer_expr, junction);\n-    return create_eq_method(cx,\n-                            span,\n-                            method_ident,\n-                            type_ident,\n-                            generics,\n-                            body);\n-}\n-\n-fn expand_deriving_iter_bytes_struct_method(cx: @ext_ctxt,\n-                                            span: span,\n-                                            struct_def: &struct_def)\n-                                         -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-\n-    // Create the body of the method.\n-    let mut statements = ~[];\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _, _) => {\n-                // Create the accessor for this field.\n-                let self_field = build::mk_access(cx,\n-                                                  span,\n-                                                  ~[ self_ident ],\n-                                                  ident);\n-\n-                // Call the substructure method.\n-                let stmt = call_substructure_iter_bytes_method(cx,\n-                                                               span,\n-                                                               self_field);\n-                statements.push(stmt);\n-            }\n-            unnamed_field => {\n-                cx.span_unimpl(span,\n-                               ~\"unnamed fields with `deriving_iter_bytes`\");\n-            }\n-        }\n-    }\n-\n-    // Create the method itself.\n-    return create_iter_bytes_method(cx, span, statements);\n-}\n-\n-fn expand_deriving_clone_struct_method(cx: @ext_ctxt,\n-                                       span: span,\n-                                       struct_def: &struct_def,\n-                                       type_ident: ident,\n-                                       generics: &Generics)\n-                                    -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-\n-    // Create the new fields.\n-    let mut fields = ~[];\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _, _) => {\n-                // Create the accessor for this field.\n-                let self_field = build::mk_access(cx,\n-                                                  span,\n-                                                  ~[ self_ident ],\n-                                                  ident);\n-\n-                // Call the substructure method.\n-                let call = call_substructure_clone_method(cx,\n-                                                          span,\n-                                                          self_field);\n-\n-                let field = build::Field { ident: ident, ex: call };\n-                fields.push(field);\n-            }\n-            unnamed_field => {\n-                cx.span_bug(span,\n-                            ~\"unnamed fields in \\\n-                              expand_deriving_clone_struct_method\");\n-            }\n-        }\n-    }\n-\n-    // Create the struct literal.\n-    let struct_literal = build::mk_struct_e(cx,\n-                                            span,\n-                                            ~[ type_ident ],\n-                                            fields);\n-    create_clone_method(cx, span, type_ident, generics, struct_literal)\n-}\n-\n-fn expand_deriving_clone_tuple_struct_method(cx: @ext_ctxt,\n-                                             span: span,\n-                                             struct_def: &struct_def,\n-                                             type_ident: ident,\n-                                             generics: &Generics)\n-                                          -> @method {\n-    // Create the pattern for the match.\n-    let matching_path = build::mk_raw_path(span, ~[ type_ident ]);\n-    let field_count = struct_def.fields.len();\n-    let subpats = create_subpatterns(cx, span, ~\"__self\", field_count);\n-    let pat = build::mk_pat_enum(cx, span, matching_path, subpats);\n-\n-    // Create the new fields.\n-    let mut subcalls = ~[];\n-    for uint::range(0, struct_def.fields.len()) |i| {\n-        // Create the expression for this field.\n-        let field_ident = cx.ident_of(~\"__self\" + i.to_str());\n-        let field = build::mk_path(cx, span, ~[ field_ident ]);\n-\n-        // Call the substructure method.\n-        let subcall = call_substructure_clone_method(cx, span, field);\n-        subcalls.push(subcall);\n-    }\n-\n-    // Create the call to the struct constructor.\n-    let call = build::mk_call(cx, span, ~[ type_ident ], subcalls);\n-\n-    // Create the pattern body.\n-    let match_body_block = build::mk_simple_block(cx, span, call);\n-\n-    // Create the arm.\n-    let arm = ast::arm {\n-        pats: ~[ pat ],\n-        guard: None,\n-        body: match_body_block\n-    };\n-\n-    // Create the method body.\n-    let self_match_expr = expand_enum_or_struct_match(cx, span, ~[ arm ]);\n-\n-    // Create the method.\n-    create_clone_method(cx, span, type_ident, generics, self_match_expr)\n-}\n-\n-fn expand_deriving_eq_enum_method(cx: @ext_ctxt,\n-                                  span: span,\n-                                  enum_definition: &enum_def,\n-                                  method_ident: ident,\n-                                  type_ident: ident,\n-                                  generics: &Generics,\n-                                  junction: Junction)\n-                               -> @method {\n-    let self_ident = cx.ident_of(~\"self\");\n-    let other_ident = cx.ident_of(~\"__other\");\n-\n-    let is_eq;\n-    match junction {\n-        Conjunction => is_eq = true,\n-        Disjunction => is_eq = false,\n-    }\n-\n-    // Create the arms of the self match in the method body.\n-    let mut self_arms = ~[];\n-    for enum_definition.variants.each |self_variant| {\n-        let mut other_arms = ~[];\n-\n-        // Create the matching pattern.\n-        let matching_pat = create_enum_variant_pattern(cx,\n-                                                       span,\n-                                                       self_variant,\n-                                                       ~\"__other\");\n-\n-        // Create the matching pattern body.\n-        let mut matching_body_expr = None;\n-        for uint::range(0, variant_arg_count(cx, span, self_variant)) |i| {\n-            // Create the expression for the other field.\n-            let other_field_ident = cx.ident_of(~\"__other\" + i.to_str());\n-            let other_field = build::mk_path(cx,\n-                                             span,\n-                                             ~[ other_field_ident ]);\n-\n-            // Create the expression for this field.\n-            let self_field_ident = cx.ident_of(~\"__self\" + i.to_str());\n-            let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n-\n-            // Call the substructure method.\n-            call_substructure_eq_method(cx,\n-                                        span,\n-                                        self_field,\n-                                        other_field,\n-                                        method_ident,\n-                                        junction,\n-                                        &mut matching_body_expr);\n-        }\n-\n-        let matching_body_expr = finish_eq_chain_expr(cx,\n-                                                      span,\n-                                                      matching_body_expr,\n-                                                      junction);\n-        let matching_body_block = build::mk_simple_block(cx,\n-                                                         span,\n-                                                         matching_body_expr);\n-\n-        // Create the matching arm.\n-        let matching_arm = ast::arm {\n-            pats: ~[ matching_pat ],\n-            guard: None,\n-            body: matching_body_block\n-        };\n-        other_arms.push(matching_arm);\n-\n-        // Maybe generate a non-matching case. If there is only one\n-        // variant then there will always be a match.\n-        if enum_definition.variants.len() > 1 {\n-            // Create the nonmatching pattern.\n-            let nonmatching_pat = @ast::pat {\n-                id: cx.next_id(),\n-                node: pat_wild,\n-                span: span\n-            };\n-\n-            // Create the nonmatching pattern body.\n-            let nonmatching_expr = build::mk_bool(cx, span, !is_eq);\n-            let nonmatching_body_block =\n-                build::mk_simple_block(cx,\n-                                       span,\n-                                       nonmatching_expr);\n-\n-            // Create the nonmatching arm.\n-            let nonmatching_arm = ast::arm {\n-                pats: ~[ nonmatching_pat ],\n-                guard: None,\n-                body: nonmatching_body_block,\n-            };\n-            other_arms.push(nonmatching_arm);\n-        }\n-\n-        // Create the self pattern.\n-        let self_pat = create_enum_variant_pattern(cx,\n-                                                   span,\n-                                                   self_variant,\n-                                                   ~\"__self\");\n-\n-        // Create the self pattern body.\n-        let other_expr = build::mk_path(cx, span, ~[ other_ident ]);\n-        let other_expr = build::mk_unary(cx, span, deref, other_expr);\n-        let other_match_expr = expr_match(other_expr, other_arms);\n-        let other_match_expr = build::mk_expr(cx,\n-                                              span,\n-                                              other_match_expr);\n-        let other_match_body_block = build::mk_simple_block(cx,\n-                                                            span,\n-                                                            other_match_expr);\n-\n-        // Create the self arm.\n-        let self_arm = ast::arm {\n-            pats: ~[ self_pat ],\n-            guard: None,\n-            body: other_match_body_block,\n-        };\n-        self_arms.push(self_arm);\n-    }\n-\n-    // Create the method body.\n-    let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n-    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_match_expr = expr_match(self_expr, self_arms);\n-    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n-\n-    // Create the method.\n-    return create_eq_method(cx,\n-                            span,\n-                            method_ident,\n-                            type_ident,\n-                            generics,\n-                            self_match_expr);\n-}\n-\n-fn expand_deriving_eq_struct_tuple_method(cx: @ext_ctxt,\n-                                          span: span,\n-                                          struct_def: &struct_def,\n-                                          method_ident: ident,\n-                                          type_ident: ident,\n-                                          generics: &Generics,\n-                                          junction: Junction)\n-                                        -> @method {\n-    let self_str = ~\"self\";\n-    let other_str = ~\"__other\";\n-    let type_path = build::mk_raw_path(span, ~[type_ident]);\n-    let fields = copy struct_def.fields;\n-\n-    // Create comparison expression, comparing each of the fields\n-    let mut match_body = None;\n-    for fields.eachi |i, _| {\n-        let other_field_ident = cx.ident_of(other_str + i.to_str());\n-        let other_field = build::mk_path(cx, span, ~[ other_field_ident ]);\n-\n-        let self_field_ident = cx.ident_of(self_str + i.to_str());\n-        let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n-\n-        call_substructure_eq_method(cx, span, self_field, other_field,\n-            method_ident, junction, &mut match_body);\n-    }\n-    let match_body = finish_eq_chain_expr(cx, span, match_body, junction);\n-\n-    // Create arm for the '__other' match, containing the comparison expr\n-    let other_subpats = create_subpatterns(cx, span, other_str, fields.len());\n-    let other_arm = ast::arm {\n-        pats: ~[ build::mk_pat_enum(cx, span, type_path, other_subpats) ],\n-        guard: None,\n-        body: build::mk_simple_block(cx, span, match_body),\n-    };\n-\n-    // Create the match on '__other'\n-    let other_expr = build::mk_path(cx, span, ~[ cx.ident_of(other_str) ]);\n-    let other_expr = build::mk_unary(cx, span, deref, other_expr);\n-    let other_match_expr = expr_match(other_expr, ~[other_arm]);\n-    let other_match_expr = build::mk_expr(cx, span, other_match_expr);\n-\n-    // Create arm for the 'self' match, which contains the '__other' match\n-    let self_subpats = create_subpatterns(cx, span, self_str, fields.len());\n-    let self_arm = ast::arm {\n-        pats: ~[build::mk_pat_enum(cx, span, type_path, self_subpats)],\n-        guard: None,\n-        body: build::mk_simple_block(cx, span, other_match_expr),\n-    };\n-\n-    // Create the match on 'self'\n-    let self_expr = build::mk_path(cx, span, ~[ cx.ident_of(self_str) ]);\n-    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_match_expr = expr_match(self_expr, ~[self_arm]);\n-    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n-\n-    create_eq_method(cx, span, method_ident,\n-        type_ident, generics, self_match_expr)\n-}\n-\n-fn expand_enum_or_struct_match(cx: @ext_ctxt,\n-                               span: span,\n-                               arms: ~[ ast::arm ])\n-                            -> @expr {\n-    let self_ident = cx.ident_of(~\"self\");\n-    let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n-    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_match_expr = expr_match(self_expr, arms);\n-    build::mk_expr(cx, span, self_match_expr)\n-}\n-\n-fn expand_deriving_iter_bytes_enum_method(cx: @ext_ctxt,\n-                                          span: span,\n-                                          enum_definition: &enum_def)\n-                                       -> @method {\n-    // Create the arms of the match in the method body.\n-    let arms = do enum_definition.variants.mapi |i, variant| {\n-        // Create the matching pattern.\n-        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n-\n-        // Determine the discriminant. We will feed this value to the byte\n-        // iteration function.\n-        let discriminant;\n-        match variant.node.disr_expr {\n-            Some(copy disr_expr) => discriminant = disr_expr,\n-            None => discriminant = build::mk_uint(cx, span, i),\n-        }\n-\n-        // Feed the discriminant to the byte iteration function.\n-        let mut stmts = ~[];\n-        let discrim_stmt = call_substructure_iter_bytes_method(cx,\n-                                                               span,\n-                                                               discriminant);\n-        stmts.push(discrim_stmt);\n-\n-        // Feed each argument in this variant to the byte iteration function\n-        // as well.\n-        for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n-            // Create the expression for this field.\n-            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n-            let field = build::mk_path(cx, span, ~[ field_ident ]);\n-\n-            // Call the substructure method.\n-            let stmt = call_substructure_iter_bytes_method(cx, span, field);\n-            stmts.push(stmt);\n-        }\n-\n-        // Create the pattern body.\n-        let match_body_block = build::mk_block_(cx, span, stmts);\n-\n-        // Create the arm.\n-        ast::arm {\n-            pats: ~[ pat ],\n-            guard: None,\n-            body: match_body_block,\n-        }\n-    };\n-\n-    // Create the method body.\n-    let self_match_expr = expand_enum_or_struct_match(cx, span, arms);\n-    let self_match_stmt = build::mk_stmt(cx, span, self_match_expr);\n-\n-    // Create the method.\n-    create_iter_bytes_method(cx, span, ~[ self_match_stmt ])\n-}\n-\n-fn expand_deriving_clone_enum_method(cx: @ext_ctxt,\n-                                     span: span,\n-                                     enum_definition: &enum_def,\n-                                     type_ident: ident,\n-                                     generics: &Generics)\n-                                  -> @method {\n-    // Create the arms of the match in the method body.\n-    let arms = do enum_definition.variants.map |variant| {\n-        // Create the matching pattern.\n-        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n-\n-        // Iterate over the variant arguments, creating the subcalls.\n-        let mut subcalls = ~[];\n-        for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n-            // Create the expression for this field.\n-            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n-            let field = build::mk_path(cx, span, ~[ field_ident ]);\n-\n-            // Call the substructure method.\n-            let subcall = call_substructure_clone_method(cx, span, field);\n-            subcalls.push(subcall);\n-        }\n-\n-        // Create the call to the enum variant (if necessary).\n-        let call = if subcalls.len() > 0 {\n-            build::mk_call(cx, span, ~[ variant.node.name ], subcalls)\n-        } else {\n-            build::mk_path(cx, span, ~[ variant.node.name ])\n-        };\n-\n-        // Create the pattern body.\n-        let match_body_block = build::mk_simple_block(cx, span, call);\n-\n-        // Create the arm.\n-        ast::arm { pats: ~[ pat ], guard: None, body: match_body_block }\n-    };\n-\n-    // Create the method body.\n-    let self_match_expr = expand_enum_or_struct_match(cx, span, arms);\n-\n-    // Create the method.\n-    create_clone_method(cx, span, type_ident, generics, self_match_expr)\n-}\n-"}, {"sha": "072cd0f6c39b2f249732a50a01a4bea98f5b595d", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/63a292fd8686f56efe7836aef46709a063efab4e/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63a292fd8686f56efe7836aef46709a063efab4e/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=63a292fd8686f56efe7836aef46709a063efab4e", "patch": "@@ -0,0 +1,289 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use ast;\n+use ast::{TraitTyParamBound, Ty, and, bind_by_ref, binop, deref, enum_def};\n+use ast::{enum_variant_kind, expr, expr_match, ident, impure_fn, item, item_};\n+use ast::{item_enum, item_impl, item_struct, Generics};\n+use ast::{m_imm, meta_item, method};\n+use ast::{named_field, or, pat, pat_ident, pat_wild, public, pure_fn};\n+use ast::{stmt, struct_def, struct_variant_kind};\n+use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, TyParam};\n+use ast::{TyParamBound, ty_path, ty_rptr, unnamed_field, variant};\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::*;\n+use codemap::{span, spanned};\n+use ast_util;\n+\n+use core::uint;\n+\n+pub fn expand_deriving_clone(cx: @ext_ctxt,\n+                             span: span,\n+                             _: @meta_item,\n+                             in_items: ~[@item])\n+                          -> ~[@item] {\n+    expand_deriving(cx,\n+                    span,\n+                    in_items,\n+                    expand_deriving_clone_struct_def,\n+                    expand_deriving_clone_enum_def)\n+}\n+\n+fn create_derived_clone_impl(cx: @ext_ctxt,\n+                             span: span,\n+                             type_ident: ident,\n+                             generics: &Generics,\n+                             method: @method)\n+                          -> @item {\n+    let methods = [ method ];\n+    let trait_path = [\n+        cx.ident_of(~\"core\"),\n+        cx.ident_of(~\"clone\"),\n+        cx.ident_of(~\"Clone\"),\n+    ];\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n+}\n+// Creates a method from the given expression conforming to the signature of\n+// the `clone` method.\n+fn create_clone_method(cx: @ext_ctxt,\n+                       span: span,\n+                       +type_ident: ast::ident,\n+                       generics: &Generics,\n+                       expr: @ast::expr)\n+                    -> @method {\n+    // Create the type parameters of the return value.\n+    let mut output_ty_params = ~[];\n+    for generics.ty_params.each |ty_param| {\n+        let path = build::mk_ty_path(cx, span, ~[ ty_param.ident ]);\n+        output_ty_params.push(path);\n+    }\n+\n+    // Create the type of the return value.\n+    let output_type_path = build::mk_raw_path_(span,\n+                                               ~[ type_ident ],\n+                                               output_ty_params);\n+    let output_type = ast::ty_path(output_type_path, cx.next_id());\n+    let output_type = @ast::Ty {\n+        id: cx.next_id(),\n+        node: output_type,\n+        span: span\n+    };\n+\n+    // Create the function declaration.\n+    let fn_decl = build::mk_fn_decl(~[], output_type);\n+\n+    // Create the body block.\n+    let body_block = build::mk_simple_block(cx, span, expr);\n+\n+    // Create the self type and method identifier.\n+    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n+    let method_ident = cx.ident_of(~\"clone\");\n+\n+    // Create the method.\n+    @ast::method {\n+        ident: method_ident,\n+        attrs: ~[],\n+        generics: ast_util::empty_generics(),\n+        self_ty: self_ty,\n+        purity: impure_fn,\n+        decl: fn_decl,\n+        body: body_block,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: public,\n+    }\n+}\n+\n+fn call_substructure_clone_method(cx: @ext_ctxt,\n+                                  span: span,\n+                                  self_field: @expr)\n+                               -> @expr {\n+    // Call the substructure method.\n+    let clone_ident = cx.ident_of(~\"clone\");\n+    let self_method = build::mk_access_(cx, span, self_field, clone_ident);\n+    build::mk_call_(cx, span, self_method, ~[])\n+}\n+\n+fn expand_deriving_clone_struct_def(cx: @ext_ctxt,\n+                                    span: span,\n+                                    struct_def: &struct_def,\n+                                    type_ident: ident,\n+                                    generics: &Generics)\n+                                 -> @item {\n+    // Create the method.\n+    let method = if !is_struct_tuple(struct_def) {\n+        expand_deriving_clone_struct_method(cx,\n+                                            span,\n+                                            struct_def,\n+                                            type_ident,\n+                                            generics)\n+    } else {\n+        expand_deriving_clone_tuple_struct_method(cx,\n+                                                  span,\n+                                                  struct_def,\n+                                                  type_ident,\n+                                                  generics)\n+    };\n+\n+    // Create the implementation.\n+    create_derived_clone_impl(cx, span, type_ident, generics, method)\n+}\n+\n+fn expand_deriving_clone_enum_def(cx: @ext_ctxt,\n+                                  span: span,\n+                                  enum_definition: &enum_def,\n+                                  type_ident: ident,\n+                                  generics: &Generics)\n+                               -> @item {\n+    // Create the method.\n+    let method = expand_deriving_clone_enum_method(cx,\n+                                                   span,\n+                                                   enum_definition,\n+                                                   type_ident,\n+                                                   generics);\n+\n+    // Create the implementation.\n+    create_derived_clone_impl(cx, span, type_ident, generics, method)\n+}\n+\n+fn expand_deriving_clone_struct_method(cx: @ext_ctxt,\n+                                       span: span,\n+                                       struct_def: &struct_def,\n+                                       type_ident: ident,\n+                                       generics: &Generics)\n+                                    -> @method {\n+    let self_ident = cx.ident_of(~\"self\");\n+\n+    // Create the new fields.\n+    let mut fields = ~[];\n+    for struct_def.fields.each |struct_field| {\n+        match struct_field.node.kind {\n+            named_field(ident, _, _) => {\n+                // Create the accessor for this field.\n+                let self_field = build::mk_access(cx,\n+                                                  span,\n+                                                  ~[ self_ident ],\n+                                                  ident);\n+\n+                // Call the substructure method.\n+                let call = call_substructure_clone_method(cx,\n+                                                          span,\n+                                                          self_field);\n+\n+                let field = build::Field { ident: ident, ex: call };\n+                fields.push(field);\n+            }\n+            unnamed_field => {\n+                cx.span_bug(span,\n+                            ~\"unnamed fields in \\\n+                              expand_deriving_clone_struct_method\");\n+            }\n+        }\n+    }\n+\n+    // Create the struct literal.\n+    let struct_literal = build::mk_struct_e(cx,\n+                                            span,\n+                                            ~[ type_ident ],\n+                                            fields);\n+    create_clone_method(cx, span, type_ident, generics, struct_literal)\n+}\n+\n+fn expand_deriving_clone_tuple_struct_method(cx: @ext_ctxt,\n+                                             span: span,\n+                                             struct_def: &struct_def,\n+                                             type_ident: ident,\n+                                             generics: &Generics)\n+                                          -> @method {\n+    // Create the pattern for the match.\n+    let matching_path = build::mk_raw_path(span, ~[ type_ident ]);\n+    let field_count = struct_def.fields.len();\n+    let subpats = create_subpatterns(cx, span, ~\"__self\", field_count);\n+    let pat = build::mk_pat_enum(cx, span, matching_path, subpats);\n+\n+    // Create the new fields.\n+    let mut subcalls = ~[];\n+    for uint::range(0, struct_def.fields.len()) |i| {\n+        // Create the expression for this field.\n+        let field_ident = cx.ident_of(~\"__self\" + i.to_str());\n+        let field = build::mk_path(cx, span, ~[ field_ident ]);\n+\n+        // Call the substructure method.\n+        let subcall = call_substructure_clone_method(cx, span, field);\n+        subcalls.push(subcall);\n+    }\n+\n+    // Create the call to the struct constructor.\n+    let call = build::mk_call(cx, span, ~[ type_ident ], subcalls);\n+\n+    // Create the pattern body.\n+    let match_body_block = build::mk_simple_block(cx, span, call);\n+\n+    // Create the arm.\n+    let arm = ast::arm {\n+        pats: ~[ pat ],\n+        guard: None,\n+        body: match_body_block\n+    };\n+\n+    // Create the method body.\n+    let self_match_expr = expand_enum_or_struct_match(cx, span, ~[ arm ]);\n+\n+    // Create the method.\n+    create_clone_method(cx, span, type_ident, generics, self_match_expr)\n+}\n+\n+fn expand_deriving_clone_enum_method(cx: @ext_ctxt,\n+                                     span: span,\n+                                     enum_definition: &enum_def,\n+                                     type_ident: ident,\n+                                     generics: &Generics)\n+                                  -> @method {\n+    // Create the arms of the match in the method body.\n+    let arms = do enum_definition.variants.map |variant| {\n+        // Create the matching pattern.\n+        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n+\n+        // Iterate over the variant arguments, creating the subcalls.\n+        let mut subcalls = ~[];\n+        for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n+            // Create the expression for this field.\n+            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n+            let field = build::mk_path(cx, span, ~[ field_ident ]);\n+\n+            // Call the substructure method.\n+            let subcall = call_substructure_clone_method(cx, span, field);\n+            subcalls.push(subcall);\n+        }\n+\n+        // Create the call to the enum variant (if necessary).\n+        let call = if subcalls.len() > 0 {\n+            build::mk_call(cx, span, ~[ variant.node.name ], subcalls)\n+        } else {\n+            build::mk_path(cx, span, ~[ variant.node.name ])\n+        };\n+\n+        // Create the pattern body.\n+        let match_body_block = build::mk_simple_block(cx, span, call);\n+\n+        // Create the arm.\n+        ast::arm { pats: ~[ pat ], guard: None, body: match_body_block }\n+    };\n+\n+    // Create the method body.\n+    let self_match_expr = expand_enum_or_struct_match(cx, span, arms);\n+\n+    // Create the method.\n+    create_clone_method(cx, span, type_ident, generics, self_match_expr)\n+}"}, {"sha": "6213eeca13461e37f66c39557c0d9324d080c259", "filename": "src/libsyntax/ext/deriving/eq.rs", "status": "added", "additions": 498, "deletions": 0, "changes": 498, "blob_url": "https://github.com/rust-lang/rust/blob/63a292fd8686f56efe7836aef46709a063efab4e/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63a292fd8686f56efe7836aef46709a063efab4e/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs?ref=63a292fd8686f56efe7836aef46709a063efab4e", "patch": "@@ -0,0 +1,498 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use ast;\n+use ast::{TraitTyParamBound, Ty, and, bind_by_ref, binop, deref, enum_def};\n+use ast::{enum_variant_kind, expr, expr_match, ident, impure_fn, item, item_};\n+use ast::{item_enum, item_impl, item_struct, Generics};\n+use ast::{m_imm, meta_item, method};\n+use ast::{named_field, or, pat, pat_ident, pat_wild, public, pure_fn};\n+use ast::{stmt, struct_def, struct_variant_kind};\n+use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, TyParam};\n+use ast::{TyParamBound, ty_path, ty_rptr, unnamed_field, variant};\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::*;\n+use codemap::{span, spanned};\n+use ast_util;\n+\n+use core::uint;\n+\n+enum Junction {\n+    Conjunction,\n+    Disjunction,\n+}\n+\n+pub impl Junction {\n+    fn to_binop(self) -> binop {\n+        match self {\n+            Conjunction => and,\n+            Disjunction => or,\n+        }\n+    }\n+}\n+\n+pub fn expand_deriving_eq(cx: @ext_ctxt,\n+                          span: span,\n+                          _mitem: @meta_item,\n+                          in_items: ~[@item])\n+                       -> ~[@item] {\n+    expand_deriving(cx,\n+                    span,\n+                    in_items,\n+                    expand_deriving_eq_struct_def,\n+                    expand_deriving_eq_enum_def)\n+}\n+\n+/// Creates a method from the given expression, the signature of which\n+/// conforms to the `eq` or `ne` method.\n+fn create_eq_method(cx: @ext_ctxt,\n+                    span: span,\n+                    method_ident: ident,\n+                    type_ident: ident,\n+                    generics: &Generics,\n+                    body: @expr)\n+                 -> @method {\n+    // Create the type of the `other` parameter.\n+    let arg_path_type = create_self_type_with_params(cx,\n+                                                     span,\n+                                                     type_ident,\n+                                                     generics);\n+    let arg_type = ty_rptr(\n+        None,\n+        ast::mt { ty: arg_path_type, mutbl: m_imm }\n+    );\n+    let arg_type = @ast::Ty {\n+        id: cx.next_id(),\n+        node: arg_type,\n+        span: span,\n+    };\n+\n+    // Create the `other` parameter.\n+    let other_ident = cx.ident_of(~\"__other\");\n+    let arg = build::mk_arg(cx, span, other_ident, arg_type);\n+\n+    // Create the type of the return value.\n+    let bool_ident = cx.ident_of(~\"bool\");\n+    let output_type = build::mk_raw_path(span, ~[ bool_ident ]);\n+    let output_type = ty_path(output_type, cx.next_id());\n+    let output_type = @ast::Ty {\n+        id: cx.next_id(),\n+        node: output_type,\n+        span: span,\n+    };\n+\n+    // Create the function declaration.\n+    let fn_decl = build::mk_fn_decl(~[ arg ], output_type);\n+\n+    // Create the body block.\n+    let body_block = build::mk_simple_block(cx, span, body);\n+\n+    // Create the method.\n+    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n+    @ast::method {\n+        ident: method_ident,\n+        attrs: ~[],\n+        generics: ast_util::empty_generics(),\n+        self_ty: self_ty,\n+        purity: impure_fn,\n+        decl: fn_decl,\n+        body: body_block,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: public\n+    }\n+}\n+\n+fn create_derived_eq_impl(cx: @ext_ctxt,\n+                          span: span,\n+                          type_ident: ident,\n+                          generics: &Generics,\n+                          eq_method: @method,\n+                          ne_method: @method)\n+                       -> @item {\n+    let methods = [ eq_method, ne_method ];\n+    let trait_path = [\n+        cx.ident_of(~\"core\"),\n+        cx.ident_of(~\"cmp\"),\n+        cx.ident_of(~\"Eq\")\n+    ];\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n+}\n+\n+fn call_substructure_eq_method(cx: @ext_ctxt,\n+                               span: span,\n+                               self_field: @expr,\n+                               other_field_ref: @expr,\n+                               method_ident: ident,\n+                               junction: Junction,\n+                               chain_expr: &mut Option<@expr>) {\n+    // Call the substructure method.\n+    let self_method = build::mk_access_(cx, span, self_field, method_ident);\n+    let self_call = build::mk_call_(cx,\n+                                    span,\n+                                    self_method,\n+                                    ~[ other_field_ref ]);\n+\n+    // Connect to the outer expression if necessary.\n+    *chain_expr = match *chain_expr {\n+        None => Some(self_call),\n+        Some(copy old_outer_expr) => {\n+            let binop = junction.to_binop();\n+            let chain_expr = build::mk_binary(cx,\n+                                              span,\n+                                              binop,\n+                                              old_outer_expr,\n+                                              self_call);\n+            Some(chain_expr)\n+        }\n+    };\n+}\n+\n+fn finish_eq_chain_expr(cx: @ext_ctxt,\n+                        span: span,\n+                        chain_expr: Option<@expr>,\n+                        junction: Junction)\n+                     -> @expr {\n+    match chain_expr {\n+        None => {\n+            match junction {\n+                Conjunction => build::mk_bool(cx, span, true),\n+                Disjunction => build::mk_bool(cx, span, false),\n+            }\n+        }\n+        Some(ref outer_expr) => *outer_expr,\n+    }\n+}\n+\n+fn expand_deriving_eq_struct_def(cx: @ext_ctxt,\n+                                 span: span,\n+                                 struct_def: &struct_def,\n+                                 type_ident: ident,\n+                                 generics: &Generics)\n+                              -> @item {\n+    // Create the methods.\n+    let eq_ident = cx.ident_of(~\"eq\");\n+    let ne_ident = cx.ident_of(~\"ne\");\n+\n+    let derive_struct_fn = if is_struct_tuple(struct_def) {\n+        expand_deriving_eq_struct_tuple_method\n+    } else {\n+        expand_deriving_eq_struct_method\n+    };\n+\n+    let eq_method = derive_struct_fn(cx,\n+                                     span,\n+                                     struct_def,\n+                                     eq_ident,\n+                                     type_ident,\n+                                     generics,\n+                                     Conjunction);\n+    let ne_method = derive_struct_fn(cx,\n+                                     span,\n+                                     struct_def,\n+                                     ne_ident,\n+                                     type_ident,\n+                                     generics,\n+                                     Disjunction);\n+\n+    // Create the implementation.\n+    return create_derived_eq_impl(cx,\n+                                  span,\n+                                  type_ident,\n+                                  generics,\n+                                  eq_method,\n+                                  ne_method);\n+}\n+\n+fn expand_deriving_eq_enum_def(cx: @ext_ctxt,\n+                               span: span,\n+                               enum_definition: &enum_def,\n+                               type_ident: ident,\n+                               generics: &Generics)\n+                            -> @item {\n+    // Create the methods.\n+    let eq_ident = cx.ident_of(~\"eq\");\n+    let ne_ident = cx.ident_of(~\"ne\");\n+    let eq_method = expand_deriving_eq_enum_method(cx,\n+                                                   span,\n+                                                   enum_definition,\n+                                                   eq_ident,\n+                                                   type_ident,\n+                                                   generics,\n+                                                   Conjunction);\n+    let ne_method = expand_deriving_eq_enum_method(cx,\n+                                                   span,\n+                                                   enum_definition,\n+                                                   ne_ident,\n+                                                   type_ident,\n+                                                   generics,\n+                                                   Disjunction);\n+\n+    // Create the implementation.\n+    return create_derived_eq_impl(cx,\n+                                  span,\n+                                  type_ident,\n+                                  generics,\n+                                  eq_method,\n+                                  ne_method);\n+}\n+\n+fn expand_deriving_eq_struct_method(cx: @ext_ctxt,\n+                                    span: span,\n+                                    struct_def: &struct_def,\n+                                    method_ident: ident,\n+                                    type_ident: ident,\n+                                    generics: &Generics,\n+                                    junction: Junction)\n+                                 -> @method {\n+    let self_ident = cx.ident_of(~\"self\");\n+    let other_ident = cx.ident_of(~\"__other\");\n+\n+    // Create the body of the method.\n+    let mut outer_expr = None;\n+    for struct_def.fields.each |struct_field| {\n+        match struct_field.node.kind {\n+            named_field(ident, _, _) => {\n+                // Create the accessor for the other field.\n+                let other_field = build::mk_access(cx,\n+                                                   span,\n+                                                   ~[ other_ident ],\n+                                                   ident);\n+                let other_field_ref = build::mk_addr_of(cx,\n+                                                        span,\n+                                                        other_field);\n+\n+                // Create the accessor for this field.\n+                let self_field = build::mk_access(cx,\n+                                                  span,\n+                                                  ~[ self_ident ],\n+                                                  ident);\n+\n+                // Call the substructure method.\n+                call_substructure_eq_method(cx,\n+                                            span,\n+                                            self_field,\n+                                            other_field_ref,\n+                                            method_ident,\n+                                            junction,\n+                                            &mut outer_expr);\n+            }\n+            unnamed_field => {\n+                cx.span_unimpl(span, ~\"unnamed fields with `deriving_eq`\");\n+            }\n+        }\n+    }\n+\n+    // Create the method itself.\n+    let body = finish_eq_chain_expr(cx, span, outer_expr, junction);\n+    return create_eq_method(cx,\n+                            span,\n+                            method_ident,\n+                            type_ident,\n+                            generics,\n+                            body);\n+}\n+\n+fn expand_deriving_eq_enum_method(cx: @ext_ctxt,\n+                                  span: span,\n+                                  enum_definition: &enum_def,\n+                                  method_ident: ident,\n+                                  type_ident: ident,\n+                                  generics: &Generics,\n+                                  junction: Junction)\n+                               -> @method {\n+    let self_ident = cx.ident_of(~\"self\");\n+    let other_ident = cx.ident_of(~\"__other\");\n+\n+    let is_eq;\n+    match junction {\n+        Conjunction => is_eq = true,\n+        Disjunction => is_eq = false,\n+    }\n+\n+    // Create the arms of the self match in the method body.\n+    let mut self_arms = ~[];\n+    for enum_definition.variants.each |self_variant| {\n+        let mut other_arms = ~[];\n+\n+        // Create the matching pattern.\n+        let matching_pat = create_enum_variant_pattern(cx,\n+                                                       span,\n+                                                       self_variant,\n+                                                       ~\"__other\");\n+\n+        // Create the matching pattern body.\n+        let mut matching_body_expr = None;\n+        for uint::range(0, variant_arg_count(cx, span, self_variant)) |i| {\n+            // Create the expression for the other field.\n+            let other_field_ident = cx.ident_of(~\"__other\" + i.to_str());\n+            let other_field = build::mk_path(cx,\n+                                             span,\n+                                             ~[ other_field_ident ]);\n+\n+            // Create the expression for this field.\n+            let self_field_ident = cx.ident_of(~\"__self\" + i.to_str());\n+            let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n+\n+            // Call the substructure method.\n+            call_substructure_eq_method(cx,\n+                                        span,\n+                                        self_field,\n+                                        other_field,\n+                                        method_ident,\n+                                        junction,\n+                                        &mut matching_body_expr);\n+        }\n+\n+        let matching_body_expr = finish_eq_chain_expr(cx,\n+                                                      span,\n+                                                      matching_body_expr,\n+                                                      junction);\n+        let matching_body_block = build::mk_simple_block(cx,\n+                                                         span,\n+                                                         matching_body_expr);\n+\n+        // Create the matching arm.\n+        let matching_arm = ast::arm {\n+            pats: ~[ matching_pat ],\n+            guard: None,\n+            body: matching_body_block\n+        };\n+        other_arms.push(matching_arm);\n+\n+        // Maybe generate a non-matching case. If there is only one\n+        // variant then there will always be a match.\n+        if enum_definition.variants.len() > 1 {\n+            // Create the nonmatching pattern.\n+            let nonmatching_pat = @ast::pat {\n+                id: cx.next_id(),\n+                node: pat_wild,\n+                span: span\n+            };\n+\n+            // Create the nonmatching pattern body.\n+            let nonmatching_expr = build::mk_bool(cx, span, !is_eq);\n+            let nonmatching_body_block =\n+                build::mk_simple_block(cx,\n+                                       span,\n+                                       nonmatching_expr);\n+\n+            // Create the nonmatching arm.\n+            let nonmatching_arm = ast::arm {\n+                pats: ~[ nonmatching_pat ],\n+                guard: None,\n+                body: nonmatching_body_block,\n+            };\n+            other_arms.push(nonmatching_arm);\n+        }\n+\n+        // Create the self pattern.\n+        let self_pat = create_enum_variant_pattern(cx,\n+                                                   span,\n+                                                   self_variant,\n+                                                   ~\"__self\");\n+\n+        // Create the self pattern body.\n+        let other_expr = build::mk_path(cx, span, ~[ other_ident ]);\n+        let other_expr = build::mk_unary(cx, span, deref, other_expr);\n+        let other_match_expr = expr_match(other_expr, other_arms);\n+        let other_match_expr = build::mk_expr(cx,\n+                                              span,\n+                                              other_match_expr);\n+        let other_match_body_block = build::mk_simple_block(cx,\n+                                                            span,\n+                                                            other_match_expr);\n+\n+        // Create the self arm.\n+        let self_arm = ast::arm {\n+            pats: ~[ self_pat ],\n+            guard: None,\n+            body: other_match_body_block,\n+        };\n+        self_arms.push(self_arm);\n+    }\n+\n+    // Create the method body.\n+    let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n+    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n+    let self_match_expr = expr_match(self_expr, self_arms);\n+    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n+\n+    // Create the method.\n+    return create_eq_method(cx,\n+                            span,\n+                            method_ident,\n+                            type_ident,\n+                            generics,\n+                            self_match_expr);\n+}\n+\n+fn expand_deriving_eq_struct_tuple_method(cx: @ext_ctxt,\n+                                          span: span,\n+                                          struct_def: &struct_def,\n+                                          method_ident: ident,\n+                                          type_ident: ident,\n+                                          generics: &Generics,\n+                                          junction: Junction)\n+                                        -> @method {\n+    let self_str = ~\"self\";\n+    let other_str = ~\"__other\";\n+    let type_path = build::mk_raw_path(span, ~[type_ident]);\n+    let fields = copy struct_def.fields;\n+\n+    // Create comparison expression, comparing each of the fields\n+    let mut match_body = None;\n+    for fields.eachi |i, _| {\n+        let other_field_ident = cx.ident_of(other_str + i.to_str());\n+        let other_field = build::mk_path(cx, span, ~[ other_field_ident ]);\n+\n+        let self_field_ident = cx.ident_of(self_str + i.to_str());\n+        let self_field = build::mk_path(cx, span, ~[ self_field_ident ]);\n+\n+        call_substructure_eq_method(cx, span, self_field, other_field,\n+            method_ident, junction, &mut match_body);\n+    }\n+    let match_body = finish_eq_chain_expr(cx, span, match_body, junction);\n+\n+    // Create arm for the '__other' match, containing the comparison expr\n+    let other_subpats = create_subpatterns(cx, span, other_str, fields.len());\n+    let other_arm = ast::arm {\n+        pats: ~[ build::mk_pat_enum(cx, span, type_path, other_subpats) ],\n+        guard: None,\n+        body: build::mk_simple_block(cx, span, match_body),\n+    };\n+\n+    // Create the match on '__other'\n+    let other_expr = build::mk_path(cx, span, ~[ cx.ident_of(other_str) ]);\n+    let other_expr = build::mk_unary(cx, span, deref, other_expr);\n+    let other_match_expr = expr_match(other_expr, ~[other_arm]);\n+    let other_match_expr = build::mk_expr(cx, span, other_match_expr);\n+\n+    // Create arm for the 'self' match, which contains the '__other' match\n+    let self_subpats = create_subpatterns(cx, span, self_str, fields.len());\n+    let self_arm = ast::arm {\n+        pats: ~[build::mk_pat_enum(cx, span, type_path, self_subpats)],\n+        guard: None,\n+        body: build::mk_simple_block(cx, span, other_match_expr),\n+    };\n+\n+    // Create the match on 'self'\n+    let self_expr = build::mk_path(cx, span, ~[ cx.ident_of(self_str) ]);\n+    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n+    let self_match_expr = expr_match(self_expr, ~[self_arm]);\n+    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n+\n+    create_eq_method(cx, span, method_ident,\n+        type_ident, generics, self_match_expr)\n+}"}, {"sha": "613e9c295eb74db978dbafe8986bea73b4dae6cb", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/63a292fd8686f56efe7836aef46709a063efab4e/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63a292fd8686f56efe7836aef46709a063efab4e/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=63a292fd8686f56efe7836aef46709a063efab4e", "patch": "@@ -0,0 +1,256 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use ast;\n+use ast::{TraitTyParamBound, Ty, and, bind_by_ref, binop, deref, enum_def};\n+use ast::{enum_variant_kind, expr, expr_match, ident, impure_fn, item, item_};\n+use ast::{item_enum, item_impl, item_struct, Generics};\n+use ast::{m_imm, meta_item, method};\n+use ast::{named_field, or, pat, pat_ident, pat_wild, public, pure_fn};\n+use ast::{stmt, struct_def, struct_variant_kind};\n+use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, TyParam};\n+use ast::{TyParamBound, ty_path, ty_rptr, unnamed_field, variant};\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::*;\n+use codemap::{span, spanned};\n+use ast_util;\n+\n+use core::uint;\n+\n+pub fn expand_deriving_iter_bytes(cx: @ext_ctxt,\n+                                  span: span,\n+                                  _mitem: @meta_item,\n+                                  in_items: ~[@item])\n+                               -> ~[@item] {\n+    expand_deriving(cx,\n+                    span,\n+                    in_items,\n+                    expand_deriving_iter_bytes_struct_def,\n+                    expand_deriving_iter_bytes_enum_def)\n+}\n+\n+fn create_derived_iter_bytes_impl(cx: @ext_ctxt,\n+                                  span: span,\n+                                  type_ident: ident,\n+                                  generics: &Generics,\n+                                  method: @method)\n+                               -> @item {\n+    let methods = [ method ];\n+    let trait_path = [\n+        cx.ident_of(~\"core\"),\n+        cx.ident_of(~\"to_bytes\"),\n+        cx.ident_of(~\"IterBytes\")\n+    ];\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n+}\n+\n+// Creates a method from the given set of statements conforming to the\n+// signature of the `iter_bytes` method.\n+fn create_iter_bytes_method(cx: @ext_ctxt,\n+                            span: span,\n+                            +statements: ~[@stmt])\n+                         -> @method {\n+    // Create the `lsb0` parameter.\n+    let bool_ident = cx.ident_of(~\"bool\");\n+    let lsb0_arg_type = build::mk_simple_ty_path(cx, span, bool_ident);\n+    let lsb0_ident = cx.ident_of(~\"__lsb0\");\n+    let lsb0_arg = build::mk_arg(cx, span, lsb0_ident, lsb0_arg_type);\n+\n+    // Create the `f` parameter.\n+    let core_ident = cx.ident_of(~\"core\");\n+    let to_bytes_ident = cx.ident_of(~\"to_bytes\");\n+    let cb_ident = cx.ident_of(~\"Cb\");\n+    let core_to_bytes_cb_ident = ~[ core_ident, to_bytes_ident, cb_ident ];\n+    let f_arg_type = build::mk_ty_path(cx, span, core_to_bytes_cb_ident);\n+    let f_ident = cx.ident_of(~\"__f\");\n+    let f_arg = build::mk_arg(cx, span, f_ident, f_arg_type);\n+\n+    // Create the type of the return value.\n+    let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n+\n+    // Create the function declaration.\n+    let inputs = ~[ lsb0_arg, f_arg ];\n+    let fn_decl = build::mk_fn_decl(inputs, output_type);\n+\n+    // Create the body block.\n+    let body_block = build::mk_block_(cx, span, statements);\n+\n+    // Create the method.\n+    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n+    let method_ident = cx.ident_of(~\"iter_bytes\");\n+    @ast::method {\n+        ident: method_ident,\n+        attrs: ~[],\n+        generics: ast_util::empty_generics(),\n+        self_ty: self_ty,\n+        purity: impure_fn,\n+        decl: fn_decl,\n+        body: body_block,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: public\n+    }\n+}\n+\n+fn call_substructure_iter_bytes_method(cx: @ext_ctxt,\n+                                       span: span,\n+                                       self_field: @expr)\n+                                    -> @stmt {\n+    // Gather up the parameters we want to chain along.\n+    let lsb0_ident = cx.ident_of(~\"__lsb0\");\n+    let f_ident = cx.ident_of(~\"__f\");\n+    let lsb0_expr = build::mk_path(cx, span, ~[ lsb0_ident ]);\n+    let f_expr = build::mk_path(cx, span, ~[ f_ident ]);\n+\n+    // Call the substructure method.\n+    let iter_bytes_ident = cx.ident_of(~\"iter_bytes\");\n+    let self_method = build::mk_access_(cx,\n+                                        span,\n+                                        self_field,\n+                                        iter_bytes_ident);\n+    let self_call = build::mk_call_(cx,\n+                                    span,\n+                                    self_method,\n+                                    ~[ lsb0_expr, f_expr ]);\n+\n+    // Create a statement out of this expression.\n+    build::mk_stmt(cx, span, self_call)\n+}\n+\n+fn expand_deriving_iter_bytes_struct_def(cx: @ext_ctxt,\n+                                         span: span,\n+                                         struct_def: &struct_def,\n+                                         type_ident: ident,\n+                                         generics: &Generics)\n+                                      -> @item {\n+    // Create the method.\n+    let method = expand_deriving_iter_bytes_struct_method(cx,\n+                                                          span,\n+                                                          struct_def);\n+\n+    // Create the implementation.\n+    return create_derived_iter_bytes_impl(cx,\n+                                          span,\n+                                          type_ident,\n+                                          generics,\n+                                          method);\n+}\n+\n+fn expand_deriving_iter_bytes_enum_def(cx: @ext_ctxt,\n+                                       span: span,\n+                                       enum_definition: &enum_def,\n+                                       type_ident: ident,\n+                                       generics: &Generics)\n+                                    -> @item {\n+    // Create the method.\n+    let method = expand_deriving_iter_bytes_enum_method(cx,\n+                                                        span,\n+                                                        enum_definition);\n+\n+    // Create the implementation.\n+    return create_derived_iter_bytes_impl(cx,\n+                                          span,\n+                                          type_ident,\n+                                          generics,\n+                                          method);\n+}\n+\n+fn expand_deriving_iter_bytes_struct_method(cx: @ext_ctxt,\n+                                            span: span,\n+                                            struct_def: &struct_def)\n+                                         -> @method {\n+    let self_ident = cx.ident_of(~\"self\");\n+\n+    // Create the body of the method.\n+    let mut statements = ~[];\n+    for struct_def.fields.each |struct_field| {\n+        match struct_field.node.kind {\n+            named_field(ident, _, _) => {\n+                // Create the accessor for this field.\n+                let self_field = build::mk_access(cx,\n+                                                  span,\n+                                                  ~[ self_ident ],\n+                                                  ident);\n+\n+                // Call the substructure method.\n+                let stmt = call_substructure_iter_bytes_method(cx,\n+                                                               span,\n+                                                               self_field);\n+                statements.push(stmt);\n+            }\n+            unnamed_field => {\n+                cx.span_unimpl(span,\n+                               ~\"unnamed fields with `deriving_iter_bytes`\");\n+            }\n+        }\n+    }\n+\n+    // Create the method itself.\n+    return create_iter_bytes_method(cx, span, statements);\n+}\n+\n+fn expand_deriving_iter_bytes_enum_method(cx: @ext_ctxt,\n+                                          span: span,\n+                                          enum_definition: &enum_def)\n+                                       -> @method {\n+    // Create the arms of the match in the method body.\n+    let arms = do enum_definition.variants.mapi |i, variant| {\n+        // Create the matching pattern.\n+        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n+\n+        // Determine the discriminant. We will feed this value to the byte\n+        // iteration function.\n+        let discriminant;\n+        match variant.node.disr_expr {\n+            Some(copy disr_expr) => discriminant = disr_expr,\n+            None => discriminant = build::mk_uint(cx, span, i),\n+        }\n+\n+        // Feed the discriminant to the byte iteration function.\n+        let mut stmts = ~[];\n+        let discrim_stmt = call_substructure_iter_bytes_method(cx,\n+                                                               span,\n+                                                               discriminant);\n+        stmts.push(discrim_stmt);\n+\n+        // Feed each argument in this variant to the byte iteration function\n+        // as well.\n+        for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n+            // Create the expression for this field.\n+            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n+            let field = build::mk_path(cx, span, ~[ field_ident ]);\n+\n+            // Call the substructure method.\n+            let stmt = call_substructure_iter_bytes_method(cx, span, field);\n+            stmts.push(stmt);\n+        }\n+\n+        // Create the pattern body.\n+        let match_body_block = build::mk_block_(cx, span, stmts);\n+\n+        // Create the arm.\n+        ast::arm {\n+            pats: ~[ pat ],\n+            guard: None,\n+            body: match_body_block,\n+        }\n+    };\n+\n+    // Create the method body.\n+    let self_match_expr = expand_enum_or_struct_match(cx, span, arms);\n+    let self_match_stmt = build::mk_stmt(cx, span, self_match_expr);\n+\n+    // Create the method.\n+    create_iter_bytes_method(cx, span, ~[ self_match_stmt ])\n+}"}, {"sha": "63bb4389999696101b98c551a7c3051aa247edb4", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/63a292fd8686f56efe7836aef46709a063efab4e/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63a292fd8686f56efe7836aef46709a063efab4e/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=63a292fd8686f56efe7836aef46709a063efab4e", "patch": "@@ -0,0 +1,309 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The compiler code necessary to implement the #[deriving_eq] and\n+/// #[deriving_iter_bytes] extensions.\n+\n+use core::prelude::*;\n+\n+use ast;\n+use ast::{TraitTyParamBound, Ty, and, bind_by_ref, binop, deref, enum_def};\n+use ast::{enum_variant_kind, expr, expr_match, ident, impure_fn, item, item_};\n+use ast::{item_enum, item_impl, item_struct, Generics};\n+use ast::{m_imm, meta_item, method};\n+use ast::{named_field, or, pat, pat_ident, pat_wild, public, pure_fn};\n+use ast::{stmt, struct_def, struct_variant_kind};\n+use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, TyParam};\n+use ast::{TyParamBound, ty_path, ty_rptr, unnamed_field, variant};\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use codemap::{span, spanned};\n+use parse::token::special_idents::clownshoes_extensions;\n+use opt_vec;\n+\n+use core::uint;\n+\n+pub mod clone;\n+pub mod eq;\n+pub mod iter_bytes;\n+\n+type ExpandDerivingStructDefFn = &'self fn(@ext_ctxt,\n+                                          span,\n+                                          x: &struct_def,\n+                                          ident,\n+                                          y: &Generics) -> @item;\n+type ExpandDerivingEnumDefFn = &'self fn(@ext_ctxt,\n+                                        span,\n+                                        x: &enum_def,\n+                                        ident,\n+                                        y: &Generics) -> @item;\n+\n+pub fn expand_meta_deriving(cx: @ext_ctxt,\n+                            _span: span,\n+                            mitem: @meta_item,\n+                            in_items: ~[@item])\n+                         -> ~[@item] {\n+    use ast::{meta_list, meta_name_value, meta_word};\n+\n+    match mitem.node {\n+        meta_name_value(_, l) => {\n+            cx.span_err(l.span, ~\"unexpected value in `deriving`\");\n+            in_items\n+        }\n+        meta_word(_) | meta_list(_, []) => {\n+            cx.span_warn(mitem.span, ~\"empty trait list in `deriving`\");\n+            in_items\n+        }\n+        meta_list(_, titems) => {\n+            do titems.foldr(in_items) |&titem, in_items| {\n+                match titem.node {\n+                    meta_name_value(tname, _) |\n+                    meta_list(tname, _) |\n+                    meta_word(tname) => {\n+                        match *tname {\n+                            ~\"Clone\" => clone::expand_deriving_clone(cx,\n+                                titem.span, titem, in_items),\n+                            ~\"Eq\" => eq::expand_deriving_eq(cx, titem.span,\n+                                titem, in_items),\n+                            ~\"IterBytes\" => iter_bytes::expand_deriving_iter_bytes(cx,\n+                                titem.span, titem, in_items),\n+                            tname => {\n+                                cx.span_err(titem.span, fmt!(\"unknown \\\n+                                    `deriving` trait: `%s`\", tname));\n+                                in_items\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn expand_deriving(cx: @ext_ctxt,\n+                   span: span,\n+                   in_items: ~[@item],\n+                   expand_deriving_struct_def: ExpandDerivingStructDefFn,\n+                   expand_deriving_enum_def: ExpandDerivingEnumDefFn)\n+                -> ~[@item] {\n+    let mut result = ~[];\n+    for in_items.each |item| {\n+        result.push(copy *item);\n+        match item.node {\n+            item_struct(struct_def, ref generics) => {\n+                result.push(expand_deriving_struct_def(cx,\n+                                                       span,\n+                                                       struct_def,\n+                                                       item.ident,\n+                                                       generics));\n+            }\n+            item_enum(ref enum_definition, ref generics) => {\n+                result.push(expand_deriving_enum_def(cx,\n+                                                     span,\n+                                                     enum_definition,\n+                                                     item.ident,\n+                                                     generics));\n+            }\n+            _ => ()\n+        }\n+    }\n+    result\n+}\n+\n+fn create_impl_item(cx: @ext_ctxt, span: span, +item: item_) -> @item {\n+    @ast::item {\n+        ident: clownshoes_extensions,\n+        attrs: ~[],\n+        id: cx.next_id(),\n+        node: item,\n+        vis: public,\n+        span: span,\n+    }\n+}\n+\n+pub fn create_self_type_with_params(cx: @ext_ctxt,\n+                                span: span,\n+                                type_ident: ident,\n+                                generics: &Generics)\n+                             -> @Ty {\n+    // Create the type parameters on the `self` path.\n+    let mut self_ty_params = ~[];\n+    for generics.ty_params.each |ty_param| {\n+        let self_ty_param = build::mk_simple_ty_path(cx,\n+                                                     span,\n+                                                     ty_param.ident);\n+        self_ty_params.push(self_ty_param);\n+    }\n+\n+    // Create the type of `self`.\n+    let self_type = build::mk_raw_path_(span,\n+                                        ~[ type_ident ],\n+                                        self_ty_params);\n+    let self_type = ty_path(self_type, cx.next_id());\n+    @ast::Ty { id: cx.next_id(), node: self_type, span: span }\n+}\n+\n+pub fn create_derived_impl(cx: @ext_ctxt,\n+                       span: span,\n+                       type_ident: ident,\n+                       generics: &Generics,\n+                       methods: &[@method],\n+                       trait_path: &[ident])\n+                    -> @item {\n+    /*!\n+     *\n+     * Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n+     * 'z, A, ..., Z>`, creates an impl like:\n+     *\n+     *      impl<'a, ..., 'z, A:Tr, ..., Z: Tr> Tr for T<A, ..., Z> { ... }\n+     *\n+     * FIXME(#5090): Remove code duplication between this and the\n+     * code in auto_encode.rs\n+     */\n+\n+    // Copy the lifetimes\n+    let impl_lifetimes = generics.lifetimes.map(|l| {\n+        build::mk_lifetime(cx, l.span, l.ident)\n+    });\n+\n+    // Create the type parameters.\n+    let impl_ty_params = generics.ty_params.map(|ty_param| {\n+        let bound = build::mk_ty_path_global(cx,\n+                                             span,\n+                                             trait_path.map(|x| *x));\n+        let bounds = @opt_vec::with(TraitTyParamBound(bound));\n+        build::mk_ty_param(cx, ty_param.ident, bounds)\n+    });\n+\n+    // Create the reference to the trait.\n+    let trait_path = ast::path {\n+        span: span,\n+        global: true,\n+        idents: trait_path.map(|x| *x),\n+        rp: None,\n+        types: ~[]\n+    };\n+    let trait_path = @trait_path;\n+    let trait_ref = ast::trait_ref {\n+        path: trait_path,\n+        ref_id: cx.next_id()\n+    };\n+    let trait_ref = @trait_ref;\n+\n+    // Create the type of `self`.\n+    let self_type = create_self_type_with_params(cx,\n+                                                 span,\n+                                                 type_ident,\n+                                                 generics);\n+\n+    // Create the impl item.\n+    let impl_item = item_impl(Generics {lifetimes: impl_lifetimes,\n+                                        ty_params: impl_ty_params},\n+                              Some(trait_ref),\n+                              self_type,\n+                              methods.map(|x| *x));\n+    return create_impl_item(cx, span, impl_item);\n+}\n+\n+pub fn create_subpatterns(cx: @ext_ctxt,\n+                      span: span,\n+                      prefix: ~str,\n+                      n: uint)\n+                   -> ~[@pat] {\n+    let mut subpats = ~[];\n+    for uint::range(0, n) |_i| {\n+        // Create the subidentifier.\n+        let index = subpats.len().to_str();\n+        let ident = cx.ident_of(prefix + index);\n+\n+        // Create the subpattern.\n+        let subpath = build::mk_raw_path(span, ~[ ident ]);\n+        let subpat = pat_ident(bind_by_ref(m_imm), subpath, None);\n+        let subpat = build::mk_pat(cx, span, subpat);\n+        subpats.push(subpat);\n+    }\n+    return subpats;\n+}\n+\n+pub fn is_struct_tuple(struct_def: &struct_def) -> bool {\n+    struct_def.fields.len() > 0 && struct_def.fields.all(|f| {\n+        match f.node.kind {\n+            named_field(*) => false,\n+            unnamed_field => true\n+        }\n+    })\n+}\n+\n+pub fn create_enum_variant_pattern(cx: @ext_ctxt,\n+                               span: span,\n+                               variant: &variant,\n+                               prefix: ~str)\n+                            -> @pat {\n+    let variant_ident = variant.node.name;\n+    match variant.node.kind {\n+        tuple_variant_kind(ref variant_args) => {\n+            if variant_args.len() == 0 {\n+                return build::mk_pat_ident_with_binding_mode(\n+                    cx, span, variant_ident, ast::bind_infer);\n+            }\n+\n+            let matching_path = build::mk_raw_path(span, ~[ variant_ident ]);\n+            let subpats = create_subpatterns(cx,\n+                                             span,\n+                                             prefix,\n+                                             variant_args.len());\n+\n+            return build::mk_pat_enum(cx, span, matching_path, subpats);\n+        }\n+        struct_variant_kind(struct_def) => {\n+            let matching_path = build::mk_raw_path(span, ~[ variant_ident ]);\n+            let subpats = create_subpatterns(cx,\n+                                             span,\n+                                             prefix,\n+                                             struct_def.fields.len());\n+\n+            let field_pats = do struct_def.fields.mapi |i, struct_field| {\n+                let ident = match struct_field.node.kind {\n+                    named_field(ident, _, _) => ident,\n+                    unnamed_field => {\n+                        cx.span_bug(span, ~\"unexpected unnamed field\");\n+                    }\n+                };\n+                ast::field_pat { ident: ident, pat: subpats[i] }\n+            };\n+\n+            build::mk_pat_struct(cx, span, matching_path, field_pats)\n+        }\n+        enum_variant_kind(*) => {\n+            cx.span_unimpl(span, ~\"enum variants for `deriving`\");\n+        }\n+    }\n+}\n+\n+pub fn variant_arg_count(cx: @ext_ctxt, span: span, variant: &variant) -> uint {\n+    match variant.node.kind {\n+        tuple_variant_kind(ref args) => args.len(),\n+        struct_variant_kind(ref struct_def) => struct_def.fields.len(),\n+        enum_variant_kind(*) => {\n+            cx.span_bug(span, ~\"variant_arg_count: enum variants deprecated\")\n+        }\n+    }\n+}\n+\n+pub fn expand_enum_or_struct_match(cx: @ext_ctxt,\n+                               span: span,\n+                               arms: ~[ ast::arm ])\n+                            -> @expr {\n+    let self_ident = cx.ident_of(~\"self\");\n+    let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n+    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n+    let self_match_expr = expr_match(self_expr, arms);\n+    build::mk_expr(cx, span, self_match_expr)\n+}"}, {"sha": "01ed707b0aef6b346568b7ba1501d7cb52c5c63e", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63a292fd8686f56efe7836aef46709a063efab4e/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/63a292fd8686f56efe7836aef46709a063efab4e/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=63a292fd8686f56efe7836aef46709a063efab4e", "patch": "@@ -64,6 +64,8 @@ pub mod ext {\n     pub mod expand;\n \n     pub mod quote;\n+\n+    #[path = \"deriving/mod.rs\"]\n     pub mod deriving;\n \n     pub mod build;"}]}