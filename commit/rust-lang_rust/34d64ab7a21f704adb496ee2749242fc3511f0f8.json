{"sha": "34d64ab7a21f704adb496ee2749242fc3511f0f8", "node_id": "C_kwDOAAsO6NoAKDM0ZDY0YWI3YTIxZjcwNGFkYjQ5NmVlMjc0OTI0MmZjMzUxMWYwZjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-11T03:42:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-11T03:42:14Z"}, "message": "Auto merge of #112466 - lcnr:opaque-type-cleanup, r=compiler-errors\n\nopaque type cleanup\n\nthe commits are pretty self-contained.\n\nr? `@compiler-errors` cc `@oli-obk`", "tree": {"sha": "b3b18faa5de609c681a53429bd1e4091f72362fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3b18faa5de609c681a53429bd1e4091f72362fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34d64ab7a21f704adb496ee2749242fc3511f0f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34d64ab7a21f704adb496ee2749242fc3511f0f8", "html_url": "https://github.com/rust-lang/rust/commit/34d64ab7a21f704adb496ee2749242fc3511f0f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34d64ab7a21f704adb496ee2749242fc3511f0f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "970058e16b307e1cff01e2ddb084d2e8d14ea8be", "url": "https://api.github.com/repos/rust-lang/rust/commits/970058e16b307e1cff01e2ddb084d2e8d14ea8be", "html_url": "https://github.com/rust-lang/rust/commit/970058e16b307e1cff01e2ddb084d2e8d14ea8be"}, {"sha": "b62e20d2fd5fd186a662c5621a41b717fcc313e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b62e20d2fd5fd186a662c5621a41b717fcc313e0", "html_url": "https://github.com/rust-lang/rust/commit/b62e20d2fd5fd186a662c5621a41b717fcc313e0"}], "stats": {"total": 379, "additions": 204, "deletions": 175}, "files": [{"sha": "b5d5071dc05360716328fe72802b7e0e6ddde089", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 77, "deletions": 73, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/34d64ab7a21f704adb496ee2749242fc3511f0f8/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d64ab7a21f704adb496ee2749242fc3511f0f8/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=34d64ab7a21f704adb496ee2749242fc3511f0f8", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'tcx>,\n-        opaque_ty_decls: FxIndexMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n+        opaque_ty_decls: FxIndexMap<OpaqueTypeKey<'tcx>, OpaqueHiddenType<'tcx>>,\n     ) -> FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>> {\n         let mut result: FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>> = FxIndexMap::default();\n \n@@ -72,7 +72,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .collect();\n         debug!(?member_constraints);\n \n-        for (opaque_type_key, (concrete_type, origin)) in opaque_ty_decls {\n+        for (opaque_type_key, concrete_type) in opaque_ty_decls {\n             let substs = opaque_type_key.substs;\n             debug!(?concrete_type, ?substs);\n \n@@ -143,7 +143,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let ty = infcx.infer_opaque_definition_from_instantiation(\n                 opaque_type_key,\n                 universal_concrete_type,\n-                origin,\n             );\n             // Sometimes two opaque types are the same only after we remap the generic parameters\n             // back to the opaque type definition. E.g. we may have `OpaqueType<X, Y>` mapped to `(X, Y)`\n@@ -215,7 +214,6 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n         instantiated_ty: OpaqueHiddenType<'tcx>,\n-        origin: OpaqueTyOrigin,\n     ) -> Ty<'tcx>;\n }\n \n@@ -248,109 +246,115 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n         instantiated_ty: OpaqueHiddenType<'tcx>,\n-        origin: OpaqueTyOrigin,\n     ) -> Ty<'tcx> {\n         if let Some(e) = self.tainted_by_errors() {\n             return self.tcx.ty_error(e);\n         }\n \n+        if let Err(guar) =\n+            check_opaque_type_parameter_valid(self.tcx, opaque_type_key, instantiated_ty.span)\n+        {\n+            return self.tcx.ty_error(guar);\n+        }\n+\n         let definition_ty = instantiated_ty\n             .remap_generic_params_to_declaration_params(opaque_type_key, self.tcx, false)\n             .ty;\n \n-        if let Err(guar) = check_opaque_type_parameter_valid(\n+        // `definition_ty` does not live in of the current inference context,\n+        // so lets make sure that we don't accidentally misuse our current `infcx`.\n+        match check_opaque_type_well_formed(\n             self.tcx,\n-            opaque_type_key,\n-            origin,\n+            self.next_trait_solver(),\n+            opaque_type_key.def_id,\n             instantiated_ty.span,\n+            definition_ty,\n         ) {\n-            return self.tcx.ty_error(guar);\n+            Ok(hidden_ty) => hidden_ty,\n+            Err(guar) => self.tcx.ty_error(guar),\n         }\n+    }\n+}\n \n-        // Only check this for TAIT. RPIT already supports `tests/ui/impl-trait/nested-return-type2.rs`\n-        // on stable and we'd break that.\n-        let OpaqueTyOrigin::TyAlias { .. } = origin else {\n-            return definition_ty;\n-        };\n-        let def_id = opaque_type_key.def_id;\n-        // This logic duplicates most of `check_opaque_meets_bounds`.\n-        // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n-        let param_env = self.tcx.param_env(def_id);\n-        // HACK This bubble is required for this tests to pass:\n-        // nested-return-type2-tait2.rs\n-        // nested-return-type2-tait3.rs\n-        // FIXME(-Ztrait-solver=next): We probably should use `DefiningAnchor::Error`\n-        // and prepopulate this `InferCtxt` with known opaque values, rather than\n-        // using the `Bind` anchor here. For now it's fine.\n-        let infcx = self\n-            .tcx\n-            .infer_ctxt()\n-            .with_opaque_type_inference(if self.next_trait_solver() {\n-                DefiningAnchor::Bind(def_id)\n-            } else {\n-                DefiningAnchor::Bubble\n-            })\n-            .build();\n-        let ocx = ObligationCtxt::new(&infcx);\n-        // Require the hidden type to be well-formed with only the generics of the opaque type.\n-        // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-        // hidden type is well formed even without those bounds.\n-        let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()));\n-\n-        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n+/// This logic duplicates most of `check_opaque_meets_bounds`.\n+/// FIXME(oli-obk): Also do region checks here and then consider removing\n+/// `check_opaque_meets_bounds` entirely.\n+fn check_opaque_type_well_formed<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    next_trait_solver: bool,\n+    def_id: LocalDefId,\n+    definition_span: Span,\n+    definition_ty: Ty<'tcx>,\n+) -> Result<Ty<'tcx>, ErrorGuaranteed> {\n+    // Only check this for TAIT. RPIT already supports `tests/ui/impl-trait/nested-return-type2.rs`\n+    // on stable and we'd break that.\n+    let opaque_ty_hir = tcx.hir().expect_item(def_id);\n+    let OpaqueTyOrigin::TyAlias { .. } = opaque_ty_hir.expect_opaque_ty().origin else {\n+        return Ok(definition_ty);\n+    };\n+    let param_env = tcx.param_env(def_id);\n+    // HACK This bubble is required for this tests to pass:\n+    // nested-return-type2-tait2.rs\n+    // nested-return-type2-tait3.rs\n+    // FIXME(-Ztrait-solver=next): We probably should use `DefiningAnchor::Error`\n+    // and prepopulate this `InferCtxt` with known opaque values, rather than\n+    // using the `Bind` anchor here. For now it's fine.\n+    let infcx = tcx\n+        .infer_ctxt()\n+        .with_next_trait_solver(next_trait_solver)\n+        .with_opaque_type_inference(if next_trait_solver {\n+            DefiningAnchor::Bind(def_id)\n+        } else {\n+            DefiningAnchor::Bubble\n+        })\n+        .build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+    let identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n \n-        // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n-        // the bounds that the function supplies.\n-        let opaque_ty = self.tcx.mk_opaque(def_id.to_def_id(), id_substs);\n-        if let Err(err) = ocx.eq(\n-            &ObligationCause::misc(instantiated_ty.span, def_id),\n-            param_env,\n-            opaque_ty,\n-            definition_ty,\n-        ) {\n+    // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n+    // the bounds that the function supplies.\n+    let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), identity_substs);\n+    ocx.eq(&ObligationCause::misc(definition_span, def_id), param_env, opaque_ty, definition_ty)\n+        .map_err(|err| {\n             infcx\n                 .err_ctxt()\n                 .report_mismatched_types(\n-                    &ObligationCause::misc(instantiated_ty.span, def_id),\n+                    &ObligationCause::misc(definition_span, def_id),\n                     opaque_ty,\n                     definition_ty,\n                     err,\n                 )\n-                .emit();\n-        }\n+                .emit()\n+        })?;\n \n-        ocx.register_obligation(Obligation::misc(\n-            infcx.tcx,\n-            instantiated_ty.span,\n-            def_id,\n-            param_env,\n-            predicate,\n-        ));\n+    // Require the hidden type to be well-formed with only the generics of the opaque type.\n+    // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+    // hidden type is well formed even without those bounds.\n+    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()));\n+    ocx.register_obligation(Obligation::misc(tcx, definition_span, def_id, param_env, predicate));\n \n-        // Check that all obligations are satisfied by the implementation's\n-        // version.\n-        let errors = ocx.select_all_or_error();\n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n+    let errors = ocx.select_all_or_error();\n \n-        // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n-        // tests to pass\n-        let _ = infcx.take_opaque_types();\n+    // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n+    // tests to pass\n+    let _ = infcx.take_opaque_types();\n \n-        if errors.is_empty() {\n-            definition_ty\n-        } else {\n-            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors);\n-            self.tcx.ty_error(reported)\n-        }\n+    if errors.is_empty() {\n+        Ok(definition_ty)\n+    } else {\n+        Err(infcx.err_ctxt().report_fulfillment_errors(&errors))\n     }\n }\n \n fn check_opaque_type_parameter_valid(\n     tcx: TyCtxt<'_>,\n     opaque_type_key: OpaqueTypeKey<'_>,\n-    origin: OpaqueTyOrigin,\n     span: Span,\n ) -> Result<(), ErrorGuaranteed> {\n-    match origin {\n+    let opaque_ty_hir = tcx.hir().expect_item(opaque_type_key.def_id);\n+    match opaque_ty_hir.expect_opaque_ty().origin {\n         // No need to check return position impl trait (RPIT)\n         // because for type and const parameters they are correct\n         // by construction: we convert"}, {"sha": "6697e1aff7dd06bbaa5abb4a5cc03d0b48ad6ef3", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/34d64ab7a21f704adb496ee2749242fc3511f0f8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d64ab7a21f704adb496ee2749242fc3511f0f8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=34d64ab7a21f704adb496ee2749242fc3511f0f8", "patch": "@@ -7,7 +7,6 @@ use std::{fmt, iter, mem};\n \n use either::Either;\n \n-use hir::OpaqueTyOrigin;\n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_errors::ErrorGuaranteed;\n@@ -28,6 +27,7 @@ use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::*;\n use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::subst::{SubstsRef, UserSubsts};\n@@ -241,7 +241,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n                 hidden_type.ty = infcx.tcx.ty_error(reported);\n             }\n \n-            (opaque_type_key, (hidden_type, decl.origin))\n+            (opaque_type_key, hidden_type)\n         })\n         .collect();\n \n@@ -878,8 +878,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n pub(crate) struct MirTypeckResults<'tcx> {\n     pub(crate) constraints: MirTypeckRegionConstraints<'tcx>,\n     pub(crate) universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-    pub(crate) opaque_type_values:\n-        FxIndexMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n+    pub(crate) opaque_type_values: FxIndexMap<OpaqueTypeKey<'tcx>, OpaqueHiddenType<'tcx>>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n@@ -1053,15 +1052,28 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             ConstraintCategory::OpaqueType,\n             CustomTypeOp::new(\n                 |ocx| {\n-                    for (key, hidden_ty) in renumbered_opaques {\n-                        ocx.register_infer_ok_obligations(\n-                            ocx.infcx.register_hidden_type_in_new_solver(\n-                                key,\n-                                param_env,\n-                                hidden_ty.ty,\n-                            )?,\n+                    let mut obligations = Vec::new();\n+                    for (opaque_type_key, hidden_ty) in renumbered_opaques {\n+                        let cause = ObligationCause::dummy();\n+                        ocx.infcx.insert_hidden_type(\n+                            opaque_type_key,\n+                            &cause,\n+                            param_env,\n+                            hidden_ty.ty,\n+                            true,\n+                            &mut obligations,\n+                        )?;\n+\n+                        ocx.infcx.add_item_bounds_for_hidden_type(\n+                            opaque_type_key,\n+                            cause,\n+                            param_env,\n+                            hidden_ty.ty,\n+                            &mut obligations,\n                         );\n                     }\n+\n+                    ocx.register_obligations(obligations);\n                     Ok(())\n                 },\n                 \"register pre-defined opaques\","}, {"sha": "6b8293f90f10aa8093d6de5b1740bac5c0d7472d", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 57, "deletions": 53, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/34d64ab7a21f704adb496ee2749242fc3511f0f8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d64ab7a21f704adb496ee2749242fc3511f0f8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=34d64ab7a21f704adb496ee2749242fc3511f0f8", "patch": "@@ -33,9 +33,6 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// There can be multiple, but they are all `lub`ed together at the end\n     /// to obtain the canonical hidden type.\n     pub hidden_type: OpaqueHiddenType<'tcx>,\n-\n-    /// The origin of the opaque type.\n-    pub origin: hir::OpaqueTyOrigin,\n }\n \n impl<'tcx> InferCtxt<'tcx> {\n@@ -108,7 +105,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         let process = |a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected| match *a.kind() {\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) if def_id.is_local() => {\n                 let def_id = def_id.expect_local();\n-                let origin = match self.defining_use_anchor {\n+                match self.defining_use_anchor {\n                     DefiningAnchor::Bind(_) => {\n                         // Check that this is `impl Trait` type is\n                         // declared by `parent_def_id` -- i.e., one whose\n@@ -144,9 +141,11 @@ impl<'tcx> InferCtxt<'tcx> {\n                         //     let x = || foo(); // returns the Opaque assoc with `foo`\n                         // }\n                         // ```\n-                        self.opaque_type_origin(def_id)?\n+                        if self.opaque_type_origin(def_id).is_none() {\n+                            return None;\n+                        }\n                     }\n-                    DefiningAnchor::Bubble => self.opaque_type_origin_unchecked(def_id),\n+                    DefiningAnchor::Bubble => {}\n                     DefiningAnchor::Error => return None,\n                 };\n                 if let ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }) = *b.kind() {\n@@ -170,7 +169,6 @@ impl<'tcx> InferCtxt<'tcx> {\n                     cause.clone(),\n                     param_env,\n                     b,\n-                    origin,\n                     a_is_expected,\n                 ))\n             }\n@@ -524,72 +522,78 @@ impl<'tcx> InferCtxt<'tcx> {\n         cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         hidden_ty: Ty<'tcx>,\n-        origin: hir::OpaqueTyOrigin,\n         a_is_expected: bool,\n     ) -> InferResult<'tcx, ()> {\n+        let mut obligations = Vec::new();\n+\n+        self.insert_hidden_type(\n+            opaque_type_key,\n+            &cause,\n+            param_env,\n+            hidden_ty,\n+            a_is_expected,\n+            &mut obligations,\n+        )?;\n+\n+        self.add_item_bounds_for_hidden_type(\n+            opaque_type_key,\n+            cause,\n+            param_env,\n+            hidden_ty,\n+            &mut obligations,\n+        );\n+\n+        Ok(InferOk { value: (), obligations })\n+    }\n+\n+    /// Insert a hidden type into the opaque type storage, equating it\n+    /// with any previous entries if necessary.\n+    ///\n+    /// This **does not** add the item bounds of the opaque as nested\n+    /// obligations. That is only necessary when normalizing the opaque\n+    /// itself, not when getting the opaque type constraints from\n+    /// somewhere else.\n+    pub fn insert_hidden_type(\n+        &self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        hidden_ty: Ty<'tcx>,\n+        a_is_expected: bool,\n+        obligations: &mut Vec<PredicateObligation<'tcx>>,\n+    ) -> Result<(), TypeError<'tcx>> {\n         // Ideally, we'd get the span where *this specific `ty` came\n         // from*, but right now we just use the span from the overall\n         // value being folded. In simple cases like `-> impl Foo`,\n         // these are the same span, but not in cases like `-> (impl\n         // Foo, impl Bar)`.\n         let span = cause.span;\n-        let mut obligations = if self.intercrate {\n+        if self.intercrate {\n             // During intercrate we do not define opaque types but instead always\n             // force ambiguity unless the hidden type is known to not implement\n             // our trait.\n-            vec![traits::Obligation::new(\n+            obligations.push(traits::Obligation::new(\n                 self.tcx,\n                 cause.clone(),\n                 param_env,\n                 ty::PredicateKind::Ambiguous,\n-            )]\n+            ))\n         } else {\n-            let prev = self.inner.borrow_mut().opaque_types().register(\n-                opaque_type_key,\n-                OpaqueHiddenType { ty: hidden_ty, span },\n-                origin,\n-            );\n+            let prev = self\n+                .inner\n+                .borrow_mut()\n+                .opaque_types()\n+                .register(opaque_type_key, OpaqueHiddenType { ty: hidden_ty, span });\n             if let Some(prev) = prev {\n-                self.at(&cause, param_env)\n-                    .eq_exp(DefineOpaqueTypes::Yes, a_is_expected, prev, hidden_ty)?\n-                    .obligations\n-            } else {\n-                Vec::new()\n+                obligations.extend(\n+                    self.at(&cause, param_env)\n+                        .eq_exp(DefineOpaqueTypes::Yes, a_is_expected, prev, hidden_ty)?\n+                        .obligations,\n+                );\n             }\n         };\n \n-        self.add_item_bounds_for_hidden_type(\n-            opaque_type_key,\n-            cause,\n-            param_env,\n-            hidden_ty,\n-            &mut obligations,\n-        );\n-\n-        Ok(InferOk { value: (), obligations })\n-    }\n-\n-    /// Registers an opaque's hidden type -- only should be used when the opaque\n-    /// can be defined. For something more fallible -- checks the anchors, tries\n-    /// to unify opaques in both dirs, etc. -- use `InferCtxt::handle_opaque_type`.\n-    pub fn register_hidden_type_in_new_solver(\n-        &self,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        hidden_ty: Ty<'tcx>,\n-    ) -> InferResult<'tcx, ()> {\n-        assert!(self.next_trait_solver());\n-        let origin = self\n-            .opaque_type_origin(opaque_type_key.def_id)\n-            .expect(\"should be called for defining usages only\");\n-        self.register_hidden_type(\n-            opaque_type_key,\n-            ObligationCause::dummy(),\n-            param_env,\n-            hidden_ty,\n-            origin,\n-            true,\n-        )\n+        Ok(())\n     }\n \n     pub fn add_item_bounds_for_hidden_type("}, {"sha": "a737761ba228276cd0361aaa983d1fdd307af5b7", "filename": "compiler/rustc_infer/src/infer/opaque_types/table.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34d64ab7a21f704adb496ee2749242fc3511f0f8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d64ab7a21f704adb496ee2749242fc3511f0f8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs?ref=34d64ab7a21f704adb496ee2749242fc3511f0f8", "patch": "@@ -1,5 +1,4 @@\n use rustc_data_structures::undo_log::UndoLogs;\n-use rustc_hir::OpaqueTyOrigin;\n use rustc_middle::ty::{self, OpaqueHiddenType, OpaqueTypeKey, Ty};\n use rustc_span::DUMMY_SP;\n \n@@ -60,14 +59,13 @@ impl<'a, 'tcx> OpaqueTypeTable<'a, 'tcx> {\n         &mut self,\n         key: OpaqueTypeKey<'tcx>,\n         hidden_type: OpaqueHiddenType<'tcx>,\n-        origin: OpaqueTyOrigin,\n     ) -> Option<Ty<'tcx>> {\n         if let Some(decl) = self.storage.opaque_types.get_mut(&key) {\n             let prev = std::mem::replace(&mut decl.hidden_type, hidden_type);\n             self.undo_log.push(UndoLog::OpaqueTypes(key, Some(prev)));\n             return Some(prev.ty);\n         }\n-        let decl = OpaqueTypeDecl { hidden_type, origin };\n+        let decl = OpaqueTypeDecl { hidden_type };\n         self.storage.opaque_types.insert(key, decl);\n         self.undo_log.push(UndoLog::OpaqueTypes(key, None));\n         None"}, {"sha": "e01187bcd3c2a81b05565912d893041360ab715d", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/34d64ab7a21f704adb496ee2749242fc3511f0f8/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d64ab7a21f704adb496ee2749242fc3511f0f8/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=34d64ab7a21f704adb496ee2749242fc3511f0f8", "patch": "@@ -15,8 +15,8 @@ use rustc_middle::traits::solve::{\n };\n use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::{\n-    self, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n-    TypeVisitor,\n+    self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable, TypeVisitable,\n+    TypeVisitableExt, TypeVisitor,\n };\n use rustc_span::DUMMY_SP;\n use std::ops::ControlFlow;\n@@ -191,16 +191,6 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 .with_opaque_type_inference(canonical_input.value.anchor)\n                 .build_with_canonical(DUMMY_SP, &canonical_input);\n \n-            for &(a, b) in &input.predefined_opaques_in_body.opaque_types {\n-                let InferOk { value: (), obligations } = infcx\n-                    .register_hidden_type_in_new_solver(a, input.goal.param_env, b)\n-                    .expect(\"expected opaque type instantiation to succeed\");\n-                // We're only registering opaques already defined by the caller,\n-                // so we're not responsible for proving that they satisfy their\n-                // item bounds, unless we use them in a normalizes-to goal,\n-                // which is handled in `EvalCtxt::unify_existing_opaque_tys`.\n-                let _ = obligations;\n-            }\n             let mut ecx = EvalCtxt {\n                 infcx,\n                 var_values,\n@@ -211,6 +201,15 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 tainted: Ok(()),\n             };\n \n+            for &(key, ty) in &input.predefined_opaques_in_body.opaque_types {\n+                ecx.insert_hidden_type(key, input.goal.param_env, ty)\n+                    .expect(\"failed to prepopulate opaque types\");\n+            }\n+\n+            if !ecx.nested_goals.is_empty() {\n+                panic!(\"prepopulating opaque types shouldn't add goals: {:?}\", ecx.nested_goals);\n+            }\n+\n             let result = ecx.compute_goal(input.goal);\n \n             // When creating a query response we clone the opaque type constraints\n@@ -729,18 +728,42 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         self.infcx.opaque_type_origin(def_id).is_some()\n     }\n \n-    pub(super) fn register_opaque_ty(\n+    pub(super) fn insert_hidden_type(\n         &mut self,\n-        a: ty::OpaqueTypeKey<'tcx>,\n-        b: Ty<'tcx>,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n+        hidden_ty: Ty<'tcx>,\n     ) -> Result<(), NoSolution> {\n-        let InferOk { value: (), obligations } =\n-            self.infcx.register_hidden_type_in_new_solver(a, param_env, b)?;\n-        self.add_goals(obligations.into_iter().map(|obligation| obligation.into()));\n+        let mut obligations = Vec::new();\n+        self.infcx.insert_hidden_type(\n+            opaque_type_key,\n+            &ObligationCause::dummy(),\n+            param_env,\n+            hidden_ty,\n+            true,\n+            &mut obligations,\n+        )?;\n+        self.add_goals(obligations.into_iter().map(|o| o.into()));\n         Ok(())\n     }\n \n+    pub(super) fn add_item_bounds_for_hidden_type(\n+        &mut self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        hidden_ty: Ty<'tcx>,\n+    ) {\n+        let mut obligations = Vec::new();\n+        self.infcx.add_item_bounds_for_hidden_type(\n+            opaque_type_key,\n+            ObligationCause::dummy(),\n+            param_env,\n+            hidden_ty,\n+            &mut obligations,\n+        );\n+        self.add_goals(obligations.into_iter().map(|o| o.into()));\n+    }\n+\n     // Do something for each opaque/hidden pair defined with `def_id` in the\n     // current inference context.\n     pub(super) fn unify_existing_opaque_tys(\n@@ -762,15 +785,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                     ecx.eq(param_env, a, b)?;\n                 }\n                 ecx.eq(param_env, candidate_ty, ty)?;\n-                let mut obl = vec![];\n-                ecx.infcx.add_item_bounds_for_hidden_type(\n-                    candidate_key,\n-                    ObligationCause::dummy(),\n-                    param_env,\n-                    candidate_ty,\n-                    &mut obl,\n-                );\n-                ecx.add_goals(obl.into_iter().map(Into::into));\n+                ecx.add_item_bounds_for_hidden_type(candidate_key, param_env, candidate_ty);\n                 ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             }));\n         }"}, {"sha": "851edf1fa1cb62834d406f7f249dd5751f2ea343", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34d64ab7a21f704adb496ee2749242fc3511f0f8/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d64ab7a21f704adb496ee2749242fc3511f0f8/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=34d64ab7a21f704adb496ee2749242fc3511f0f8", "patch": "@@ -16,7 +16,6 @@ use rustc_index::IndexVec;\n use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::canonical::{CanonicalExt, QueryRegionConstraints};\n-use rustc_infer::infer::InferOk;\n use rustc_middle::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n     ExternalConstraints, ExternalConstraintsData, MaybeCause, PredefinedOpaquesData, QueryInput,\n@@ -321,12 +320,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         opaque_types: &[(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)],\n     ) -> Result<(), NoSolution> {\n-        for &(a, b) in opaque_types {\n-            let InferOk { value: (), obligations } =\n-                self.infcx.register_hidden_type_in_new_solver(a, param_env, b)?;\n-            // It's sound to drop these obligations, since the normalizes-to goal\n-            // is responsible for proving these obligations.\n-            let _ = obligations;\n+        for &(key, ty) in opaque_types {\n+            self.insert_hidden_type(key, param_env, ty)?;\n         }\n         Ok(())\n     }"}, {"sha": "538c16c8ce2cde6eef9a8104e05a4575ed3536d6", "filename": "compiler/rustc_trait_selection/src/solve/opaques.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34d64ab7a21f704adb496ee2749242fc3511f0f8/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d64ab7a21f704adb496ee2749242fc3511f0f8/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs?ref=34d64ab7a21f704adb496ee2749242fc3511f0f8", "patch": "@@ -50,7 +50,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                     }\n                 }\n                 // Otherwise, define a new opaque type\n-                self.register_opaque_ty(opaque_ty, expected, goal.param_env)?;\n+                self.insert_hidden_type(opaque_ty, goal.param_env, expected)?;\n+                self.add_item_bounds_for_hidden_type(opaque_ty, goal.param_env, expected);\n                 self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             }\n             (Reveal::UserFacing, SolverMode::Coherence) => {"}]}