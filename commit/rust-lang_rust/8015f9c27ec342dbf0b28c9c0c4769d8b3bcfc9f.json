{"sha": "8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwMTVmOWMyN2VjMzQyZGJmMGIyOGM5YzBjNDc2OWQ4YjNiY2ZjOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-10T13:06:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-10T13:06:24Z"}, "message": "auto merge of #9791 : alexcrichton/rust/reachable, r=catamorphism\n\nThis fixes a bug in which the visibility rules were approximated by\r\nreachability, but forgot to cover the case where a 'pub use' reexports a private\r\nitem. This fixes the commit by instead using the results of the privacy pass of\r\nthe compiler to create the initial working set of the reachability pass.\r\n\r\nThis may have the side effect of increasing the size of metadata, but it's\r\ndifficult to avoid for correctness purposes sadly.\r\n\r\nCloses #9790", "tree": {"sha": "70de1d8ad3a4d6ddc671f92bbd3a1af5b789542f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70de1d8ad3a4d6ddc671f92bbd3a1af5b789542f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "html_url": "https://github.com/rust-lang/rust/commit/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ede2ea4e2e9384ac5bd614012d85ed213873dab", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ede2ea4e2e9384ac5bd614012d85ed213873dab", "html_url": "https://github.com/rust-lang/rust/commit/0ede2ea4e2e9384ac5bd614012d85ed213873dab"}, {"sha": "caf7b678dd2f07918b47120aa73a1bca51d12da1", "url": "https://api.github.com/repos/rust-lang/rust/commits/caf7b678dd2f07918b47120aa73a1bca51d12da1", "html_url": "https://github.com/rust-lang/rust/commit/caf7b678dd2f07918b47120aa73a1bca51d12da1"}], "stats": {"total": 271, "additions": 111, "deletions": 160}, "files": [{"sha": "0c896007fc3baee95c7f42f21741d42735a7fdd0", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -263,9 +263,10 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n                                           method_map, ty_cx));\n \n     let maps = (external_exports, last_private_map);\n-    time(time_passes, \"privacy checking\", maps, |(a, b)|\n-         middle::privacy::check_crate(ty_cx, &method_map, &exp_map2,\n-                                      a, b, crate));\n+    let exported_items =\n+        time(time_passes, \"privacy checking\", maps, |(a, b)|\n+             middle::privacy::check_crate(ty_cx, &method_map, &exp_map2,\n+                                          a, b, crate));\n \n     time(time_passes, \"effect checking\", (), |_|\n          middle::effect::check_crate(ty_cx, method_map, crate));\n@@ -300,7 +301,8 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n \n     let reachable_map =\n         time(time_passes, \"reachability checking\", (), |_|\n-             reachable::find_reachable(ty_cx, method_map, crate));\n+             reachable::find_reachable(ty_cx, method_map, exp_map2,\n+                                       &exported_items));\n \n     time(time_passes, \"lint checking\", (), |_|\n          lint::check_crate(ty_cx, crate));"}, {"sha": "6f52ba5db4e10eb0538127daaba44736a3ae127d", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -31,6 +31,10 @@ use syntax::visit::Visitor;\n \n type Context<'self> = (&'self method_map, &'self resolve::ExportMap2);\n \n+// A set of all nodes in the ast which can be considered \"publicly exported\" in\n+// the sense that they are accessible from anywhere in any hierarchy.\n+pub type ExportedItems = HashSet<ast::NodeId>;\n+\n // This visitor is used to determine the parent of all nodes in question when it\n // comes to privacy. This is used to determine later on if a usage is actually\n // valid or not.\n@@ -137,7 +141,7 @@ impl<'self> Visitor<()> for ParentVisitor<'self> {\n // This visitor is used to determine which items of the ast are embargoed,\n // otherwise known as not exported.\n struct EmbargoVisitor<'self> {\n-    exported_items: &'self mut HashSet<ast::NodeId>,\n+    exported_items: &'self mut ExportedItems,\n     exp_map2: &'self resolve::ExportMap2,\n     path_all_public: bool,\n }\n@@ -239,7 +243,7 @@ struct PrivacyVisitor<'self> {\n     curitem: ast::NodeId,\n \n     // Results of previous analyses necessary for privacy checking.\n-    exported_items: &'self HashSet<ast::NodeId>,\n+    exported_items: &'self ExportedItems,\n     method_map: &'self method_map,\n     parents: &'self HashMap<ast::NodeId, ast::NodeId>,\n     external_exports: resolve::ExternalExports,\n@@ -785,7 +789,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                    exp_map2: &resolve::ExportMap2,\n                    external_exports: resolve::ExternalExports,\n                    last_private_map: resolve::LastPrivateMap,\n-                   crate: &ast::Crate) {\n+                   crate: &ast::Crate) -> ExportedItems {\n     let mut parents = HashMap::new();\n     let mut exported_items = HashSet::new();\n \n@@ -802,7 +806,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     {\n         // Initialize the exported items with resolve's id for the \"root crate\"\n         // to resolve references to `super` leading to the root and such.\n-        exported_items.insert(0);\n+        exported_items.insert(ast::CRATE_NODE_ID);\n         let mut visitor = EmbargoVisitor {\n             exported_items: &mut exported_items,\n             exp_map2: exp_map2,\n@@ -824,4 +828,5 @@ pub fn check_crate(tcx: ty::ctxt,\n         };\n         visit::walk_crate(&mut visitor, crate, ());\n     }\n+    return exported_items;\n }"}, {"sha": "3c78c86d43603d2b71faa8fc650c4d6c74eac30a", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 50, "deletions": 138, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -17,11 +17,13 @@\n \n use middle::ty;\n use middle::typeck;\n+use middle::privacy;\n+use middle::resolve;\n \n use std::hashmap::HashSet;\n use syntax::ast::*;\n use syntax::ast_map;\n-use syntax::ast_util::def_id_of_def;\n+use syntax::ast_util::{def_id_of_def, is_local};\n use syntax::attr;\n use syntax::parse::token;\n use syntax::visit::Visitor;\n@@ -71,15 +73,6 @@ fn trait_method_might_be_inlined(trait_method: &trait_method) -> bool {\n     }\n }\n \n-// The context we're in. If we're in a public context, then public symbols are\n-// marked reachable. If we're in a private context, then only trait\n-// implementations are marked reachable.\n-#[deriving(Clone, Eq)]\n-enum PrivacyContext {\n-    PublicContext,\n-    PrivateContext,\n-}\n-\n // Information needed while computing reachability.\n struct ReachableContext {\n     // The type context.\n@@ -92,108 +85,8 @@ struct ReachableContext {\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n     worklist: @mut ~[NodeId],\n-}\n-\n-struct ReachableVisitor {\n-    reachable_symbols: @mut HashSet<NodeId>,\n-    worklist: @mut ~[NodeId],\n-}\n-\n-impl Visitor<PrivacyContext> for ReachableVisitor {\n-\n-    fn visit_item(&mut self, item:@item, privacy_context:PrivacyContext) {\n-\n-                match item.node {\n-                    item_fn(*) => {\n-                        if privacy_context == PublicContext {\n-                            self.reachable_symbols.insert(item.id);\n-                        }\n-                        if item_might_be_inlined(item) {\n-                            self.worklist.push(item.id)\n-                        }\n-                    }\n-                    item_struct(ref struct_def, _) => {\n-                        match struct_def.ctor_id {\n-                            Some(ctor_id) if\n-                                    privacy_context == PublicContext => {\n-                                self.reachable_symbols.insert(ctor_id);\n-                            }\n-                            Some(_) | None => {}\n-                        }\n-                    }\n-                    item_enum(ref enum_def, _) => {\n-                        if privacy_context == PublicContext {\n-                            for variant in enum_def.variants.iter() {\n-                                self.reachable_symbols.insert(variant.node.id);\n-                            }\n-                        }\n-                    }\n-                    item_impl(ref generics, ref trait_ref, _, ref methods) => {\n-                        // XXX(pcwalton): We conservatively assume any methods\n-                        // on a trait implementation are reachable, when this\n-                        // is not the case. We could be more precise by only\n-                        // treating implementations of reachable or cross-\n-                        // crate traits as reachable.\n-\n-                        let should_be_considered_public = |method: @method| {\n-                            (method.vis == public &&\n-                                    privacy_context == PublicContext) ||\n-                                    trait_ref.is_some()\n-                        };\n-\n-                        // Mark all public methods as reachable.\n-                        for &method in methods.iter() {\n-                            if should_be_considered_public(method) {\n-                                self.reachable_symbols.insert(method.id);\n-                            }\n-                        }\n-\n-                        if generics_require_inlining(generics) {\n-                            // If the impl itself has generics, add all public\n-                            // symbols to the worklist.\n-                            for &method in methods.iter() {\n-                                if should_be_considered_public(method) {\n-                                    self.worklist.push(method.id)\n-                                }\n-                            }\n-                        } else {\n-                            // Otherwise, add only public methods that have\n-                            // generics to the worklist.\n-                            for method in methods.iter() {\n-                                let generics = &method.generics;\n-                                let attrs = &method.attrs;\n-                                if generics_require_inlining(generics) ||\n-                                        attributes_specify_inlining(*attrs) ||\n-                                        should_be_considered_public(*method) {\n-                                    self.worklist.push(method.id)\n-                                }\n-                            }\n-                        }\n-                    }\n-                    item_trait(_, _, ref trait_methods) => {\n-                        // Mark all provided methods as reachable.\n-                        if privacy_context == PublicContext {\n-                            for trait_method in trait_methods.iter() {\n-                                match *trait_method {\n-                                    provided(method) => {\n-                                        self.reachable_symbols.insert(method.id);\n-                                        self.worklist.push(method.id)\n-                                    }\n-                                    required(_) => {}\n-                                }\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-\n-                if item.vis == public && privacy_context == PublicContext {\n-                    visit::walk_item(self, item, PublicContext)\n-                } else {\n-                    visit::walk_item(self, item, PrivateContext)\n-                }\n-    }\n-\n+    // Known reexports of modules\n+    exp_map2: resolve::ExportMap2,\n }\n \n struct MarkSymbolVisitor {\n@@ -256,31 +149,17 @@ impl Visitor<()> for MarkSymbolVisitor {\n \n impl ReachableContext {\n     // Creates a new reachability computation context.\n-    fn new(tcx: ty::ctxt, method_map: typeck::method_map)\n-           -> ReachableContext {\n+    fn new(tcx: ty::ctxt, method_map: typeck::method_map,\n+           exp_map2: resolve::ExportMap2) -> ReachableContext {\n         ReachableContext {\n             tcx: tcx,\n             method_map: method_map,\n             reachable_symbols: @mut HashSet::new(),\n             worklist: @mut ~[],\n+            exp_map2: exp_map2,\n         }\n     }\n \n-    // Step 1: Mark all public symbols, and add all public symbols that might\n-    // be inlined to a worklist.\n-    fn mark_public_symbols(&self, crate: &Crate) {\n-        let reachable_symbols = self.reachable_symbols;\n-        let worklist = self.worklist;\n-\n-        let mut visitor = ReachableVisitor {\n-            reachable_symbols: reachable_symbols,\n-            worklist: worklist,\n-        };\n-\n-\n-        visit::walk_crate(&mut visitor, crate, PublicContext);\n-    }\n-\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(tcx: ty::ctxt, def_id: DefId)\n@@ -352,6 +231,19 @@ impl ReachableContext {\n         }\n     }\n \n+    fn propagate_mod(&self, id: NodeId) {\n+        match self.exp_map2.find(&id) {\n+            Some(l) => {\n+                for reexport in l.iter() {\n+                    if reexport.reexport && is_local(reexport.def_id) {\n+                        self.worklist.push(reexport.def_id.node);\n+                    }\n+                }\n+            }\n+            None => {}\n+        }\n+    }\n+\n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     fn propagate(&self) {\n         let mut visitor = self.init_visitor();\n@@ -373,6 +265,18 @@ impl ReachableContext {\n                         item_fn(_, _, _, _, ref search_block) => {\n                             visit::walk_block(&mut visitor, search_block, ())\n                         }\n+                        // Our recursion into modules involves looking up their\n+                        // public reexports and the destinations of those\n+                        // exports. Privacy will put them in the worklist, but\n+                        // we won't find them in the ast_map, so this is where\n+                        // we deal with publicly re-exported items instead.\n+                        item_mod(*) => { self.propagate_mod(item.id); }\n+                        // These are normal, nothing reachable about these\n+                        // inherently and their children are already in the\n+                        // worklist\n+                        item_struct(*) | item_impl(*) | item_static(*) |\n+                        item_enum(*) | item_ty(*) | item_trait(*) |\n+                        item_foreign_mod(*) => {}\n                         _ => {\n                             self.tcx.sess.span_bug(item.span,\n                                                    \"found non-function item \\\n@@ -382,10 +286,8 @@ impl ReachableContext {\n                 }\n                 Some(&ast_map::node_trait_method(trait_method, _, _)) => {\n                     match *trait_method {\n-                        required(ref ty_method) => {\n-                            self.tcx.sess.span_bug(ty_method.span,\n-                                                   \"found required method in \\\n-                                                    worklist?!\")\n+                        required(*) => {\n+                            // Keep going, nothing to get exported\n                         }\n                         provided(ref method) => {\n                             visit::walk_block(&mut visitor, &method.body, ())\n@@ -395,6 +297,10 @@ impl ReachableContext {\n                 Some(&ast_map::node_method(ref method, _, _)) => {\n                     visit::walk_block(&mut visitor, &method.body, ())\n                 }\n+                // Nothing to recurse on for these\n+                Some(&ast_map::node_foreign_item(*)) |\n+                Some(&ast_map::node_variant(*)) |\n+                Some(&ast_map::node_struct_ctor(*)) => {}\n                 Some(_) => {\n                     let ident_interner = token::get_ident_interner();\n                     let desc = ast_map::node_id_to_str(self.tcx.items,\n@@ -404,6 +310,9 @@ impl ReachableContext {\n                                                worklist: {}\",\n                                                desc))\n                 }\n+                None if search_item == CRATE_NODE_ID => {\n+                    self.propagate_mod(search_item);\n+                }\n                 None => {\n                     self.tcx.sess.bug(format!(\"found unmapped ID in worklist: \\\n                                                {}\",\n@@ -429,7 +338,8 @@ impl ReachableContext {\n \n pub fn find_reachable(tcx: ty::ctxt,\n                       method_map: typeck::method_map,\n-                      crate: &Crate)\n+                      exp_map2: resolve::ExportMap2,\n+                      exported_items: &privacy::ExportedItems)\n                       -> @mut HashSet<NodeId> {\n     // XXX(pcwalton): We only need to mark symbols that are exported. But this\n     // is more complicated than just looking at whether the symbol is `pub`,\n@@ -442,11 +352,13 @@ pub fn find_reachable(tcx: ty::ctxt,\n     // is to have the name resolution pass mark all targets of a `pub use` as\n     // \"must be reachable\".\n \n-    let reachable_context = ReachableContext::new(tcx, method_map);\n+    let reachable_context = ReachableContext::new(tcx, method_map, exp_map2);\n \n-    // Step 1: Mark all public symbols, and add all public symbols that might\n-    // be inlined to a worklist.\n-    reachable_context.mark_public_symbols(crate);\n+    // Step 1: Seed the worklist with all nodes which were found to be public as\n+    //         a result of the privacy pass\n+    for &id in exported_items.iter() {\n+        reachable_context.worklist.push(id);\n+    }\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     reachable_context.propagate();"}, {"sha": "d0085afb3a7a24c69e6d9d2a05869c54e2b04911", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -2535,7 +2535,6 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             let (v, inlineable) = consts::const_expr(ccx, expr);\n                             ccx.const_values.insert(id, v);\n                             let mut inlineable = inlineable;\n-                            exprt = true;\n \n                             unsafe {\n                                 let llty = llvm::LLVMTypeOf(v);"}, {"sha": "9d5464e652651194c9c72d2a23af9dbafee9ca8c", "filename": "src/test/auxiliary/reexport-should-still-link.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fauxiliary%2Freexport-should-still-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fauxiliary%2Freexport-should-still-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Freexport-should-still-link.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use foo::bar;\n+\n+mod foo {\n+    pub fn bar() {}\n+}"}, {"sha": "b2cbd8821e4655c54e570893c76f8a4c439daf28", "filename": "src/test/codegen/iterate-over-array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fiterate-over-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fiterate-over-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fiterate-over-array.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #[no_mangle]\n-fn test(x: &[int]) -> int {\n+pub fn test(x: &[int]) -> int {\n     let mut y = 0;\n     let mut i = 0;\n     while (i < x.len()) {"}, {"sha": "b95d6b03288ea96ce476cafe7f6d1b27b270940a", "filename": "src/test/codegen/scalar-function-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fscalar-function-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fscalar-function-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fscalar-function-call.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -13,6 +13,6 @@ fn foo(x: int) -> int {\n }\n \n #[no_mangle]\n-fn test() {\n+pub fn test() {\n     let _x = foo(10);\n }"}, {"sha": "948809a63267905bea5057dfdbc61a216d7f6560", "filename": "src/test/codegen/single-return-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fsingle-return-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fsingle-return-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsingle-return-value.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n #[no_mangle]\n-fn test() -> int {\n+pub fn test() -> int {\n     5\n }"}, {"sha": "d75bc5209fd25a3896339f0cc49f40daf7fe05d5", "filename": "src/test/codegen/small-dense-int-switch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fsmall-dense-int-switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fsmall-dense-int-switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsmall-dense-int-switch.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #[no_mangle]\n-fn test(x: int, y: int) -> int {\n+pub fn test(x: int, y: int) -> int {\n     match x {\n         1 => y,\n         2 => y*2,"}, {"sha": "188ee246bf32c15bc362ff34f8dee03efa6e9691", "filename": "src/test/codegen/stack-alloc-string-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fstack-alloc-string-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fstack-alloc-string-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstack-alloc-string-slice.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n #[no_mangle]\n-fn test() {\n+pub fn test() {\n     let _x = \"hello\";\n }"}, {"sha": "efac93692f679a59b7d4b6ae650ec0244c01971c", "filename": "src/test/codegen/static-method-call-multi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fstatic-method-call-multi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fstatic-method-call-multi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstatic-method-call-multi.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -19,10 +19,10 @@ impl Struct {\n }\n \n #[no_mangle]\n-fn test(a: &Struct,\n-        b: &Struct,\n-        c: &Struct,\n-        d: &Struct,\n-        e: &Struct) -> int {\n+pub fn test(a: &Struct,\n+            b: &Struct,\n+            c: &Struct,\n+            d: &Struct,\n+            e: &Struct) -> int {\n     a.method(b.method(c.method(d.method(e.method(1)))))\n }"}, {"sha": "79fb9d8aa29338ab969cc1f08646ee1cec784079", "filename": "src/test/codegen/static-method-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fstatic-method-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fstatic-method-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstatic-method-call.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -19,6 +19,6 @@ impl Struct {\n }\n \n #[no_mangle]\n-fn test(s: &Struct) -> int {\n+pub fn test(s: &Struct) -> int {\n     s.method()\n }"}, {"sha": "20bda755f37284b4ce4036ecbc9666ccad0fcbb9", "filename": "src/test/codegen/virtual-method-call-struct-return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fvirtual-method-call-struct-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fvirtual-method-call-struct-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvirtual-method-call-struct-return.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -18,6 +18,6 @@ trait Trait {\n }\n \n #[no_mangle]\n-fn test(t: &Trait) -> int {\n+pub fn test(t: &Trait) -> int {\n     t.method().a\n }"}, {"sha": "513a299cc63b6d1bfe7bc1b988441dd8351562a8", "filename": "src/test/codegen/virtual-method-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fvirtual-method-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Fcodegen%2Fvirtual-method-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvirtual-method-call.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -13,6 +13,6 @@ trait Trait {\n }\n \n #[no_mangle]\n-fn test(t: &Trait) -> int {\n+pub fn test(t: &Trait) -> int {\n     t.method()\n }"}, {"sha": "ed5c3941c36574e987474ecaf8fba467e7fa2b0e", "filename": "src/test/run-pass/reexport-should-still-link.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Frun-pass%2Freexport-should-still-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f/src%2Ftest%2Frun-pass%2Freexport-should-still-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freexport-should-still-link.rs?ref=8015f9c27ec342dbf0b28c9c0c4769d8b3bcfc9f", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:reexport-should-still-link.rs\n+// xfail-fast windows doesn't like extern mod\n+\n+extern mod foo(name = \"reexport-should-still-link\");\n+\n+fn main() {\n+    foo::bar();\n+}"}]}