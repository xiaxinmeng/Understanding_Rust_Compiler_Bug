{"sha": "941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MWVjNmU0ZjVjZmM1NDA3OGY1ZmU2NTcwMmVjNDZiNmM1OWI4ZDI=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-19T16:48:29Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-28T19:24:36Z"}, "message": "Beautify more docs", "tree": {"sha": "106094d9ae531c1166ab55aa80701e5a6f2c88db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/106094d9ae531c1166ab55aa80701e5a6f2c88db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "html_url": "https://github.com/rust-lang/rust/commit/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfb1bc3723f42e98d08e24001696abc5a17bc8a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfb1bc3723f42e98d08e24001696abc5a17bc8a6", "html_url": "https://github.com/rust-lang/rust/commit/cfb1bc3723f42e98d08e24001696abc5a17bc8a6"}], "stats": {"total": 90, "additions": 44, "deletions": 46}, "files": [{"sha": "15fbabf9f0b396ee7fc6b291eb3fcf60deaab860", "filename": "src/bit_mask.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "patch": "@@ -13,14 +13,14 @@ use utils::span_lint;\n /// The formula for detecting if an expression of the type  `_ <bit_op> m <cmp_op> c` (where `<bit_op>`\n /// is one of {`&`, `|`} and `<cmp_op>` is one of {`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following table:\n ///\n-/// |Comparison  |Bit-Op|Example     |is always|Formula               |\n-/// |------------|------|------------|---------|----------------------|\n-/// |`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n-/// |`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n-/// |`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n-/// |`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n-/// |`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n-/// |`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n+/// |Comparison  |Bit Op |Example     |is always|Formula               |\n+/// |------------|-------|------------|---------|----------------------|\n+/// |`==` or `!=`|  `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n+/// |`<`  or `>=`|  `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n+/// |`>`  or `<=`|  `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n+/// |`==` or `!=`|  `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n+/// |`<`  or `>=`|  `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n+/// |`<=` or `>` |  `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n ///\n /// **Why is this bad?** If the bits that the comparison cares about are always set to zero or one by the bit mask, the comparison is constant `true` or `false` (depending on mask, compared value, and operators).\n ///\n@@ -38,7 +38,7 @@ declare_lint! {\n \n /// **What it does:** This lint checks for bit masks in comparisons which can be removed without changing the outcome. The basic structure can be seen in the following table:\n ///\n-/// |Comparison|Bit-Op   |Example    |equals |\n+/// |Comparison| Bit Op  |Example    |equals |\n /// |----------|---------|-----------|-------|\n /// |`>` / `<=`|`|` / `^`|`x | 2 > 3`|`x > 3`|\n /// |`<` / `>=`|`|` / `^`|`x ^ 1 < 4`|`x < 4`|\n@@ -61,21 +61,21 @@ declare_lint! {\n /// is one of {`&`, '|'} and `<cmp_op>` is one of {`!=`, `>=`, `>` ,\n /// `!=`, `>=`, `>`}) can be determined from the following table:\n ///\n-/// |Comparison  |Bit-Op|Example     |is always|Formula               |\n-/// |------------|------|------------|---------|----------------------|\n-/// |`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n-/// |`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n-/// |`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n-/// |`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n-/// |`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n-/// |`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n+/// |Comparison  |Bit Op |Example     |is always|Formula               |\n+/// |------------|-------|------------|---------|----------------------|\n+/// |`==` or `!=`|  `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n+/// |`<`  or `>=`|  `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n+/// |`>`  or `<=`|  `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n+/// |`==` or `!=`|  `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n+/// |`<`  or `>=`|  `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n+/// |`<=` or `>` |  `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n ///\n /// This lint is **deny** by default\n ///\n /// There is also a lint that warns on ineffective masks that is *warn*\n /// by default.\n ///\n-/// |Comparison|Bit-Op   |Example    |equals |Formula|\n+/// |Comparison| Bit Op  |Example    |equals |Formula|\n /// |`>` / `<=`|`|` / `^`|`x | 2 > 3`|`x > 3`|`\u00b9 && m <= c`|\n /// |`<` / `>=`|`|` / `^`|`x ^ 1 < 4`|`x < 4`|`\u00b9 && m < c` |\n ///"}, {"sha": "97a99dda4b5b40ff372f244bd125b90ffd25ed51", "filename": "src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "patch": "@@ -30,7 +30,7 @@ impl From<FloatTy> for FloatWidth {\n     }\n }\n \n-/// a Lit_-like enum to fold constant `Expr`s into\n+/// A `LitKind`-like enum to fold constant `Expr`s into.\n #[derive(Debug, Clone)]\n pub enum Constant {\n     /// a String \"abc\""}, {"sha": "aa6dd46cf0b979299c143fbd88752381fd951f1b", "filename": "src/formatting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "patch": "@@ -82,7 +82,7 @@ impl EarlyLintPass for Formatting {\n     }\n }\n \n-/// Implementation of the SUSPICIOUS_ASSIGNMENT_FORMATTING lint.\n+/// Implementation of the `SUSPICIOUS_ASSIGNMENT_FORMATTING` lint.\n fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n     if let ast::ExprKind::Assign(ref lhs, ref rhs) = expr.node {\n         if !differing_macro_contexts(lhs.span, rhs.span) && !in_macro(cx, lhs.span) {\n@@ -108,7 +108,7 @@ fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n     }\n }\n \n-/// Implementation of the SUSPICIOUS_ELSE_FORMATTING lint for weird `else if`.\n+/// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for weird `else if`.\n fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n     if let Some((then, &Some(ref else_))) = unsugar_if(expr) {\n         if unsugar_if(else_).is_some() && !differing_macro_contexts(then.span, else_.span) && !in_macro(cx, then.span) {"}, {"sha": "1a097820e1e3b3880bfdef2a11478967f4c6c0e0", "filename": "src/len_zero.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "patch": "@@ -164,9 +164,9 @@ fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[P<Expr>], l\n     }\n }\n \n-/// check if this type has an is_empty method\n+/// Check if this type has an `is_empty` method.\n fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n-    /// get a ImplOrTraitItem and return true if it matches is_empty(self)\n+    /// Get an `ImplOrTraitItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext, id: &ImplOrTraitItemId) -> bool {\n         if let MethodTraitItemId(def_id) = *id {\n             if let ty::MethodTraitItem(ref method) = cx.tcx.impl_or_trait_item(def_id) {\n@@ -179,7 +179,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n         }\n     }\n \n-    /// check the inherent impl's items for an is_empty(self) method\n+    /// Check the inherent impl's items for an `is_empty(self)` method.\n     fn has_is_empty_impl(cx: &LateContext, id: &DefId) -> bool {\n         let impl_items = cx.tcx.impl_items.borrow();\n         cx.tcx.inherent_impls.borrow().get(id).map_or(false, |ids| {"}, {"sha": "546f07a650751edc7face6e8288ae5579e127c45", "filename": "src/loops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "patch": "@@ -571,7 +571,7 @@ fn check_for_loop_explicit_counter(cx: &LateContext, arg: &Expr, body: &Expr, ex\n     }\n }\n \n-/// Check for the FOR_KV_MAP lint.\n+/// Check for the `FOR_KV_MAP` lint.\n fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n     if let PatKind::Tup(ref pat) = pat.node {\n         if pat.len() == 2 {\n@@ -607,7 +607,7 @@ fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Ex\n \n }\n \n-/// Return true if the pattern is a `PatWild` or an ident prefixed with '_'.\n+/// Return true if the pattern is a `PatWild` or an ident prefixed with `'_'`.\n fn pat_is_wild(pat: &PatKind, body: &Expr) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n@@ -750,8 +750,8 @@ impl<'v, 't> Visitor<'v> for VarUsedAfterLoopVisitor<'v, 't> {\n }\n \n \n-/// Return true if the type of expr is one that provides IntoIterator impls\n-/// for &T and &mut T, such as Vec.\n+/// Return true if the type of expr is one that provides `IntoIterator` impls\n+/// for `&T` and `&mut T`, such as `Vec`.\n #[cfg_attr(rustfmt, rustfmt_skip)]\n fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     // no walk_ptrs_ty: calling iter() on a reference can make sense because it"}, {"sha": "7bffd445f6b92210f8d4e1d16a5b1ab19e18bd80", "filename": "src/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "patch": "@@ -330,7 +330,7 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n     }\n }\n \n-/// Get all arms that are unbounded PatRange-s.\n+/// Get all arms that are unbounded `PatRange`s.\n fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n     arms.iter()\n         .filter_map(|arm| {"}, {"sha": "d7cb6fc5d281ebe5f525a8219c59917d4b9dc6dc", "filename": "src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnon_expressive_names.rs?ref=941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "patch": "@@ -251,7 +251,7 @@ impl EarlyLintPass for NonExpressiveNames {\n     }\n }\n \n-/// precondition: a_name.chars().count() < b_name.chars().count()\n+/// Precondition: `a_name.chars().count() < b_name.chars().count()`.\n fn levenstein_not_1(a_name: &str, b_name: &str) -> bool {\n     debug_assert!(a_name.chars().count() < b_name.chars().count());\n     let mut a_chars = a_name.chars();"}, {"sha": "6498db66e139cf141bfeb7bb249f7dd511594508", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "patch": "@@ -1,6 +1,4 @@\n-//! Checks for usage of &Vec[_] and &String\n-//!\n-//! This lint is **warn** by default\n+//! Checks for usage of  `&Vec[_]` and `&String`.\n \n use rustc::front::map::NodeItem;\n use rustc::lint::*;"}, {"sha": "9f68175b2024cedd31243768e93dbb3f600e89b1", "filename": "src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "patch": "@@ -1,4 +1,4 @@\n-//! This LintPass catches both string addition and string addition + assignment\n+//! This lint catches both string addition and string addition + assignment\n //!\n //! Note that since we have two lints where one subsumes the other, we try to\n //! disable the subsumed lint unless it has a higher level"}, {"sha": "34404f4c2e9890e21413a2b0dc46a9bc88dcdfa0", "filename": "src/utils/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "patch": "@@ -129,8 +129,8 @@ pub fn in_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n /// Returns true if the macro that expanded the crate was outside of the current crate or was a\n /// compiler plugin.\n pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n-    /// Invokes in_macro with the expansion info of the given span slightly heavy, try to use this\n-    /// after other checks have already happened.\n+    /// Invokes `in_macro` with the expansion info of the given span slightly heavy, try to use\n+    /// this after other checks have already happened.\n     fn in_macro_ext<T: LintContext>(cx: &T, opt_info: Option<&ExpnInfo>) -> bool {\n         // no ExpnInfo = no macro\n         opt_info.map_or(false, |info| {\n@@ -657,7 +657,7 @@ pub fn is_direct_expn_of(cx: &LateContext, span: Span, name: &str) -> Option<Spa\n     }\n }\n \n-/// Returns index of character after first CamelCase component of `s`\n+/// Return the index of the character after the first camel-case component of `s`.\n pub fn camel_case_until(s: &str) -> usize {\n     let mut iter = s.char_indices();\n     if let Some((_, first)) = iter.next() {\n@@ -690,7 +690,7 @@ pub fn camel_case_until(s: &str) -> usize {\n     }\n }\n \n-/// Returns index of last CamelCase component of `s`.\n+/// Return index of the last camel-case component of `s`.\n pub fn camel_case_from(s: &str) -> usize {\n     let mut iter = s.char_indices().rev();\n     if let Some((_, first)) = iter.next() {\n@@ -719,7 +719,7 @@ pub fn camel_case_from(s: &str) -> usize {\n     last_i\n }\n \n-/// Represents a range akin to `ast::ExprKind::Range`.\n+/// Represent a range akin to `ast::ExprKind::Range`.\n #[derive(Debug, Copy, Clone)]\n pub struct UnsugaredRange<'a> {\n     pub start: Option<&'a Expr>,"}, {"sha": "f58b0e695a91f0be65946aaf749182505d716847", "filename": "src/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/src%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fzero_div_zero.rs?ref=941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "patch": "@@ -4,7 +4,7 @@ use rustc_front::hir::*;\n use utils::span_help_and_lint;\n \n /// `ZeroDivZeroPass` is a pass that checks for a binary expression that consists\n-/// `of 0.0/0.0`, which is always NaN. It is more clear to replace instances of\n+/// `of 0.0/0.0`, which is always `NaN`. It is more clear to replace instances of\n /// `0.0/0.0` with `std::f32::NaN` or `std::f64::NaN`, depending on the precision.\n pub struct ZeroDivZeroPass;\n "}, {"sha": "9d938ebb19e6f53ae7226b28004e2cf3d60ff9b4", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "patch": "@@ -85,8 +85,8 @@ macro_rules! opt_map {\n }\n \n /// Checks implementation of the following lints:\n-/// OPTION_MAP_UNWRAP_OR\n-/// OPTION_MAP_UNWRAP_OR_ELSE\n+/// * `OPTION_MAP_UNWRAP_OR`\n+/// * `OPTION_MAP_UNWRAP_OR_ELSE`\n fn option_methods() {\n     let opt = Some(1);\n \n@@ -154,7 +154,7 @@ impl IteratorFalsePositives {\n     }\n }\n \n-/// Checks implementation of FILTER_NEXT lint\n+/// Checks implementation of `FILTER_NEXT` lint\n fn filter_next() {\n     let v = vec![3, 2, 1, 0, -1, -2, -3];\n \n@@ -174,7 +174,7 @@ fn filter_next() {\n     let _ = foo.filter().next();\n }\n \n-/// Checks implementation of SEARCH_IS_SOME lint\n+/// Checks implementation of `SEARCH_IS_SOME` lint\n fn search_is_some() {\n     let v = vec![3, 2, 1, 0, -1, -2, -3];\n \n@@ -218,7 +218,7 @@ fn search_is_some() {\n     let _ = foo.rposition().is_some();\n }\n \n-/// Checks implementation of the OR_FUN_CALL lint\n+/// Checks implementation of the `OR_FUN_CALL` lint\n fn or_fun_call() {\n     struct Foo;\n "}, {"sha": "7a8faa62742ab515944380dc2c5416d4493ebcfc", "filename": "tests/used_underscore_binding_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/tests%2Fused_underscore_binding_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2/tests%2Fused_underscore_binding_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fused_underscore_binding_macro.rs?ref=941ec6e4f5cfc54078f5fe65702ec46b6c59b8d2", "patch": "@@ -3,7 +3,7 @@\n \n extern crate rustc_serialize;\n \n-/// Test that we do not lint for unused underscores in a MacroAttribute expansion\n+/// Test that we do not lint for unused underscores in a `MacroAttribute` expansion\n #[deny(used_underscore_binding)]\n #[derive(RustcEncodable)]\n struct MacroAttributesTest {"}]}