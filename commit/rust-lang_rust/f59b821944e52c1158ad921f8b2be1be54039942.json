{"sha": "f59b821944e52c1158ad921f8b2be1be54039942", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1OWI4MjE5NDRlNTJjMTE1OGFkOTIxZjhiMmJlMWJlNTQwMzk5NDI=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-01-25T18:45:27Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-01-30T18:41:04Z"}, "message": "Attempted fix for `?` kleene op", "tree": {"sha": "b834184924061cddb22fd76cf21c65ee9226472b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b834184924061cddb22fd76cf21c65ee9226472b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f59b821944e52c1158ad921f8b2be1be54039942", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f59b821944e52c1158ad921f8b2be1be54039942", "html_url": "https://github.com/rust-lang/rust/commit/f59b821944e52c1158ad921f8b2be1be54039942", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f59b821944e52c1158ad921f8b2be1be54039942/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ac48ec82623433bc6dbf62ce8c101eeec12648d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ac48ec82623433bc6dbf62ce8c101eeec12648d", "html_url": "https://github.com/rust-lang/rust/commit/5ac48ec82623433bc6dbf62ce8c101eeec12648d"}], "stats": {"total": 44, "additions": 21, "deletions": 23}, "files": [{"sha": "b35beedfff7d47823ace8fe5666aff40cffb4f91", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f59b821944e52c1158ad921f8b2be1be54039942/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f59b821944e52c1158ad921f8b2be1be54039942/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=f59b821944e52c1158ad921f8b2be1be54039942", "patch": "@@ -181,6 +181,8 @@ struct MatcherPos {\n     match_hi: usize,\n \n     // Specifically used if we are matching a repetition. If we aren't both should be `None`.\n+    /// The KleeneOp of this sequence if we are in a repetition.\n+    seq_op: Option<quoted::KleeneOp>,\n     /// The separator if we are in a repetition\n     sep: Option<Token>,\n     /// The \"parent\" matcher position if we are in a repetition. That is, the matcher position just\n@@ -263,6 +265,7 @@ fn initial_matcher_pos(ms: Vec<TokenTree>, lo: BytePos) -> Box<MatcherPos> {\n         stack: vec![],\n \n         // Haven't descended into any sequences, so both of these are `None`.\n+        seq_op: None,\n         sep: None,\n         up: None,\n     })\n@@ -464,10 +467,11 @@ fn inner_parse_loop(\n                         item.idx += 1;\n                         next_items.push(item);\n                     }\n-                }\n+                } \n                 // We don't need a separator. Move the \"dot\" back to the beginning of the matcher\n-                // and try to match again.\n-                else {\n+                // and try to match again UNLESS we are only allowed to have _one_ repetition.\n+                else if item.seq_op != Some(quoted::KleeneOp::ZeroOrOne) {\n+                    // we don't need a separator\n                     item.match_cur = item.match_lo;\n                     item.idx = 0;\n                     cur_items.push(item);\n@@ -499,26 +503,20 @@ fn inner_parse_loop(\n                         cur_items.push(new_item);\n                     }\n \n-                    // For ZeroOrMore and OneOrMore, we want to examine the case were there is at\n-                    // least one match. For ZeroOrOne, we only want the case where there is exactly\n-                    // one match.\n-                    if (seq.op == quoted::KleeneOp::ZeroOrOne && seq.num_captures == 1)\n-                        || seq.op != quoted::KleeneOp::ZeroOrOne\n-                    {\n-                        let matches = create_matches(item.matches.len());\n-                        cur_items.push(Box::new(MatcherPos {\n-                            stack: vec![],\n-                            sep: seq.separator.clone(),\n-                            idx: 0,\n-                            matches,\n-                            match_lo: item.match_cur,\n-                            match_cur: item.match_cur,\n-                            match_hi: item.match_cur + seq.num_captures,\n-                            up: Some(item),\n-                            sp_lo: sp.lo(),\n-                            top_elts: Tt(TokenTree::Sequence(sp, seq)),\n-                        }));\n-                    }\n+                    let matches = create_matches(item.matches.len());\n+                    cur_items.push(Box::new(MatcherPos {\n+                        stack: vec![],\n+                        sep: seq.separator.clone(),\n+                        seq_op: Some(seq.op),\n+                        idx: 0,\n+                        matches,\n+                        match_lo: item.match_cur,\n+                        match_cur: item.match_cur,\n+                        match_hi: item.match_cur + seq.num_captures,\n+                        up: Some(item),\n+                        sp_lo: sp.lo(),\n+                        top_elts: Tt(TokenTree::Sequence(sp, seq)),\n+                    }));\n                 }\n \n                 // We need to match a metavar (but the identifier is invalid)... this is an error"}]}