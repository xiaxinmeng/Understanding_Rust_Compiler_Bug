{"sha": "ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiOGE2N2MxMmFkYzZiYTg0YjYxNDNhNTM5NjQwZDU5NjJlZjZjYmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-29T12:40:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-29T12:40:12Z"}, "message": "Auto merge of #51729 - matthewjasper:move-errors, r=nikomatsakis\n\n[NLL] Better move errors\n\nMake a number of changes to improve the quality of NLL cannot move errors.\n\n* Group errors that occur in the same `match` with the same cause.\n* Suggest `ref`, `&` or removing `*` to avoid the move.\n* Show the place being matched on.\n\nDifferences from AST borrowck:\n\n* `&` is suggested over `ref` when matching on a place that can't be moved from.\n* Removing `*` is suggested instead of adding `&` when applicable.\n* Sub-pattern spans aren't used, this would probably need Spans on Places.\n\nCloses #45699\nCloses #46627\nCloses #51187\nCloses #51189\n\nr? @pnkfelix", "tree": {"sha": "369362bb7a54b0f6e4794cedb6062f9e7a3f740f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/369362bb7a54b0f6e4794cedb6062f9e7a3f740f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "html_url": "https://github.com/rust-lang/rust/commit/ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e5e63a48c3be7de2faf914c2a9e194ff7cede9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e", "html_url": "https://github.com/rust-lang/rust/commit/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e"}, {"sha": "2cb0a0631a640318ae288ead20758db8508f6835", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cb0a0631a640318ae288ead20758db8508f6835", "html_url": "https://github.com/rust-lang/rust/commit/2cb0a0631a640318ae288ead20758db8508f6835"}], "stats": {"total": 1318, "additions": 997, "deletions": 321}, "files": [{"sha": "dec37bdf7195d6c911cfc53339017ac345353d98", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -497,8 +497,8 @@ pub enum LocalKind {\n     ReturnPointer,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct VarBindingForm {\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub struct VarBindingForm<'tcx> {\n     /// Is variable bound via `x`, `mut x`, `ref x`, or `ref mut x`?\n     pub binding_mode: ty::BindingMode,\n     /// If an explicit type was provided for this variable binding,\n@@ -508,21 +508,49 @@ pub struct VarBindingForm {\n     /// doing so breaks incremental compilation (as of this writing),\n     /// while a `Span` does not cause our tests to fail.\n     pub opt_ty_info: Option<Span>,\n+    /// Place of the RHS of the =, or the subject of the `match` where this\n+    /// variable is initialized. None in the case of `let PATTERN;`.\n+    /// Some((None, ..)) in the case of and `let [mut] x = ...` because\n+    /// (a) the right-hand side isn't evaluated as a place expression.\n+    /// (b) it gives a way to separate this case from the remaining cases\n+    ///     for diagnostics.\n+    pub opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub enum BindingForm {\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub enum BindingForm<'tcx> {\n     /// This is a binding for a non-`self` binding, or a `self` that has an explicit type.\n-    Var(VarBindingForm),\n+    Var(VarBindingForm<'tcx>),\n     /// Binding for a `self`/`&self`/`&mut self` binding where the type is implicit.\n     ImplicitSelf,\n }\n \n-CloneTypeFoldableAndLiftImpls! { BindingForm, }\n+CloneTypeFoldableAndLiftImpls! { BindingForm<'tcx>, }\n \n-impl_stable_hash_for!(struct self::VarBindingForm { binding_mode, opt_ty_info });\n+impl_stable_hash_for!(struct self::VarBindingForm<'tcx> {\n+    binding_mode,\n+    opt_ty_info,\n+    opt_match_place\n+});\n+\n+mod binding_form_impl {\n+    use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+    use ich::StableHashingContext;\n \n-impl_stable_hash_for!(enum self::BindingForm { Var(binding), ImplicitSelf, });\n+    impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for super::BindingForm<'tcx> {\n+        fn hash_stable<W: StableHasherResult>(&self,\n+                                            hcx: &mut StableHashingContext<'a>,\n+                                            hasher: &mut StableHasher<W>) {\n+            use super::BindingForm::*;\n+            ::std::mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+            match self {\n+                Var(binding) => binding.hash_stable(hcx, hasher),\n+                ImplicitSelf => (),\n+            }\n+        }\n+    }\n+}\n \n /// A MIR local.\n ///\n@@ -542,7 +570,7 @@ pub struct LocalDecl<'tcx> {\n     /// therefore it need not be visible across crates. pnkfelix\n     /// currently hypothesized we *need* to wrap this in a\n     /// `ClearCrossCrate` as long as it carries as `HirId`.\n-    pub is_user_variable: Option<ClearCrossCrate<BindingForm>>,\n+    pub is_user_variable: Option<ClearCrossCrate<BindingForm<'tcx>>>,\n \n     /// True if this is an internal local\n     ///\n@@ -670,6 +698,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n                 opt_ty_info: _,\n+                opt_match_place: _,\n             }))) => true,\n \n             // FIXME: might be able to thread the distinction between\n@@ -688,6 +717,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n                 opt_ty_info: _,\n+                opt_match_place: _,\n             }))) => true,\n \n             Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf)) => true,"}, {"sha": "ea303cd4e6c2f61f6f8fd7f434f3a10b0e51d4e3", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -35,7 +35,6 @@ use syntax_pos::Span;\n \n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n-use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n use dataflow::Borrows;\n use dataflow::DataflowResultsConsumer;\n use dataflow::FlowAtLocation;\n@@ -62,6 +61,7 @@ mod path_utils;\n crate mod place_ext;\n mod prefixes;\n mod used_muts;\n+mod move_errors;\n \n pub(crate) mod nll;\n \n@@ -147,40 +147,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let move_data: MoveData<'tcx> = match MoveData::gather_moves(mir, tcx) {\n         Ok(move_data) => move_data,\n         Err((move_data, move_errors)) => {\n-            for move_error in move_errors {\n-                let (span, kind): (Span, IllegalMoveOriginKind) = match move_error {\n-                    MoveError::UnionMove { .. } => {\n-                        unimplemented!(\"don't know how to report union move errors yet.\")\n-                    }\n-                    MoveError::IllegalMove {\n-                        cannot_move_out_of: o,\n-                    } => (o.span, o.kind),\n-                };\n-                let origin = Origin::Mir;\n-                let mut err = match kind {\n-                    IllegalMoveOriginKind::Static => {\n-                        tcx.cannot_move_out_of(span, \"static item\", origin)\n-                    }\n-                    IllegalMoveOriginKind::BorrowedContent { target_ty: ty } => {\n-                        // Inspect the type of the content behind the\n-                        // borrow to provide feedback about why this\n-                        // was a move rather than a copy.\n-                        match ty.sty {\n-                            ty::TyArray(..) | ty::TySlice(..) => {\n-                                tcx.cannot_move_out_of_interior_noncopy(span, ty, None, origin)\n-                            }\n-                            _ => tcx.cannot_move_out_of(span, \"borrowed content\", origin),\n-                        }\n-                    }\n-                    IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n-                        tcx.cannot_move_out_of_interior_of_drop(span, ty, origin)\n-                    }\n-                    IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } => {\n-                        tcx.cannot_move_out_of_interior_noncopy(span, ty, Some(is_index), origin)\n-                    }\n-                };\n-                err.emit();\n-            }\n+            move_errors::report_move_errors(&mir, tcx, move_errors, &move_data);\n             move_data\n         }\n     };"}, {"sha": "bc68708decbd54a25754c199d057b070d8f3a857", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -0,0 +1,388 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::mir::*;\n+use rustc::ty::{self, TyCtxt};\n+use rustc_errors::DiagnosticBuilder;\n+use syntax_pos::Span;\n+\n+use dataflow::move_paths::{IllegalMoveOrigin, IllegalMoveOriginKind, MoveData};\n+use dataflow::move_paths::{LookupResult, MoveError, MovePathIndex};\n+use util::borrowck_errors::{BorrowckErrors, Origin};\n+\n+pub(crate) fn report_move_errors<'gcx, 'tcx>(\n+    mir: &Mir<'tcx>,\n+    tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+    move_errors: Vec<MoveError<'tcx>>,\n+    move_data: &MoveData<'tcx>,\n+) {\n+    MoveErrorCtxt {\n+        mir,\n+        tcx,\n+        move_data,\n+    }.report_errors(move_errors);\n+}\n+\n+#[derive(Copy, Clone)]\n+struct MoveErrorCtxt<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    move_data: &'a MoveData<'tcx>,\n+}\n+\n+// Often when desugaring a pattern match we may have many individual moves in\n+// MIR that are all part of one operation from the user's point-of-view. For\n+// example:\n+//\n+// let (x, y) = foo()\n+//\n+// would move x from the 0 field of some temporary, and y from the 1 field. We\n+// group such errors together for cleaner error reporting.\n+//\n+// Errors are kept separate if they are from places with different parent move\n+// paths. For example, this generates two errors:\n+//\n+// let (&x, &y) = (&String::new(), &String::new());\n+#[derive(Debug)]\n+enum GroupedMoveError<'tcx> {\n+    // Match place can't be moved from\n+    // e.g. match x[0] { s => (), } where x: &[String]\n+    MovesFromMatchPlace {\n+        span: Span,\n+        move_from: Place<'tcx>,\n+        kind: IllegalMoveOriginKind<'tcx>,\n+        binds_to: Vec<Local>,\n+    },\n+    // Part of a pattern can't be moved from,\n+    // e.g. match &String::new() { &x => (), }\n+    MovesFromPattern {\n+        span: Span,\n+        move_from: MovePathIndex,\n+        kind: IllegalMoveOriginKind<'tcx>,\n+        binds_to: Vec<Local>,\n+    },\n+    // Everything that isn't from pattern matching.\n+    OtherIllegalMove {\n+        span: Span,\n+        kind: IllegalMoveOriginKind<'tcx>,\n+    },\n+}\n+\n+impl<'a, 'gcx, 'tcx> MoveErrorCtxt<'a, 'gcx, 'tcx> {\n+    fn report_errors(self, move_errors: Vec<MoveError<'tcx>>) {\n+        let grouped_errors = self.group_move_errors(move_errors);\n+        for error in grouped_errors {\n+            self.report(error);\n+        }\n+    }\n+\n+    fn group_move_errors(self, errors: Vec<MoveError<'tcx>>) -> Vec<GroupedMoveError<'tcx>> {\n+        let mut grouped_errors = Vec::new();\n+        for error in errors {\n+            self.append_to_grouped_errors(&mut grouped_errors, error);\n+        }\n+        grouped_errors\n+    }\n+\n+    fn append_to_grouped_errors(\n+        self,\n+        grouped_errors: &mut Vec<GroupedMoveError<'tcx>>,\n+        error: MoveError<'tcx>,\n+    ) {\n+        match error {\n+            MoveError::UnionMove { .. } => {\n+                unimplemented!(\"don't know how to report union move errors yet.\")\n+            }\n+            MoveError::IllegalMove {\n+                cannot_move_out_of: IllegalMoveOrigin { location, kind },\n+            } => {\n+                let stmt_source_info = self.mir.source_info(location);\n+                if let Some(StatementKind::Assign(\n+                    Place::Local(local),\n+                    Rvalue::Use(Operand::Move(move_from)),\n+                )) = self.mir.basic_blocks()[location.block]\n+                    .statements\n+                    .get(location.statement_index)\n+                    .map(|stmt| &stmt.kind)\n+                {\n+                    let local_decl = &self.mir.local_decls[*local];\n+                    if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                        opt_match_place: Some((ref opt_match_place, match_span)),\n+                        binding_mode: _,\n+                        opt_ty_info: _,\n+                    }))) = local_decl.is_user_variable\n+                    {\n+                        // opt_match_place is the\n+                        // match_span is the span of the expression being matched on\n+                        // match *x.y { ... }        match_place is Some(*x.y)\n+                        //       ^^^^                match_span is the span of *x.y\n+                        // opt_match_place is None for let [mut] x = ... statements,\n+                        // whether or not the right-hand side is a place expression\n+\n+                        // HACK use scopes to determine if this assignment is\n+                        // the initialization of a variable.\n+                        // FIXME(matthewjasper) This would probably be more\n+                        // reliable if it used the ever initialized dataflow\n+                        // but move errors are currently reported before the\n+                        // rest of borrowck has run.\n+                        if self\n+                            .mir\n+                            .is_sub_scope(local_decl.source_info.scope, stmt_source_info.scope)\n+                        {\n+                            self.append_binding_error(\n+                                grouped_errors,\n+                                kind,\n+                                move_from,\n+                                *local,\n+                                opt_match_place,\n+                                match_span,\n+                            );\n+                        }\n+                        return;\n+                    }\n+                }\n+                grouped_errors.push(GroupedMoveError::OtherIllegalMove {\n+                    span: stmt_source_info.span,\n+                    kind,\n+                });\n+            }\n+        }\n+    }\n+\n+    fn append_binding_error(\n+        self,\n+        grouped_errors: &mut Vec<GroupedMoveError<'tcx>>,\n+        kind: IllegalMoveOriginKind<'tcx>,\n+        move_from: &Place<'tcx>,\n+        bind_to: Local,\n+        match_place: &Option<Place<'tcx>>,\n+        match_span: Span,\n+    ) {\n+        debug!(\n+            \"append_to_grouped_errors(match_place={:?}, match_span={:?})\",\n+            match_place, match_span\n+        );\n+\n+        let from_simple_let = match_place.is_none();\n+        let match_place = match_place.as_ref().unwrap_or(move_from);\n+\n+        match self.move_data.rev_lookup.find(match_place) {\n+            // Error with the match place\n+            LookupResult::Parent(_) => {\n+                for ge in &mut *grouped_errors {\n+                    if let GroupedMoveError::MovesFromMatchPlace { span, binds_to, .. } = ge {\n+                        if match_span == *span {\n+                            debug!(\"appending local({:?}) to list\", bind_to);\n+                            if !binds_to.is_empty() {\n+                                binds_to.push(bind_to);\n+                            }\n+                            return;\n+                        }\n+                    }\n+                }\n+                debug!(\"found a new move error location\");\n+\n+                // Don't need to point to x in let x = ... .\n+                let binds_to = if from_simple_let {\n+                    vec![]\n+                } else {\n+                    vec![bind_to]\n+                };\n+                grouped_errors.push(GroupedMoveError::MovesFromMatchPlace {\n+                    span: match_span,\n+                    move_from: match_place.clone(),\n+                    kind,\n+                    binds_to,\n+                });\n+            }\n+            // Error with the pattern\n+            LookupResult::Exact(_) => {\n+                let mpi = match self.move_data.rev_lookup.find(move_from) {\n+                    LookupResult::Parent(Some(mpi)) => mpi,\n+                    // move_from should be a projection from match_place.\n+                    _ => unreachable!(\"Probably not unreachable...\"),\n+                };\n+                for ge in &mut *grouped_errors {\n+                    if let GroupedMoveError::MovesFromPattern {\n+                        span,\n+                        move_from: other_mpi,\n+                        binds_to,\n+                        ..\n+                    } = ge\n+                    {\n+                        if match_span == *span && mpi == *other_mpi {\n+                            debug!(\"appending local({:?}) to list\", bind_to);\n+                            binds_to.push(bind_to);\n+                            return;\n+                        }\n+                    }\n+                }\n+                debug!(\"found a new move error location\");\n+                grouped_errors.push(GroupedMoveError::MovesFromPattern {\n+                    span: match_span,\n+                    move_from: mpi,\n+                    kind,\n+                    binds_to: vec![bind_to],\n+                });\n+            }\n+        };\n+    }\n+\n+    fn report(self, error: GroupedMoveError<'tcx>) {\n+        let (mut err, err_span) = {\n+            let (span, kind): (Span, &IllegalMoveOriginKind) = match error {\n+                GroupedMoveError::MovesFromMatchPlace { span, ref kind, .. }\n+                | GroupedMoveError::MovesFromPattern { span, ref kind, .. }\n+                | GroupedMoveError::OtherIllegalMove { span, ref kind } => (span, kind),\n+            };\n+            let origin = Origin::Mir;\n+            (\n+                match kind {\n+                    IllegalMoveOriginKind::Static => {\n+                        self.tcx.cannot_move_out_of(span, \"static item\", origin)\n+                    }\n+                    IllegalMoveOriginKind::BorrowedContent { target_ty: ty } => {\n+                        // Inspect the type of the content behind the\n+                        // borrow to provide feedback about why this\n+                        // was a move rather than a copy.\n+                        match ty.sty {\n+                            ty::TyArray(..) | ty::TySlice(..) => self\n+                                .tcx\n+                                .cannot_move_out_of_interior_noncopy(span, ty, None, origin),\n+                            _ => self\n+                                .tcx\n+                                .cannot_move_out_of(span, \"borrowed content\", origin),\n+                        }\n+                    }\n+                    IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n+                        self.tcx\n+                            .cannot_move_out_of_interior_of_drop(span, ty, origin)\n+                    }\n+                    IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } => self\n+                        .tcx\n+                        .cannot_move_out_of_interior_noncopy(span, ty, Some(*is_index), origin),\n+                },\n+                span,\n+            )\n+        };\n+\n+        self.add_move_hints(error, &mut err, err_span);\n+        err.emit();\n+    }\n+\n+    fn add_move_hints(\n+        self,\n+        error: GroupedMoveError<'tcx>,\n+        err: &mut DiagnosticBuilder<'a>,\n+        span: Span,\n+    ) {\n+        match error {\n+            GroupedMoveError::MovesFromMatchPlace {\n+                mut binds_to,\n+                move_from,\n+                ..\n+            } => {\n+                // Ok to suggest a borrow, since the target can't be moved from\n+                // anyway.\n+                if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+                    match move_from {\n+                        Place::Projection(ref proj)\n+                            if self.suitable_to_remove_deref(proj, &snippet) =>\n+                        {\n+                            err.span_suggestion(\n+                                span,\n+                                \"consider removing this dereference operator\",\n+                                format!(\"{}\", &snippet[1..]),\n+                            );\n+                        }\n+                        _ => {\n+                            err.span_suggestion(\n+                                span,\n+                                \"consider using a reference instead\",\n+                                format!(\"&{}\", snippet),\n+                            );\n+                        }\n+                    }\n+\n+                    binds_to.sort();\n+                    binds_to.dedup();\n+                    for local in binds_to {\n+                        let bind_to = &self.mir.local_decls[local];\n+                        let binding_span = bind_to.source_info.span;\n+                        err.span_label(\n+                            binding_span,\n+                            format!(\n+                                \"move occurs because {} has type `{}`, \\\n+                                 which does not implement the `Copy` trait\",\n+                                bind_to.name.unwrap(),\n+                                bind_to.ty\n+                            ),\n+                        );\n+                    }\n+                }\n+            }\n+            GroupedMoveError::MovesFromPattern { mut binds_to, .. } => {\n+                // Suggest ref, since there might be a move in\n+                // another match arm\n+                binds_to.sort();\n+                binds_to.dedup();\n+                for local in binds_to {\n+                    let bind_to = &self.mir.local_decls[local];\n+                    let binding_span = bind_to.source_info.span;\n+\n+                    // Suggest ref mut when the user has already written mut.\n+                    let ref_kind = match bind_to.mutability {\n+                        Mutability::Not => \"ref\",\n+                        Mutability::Mut => \"ref mut\",\n+                    };\n+                    match bind_to.name {\n+                        Some(name) => {\n+                            err.span_suggestion(\n+                                binding_span,\n+                                \"to prevent move, use ref or ref mut\",\n+                                format!(\"{} {:?}\", ref_kind, name),\n+                            );\n+                        }\n+                        None => {\n+                            err.span_label(\n+                                span,\n+                                format!(\"Local {:?} is not suitable for ref\", bind_to),\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+            // Nothing to suggest.\n+            GroupedMoveError::OtherIllegalMove { .. } => (),\n+        }\n+    }\n+\n+    fn suitable_to_remove_deref(self, proj: &PlaceProjection<'tcx>, snippet: &str) -> bool {\n+        let is_shared_ref = |ty: ty::Ty| match ty.sty {\n+            ty::TypeVariants::TyRef(.., hir::Mutability::MutImmutable) => true,\n+            _ => false,\n+        };\n+\n+        proj.elem == ProjectionElem::Deref && snippet.starts_with('*') && match proj.base {\n+            Place::Local(local) => {\n+                let local_decl = &self.mir.local_decls[local];\n+                // If this is a temporary, then this could be from an\n+                // overloaded * operator.\n+                local_decl.is_user_variable.is_some() && is_shared_ref(local_decl.ty)\n+            }\n+            Place::Static(ref st) => is_shared_ref(st.ty),\n+            Place::Projection(ref proj) => match proj.elem {\n+                ProjectionElem::Field(_, ty) => is_shared_ref(ty),\n+                _ => false,\n+            },\n+        }\n+    }\n+}"}, {"sha": "bbbe757e96ec68fd49f9f27030f9e3ddae0ef867", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -115,11 +115,21 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // Declare the bindings, which may create a source scope.\n                     let remainder_span = remainder_scope.span(this.hir.tcx(),\n                                                               &this.hir.region_scope_tree);\n-                    let scope = this.declare_bindings(None, remainder_span, lint_level, &pattern,\n-                                                      ArmHasGuard(false));\n+\n+                    let scope;\n \n                     // Evaluate the initializer, if present.\n                     if let Some(init) = initializer {\n+                        let initializer_span = init.span();\n+\n+                        scope = this.declare_bindings(\n+                            None,\n+                            remainder_span,\n+                            lint_level,\n+                            &pattern,\n+                            ArmHasGuard(false),\n+                            Some((None, initializer_span)),\n+                        );\n                         unpack!(block = this.in_opt_scope(\n                             opt_destruction_scope.map(|de|(de, source_info)), block, |this| {\n                                 let scope = (init_scope, source_info);\n@@ -128,6 +138,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                 })\n                             }));\n                     } else {\n+                        scope = this.declare_bindings(None, remainder_span, lint_level, &pattern,\n+                                                        ArmHasGuard(false), None);\n+\n                         // FIXME(#47184): We currently only insert `UserAssertTy` statements for\n                         // patterns that are bindings, this is as we do not want to deconstruct\n                         // the type being assertion to match the pattern."}, {"sha": "d905b38331607da2cc4e6f923001e94c75592c11", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -11,7 +11,6 @@\n //! See docs in build/expr/mod.rs\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n-use build::expr::category::Category;\n use hair::*;\n use rustc::middle::region;\n use rustc::mir::*;\n@@ -57,23 +56,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             });\n         }\n \n-        // Careful here not to cause an infinite cycle. If we always\n-        // called `into`, then for places like `x.f`, it would\n-        // eventually fallback to us, and we'd loop. There's a reason\n-        // for this: `as_temp` is the point where we bridge the \"by\n-        // reference\" semantics of `as_place` with the \"by value\"\n-        // semantics of `into`, `as_operand`, `as_rvalue`, and (of\n-        // course) `as_temp`.\n-        match Category::of(&expr.kind).unwrap() {\n-            Category::Place => {\n-                let place = unpack!(block = this.as_place(block, expr));\n-                let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n-                this.cfg.push_assign(block, source_info, &Place::Local(temp), rvalue);\n-            }\n-            _ => {\n-                unpack!(block = this.into(&Place::Local(temp), block, expr));\n-            }\n-        }\n+        unpack!(block = this.into(&Place::Local(temp), block, expr));\n \n         // In constants, temp_lifetime is None. We should not need to drop\n         // anything because no values with a destructor can be created in"}, {"sha": "59a7f49af80746ff955b62d14e37b544384e37f8", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -288,6 +288,37 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.unit()\n             }\n \n+            // Avoid creating a temporary\n+            ExprKind::VarRef { .. } |\n+            ExprKind::SelfRef |\n+            ExprKind::StaticRef { .. } => {\n+                debug_assert!(Category::of(&expr.kind) == Some(Category::Place));\n+\n+                let place = unpack!(block = this.as_place(block, expr));\n+                let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n+                this.cfg.push_assign(block, source_info, destination, rvalue);\n+                block.unit()\n+            }\n+            ExprKind::Index { .. } |\n+            ExprKind::Deref { .. } |\n+            ExprKind::Field { .. } => {\n+                debug_assert!(Category::of(&expr.kind) == Some(Category::Place));\n+\n+                // Create a \"fake\" temporary variable so that we check that the\n+                // value is Sized. Usually, this is caught in type checking, but\n+                // in the case of box expr there is no such check.\n+                if let Place::Projection(..) = destination {\n+                    this.local_decls.push(LocalDecl::new_temp(expr.ty, expr.span));\n+                }\n+\n+                debug_assert!(Category::of(&expr.kind) == Some(Category::Place));\n+\n+                let place = unpack!(block = this.as_place(block, expr));\n+                let rvalue = Rvalue::Use(this.consume_by_copy_or_move(place));\n+                this.cfg.push_assign(block, source_info, destination, rvalue);\n+                block.unit()\n+            }\n+\n             // these are the cases that are more naturally handled by some other mode\n             ExprKind::Unary { .. } |\n             ExprKind::Binary { .. } |\n@@ -300,18 +331,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Unsize { .. } |\n             ExprKind::Repeat { .. } |\n             ExprKind::Borrow { .. } |\n-            ExprKind::VarRef { .. } |\n-            ExprKind::SelfRef |\n-            ExprKind::StaticRef { .. } |\n             ExprKind::Array { .. } |\n             ExprKind::Tuple { .. } |\n             ExprKind::Adt { .. } |\n             ExprKind::Closure { .. } |\n-            ExprKind::Index { .. } |\n-            ExprKind::Deref { .. } |\n             ExprKind::Literal { .. } |\n-            ExprKind::Yield { .. } |\n-            ExprKind::Field { .. } => {\n+            ExprKind::Yield { .. } => {\n                 debug_assert!(match Category::of(&expr.kind).unwrap() {\n                     Category::Rvalue(RvalueFunc::Into) => false,\n                     _ => true,"}, {"sha": "a63cf41f0663ed25d858cbe7ef9e81aa3541803b", "filename": "src/librustc_mir/build/expr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -65,7 +65,7 @@\n //! which can fallback to `into`. So if one of the `ExprKind` variants is not, in fact,\n //! implemented in the category where it is supposed to be, there will be a problem.\n //!\n-//! Of those fallbacks, the most interesting one is `as_temp`, because\n+//! Of those fallbacks, the most interesting one is `into`, because\n //! it discriminates based on the category of the expression. This is\n //! basically the point where the \"by value\" operations are bridged\n //! over to the \"by reference\" mode (`as_place`)."}, {"sha": "79dbdfefeb8e129fc194dab843d5d286f9b0cde0", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -44,6 +44,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                       arms: Vec<Arm<'tcx>>)\n                       -> BlockAnd<()> {\n         let tcx = self.hir.tcx();\n+        let discriminant_span = discriminant.span();\n         let discriminant_place = unpack!(block = self.as_place(block, discriminant));\n \n         // Matching on a `discriminant_place` with an uninhabited type doesn't\n@@ -96,7 +97,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let scope = self.declare_bindings(None, body.span,\n                                               LintLevel::Inherited,\n                                               &arm.patterns[0],\n-                                              ArmHasGuard(arm.guard.is_some()));\n+                                              ArmHasGuard(arm.guard.is_some()),\n+                                              Some((Some(&discriminant_place), discriminant_span)));\n             (body, scope.unwrap_or(self.source_scope))\n         }).collect();\n \n@@ -254,15 +256,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             _ => {\n                 let place = unpack!(block = self.as_place(block, initializer));\n-                self.place_into_pattern(block, irrefutable_pat, &place)\n+                self.place_into_pattern(block, irrefutable_pat, &place, true)\n             }\n         }\n     }\n \n     pub fn place_into_pattern(&mut self,\n                                mut block: BasicBlock,\n                                irrefutable_pat: Pattern<'tcx>,\n-                               initializer: &Place<'tcx>)\n+                               initializer: &Place<'tcx>,\n+                               set_match_place: bool)\n                                -> BlockAnd<()> {\n         // create a dummy candidate\n         let mut candidate = Candidate {\n@@ -288,6 +291,25 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                       candidate.match_pairs);\n         }\n \n+        // for matches and function arguments, the place that is being matched\n+        // can be set when creating the variables. But the place for\n+        // let PATTERN = ... might not even exist until we do the assignment.\n+        // so we set it here instead\n+        if set_match_place {\n+            for binding in &candidate.bindings {\n+                let local = self.var_local_id(binding.var_id, OutsideGuard);\n+\n+                if let Some(ClearCrossCrate::Set(BindingForm::Var(\n+                    VarBindingForm {opt_match_place: Some((ref mut match_place, _)), .. }\n+                ))) = self.local_decls[local].is_user_variable\n+                {\n+                    *match_place = Some(initializer.clone());\n+                } else {\n+                    bug!(\"Let binding to non-user variable.\")\n+                }\n+            }\n+        }\n+\n         // now apply the bindings, which will also declare the variables\n         self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n \n@@ -302,7 +324,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             scope_span: Span,\n                             lint_level: LintLevel,\n                             pattern: &Pattern<'tcx>,\n-                            has_guard: ArmHasGuard)\n+                            has_guard: ArmHasGuard,\n+                            opt_match_place: Option<(Option<&Place<'tcx>>, Span)>)\n                             -> Option<SourceScope> {\n         assert!(!(visibility_scope.is_some() && lint_level.is_explicit()),\n                 \"can't have both a visibility and a lint scope at the same time\");\n@@ -326,7 +349,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             };\n             let visibility_scope = visibility_scope.unwrap();\n             this.declare_binding(source_info, visibility_scope, mutability, name, mode, var,\n-                                 ty, has_guard);\n+                                 ty, has_guard, opt_match_place.map(|(x, y)| (x.cloned(), y)));\n         });\n         visibility_scope\n     }\n@@ -1121,7 +1144,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                        mode: BindingMode,\n                        var_id: NodeId,\n                        var_ty: Ty<'tcx>,\n-                       has_guard: ArmHasGuard)\n+                       has_guard: ArmHasGuard,\n+                       opt_match_place: Option<(Option<Place<'tcx>>, Span)>)\n     {\n         debug!(\"declare_binding(var_id={:?}, name={:?}, mode={:?}, var_ty={:?}, \\\n                 visibility_scope={:?}, source_info={:?})\",\n@@ -1146,6 +1170,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // idents in pat; but complex w/ unclear UI payoff.\n                 // Instead, just abandon providing diagnostic info.\n                 opt_ty_info: None,\n+                opt_match_place,\n             }))),\n         };\n         let for_arm_body = self.local_decls.push(local.clone());"}, {"sha": "4db5c8e9278e5e19e0c7c52385e202bf0edb0642", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -705,6 +705,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             if let Some(pattern) = pattern {\n                 let pattern = self.hir.pattern_from_hir(pattern);\n+                let span = pattern.span;\n \n                 match *pattern.kind {\n                     // Don't introduce extra copies for simple bindings\n@@ -716,15 +717,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             } else {\n                                 let binding_mode = ty::BindingMode::BindByValue(mutability.into());\n                                 Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                                    binding_mode, opt_ty_info })))\n+                                    binding_mode,\n+                                    opt_ty_info,\n+                                    opt_match_place: Some((Some(place.clone()), span)),\n+                                })))\n                             };\n                         self.var_indices.insert(var, LocalsForNode::One(local));\n                     }\n                     _ => {\n                         scope = self.declare_bindings(scope, ast_body.span,\n                                                       LintLevel::Inherited, &pattern,\n-                                                      matches::ArmHasGuard(false));\n-                        unpack!(block = self.place_into_pattern(block, pattern, &place));\n+                                                      matches::ArmHasGuard(false),\n+                                                      Some((Some(&place), span)));\n+                        unpack!(block = self.place_into_pattern(block, pattern, &place, false));\n                     }\n                 }\n             }"}, {"sha": "9ffbe21e1e2cce12dc35ec2987e97e8a7a251b09", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -109,8 +109,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         match *place {\n             Place::Local(local) => Ok(self.builder.data.rev_lookup.locals[local]),\n             Place::Static(..) => {\n-                let span = self.builder.mir.source_info(self.loc).span;\n-                Err(MoveError::cannot_move_out_of(span, Static))\n+                Err(MoveError::cannot_move_out_of(self.loc, Static))\n             }\n             Place::Projection(ref proj) => {\n                 self.move_path_for_projection(place, proj)\n@@ -133,13 +132,13 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         let mir = self.builder.mir;\n         let tcx = self.builder.tcx;\n         let place_ty = proj.base.ty(mir, tcx).to_ty(tcx);\n-        match place_ty.sty {\n+ match place_ty.sty {\n             ty::TyRef(..) | ty::TyRawPtr(..) =>\n                 return Err(MoveError::cannot_move_out_of(\n-                    mir.source_info(self.loc).span,\n+                    self.loc,\n                     BorrowedContent { target_ty: place.ty(mir, tcx).to_ty(tcx) })),\n             ty::TyAdt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n-                return Err(MoveError::cannot_move_out_of(mir.source_info(self.loc).span,\n+                return Err(MoveError::cannot_move_out_of(self.loc,\n                                                          InteriorOfTypeWithDestructor {\n                     container_ty: place_ty\n                 })),\n@@ -148,7 +147,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                 return Err(MoveError::UnionMove { path: base }),\n             ty::TySlice(_) =>\n                 return Err(MoveError::cannot_move_out_of(\n-                    mir.source_info(self.loc).span,\n+                    self.loc,\n                     InteriorOfSliceOrArray {\n                         ty: place_ty, is_index: match proj.elem {\n                             ProjectionElem::Index(..) => true,\n@@ -158,7 +157,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             ty::TyArray(..) => match proj.elem {\n                 ProjectionElem::Index(..) =>\n                     return Err(MoveError::cannot_move_out_of(\n-                        mir.source_info(self.loc).span,\n+                        self.loc,\n                         InteriorOfSliceOrArray {\n                             ty: place_ty, is_index: true\n                         })),"}, {"sha": "3051a687eac7008c519c32b4d51ed3b854e39ce6", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -209,7 +209,7 @@ pub enum InitKind {\n     Deep,\n     /// Only does a shallow init\n     Shallow,\n-    /// This doesn't initialize the variabe on panic (and a panic is possible).\n+    /// This doesn't initialize the variable on panic (and a panic is possible).\n     NonPanicPathOnly,\n }\n \n@@ -271,7 +271,7 @@ impl<'tcx> MovePathLookup<'tcx> {\n \n #[derive(Debug)]\n pub struct IllegalMoveOrigin<'tcx> {\n-    pub(crate) span: Span,\n+    pub(crate) location: Location,\n     pub(crate) kind: IllegalMoveOriginKind<'tcx>,\n }\n \n@@ -304,8 +304,8 @@ pub enum MoveError<'tcx> {\n }\n \n impl<'tcx> MoveError<'tcx> {\n-    fn cannot_move_out_of(span: Span, kind: IllegalMoveOriginKind<'tcx>) -> Self {\n-        let origin = IllegalMoveOrigin { span, kind };\n+    fn cannot_move_out_of(location: Location, kind: IllegalMoveOriginKind<'tcx>) -> Self {\n+        let origin = IllegalMoveOrigin { location, kind };\n         MoveError::IllegalMove { cannot_move_out_of: origin }\n     }\n }"}, {"sha": "a8d29df86908d5d4d009a147179cc8d80099843a", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -315,6 +315,15 @@ pub enum LogicalOp {\n     Or,\n }\n \n+impl<'tcx> ExprRef<'tcx> {\n+    pub fn span(&self) -> Span {\n+        match self {\n+            ExprRef::Hair(expr) => expr.span,\n+            ExprRef::Mirror(expr) => expr.span,\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // The Mirror trait\n "}, {"sha": "4bb66ace02687c2e597603aa3e11333183bebb26", "filename": "src/test/compile-fail/borrowck/borrowck-move-out-of-struct-with-dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-struct-with-dtor.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -18,9 +18,9 @@ impl Drop for S {\n \n fn move_in_match() {\n     match (S {f:\"foo\".to_string()}) {\n+        //[mir]~^ ERROR [E0509]\n         S {f:_s} => {}\n         //[ast]~^ ERROR cannot move out of type `S`, which implements the `Drop` trait [E0509]\n-        //[mir]~^^ ERROR [E0509]\n     }\n }\n "}, {"sha": "440ad3518ae5afc97ab74c48d429d6bd56f9db1d", "filename": "src/test/mir-opt/combine_array_len.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fcombine_array_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fcombine_array_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcombine_array_len.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -21,13 +21,13 @@ fn main() {\n // END RUST SOURCE\n \n // START rustc.norm2.InstCombine.before.mir\n-//     _5 = Len(_1);\n+//     _4 = Len(_1);\n //     ...\n-//     _10 = Len(_1);\n+//     _8 = Len(_1);\n // END rustc.norm2.InstCombine.before.mir\n \n // START rustc.norm2.InstCombine.after.mir\n-//     _5 = const 2usize;\n+//     _4 = const 2usize;\n //     ...\n-//     _10 = const 2usize;\n+//     _8 = const 2usize;\n // END rustc.norm2.InstCombine.after.mir"}, {"sha": "067a937b0b30c878a33fd1d8c9ead1669abe5446", "filename": "src/test/mir-opt/copy_propagation.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fcopy_propagation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fcopy_propagation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -22,20 +22,17 @@ fn main() {\n // START rustc.test.CopyPropagation.before.mir\n //  bb0: {\n //      ...\n-//      _3 = _1;\n+//      _2 = _1;\n //      ...\n-//      _2 = move _3;\n-//      ...\n-//      _4 = _2;\n-//      _0 = move _4;\n+//      _0 = _2;\n //      ...\n //      return;\n //  }\n // END rustc.test.CopyPropagation.before.mir\n // START rustc.test.CopyPropagation.after.mir\n //  bb0: {\n //      ...\n-//      _0 = move _1;\n+//      _0 = _1;\n //      ...\n //      return;\n //  }"}, {"sha": "dacaff8f2d9420bbee07e0de845669a801a2456b", "filename": "src/test/mir-opt/copy_propagation_arg.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -117,25 +117,23 @@ fn main() {\n // START rustc.arg_src.CopyPropagation.before.mir\n // bb0: {\n //      ...\n-//      _3 = _1;\n-//      _2 = move _3;\n+//      _2 = _1;\n //      ...\n //      _1 = const 123i32;\n //      ...\n-//      _4 = _2;\n-//      _0 = move _4;\n+//      _0 = _2;\n //      ...\n //      return;\n //  }\n // END rustc.arg_src.CopyPropagation.before.mir\n // START rustc.arg_src.CopyPropagation.after.mir\n // bb0: {\n //     ...\n-//     _3 = _1;\n+//     _2 = _1;\n //     ...\n //     _1 = const 123i32;\n //     ...\n-//     _0 = move _3;\n+//     _0 = _2;\n //     ...\n //     return;\n // }"}, {"sha": "9496fd9e6c173119d94f7f5f140f4c7f21548da4", "filename": "src/test/mir-opt/end_region_5.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_5.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -68,13 +68,9 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // START rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir\n // fn main::{{closure}}(_1: [closure@NodeId(18) d:&'14s D]) -> i32 {\n //    let mut _0: i32;\n-//    let mut _2: i32;\n //\n //    bb0: {\n-//        StorageLive(_2);\n-//        _2 = ((*(_1.0: &'14s D)).0: i32);\n-//        _0 = move _2;\n-//        StorageDead(_2);\n+//        _0 = ((*(_1.0: &'14s D)).0: i32);\n //        return;\n //    }\n // END rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "910362f65c8d92d797c8c3c16404ff329108730c", "filename": "src/test/mir-opt/end_region_6.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_6.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -70,14 +70,10 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     ...\n //     let _2: &'16_0rs D;\n //     ...\n-//     let mut _3: i32;\n //     bb0: {\n //         StorageLive(_2);\n //         _2 = &'16_0rs (*(_1.0: &'19s D));\n-//         StorageLive(_3);\n-//         _3 = ((*_2).0: i32);\n-//         _0 = move _3;\n-//         StorageDead(_3);\n+//         _0 = ((*_2).0: i32);\n //         EndRegion('16_0rs);\n //         StorageDead(_2);\n //         return;"}, {"sha": "e44b41993aa9512329cbefe78f3077d11a980efc", "filename": "src/test/mir-opt/end_region_7.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_7.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -78,14 +78,10 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     ...\n //     let _2: &'16_0rs D;\n //     ...\n-//     let mut _3: i32;\n //     bb0: {\n //         StorageLive(_2);\n //         _2 = &'16_0rs (_1.0: D);\n-//         StorageLive(_3);\n-//         _3 = ((*_2).0: i32);\n-//         _0 = move _3;\n-//         StorageDead(_3);\n+//         _0 = ((*_2).0: i32);\n //         EndRegion('16_0rs);\n //         StorageDead(_2);\n //         drop(_1) -> [return: bb2, unwind: bb1];"}, {"sha": "7fdf971b3b9df0bd945de24c4347e3decb51976b", "filename": "src/test/mir-opt/end_region_8.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_8.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -76,13 +76,9 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // START rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir\n // fn main::{{closure}}(_1: [closure@NodeId(22) r:&'19s D]) -> i32 {\n //     let mut _0: i32;\n-//     let mut _2: i32;\n //\n //     bb0: {\n-//         StorageLive(_2);\n-//         _2 = ((*(_1.0: &'21_1rs D)).0: i32);\n-//         _0 = move _2;\n-//         StorageDead(_2);\n+//         _0 = ((*(_1.0: &'21_1rs D)).0: i32);\n //         return;\n //     }\n // }"}, {"sha": "fab2f9eff5af35d47add05bd81b010ad18b027c4", "filename": "src/test/mir-opt/end_region_destruction_extents_1.rs", "status": "modified", "additions": 43, "deletions": 57, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -65,52 +65,45 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n \n // START rustc.main.QualifyAndPromoteConstants.before.mir\n // fn main() -> () {\n-//     let mut _0: ();\n+// let mut _0: ();\n //     let mut _1: &'12ds S1;\n-//     let mut _2: &'12ds S1;\n-//     let mut _3: D1<'12ds, '10s>;\n+//     let mut _2: D1<'12ds, '10s>;\n+//     let mut _3: &'12ds S1;\n //     let mut _4: &'12ds S1;\n-//     let mut _5: &'12ds S1;\n-//     let mut _6: S1;\n+//     let mut _5: S1;\n+//     let mut _6: &'10s S1;\n //     let mut _7: &'10s S1;\n-//     let mut _8: &'10s S1;\n-//     let mut _9: S1;\n-//\n+//     let mut _8: S1;\n //     bb0: {\n //         StorageLive(_2);\n //         StorageLive(_3);\n //         StorageLive(_4);\n //         StorageLive(_5);\n+//         _5 = S1::{{constructor}}(const \"ex1\",);\n+//         _4 = &'12ds _5;\n+//         _3 = &'12ds (*_4);\n //         StorageLive(_6);\n-//         _6 = S1::{{constructor}}(const \"ex1\",);\n-//         _5 = &'12ds _6;\n-//         _4 = &'12ds (*_5);\n //         StorageLive(_7);\n //         StorageLive(_8);\n-//         StorageLive(_9);\n-//         _9 = S1::{{constructor}}(const \"dang1\",);\n-//         _8 = &'10s _9;\n-//         _7 = &'10s (*_8);\n-//         _3 = D1<'12ds, '10s>::{{constructor}}(move _4, move _7);\n+//         _8 = S1::{{constructor}}(const \"dang1\",);\n+//         _7 = &'10s _8;\n+//         _6 = &'10s (*_7);\n+//         _2 = D1<'12ds, '10s>::{{constructor}}(move _3, move _6);\n //         EndRegion('10s);\n-//         StorageDead(_7);\n-//         StorageDead(_4);\n-//         _2 = (_3.0: &'12ds S1);\n-//         _1 = move _2;\n-//         StorageDead(_2);\n-//         drop(_3) -> [return: bb2, unwind: bb1];\n+//         StorageDead(_6);\n+//         StorageDead(_3);\n+//         _1 = (_2.0: &'12ds S1);\n+//         drop(_2) -> [return: bb2, unwind: bb1];\n //     }\n-//\n //     bb1: {\n //         resume;\n //     }\n-//\n //     bb2: {\n-//         StorageDead(_3);\n+//         StorageDead(_2);\n+//         StorageDead(_7);\n //         StorageDead(_8);\n-//         StorageDead(_9);\n+//         StorageDead(_4);\n //         StorageDead(_5);\n-//         StorageDead(_6);\n //         EndRegion('12ds);\n //         _0 = ();\n //         return;\n@@ -119,51 +112,44 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n // END rustc.main.QualifyAndPromoteConstants.before.mir\n \n // START rustc.main.QualifyAndPromoteConstants.after.mir\n-// fn main() -> () {\n+// fn main() -> (){\n //     let mut _0: ();\n //     let mut _1: &'12ds S1;\n-//     let mut _2: &'12ds S1;\n-//     let mut _3: D1<'12ds, '10s>;\n+//     let mut _2: D1<'12ds, '10s>;\n+//     let mut _3: &'12ds S1;\n //     let mut _4: &'12ds S1;\n-//     let mut _5: &'12ds S1;\n-//     let mut _6: S1;\n+//     let mut _5: S1;\n+//     let mut _6: &'10s S1;\n //     let mut _7: &'10s S1;\n-//     let mut _8: &'10s S1;\n-//     let mut _9: S1;\n-//     let mut _10: &'10s S1;\n-//     let mut _11: &'12ds S1;\n-//\n+//     let mut _8: S1;\n+//     let mut _9: &'10s S1;\n+//     let mut _10: &'12ds S1;\n //     bb0: {\n //         StorageLive(_2);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         StorageLive(_5);\n-//         _11 = promoted[1];\n-//         _5 = &'12ds (*_11);\n-//         _4 = &'12ds (*_5);\n+//         _10 = promoted[1];\n+//         _4 = &'12ds (*_10);\n+//         _3 = &'12ds (*_4);\n+//         StorageLive(_6);\n //         StorageLive(_7);\n-//         StorageLive(_8);\n-//         _10 = promoted[0];\n-//         _8 = &'10s (*_10);\n-//         _7 = &'10s (*_8);\n-//         _3 = D1<'12ds, '10s>::{{constructor}}(move _4, move _7);\n+//         _9 = promoted[0];\n+//         _7 = &'10s (*_9);\n+//         _6 = &'10s (*_7);\n+//         _2 = D1<'12ds, '10s>::{{constructor}}(move _3, move _6);\n //         EndRegion('10s);\n-//         StorageDead(_7);\n-//         StorageDead(_4);\n-//         _2 = (_3.0: &'12ds S1);\n-//         _1 = move _2;\n-//         StorageDead(_2);\n-//         drop(_3) -> [return: bb2, unwind: bb1];\n+//         StorageDead(_6);\n+//         StorageDead(_3);\n+//         _1 = (_2.0: &'12ds S1);\n+//         drop(_2) -> [return: bb2, unwind: bb1];\n //     }\n-//\n //     bb1: {\n //         resume;\n //     }\n-//\n //     bb2: {\n-//         StorageDead(_3);\n-//         StorageDead(_8);\n-//         StorageDead(_5);\n+//         StorageDead(_2);\n+//         StorageDead(_7);\n+//         StorageDead(_4);\n //         EndRegion('12ds);\n //         _0 = ();\n //         return;"}, {"sha": "6ce51be3ec5db8d1231f827cb9c06e5f825565c0", "filename": "src/test/mir-opt/inline-closure-borrows-arg.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -38,11 +38,9 @@ fn foo<T: Copy>(_t: T, q: &i32) -> i32 {\n //     ...\n //     _7 = &(*_2);\n //     _5 = (move _6, move _7);\n-//     _9 = move (_5.0: &i32);\n-//     _10 = move (_5.1: &i32);\n-//     StorageLive(_8);\n-//     _8 = (*_9);\n-//     _0 = move _8;\n+//     _8 = move (_5.0: &i32);\n+//     _9 = move (_5.1: &i32);\n+//     _0 = (*_8);\n //     ...\n //     return;\n // }"}, {"sha": "22e7de31e90cf2c95a5a527faf70422e6305fd99", "filename": "src/test/mir-opt/inline-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Finline-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Finline-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-closure.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -36,7 +36,7 @@ fn foo<T: Copy>(_t: T, q: i32) -> i32 {\n //     _5 = (move _6, move _7);\n //     _8 = move (_5.0: i32);\n //     _9 = move (_5.1: i32);\n-//     _0 = move _8;\n+//     _0 = _8;\n //     ...\n //     return;\n // }"}, {"sha": "646c4312fc21f9598197ad5ebf719c735fd11762", "filename": "src/test/mir-opt/lower_128bit_debug_test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Flower_128bit_debug_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Flower_128bit_debug_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_128bit_debug_test.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -182,8 +182,8 @@ fn main() {\n //     ...\n //     _1 = move (_13.0: i128);\n //     ...\n-//     _17 = const 7i32 as u128 (Misc);\n-//     _14 = const compiler_builtins::int::shift::rust_i128_shro(_1, move _17) -> bb16;\n+//     _16 = const 7i32 as u128 (Misc);\n+//     _14 = const compiler_builtins::int::shift::rust_i128_shro(_1, move _16) -> bb16;\n //     ...\n //     _1 = move (_14.0: i128);\n //     ...\n@@ -195,8 +195,8 @@ fn main() {\n //     ...\n //     assert(!move (_13.1: bool), \"attempt to shift left with overflow\") -> bb8;\n //     ...\n-//     _16 = const 6i32 as u128 (Misc);\n-//     _13 = const compiler_builtins::int::shift::rust_i128_shlo(_1, move _16) -> bb14;\n+//     _15 = const 6i32 as u128 (Misc);\n+//     _13 = const compiler_builtins::int::shift::rust_i128_shlo(_1, move _15) -> bb14;\n //     ...\n //     assert(!move (_14.1: bool), \"attempt to shift right with overflow\") -> bb9;\n // END rustc.test_signed.Lower128Bit.after.mir\n@@ -218,8 +218,8 @@ fn main() {\n //     ...\n //     _1 = move (_7.0: u128);\n //     ...\n-//     _11 = const 7i32 as u128 (Misc);\n-//     _8 = const compiler_builtins::int::shift::rust_u128_shro(_1, move _11) -> bb14;\n+//     _10 = const 7i32 as u128 (Misc);\n+//     _8 = const compiler_builtins::int::shift::rust_u128_shro(_1, move _10) -> bb14;\n //     ...\n //     _1 = move (_8.0: u128);\n //     ...\n@@ -231,8 +231,8 @@ fn main() {\n //     ...\n //     assert(!move (_7.1: bool), \"attempt to shift left with overflow\") -> bb6;\n //     ...\n-//     _10 = const 6i32 as u128 (Misc);\n-//     _7 = const compiler_builtins::int::shift::rust_u128_shlo(_1, move _10) -> bb12;\n+//     _9 = const 6i32 as u128 (Misc);\n+//     _7 = const compiler_builtins::int::shift::rust_u128_shlo(_1, move _9) -> bb12;\n //     ...\n //     assert(!move (_8.1: bool), \"attempt to shift right with overflow\") -> bb7;\n // END rustc.test_unsigned.Lower128Bit.after.mir"}, {"sha": "27446d6bd28f58c2b7485d2abcb5e3e4e3da500c", "filename": "src/test/mir-opt/lower_128bit_test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Flower_128bit_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Flower_128bit_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_128bit_test.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -176,11 +176,11 @@ fn main() {\n //     ...\n //     _1 = const compiler_builtins::int::addsub::rust_i128_sub(_1, const 2i128) -> bb6;\n //     ...\n-//     _11 = const 7i32 as u32 (Misc);\n-//     _1 = const compiler_builtins::int::shift::rust_i128_shr(_1, move _11) -> bb9;\n+//     _10 = const 7i32 as u32 (Misc);\n+//     _1 = const compiler_builtins::int::shift::rust_i128_shr(_1, move _10) -> bb9;\n //     ...\n-//     _12 = const 6i32 as u32 (Misc);\n-//     _1 = const compiler_builtins::int::shift::rust_i128_shl(_1, move _12) -> bb10;\n+//     _11 = const 6i32 as u32 (Misc);\n+//     _1 = const compiler_builtins::int::shift::rust_i128_shl(_1, move _11) -> bb10;\n // END rustc.test_signed.Lower128Bit.after.mir\n \n // START rustc.test_unsigned.Lower128Bit.after.mir\n@@ -194,9 +194,9 @@ fn main() {\n //     ...\n //     _1 = const compiler_builtins::int::addsub::rust_u128_sub(_1, const 2u128) -> bb4;\n //     ...\n-//     _5 = const 7i32 as u32 (Misc);\n-//     _1 = const compiler_builtins::int::shift::rust_u128_shr(_1, move _5) -> bb7;\n+//     _4 = const 7i32 as u32 (Misc);\n+//     _1 = const compiler_builtins::int::shift::rust_u128_shr(_1, move _4) -> bb7;\n //     ...\n-//     _6 = const 6i32 as u32 (Misc);\n-//     _1 = const compiler_builtins::int::shift::rust_u128_shl(_1, move _6) -> bb8;\n+//     _5 = const 6i32 as u32 (Misc);\n+//     _1 = const compiler_builtins::int::shift::rust_u128_shl(_1, move _5) -> bb8;\n // END rustc.test_unsigned.Lower128Bit.after.mir"}, {"sha": "a8dd6c73ef017fcd53af55691eae02cbf0e8d415", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -32,9 +32,9 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#2r    | {bb2[0..=6], bb3[0..=1]}\n-// | '_#3r    | {bb2[1..=6], bb3[0..=1]}\n-// | '_#4r    | {bb2[5..=6], bb3[0..=1]}\n+// | '_#2r    | {bb2[0..=3], bb3[0..=1]}\n+// | '_#3r    | {bb2[1..=3], bb3[0..=1]}\n+// | '_#4r    | {bb2[3], bb3[0..=1]}\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n // let _6: &'_#4r usize;\n@@ -43,7 +43,5 @@ fn main() {\n // ...\n // _2 = &'_#2r _1[_3];\n // ...\n-// _7 = _2;\n-// ...\n-// _6 = move _7;\n+// _6 = _2;\n // END rustc.main.nll.0.mir"}, {"sha": "2d5c98ff0ed91336fd24a8c153bc5377f23d7b50", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -67,10 +67,7 @@ fn main() {\n //         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: ItemLocalId(25), first_statement_index: 0 }))), [(*_2): i32]);\n //         _3 = &ReErased (*_2);\n //         Validate(Acquire, [(*_3): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(25), first_statement_index: 0 })) (imm)]);\n-//         StorageLive(_4);\n-//         _4 = (*_3);\n-//         _0 = move _4;\n-//         StorageDead(_4);\n+//         _0 = (*_3);\n //         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(25), first_statement_index: 0 })));\n //         StorageDead(_3);\n //         return;"}, {"sha": "28403644a234af55a0ee3760042cd9a711d01f3e", "filename": "src/test/ui/E0508.ast.nll.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/src%2Ftest%2Fui%2FE0508.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/src%2Ftest%2Fui%2FE0508.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2FE0508.ast.nll.stderr?ref=6e5e63a48c3be7de2faf914c2a9e194ff7cede9e", "patch": "@@ -1,9 +0,0 @@\n-error[E0508]: cannot move out of type `[NonCopy; 1]`, a non-copy array\n-  --> $DIR/E0508.rs:18:18\n-   |\n-LL |     let _value = array[0];  //[ast]~ ERROR [E0508]\n-   |                  ^^^^^^^^ cannot move out of here\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0508`."}, {"sha": "28403644a234af55a0ee3760042cd9a711d01f3e", "filename": "src/test/ui/E0508.mir.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/src%2Ftest%2Fui%2FE0508.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/src%2Ftest%2Fui%2FE0508.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2FE0508.mir.stderr?ref=6e5e63a48c3be7de2faf914c2a9e194ff7cede9e", "patch": "@@ -1,9 +0,0 @@\n-error[E0508]: cannot move out of type `[NonCopy; 1]`, a non-copy array\n-  --> $DIR/E0508.rs:18:18\n-   |\n-LL |     let _value = array[0];  //[ast]~ ERROR [E0508]\n-   |                  ^^^^^^^^ cannot move out of here\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0508`."}, {"sha": "86445ad89821c5c209168afe86df55eaa776c683", "filename": "src/test/ui/E0508.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2FE0508.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2FE0508.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2FE0508.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -8,13 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: ast mir\n-//[mir]compile-flags: -Z borrowck=mir\n-\n struct NonCopy;\n \n fn main() {\n     let array = [NonCopy; 1];\n-    let _value = array[0];  //[ast]~ ERROR [E0508]\n-                            //[mir]~^ ERROR [E0508]\n+    let _value = array[0];  //~ ERROR [E0508]\n }"}, {"sha": "28ce0d971c69d36440e6a8a4e35d1661674e8555", "filename": "src/test/ui/E0508.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2FE0508.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2FE0508.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2FE0508.stderr?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -1,7 +1,7 @@\n error[E0508]: cannot move out of type `[NonCopy; 1]`, a non-copy array\n-  --> $DIR/E0508.rs:18:18\n+  --> $DIR/E0508.rs:15:18\n    |\n-LL |     let _value = array[0];  //[ast]~ ERROR [E0508]\n+LL |     let _value = array[0];  //~ ERROR [E0508]\n    |                  ^^^^^^^^\n    |                  |\n    |                  cannot move out of here", "previous_filename": "src/test/ui/E0508.ast.stderr"}, {"sha": "a34c97974da110360c9a96b768bb5258e36b46d6", "filename": "src/test/ui/borrowck/borrowck-move-error-with-note.nll.stderr", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.nll.stderr?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -1,40 +1,46 @@\n error[E0507]: cannot move out of borrowed content\n-  --> $DIR/borrowck-move-error-with-note.rs:23:19\n+  --> $DIR/borrowck-move-error-with-note.rs:21:11\n    |\n+LL |     match *f {             //~ ERROR cannot move out of\n+   |           ^^\n+   |           |\n+   |           cannot move out of borrowed content\n+   |           help: consider removing this dereference operator: `f`\n+LL |                            //~| cannot move out\n LL |         Foo::Foo1(num1,\n-   |                   ^^^^ cannot move out of borrowed content\n-\n-error[E0507]: cannot move out of borrowed content\n-  --> $DIR/borrowck-move-error-with-note.rs:24:19\n-   |\n+   |                   ---- move occurs because num1 has type `std::boxed::Box<u32>`, which does not implement the `Copy` trait\n LL |                   num2) => (),\n-   |                   ^^^^ cannot move out of borrowed content\n-\n-error[E0507]: cannot move out of borrowed content\n-  --> $DIR/borrowck-move-error-with-note.rs:25:19\n-   |\n+   |                   ---- move occurs because num2 has type `std::boxed::Box<u32>`, which does not implement the `Copy` trait\n LL |         Foo::Foo2(num) => (),\n-   |                   ^^^ cannot move out of borrowed content\n+   |                   --- move occurs because num has type `std::boxed::Box<u32>`, which does not implement the `Copy` trait\n \n error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n-  --> $DIR/borrowck-move-error-with-note.rs:42:16\n+  --> $DIR/borrowck-move-error-with-note.rs:39:11\n    |\n-LL |             f: _s,\n-   |                ^^ cannot move out of here\n-\n-error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n-  --> $DIR/borrowck-move-error-with-note.rs:43:16\n+LL |     match (S {f: \"foo\".to_string(), g: \"bar\".to_string()}) {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot move out of here\n+help: to prevent move, use ref or ref mut\n+   |\n+LL |             f: ref _s,\n+   |                ^^^^^^\n+help: to prevent move, use ref or ref mut\n    |\n-LL |             g: _t\n-   |                ^^ cannot move out of here\n+LL |             g: ref _t\n+   |                ^^^^^^\n \n error[E0507]: cannot move out of borrowed content\n-  --> $DIR/borrowck-move-error-with-note.rs:59:9\n+  --> $DIR/borrowck-move-error-with-note.rs:57:11\n    |\n+LL |     match a.a {           //~ ERROR cannot move out of\n+   |           ^^^\n+   |           |\n+   |           cannot move out of borrowed content\n+   |           help: consider using a reference instead: `&a.a`\n+LL |                           //~| cannot move out\n LL |         n => {\n-   |         ^ cannot move out of borrowed content\n+   |         - move occurs because n has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 3 previous errors\n \n Some errors occurred: E0507, E0509.\n For more information about an error, try `rustc --explain E0507`."}, {"sha": "d01b24507d9fe390ba6d72d208d07ef4144da6a6", "filename": "src/test/ui/borrowck/borrowck-move-out-of-vec-tail.nll.stderr", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.nll.stderr?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -1,15 +1,17 @@\n error[E0508]: cannot move out of type `[Foo]`, a non-copy slice\n-  --> $DIR/borrowck-move-out-of-vec-tail.rs:30:33\n+  --> $DIR/borrowck-move-out-of-vec-tail.rs:29:19\n    |\n-LL |                 &[Foo { string: a },\n-   |                                 ^ cannot move out of here\n-\n-error[E0508]: cannot move out of type `[Foo]`, a non-copy slice\n-  --> $DIR/borrowck-move-out-of-vec-tail.rs:34:33\n+LL |             match tail {\n+   |                   ^^^^ cannot move out of here\n+help: to prevent move, use ref or ref mut\n+   |\n+LL |                 &[Foo { string: ref a },\n+   |                                 ^^^^^\n+help: to prevent move, use ref or ref mut\n    |\n-LL |                   Foo { string: b }] => {\n-   |                                 ^ cannot move out of here\n+LL |                   Foo { string: ref b }] => {\n+   |                                 ^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0508`."}, {"sha": "50ef3ba40e7b23afc6a5ad665c1f3f6d91d4000d", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-nesting.nll.stderr", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.nll.stderr?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -23,54 +23,68 @@ LL |             _b.use_ref();\n    |             -- borrow later used here\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:44:15\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:43:11\n    |\n+LL |     match vec {\n+   |           ^^^ cannot move out of here\n LL |         &mut [_a, //~ ERROR cannot move out\n-   |               ^^ cannot move out of here\n+   |               -- help: to prevent move, use ref or ref mut: `ref _a`\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n   --> $DIR/borrowck-vec-pattern-nesting.rs:57:13\n    |\n LL |     let a = vec[0]; //~ ERROR cannot move out\n-   |             ^^^^^^ cannot move out of here\n+   |             ^^^^^^\n+   |             |\n+   |             cannot move out of here\n+   |             help: consider using a reference instead: `&vec[0]`\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:67:10\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:64:11\n    |\n+LL |     match vec {\n+   |           ^^^ cannot move out of here\n+...\n LL |          _b] => {}\n-   |          ^^ cannot move out of here\n+   |          -- help: to prevent move, use ref or ref mut: `ref _b`\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n   --> $DIR/borrowck-vec-pattern-nesting.rs:70:13\n    |\n LL |     let a = vec[0]; //~ ERROR cannot move out\n-   |             ^^^^^^ cannot move out of here\n+   |             ^^^^^^\n+   |             |\n+   |             cannot move out of here\n+   |             help: consider using a reference instead: `&vec[0]`\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:78:15\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:77:11\n    |\n-LL |         &mut [_a, _b, _c] => {}  //~ ERROR cannot move out\n-   |               ^^ cannot move out of here\n-\n-error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:78:19\n+LL |     match vec {\n+   |           ^^^ cannot move out of here\n+help: to prevent move, use ref or ref mut\n    |\n-LL |         &mut [_a, _b, _c] => {}  //~ ERROR cannot move out\n-   |                   ^^ cannot move out of here\n-\n-error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:78:23\n+LL |         &mut [ref _a, _b, _c] => {}  //~ ERROR cannot move out\n+   |               ^^^^^^\n+help: to prevent move, use ref or ref mut\n+   |\n+LL |         &mut [_a, ref _b, _c] => {}  //~ ERROR cannot move out\n+   |                   ^^^^^^\n+help: to prevent move, use ref or ref mut\n    |\n-LL |         &mut [_a, _b, _c] => {}  //~ ERROR cannot move out\n-   |                       ^^ cannot move out of here\n+LL |         &mut [_a, _b, ref _c] => {}  //~ ERROR cannot move out\n+   |                       ^^^^^^\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n   --> $DIR/borrowck-vec-pattern-nesting.rs:82:13\n    |\n LL |     let a = vec[0]; //~ ERROR cannot move out\n-   |             ^^^^^^ cannot move out of here\n+   |             ^^^^^^\n+   |             |\n+   |             cannot move out of here\n+   |             help: consider using a reference instead: `&vec[0]`\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 8 previous errors\n \n Some errors occurred: E0506, E0508.\n For more information about an error, try `rustc --explain E0506`."}, {"sha": "d872c7efe2bc116dca0abdd552dcf4aec7b3888c", "filename": "src/test/ui/borrowck/issue-51415.nll.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.nll.stderr?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -1,8 +1,11 @@\n error[E0507]: cannot move out of borrowed content\n-  --> $DIR/issue-51415.rs:16:47\n+  --> $DIR/issue-51415.rs:16:42\n    |\n LL |     let opt = a.iter().enumerate().find(|(_, &s)| {\n-   |                                               ^ cannot move out of borrowed content\n+   |                                          ^^^^^-^\n+   |                                          |    |\n+   |                                          |    help: to prevent move, use ref or ref mut: `ref s`\n+   |                                          cannot move out of borrowed content\n \n error: aborting due to previous error\n "}, {"sha": "34616a8de45ed9882743c67058448700e39b5133", "filename": "src/test/ui/codemap_tests/overlapping_spans.nll.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.nll.stderr?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -1,8 +1,10 @@\n error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n-  --> $DIR/overlapping_spans.rs:21:14\n+  --> $DIR/overlapping_spans.rs:20:11\n    |\n+LL |     match (S {f:\"foo\".to_string()}) {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot move out of here\n LL |         S {f:_s} => {} //~ ERROR cannot move out\n-   |              ^^ cannot move out of here\n+   |              -- help: to prevent move, use ref or ref mut: `ref _s`\n \n error: aborting due to previous error\n "}, {"sha": "56d970494a0e07efe8687505c9ada8b9355cac21", "filename": "src/test/ui/error-codes/E0509.nll.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/src%2Ftest%2Fui%2Ferror-codes%2FE0509.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e5e63a48c3be7de2faf914c2a9e194ff7cede9e/src%2Ftest%2Fui%2Ferror-codes%2FE0509.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0509.nll.stderr?ref=6e5e63a48c3be7de2faf914c2a9e194ff7cede9e", "patch": "@@ -1,9 +0,0 @@\n-error[E0509]: cannot move out of type `DropStruct`, which implements the `Drop` trait\n-  --> $DIR/E0509.rs:26:23\n-   |\n-LL |     let fancy_field = drop_struct.fancy; //~ ERROR E0509\n-   |                       ^^^^^^^^^^^^^^^^^ cannot move out of here\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0509`."}, {"sha": "162e43abc0ac47a0e915200ff2df12e647227194", "filename": "src/test/ui/issue-40402-ref-hints/issue-40402-1.nll.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fissue-40402-ref-hints%2Fissue-40402-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fissue-40402-ref-hints%2Fissue-40402-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-40402-ref-hints%2Fissue-40402-1.nll.stderr?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -2,7 +2,10 @@ error[E0507]: cannot move out of borrowed content\n   --> $DIR/issue-40402-1.rs:19:13\n    |\n LL |     let e = f.v[0]; //~ ERROR cannot move out of indexed content\n-   |             ^^^^^^ cannot move out of borrowed content\n+   |             ^^^^^^\n+   |             |\n+   |             cannot move out of borrowed content\n+   |             help: consider using a reference instead: `&f.v[0]`\n \n error: aborting due to previous error\n "}, {"sha": "cd75be24589dfbf443bd00671ba8dc3e43056891", "filename": "src/test/ui/issue-40402-ref-hints/issue-40402-2.nll.stderr", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fissue-40402-ref-hints%2Fissue-40402-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fissue-40402-ref-hints%2Fissue-40402-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-40402-ref-hints%2Fissue-40402-2.nll.stderr?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -1,15 +1,14 @@\n error[E0507]: cannot move out of borrowed content\n-  --> $DIR/issue-40402-2.rs:15:10\n+  --> $DIR/issue-40402-2.rs:15:18\n    |\n LL |     let (a, b) = x[0]; //~ ERROR cannot move out of indexed content\n-   |          ^ cannot move out of borrowed content\n+   |          -  -    ^^^^\n+   |          |  |    |\n+   |          |  |    cannot move out of borrowed content\n+   |          |  |    help: consider using a reference instead: `&x[0]`\n+   |          |  move occurs because b has type `std::string::String`, which does not implement the `Copy` trait\n+   |          move occurs because a has type `std::string::String`, which does not implement the `Copy` trait\n \n-error[E0507]: cannot move out of borrowed content\n-  --> $DIR/issue-40402-2.rs:15:13\n-   |\n-LL |     let (a, b) = x[0]; //~ ERROR cannot move out of indexed content\n-   |             ^ cannot move out of borrowed content\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0507`."}, {"sha": "94f2074b45d4c0a444f38b6606876e5eefdb3097", "filename": "src/test/ui/moves-based-on-type-block-bad.nll.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fmoves-based-on-type-block-bad.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fmoves-based-on-type-block-bad.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves-based-on-type-block-bad.nll.stderr?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -1,8 +1,14 @@\n error[E0507]: cannot move out of borrowed content\n-  --> $DIR/moves-based-on-type-block-bad.rs:37:28\n+  --> $DIR/moves-based-on-type-block-bad.rs:34:19\n    |\n+LL |             match hellothere.x { //~ ERROR cannot move out\n+   |                   ^^^^^^^^^^^^\n+   |                   |\n+   |                   cannot move out of borrowed content\n+   |                   help: consider using a reference instead: `&hellothere.x`\n+...\n LL |                 box E::Bar(x) => println!(\"{}\", x.to_string()),\n-   |                            ^ cannot move out of borrowed content\n+   |                            - move occurs because x has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n \n error: aborting due to previous error\n "}, {"sha": "6445f166b57197a493f642a4597f83444229c96c", "filename": "src/test/ui/nll/move-errors.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fnll%2Fmove-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fnll%2Fmove-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmove-errors.rs?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -0,0 +1,130 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+#![feature(nll)]\n+\n+struct A(String);\n+struct C(D);\n+\n+fn suggest_remove_deref() {\n+    let a = &A(\"\".to_string());\n+    let b = *a;\n+    //~^ ERROR\n+}\n+\n+fn suggest_borrow() {\n+    let a = [A(\"\".to_string())];\n+    let b = a[0];\n+    //~^ ERROR\n+}\n+\n+fn suggest_borrow2() {\n+    let mut a = A(\"\".to_string());\n+    let r = &&mut a;\n+    let s = **r;\n+    //~^ ERROR\n+}\n+\n+fn suggest_borrow3() {\n+    use std::rc::Rc;\n+    let mut a = A(\"\".to_string());\n+    let r = Rc::new(a);\n+    let s = *r;\n+    //~^ ERROR\n+}\n+\n+fn suggest_borrow4() {\n+    let a = [A(\"\".to_string())][0];\n+    //~^ ERROR\n+}\n+\n+fn suggest_borrow5() {\n+    let a = &A(\"\".to_string());\n+    let A(s) = *a;\n+    //~^ ERROR\n+}\n+\n+fn suggest_ref() {\n+    let c = C(D(String::new()));\n+    let C(D(s)) = c;\n+    //~^ ERROR\n+}\n+\n+fn suggest_nothing() {\n+    let a = &A(\"\".to_string());\n+    let b;\n+    b = *a;\n+    //~^ ERROR\n+}\n+\n+enum B {\n+    V(String),\n+    U(D),\n+}\n+\n+struct D(String);\n+\n+impl Drop for D {\n+    fn drop(&mut self) {}\n+}\n+\n+struct F(String, String);\n+\n+impl Drop for F {\n+    fn drop(&mut self) {}\n+}\n+\n+fn probably_suggest_borrow() {\n+    let x = [B::V(String::new())];\n+    match x[0] {\n+    //~^ ERROR\n+        B::U(d) => (),\n+        B::V(s) => (),\n+    }\n+}\n+\n+fn have_to_suggest_ref() {\n+    let x = B::V(String::new());\n+    match x {\n+    //~^ ERROR\n+        B::V(s) => drop(s),\n+        B::U(D(s)) => (),\n+    };\n+}\n+\n+fn two_separate_errors() {\n+    let x = (D(String::new()), &String::new());\n+    match x {\n+    //~^ ERROR\n+    //~^^ ERROR\n+        (D(s), &t) => (),\n+        _ => (),\n+    }\n+}\n+\n+fn have_to_suggest_double_ref() {\n+    let x = F(String::new(), String::new());\n+    match x {\n+    //~^ ERROR\n+        F(s, mut t) => (),\n+        _ => (),\n+    }\n+}\n+\n+fn double_binding(x: &Result<String, String>) {\n+    match *x {\n+    //~^ ERROR\n+        Ok(s) | Err(s) => (),\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "3f2c651ae3a6af343245fc10d536e088545fcd6a", "filename": "src/test/ui/nll/move-errors.stderr", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fnll%2Fmove-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab8a67c12adc6ba84b6143a539640d5962ef6cbe/src%2Ftest%2Fui%2Fnll%2Fmove-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmove-errors.stderr?ref=ab8a67c12adc6ba84b6143a539640d5962ef6cbe", "patch": "@@ -0,0 +1,140 @@\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/move-errors.rs:19:13\n+   |\n+LL |     let b = *a;\n+   |             ^^\n+   |             |\n+   |             cannot move out of borrowed content\n+   |             help: consider removing this dereference operator: `a`\n+\n+error[E0508]: cannot move out of type `[A; 1]`, a non-copy array\n+  --> $DIR/move-errors.rs:25:13\n+   |\n+LL |     let b = a[0];\n+   |             ^^^^\n+   |             |\n+   |             cannot move out of here\n+   |             help: consider using a reference instead: `&a[0]`\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/move-errors.rs:32:13\n+   |\n+LL |     let s = **r;\n+   |             ^^^\n+   |             |\n+   |             cannot move out of borrowed content\n+   |             help: consider using a reference instead: `&**r`\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/move-errors.rs:40:13\n+   |\n+LL |     let s = *r;\n+   |             ^^\n+   |             |\n+   |             cannot move out of borrowed content\n+   |             help: consider using a reference instead: `&*r`\n+\n+error[E0508]: cannot move out of type `[A; 1]`, a non-copy array\n+  --> $DIR/move-errors.rs:45:13\n+   |\n+LL |     let a = [A(\"\".to_string())][0];\n+   |             ^^^^^^^^^^^^^^^^^^^^^^\n+   |             |\n+   |             cannot move out of here\n+   |             help: consider using a reference instead: `&[A(\"\".to_string())][0]`\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/move-errors.rs:51:16\n+   |\n+LL |     let A(s) = *a;\n+   |           -    ^^\n+   |           |    |\n+   |           |    cannot move out of borrowed content\n+   |           |    help: consider removing this dereference operator: `a`\n+   |           move occurs because s has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0509]: cannot move out of type `D`, which implements the `Drop` trait\n+  --> $DIR/move-errors.rs:57:19\n+   |\n+LL |     let C(D(s)) = c;\n+   |             -     ^ cannot move out of here\n+   |             |\n+   |             help: to prevent move, use ref or ref mut: `ref s`\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/move-errors.rs:64:9\n+   |\n+LL |     b = *a;\n+   |         ^^ cannot move out of borrowed content\n+\n+error[E0508]: cannot move out of type `[B; 1]`, a non-copy array\n+  --> $DIR/move-errors.rs:87:11\n+   |\n+LL |     match x[0] {\n+   |           ^^^^\n+   |           |\n+   |           cannot move out of here\n+   |           help: consider using a reference instead: `&x[0]`\n+LL |     //~^ ERROR\n+LL |         B::U(d) => (),\n+   |              - move occurs because d has type `D`, which does not implement the `Copy` trait\n+LL |         B::V(s) => (),\n+   |              - move occurs because s has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error[E0509]: cannot move out of type `D`, which implements the `Drop` trait\n+  --> $DIR/move-errors.rs:96:11\n+   |\n+LL |     match x {\n+   |           ^ cannot move out of here\n+...\n+LL |         B::U(D(s)) => (),\n+   |                - help: to prevent move, use ref or ref mut: `ref s`\n+\n+error[E0509]: cannot move out of type `D`, which implements the `Drop` trait\n+  --> $DIR/move-errors.rs:105:11\n+   |\n+LL |     match x {\n+   |           ^ cannot move out of here\n+...\n+LL |         (D(s), &t) => (),\n+   |            - help: to prevent move, use ref or ref mut: `ref s`\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/move-errors.rs:105:11\n+   |\n+LL |     match x {\n+   |           ^ cannot move out of borrowed content\n+...\n+LL |         (D(s), &t) => (),\n+   |                 - help: to prevent move, use ref or ref mut: `ref t`\n+\n+error[E0509]: cannot move out of type `F`, which implements the `Drop` trait\n+  --> $DIR/move-errors.rs:115:11\n+   |\n+LL |     match x {\n+   |           ^ cannot move out of here\n+help: to prevent move, use ref or ref mut\n+   |\n+LL |         F(ref s, mut t) => (),\n+   |           ^^^^^\n+help: to prevent move, use ref or ref mut\n+   |\n+LL |         F(s, ref mut t) => (),\n+   |              ^^^^^^^^^\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/move-errors.rs:123:11\n+   |\n+LL |     match *x {\n+   |           ^^\n+   |           |\n+   |           cannot move out of borrowed content\n+   |           help: consider removing this dereference operator: `x`\n+LL |     //~^ ERROR\n+LL |         Ok(s) | Err(s) => (),\n+   |            - move occurs because s has type `std::string::String`, which does not implement the `Copy` trait\n+\n+error: aborting due to 14 previous errors\n+\n+Some errors occurred: E0507, E0508, E0509.\n+For more information about an error, try `rustc --explain E0507`."}]}