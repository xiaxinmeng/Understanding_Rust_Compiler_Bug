{"sha": "eeb2a6203b9b7072d088fbc5339f4c8311e57097", "node_id": "C_kwDOAAsO6NoAKGVlYjJhNjIwM2I5YjcwNzJkMDg4ZmJjNTMzOWY0YzgzMTFlNTcwOTc", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-10-31T04:21:35Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-10-31T17:19:18Z"}, "message": "Extract function for expanding private type aliases", "tree": {"sha": "6a462325f7eed857f342cce1b9097279cd0a2dfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a462325f7eed857f342cce1b9097279cd0a2dfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eeb2a6203b9b7072d088fbc5339f4c8311e57097", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb2a6203b9b7072d088fbc5339f4c8311e57097", "html_url": "https://github.com/rust-lang/rust/commit/eeb2a6203b9b7072d088fbc5339f4c8311e57097", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eeb2a6203b9b7072d088fbc5339f4c8311e57097/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68b554e6af18726fe6fa8de2134c59c441e0b019", "url": "https://api.github.com/repos/rust-lang/rust/commits/68b554e6af18726fe6fa8de2134c59c441e0b019", "html_url": "https://github.com/rust-lang/rust/commit/68b554e6af18726fe6fa8de2134c59c441e0b019"}], "stats": {"total": 189, "additions": 98, "deletions": 91}, "files": [{"sha": "3adc067005b38b278eb154f183d0ed22d4335277", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 98, "deletions": 91, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/eeb2a6203b9b7072d088fbc5339f4c8311e57097/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeb2a6203b9b7072d088fbc5339f4c8311e57097/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=eeb2a6203b9b7072d088fbc5339f4c8311e57097", "patch": "@@ -1148,7 +1148,6 @@ impl Clean<Item> for ty::AssocItem {\n }\n \n fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n-    use rustc_hir::GenericParamCount;\n     let hir::Ty { hir_id: _, span, ref kind } = *hir_ty;\n     let qpath = match kind {\n         hir::TyKind::Path(qpath) => qpath,\n@@ -1166,97 +1165,12 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 }\n             }\n \n-            let mut alias = None;\n-            if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n-                // Substitute private type aliases\n-                if let Some(def_id) = def_id.as_local() {\n-                    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n-                    if !cx.cache.access_levels.is_exported(def_id.to_def_id()) {\n-                        alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);\n-                    }\n-                }\n-            };\n-\n-            if let Some(&hir::ItemKind::TyAlias(ref ty, ref generics)) = alias {\n-                let provided_params = &path.segments.last().expect(\"segments were empty\");\n-                let mut ty_substs = FxHashMap::default();\n-                let mut lt_substs = FxHashMap::default();\n-                let mut ct_substs = FxHashMap::default();\n-                let generic_args = provided_params.args();\n-                {\n-                    let mut indices: GenericParamCount = Default::default();\n-                    for param in generics.params.iter() {\n-                        match param.kind {\n-                            hir::GenericParamKind::Lifetime { .. } => {\n-                                let mut j = 0;\n-                                let lifetime = generic_args.args.iter().find_map(|arg| match arg {\n-                                    hir::GenericArg::Lifetime(lt) => {\n-                                        if indices.lifetimes == j {\n-                                            return Some(lt);\n-                                        }\n-                                        j += 1;\n-                                        None\n-                                    }\n-                                    _ => None,\n-                                });\n-                                if let Some(lt) = lifetime.cloned() {\n-                                    let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                                    let cleaned = if !lt.is_elided() {\n-                                        lt.clean(cx)\n-                                    } else {\n-                                        self::types::Lifetime::elided()\n-                                    };\n-                                    lt_substs.insert(lt_def_id.to_def_id(), cleaned);\n-                                }\n-                                indices.lifetimes += 1;\n-                            }\n-                            hir::GenericParamKind::Type { ref default, .. } => {\n-                                let ty_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                                let mut j = 0;\n-                                let type_ = generic_args.args.iter().find_map(|arg| match arg {\n-                                    hir::GenericArg::Type(ty) => {\n-                                        if indices.types == j {\n-                                            return Some(ty);\n-                                        }\n-                                        j += 1;\n-                                        None\n-                                    }\n-                                    _ => None,\n-                                });\n-                                if let Some(ty) = type_ {\n-                                    ty_substs.insert(ty_param_def_id.to_def_id(), ty.clean(cx));\n-                                } else if let Some(default) = *default {\n-                                    ty_substs\n-                                        .insert(ty_param_def_id.to_def_id(), default.clean(cx));\n-                                }\n-                                indices.types += 1;\n-                            }\n-                            hir::GenericParamKind::Const { .. } => {\n-                                let const_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                                let mut j = 0;\n-                                let const_ = generic_args.args.iter().find_map(|arg| match arg {\n-                                    hir::GenericArg::Const(ct) => {\n-                                        if indices.consts == j {\n-                                            return Some(ct);\n-                                        }\n-                                        j += 1;\n-                                        None\n-                                    }\n-                                    _ => None,\n-                                });\n-                                if let Some(ct) = const_ {\n-                                    ct_substs.insert(const_param_def_id.to_def_id(), ct.clean(cx));\n-                                }\n-                                // FIXME(const_generics_defaults)\n-                                indices.consts += 1;\n-                            }\n-                        }\n-                    }\n-                }\n-                return cx.enter_alias(ty_substs, lt_substs, ct_substs, |cx| ty.clean(cx));\n+            if let Some(expanded) = maybe_expand_private_type_alias(cx, path) {\n+                expanded\n+            } else {\n+                let path = path.clean(cx);\n+                resolve_type(cx, path)\n             }\n-            let path = path.clean(cx);\n-            resolve_type(cx, path)\n         }\n         hir::QPath::Resolved(Some(ref qself), p) => {\n             // Try to normalize `<X as Y>::T` to a type\n@@ -1300,6 +1214,99 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n     }\n }\n \n+fn maybe_expand_private_type_alias(cx: &mut DocContext<'_>, path: &hir::Path<'_>) -> Option<Type> {\n+    let mut alias = None;\n+    if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n+        // Substitute private type aliases\n+        if let Some(def_id) = def_id.as_local() {\n+            let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n+            if !cx.cache.access_levels.is_exported(def_id.to_def_id()) {\n+                alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);\n+            }\n+        }\n+    };\n+\n+    if let Some(&hir::ItemKind::TyAlias(ref ty, ref generics)) = alias {\n+        let provided_params = &path.segments.last().expect(\"segments were empty\");\n+        let mut ty_substs = FxHashMap::default();\n+        let mut lt_substs = FxHashMap::default();\n+        let mut ct_substs = FxHashMap::default();\n+        let generic_args = provided_params.args();\n+        {\n+            let mut indices: hir::GenericParamCount = Default::default();\n+            for param in generics.params.iter() {\n+                match param.kind {\n+                    hir::GenericParamKind::Lifetime { .. } => {\n+                        let mut j = 0;\n+                        let lifetime = generic_args.args.iter().find_map(|arg| match arg {\n+                            hir::GenericArg::Lifetime(lt) => {\n+                                if indices.lifetimes == j {\n+                                    return Some(lt);\n+                                }\n+                                j += 1;\n+                                None\n+                            }\n+                            _ => None,\n+                        });\n+                        if let Some(lt) = lifetime.cloned() {\n+                            let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                            let cleaned = if !lt.is_elided() {\n+                                lt.clean(cx)\n+                            } else {\n+                                self::types::Lifetime::elided()\n+                            };\n+                            lt_substs.insert(lt_def_id.to_def_id(), cleaned);\n+                        }\n+                        indices.lifetimes += 1;\n+                    }\n+                    hir::GenericParamKind::Type { ref default, .. } => {\n+                        let ty_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                        let mut j = 0;\n+                        let type_ = generic_args.args.iter().find_map(|arg| match arg {\n+                            hir::GenericArg::Type(ty) => {\n+                                if indices.types == j {\n+                                    return Some(ty);\n+                                }\n+                                j += 1;\n+                                None\n+                            }\n+                            _ => None,\n+                        });\n+                        if let Some(ty) = type_ {\n+                            ty_substs.insert(ty_param_def_id.to_def_id(), ty.clean(cx));\n+                        } else if let Some(default) = *default {\n+                            ty_substs.insert(ty_param_def_id.to_def_id(), default.clean(cx));\n+                        }\n+                        indices.types += 1;\n+                    }\n+                    hir::GenericParamKind::Const { .. } => {\n+                        let const_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                        let mut j = 0;\n+                        let const_ = generic_args.args.iter().find_map(|arg| match arg {\n+                            hir::GenericArg::Const(ct) => {\n+                                if indices.consts == j {\n+                                    return Some(ct);\n+                                }\n+                                j += 1;\n+                                None\n+                            }\n+                            _ => None,\n+                        });\n+                        if let Some(ct) = const_ {\n+                            ct_substs.insert(const_param_def_id.to_def_id(), ct.clean(cx));\n+                        }\n+                        // FIXME(const_generics_defaults)\n+                        indices.consts += 1;\n+                    }\n+                }\n+            }\n+        }\n+        Some(cx.enter_alias(ty_substs, lt_substs, ct_substs, |cx| ty.clean(cx)))\n+    } else {\n+        None\n+    }\n+}\n+\n impl Clean<Type> for hir::Ty<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         use rustc_hir::*;"}]}