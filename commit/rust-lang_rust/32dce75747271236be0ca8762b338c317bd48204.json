{"sha": "32dce75747271236be0ca8762b338c317bd48204", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyZGNlNzU3NDcyNzEyMzZiZTBjYTg3NjJiMzM4YzMxN2JkNDgyMDQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-16T17:38:10Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-03-16T17:38:19Z"}, "message": "Some more refactoring", "tree": {"sha": "5ab1c14160b2b416e022a5fa0c106dd851bf8fe4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ab1c14160b2b416e022a5fa0c106dd851bf8fe4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32dce75747271236be0ca8762b338c317bd48204", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32dce75747271236be0ca8762b338c317bd48204", "html_url": "https://github.com/rust-lang/rust/commit/32dce75747271236be0ca8762b338c317bd48204", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32dce75747271236be0ca8762b338c317bd48204/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6b622cdef6af45aff46650c247940a590afde92", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6b622cdef6af45aff46650c247940a590afde92", "html_url": "https://github.com/rust-lang/rust/commit/d6b622cdef6af45aff46650c247940a590afde92"}], "stats": {"total": 134, "additions": 76, "deletions": 58}, "files": [{"sha": "7adb70d45a9f002f20c871dde8ded6467a30f547", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/32dce75747271236be0ca8762b338c317bd48204/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32dce75747271236be0ca8762b338c317bd48204/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=32dce75747271236be0ca8762b338c317bd48204", "patch": "@@ -16,10 +16,15 @@ pub(crate) fn expand(rules: &crate::MacroRules, input: &tt::Subtree) -> ExpandRe\n \n fn expand_rules(rules: &[crate::Rule], input: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n     let mut match_: Option<(matcher::Match, &crate::Rule)> = None;\n-    let mut err = Some(ExpandError::NoMatchingRule);\n     for rule in rules {\n-        let ExpandResult(new_match, bindings_err) = matcher::match_(&rule.lhs, input);\n-        if bindings_err.is_none() {\n+        let new_match = match matcher::match_(&rule.lhs, input) {\n+            Ok(m) => m,\n+            Err(_e) => {\n+                // error in pattern parsing\n+                continue;\n+            }\n+        };\n+        if new_match.err.is_none() {\n             // If we find a rule that applies without errors, we're done.\n             // Unconditionally returning the transcription here makes the\n             // `test_repeat_bad_var` test fail.\n@@ -32,25 +37,22 @@ fn expand_rules(rules: &[crate::Rule], input: &tt::Subtree) -> ExpandResult<tt::\n         // Use the rule if we matched more tokens, or had fewer patterns left,\n         // or had no error\n         if let Some((prev_match, _)) = &match_ {\n-            if (new_match.unmatched_tokens, new_match.unmatched_patterns)\n-                < (prev_match.unmatched_tokens, prev_match.unmatched_patterns)\n-                || err.is_some() && bindings_err.is_none()\n+            if (new_match.unmatched_tts, new_match.err_count)\n+                < (prev_match.unmatched_tts, prev_match.err_count)\n             {\n                 match_ = Some((new_match, rule));\n-                err = bindings_err;\n             }\n         } else {\n             match_ = Some((new_match, rule));\n-            err = bindings_err;\n         }\n     }\n     if let Some((match_, rule)) = match_ {\n         // if we got here, there was no match without errors\n         let ExpandResult(result, transcribe_err) =\n             transcriber::transcribe(&rule.rhs, &match_.bindings);\n-        ExpandResult(result, err.or(transcribe_err))\n+        ExpandResult(result, match_.err.or(transcribe_err))\n     } else {\n-        ExpandResult(tt::Subtree::default(), err)\n+        ExpandResult(tt::Subtree::default(), Some(ExpandError::NoMatchingRule))\n     }\n }\n "}, {"sha": "2579382da8dad14d2ef5f3744113bc320d482588", "filename": "crates/ra_mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 64, "deletions": 48, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/32dce75747271236be0ca8762b338c317bd48204/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32dce75747271236be0ca8762b338c317bd48204/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=32dce75747271236be0ca8762b338c317bd48204", "patch": "@@ -62,44 +62,55 @@ macro_rules! err {\n #[derive(Debug, Default)]\n pub(super) struct Match {\n     pub bindings: Bindings,\n-    pub unmatched_tokens: usize,\n-    pub unmatched_patterns: usize,\n+    /// We currently just keep the first error and count the rest to compare matches.\n+    pub err: Option<ExpandError>,\n+    pub err_count: usize,\n+    /// How many top-level token trees were left to match.\n+    pub unmatched_tts: usize,\n }\n \n-pub(super) fn match_(pattern: &tt::Subtree, src: &tt::Subtree) -> ExpandResult<Match> {\n+impl Match {\n+    pub fn add_err(&mut self, err: ExpandError) {\n+        let prev_err = self.err.take();\n+        self.err = prev_err.or(Some(err));\n+        self.err_count += 1;\n+    }\n+}\n+\n+// General note: These functions have two channels to return errors, a `Result`\n+// return value and the `&mut Match`. The returned Result is for pattern parsing\n+// errors; if a branch of the macro definition doesn't parse, it doesn't make\n+// sense to try using it. Matching errors are added to the `Match`. It might\n+// make sense to make pattern parsing a separate step?\n+\n+pub(super) fn match_(pattern: &tt::Subtree, src: &tt::Subtree) -> Result<Match, ExpandError> {\n     assert!(pattern.delimiter == None);\n \n     let mut res = Match::default();\n     let mut src = TtIter::new(src);\n \n-    let mut err = match_subtree(&mut res, pattern, &mut src).err();\n+    match_subtree(&mut res, pattern, &mut src)?;\n \n-    res.unmatched_tokens += src.len();\n-    if src.len() > 0 && err.is_none() {\n-        err = Some(err!(\"leftover tokens\"));\n+    if src.len() > 0 {\n+        res.unmatched_tts += src.len();\n+        res.add_err(err!(\"leftover tokens\"));\n     }\n \n-    ExpandResult(res, err)\n+    Ok(res)\n }\n \n fn match_subtree(\n     res: &mut Match,\n     pattern: &tt::Subtree,\n     src: &mut TtIter,\n ) -> Result<(), ExpandError> {\n-    let mut result = Ok(());\n     for op in parse_pattern(pattern) {\n-        if result.is_err() {\n-            // We're just going through the patterns to count how many we missed\n-            res.unmatched_patterns += 1;\n-            continue;\n-        }\n         match op? {\n             Op::TokenTree(tt::TokenTree::Leaf(lhs)) => {\n                 let rhs = match src.expect_leaf() {\n                     Ok(l) => l,\n                     Err(()) => {\n-                        result = Err(err!(\"expected leaf: `{}`\", lhs));\n+                        res.add_err(err!(\"expected leaf: `{}`\", lhs));\n                         continue;\n                     }\n                 };\n@@ -117,34 +128,33 @@ fn match_subtree(\n                         tt::Leaf::Literal(tt::Literal { text: rhs, .. }),\n                     ) if lhs == rhs => (),\n                     _ => {\n-                        result = Err(ExpandError::UnexpectedToken);\n+                        res.add_err(ExpandError::UnexpectedToken);\n                     }\n                 }\n             }\n             Op::TokenTree(tt::TokenTree::Subtree(lhs)) => {\n                 let rhs = match src.expect_subtree() {\n                     Ok(s) => s,\n                     Err(()) => {\n-                        result = Err(err!(\"expected subtree\"));\n+                        res.add_err(err!(\"expected subtree\"));\n                         continue;\n                     }\n                 };\n                 if lhs.delimiter_kind() != rhs.delimiter_kind() {\n-                    result = Err(err!(\"mismatched delimiter\"));\n+                    res.add_err(err!(\"mismatched delimiter\"));\n                     continue;\n                 }\n                 let mut src = TtIter::new(rhs);\n-                result = match_subtree(res, lhs, &mut src);\n-                res.unmatched_tokens += src.len();\n-                if src.len() > 0 && result.is_ok() {\n-                    result = Err(err!(\"leftover tokens\"));\n+                match_subtree(res, lhs, &mut src)?;\n+                if src.len() > 0 {\n+                    res.add_err(err!(\"leftover tokens\"));\n                 }\n             }\n             Op::Var { name, kind } => {\n                 let kind = match kind {\n                     Some(k) => k,\n                     None => {\n-                        result = Err(ExpandError::UnexpectedToken);\n+                        res.add_err(ExpandError::UnexpectedToken);\n                         continue;\n                     }\n                 };\n@@ -156,14 +166,16 @@ fn match_subtree(\n                     None if match_err.is_none() => res.bindings.push_optional(name),\n                     _ => {}\n                 }\n-                result = match_err.map_or(Ok(()), Err);\n+                if let Some(err) = match_err {\n+                    res.add_err(err);\n+                }\n             }\n             Op::Repeat { subtree, kind, separator } => {\n-                result = match_repeat(res, subtree, kind, separator, src);\n+                match_repeat(res, subtree, kind, separator, src)?;\n             }\n         }\n     }\n-    result\n+    Ok(())\n }\n \n impl<'a> TtIter<'a> {\n@@ -345,35 +357,39 @@ pub(super) fn match_repeat(\n         }\n \n         let mut nested = Match::default();\n-        match match_subtree(&mut nested, pattern, &mut fork) {\n-            Ok(()) => {\n-                limit -= 1;\n-                if limit == 0 {\n-                    log::warn!(\n-                        \"match_lhs exceeded repeat pattern limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\",\n-                        pattern,\n-                        src,\n-                        kind,\n-                        separator\n-                    );\n-                    break;\n-                }\n-                *src = fork;\n+        match_subtree(&mut nested, pattern, &mut fork)?;\n+        if nested.err.is_none() {\n+            limit -= 1;\n+            if limit == 0 {\n+                log::warn!(\n+                    \"match_lhs exceeded repeat pattern limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\",\n+                    pattern,\n+                    src,\n+                    kind,\n+                    separator\n+                );\n+                break;\n+            }\n+            *src = fork;\n \n-                res.bindings.push_nested(counter, nested.bindings)?;\n-                counter += 1;\n-                if counter == 1 {\n-                    if let RepeatKind::ZeroOrOne = kind {\n-                        break;\n-                    }\n+            if let Err(err) = res.bindings.push_nested(counter, nested.bindings) {\n+                res.add_err(err);\n+            }\n+            counter += 1;\n+            if counter == 1 {\n+                if let RepeatKind::ZeroOrOne = kind {\n+                    break;\n                 }\n             }\n-            Err(_) => break,\n+        } else {\n+            break;\n         }\n     }\n \n     match (kind, counter) {\n-        (RepeatKind::OneOrMore, 0) => return Err(ExpandError::UnexpectedToken),\n+        (RepeatKind::OneOrMore, 0) => {\n+            res.add_err(ExpandError::UnexpectedToken);\n+        }\n         (_, 0) => {\n             // Collect all empty variables in subtrees\n             let mut vars = Vec::new();"}]}