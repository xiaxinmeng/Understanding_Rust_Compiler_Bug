{"sha": "9d42b1bf04a807c18da0671ecadb8f4fa2044077", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNDJiMWJmMDRhODA3YzE4ZGEwNjcxZWNhZGI4ZjRmYTIwNDQwNzc=", "commit": {"author": {"name": "jD91mZM2", "email": "me@krake.one", "date": "2018-10-15T19:16:04Z"}, "committer": {"name": "jD91mZM2", "email": "me@krake.one", "date": "2018-10-18T14:32:42Z"}, "message": "Interpret shebangs on redox\n\nThis is no longer handled on the kernel side", "tree": {"sha": "55304022ebb6863ee1d8f3ba16cd1a7faf412f03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55304022ebb6863ee1d8f3ba16cd1a7faf412f03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d42b1bf04a807c18da0671ecadb8f4fa2044077", "comment_count": 0, "verification": {"verified": false, "reason": "unverified_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEvF2uTsFosfm5TJhQMFXVRymnJmYFAlvImYsACgkQMFXVRymn\nJma/igf+PQdxJb9Q8/qXtfz1D3JczIFWP/mUVAvHWuMo4A6YWurZJMr7aDL6sQj4\nsy6cfRW3Ssq1M+Z8klLM80koGnCyRhBT9VgEhI1lVU1GAhm2fo8JhZpB6haE+YXU\niMZcByimPxQykQ6lHueiJAF4vOyzp7H2wKEVtZTItePAE2RZohdxsY9P66CtRmvT\nwWWlERL3oCH0Z2gFW/0NGUSlxNOEj+fMhCJ5rcbn98jYjNohcE7KlpA9Hq54l6OU\nLRYHGmXPyKuM+JjE4h65Dl87I0pylv88PUEEHM5WYothYHjwgJN44bYm49+Z+CMp\nW0P16DGub2Ww0t6gk31OCmjGqBLjaw==\n=dd5o\n-----END PGP SIGNATURE-----", "payload": "tree 55304022ebb6863ee1d8f3ba16cd1a7faf412f03\nparent 8c277d843cbac4d89f5f2dbfdb773cb80f48977b\nauthor jD91mZM2 <me@krake.one> 1539630964 +0200\ncommitter jD91mZM2 <me@krake.one> 1539873162 +0200\n\nInterpret shebangs on redox\n\nThis is no longer handled on the kernel side\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d42b1bf04a807c18da0671ecadb8f4fa2044077", "html_url": "https://github.com/rust-lang/rust/commit/9d42b1bf04a807c18da0671ecadb8f4fa2044077", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d42b1bf04a807c18da0671ecadb8f4fa2044077/comments", "author": {"login": "jD91mZM2", "id": 12830969, "node_id": "MDQ6VXNlcjEyODMwOTY5", "avatar_url": "https://avatars.githubusercontent.com/u/12830969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jD91mZM2", "html_url": "https://github.com/jD91mZM2", "followers_url": "https://api.github.com/users/jD91mZM2/followers", "following_url": "https://api.github.com/users/jD91mZM2/following{/other_user}", "gists_url": "https://api.github.com/users/jD91mZM2/gists{/gist_id}", "starred_url": "https://api.github.com/users/jD91mZM2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jD91mZM2/subscriptions", "organizations_url": "https://api.github.com/users/jD91mZM2/orgs", "repos_url": "https://api.github.com/users/jD91mZM2/repos", "events_url": "https://api.github.com/users/jD91mZM2/events{/privacy}", "received_events_url": "https://api.github.com/users/jD91mZM2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jD91mZM2", "id": 12830969, "node_id": "MDQ6VXNlcjEyODMwOTY5", "avatar_url": "https://avatars.githubusercontent.com/u/12830969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jD91mZM2", "html_url": "https://github.com/jD91mZM2", "followers_url": "https://api.github.com/users/jD91mZM2/followers", "following_url": "https://api.github.com/users/jD91mZM2/following{/other_user}", "gists_url": "https://api.github.com/users/jD91mZM2/gists{/gist_id}", "starred_url": "https://api.github.com/users/jD91mZM2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jD91mZM2/subscriptions", "organizations_url": "https://api.github.com/users/jD91mZM2/orgs", "repos_url": "https://api.github.com/users/jD91mZM2/repos", "events_url": "https://api.github.com/users/jD91mZM2/events{/privacy}", "received_events_url": "https://api.github.com/users/jD91mZM2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c277d843cbac4d89f5f2dbfdb773cb80f48977b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c277d843cbac4d89f5f2dbfdb773cb80f48977b", "html_url": "https://github.com/rust-lang/rust/commit/8c277d843cbac4d89f5f2dbfdb773cb80f48977b"}], "stats": {"total": 94, "additions": 80, "deletions": 14}, "files": [{"sha": "3b2cb7c5e1363f3de76959d6cf0f3b26f8ba8d5f", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 80, "deletions": 14, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9d42b1bf04a807c18da0671ecadb8f4fa2044077/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d42b1bf04a807c18da0671ecadb8f4fa2044077/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=9d42b1bf04a807c18da0671ecadb8f4fa2044077", "patch": "@@ -10,15 +10,22 @@\n \n use env::{split_paths};\n use ffi::{CStr, OsStr};\n+use fs::File;\n use os::unix::ffi::OsStrExt;\n use fmt;\n+<<<<<<< HEAD\n use io::{self, Error, ErrorKind};\n use iter;\n+=======\n+use io::{self, prelude::*, BufReader, Error, ErrorKind, SeekFrom};\n+>>>>>>> b7b1d416a1... Interpret shebangs on redox\n use libc::{EXIT_SUCCESS, EXIT_FAILURE};\n use path::{Path, PathBuf};\n use ptr;\n+use sys::ext::fs::MetadataExt;\n+use sys::ext::io::AsRawFd;\n use sys::fd::FileDesc;\n-use sys::fs::{File, OpenOptions};\n+use sys::fs::{File as SysFile, OpenOptions};\n use sys::os::{ENV_LOCK, environ};\n use sys::pipe::{self, AnonPipe};\n use sys::{cvt, syscall};\n@@ -317,20 +324,80 @@ impl Command {\n             None\n         };\n \n-        let fd = if let Some(program) = program {\n-            t!(cvt(syscall::open(program.as_os_str().as_bytes(), syscall::O_RDONLY | syscall::O_CLOEXEC)))\n+        let mut file = if let Some(program) = program {\n+            t!(File::open(program.as_os_str()))\n         } else {\n             return io::Error::from_raw_os_error(syscall::ENOENT);\n         };\n \n-        let mut args: Vec<[usize; 2]> = iter::once(\n-            [self.program.as_ptr() as usize, self.program.len()]\n-        ).chain(\n-            self.args.iter().map(|arg| [arg.as_ptr() as usize, arg.len()])\n-        ).collect();\n+        // Push all the arguments\n+        let mut args: Vec<[usize; 2]> = Vec::with_capacity(1 + self.args.len());\n \n+        let interpreter = {\n+            let mut reader = BufReader::new(&file);\n+\n+            let mut shebang = [0; 2];\n+            let mut read = 0;\n+            loop {\n+                match t!(reader.read(&mut shebang[read..])) {\n+                    0 => break,\n+                    n => read += n,\n+                }\n+            }\n+\n+            if &shebang == b\"#!\" {\n+                // This is an interpreted script.\n+                // First of all, since we'll be passing another file to\n+                // fexec(), we need to manually check that we have permission\n+                // to execute this file:\n+                let uid = t!(cvt(syscall::getuid()));\n+                let gid = t!(cvt(syscall::getgid()));\n+                let meta = t!(file.metadata());\n+\n+                let mode = if uid == meta.uid() as usize {\n+                    meta.mode() >> 3*2 & 0o7\n+                } else if gid == meta.gid() as usize {\n+                    meta.mode() >> 3*1 & 0o7\n+                } else {\n+                    meta.mode() & 0o7\n+                };\n+                if mode & 1 == 0 {\n+                    return io::Error::from_raw_os_error(syscall::EPERM);\n+                }\n+\n+                // Second of all, we need to actually read which interpreter it wants\n+                let mut interpreter = Vec::new();\n+                t!(reader.read_until(b'\\n', &mut interpreter));\n+                // Pop one trailing newline, if any\n+                if interpreter.ends_with(&[b'\\n']) {\n+                    interpreter.pop().unwrap();\n+                }\n+\n+                // TODO: Here we could just reassign `file` directly, if it\n+                // wasn't for lexical lifetimes. Remove the whole `let\n+                // interpreter = { ... };` hack once NLL lands.\n+                // NOTE: Although DO REMEMBER to make sure the interpreter path\n+                // still lives long enough to reach fexec.\n+                Some(interpreter)\n+            } else {\n+                None\n+            }\n+        };\n+        if let Some(ref interpreter) = interpreter {\n+            let path: &OsStr = OsStr::from_bytes(&interpreter);\n+            file = t!(File::open(path));\n+\n+            args.push([interpreter.as_ptr() as usize, interpreter.len()]);\n+        } else {\n+            t!(file.seek(SeekFrom::Start(0)));\n+        }\n+\n+        args.push([self.program.as_ptr() as usize, self.program.len()]);\n+        args.extend(self.args.iter().map(|arg| [arg.as_ptr() as usize, arg.len()]));\n+\n+        // Push all the variables\n         let mut vars: Vec<[usize; 2]> = Vec::new();\n-        unsafe {\n+        {\n             let _guard = ENV_LOCK.lock();\n             let mut environ = *environ();\n             while *environ != ptr::null() {\n@@ -340,8 +407,7 @@ impl Command {\n             }\n         }\n \n-        if let Err(err) = syscall::fexec(fd, &args, &vars) {\n-            let _ = syscall::close(fd);\n+        if let Err(err) = syscall::fexec(file.as_raw_fd(), &args, &vars) {\n             io::Error::from_raw_os_error(err.errno as i32)\n         } else {\n             panic!(\"return from exec without err\");\n@@ -408,7 +474,7 @@ impl Stdio {\n                 let mut opts = OpenOptions::new();\n                 opts.read(readable);\n                 opts.write(!readable);\n-                let fd = File::open(Path::new(\"null:\"), &opts)?;\n+                let fd = SysFile::open(Path::new(\"null:\"), &opts)?;\n                 Ok((ChildStdio::Owned(fd.into_fd()), None))\n             }\n         }\n@@ -421,8 +487,8 @@ impl From<AnonPipe> for Stdio {\n     }\n }\n \n-impl From<File> for Stdio {\n-    fn from(file: File) -> Stdio {\n+impl From<SysFile> for Stdio {\n+    fn from(file: SysFile) -> Stdio {\n         Stdio::Fd(file.into_fd())\n     }\n }"}]}