{"sha": "2e51e8d926625187226e2e37381b9ea671e18a48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlNTFlOGQ5MjY2MjUxODcyMjZlMmUzNzM4MWI5ZWE2NzFlMThhNDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-28T14:06:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-28T14:06:31Z"}, "message": "auto merge of #12595 : huonw/rust/pub-vis-typ, r=alexcrichton\n\nThese are types that are in exported type signatures, but are not\r\nexported themselves, e.g.\r\n\r\n    struct Foo { ... }\r\n\r\n    pub fn bar() -> Foo { ... }\r\n\r\nwill warn about the Foo.\r\n\r\nSuch types are not listed in documentation, and cannot be named outside\r\nthe crate in which they are declared, which is very user-unfriendly.\r\n\r\ncc #10573.", "tree": {"sha": "265ef6e286dda8ab1499b779f250c9423b0bc2e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/265ef6e286dda8ab1499b779f250c9423b0bc2e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e51e8d926625187226e2e37381b9ea671e18a48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e51e8d926625187226e2e37381b9ea671e18a48", "html_url": "https://github.com/rust-lang/rust/commit/2e51e8d926625187226e2e37381b9ea671e18a48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e51e8d926625187226e2e37381b9ea671e18a48/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b99a8ffad4b2f791c2a32e036dffb160a00bdc69", "url": "https://api.github.com/repos/rust-lang/rust/commits/b99a8ffad4b2f791c2a32e036dffb160a00bdc69", "html_url": "https://github.com/rust-lang/rust/commit/b99a8ffad4b2f791c2a32e036dffb160a00bdc69"}, {"sha": "218eae06ab7c7858057cc6bbd28fb4e0db9f5264", "url": "https://api.github.com/repos/rust-lang/rust/commits/218eae06ab7c7858057cc6bbd28fb4e0db9f5264", "html_url": "https://github.com/rust-lang/rust/commit/218eae06ab7c7858057cc6bbd28fb4e0db9f5264"}], "stats": {"total": 449, "additions": 428, "deletions": 21}, "files": [{"sha": "2a2493688e62a9ca62ed2679bf48c89e5e38ae82", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #[allow(missing_doc)];\n+#[allow(visible_private_types)];\n \n use serialize::json;\n use serialize::json::ToJson;"}, {"sha": "dca1c869ad2fff441376a454c064fcdf473088f1", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -173,6 +173,7 @@\n \n // NB this does *not* include globs, please keep it that way.\n #[feature(macro_rules)];\n+#[allow(visible_private_types)];\n \n use std::mem::replace;\n use std::os;"}, {"sha": "9d70055086359b2a723845b885bcb7b6ffcf9805", "filename": "src/libnative/io/timer_other.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibnative%2Fio%2Ftimer_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibnative%2Fio%2Ftimer_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_other.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -71,6 +71,7 @@ struct Inner {\n     id: uint,\n }\n \n+#[allow(visible_private_types)]\n pub enum Req {\n     // Add a new timer to the helper thread.\n     NewTimer(~Inner),"}, {"sha": "68277efc9b7140c5411bf3f0bb1cb70a4b8ecedd", "filename": "src/libnative/io/timer_timerfd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_timerfd.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -44,6 +44,7 @@ pub struct Timer {\n     priv on_worker: bool,\n }\n \n+#[allow(visible_private_types)]\n pub enum Req {\n     NewTimer(libc::c_int, Chan<()>, bool, imp::itimerspec),\n     RemoveTimer(libc::c_int, Chan<()>),"}, {"sha": "ff1a6bb7f7efb5b91ed32a0baea373e661a1beae", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -30,6 +30,8 @@ This API is completely unstable and subject to change.\n #[feature(macro_rules, globs, struct_variant, managed_boxes)];\n #[feature(quote)];\n \n+#[allow(visible_private_types)];\n+\n extern crate extra;\n extern crate flate;\n extern crate arena;"}, {"sha": "693f6fb35f4fce56a570cf7459bb8c10ac209bfe", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -98,6 +98,7 @@ pub enum Lint {\n     UnusedMut,\n     UnnecessaryAllocation,\n     DeadCode,\n+    VisiblePrivateTypes,\n     UnnecessaryTypecast,\n \n     MissingDoc,\n@@ -312,6 +313,12 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         desc: \"detect piece of code that will never be used\",\n         default: warn\n     }),\n+    (\"visible_private_types\",\n+     LintSpec {\n+        lint: VisiblePrivateTypes,\n+        desc: \"detect use of private types in exported type signatures\",\n+        default: warn\n+    }),\n \n     (\"missing_doc\",\n      LintSpec {"}, {"sha": "afe4d00103618e40a0c7f61a23bd7582ce84afa9", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -16,6 +16,7 @@ use std::mem::replace;\n use collections::{HashSet, HashMap};\n \n use metadata::csearch;\n+use middle::lint;\n use middle::resolve;\n use middle::ty;\n use middle::typeck::{MethodMap, MethodOrigin, MethodParam};\n@@ -1169,6 +1170,251 @@ impl SanePrivacyVisitor {\n     }\n }\n \n+struct VisiblePrivateTypesVisitor<'a> {\n+    tcx: ty::ctxt,\n+    exported_items: &'a ExportedItems,\n+    public_items: &'a PublicItems,\n+}\n+\n+struct CheckTypeForPrivatenessVisitor<'a, 'b> {\n+    inner: &'b VisiblePrivateTypesVisitor<'a>,\n+    /// whether the type refers to private types.\n+    contains_private: bool,\n+    /// whether we've recurred at all (i.e. if we're pointing at the\n+    /// first type on which visit_ty was called).\n+    at_outer_type: bool,\n+    // whether that first type is a public path.\n+    outer_type_is_public_path: bool,\n+}\n+\n+impl<'a> VisiblePrivateTypesVisitor<'a> {\n+    fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n+        let did = match self.tcx.def_map.borrow().get().find_copy(&path_id) {\n+            // `int` etc. (None doesn't seem to occur.)\n+            None | Some(ast::DefPrimTy(..)) => return false,\n+            Some(def) => def_id_of_def(def)\n+        };\n+        // A path can only be private if:\n+        // it's in this crate...\n+        is_local(did) &&\n+            // ... it's not exported (obviously) ...\n+            !self.exported_items.contains(&did.node) &&\n+            // .. and it corresponds to a type in the AST (this returns None for\n+            // type parameters)\n+            self.tcx.map.find(did.node).is_some()\n+    }\n+\n+    fn trait_is_public(&self, trait_id: ast::NodeId) -> bool {\n+        // FIXME: this would preferably be using `exported_items`, but all\n+        // traits are exported currently (see `EmbargoVisitor.exported_trait`)\n+        self.public_items.contains(&trait_id)\n+    }\n+}\n+\n+impl<'a, 'b> Visitor<()> for CheckTypeForPrivatenessVisitor<'a, 'b> {\n+    fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n+        match ty.node {\n+            ast::TyPath(_, _, path_id) => {\n+                if self.inner.path_is_private_type(path_id) {\n+                    self.contains_private = true;\n+                    // found what we're looking for so let's stop\n+                    // working.\n+                    return\n+                } else if self.at_outer_type {\n+                    self.outer_type_is_public_path = true;\n+                }\n+            }\n+            _ => {}\n+        }\n+        self.at_outer_type = false;\n+        visit::walk_ty(self, ty, ())\n+    }\n+\n+    // don't want to recurse into [, .. expr]\n+    fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n+}\n+\n+impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n+    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+        match item.node {\n+            // contents of a private mod can be reexported, so we need\n+            // to check internals.\n+            ast::ItemMod(_) => {}\n+\n+            // An `extern {}` doesn't introduce a new privacy\n+            // namespace (the contents have their own privacies).\n+            ast::ItemForeignMod(_) => {}\n+\n+            ast::ItemTrait(..) if !self.trait_is_public(item.id) => return,\n+\n+            // impls need some special handling to try to offer useful\n+            // error messages without (too many) false positives\n+            // (i.e. we could just return here to not check them at\n+            // all, or some worse estimation of whether an impl is\n+            // publically visible.\n+            ast::ItemImpl(ref g, ref trait_ref, self_, ref methods) => {\n+                // `impl [... for] Private` is never visible.\n+                let self_contains_private;\n+                // impl [... for] Public<...>, but not `impl [... for]\n+                // ~[Public]` or `(Public,)` etc.\n+                let self_is_public_path;\n+\n+                // check the properties of the Self type:\n+                {\n+                    let mut visitor = CheckTypeForPrivatenessVisitor {\n+                        inner: self,\n+                        contains_private: false,\n+                        at_outer_type: true,\n+                        outer_type_is_public_path: false,\n+                    };\n+                    visitor.visit_ty(self_, ());\n+                    self_contains_private = visitor.contains_private;\n+                    self_is_public_path = visitor.outer_type_is_public_path;\n+                }\n+\n+                // miscellanous info about the impl\n+\n+                // `true` iff this is `impl Private for ...`.\n+                let not_private_trait =\n+                    trait_ref.as_ref().map_or(true, // no trait counts as public trait\n+                                              |tr| {\n+                        let did = ty::trait_ref_to_def_id(self.tcx, tr);\n+\n+                        !is_local(did) || self.trait_is_public(did.node)\n+                    });\n+\n+                // `true` iff this is a trait impl or at least one method is public.\n+                //\n+                // `impl Public { $( fn ...() {} )* }` is not visible.\n+                //\n+                // This is required over just using the methods' privacy\n+                // directly because we might have `impl<T: Foo<Private>> ...`,\n+                // and we shouldn't warn about the generics if all the methods\n+                // are private (because `T` won't be visible externally).\n+                let trait_or_some_public_method =\n+                    trait_ref.is_some() ||\n+                    methods.iter().any(|m| self.exported_items.contains(&m.id));\n+\n+                if !self_contains_private &&\n+                        not_private_trait &&\n+                        trait_or_some_public_method {\n+\n+                    visit::walk_generics(self, g, ());\n+\n+                    match *trait_ref {\n+                        None => {\n+                            for method in methods.iter() {\n+                                visit::walk_method_helper(self, *method, ())\n+                            }\n+                        }\n+                        Some(ref tr) => {\n+                            // Any private types in a trait impl fall into two\n+                            // categories.\n+                            // 1. mentioned in the trait definition\n+                            // 2. mentioned in the type params/generics\n+                            //\n+                            // Those in 1. can only occur if the trait is in\n+                            // this crate and will've been warned about on the\n+                            // trait definition (there's no need to warn twice\n+                            // so we don't check the methods).\n+                            //\n+                            // Those in 2. are warned via walk_generics and this\n+                            // call here.\n+                            visit::walk_trait_ref_helper(self, tr, ())\n+                        }\n+                    }\n+                } else if trait_ref.is_none() && self_is_public_path {\n+                    // impl Public<Private> { ... }. Any public static\n+                    // methods will be visible as `Public::foo`.\n+                    let mut found_pub_static = false;\n+                    for method in methods.iter() {\n+                        if method.explicit_self.node == ast::SelfStatic &&\n+                            self.exported_items.contains(&method.id) {\n+                            found_pub_static = true;\n+                            visit::walk_method_helper(self, *method, ());\n+                        }\n+                    }\n+                    if found_pub_static {\n+                        visit::walk_generics(self, g, ())\n+                    }\n+                }\n+                return\n+            }\n+\n+            // `type ... = ...;` can contain private types, because\n+            // we're introducing a new name.\n+            ast::ItemTy(..) => return,\n+\n+            // not at all public, so we don't care\n+            _ if !self.exported_items.contains(&item.id) => return,\n+\n+            _ => {}\n+        }\n+\n+        // we've carefully constructed it so that if we're here, then\n+        // any `visit_ty`'s will be called on things that are in\n+        // public signatures, i.e. things that we're interested in for\n+        // this visitor.\n+        visit::walk_item(self, item, ());\n+    }\n+\n+    fn visit_foreign_item(&mut self, item: &ast::ForeignItem, _: ()) {\n+        if self.exported_items.contains(&item.id) {\n+            visit::walk_foreign_item(self, item, ())\n+        }\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fk: &visit::FnKind, fd: &ast::FnDecl, b: &ast::Block, s: Span, id: ast::NodeId,\n+                _: ()) {\n+        // needs special handling for methods.\n+        if self.exported_items.contains(&id) {\n+            visit::walk_fn(self, fk, fd, b, s, id, ());\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n+        match t.node {\n+            ast::TyPath(ref p, _, path_id) => {\n+                if self.path_is_private_type(path_id) {\n+                    self.tcx.sess.add_lint(lint::VisiblePrivateTypes,\n+                                           path_id, p.span,\n+                                           ~\"private type in exported type signature\");\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_ty(self, t, ())\n+    }\n+\n+    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, _: ()) {\n+        if self.exported_items.contains(&v.node.id) {\n+            visit::walk_variant(self, v, g, ());\n+        }\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &ast::StructField, _: ()) {\n+        match s.node.kind {\n+            // the only way to get here is by being inside a public\n+            // struct/enum variant, so the only way to have a private\n+            // field is with an explicit `priv`.\n+            ast::NamedField(_, ast::Private) => {}\n+\n+            _ => visit::walk_struct_field(self, s, ())\n+        }\n+    }\n+\n+\n+    // we don't need to introspect into these at all: an\n+    // expression/block context can't possibly contain exported\n+    // things, and neither do view_items. (Making them no-ops stops us\n+    // from traversing the whole AST without having to be super\n+    // careful about our `walk_...` calls above.)\n+    fn visit_view_item(&mut self, _: &ast::ViewItem, _: ()) {}\n+    fn visit_block(&mut self, _: &ast::Block, _: ()) {}\n+    fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n+}\n+\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: &MethodMap,\n                    exp_map2: &resolve::ExportMap2,\n@@ -1225,5 +1471,14 @@ pub fn check_crate(tcx: ty::ctxt,\n     }\n \n     let EmbargoVisitor { exported_items, public_items, .. } = visitor;\n+\n+    {\n+        let mut visitor = VisiblePrivateTypesVisitor {\n+            tcx: tcx,\n+            exported_items: &exported_items,\n+            public_items: &public_items\n+        };\n+        visit::walk_crate(&mut visitor, krate, ());\n+    }\n     return (exported_items, public_items);\n }"}, {"sha": "919a7b208d4d764a0a52dbf67c90f19fd1c74422", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -99,7 +99,7 @@ pub enum ExternalLocation {\n }\n \n /// Different ways an implementor of a trait can be rendered.\n-enum Implementor {\n+pub enum Implementor {\n     /// Paths are displayed specially by omitting the `impl XX for` cruft\n     PathType(clean::Type),\n     /// This is the generic representation of a trait implementor, used for"}, {"sha": "890f44faabc0d6e0280b7e3edca56c1651107928", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -41,6 +41,7 @@ via `close` and `delete` methods.\n \n #[feature(macro_rules)];\n #[deny(unused_result, unused_must_use)];\n+#[allow(visible_private_types)];\n \n #[cfg(test)] extern crate green;\n "}, {"sha": "ef641bbb6657f9514b4352fc77896f828393f5f3", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -1130,7 +1130,7 @@ pub mod types {\n                     Data4: [BYTE, ..8],\n                 }\n \n-                struct WSAPROTOCOLCHAIN {\n+                pub struct WSAPROTOCOLCHAIN {\n                     ChainLen: c_int,\n                     ChainEntries: [DWORD, ..MAX_PROTOCOL_CHAIN],\n                 }"}, {"sha": "3cfa494d38293bb013085c81b5d1b96da1a7d5a1", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -24,6 +24,7 @@ pub trait Local<Borrowed> {\n     unsafe fn try_unsafe_borrow() -> Option<*mut Self>;\n }\n \n+#[allow(visible_private_types)]\n impl Local<local_ptr::Borrowed<Task>> for Task {\n     #[inline]\n     fn put(value: ~Task) { unsafe { local_ptr::put(value) } }\n@@ -127,4 +128,3 @@ mod test {\n     }\n \n }\n-"}, {"sha": "898004c665d1d9507895d5744b15f3c83a0dbe29", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -366,6 +366,7 @@ pub mod native {\n \n     #[inline]\n     #[cfg(not(test))]\n+    #[allow(visible_private_types)]\n     pub fn maybe_tls_key() -> Option<tls::Key> {\n         unsafe {\n             // NB: This is a little racy because, while the key is"}, {"sha": "b194a9fe308614de996ee2d13ae956349d8544c3", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -280,6 +280,7 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n \n #[cfg(not(target_arch = \"arm\"), not(test))]\n #[doc(hidden)]\n+#[allow(visible_private_types)]\n pub mod eabi {\n     use uw = super::libunwind;\n     use libc::c_int;\n@@ -333,6 +334,7 @@ pub mod eabi {\n // ARM EHABI uses a slightly different personality routine signature,\n // but otherwise works the same.\n #[cfg(target_arch = \"arm\", not(test))]\n+#[allow(visible_private_types)]\n pub mod eabi {\n     use uw = super::libunwind;\n     use libc::c_int;"}, {"sha": "17a35f331705d2bc29153213fc9f77cca9034dd3", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -49,14 +49,15 @@ use std::kinds::marker;\n use std::sync::arc::UnsafeArc;\n use std::task;\n \n-/// As sync::condvar, a mechanism for unlock-and-descheduling and signaling.\n-pub struct Condvar<'a> {\n+/// As sync::condvar, a mechanism for unlock-and-descheduling and\n+/// signaling, for use with the Arc types.\n+pub struct ArcCondvar<'a> {\n     priv is_mutex: bool,\n     priv failed: &'a bool,\n     priv cond: &'a sync::Condvar<'a>\n }\n \n-impl<'a> Condvar<'a> {\n+impl<'a> ArcCondvar<'a> {\n     /// Atomically exit the associated Arc and block until a signal is sent.\n     #[inline]\n     pub fn wait(&self) { self.wait_on(0) }\n@@ -219,14 +220,14 @@ impl<T:Send> MutexArc<T> {\n \n     /// As access(), but with a condvar, as sync::mutex.lock_cond().\n     #[inline]\n-    pub fn access_cond<U>(&self, blk: |x: &mut T, c: &Condvar| -> U) -> U {\n+    pub fn access_cond<U>(&self, blk: |x: &mut T, c: &ArcCondvar| -> U) -> U {\n         let state = self.x.get();\n         unsafe {\n             (&(*state).lock).lock_cond(|cond| {\n                 check_poison(true, (*state).failed);\n                 let _z = PoisonOnFail::new(&mut (*state).failed);\n                 blk(&mut (*state).data,\n-                    &Condvar {is_mutex: true,\n+                    &ArcCondvar {is_mutex: true,\n                             failed: &(*state).failed,\n                             cond: cond })\n             })\n@@ -345,15 +346,15 @@ impl<T:Freeze + Send> RWArc<T> {\n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n     #[inline]\n     pub fn write_cond<U>(&self,\n-                         blk: |x: &mut T, c: &Condvar| -> U)\n+                         blk: |x: &mut T, c: &ArcCondvar| -> U)\n                          -> U {\n         unsafe {\n             let state = self.x.get();\n             (*borrow_rwlock(state)).write_cond(|cond| {\n                 check_poison(false, (*state).failed);\n                 let _z = PoisonOnFail::new(&mut (*state).failed);\n                 blk(&mut (*state).data,\n-                    &Condvar {is_mutex: false,\n+                    &ArcCondvar {is_mutex: false,\n                               failed: &(*state).failed,\n                               cond: cond})\n             })\n@@ -481,7 +482,7 @@ impl<'a, T:Freeze + Send> RWWriteMode<'a, T> {\n \n     /// Access the pre-downgrade RWArc in write mode with a condvar.\n     pub fn write_cond<U>(&mut self,\n-                         blk: |x: &mut T, c: &Condvar| -> U)\n+                         blk: |x: &mut T, c: &ArcCondvar| -> U)\n                          -> U {\n         match *self {\n             RWWriteMode {\n@@ -491,7 +492,7 @@ impl<'a, T:Freeze + Send> RWWriteMode<'a, T> {\n             } => {\n                 token.write_cond(|cond| {\n                     unsafe {\n-                        let cvar = Condvar {\n+                        let cvar = ArcCondvar {\n                             is_mutex: false,\n                             failed: &*poison.flag,\n                             cond: cond\n@@ -915,7 +916,7 @@ mod tests {\n         // rwarc gives us extra shared state to help check for the race.\n         // If you want to see this test fail, go to sync.rs and replace the\n         // line in RWLock::write_cond() that looks like:\n-        //     \"blk(&Condvar { order: opt_lock, ..*cond })\"\n+        //     \"blk(&ArcCondvar { order: opt_lock, ..*cond })\"\n         // with just \"blk(cond)\".\n         let x = RWArc::new(true);\n         let (wp, wc) = Chan::new();"}, {"sha": "80abcce0df35024736b5886c60893330c582a271", "filename": "src/libsync/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibsync%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibsync%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flib.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -17,7 +17,7 @@\n #[crate_type = \"dylib\"];\n #[license = \"MIT/ASL2\"];\n \n-pub use arc::{Arc, MutexArc, RWArc, RWWriteMode, RWReadMode, Condvar, CowArc};\n+pub use arc::{Arc, MutexArc, RWArc, RWWriteMode, RWReadMode, ArcCondvar, CowArc};\n pub use sync::{Mutex, RWLock, Condvar, Semaphore, RWLockWriteMode,\n     RWLockReadMode, Barrier, one, mutex};\n pub use comm::{DuplexStream, SyncChan, SyncPort, rendezvous};"}, {"sha": "861cd8ae7d301160886fb105da80acbd15b196d5", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -48,7 +48,7 @@ pub enum Architecture {\n static IntelBits: u32 = (1 << (X86 as uint)) | (1 << (X86_64 as uint));\n static ArmBits: u32 = (1 << (Arm as uint));\n \n-struct AbiData {\n+pub struct AbiData {\n     abi: Abi,\n \n     // Name of this ABI as we like it called.\n@@ -59,7 +59,7 @@ struct AbiData {\n     abi_arch: AbiArchitecture\n }\n \n-enum AbiArchitecture {\n+pub enum AbiArchitecture {\n     RustArch,   // Not a real ABI (e.g., intrinsic)\n     AllArch,    // An ABI that specifies cross-platform defaults (e.g., \"C\")\n     Archs(u32)  // Multiple architectures (bitset)"}, {"sha": "260375b5f81d619c77da339e3108acc99d2f8fca", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -31,6 +31,7 @@ This API is completely unstable and subject to change.\n #[feature(quote)];\n \n #[deny(non_camel_case_types)];\n+#[allow(visible_private_types)];\n \n extern crate serialize;\n extern crate term;"}, {"sha": "39989977d69faa5e213ced72beeffd4666f24566", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -193,9 +193,11 @@ fn walk_explicit_self<E: Clone, V: Visitor<E>>(visitor: &mut V,\n     }\n }\n \n-fn walk_trait_ref<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                           trait_ref: &TraitRef,\n-                                           env: E) {\n+/// Like with walk_method_helper this doesn't correspond to a method\n+/// in Visitor, and so it gets a _helper suffix.\n+pub fn walk_trait_ref_helper<E: Clone, V: Visitor<E>>(visitor: &mut V,\n+                                                      trait_ref: &TraitRef,\n+                                                      env: E) {\n     visitor.visit_path(&trait_ref.path, trait_ref.ref_id, env)\n }\n \n@@ -239,7 +241,8 @@ pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E)\n                  ref methods) => {\n             visitor.visit_generics(type_parameters, env.clone());\n             match *trait_reference {\n-                Some(ref trait_reference) => walk_trait_ref(visitor, trait_reference, env.clone()),\n+                Some(ref trait_reference) => walk_trait_ref_helper(visitor,\n+                                                                   trait_reference, env.clone()),\n                 None => ()\n             }\n             visitor.visit_ty(typ, env.clone());\n@@ -459,7 +462,7 @@ pub fn walk_ty_param_bounds<E: Clone, V: Visitor<E>>(visitor: &mut V,\n     for bound in bounds.iter() {\n         match *bound {\n             TraitTyParamBound(ref typ) => {\n-                walk_trait_ref(visitor, typ, env.clone())\n+                walk_trait_ref_helper(visitor, typ, env.clone())\n             }\n             RegionTyParamBound => {}\n         }"}, {"sha": "629a203fcbb6c8d30b7323c73ce292f945036fdc", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -11,6 +11,7 @@\n #[no_std];\n #[allow(unused_variable)];\n #[allow(non_camel_case_types)];\n+#[allow(visible_private_types)];\n #[deny(dead_code)];\n \n #[crate_type=\"lib\"];"}, {"sha": "6d77f8b324c524a6f4d27ba51afb8961f894d382", "filename": "src/test/compile-fail/lint-visible-private-types.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e51e8d926625187226e2e37381b9ea671e18a48/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs?ref=2e51e8d926625187226e2e37381b9ea671e18a48", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(struct_variant)];\n+#[deny(visible_private_types)];\n+#[allow(dead_code)];\n+#[crate_type=\"lib\"];\n+\n+struct Private<T>;\n+pub struct Public<T>;\n+\n+impl Private<Public<int>> {\n+    pub fn a(&self) -> Private<int> { fail!() }\n+    fn b(&self) -> Private<int> { fail!() }\n+\n+    pub fn c() -> Private<int> { fail!() }\n+    fn d() -> Private<int> { fail!() }\n+}\n+impl Private<int> {\n+    pub fn e(&self) -> Private<int> { fail!() }\n+    fn f(&self) -> Private<int> { fail!() }\n+}\n+\n+impl Public<Private<int>> {\n+    pub fn a(&self) -> Private<int> { fail!() }\n+    fn b(&self) -> Private<int> { fail!() }\n+\n+    pub fn c() -> Private<int> { fail!() } //~ ERROR private type in exported type signature\n+    fn d() -> Private<int> { fail!() }\n+}\n+impl Public<int> {\n+    pub fn e(&self) -> Private<int> { fail!() } //~ ERROR private type in exported type signature\n+    fn f(&self) -> Private<int> { fail!() }\n+}\n+\n+pub fn x(_: Private<int>) {} //~ ERROR private type in exported type signature\n+\n+fn y(_: Private<int>) {}\n+\n+\n+pub struct Foo {\n+    x: Private<int>, //~ ERROR private type in exported type signature\n+    priv y: Private<int>\n+}\n+\n+struct Bar {\n+    x: Private<int>,\n+}\n+\n+pub enum Baz {\n+    Baz1(Private<int>), //~ ERROR private type in exported type signature\n+    Baz2 {\n+        x: Private<int>, //~ ERROR private type in exported type signature\n+        priv y: Private<int>\n+    },\n+\n+    priv Baz3(Private<int>),\n+    priv Baz4 {\n+        x: Private<int>,\n+    }\n+}\n+\n+enum Qux {\n+    Qux1(Private<int>),\n+    Qux2 {\n+        x: Private<int>,\n+    }\n+}\n+\n+pub trait PubTrait {\n+    fn foo(&self) -> Private<int> { fail!( )} //~ ERROR private type in exported type signature\n+    fn bar(&self) -> Private<int>; //~ ERROR private type in exported type signature\n+    fn baz() -> Private<int>; //~ ERROR private type in exported type signature\n+}\n+\n+impl PubTrait for Public<int> {\n+    fn bar(&self) -> Private<int> { fail!() }\n+    fn baz() -> Private<int> { fail!() }\n+}\n+impl PubTrait for Public<Private<int>> {\n+    fn bar(&self) -> Private<int> { fail!() }\n+    fn baz() -> Private<int> { fail!() }\n+}\n+\n+impl PubTrait for Private<int> {\n+    fn bar(&self) -> Private<int> { fail!() }\n+    fn baz() -> Private<int> { fail!() }\n+}\n+impl PubTrait for (Private<int>,) {\n+    fn bar(&self) -> Private<int> { fail!() }\n+    fn baz() -> Private<int> { fail!() }\n+}\n+\n+\n+trait PrivTrait {\n+    fn foo(&self) -> Private<int> { fail!( )}\n+    fn bar(&self) -> Private<int>;\n+}\n+impl PrivTrait for Private<int> {\n+    fn bar(&self) -> Private<int> { fail!() }\n+}\n+impl PrivTrait for (Private<int>,) {\n+    fn bar(&self) -> Private<int> { fail!() }\n+}\n+\n+pub trait ParamTrait<T> {\n+    fn foo() -> T;\n+}\n+\n+impl ParamTrait<Private<int>> //~ ERROR private type in exported type signature\n+   for Public<int> {\n+    fn foo() -> Private<int> { fail!() }\n+}\n+\n+impl ParamTrait<Private<int>> for Private<int> {\n+    fn foo() -> Private<int> { fail!( )}\n+}\n+\n+impl<T: ParamTrait<Private<int>>>  //~ ERROR private type in exported type signature\n+     ParamTrait<T> for Public<i8> {\n+    fn foo() -> T { fail!() }\n+}"}]}