{"sha": "702fe5cdac4f6852689c1e74c3ca95af249f4285", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMmZlNWNkYWM0ZjY4NTI2ODljMWU3NGMzY2E5NWFmMjQ5ZjQyODU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-17T20:58:49Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-17T20:58:49Z"}, "message": "rustc: Run obstack cleanups at the end of each function", "tree": {"sha": "d38b9e25223ec567658019bc1fe1ad832f3b5460", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d38b9e25223ec567658019bc1fe1ad832f3b5460"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/702fe5cdac4f6852689c1e74c3ca95af249f4285", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/702fe5cdac4f6852689c1e74c3ca95af249f4285", "html_url": "https://github.com/rust-lang/rust/commit/702fe5cdac4f6852689c1e74c3ca95af249f4285", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/702fe5cdac4f6852689c1e74c3ca95af249f4285/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3aab46b0209adad0fd6f24b5b94b6401b13257b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3aab46b0209adad0fd6f24b5b94b6401b13257b7", "html_url": "https://github.com/rust-lang/rust/commit/3aab46b0209adad0fd6f24b5b94b6401b13257b7"}], "stats": {"total": 41, "additions": 33, "deletions": 8}, "files": [{"sha": "ff8464ccbf540d0f4c818018cbb7bc6f33790d17", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/702fe5cdac4f6852689c1e74c3ca95af249f4285/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/702fe5cdac4f6852689c1e74c3ca95af249f4285/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=702fe5cdac4f6852689c1e74c3ca95af249f4285", "patch": "@@ -466,15 +466,17 @@ fn alloca(cx: &@block_ctxt, t: TypeRef) -> ValueRef {\n }\n \n fn array_alloca(cx: &@block_ctxt, t: TypeRef, n: ValueRef) -> ValueRef {\n+    let builder = new_builder(cx.fcx.lldynamicallocas);\n     alt bcx_fcx(cx).llobstacktoken {\n         none. {\n+            let dynastack_mark = bcx_ccx(cx).upcalls.dynastack_mark;\n+            let lltaskptr = bcx_fcx(cx).lltaskptr;\n             bcx_fcx(cx).llobstacktoken =\n-                some(cx.build.Call(bcx_ccx(cx).upcalls.dynastack_mark,\n-                     ~[bcx_fcx(cx).lltaskptr]));\n+                some(builder.Call(dynastack_mark, ~[lltaskptr]));\n         }\n         some(_) { /* no-op */ }\n     }\n-    ret new_builder(cx.fcx.lldynamicallocas).ArrayAlloca(t, n);\n+    ret builder.ArrayAlloca(t, n);\n }\n \n \n@@ -1266,6 +1268,8 @@ fn make_copy_glue(cx: &@block_ctxt, v: ValueRef, t: &ty::t) {\n         bcx = duplicate_heap_parts_if_necessary(cx, v, t).bcx;\n         bcx = iter_structural_ty(bcx, v, t, bind copy_ty(_, _, _)).bcx;\n     } else { bcx = cx; }\n+\n+    trans_fn_cleanups(bcx);\n     bcx.build.RetVoid();\n }\n \n@@ -1371,7 +1375,9 @@ fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n           }\n           _ { rslt(cx, C_nil()) }\n         };\n-    rs.bcx.build.RetVoid();\n+\n+    let bcx = trans_fn_cleanups(rs.bcx);\n+    bcx.build.RetVoid();\n }\n \n fn maybe_free_ivec_heap_part(cx: &@block_ctxt, v0: ValueRef, unit_ty: ty::t)\n@@ -1439,7 +1445,9 @@ fn make_drop_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n             } else { rslt(cx, C_nil()) }\n           }\n         };\n-    rs.bcx.build.RetVoid();\n+\n+    let bcx = trans_fn_cleanups(rs.bcx);\n+    bcx.build.RetVoid();\n }\n \n fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n@@ -3719,7 +3727,8 @@ fn trans_for_each(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n \n     if !r.bcx.build.is_terminated() {\n         // if terminated is true, no need for the ret-fail\n-        r.bcx.build.RetVoid();\n+        let bcx = trans_fn_cleanups(r.bcx);\n+        bcx.build.RetVoid();\n     }\n \n     // Step 3: Call iter passing [lliterbody, llenv], plus other args.\n@@ -5439,6 +5448,7 @@ fn trans_ret(cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n           parent_none. { more_cleanups = false; }\n         }\n     }\n+    bcx = trans_fn_cleanups(bcx);\n     bcx.build.RetVoid();\n     ret rslt(new_sub_block_ctxt(bcx, \"ret.unreachable\"), C_nil());\n }\n@@ -5600,6 +5610,18 @@ fn trans_block_cleanups(cx: &@block_ctxt, cleanup_cx: &@block_ctxt) ->\n     ret bcx;\n }\n \n+fn trans_fn_cleanups(bcx: &@block_ctxt) -> @block_ctxt {\n+    alt bcx_fcx(bcx).llobstacktoken {\n+        some(lltoken_) {\n+            let lltoken = lltoken_; // satisfy alias checker\n+            bcx.build.Call(bcx_ccx(bcx).upcalls.dynastack_free,\n+                           ~[bcx_fcx(bcx).lltaskptr, lltoken]);\n+        }\n+        none. { /* nothing to do */ }\n+    }\n+    ret bcx;\n+}\n+\n iter block_locals(b: &ast::blk) -> @ast::local {\n     // FIXME: putting from inside an iter block doesn't work, so we can't\n     // use the index here.\n@@ -6048,6 +6070,7 @@ fn trans_closure(bcx_maybe: &option::t<@block_ctxt>,\n     if !is_terminated(bcx) {\n         // FIXME: until LLVM has a unit type, we are moving around\n         // C_nil values rather than their void type.\n+        bcx = trans_fn_cleanups(bcx);\n         bcx.build.RetVoid();\n     }\n \n@@ -6204,6 +6227,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n         i += 1u;\n     }\n     bcx = trans_block_cleanups(bcx, find_scope_cx(bcx));\n+    bcx = trans_fn_cleanups(bcx);\n     bcx.build.RetVoid();\n     finish_fn(fcx, lltop);\n }"}, {"sha": "5ec996f4e32f3847a59f12ba5025f168bfe2b68e", "filename": "src/rt/rust_obstack.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/702fe5cdac4f6852689c1e74c3ca95af249f4285/src%2Frt%2Frust_obstack.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/702fe5cdac4f6852689c1e74c3ca95af249f4285/src%2Frt%2Frust_obstack.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_obstack.cpp?ref=702fe5cdac4f6852689c1e74c3ca95af249f4285", "patch": "@@ -44,7 +44,7 @@ rust_obstack_chunk::free(void *ptr) {\n     uint8_t *p = (uint8_t *)ptr;\n     if (p < data || p >= data + size)\n         return false;\n-    assert(p < data + alen);\n+    assert(p <= data + alen);\n     alen = (size_t)(p - data);\n     return true;\n }\n@@ -71,7 +71,8 @@ rust_obstack::alloc(size_t len) {\n     if (!chunk)\n         return alloc_new(len);\n     void *ptr = chunk->alloc(len);\n-    return ptr ? ptr : alloc_new(len);\n+    ptr = ptr ? ptr : alloc_new(len);\n+    return ptr;\n }\n \n void"}]}