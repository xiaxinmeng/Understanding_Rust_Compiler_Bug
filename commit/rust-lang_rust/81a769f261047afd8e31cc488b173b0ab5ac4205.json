{"sha": "81a769f261047afd8e31cc488b173b0ab5ac4205", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxYTc2OWYyNjEwNDdhZmQ4ZTMxY2M0ODhiMTczYjBhYjVhYzQyMDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-05T11:47:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-05T11:47:01Z"}, "message": "Auto merge of #75584 - RalfJung:union-no-deref, r=matthewjasper\n\ndo not apply DerefMut on union field\n\nThis implements the part of [RFC 2514](https://github.com/rust-lang/rfcs/blob/master/text/2514-union-initialization-and-drop.md) about `DerefMut`. Unlike described in the RFC, we only apply this warning specifically when doing `DerefMut` of a `ManuallyDrop` field; that is really the case we are worried about here.\n\n@matthewjasper suggested I patch `convert_place_derefs_to_mutable` and `convert_place_op_to_mutable` for this, but I could not find anything to do in `convert_place_op_to_mutable` and this is sufficient to make the test pass. However, maybe there are some other cases this misses? I have no familiarity with this code.\n\nThis is a breaking change *in theory*, if someone used `ManuallyDrop<T>` in a union field and relied on automatic `DerefMut`. But on stable this means `T: Copy`, so the `ManuallyDrop` is rather pointless.\n\nCc https://github.com/rust-lang/rust/issues/55149", "tree": {"sha": "3cebc2a8e902358abc77aa72c7ad2df2614b31d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cebc2a8e902358abc77aa72c7ad2df2614b31d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81a769f261047afd8e31cc488b173b0ab5ac4205", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81a769f261047afd8e31cc488b173b0ab5ac4205", "html_url": "https://github.com/rust-lang/rust/commit/81a769f261047afd8e31cc488b173b0ab5ac4205", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81a769f261047afd8e31cc488b173b0ab5ac4205/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02fe30971ef397bcff3460a9aaf175e0810c2c90", "url": "https://api.github.com/repos/rust-lang/rust/commits/02fe30971ef397bcff3460a9aaf175e0810c2c90", "html_url": "https://github.com/rust-lang/rust/commit/02fe30971ef397bcff3460a9aaf175e0810c2c90"}, {"sha": "66b340f5003910bd8b46f6675cd9a491809aa9fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/66b340f5003910bd8b46f6675cd9a491809aa9fe", "html_url": "https://github.com/rust-lang/rust/commit/66b340f5003910bd8b46f6675cd9a491809aa9fe"}], "stats": {"total": 111, "additions": 109, "deletions": 2}, "files": [{"sha": "aed2af20e5271f192dea23e913402bb52bc9c3f2", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/81a769f261047afd8e31cc488b173b0ab5ac4205/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a769f261047afd8e31cc488b173b0ab5ac4205/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=81a769f261047afd8e31cc488b173b0ab5ac4205", "patch": "@@ -193,7 +193,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Convert auto-derefs, indices, etc of an expression from `Deref` and `Index`\n     /// into `DerefMut` and `IndexMut` respectively.\n     ///\n-    /// This is a second pass of typechecking derefs/indices. We need this we do not\n+    /// This is a second pass of typechecking derefs/indices. We need this because we do not\n     /// always know whether a place needs to be mutable or not in the first pass.\n     /// This happens whether there is an implicit mutable reborrow, e.g. when the type\n     /// is used as the receiver of a method call.\n@@ -211,13 +211,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n \n         // Fix up autoderefs and derefs.\n+        let mut inside_union = false;\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n             debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n \n+            let mut source = self.node_ty(expr.hir_id);\n+            if matches!(expr.kind, hir::ExprKind::Unary(hir::UnOp::UnDeref, _)) {\n+                // Clear previous flag; after a pointer indirection it does not apply any more.\n+                inside_union = false;\n+            }\n+            if source.ty_adt_def().map_or(false, |adt| adt.is_union()) {\n+                inside_union = true;\n+            }\n             // Fix up the autoderefs. Autorefs can only occur immediately preceding\n             // overloaded place ops, and will be fixed by them in order to get\n             // the correct region.\n-            let mut source = self.node_ty(expr.hir_id);\n             // Do not mutate adjustments in place, but rather take them,\n             // and replace them after mutating them, to avoid having the\n             // typeck results borrowed during (`deref_mut`) method resolution.\n@@ -236,6 +244,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             if let ty::Ref(region, _, mutbl) = *method.sig.output().kind() {\n                                 *deref = OverloadedDeref { region, mutbl };\n                             }\n+                            // If this is a union field, also throw an error for `DerefMut` of `ManuallyDrop` (see RFC 2514).\n+                            // This helps avoid accidental drops.\n+                            if inside_union\n+                                && source.ty_adt_def().map_or(false, |adt| adt.is_manually_drop())\n+                            {\n+                                let mut err = self.tcx.sess.struct_span_err(\n+                                    expr.span,\n+                                    \"not automatically applying `DerefMut` on `ManuallyDrop` union field\",\n+                                );\n+                                err.help(\n+                                    \"writing to this reference calls the destructor for the old value\",\n+                                );\n+                                err.help(\"add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\");\n+                                err.emit();\n+                            }\n                         }\n                     }\n                     source = adjustment.target;"}, {"sha": "df598eea9ef0f7a138a9da4dfbe1dd1e5565e77f", "filename": "src/test/ui/union/union-deref.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/81a769f261047afd8e31cc488b173b0ab5ac4205/src%2Ftest%2Fui%2Funion%2Funion-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81a769f261047afd8e31cc488b173b0ab5ac4205/src%2Ftest%2Fui%2Funion%2Funion-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-deref.rs?ref=81a769f261047afd8e31cc488b173b0ab5ac4205", "patch": "@@ -0,0 +1,28 @@\n+// ignore-tidy-linelength\n+//! Test the part of RFC 2514 that is about not applying `DerefMut` coercions\n+//! of union fields.\n+#![feature(untagged_unions)]\n+\n+use std::mem::ManuallyDrop;\n+\n+union U1<T> { x:(), f: ManuallyDrop<(T,)> }\n+\n+union U2<T> { x:(), f: (ManuallyDrop<(T,)>,) }\n+\n+fn main() {\n+    let mut u : U1<Vec<i32>> = U1 { x: () };\n+    unsafe { (*u.f).0 = Vec::new() }; // explicit deref, this compiles\n+    unsafe { u.f.0 = Vec::new() }; //~ERROR not automatically applying `DerefMut` on `ManuallyDrop` union field\n+    unsafe { &mut (*u.f).0 }; // explicit deref, this compiles\n+    unsafe { &mut u.f.0 }; //~ERROR not automatically applying `DerefMut` on `ManuallyDrop` union field\n+    unsafe { (*u.f).0.push(0) }; // explicit deref, this compiles\n+    unsafe { u.f.0.push(0) }; //~ERROR not automatically applying `DerefMut` on `ManuallyDrop` union field\n+\n+    let mut u : U2<Vec<i32>> = U2 { x: () };\n+    unsafe { (*u.f.0).0 = Vec::new() }; // explicit deref, this compiles\n+    unsafe { u.f.0.0 = Vec::new() }; //~ERROR not automatically applying `DerefMut` on `ManuallyDrop` union field\n+    unsafe { &mut (*u.f.0).0 }; // explicit deref, this compiles\n+    unsafe { &mut u.f.0.0 }; //~ERROR not automatically applying `DerefMut` on `ManuallyDrop` union field\n+    unsafe { (*u.f.0).0.push(0) }; // explicit deref, this compiles\n+    unsafe { u.f.0.0.push(0) }; //~ERROR not automatically applying `DerefMut` on `ManuallyDrop` union field\n+}"}, {"sha": "fb16649767fb73c974969c1420f77b62bd3a45ba", "filename": "src/test/ui/union/union-deref.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/81a769f261047afd8e31cc488b173b0ab5ac4205/src%2Ftest%2Fui%2Funion%2Funion-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/81a769f261047afd8e31cc488b173b0ab5ac4205/src%2Ftest%2Fui%2Funion%2Funion-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-deref.stderr?ref=81a769f261047afd8e31cc488b173b0ab5ac4205", "patch": "@@ -0,0 +1,56 @@\n+error: not automatically applying `DerefMut` on `ManuallyDrop` union field\n+  --> $DIR/union-deref.rs:15:14\n+   |\n+LL |     unsafe { u.f.0 = Vec::new() };\n+   |              ^^^\n+   |\n+   = help: writing to this reference calls the destructor for the old value\n+   = help: add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\n+\n+error: not automatically applying `DerefMut` on `ManuallyDrop` union field\n+  --> $DIR/union-deref.rs:17:19\n+   |\n+LL |     unsafe { &mut u.f.0 };\n+   |                   ^^^\n+   |\n+   = help: writing to this reference calls the destructor for the old value\n+   = help: add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\n+\n+error: not automatically applying `DerefMut` on `ManuallyDrop` union field\n+  --> $DIR/union-deref.rs:19:14\n+   |\n+LL |     unsafe { u.f.0.push(0) };\n+   |              ^^^\n+   |\n+   = help: writing to this reference calls the destructor for the old value\n+   = help: add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\n+\n+error: not automatically applying `DerefMut` on `ManuallyDrop` union field\n+  --> $DIR/union-deref.rs:23:14\n+   |\n+LL |     unsafe { u.f.0.0 = Vec::new() };\n+   |              ^^^^^^^\n+   |\n+   = help: writing to this reference calls the destructor for the old value\n+   = help: add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\n+\n+error: not automatically applying `DerefMut` on `ManuallyDrop` union field\n+  --> $DIR/union-deref.rs:25:19\n+   |\n+LL |     unsafe { &mut u.f.0.0 };\n+   |                   ^^^^^^^\n+   |\n+   = help: writing to this reference calls the destructor for the old value\n+   = help: add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\n+\n+error: not automatically applying `DerefMut` on `ManuallyDrop` union field\n+  --> $DIR/union-deref.rs:27:14\n+   |\n+LL |     unsafe { u.f.0.0.push(0) };\n+   |              ^^^^^^^\n+   |\n+   = help: writing to this reference calls the destructor for the old value\n+   = help: add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\n+\n+error: aborting due to 6 previous errors\n+"}]}