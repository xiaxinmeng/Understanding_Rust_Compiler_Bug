{"sha": "9b40e1e5b3d75c101b1ad78a1e2160962e955174", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNDBlMWU1YjNkNzVjMTAxYjFhZDc4YTFlMjE2MDk2MmU5NTUxNzQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-02-14T12:25:12Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-02-14T12:25:12Z"}, "message": "Rename hir::Pat_ and its variants", "tree": {"sha": "54bf2547c70734f478918cfe5277484a71eb25bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54bf2547c70734f478918cfe5277484a71eb25bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b40e1e5b3d75c101b1ad78a1e2160962e955174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b40e1e5b3d75c101b1ad78a1e2160962e955174", "html_url": "https://github.com/rust-lang/rust/commit/9b40e1e5b3d75c101b1ad78a1e2160962e955174", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b40e1e5b3d75c101b1ad78a1e2160962e955174/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86e6e3235ee0df25ce41dcb48a08387125d31d35", "url": "https://api.github.com/repos/rust-lang/rust/commits/86e6e3235ee0df25ce41dcb48a08387125d31d35", "html_url": "https://github.com/rust-lang/rust/commit/86e6e3235ee0df25ce41dcb48a08387125d31d35"}], "stats": {"total": 680, "additions": 339, "deletions": 341}, "files": [{"sha": "3c4f682ad952386139cc7ed44abd321e76c6977d", "filename": "src/librustc/front/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -262,7 +262,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n     fn visit_pat(&mut self, pat: &'ast Pat) {\n         let maybe_binding = match pat.node {\n-            PatIdent(_, id, _) => Some(id.node),\n+            PatKind::Ident(_, id, _) => Some(id.node),\n             _ => None\n         };\n "}, {"sha": "53a311f95dae34a10f4ee484e6a396b666e14905", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -615,7 +615,7 @@ impl<'ast> Map<'ast> {\n             NodeVariant(v) => PathName(v.node.name),\n             NodeLifetime(lt) => PathName(lt.name),\n             NodeTyParam(tp) => PathName(tp.name),\n-            NodeLocal(&Pat { node: PatIdent(_,l,_), .. }) => {\n+            NodeLocal(&Pat { node: PatKind::Ident(_,l,_), .. }) => {\n                 PathName(l.node.name)\n             },\n             _ => panic!(\"no path elem for {:?}\", node)"}, {"sha": "feefda741432c28cb8f41c5bd087455d1d5eaae9", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -16,7 +16,7 @@ use middle::ty;\n use syntax::ast;\n use syntax::ptr::P;\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n@@ -99,35 +99,35 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n-            hir::PatIdent(_, _, None) |\n-            hir::PatEnum(_, None) |\n-            hir::PatQPath(..) |\n-            hir::PatLit(..) |\n-            hir::PatRange(..) |\n-            hir::PatWild => {\n+            PatKind::Ident(_, _, None) |\n+            PatKind::Enum(_, None) |\n+            PatKind::QPath(..) |\n+            PatKind::Lit(..) |\n+            PatKind::Range(..) |\n+            PatKind::Wild => {\n                 self.add_ast_node(pat.id, &[pred])\n             }\n \n-            hir::PatBox(ref subpat) |\n-            hir::PatRegion(ref subpat, _) |\n-            hir::PatIdent(_, _, Some(ref subpat)) => {\n+            PatKind::Box(ref subpat) |\n+            PatKind::Ref(ref subpat, _) |\n+            PatKind::Ident(_, _, Some(ref subpat)) => {\n                 let subpat_exit = self.pat(&subpat, pred);\n                 self.add_ast_node(pat.id, &[subpat_exit])\n             }\n \n-            hir::PatEnum(_, Some(ref subpats)) |\n-            hir::PatTup(ref subpats) => {\n+            PatKind::Enum(_, Some(ref subpats)) |\n+            PatKind::Tup(ref subpats) => {\n                 let pats_exit = self.pats_all(subpats.iter(), pred);\n                 self.add_ast_node(pat.id, &[pats_exit])\n             }\n \n-            hir::PatStruct(_, ref subpats, _) => {\n+            PatKind::Struct(_, ref subpats, _) => {\n                 let pats_exit =\n                     self.pats_all(subpats.iter().map(|f| &f.node.pat), pred);\n                 self.add_ast_node(pat.id, &[pats_exit])\n             }\n \n-            hir::PatVec(ref pre, ref vec, ref post) => {\n+            PatKind::Vec(ref pre, ref vec, ref post) => {\n                 let pre_exit = self.pats_all(pre.iter(), pred);\n                 let vec_exit = self.pats_all(vec.iter(), pre_exit);\n                 let post_exit = self.pats_all(post.iter(), vec_exit);"}, {"sha": "3a269e9946fdb282d2730c55a1cbf90c9178848c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -32,7 +32,7 @@ use std::fmt;\n use std::iter::{FromIterator, IntoIterator, repeat};\n \n use rustc_front::hir;\n-use rustc_front::hir::Pat;\n+use rustc_front::hir::{Pat, PatKind};\n use rustc_front::intravisit::{self, Visitor, FnKind};\n use rustc_front::util as front_util;\n use rustc_back::slice;\n@@ -47,7 +47,7 @@ use util::nodemap::FnvHashMap;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n-    node: hir::PatWild,\n+    node: PatKind::Wild,\n     span: DUMMY_SP\n };\n \n@@ -242,7 +242,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat) {\n     front_util::walk_pat(pat, |p| {\n         match p.node {\n-            hir::PatIdent(hir::BindByValue(hir::MutImmutable), ident, None) => {\n+            PatKind::Ident(hir::BindByValue(hir::MutImmutable), ident, None) => {\n                 let pat_ty = cx.tcx.pat_ty(p);\n                 if let ty::TyEnum(edef, _) = pat_ty.sty {\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n@@ -274,7 +274,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n // Check that we do not match against a static NaN (#6804)\n fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n     front_util::walk_pat(pat, |p| {\n-        if let hir::PatLit(ref expr) = p.node {\n+        if let PatKind::Lit(ref expr) = p.node {\n             match eval_const_expr_partial(cx.tcx, &expr, ExprTypeChecked, None) {\n                 Ok(ConstVal::Float(f)) if f.is_nan() => {\n                     span_warn!(cx.tcx.sess, p.span, E0003,\n@@ -360,7 +360,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n \n fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n     match p.node {\n-        hir::PatIdent(_, _, Some(ref s)) => raw_pat(&s),\n+        PatKind::Ident(_, _, Some(ref s)) => raw_pat(&s),\n         _ => p\n     }\n }\n@@ -377,7 +377,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir:\n                 hir::MatchSource::ForLoopDesugar => {\n                     // `witnesses[0]` has the form `Some(<head>)`, peel off the `Some`\n                     let witness = match witnesses[0].node {\n-                        hir::PatEnum(_, Some(ref pats)) => match &pats[..] {\n+                        PatKind::Enum(_, Some(ref pats)) => match &pats[..] {\n                             [ref pat] => &**pat,\n                             _ => unreachable!(),\n                         },\n@@ -466,7 +466,7 @@ impl<'map> ast_util::IdVisitingOperation for RenamingRecorder<'map> {\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n-            hir::PatIdent(..) | hir::PatEnum(..) | hir::PatQPath(..) => {\n+            PatKind::Ident(..) | PatKind::Enum(..) | PatKind::QPath(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n                     Some(Def::AssociatedConst(did)) |\n@@ -530,14 +530,14 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     let pats_len = pats.len();\n     let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n     let pat = match left_ty.sty {\n-        ty::TyTuple(_) => hir::PatTup(pats.collect()),\n+        ty::TyTuple(_) => PatKind::Tup(pats.collect()),\n \n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n             let v = adt.variant_of_ctor(ctor);\n             if let VariantKind::Struct = v.kind() {\n                 let field_pats: hir::HirVec<_> = v.fields.iter()\n                     .zip(pats)\n-                    .filter(|&(_, ref pat)| pat.node != hir::PatWild)\n+                    .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n                     .map(|(field, pat)| Spanned {\n                         span: DUMMY_SP,\n                         node: hir::FieldPat {\n@@ -547,9 +547,9 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                         }\n                     }).collect();\n                 let has_more_fields = field_pats.len() < pats_len;\n-                hir::PatStruct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n+                PatKind::Struct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n             } else {\n-                hir::PatEnum(def_to_path(cx.tcx, v.did), Some(pats.collect()))\n+                PatKind::Enum(def_to_path(cx.tcx, v.did), Some(pats.collect()))\n             }\n         }\n \n@@ -558,35 +558,35 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                ty::TyArray(_, n) => match ctor {\n                     &Single => {\n                         assert_eq!(pats_len, n);\n-                        hir::PatVec(pats.collect(), None, hir::HirVec::new())\n+                        PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n                     },\n                     _ => unreachable!()\n                 },\n                 ty::TySlice(_) => match ctor {\n                     &Slice(n) => {\n                         assert_eq!(pats_len, n);\n-                        hir::PatVec(pats.collect(), None, hir::HirVec::new())\n+                        PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n                     },\n                     _ => unreachable!()\n                 },\n-                ty::TyStr => hir::PatWild,\n+                ty::TyStr => PatKind::Wild,\n \n                 _ => {\n                     assert_eq!(pats_len, 1);\n-                    hir::PatRegion(pats.nth(0).unwrap(), mutbl)\n+                    PatKind::Ref(pats.nth(0).unwrap(), mutbl)\n                 }\n             }\n         }\n \n         ty::TyArray(_, len) => {\n             assert_eq!(pats_len, len);\n-            hir::PatVec(pats.collect(), None, hir::HirVec::new())\n+            PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n         }\n \n         _ => {\n             match *ctor {\n-                ConstantValue(ref v) => hir::PatLit(const_val_to_expr(v)),\n-                _ => hir::PatWild,\n+                ConstantValue(ref v) => PatKind::Lit(const_val_to_expr(v)),\n+                _ => PatKind::Wild,\n             }\n         }\n     };\n@@ -682,15 +682,15 @@ fn is_useful(cx: &MatchCheckCtxt,\n         let left_ty = cx.tcx.pat_ty(&real_pat);\n \n         match real_pat.node {\n-            hir::PatIdent(hir::BindByRef(..), _, _) => {\n+            PatKind::Ident(hir::BindByRef(..), _, _) => {\n                 left_ty.builtin_deref(false, NoPreference).unwrap().ty\n             }\n             _ => left_ty,\n         }\n     };\n \n     let max_slice_length = rows.iter().filter_map(|row| match row[0].node {\n-        hir::PatVec(ref before, _, ref after) => Some(before.len() + after.len()),\n+        PatKind::Vec(ref before, _, ref after) => Some(before.len() + after.len()),\n         _ => None\n     }).max().map_or(0, |v| v + 1);\n \n@@ -769,7 +769,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n-        hir::PatIdent(..) =>\n+        PatKind::Ident(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n@@ -778,30 +778,30 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                 Some(Def::Variant(_, id)) => vec!(Variant(id)),\n                 _ => vec!()\n             },\n-        hir::PatEnum(..) =>\n+        PatKind::Enum(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(Def::Variant(_, id)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n-        hir::PatQPath(..) =>\n+        PatKind::QPath(..) =>\n             cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                             been rewritten\"),\n-        hir::PatStruct(..) =>\n+        PatKind::Struct(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(Def::Variant(_, id)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n-        hir::PatLit(ref expr) =>\n+        PatKind::Lit(ref expr) =>\n             vec!(ConstantValue(eval_const_expr(cx.tcx, &expr))),\n-        hir::PatRange(ref lo, ref hi) =>\n+        PatKind::Range(ref lo, ref hi) =>\n             vec!(ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))),\n-        hir::PatVec(ref before, ref slice, ref after) =>\n+        PatKind::Vec(ref before, ref slice, ref after) =>\n             match left_ty.sty {\n                 ty::TyArray(_, _) => vec!(Single),\n                 _                      => if slice.is_some() {\n@@ -812,9 +812,9 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     vec!(Slice(before.len() + after.len()))\n                 }\n             },\n-        hir::PatBox(_) | hir::PatTup(_) | hir::PatRegion(..) =>\n+        PatKind::Box(_) | PatKind::Tup(_) | PatKind::Ref(..) =>\n             vec!(Single),\n-        hir::PatWild =>\n+        PatKind::Wild =>\n             vec!(),\n     }\n }\n@@ -877,10 +877,10 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         id: pat_id, ref node, span: pat_span\n     } = raw_pat(r[col]);\n     let head: Option<Vec<&Pat>> = match *node {\n-        hir::PatWild =>\n+        PatKind::Wild =>\n             Some(vec![DUMMY_WILD_PAT; arity]),\n \n-        hir::PatIdent(_, _, _) => {\n+        PatKind::Ident(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().get(&pat_id).map(|d| d.full_def());\n             match opt_def {\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n@@ -895,7 +895,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        hir::PatEnum(_, ref args) => {\n+        PatKind::Enum(_, ref args) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n@@ -912,12 +912,12 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        hir::PatQPath(_, _) => {\n+        PatKind::QPath(_, _) => {\n             cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                             been rewritten\")\n         }\n \n-        hir::PatStruct(_, ref pattern_fields, _) => {\n+        PatKind::Struct(_, ref pattern_fields, _) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n             let variant = adt.variant_of_ctor(constructor);\n@@ -934,13 +934,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        hir::PatTup(ref args) =>\n+        PatKind::Tup(ref args) =>\n             Some(args.iter().map(|p| &**p).collect()),\n \n-        hir::PatBox(ref inner) | hir::PatRegion(ref inner, _) =>\n+        PatKind::Box(ref inner) | PatKind::Ref(ref inner, _) =>\n             Some(vec![&**inner]),\n \n-        hir::PatLit(ref expr) => {\n+        PatKind::Lit(ref expr) => {\n             let expr_value = eval_const_expr(cx.tcx, &expr);\n             match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n                 Some(true) => Some(vec![]),\n@@ -952,7 +952,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        hir::PatRange(ref from, ref to) => {\n+        PatKind::Range(ref from, ref to) => {\n             let from_value = eval_const_expr(cx.tcx, &from);\n             let to_value = eval_const_expr(cx.tcx, &to);\n             match range_covered_by_constructor(constructor, &from_value, &to_value) {\n@@ -965,7 +965,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        hir::PatVec(ref before, ref slice, ref after) => {\n+        PatKind::Vec(ref before, ref slice, ref after) => {\n             match *constructor {\n                 // Fixed-length vectors.\n                 Single => {\n@@ -1104,7 +1104,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         front_util::walk_pat(&pat, |p| {\n             if pat_is_binding(&def_map.borrow(), &p) {\n                 match p.node {\n-                    hir::PatIdent(hir::BindByValue(_), _, ref sub) => {\n+                    PatKind::Ident(hir::BindByValue(_), _, ref sub) => {\n                         let pat_ty = tcx.node_id_to_type(p.id);\n                         //FIXME: (@jroesch) this code should be floated up as well\n                         let infcx = infer::new_infer_ctxt(cx.tcx,\n@@ -1114,7 +1114,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n                     }\n-                    hir::PatIdent(hir::BindByRef(_), _, _) => {\n+                    PatKind::Ident(hir::BindByRef(_), _, _) => {\n                     }\n                     _ => {\n                         cx.tcx.sess.span_bug(\n@@ -1202,7 +1202,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n         }\n \n         match pat.node {\n-            hir::PatIdent(_, _, Some(_)) => {\n+            PatKind::Ident(_, _, Some(_)) => {\n                 let bindings_were_allowed = self.bindings_allowed;\n                 self.bindings_allowed = false;\n                 intravisit::walk_pat(self, pat);"}, {"sha": "a347bfc9b48c829829811073ffa5843fe60f0408", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -30,7 +30,7 @@ use session::Session;\n \n use graphviz::IntoCow;\n use syntax::ast;\n-use rustc_front::hir::Expr;\n+use rustc_front::hir::{Expr, PatKind};\n use rustc_front::hir;\n use rustc_front::intravisit::FnKind;\n use syntax::codemap::Span;\n@@ -325,7 +325,7 @@ impl ConstVal {\n pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n     let pat = match expr.node {\n         hir::ExprTup(ref exprs) =>\n-            hir::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect()),\n+            PatKind::Tup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect()),\n \n         hir::ExprCall(ref callee, ref args) => {\n             let def = *tcx.def_map.borrow().get(&callee.id).unwrap();\n@@ -337,13 +337,13 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n                 Def::Variant(_, variant_did) => def_to_path(tcx, variant_did),\n                 Def::Fn(..) => return P(hir::Pat {\n                     id: expr.id,\n-                    node: hir::PatLit(P(expr.clone())),\n+                    node: PatKind::Lit(P(expr.clone())),\n                     span: span,\n                 }),\n                 _ => unreachable!()\n             };\n             let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect();\n-            hir::PatEnum(path, Some(pats))\n+            PatKind::Enum(path, Some(pats))\n         }\n \n         hir::ExprStruct(ref path, ref fields, None) => {\n@@ -355,21 +355,21 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n                     is_shorthand: false,\n                 },\n             }).collect();\n-            hir::PatStruct(path.clone(), field_pats, false)\n+            PatKind::Struct(path.clone(), field_pats, false)\n         }\n \n         hir::ExprVec(ref exprs) => {\n             let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect();\n-            hir::PatVec(pats, None, hir::HirVec::new())\n+            PatKind::Vec(pats, None, hir::HirVec::new())\n         }\n \n         hir::ExprPath(_, ref path) => {\n             let opt_def = tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(Def::Struct(..)) =>\n-                    hir::PatStruct(path.clone(), hir::HirVec::new(), false),\n+                    PatKind::Struct(path.clone(), hir::HirVec::new(), false),\n                 Some(Def::Variant(..)) =>\n-                    hir::PatEnum(path.clone(), None),\n+                    PatKind::Enum(path.clone(), None),\n                 Some(Def::Const(def_id)) |\n                 Some(Def::AssociatedConst(def_id)) => {\n                     let expr = lookup_const_by_id(tcx, def_id, Some(expr.id), None).unwrap();\n@@ -379,7 +379,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n             }\n         }\n \n-        _ => hir::PatLit(P(expr.clone()))\n+        _ => PatKind::Lit(P(expr.clone()))\n     };\n     P(hir::Pat { id: expr.id, node: pat, span: span })\n }"}, {"sha": "92372870cd16e0d2f8ae7b4df59b4f6ae3355eb7", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -14,7 +14,7 @@\n \n use dep_graph::DepNode;\n use front::map as ast_map;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::intravisit::{self, Visitor};\n \n use middle::{pat_util, privacy, ty};\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             _ => self.tcx.sess.span_bug(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n-            if let hir::PatWild = pat.node.pat.node {\n+            if let PatKind::Wild = pat.node.pat.node {\n                 continue;\n             }\n             self.insert_def_id(variant.field_named(pat.node.name).did);\n@@ -268,7 +268,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_pat(&mut self, pat: &hir::Pat) {\n         let def_map = &self.tcx.def_map;\n         match pat.node {\n-            hir::PatStruct(_, ref fields, _) => {\n+            PatKind::Struct(_, ref fields, _) => {\n                 self.handle_field_pattern_match(pat, fields);\n             }\n             _ if pat_util::pat_is_const(&def_map.borrow(), pat) => {"}, {"sha": "491cfa65a1eed162456c99e4e6fb91f3c3b2818c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -27,7 +27,7 @@ use middle::mem_categorization as mc;\n use middle::ty;\n use middle::ty::adjustment;\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n \n use syntax::ast;\n use syntax::ptr::P;\n@@ -946,9 +946,9 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             let def_map = &self.tcx().def_map;\n             if pat_util::pat_is_binding(&def_map.borrow(), pat) {\n                 match pat.node {\n-                    hir::PatIdent(hir::BindByRef(_), _, _) =>\n+                    PatKind::Ident(hir::BindByRef(_), _, _) =>\n                         mode.lub(BorrowingMatch),\n-                    hir::PatIdent(hir::BindByValue(_), _, _) => {\n+                    PatKind::Ident(hir::BindByValue(_), _, _) => {\n                         match copy_or_move(self.typer, &cmt_pat, PatBindingMove) {\n                             Copy => mode.lub(CopyingMatch),\n                             Move(_) => mode.lub(MovingMatch),\n@@ -1002,14 +1002,14 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n                 // It is also a borrow or copy/move of the value being matched.\n                 match pat.node {\n-                    hir::PatIdent(hir::BindByRef(m), _, _) => {\n+                    PatKind::Ident(hir::BindByRef(m), _, _) => {\n                         if let ty::TyRef(&r, _) = pat_ty.sty {\n                             let bk = ty::BorrowKind::from_mutbl(m);\n                             delegate.borrow(pat.id, pat.span, cmt_pat,\n                                             r, bk, RefBinding);\n                         }\n                     }\n-                    hir::PatIdent(hir::BindByValue(_), _, _) => {\n+                    PatKind::Ident(hir::BindByValue(_), _, _) => {\n                         let mode = copy_or_move(typer, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n                         delegate.consume_pat(pat, cmt_pat, mode);\n@@ -1022,7 +1022,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 }\n             } else {\n                 match pat.node {\n-                    hir::PatVec(_, Some(ref slice_pat), _) => {\n+                    PatKind::Vec(_, Some(ref slice_pat), _) => {\n                         // The `slice_pat` here creates a slice into\n                         // the original vector.  This is effectively a\n                         // borrow of the elements of the vector being\n@@ -1070,8 +1070,8 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             let tcx = typer.tcx;\n \n             match pat.node {\n-                hir::PatEnum(_, _) | hir::PatQPath(..) |\n-                hir::PatIdent(_, _, None) | hir::PatStruct(..) => {\n+                PatKind::Enum(_, _) | PatKind::QPath(..) |\n+                PatKind::Ident(_, _, None) | PatKind::Struct(..) => {\n                     match def_map.get(&pat.id).map(|d| d.full_def()) {\n                         None => {\n                             // no definition found: pat is not a\n@@ -1134,15 +1134,15 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                     }\n                 }\n \n-                hir::PatIdent(_, _, Some(_)) => {\n+                PatKind::Ident(_, _, Some(_)) => {\n                     // Do nothing; this is a binding (not an enum\n                     // variant or struct), and the cat_pattern call\n                     // will visit the substructure recursively.\n                 }\n \n-                hir::PatWild | hir::PatTup(..) | hir::PatBox(..) |\n-                hir::PatRegion(..) | hir::PatLit(..) | hir::PatRange(..) |\n-                hir::PatVec(..) => {\n+                PatKind::Wild | PatKind::Tup(..) | PatKind::Box(..) |\n+                PatKind::Ref(..) | PatKind::Lit(..) | PatKind::Range(..) |\n+                PatKind::Vec(..) => {\n                     // Similarly, each of these cases does not\n                     // correspond to an enum variant or struct, so we\n                     // do not do any `matched_pat` calls for these"}, {"sha": "a18d4dbee7d66562035c55ef046c8eb6231ef117", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -79,7 +79,7 @@ use middle::def::Def;\n use middle::ty::adjustment;\n use middle::ty::{self, Ty};\n \n-use rustc_front::hir::{MutImmutable, MutMutable};\n+use rustc_front::hir::{MutImmutable, MutMutable, PatKind};\n use rustc_front::hir;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -305,7 +305,7 @@ impl MutabilityCategory {\n     fn from_local(tcx: &ty::ctxt, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.map.get(id) {\n             ast_map::NodeLocal(p) => match p.node {\n-                hir::PatIdent(bind_mode, _, _) => {\n+                PatKind::Ident(bind_mode, _, _) => {\n                     if bind_mode == hir::BindByValue(hir::MutMutable) {\n                         McDeclared\n                     } else {\n@@ -396,7 +396,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         // *being borrowed* is.  But ideally we would put in a more\n         // fundamental fix to this conflated use of the node id.\n         let ret_ty = match pat.node {\n-            hir::PatIdent(hir::BindByRef(_), _, _) => {\n+            PatKind::Ident(hir::BindByRef(_), _, _) => {\n                 // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                 // but what we want here is the type of the underlying value being borrowed.\n                 // So peel off one-level, turning the &T into T.\n@@ -1209,7 +1209,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             None\n         };\n \n-        // Note: This goes up here (rather than within the PatEnum arm\n+        // Note: This goes up here (rather than within the PatKind::Enum arm\n         // alone) because struct patterns can refer to struct types or\n         // to struct variants within enums.\n         let cmt = match opt_def {\n@@ -1222,14 +1222,14 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         };\n \n         match pat.node {\n-          hir::PatWild => {\n+          PatKind::Wild => {\n             // _\n           }\n \n-          hir::PatEnum(_, None) => {\n+          PatKind::Enum(_, None) => {\n             // variant(..)\n           }\n-          hir::PatEnum(_, Some(ref subpats)) => {\n+          PatKind::Enum(_, Some(ref subpats)) => {\n             match opt_def {\n                 Some(Def::Variant(..)) => {\n                     // variant(x, y, z)\n@@ -1267,19 +1267,19 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             }\n           }\n \n-          hir::PatQPath(..) => {\n+          PatKind::QPath(..) => {\n               // Lone constant: ignore\n           }\n \n-          hir::PatIdent(_, _, Some(ref subpat)) => {\n+          PatKind::Ident(_, _, Some(ref subpat)) => {\n               try!(self.cat_pattern_(cmt, &subpat, op));\n           }\n \n-          hir::PatIdent(_, _, None) => {\n+          PatKind::Ident(_, _, None) => {\n               // nullary variant or identifier: ignore\n           }\n \n-          hir::PatStruct(_, ref field_pats, _) => {\n+          PatKind::Struct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats {\n                 let field_ty = try!(self.pat_ty(&fp.node.pat)); // see (*2)\n@@ -1288,7 +1288,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             }\n           }\n \n-          hir::PatTup(ref subpats) => {\n+          PatKind::Tup(ref subpats) => {\n             // (p1, ..., pN)\n             for (i, subpat) in subpats.iter().enumerate() {\n                 let subpat_ty = try!(self.pat_ty(&subpat)); // see (*2)\n@@ -1300,15 +1300,15 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             }\n           }\n \n-          hir::PatBox(ref subpat) | hir::PatRegion(ref subpat, _) => {\n+          PatKind::Box(ref subpat) | PatKind::Ref(ref subpat, _) => {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n-            // PatRegion since that information is already contained\n+            // PatKind::Ref since that information is already contained\n             // in the type.\n             let subcmt = try!(self.cat_deref(pat, cmt, 0, None));\n               try!(self.cat_pattern_(subcmt, &subpat, op));\n           }\n \n-          hir::PatVec(ref before, ref slice, ref after) => {\n+          PatKind::Vec(ref before, ref slice, ref after) => {\n               let context = InteriorOffsetKind::Pattern;\n               let vec_cmt = try!(self.deref_vec(pat, cmt, context));\n               let elt_cmt = try!(self.cat_index(pat, vec_cmt, context));\n@@ -1325,7 +1325,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n               }\n           }\n \n-          hir::PatLit(_) | hir::PatRange(_, _) => {\n+          PatKind::Lit(_) | PatKind::Range(_, _) => {\n               /*always ok*/\n           }\n         }"}, {"sha": "55fad3e3595592e72b757dfff73c7f0e5527b53f", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -14,7 +14,7 @@ use middle::ty;\n use util::nodemap::FnvHashMap;\n \n use syntax::ast;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::util::walk_pat;\n use syntax::codemap::{respan, Span, Spanned, DUMMY_SP};\n \n@@ -34,25 +34,25 @@ pub fn pat_id_map(dm: &RefCell<DefMap>, pat: &hir::Pat) -> PatIdMap {\n \n pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        hir::PatLit(_) | hir::PatRange(_, _) | hir::PatQPath(..) => true,\n-        hir::PatEnum(_, _) |\n-        hir::PatIdent(_, _, None) |\n-        hir::PatStruct(..) => {\n+        PatKind::Lit(_) | PatKind::Range(_, _) | PatKind::QPath(..) => true,\n+        PatKind::Enum(_, _) |\n+        PatKind::Ident(_, _, None) |\n+        PatKind::Struct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Variant(..)) => true,\n                 _ => false\n             }\n         }\n-        hir::PatVec(_, _, _) => true,\n+        PatKind::Vec(_, _, _) => true,\n         _ => false\n     }\n }\n \n pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        hir::PatEnum(_, _) |\n-        hir::PatIdent(_, _, None) |\n-        hir::PatStruct(..) => {\n+        PatKind::Enum(_, _) |\n+        PatKind::Ident(_, _, None) |\n+        PatKind::Struct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Variant(..)) | Some(Def::Struct(..)) => true,\n                 _ => false\n@@ -64,7 +64,7 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        hir::PatIdent(_, _, None) | hir::PatEnum(..) | hir::PatQPath(..) => {\n+        PatKind::Ident(_, _, None) | PatKind::Enum(..) | PatKind::QPath(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n                 _ => false\n@@ -78,7 +78,7 @@ pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n // returned instead of a panic.\n pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        hir::PatIdent(_, _, None) | hir::PatEnum(..) | hir::PatQPath(..) => {\n+        PatKind::Ident(_, _, None) | PatKind::Enum(..) | PatKind::QPath(..) => {\n             match dm.get(&pat.id)\n                     .and_then(|d| if d.depth == 0 { Some(d.base_def) }\n                                   else { None } ) {\n@@ -92,7 +92,7 @@ pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n pub fn pat_is_binding(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        hir::PatIdent(..) => {\n+        PatKind::Ident(..) => {\n             !pat_is_variant_or_struct(dm, pat) &&\n             !pat_is_const(dm, pat)\n         }\n@@ -102,8 +102,8 @@ pub fn pat_is_binding(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        hir::PatIdent(..) => pat_is_binding(dm, pat),\n-        hir::PatWild => true,\n+        PatKind::Ident(..) => pat_is_binding(dm, pat),\n+        PatKind::Wild => true,\n         _ => false\n     }\n }\n@@ -115,7 +115,7 @@ pub fn pat_bindings<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n {\n     walk_pat(pat, |p| {\n         match p.node {\n-          hir::PatIdent(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n+          PatKind::Ident(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n             it(binding_mode, p.id, p.span, &respan(pth.span, pth.node.name));\n           }\n           _ => {}\n@@ -128,7 +128,7 @@ pub fn pat_bindings_ident<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) wh\n {\n     walk_pat(pat, |p| {\n         match p.node {\n-          hir::PatIdent(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n+          PatKind::Ident(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n             it(binding_mode, p.id, p.span, &respan(pth.span, pth.node));\n           }\n           _ => {}\n@@ -199,7 +199,7 @@ pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n pub fn simple_name<'a>(pat: &'a hir::Pat) -> Option<ast::Name> {\n     match pat.node {\n-        hir::PatIdent(hir::BindByValue(_), ref path1, None) => {\n+        PatKind::Ident(hir::BindByValue(_), ref path1, None) => {\n             Some(path1.node.name)\n         }\n         _ => {\n@@ -224,9 +224,9 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n     let mut variants = vec![];\n     walk_pat(pat, |p| {\n         match p.node {\n-            hir::PatEnum(_, _) |\n-            hir::PatIdent(_, _, None) |\n-            hir::PatStruct(..) => {\n+            PatKind::Enum(_, _) |\n+            PatKind::Ident(_, _, None) |\n+            PatKind::Struct(..) => {\n                 match dm.get(&p.id) {\n                     Some(&PathResolution { base_def: Def::Variant(_, id), .. }) => {\n                         variants.push(id);"}, {"sha": "21df46990dd606efad5eb412534b4d4f975bef82", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -32,7 +32,7 @@ use syntax::ast::{self, NodeId};\n \n use rustc_front::hir;\n use rustc_front::intravisit::{self, Visitor, FnKind};\n-use rustc_front::hir::{Block, Item, FnDecl, Arm, Pat, Stmt, Expr, Local};\n+use rustc_front::hir::{Block, Item, FnDecl, Arm, Pat, PatKind, Stmt, Expr, Local};\n use rustc_front::util::stmt_id;\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n@@ -755,7 +755,7 @@ fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &hir::Pat) {\n     // If this is a binding (or maybe a binding, I'm too lazy to check\n     // the def map) then record the lifetime of that binding.\n     match pat.node {\n-        hir::PatIdent(..) => {\n+        PatKind::Ident(..) => {\n             record_var_lifetime(visitor, pat.id, pat.span);\n         }\n         _ => { }\n@@ -958,24 +958,24 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n     ///        | box P&\n     fn is_binding_pat(pat: &hir::Pat) -> bool {\n         match pat.node {\n-            hir::PatIdent(hir::BindByRef(_), _, _) => true,\n+            PatKind::Ident(hir::BindByRef(_), _, _) => true,\n \n-            hir::PatStruct(_, ref field_pats, _) => {\n+            PatKind::Struct(_, ref field_pats, _) => {\n                 field_pats.iter().any(|fp| is_binding_pat(&fp.node.pat))\n             }\n \n-            hir::PatVec(ref pats1, ref pats2, ref pats3) => {\n+            PatKind::Vec(ref pats1, ref pats2, ref pats3) => {\n                 pats1.iter().any(|p| is_binding_pat(&p)) ||\n                 pats2.iter().any(|p| is_binding_pat(&p)) ||\n                 pats3.iter().any(|p| is_binding_pat(&p))\n             }\n \n-            hir::PatEnum(_, Some(ref subpats)) |\n-            hir::PatTup(ref subpats) => {\n+            PatKind::Enum(_, Some(ref subpats)) |\n+            PatKind::Tup(ref subpats) => {\n                 subpats.iter().any(|p| is_binding_pat(&p))\n             }\n \n-            hir::PatBox(ref subpat) => {\n+            PatKind::Box(ref subpat) => {\n                 is_binding_pat(&subpat)\n             }\n "}, {"sha": "eeb9d673361d533bab119be233852ea76a55d1ea", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -31,7 +31,7 @@ use syntax::attr::{self, Stability, Deprecation, AttrMetaMethods};\n use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n \n use rustc_front::hir;\n-use rustc_front::hir::{Item, Generics, StructField, Variant};\n+use rustc_front::hir::{Item, Generics, StructField, Variant, PatKind};\n use rustc_front::intravisit::{self, Visitor};\n \n use std::mem::replace;\n@@ -598,14 +598,14 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &hir::Pat,\n     };\n     match pat.node {\n         // Foo(a, b, c)\n-        // A Variant(..) pattern `hir::PatEnum(_, None)` doesn't have to be recursed into.\n-        hir::PatEnum(_, Some(ref pat_fields)) => {\n+        // A Variant(..) pattern `PatKind::Enum(_, None)` doesn't have to be recursed into.\n+        PatKind::Enum(_, Some(ref pat_fields)) => {\n             for (field, struct_field) in pat_fields.iter().zip(&v.fields) {\n                 maybe_do_stability_check(tcx, struct_field.did, field.span, cb)\n             }\n         }\n         // Foo { a, b, c }\n-        hir::PatStruct(_, ref pat_fields, _) => {\n+        PatKind::Struct(_, ref pat_fields, _) => {\n             for field in pat_fields {\n                 let did = v.field_named(field.node.name).did;\n                 maybe_do_stability_check(tcx, did, field.span, cb);"}, {"sha": "8740b2ec1eac1b2bad80472a504f23bffe4a780b", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -52,7 +52,7 @@ use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n \n use rustc_front::hir;\n-use rustc_front::hir::{ItemImpl, ItemTrait};\n+use rustc_front::hir::{ItemImpl, ItemTrait, PatKind};\n use rustc_front::intravisit::Visitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n@@ -1945,7 +1945,7 @@ impl<'tcx> ctxt<'tcx> {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n-                    hir::PatIdent(_, ref path1, _) => path1.node.name.as_str(),\n+                    PatKind::Ident(_, ref path1, _) => path1.node.name.as_str(),\n                     _ => {\n                         self.sess.bug(&format!(\"Variable id {} maps to {:?}, not local\", id, pat));\n                     },"}, {"sha": "4e507284a1b46bb130f00110d160835d9cd987ae", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -23,7 +23,7 @@ use rustc::middle::ty;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n \n struct GatherMoveInfo<'tcx> {\n     id: ast::NodeId,\n@@ -98,7 +98,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       move_pat: &hir::Pat,\n                                       cmt: mc::cmt<'tcx>) {\n     let pat_span_path_opt = match move_pat.node {\n-        hir::PatIdent(_, ref path1, _) => {\n+        PatKind::Ident(_, ref path1, _) => {\n             Some(MoveSpanAndPath{span: move_pat.span,\n                                  name: path1.node.name})\n         },"}, {"sha": "c2c776a7443a565ff8a424c6bd5a40b0697bf5e6", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -962,25 +962,25 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n         Pat {\n             id: folder.new_id(id),\n             node: match node {\n-                PatWild => PatWild,\n-                PatIdent(binding_mode, pth1, sub) => {\n-                    PatIdent(binding_mode,\n+                PatKind::Wild => PatKind::Wild,\n+                PatKind::Ident(binding_mode, pth1, sub) => {\n+                    PatKind::Ident(binding_mode,\n                              Spanned {\n                                  span: folder.new_span(pth1.span),\n                                  node: folder.fold_ident(pth1.node),\n                              },\n                              sub.map(|x| folder.fold_pat(x)))\n                 }\n-                PatLit(e) => PatLit(folder.fold_expr(e)),\n-                PatEnum(pth, pats) => {\n-                    PatEnum(folder.fold_path(pth),\n+                PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n+                PatKind::Enum(pth, pats) => {\n+                    PatKind::Enum(folder.fold_path(pth),\n                             pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n                 }\n-                PatQPath(qself, pth) => {\n+                PatKind::QPath(qself, pth) => {\n                     let qself = QSelf { ty: folder.fold_ty(qself.ty), ..qself };\n-                    PatQPath(qself, folder.fold_path(pth))\n+                    PatKind::QPath(qself, folder.fold_path(pth))\n                 }\n-                PatStruct(pth, fields, etc) => {\n+                PatKind::Struct(pth, fields, etc) => {\n                     let pth = folder.fold_path(pth);\n                     let fs = fields.move_map(|f| {\n                         Spanned {\n@@ -992,16 +992,16 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                             },\n                         }\n                     });\n-                    PatStruct(pth, fs, etc)\n+                    PatKind::Struct(pth, fs, etc)\n                 }\n-                PatTup(elts) => PatTup(elts.move_map(|x| folder.fold_pat(x))),\n-                PatBox(inner) => PatBox(folder.fold_pat(inner)),\n-                PatRegion(inner, mutbl) => PatRegion(folder.fold_pat(inner), mutbl),\n-                PatRange(e1, e2) => {\n-                    PatRange(folder.fold_expr(e1), folder.fold_expr(e2))\n+                PatKind::Tup(elts) => PatKind::Tup(elts.move_map(|x| folder.fold_pat(x))),\n+                PatKind::Box(inner) => PatKind::Box(folder.fold_pat(inner)),\n+                PatKind::Ref(inner, mutbl) => PatKind::Ref(folder.fold_pat(inner), mutbl),\n+                PatKind::Range(e1, e2) => {\n+                    PatKind::Range(folder.fold_expr(e1), folder.fold_expr(e2))\n                 }\n-                PatVec(before, slice, after) => {\n-                    PatVec(before.move_map(|x| folder.fold_pat(x)),\n+                PatKind::Vec(before, slice, after) => {\n+                    PatKind::Vec(before.move_map(|x| folder.fold_pat(x)),\n                            slice.map(|x| folder.fold_pat(x)),\n                            after.move_map(|x| folder.fold_pat(x)))\n                 }"}, {"sha": "395bd0ef3e464e24c89f2c23246c32c5aacd56d5", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -21,7 +21,6 @@ pub use self::FunctionRetTy::*;\n pub use self::ForeignItem_::*;\n pub use self::Item_::*;\n pub use self::Mutability::*;\n-pub use self::Pat_::*;\n pub use self::PathListItem_::*;\n pub use self::PrimTy::*;\n pub use self::Stmt_::*;\n@@ -475,7 +474,7 @@ pub struct Block {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Pat {\n     pub id: NodeId,\n-    pub node: Pat_,\n+    pub node: PatKind,\n     pub span: Span,\n }\n \n@@ -506,45 +505,45 @@ pub enum BindingMode {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Pat_ {\n+pub enum PatKind {\n     /// Represents a wildcard pattern (`_`)\n-    PatWild,\n+    Wild,\n \n-    /// A PatIdent may either be a new bound variable,\n+    /// A PatKind::Ident may either be a new bound variable,\n     /// or a nullary enum (in which case the third field\n     /// is None).\n     ///\n     /// In the nullary enum case, the parser can't determine\n     /// which it is. The resolver determines this, and\n     /// records this pattern's NodeId in an auxiliary\n     /// set (of \"PatIdents that refer to nullary enums\")\n-    PatIdent(BindingMode, Spanned<Ident>, Option<P<Pat>>),\n+    Ident(BindingMode, Spanned<Ident>, Option<P<Pat>>),\n \n     /// \"None\" means a `Variant(..)` pattern where we don't bind the fields to names.\n-    PatEnum(Path, Option<HirVec<P<Pat>>>),\n+    Enum(Path, Option<HirVec<P<Pat>>>),\n \n     /// An associated const named using the qualified path `<T>::CONST` or\n     /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n     /// referred to as simply `T::CONST`, in which case they will end up as\n-    /// PatEnum, and the resolver will have to sort that out.\n-    PatQPath(QSelf, Path),\n+    /// PatKind::Enum, and the resolver will have to sort that out.\n+    QPath(QSelf, Path),\n \n     /// Destructuring of a struct, e.g. `Foo {x, y, ..}`\n     /// The `bool` is `true` in the presence of a `..`\n-    PatStruct(Path, HirVec<Spanned<FieldPat>>, bool),\n+    Struct(Path, HirVec<Spanned<FieldPat>>, bool),\n     /// A tuple pattern `(a, b)`\n-    PatTup(HirVec<P<Pat>>),\n+    Tup(HirVec<P<Pat>>),\n     /// A `box` pattern\n-    PatBox(P<Pat>),\n+    Box(P<Pat>),\n     /// A reference pattern, e.g. `&mut (a, b)`\n-    PatRegion(P<Pat>, Mutability),\n+    Ref(P<Pat>, Mutability),\n     /// A literal\n-    PatLit(P<Expr>),\n+    Lit(P<Expr>),\n     /// A range pattern, e.g. `1...2`\n-    PatRange(P<Expr>, P<Expr>),\n+    Range(P<Expr>, P<Expr>),\n     /// `[a, b, ..i, y, z]` is represented as:\n-    ///     `PatVec(box [a, b], Some(i), box [y, z])`\n-    PatVec(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n+    ///     `PatKind::Vec(box [a, b], Some(i), box [y, z])`\n+    Vec(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -1015,7 +1014,7 @@ impl Arg {\n             }),\n             pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n-                node: PatIdent(BindByValue(mutability), path, None),\n+                node: PatKind::Ident(BindByValue(mutability), path, None),\n                 span: span,\n             }),\n             id: DUMMY_NODE_ID,"}, {"sha": "f235a7b823442201516eaa2013e993ab0b5bf550", "filename": "src/librustc_front/intravisit.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_front%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_front%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fintravisit.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -468,41 +468,41 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     match pattern.node {\n-        PatEnum(ref path, ref opt_children) => {\n+        PatKind::Enum(ref path, ref opt_children) => {\n             visitor.visit_path(path, pattern.id);\n             if let Some(ref children) = *opt_children {\n                 walk_list!(visitor, visit_pat, children);\n             }\n         }\n-        PatQPath(ref qself, ref path) => {\n+        PatKind::QPath(ref qself, ref path) => {\n             visitor.visit_ty(&qself.ty);\n             visitor.visit_path(path, pattern.id)\n         }\n-        PatStruct(ref path, ref fields, _) => {\n+        PatKind::Struct(ref path, ref fields, _) => {\n             visitor.visit_path(path, pattern.id);\n             for field in fields {\n                 visitor.visit_name(field.span, field.node.name);\n                 visitor.visit_pat(&field.node.pat)\n             }\n         }\n-        PatTup(ref tuple_elements) => {\n+        PatKind::Tup(ref tuple_elements) => {\n             walk_list!(visitor, visit_pat, tuple_elements);\n         }\n-        PatBox(ref subpattern) |\n-        PatRegion(ref subpattern, _) => {\n+        PatKind::Box(ref subpattern) |\n+        PatKind::Ref(ref subpattern, _) => {\n             visitor.visit_pat(subpattern)\n         }\n-        PatIdent(_, ref pth1, ref optional_subpattern) => {\n+        PatKind::Ident(_, ref pth1, ref optional_subpattern) => {\n             visitor.visit_ident(pth1.span, pth1.node);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n-        PatLit(ref expression) => visitor.visit_expr(expression),\n-        PatRange(ref lower_bound, ref upper_bound) => {\n+        PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n+        PatKind::Range(ref lower_bound, ref upper_bound) => {\n             visitor.visit_expr(lower_bound);\n             visitor.visit_expr(upper_bound)\n         }\n-        PatWild => (),\n-        PatVec(ref prepatterns, ref slice_pattern, ref postpatterns) => {\n+        PatKind::Wild => (),\n+        PatKind::Vec(ref prepatterns, ref slice_pattern, ref postpatterns) => {\n             walk_list!(visitor, visit_pat, prepatterns);\n             walk_list!(visitor, visit_pat, slice_pattern);\n             walk_list!(visitor, visit_pat, postpatterns);"}, {"sha": "5935594b67ff00a2c83c57b6eca2d3dc0a163f53", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -913,27 +913,27 @@ pub fn lower_pat(lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n     P(hir::Pat {\n         id: p.id,\n         node: match p.node {\n-            PatKind::Wild => hir::PatWild,\n+            PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n-                hir::PatIdent(lower_binding_mode(lctx, binding_mode),\n+                hir::PatKind::Ident(lower_binding_mode(lctx, binding_mode),\n                               respan(pth1.span, lower_ident(lctx, pth1.node)),\n                               sub.as_ref().map(|x| lower_pat(lctx, x)))\n             }\n-            PatKind::Lit(ref e) => hir::PatLit(lower_expr(lctx, e)),\n+            PatKind::Lit(ref e) => hir::PatKind::Lit(lower_expr(lctx, e)),\n             PatKind::TupleStruct(ref pth, ref pats) => {\n-                hir::PatEnum(lower_path(lctx, pth),\n+                hir::PatKind::Enum(lower_path(lctx, pth),\n                              pats.as_ref()\n                                  .map(|pats| pats.iter().map(|x| lower_pat(lctx, x)).collect()))\n             }\n             PatKind::Path(ref pth) => {\n-                hir::PatEnum(lower_path(lctx, pth), Some(hir::HirVec::new()))\n+                hir::PatKind::Enum(lower_path(lctx, pth), Some(hir::HirVec::new()))\n             }\n             PatKind::QPath(ref qself, ref pth) => {\n                 let qself = hir::QSelf {\n                     ty: lower_ty(lctx, &qself.ty),\n                     position: qself.position,\n                 };\n-                hir::PatQPath(qself, lower_path(lctx, pth))\n+                hir::PatKind::QPath(qself, lower_path(lctx, pth))\n             }\n             PatKind::Struct(ref pth, ref fields, etc) => {\n                 let pth = lower_path(lctx, pth);\n@@ -949,20 +949,20 @@ pub fn lower_pat(lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n                                    }\n                                })\n                                .collect();\n-                hir::PatStruct(pth, fs, etc)\n+                hir::PatKind::Struct(pth, fs, etc)\n             }\n             PatKind::Tup(ref elts) => {\n-                hir::PatTup(elts.iter().map(|x| lower_pat(lctx, x)).collect())\n+                hir::PatKind::Tup(elts.iter().map(|x| lower_pat(lctx, x)).collect())\n             }\n-            PatKind::Box(ref inner) => hir::PatBox(lower_pat(lctx, inner)),\n+            PatKind::Box(ref inner) => hir::PatKind::Box(lower_pat(lctx, inner)),\n             PatKind::Ref(ref inner, mutbl) => {\n-                hir::PatRegion(lower_pat(lctx, inner), lower_mutability(lctx, mutbl))\n+                hir::PatKind::Ref(lower_pat(lctx, inner), lower_mutability(lctx, mutbl))\n             }\n             PatKind::Range(ref e1, ref e2) => {\n-                hir::PatRange(lower_expr(lctx, e1), lower_expr(lctx, e2))\n+                hir::PatKind::Range(lower_expr(lctx, e1), lower_expr(lctx, e2))\n             }\n             PatKind::Vec(ref before, ref slice, ref after) => {\n-                hir::PatVec(before.iter().map(|x| lower_pat(lctx, x)).collect(),\n+                hir::PatKind::Vec(before.iter().map(|x| lower_pat(lctx, x)).collect(),\n                             slice.as_ref().map(|x| lower_pat(lctx, x)),\n                             after.iter().map(|x| lower_pat(lctx, x)).collect())\n             }\n@@ -1750,7 +1750,7 @@ fn pat_enum(lctx: &LoweringContext,\n             path: hir::Path,\n             subpats: hir::HirVec<P<hir::Pat>>)\n             -> P<hir::Pat> {\n-    let pt = hir::PatEnum(path, Some(subpats));\n+    let pt = hir::PatKind::Enum(path, Some(subpats));\n     pat(lctx, span, pt)\n }\n \n@@ -1763,7 +1763,7 @@ fn pat_ident_binding_mode(lctx: &LoweringContext,\n                           ident: hir::Ident,\n                           bm: hir::BindingMode)\n                           -> P<hir::Pat> {\n-    let pat_ident = hir::PatIdent(bm,\n+    let pat_ident = hir::PatKind::Ident(bm,\n                                   Spanned {\n                                       span: span,\n                                       node: ident,\n@@ -1773,10 +1773,10 @@ fn pat_ident_binding_mode(lctx: &LoweringContext,\n }\n \n fn pat_wild(lctx: &LoweringContext, span: Span) -> P<hir::Pat> {\n-    pat(lctx, span, hir::PatWild)\n+    pat(lctx, span, hir::PatKind::Wild)\n }\n \n-fn pat(lctx: &LoweringContext, span: Span, pat: hir::Pat_) -> P<hir::Pat> {\n+fn pat(lctx: &LoweringContext, span: Span, pat: hir::PatKind) -> P<hir::Pat> {\n     P(hir::Pat {\n         id: lctx.next_id(),\n         node: pat,"}, {"sha": "dc4bd8ba474b854458f91be73f203c4191ef0b29", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -24,7 +24,7 @@ use syntax::print::pprust::{self as ast_pp, PrintState};\n use syntax::ptr::P;\n \n use hir;\n-use hir::{Crate, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n+use hir::{Crate, PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n \n use std::io::{self, Write, Read};\n \n@@ -1727,8 +1727,8 @@ impl<'a> State<'a> {\n         // Pat isn't normalized, but the beauty of it\n         // is that it doesn't matter\n         match pat.node {\n-            hir::PatWild => try!(word(&mut self.s, \"_\")),\n-            hir::PatIdent(binding_mode, ref path1, ref sub) => {\n+            PatKind::Wild => try!(word(&mut self.s, \"_\")),\n+            PatKind::Ident(binding_mode, ref path1, ref sub) => {\n                 match binding_mode {\n                     hir::BindByRef(mutbl) => {\n                         try!(self.word_nbsp(\"ref\"));\n@@ -1748,7 +1748,7 @@ impl<'a> State<'a> {\n                     None => (),\n                 }\n             }\n-            hir::PatEnum(ref path, ref args_) => {\n+            PatKind::Enum(ref path, ref args_) => {\n                 try!(self.print_path(path, true, 0));\n                 match *args_ {\n                     None => try!(word(&mut self.s, \"(..)\")),\n@@ -1761,10 +1761,10 @@ impl<'a> State<'a> {\n                     }\n                 }\n             }\n-            hir::PatQPath(ref qself, ref path) => {\n+            PatKind::QPath(ref qself, ref path) => {\n                 try!(self.print_qpath(path, qself, false));\n             }\n-            hir::PatStruct(ref path, ref fields, etc) => {\n+            PatKind::Struct(ref path, ref fields, etc) => {\n                 try!(self.print_path(path, true, 0));\n                 try!(self.nbsp());\n                 try!(self.word_space(\"{\"));\n@@ -1789,40 +1789,40 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, \"}\"));\n             }\n-            hir::PatTup(ref elts) => {\n+            PatKind::Tup(ref elts) => {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n                 try!(self.pclose());\n             }\n-            hir::PatBox(ref inner) => {\n+            PatKind::Box(ref inner) => {\n                 try!(word(&mut self.s, \"box \"));\n                 try!(self.print_pat(&inner));\n             }\n-            hir::PatRegion(ref inner, mutbl) => {\n+            PatKind::Ref(ref inner, mutbl) => {\n                 try!(word(&mut self.s, \"&\"));\n                 if mutbl == hir::MutMutable {\n                     try!(word(&mut self.s, \"mut \"));\n                 }\n                 try!(self.print_pat(&inner));\n             }\n-            hir::PatLit(ref e) => try!(self.print_expr(&e)),\n-            hir::PatRange(ref begin, ref end) => {\n+            PatKind::Lit(ref e) => try!(self.print_expr(&e)),\n+            PatKind::Range(ref begin, ref end) => {\n                 try!(self.print_expr(&begin));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, \"...\"));\n                 try!(self.print_expr(&end));\n             }\n-            hir::PatVec(ref before, ref slice, ref after) => {\n+            PatKind::Vec(ref before, ref slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.commasep(Inconsistent, &before[..], |s, p| s.print_pat(&p)));\n                 if let Some(ref p) = *slice {\n                     if !before.is_empty() {\n                         try!(self.word_space(\",\"));\n                     }\n-                    if p.node != hir::PatWild {\n+                    if p.node != PatKind::Wild {\n                         try!(self.print_pat(&p));\n                     }\n                     try!(word(&mut self.s, \"..\"));\n@@ -1945,7 +1945,7 @@ impl<'a> State<'a> {\n             let m = match explicit_self {\n                 &hir::SelfStatic => hir::MutImmutable,\n                 _ => match decl.inputs[0].pat.node {\n-                    hir::PatIdent(hir::BindByValue(m), _, _) => m,\n+                    PatKind::Ident(hir::BindByValue(m), _, _) => m,\n                     _ => hir::MutImmutable,\n                 },\n             };\n@@ -2210,7 +2210,7 @@ impl<'a> State<'a> {\n             hir::TyInfer if is_closure => try!(self.print_pat(&input.pat)),\n             _ => {\n                 match input.pat.node {\n-                    hir::PatIdent(_, ref path1, _) if\n+                    PatKind::Ident(_, ref path1, _) if\n                         path1.node.name ==\n                             parse::token::special_idents::invalid.name => {\n                         // Do nothing."}, {"sha": "12654b2b3d74e21573e1665ac522f06e9a66f2ee", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -28,27 +28,27 @@ pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool\n         }\n \n         match pat.node {\n-            PatIdent(_, _, Some(ref p)) => walk_pat_(&p, it),\n-            PatStruct(_, ref fields, _) => {\n+            PatKind::Ident(_, _, Some(ref p)) => walk_pat_(&p, it),\n+            PatKind::Struct(_, ref fields, _) => {\n                 fields.iter().all(|field| walk_pat_(&field.node.pat, it))\n             }\n-            PatEnum(_, Some(ref s)) | PatTup(ref s) => {\n+            PatKind::Enum(_, Some(ref s)) | PatKind::Tup(ref s) => {\n                 s.iter().all(|p| walk_pat_(&p, it))\n             }\n-            PatBox(ref s) | PatRegion(ref s, _) => {\n+            PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n                 walk_pat_(&s, it)\n             }\n-            PatVec(ref before, ref slice, ref after) => {\n+            PatKind::Vec(ref before, ref slice, ref after) => {\n                 before.iter().all(|p| walk_pat_(&p, it)) &&\n                 slice.iter().all(|p| walk_pat_(&p, it)) &&\n                 after.iter().all(|p| walk_pat_(&p, it))\n             }\n-            PatWild |\n-            PatLit(_) |\n-            PatRange(_, _) |\n-            PatIdent(_, _, _) |\n-            PatEnum(_, _) |\n-            PatQPath(_, _) => {\n+            PatKind::Wild |\n+            PatKind::Lit(_) |\n+            PatKind::Range(_, _) |\n+            PatKind::Ident(_, _, _) |\n+            PatKind::Enum(_, _) |\n+            PatKind::QPath(_, _) => {\n                 true\n             }\n         }"}, {"sha": "16ef6e001ddbd867c4ae6c7d75762d2729fd47b2", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -17,7 +17,7 @@ use syntax::ast;\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::intravisit::FnKind;\n \n #[derive(PartialEq)]\n@@ -272,7 +272,7 @@ impl LateLintPass for NonSnakeCase {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n-        if let &hir::PatIdent(_, ref path1, _) = &p.node {\n+        if let &PatKind::Ident(_, ref path1, _) = &p.node {\n             let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n             if let Some(Def::Local(..)) = def {\n                 self.check_snake_case(cx, \"variable\", &path1.node.name.as_str(), Some(p.span));\n@@ -362,7 +362,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n-            (&hir::PatIdent(_, ref path1, _), Some(Def::Const(..))) => {\n+            (&PatKind::Ident(_, ref path1, _), Some(Def::Const(..))) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n                                                       path1.node.name, p.span);\n             }"}, {"sha": "2780baa6de3fd72109adcb7a28aaa410ee030284", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -46,7 +46,7 @@ use syntax::{ast};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::intravisit::FnKind;\n \n use bad_style::{MethodLateContext, method_context};\n@@ -157,7 +157,7 @@ impl LintPass for NonShorthandFieldPatterns {\n impl LateLintPass for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n         let def_map = cx.tcx.def_map.borrow();\n-        if let hir::PatStruct(_, ref v, _) = pat.node {\n+        if let PatKind::Struct(_, ref v, _) = pat.node {\n             let field_pats = v.iter().filter(|fieldpat| {\n                 if fieldpat.node.is_shorthand {\n                     return false;\n@@ -170,7 +170,7 @@ impl LateLintPass for NonShorthandFieldPatterns {\n                 }\n             });\n             for fieldpat in field_pats {\n-                if let hir::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n+                if let PatKind::Ident(_, ident, None) = fieldpat.node.pat.node {\n                     if ident.node.unhygienic_name == fieldpat.node.name {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant and can \\"}, {"sha": "d707c61cbb44079257859a40da4f1789d5896598", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -50,7 +50,7 @@ use syntax::parse::token::special_idents;\n use syntax;\n use rbml::writer::Encoder;\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::intravisit::Visitor;\n use rustc_front::intravisit;\n \n@@ -783,7 +783,7 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n     rbml_w.start_tag(tag_method_argument_names);\n     for arg in &decl.inputs {\n         let tag = tag_method_argument_name;\n-        if let hir::PatIdent(_, ref path1, _) = arg.pat.node {\n+        if let PatKind::Ident(_, ref path1, _) = arg.pat.node {\n             let name = path1.node.name.as_str();\n             rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n         } else {"}, {"sha": "fc1af0e7af16eaa4203bc896e74e6edce7e395be", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -16,7 +16,7 @@ use rustc::middle::def::Def;\n use rustc::middle::pat_util::{pat_is_resolved_const, pat_is_binding};\n use rustc::middle::ty::{self, Ty};\n use rustc::mir::repr::*;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::ptr::P;\n@@ -64,22 +64,22 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n \n     fn to_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n         let kind = match pat.node {\n-            hir::PatWild => PatternKind::Wild,\n+            PatKind::Wild => PatternKind::Wild,\n \n-            hir::PatLit(ref value) => {\n+            PatKind::Lit(ref value) => {\n                 let value = const_eval::eval_const_expr(self.cx.tcx, value);\n                 PatternKind::Constant { value: value }\n             }\n \n-            hir::PatRange(ref lo, ref hi) => {\n+            PatKind::Range(ref lo, ref hi) => {\n                 let lo = const_eval::eval_const_expr(self.cx.tcx, lo);\n                 let lo = Literal::Value { value: lo };\n                 let hi = const_eval::eval_const_expr(self.cx.tcx, hi);\n                 let hi = Literal::Value { value: hi };\n                 PatternKind::Range { lo: lo, hi: hi }\n             },\n \n-            hir::PatEnum(..) | hir::PatIdent(..) | hir::PatQPath(..)\n+            PatKind::Enum(..) | PatKind::Ident(..) | PatKind::QPath(..)\n                 if pat_is_resolved_const(&self.cx.tcx.def_map.borrow(), pat) =>\n             {\n                 let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n@@ -105,12 +105,12 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 }\n             }\n \n-            hir::PatRegion(ref subpattern, _) |\n-            hir::PatBox(ref subpattern) => {\n+            PatKind::Ref(ref subpattern, _) |\n+            PatKind::Box(ref subpattern) => {\n                 PatternKind::Deref { subpattern: self.to_pattern(subpattern) }\n             }\n \n-            hir::PatVec(ref prefix, ref slice, ref suffix) => {\n+            PatKind::Vec(ref prefix, ref slice, ref suffix) => {\n                 let ty = self.cx.tcx.node_id_to_type(pat.id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n@@ -134,7 +134,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 }\n             }\n \n-            hir::PatTup(ref subpatterns) => {\n+            PatKind::Tup(ref subpatterns) => {\n                 let subpatterns =\n                     subpatterns.iter()\n                                .enumerate()\n@@ -147,7 +147,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n \n-            hir::PatIdent(bm, ref ident, ref sub)\n+            PatKind::Ident(bm, ref ident, ref sub)\n                 if pat_is_binding(&self.cx.tcx.def_map.borrow(), pat) =>\n             {\n                 let id = match self.binding_map {\n@@ -179,11 +179,11 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 }\n             }\n \n-            hir::PatIdent(..) => {\n+            PatKind::Ident(..) => {\n                 self.variant_or_leaf(pat, vec![])\n             }\n \n-            hir::PatEnum(_, ref opt_subpatterns) => {\n+            PatKind::Enum(_, ref opt_subpatterns) => {\n                 let subpatterns =\n                     opt_subpatterns.iter()\n                                    .flat_map(|v| v.iter())\n@@ -196,7 +196,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 self.variant_or_leaf(pat, subpatterns)\n             }\n \n-            hir::PatStruct(_, ref fields, _) => {\n+            PatKind::Struct(_, ref fields, _) => {\n                 let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyStruct(adt_def, _) | ty::TyEnum(adt_def, _) => adt_def,\n@@ -229,7 +229,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 self.variant_or_leaf(pat, subpatterns)\n             }\n \n-            hir::PatQPath(..) => {\n+            PatKind::QPath(..) => {\n                 self.cx.tcx.sess.span_bug(pat.span, \"unexpanded macro or bad constant etc\");\n             }\n         };"}, {"sha": "ee6003f713e7b814b3806af1a3f4b0b7e9916b00", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -41,7 +41,7 @@ use rustc::util::nodemap::NodeMap;\n use rustc::middle::const_qualif::ConstQualif;\n use rustc::lint::builtin::CONST_ERR;\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::feature_gate::UnstableFeatures;\n@@ -322,10 +322,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n \n     fn visit_pat(&mut self, p: &hir::Pat) {\n         match p.node {\n-            hir::PatLit(ref lit) => {\n+            PatKind::Lit(ref lit) => {\n                 self.global_expr(Mode::Const, &lit);\n             }\n-            hir::PatRange(ref start, ref end) => {\n+            PatKind::Range(ref start, ref end) => {\n                 self.global_expr(Mode::Const, &start);\n                 self.global_expr(Mode::Const, &end);\n "}, {"sha": "862ab02ee954b1ad9c185e865a81074e11f91766", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -33,7 +33,7 @@ use self::FieldName::*;\n use std::cmp;\n use std::mem::replace;\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::intravisit::{self, Visitor};\n \n use rustc::dep_graph::DepNode;\n@@ -920,7 +920,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         if self.in_foreign { return }\n \n         match pattern.node {\n-            hir::PatStruct(_, ref fields, _) => {\n+            PatKind::Struct(_, ref fields, _) => {\n                 let adt = self.tcx.pat_ty(pattern).ty_adt_def().unwrap();\n                 let def = self.tcx.def_map.borrow().get(&pattern.id).unwrap().full_def();\n                 let variant = adt.variant_of_def(def);\n@@ -932,11 +932,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n             // Patterns which bind no fields are allowable (the path is check\n             // elsewhere).\n-            hir::PatEnum(_, Some(ref fields)) => {\n+            PatKind::Enum(_, Some(ref fields)) => {\n                 match self.tcx.pat_ty(pattern).sty {\n                     ty::TyStruct(def, _) => {\n                         for (i, field) in fields.iter().enumerate() {\n-                            if let hir::PatWild = field.node {\n+                            if let PatKind::Wild = field.node {\n                                 continue\n                             }\n                             self.check_field(field.span,"}, {"sha": "2ee62e71fab1d0156e651a85a290672bf648f204", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -80,8 +80,7 @@ use rustc_front::hir::{ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n use rustc_front::hir::{ItemFn, ItemForeignMod, ItemImpl, ItemMod, ItemStatic, ItemDefaultImpl};\n use rustc_front::hir::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n use rustc_front::hir::Local;\n-use rustc_front::hir::{Pat, PatEnum, PatIdent, PatLit, PatQPath};\n-use rustc_front::hir::{PatRange, PatStruct, Path, PrimTy};\n+use rustc_front::hir::{Pat, PatKind, Path, PrimTy};\n use rustc_front::hir::{TraitRef, Ty, TyBool, TyChar, TyFloat, TyInt};\n use rustc_front::hir::{TyRptr, TyStr, TyUint, TyPath, TyPtr};\n use rustc_front::util::walk_pat;\n@@ -2362,8 +2361,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let pat_id = pattern.id;\n         walk_pat(pattern, |pattern| {\n             match pattern.node {\n-                PatIdent(binding_mode, ref path1, ref at_rhs) => {\n-                    // The meaning of PatIdent with no type parameters\n+                PatKind::Ident(binding_mode, ref path1, ref at_rhs) => {\n+                    // The meaning of PatKind::Ident with no type parameters\n                     // depends on whether an enum variant or unit-like struct\n                     // with that name is in scope. The probing lookup has to\n                     // be careful not to emit spurious errors. Only matching\n@@ -2474,24 +2473,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n \n-                PatEnum(ref path, _) => {\n+                PatKind::Enum(ref path, _) => {\n                     // This must be an enum variant, struct or const.\n                     let resolution = match self.resolve_possibly_assoc_item(pat_id,\n                                                                             None,\n                                                                             path,\n                                                                             ValueNS,\n                                                                             false) {\n                         // The below shouldn't happen because all\n-                        // qualified paths should be in PatQPath.\n+                        // qualified paths should be in PatKind::QPath.\n                         TypecheckRequired =>\n                             self.session.span_bug(path.span,\n                                                   \"resolve_possibly_assoc_item claimed\n                                      \\\n-                                                   that a path in PatEnum requires typecheck\n+                                                   that a path in PatKind::Enum requires typecheck\n                                      \\\n                                                    to resolve, but qualified paths should be\n                                      \\\n-                                                   PatQPath\"),\n+                                                   PatKind::QPath\"),\n                         ResolveAttempt(resolution) => resolution,\n                     };\n                     if let Some(path_res) = resolution {\n@@ -2550,7 +2549,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     intravisit::walk_path(self, path);\n                 }\n \n-                PatQPath(ref qself, ref path) => {\n+                PatKind::QPath(ref qself, ref path) => {\n                     // Associated constants only.\n                     let resolution = match self.resolve_possibly_assoc_item(pat_id,\n                                                                             Some(qself),\n@@ -2605,7 +2604,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     intravisit::walk_pat(self, pattern);\n                 }\n \n-                PatStruct(ref path, _, _) => {\n+                PatKind::Struct(ref path, _, _) => {\n                     match self.resolve_path(pat_id, path, 0, TypeNS, false) {\n                         Some(definition) => {\n                             self.record_def(pattern.id, definition);\n@@ -2624,7 +2623,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     intravisit::walk_path(self, path);\n                 }\n \n-                PatLit(_) | PatRange(..) => {\n+                PatKind::Lit(_) | PatKind::Range(..) => {\n                     intravisit::walk_pat(self, pattern);\n                 }\n "}, {"sha": "e81fe08e7b16496d3bf74b3b9b235522a5194622", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -227,7 +227,7 @@ use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::fmt;\n use std::rc::Rc;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n use syntax::codemap::Span;\n use rustc_front::fold::Folder;\n@@ -424,7 +424,7 @@ impl<'a, 'p, 'blk, 'tcx> fmt::Debug for Match<'a, 'p, 'blk, 'tcx> {\n fn has_nested_bindings(m: &[Match], col: usize) -> bool {\n     for br in m {\n         match br.pats[col].node {\n-            hir::PatIdent(_, _, Some(_)) => return true,\n+            PatKind::Ident(_, _, Some(_)) => return true,\n             _ => ()\n         }\n     }\n@@ -477,7 +477,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let mut pat = br.pats[col];\n         loop {\n             pat = match pat.node {\n-                hir::PatIdent(_, ref path, Some(ref inner)) => {\n+                PatKind::Ident(_, ref path, Some(ref inner)) => {\n                     bound_ptrs.push((path.node.name, val.val));\n                     &inner\n                 },\n@@ -517,13 +517,13 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n-                hir::PatIdent(_, ref path, None) => {\n+                PatKind::Ident(_, ref path, None) => {\n                     if pat_is_binding(&dm.borrow(), &this) {\n                         bound_ptrs.push((path.node.name, val.val));\n                     }\n                 }\n-                hir::PatVec(ref before, Some(ref slice), ref after) => {\n-                    if let hir::PatIdent(_, ref path, None) = slice.node {\n+                PatKind::Vec(ref before, Some(ref slice), ref after) => {\n+                    if let PatKind::Ident(_, ref path, None) = slice.node {\n                         let subslice_val = bind_subslice_pat(\n                             bcx, this.id, val,\n                             before.len(), after.len());\n@@ -662,10 +662,10 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         };\n \n         let opt = match cur.node {\n-            hir::PatLit(ref l) => {\n+            PatKind::Lit(ref l) => {\n                 ConstantValue(ConstantExpr(&l), debug_loc)\n             }\n-            hir::PatIdent(..) | hir::PatEnum(..) | hir::PatStruct(..) => {\n+            PatKind::Ident(..) | PatKind::Enum(..) | PatKind::Struct(..) => {\n                 // This is either an enum variant or a variable binding.\n                 let opt_def = tcx.def_map.borrow().get(&cur.id).map(|d| d.full_def());\n                 match opt_def {\n@@ -679,13 +679,13 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     _ => continue\n                 }\n             }\n-            hir::PatRange(ref l1, ref l2) => {\n+            PatKind::Range(ref l1, ref l2) => {\n                 ConstantRange(ConstantExpr(&l1), ConstantExpr(&l2), debug_loc)\n             }\n-            hir::PatVec(ref before, None, ref after) => {\n+            PatKind::Vec(ref before, None, ref after) => {\n                 SliceLengthEqual(before.len() + after.len(), debug_loc)\n             }\n-            hir::PatVec(ref before, Some(_), ref after) => {\n+            PatKind::Vec(ref before, Some(_), ref after) => {\n                 SliceLengthGreaterOrEqual(before.len(), after.len(), debug_loc)\n             }\n             _ => continue\n@@ -786,25 +786,25 @@ macro_rules! any_pat {\n }\n \n fn any_uniq_pat(m: &[Match], col: usize) -> bool {\n-    any_pat!(m, col, hir::PatBox(_))\n+    any_pat!(m, col, PatKind::Box(_))\n }\n \n fn any_region_pat(m: &[Match], col: usize) -> bool {\n-    any_pat!(m, col, hir::PatRegion(..))\n+    any_pat!(m, col, PatKind::Ref(..))\n }\n \n fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: usize) -> bool {\n     m.iter().any(|br| {\n         let pat = br.pats[col];\n         match pat.node {\n-            hir::PatTup(_) => true,\n-            hir::PatStruct(..) => {\n+            PatKind::Tup(_) => true,\n+            PatKind::Struct(..) => {\n                 match tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n                     Some(Def::Variant(..)) => false,\n                     _ => true,\n                 }\n             }\n-            hir::PatEnum(..) | hir::PatIdent(_, _, None) => {\n+            PatKind::Enum(..) | PatKind::Ident(_, _, None) => {\n                 match tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n                     Some(Def::Struct(..)) => true,\n                     _ => false\n@@ -849,7 +849,7 @@ impl FailureHandler {\n fn pick_column_to_specialize(def_map: &RefCell<DefMap>, m: &[Match]) -> Option<usize> {\n     fn pat_score(def_map: &RefCell<DefMap>, pat: &hir::Pat) -> usize {\n         match pat.node {\n-            hir::PatIdent(_, _, Some(ref inner)) => pat_score(def_map, &inner),\n+            PatKind::Ident(_, _, Some(ref inner)) => pat_score(def_map, &inner),\n             _ if pat_is_refutable(&def_map.borrow(), pat) => 1,\n             _ => 0\n         }\n@@ -871,7 +871,7 @@ fn pick_column_to_specialize(def_map: &RefCell<DefMap>, m: &[Match]) -> Option<u\n \n     let column_contains_any_nonwild_patterns = |&col: &usize| -> bool {\n         m.iter().any(|row| match row.pats[col].node {\n-            hir::PatWild => false,\n+            PatKind::Wild => false,\n             _ => true\n         })\n     };\n@@ -1639,7 +1639,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     // to the default arm.\n     let has_default = arms.last().map_or(false, |arm| {\n         arm.pats.len() == 1\n-        && arm.pats.last().unwrap().node == hir::PatWild\n+        && arm.pats.last().unwrap().node == PatKind::Wild\n     });\n \n     compile_submatch(bcx, &matches[..], &[discr_datum.match_input()], &chk, has_default);\n@@ -1812,7 +1812,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let ccx = bcx.ccx();\n     match pat.node {\n-        hir::PatIdent(pat_binding_mode, ref path1, ref inner) => {\n+        PatKind::Ident(pat_binding_mode, ref path1, ref inner) => {\n             if pat_is_binding(&tcx.def_map.borrow(), &pat) {\n                 // Allocate the stack slot where the value of this\n                 // binding will live and place it into the appropriate\n@@ -1849,7 +1849,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx = bind_irrefutable_pat(bcx, &inner_pat, val, cleanup_scope);\n             }\n         }\n-        hir::PatEnum(_, ref sub_pats) => {\n+        PatKind::Enum(_, ref sub_pats) => {\n             let opt_def = bcx.tcx().def_map.borrow().get(&pat.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(Def::Variant(enum_id, var_id)) => {\n@@ -1895,7 +1895,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             }\n         }\n-        hir::PatStruct(_, ref fields, _) => {\n+        PatKind::Struct(_, ref fields, _) => {\n             let tcx = bcx.tcx();\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n@@ -1935,7 +1935,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                            cleanup_scope);\n             }\n         }\n-        hir::PatTup(ref elems) => {\n+        PatKind::Tup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n             let val = adt::MaybeSizedValue::sized(val.val);\n             for (i, elem) in elems.iter().enumerate() {\n@@ -1947,13 +1947,13 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     cleanup_scope);\n             }\n         }\n-        hir::PatBox(ref inner) => {\n+        PatKind::Box(ref inner) => {\n             let pat_ty = node_id_type(bcx, inner.id);\n             // Pass along DSTs as fat pointers.\n             let val = if type_is_fat_ptr(tcx, pat_ty) {\n                 // We need to check for this, as the pattern could be binding\n                 // a fat pointer by-value.\n-                if let hir::PatIdent(hir::BindByRef(_),_,_) = inner.node {\n+                if let PatKind::Ident(hir::BindByRef(_),_,_) = inner.node {\n                     val.val\n                 } else {\n                     Load(bcx, val.val)\n@@ -1966,13 +1966,13 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx = bind_irrefutable_pat(\n                 bcx, &inner, MatchInput::from_val(val), cleanup_scope);\n         }\n-        hir::PatRegion(ref inner, _) => {\n+        PatKind::Ref(ref inner, _) => {\n             let pat_ty = node_id_type(bcx, inner.id);\n             // Pass along DSTs as fat pointers.\n             let val = if type_is_fat_ptr(tcx, pat_ty) {\n                 // We need to check for this, as the pattern could be binding\n                 // a fat pointer by-value.\n-                if let hir::PatIdent(hir::BindByRef(_),_,_) = inner.node {\n+                if let PatKind::Ident(hir::BindByRef(_),_,_) = inner.node {\n                     val.val\n                 } else {\n                     Load(bcx, val.val)\n@@ -1988,7 +1988,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 MatchInput::from_val(val),\n                 cleanup_scope);\n         }\n-        hir::PatVec(ref before, ref slice, ref after) => {\n+        PatKind::Vec(ref before, ref slice, ref after) => {\n             let pat_ty = node_id_type(bcx, pat.id);\n             let mut extracted = extract_vec_elems(bcx, pat_ty, before.len(), after.len(), val);\n             match slice {\n@@ -2013,8 +2013,8 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         cleanup_scope)\n                 });\n         }\n-        hir::PatQPath(..) | hir::PatWild | hir::PatLit(_) |\n-        hir::PatRange(_, _) => ()\n+        PatKind::QPath(..) | PatKind::Wild | PatKind::Lit(_) |\n+        PatKind::Range(_, _) => ()\n     }\n     return bcx;\n }"}, {"sha": "1589cf6486537b28b5409b15efef01f9470fb646", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -22,7 +22,7 @@ use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap};\n \n use rustc_front;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n \n // This procedure builds the *scope map* for a given function, which maps any\n // given ast::NodeId in the function's AST to the correct DIScope metadata instance.\n@@ -163,7 +163,7 @@ fn walk_pattern(cx: &CrateContext,\n     // ast_util::walk_pat() here because we have to visit *all* nodes in\n     // order to put them into the scope map. The above functions don't do that.\n     match pat.node {\n-        hir::PatIdent(_, ref path1, ref sub_pat_opt) => {\n+        PatKind::Ident(_, ref path1, ref sub_pat_opt) => {\n \n             // Check if this is a binding. If so we need to put it on the\n             // scope stack and maybe introduce an artificial scope\n@@ -235,11 +235,11 @@ fn walk_pattern(cx: &CrateContext,\n             }\n         }\n \n-        hir::PatWild => {\n+        PatKind::Wild => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n         }\n \n-        hir::PatEnum(_, ref sub_pats_opt) => {\n+        PatKind::Enum(_, ref sub_pats_opt) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             if let Some(ref sub_pats) = *sub_pats_opt {\n@@ -249,11 +249,11 @@ fn walk_pattern(cx: &CrateContext,\n             }\n         }\n \n-        hir::PatQPath(..) => {\n+        PatKind::QPath(..) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n         }\n \n-        hir::PatStruct(_, ref field_pats, _) => {\n+        PatKind::Struct(_, ref field_pats, _) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             for &codemap::Spanned {\n@@ -264,31 +264,31 @@ fn walk_pattern(cx: &CrateContext,\n             }\n         }\n \n-        hir::PatTup(ref sub_pats) => {\n+        PatKind::Tup(ref sub_pats) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             for sub_pat in sub_pats {\n                 walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n             }\n         }\n \n-        hir::PatBox(ref sub_pat) | hir::PatRegion(ref sub_pat, _) => {\n+        PatKind::Box(ref sub_pat) | PatKind::Ref(ref sub_pat, _) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n             walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n         }\n \n-        hir::PatLit(ref exp) => {\n+        PatKind::Lit(ref exp) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n             walk_expr(cx, &exp, scope_stack, scope_map);\n         }\n \n-        hir::PatRange(ref exp1, ref exp2) => {\n+        PatKind::Range(ref exp1, ref exp2) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n             walk_expr(cx, &exp1, scope_stack, scope_map);\n             walk_expr(cx, &exp2, scope_stack, scope_map);\n         }\n \n-        hir::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n+        PatKind::Vec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             for sub_pat in front_sub_pats {"}, {"sha": "330d4077c4101ec78cbe82b3fb14e02c64a78cde", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -28,7 +28,7 @@ use middle::infer;\n use middle::pat_util;\n use middle::subst;\n use rustc::front::map as hir_map;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use trans::{type_of, adt, machine, monomorphize};\n use trans::common::{self, CrateContext, FunctionContext, Block};\n use trans::_match::{BindingInfo, TransBindingMode};\n@@ -1971,7 +1971,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         Some(hir_map::NodeLocal(pat)) => {\n             match pat.node {\n-                hir::PatIdent(_, ref path1, _) => {\n+                PatKind::Ident(_, ref path1, _) => {\n                     path1.node.name\n                 }\n                 _ => {"}, {"sha": "2803cbe4dd96df3a30f255ec681d5b93be36fb39", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -30,7 +30,7 @@ use syntax::ast;\n use syntax::codemap::{Span, Spanned};\n use syntax::ptr::P;\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::print::pprust;\n use rustc_front::util as hir_util;\n \n@@ -46,10 +46,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n            expected);\n \n     match pat.node {\n-        hir::PatWild => {\n+        PatKind::Wild => {\n             fcx.write_ty(pat.id, expected);\n         }\n-        hir::PatLit(ref lt) => {\n+        PatKind::Lit(ref lt) => {\n             check_expr(fcx, &lt);\n             let expr_ty = fcx.expr_ty(&lt);\n \n@@ -84,7 +84,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // that's equivalent to there existing a LUB.\n             demand::suptype(fcx, pat.span, expected, pat_ty);\n         }\n-        hir::PatRange(ref begin, ref end) => {\n+        PatKind::Range(ref begin, ref end) => {\n             check_expr(fcx, begin);\n             check_expr(fcx, end);\n \n@@ -135,9 +135,9 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // subtyping doesn't matter here, as the value is some kind of scalar\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n-        hir::PatEnum(..) | hir::PatIdent(..)\n+        PatKind::Enum(..) | PatKind::Ident(..)\n                 if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n-            if let hir::PatEnum(ref path, ref subpats) = pat.node {\n+            if let PatKind::Enum(ref path, ref subpats) = pat.node {\n                 if !(subpats.is_some() && subpats.as_ref().unwrap().is_empty()) {\n                     bad_struct_kind_err(tcx.sess, pat, path, false);\n                     return;\n@@ -154,15 +154,15 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n                 // FIXME(#20489) -- we should limit the types here to scalars or something!\n \n-                // As with PatLit, what we really want here is that there\n+                // As with PatKind::Lit, what we really want here is that there\n                 // exist a LUB, but for the cases that can occur, subtype\n                 // is good enough.\n                 demand::suptype(fcx, pat.span, expected, const_ty);\n             } else {\n                 fcx.write_error(pat.id);\n             }\n         }\n-        hir::PatIdent(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map.borrow(), pat) => {\n+        PatKind::Ident(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map.borrow(), pat) => {\n             let typ = fcx.local_ty(pat.span, pat.id);\n             match bm {\n                 hir::BindByRef(mutbl) => {\n@@ -202,16 +202,16 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 }\n             }\n         }\n-        hir::PatIdent(_, ref path, _) => {\n+        PatKind::Ident(_, ref path, _) => {\n             let path = hir_util::ident_to_path(path.span, path.node);\n             check_pat_enum(pcx, pat, &path, Some(&[]), expected, false);\n         }\n-        hir::PatEnum(ref path, ref subpats) => {\n+        PatKind::Enum(ref path, ref subpats) => {\n             let subpats = subpats.as_ref().map(|v| &v[..]);\n             let is_tuple_struct_pat = !(subpats.is_some() && subpats.unwrap().is_empty());\n             check_pat_enum(pcx, pat, path, subpats, expected, is_tuple_struct_pat);\n         }\n-        hir::PatQPath(ref qself, ref path) => {\n+        PatKind::QPath(ref qself, ref path) => {\n             let self_ty = fcx.to_ty(&qself.ty);\n             let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n                 if d.base_def == Def::Err {\n@@ -248,10 +248,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 }\n             }\n         }\n-        hir::PatStruct(ref path, ref fields, etc) => {\n+        PatKind::Struct(ref path, ref fields, etc) => {\n             check_pat_struct(pcx, pat, path, fields, etc, expected);\n         }\n-        hir::PatTup(ref elements) => {\n+        PatKind::Tup(ref elements) => {\n             let element_tys: Vec<_> =\n                 (0..elements.len()).map(|_| fcx.infcx().next_ty_var())\n                                         .collect();\n@@ -262,7 +262,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 check_pat(pcx, &element_pat, element_ty);\n             }\n         }\n-        hir::PatBox(ref inner) => {\n+        PatKind::Box(ref inner) => {\n             let inner_ty = fcx.infcx().next_ty_var();\n             let uniq_ty = tcx.mk_box(inner_ty);\n \n@@ -278,7 +278,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 check_pat(pcx, &inner, tcx.types.err);\n             }\n         }\n-        hir::PatRegion(ref inner, mutbl) => {\n+        PatKind::Ref(ref inner, mutbl) => {\n             let expected = fcx.infcx().shallow_resolve(expected);\n             if check_dereferencable(pcx, pat.span, expected, &inner) {\n                 // `demand::subtype` would be good enough, but using\n@@ -310,7 +310,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 check_pat(pcx, &inner, tcx.types.err);\n             }\n         }\n-        hir::PatVec(ref before, ref slice, ref after) => {\n+        PatKind::Vec(ref before, ref slice, ref after) => {\n             let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n             let inner_ty = fcx.infcx().next_ty_var();\n             let pat_ty = match expected_ty.sty {"}, {"sha": "208c166dedf1902e03a9ffb1d4003671e037d7dc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -127,7 +127,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n \n use rustc_front::intravisit::{self, Visitor};\n use rustc_front::hir;\n-use rustc_front::hir::Visibility;\n+use rustc_front::hir::{Visibility, PatKind};\n use rustc_front::print::pprust;\n use rustc_back::slice;\n \n@@ -506,7 +506,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n-        if let hir::PatIdent(_, ref path1, _) = p.node {\n+        if let PatKind::Ident(_, ref path1, _) = p.node {\n             if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map.borrow(), p) {\n                 let var_ty = self.assign(p.span, p.id, None);\n "}, {"sha": "e399818779ecf60dff659d59e07a2177aa752e4f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -101,7 +101,7 @@ use std::mem;\n use syntax::ast;\n use syntax::codemap::Span;\n use rustc_front::intravisit::{self, Visitor};\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::util as hir_util;\n \n use self::SubjectNode::Subject;\n@@ -1190,14 +1190,14 @@ fn link_pattern<'t, 'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     let _ = mc.cat_pattern(discr_cmt, root_pat, |mc, sub_cmt, sub_pat| {\n             match sub_pat.node {\n                 // `ref x` pattern\n-                hir::PatIdent(hir::BindByRef(mutbl), _, _) => {\n+                PatKind::Ident(hir::BindByRef(mutbl), _, _) => {\n                     link_region_from_node_type(\n                         rcx, sub_pat.span, sub_pat.id,\n                         mutbl, sub_cmt);\n                 }\n \n                 // `[_, ..slice, _]` pattern\n-                hir::PatVec(_, Some(ref slice_pat), _) => {\n+                PatKind::Vec(_, Some(ref slice_pat), _) => {\n                     match mc.cat_slice_pattern(sub_cmt, &slice_pat) {\n                         Ok((slice_cmt, slice_mutbl, slice_r)) => {\n                             link_region(rcx, sub_pat.span, &slice_r,"}, {"sha": "026881927cb21e5678f230aa4d283b9d771a7fdd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -90,7 +90,7 @@ use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n use syntax::ptr::P;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::intravisit;\n use rustc_front::print::pprust;\n \n@@ -2121,8 +2121,8 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n {\n     for i in &decl.inputs {\n         match i.pat.node {\n-            hir::PatIdent(_, _, _) => (),\n-            hir::PatWild => (),\n+            PatKind::Ident(_, _, _) => (),\n+            PatKind::Wild => (),\n             _ => {\n                 span_err!(ccx.tcx.sess, i.pat.span, E0130,\n                           \"patterns aren't allowed in foreign function declarations\");"}, {"sha": "772652eace5ba128b9df78bc119f7e2974d4717d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b40e1e5b3d75c101b1ad78a1e2160962e955174/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9b40e1e5b3d75c101b1ad78a1e2160962e955174", "patch": "@@ -2552,31 +2552,31 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     debug!(\"Trying to get a name from pattern: {:?}\", p);\n \n     match p.node {\n-        PatWild => \"_\".to_string(),\n-        PatIdent(_, ref p, _) => p.node.to_string(),\n-        PatEnum(ref p, _) => path_to_string(p),\n-        PatQPath(..) => panic!(\"tried to get argument name from PatQPath, \\\n+        PatKind::Wild => \"_\".to_string(),\n+        PatKind::Ident(_, ref p, _) => p.node.to_string(),\n+        PatKind::Enum(ref p, _) => path_to_string(p),\n+        PatKind::QPath(..) => panic!(\"tried to get argument name from PatKind::QPath, \\\n                                 which is not allowed in function arguments\"),\n-        PatStruct(ref name, ref fields, etc) => {\n+        PatKind::Struct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", path_to_string(name),\n                 fields.iter().map(|&Spanned { node: ref fp, .. }|\n                                   format!(\"{}: {}\", fp.name, name_from_pat(&*fp.pat)))\n                              .collect::<Vec<String>>().join(\", \"),\n                 if etc { \", ...\" } else { \"\" }\n             )\n         },\n-        PatTup(ref elts) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n+        PatKind::Tup(ref elts) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n                                             .collect::<Vec<String>>().join(\", \")),\n-        PatBox(ref p) => name_from_pat(&**p),\n-        PatRegion(ref p, _) => name_from_pat(&**p),\n-        PatLit(..) => {\n-            warn!(\"tried to get argument name from PatLit, \\\n+        PatKind::Box(ref p) => name_from_pat(&**p),\n+        PatKind::Ref(ref p, _) => name_from_pat(&**p),\n+        PatKind::Lit(..) => {\n+            warn!(\"tried to get argument name from PatKind::Lit, \\\n                   which is silly in function arguments\");\n             \"()\".to_string()\n         },\n-        PatRange(..) => panic!(\"tried to get argument name from PatRange, \\\n+        PatKind::Range(..) => panic!(\"tried to get argument name from PatKind::Range, \\\n                               which is not allowed in function arguments\"),\n-        PatVec(ref begin, ref mid, ref end) => {\n+        PatKind::Vec(ref begin, ref mid, ref end) => {\n             let begin = begin.iter().map(|p| name_from_pat(&**p));\n             let mid = mid.as_ref().map(|p| format!(\"..{}\", name_from_pat(&**p))).into_iter();\n             let end = end.iter().map(|p| name_from_pat(&**p));"}]}