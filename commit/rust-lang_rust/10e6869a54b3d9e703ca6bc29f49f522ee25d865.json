{"sha": "10e6869a54b3d9e703ca6bc29f49f522ee25d865", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwZTY4NjlhNTRiM2Q5ZTcwM2NhNmJjMjlmNDlmNTIyZWUyNWQ4NjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-19T16:48:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-19T16:48:50Z"}, "message": "auto merge of #5955 : thestinger/rust/iterator, r=graydon", "tree": {"sha": "5903ec74a560e2bdd6a12ccb1e19d908eda9930e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5903ec74a560e2bdd6a12ccb1e19d908eda9930e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10e6869a54b3d9e703ca6bc29f49f522ee25d865", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10e6869a54b3d9e703ca6bc29f49f522ee25d865", "html_url": "https://github.com/rust-lang/rust/commit/10e6869a54b3d9e703ca6bc29f49f522ee25d865", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10e6869a54b3d9e703ca6bc29f49f522ee25d865/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "465666d5c85fd4b97551bd1caa5fdc9bc59bd10b", "url": "https://api.github.com/repos/rust-lang/rust/commits/465666d5c85fd4b97551bd1caa5fdc9bc59bd10b", "html_url": "https://github.com/rust-lang/rust/commit/465666d5c85fd4b97551bd1caa5fdc9bc59bd10b"}, {"sha": "a2e535028471b715b5a3aaf7cbeb3e6d77a07af6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2e535028471b715b5a3aaf7cbeb3e6d77a07af6", "html_url": "https://github.com/rust-lang/rust/commit/a2e535028471b715b5a3aaf7cbeb3e6d77a07af6"}], "stats": {"total": 312, "additions": 251, "deletions": 61}, "files": [{"sha": "4929b1b8dba377a54a890760578a3caaae088771", "filename": "src/libcore/iterator.rs", "status": "modified", "additions": 251, "deletions": 23, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/10e6869a54b3d9e703ca6bc29f49f522ee25d865/src%2Flibcore%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e6869a54b3d9e703ca6bc29f49f522ee25d865/src%2Flibcore%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiterator.rs?ref=10e6869a54b3d9e703ca6bc29f49f522ee25d865", "patch": "@@ -8,7 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Composable iterator objects\n+/*! Composable external iterators\n+\n+The `Iterator` trait defines an interface for objects which implement iteration as a state machine.\n+\n+Algorithms like `zip` are provided as `Iterator` implementations which wrap other objects\n+implementing the `Iterator` trait.\n+\n+*/\n \n use prelude::*;\n \n@@ -17,18 +24,34 @@ pub trait Iterator<A> {\n     fn next(&mut self) -> Option<A>;\n }\n \n+/// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n+/// implementations of the `Iterator` trait.\n+///\n+/// In the future these will be default methods instead of a utility trait.\n pub trait IteratorUtil<A> {\n+    fn chain(self, other: Self) -> ChainIterator<Self>;\n     fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<Self, U>;\n     // FIXME: #5898: should be called map\n     fn transform<'r, B>(self, f: &'r fn(A) -> B) -> MapIterator<'r, A, B, Self>;\n     fn filter<'r>(self, predicate: &'r fn(&A) -> bool) -> FilterIterator<'r, A, Self>;\n-    fn dropwhile<'r>(self, predicate: &'r fn(&A) -> bool) -> DropWhileIterator<'r, A, Self>;\n-    fn takewhile<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhileIterator<'r, A, Self>;\n     fn enumerate(self) -> EnumerateIterator<Self>;\n+    fn skip_while<'r>(self, predicate: &'r fn(&A) -> bool) -> SkipWhileIterator<'r, A, Self>;\n+    fn take_while<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhileIterator<'r, A, Self>;\n+    fn skip(self, n: uint) -> SkipIterator<Self>;\n+    fn take(self, n: uint) -> TakeIterator<Self>;\n     fn advance(&mut self, f: &fn(A) -> bool);\n }\n \n+/// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n+/// implementations of the `Iterator` trait.\n+///\n+/// In the future these will be default methods instead of a utility trait.\n impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n+    #[inline(always)]\n+    fn chain(self, other: T) -> ChainIterator<T> {\n+        ChainIterator{a: self, b: other, flag: false}\n+    }\n+\n     #[inline(always)]\n     fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<T, U> {\n         ZipIterator{a: self, b: other}\n@@ -51,15 +74,25 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n \n     #[inline(always)]\n-    fn dropwhile<'r>(self, predicate: &'r fn(&A) -> bool) -> DropWhileIterator<'r, A, T> {\n-        DropWhileIterator{iter: self, flag: false, predicate: predicate}\n+    fn skip_while<'r>(self, predicate: &'r fn(&A) -> bool) -> SkipWhileIterator<'r, A, T> {\n+        SkipWhileIterator{iter: self, flag: false, predicate: predicate}\n     }\n \n     #[inline(always)]\n-    fn takewhile<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhileIterator<'r, A, T> {\n+    fn take_while<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhileIterator<'r, A, T> {\n         TakeWhileIterator{iter: self, flag: false, predicate: predicate}\n     }\n \n+    #[inline(always)]\n+    fn skip(self, n: uint) -> SkipIterator<T> {\n+        SkipIterator{iter: self, n: n}\n+    }\n+\n+    #[inline(always)]\n+    fn take(self, n: uint) -> TakeIterator<T> {\n+        TakeIterator{iter: self, n: n}\n+    }\n+\n     /// A shim implementing the `for` loop iteration protocol for iterator objects\n     #[inline]\n     fn advance(&mut self, f: &fn(A) -> bool) {\n@@ -74,6 +107,28 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n }\n \n+pub struct ChainIterator<T> {\n+    priv a: T,\n+    priv b: T,\n+    priv flag: bool\n+}\n+\n+impl<A, T: Iterator<A>> Iterator<A> for ChainIterator<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        if self.flag {\n+            self.b.next()\n+        } else {\n+            match self.a.next() {\n+                Some(x) => return Some(x),\n+                _ => ()\n+            }\n+            self.flag = true;\n+            self.b.next()\n+        }\n+    }\n+}\n+\n pub struct ZipIterator<T, U> {\n     priv a: T,\n     priv b: U\n@@ -89,6 +144,21 @@ impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for ZipIterator<T, U\n     }\n }\n \n+pub struct MapIterator<'self, A, B, T> {\n+    priv iter: T,\n+    priv f: &'self fn(A) -> B\n+}\n+\n+impl<'self, A, B, T: Iterator<A>> Iterator<B> for MapIterator<'self, A, B, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        match self.iter.next() {\n+            Some(a) => Some((self.f)(a)),\n+            _ => None\n+        }\n+    }\n+}\n+\n pub struct FilterIterator<'self, A, T> {\n     priv iter: T,\n     priv predicate: &'self fn(&A) -> bool\n@@ -108,21 +178,6 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for FilterIterator<'self, A, T> {\n     }\n }\n \n-pub struct MapIterator<'self, A, B, T> {\n-    priv iter: T,\n-    priv f: &'self fn(A) -> B\n-}\n-\n-impl<'self, A, B, T: Iterator<A>> Iterator<B> for MapIterator<'self, A, B, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        match self.iter.next() {\n-            Some(a) => Some((self.f)(a)),\n-            _ => None\n-        }\n-    }\n-}\n-\n pub struct EnumerateIterator<T> {\n     priv iter: T,\n     priv count: uint\n@@ -142,13 +197,13 @@ impl<A, T: Iterator<A>> Iterator<(uint, A)> for EnumerateIterator<T> {\n     }\n }\n \n-pub struct DropWhileIterator<'self, A, T> {\n+pub struct SkipWhileIterator<'self, A, T> {\n     priv iter: T,\n     priv flag: bool,\n     priv predicate: &'self fn(&A) -> bool\n }\n \n-impl<'self, A, T: Iterator<A>> Iterator<A> for DropWhileIterator<'self, A, T> {\n+impl<'self, A, T: Iterator<A>> Iterator<A> for SkipWhileIterator<'self, A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         let mut next = self.iter.next();\n@@ -199,3 +254,176 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for TakeWhileIterator<'self, A, T> {\n         }\n     }\n }\n+\n+pub struct SkipIterator<T> {\n+    priv iter: T,\n+    priv n: uint\n+}\n+\n+impl<A, T: Iterator<A>> Iterator<A> for SkipIterator<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let mut next = self.iter.next();\n+        if self.n == 0 {\n+            next\n+        } else {\n+            let n = self.n;\n+            for n.times {\n+                match next {\n+                    Some(_) => {\n+                        next = self.iter.next();\n+                        loop\n+                    }\n+                    None => {\n+                        self.n = 0;\n+                        return None\n+                    }\n+                }\n+            }\n+            self.n = 0;\n+            next\n+        }\n+    }\n+}\n+\n+pub struct TakeIterator<T> {\n+    priv iter: T,\n+    priv n: uint\n+}\n+\n+impl<A, T: Iterator<A>> Iterator<A> for TakeIterator<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let next = self.iter.next();\n+        if self.n != 0 {\n+            self.n -= 1;\n+            next\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+pub struct UnfoldrIterator<'self, A, St> {\n+    priv f: &'self fn(&mut St) -> Option<A>,\n+    priv state: St\n+}\n+\n+pub impl<'self, A, St> UnfoldrIterator<'self, A, St> {\n+    #[inline]\n+    fn new(f: &'self fn(&mut St) -> Option<A>, initial_state: St) -> UnfoldrIterator<'self, A, St> {\n+        UnfoldrIterator {\n+            f: f,\n+            state: initial_state\n+        }\n+    }\n+}\n+\n+impl<'self, A, St> Iterator<A> for UnfoldrIterator<'self, A, St> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        (self.f)(&mut self.state)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::*;\n+\n+    #[test]\n+    fn test_iterator_chain() {\n+        let xs = [0u, 1, 2, 3, 4, 5];\n+        let ys = [30, 40, 50, 60];\n+        let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n+        let mut it = xs.iter().chain(ys.iter());\n+        let mut i = 0;\n+        for it.advance |&x: &uint| {\n+            assert_eq!(x, expected[i]);\n+            i += 1;\n+        }\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_iterator_enumerate() {\n+        let xs = [0u, 1, 2, 3, 4, 5];\n+        let mut it = xs.iter().enumerate();\n+        for it.advance |(i, &x): (uint, &uint)| {\n+            assert_eq!(i, x);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_iterator_take_while() {\n+        let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+        let ys = [0u, 1, 2, 3, 5, 13];\n+        let mut it = xs.iter().take_while(|&x| *x < 15u);\n+        let mut i = 0;\n+        for it.advance |&x: &uint| {\n+            assert_eq!(x, ys[i]);\n+            i += 1;\n+        }\n+        assert_eq!(i, ys.len());\n+    }\n+\n+    #[test]\n+    fn test_iterator_skip_while() {\n+        let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+        let ys = [15, 16, 17, 19];\n+        let mut it = xs.iter().skip_while(|&x| *x < 15u);\n+        let mut i = 0;\n+        for it.advance |&x: &uint| {\n+            assert_eq!(x, ys[i]);\n+            i += 1;\n+        }\n+        assert_eq!(i, ys.len());\n+    }\n+\n+    #[test]\n+    fn test_iterator_skip() {\n+        let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+        let ys = [13, 15, 16, 17, 19, 20, 30];\n+        let mut it = xs.iter().skip(5);\n+        let mut i = 0;\n+        for it.advance |&x: &uint| {\n+            assert_eq!(x, ys[i]);\n+            i += 1;\n+        }\n+        assert_eq!(i, ys.len());\n+    }\n+\n+    #[test]\n+    fn test_iterator_take() {\n+        let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+        let ys = [0u, 1, 2, 3, 5];\n+        let mut it = xs.iter().take(5);\n+        let mut i = 0;\n+        for it.advance |&x: &uint| {\n+            assert_eq!(x, ys[i]);\n+            i += 1;\n+        }\n+        assert_eq!(i, ys.len());\n+    }\n+\n+    #[test]\n+    fn test_unfoldr() {\n+        fn count(st: &mut uint) -> Option<uint> {\n+            if *st < 10 {\n+                let ret = Some(*st);\n+                *st += 1;\n+                ret\n+            } else {\n+                None\n+            }\n+        }\n+\n+        let mut it = UnfoldrIterator::new(count, 0);\n+        let mut i = 0;\n+        for it.advance |counted| {\n+            assert_eq!(counted, i);\n+            i += 1;\n+        }\n+        assert_eq!(i, 10);\n+    }\n+}"}, {"sha": "139fcedad2779e15eae109b90cc9f0c898a58f9a", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/10e6869a54b3d9e703ca6bc29f49f522ee25d865/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10e6869a54b3d9e703ca6bc29f49f522ee25d865/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=10e6869a54b3d9e703ca6bc29f49f522ee25d865", "patch": "@@ -4474,42 +4474,4 @@ mod tests {\n             i += 1;\n         }\n     }\n-\n-    #[test]\n-    fn test_iterator_enumerate() {\n-        use iterator::*;\n-        let xs = [0u, 1, 2, 3, 4, 5];\n-        let mut it = xs.iter().enumerate();\n-        for it.advance |(i, &x): (uint, &uint)| {\n-            assert_eq!(i, x);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_iterator_takewhile() {\n-        use iterator::*;\n-        let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n-        let ys = [0u, 1, 2, 3, 5, 13];\n-        let mut it = xs.iter().takewhile(|&x| *x < 15u);\n-        let mut i = 0;\n-        for it.advance |&x: &uint| {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, ys.len());\n-    }\n-\n-    #[test]\n-    fn test_iterator_dropwhile() {\n-        use iterator::*;\n-        let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n-        let ys = [15, 16, 17, 19];\n-        let mut it = xs.iter().dropwhile(|&x| *x < 15u);\n-        let mut i = 0;\n-        for it.advance |&x: &uint| {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, ys.len());\n-    }\n }"}]}