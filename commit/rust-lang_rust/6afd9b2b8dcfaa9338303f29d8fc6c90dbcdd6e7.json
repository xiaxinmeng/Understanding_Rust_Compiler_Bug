{"sha": "6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZmQ5YjJiOGRjZmFhOTMzODMwM2YyOWQ4ZmM2YzkwZGJjZGQ2ZTc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-11T17:47:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-11T17:47:45Z"}, "message": "Merge #8796\n\n8796: internal: rewrite `#[derive]` removal to be based on AST (take 2) r=jonas-schievink a=jonas-schievink\n\nSecond attempt of https://github.com/rust-analyzer/rust-analyzer/pull/8443, this uses syntactical attribute offsets in `hir_expand`, and changes `attr.rs` to make those easy to derive.\r\n\r\nThis will make it easy to add similar attribute removal for attribute macros, unblocking them.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "b1534743851c3805c64fe764f9d0bf8f7ab9f7ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1534743851c3805c64fe764f9d0bf8f7ab9f7ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgmsNCCRBK7hj4Ov3rIwAAcf0IAJtF7lzp/UGWD1qJTgCxs2f3\natOSCFs3Rc5N91QTjf7JT0s8InrAqx6q5tl7lTMfySSNwyGL4vaG5aULB5v77Ya4\nbMCSRCAgD+bHvj9LqbN3TMMrkqwAWWdOWA7Hoc6zPcV0fWxChHWrpyyYxvsQ48C4\nE15nZKE+FrgpQv3rqklkgWQ1Y7pWLWg9WC2DRI0JzDbhTigy6Xw3WCWzvObr1tRc\nbTFgRYy9D7jQBIEu06phGedYH0sfQTZYr41qpctMw/pAInmUsKBmf5+2HXYc/0hJ\n5IImQs7npWYQdMi2QYDlSVYQJsT97HEyyQhvL1TMOqDAVSmtV9JvHp92tq+ExLk=\n=82jI\n-----END PGP SIGNATURE-----\n", "payload": "tree b1534743851c3805c64fe764f9d0bf8f7ab9f7ef\nparent 9fa9d166d8141bb9ca4fcf0544c49b903fb85e09\nparent 8ea9d939d2c44feb71e2d1c8ec390a9471b75e57\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1620755265 +0000\ncommitter GitHub <noreply@github.com> 1620755265 +0000\n\nMerge #8796\n\n8796: internal: rewrite `#[derive]` removal to be based on AST (take 2) r=jonas-schievink a=jonas-schievink\n\nSecond attempt of https://github.com/rust-analyzer/rust-analyzer/pull/8443, this uses syntactical attribute offsets in `hir_expand`, and changes `attr.rs` to make those easy to derive.\r\n\r\nThis will make it easy to add similar attribute removal for attribute macros, unblocking them.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7", "html_url": "https://github.com/rust-lang/rust/commit/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fa9d166d8141bb9ca4fcf0544c49b903fb85e09", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fa9d166d8141bb9ca4fcf0544c49b903fb85e09", "html_url": "https://github.com/rust-lang/rust/commit/9fa9d166d8141bb9ca4fcf0544c49b903fb85e09"}, {"sha": "8ea9d939d2c44feb71e2d1c8ec390a9471b75e57", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ea9d939d2c44feb71e2d1c8ec390a9471b75e57", "html_url": "https://github.com/rust-lang/rust/commit/8ea9d939d2c44feb71e2d1c8ec390a9471b75e57"}], "stats": {"total": 380, "additions": 205, "deletions": 175}, "files": [{"sha": "aadd4e44ae7c60442a8d2c218ecd3b980e7f1422", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 86, "deletions": 58, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7", "patch": "@@ -9,7 +9,7 @@ use std::{\n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n-use hir_expand::{hygiene::Hygiene, name::AsName, AstId, AttrId, InFile};\n+use hir_expand::{hygiene::Hygiene, name::AsName, AstId, InFile};\n use itertools::Itertools;\n use la_arena::ArenaMap;\n use mbe::ast_to_token_tree;\n@@ -101,17 +101,13 @@ impl RawAttrs {\n         hygiene: &Hygiene,\n     ) -> Self {\n         let entries = collect_attrs(owner)\n-            .enumerate()\n-            .flat_map(|(i, attr)| {\n-                let index = AttrId(i as u32);\n-                match attr {\n-                    Either::Left(attr) => Attr::from_src(db, attr, hygiene, index),\n-                    Either::Right(comment) => comment.doc_comment().map(|doc| Attr {\n-                        id: index,\n-                        input: Some(AttrInput::Literal(SmolStr::new(doc))),\n-                        path: Interned::new(ModPath::from(hir_expand::name!(doc))),\n-                    }),\n-                }\n+            .flat_map(|(id, attr)| match attr {\n+                Either::Left(attr) => Attr::from_src(db, attr, hygiene, id),\n+                Either::Right(comment) => comment.doc_comment().map(|doc| Attr {\n+                    id,\n+                    input: Some(AttrInput::Literal(SmolStr::new(doc))),\n+                    path: Interned::new(ModPath::from(hir_expand::name!(doc))),\n+                }),\n             })\n             .collect::<Arc<_>>();\n \n@@ -124,6 +120,7 @@ impl RawAttrs {\n     }\n \n     pub(crate) fn merge(&self, other: Self) -> Self {\n+        // FIXME: This needs to fixup `AttrId`s\n         match (&self.entries, &other.entries) {\n             (None, None) => Self::EMPTY,\n             (Some(entries), None) | (None, Some(entries)) => {\n@@ -375,39 +372,26 @@ impl AttrsWithOwner {\n \n                 let def_map = module.def_map(db);\n                 let mod_data = &def_map[module.local_id];\n-                let attrs = match mod_data.declaration_source(db) {\n+                match mod_data.declaration_source(db) {\n                     Some(it) => {\n-                        let mut attrs: Vec<_> = collect_attrs(&it.value as &dyn ast::AttrsOwner)\n-                            .map(|attr| InFile::new(it.file_id, attr))\n-                            .collect();\n+                        let mut map = AttrSourceMap::new(InFile::new(it.file_id, &it.value));\n                         if let InFile { file_id, value: ModuleSource::SourceFile(file) } =\n                             mod_data.definition_source(db)\n                         {\n-                            attrs.extend(\n-                                collect_attrs(&file as &dyn ast::AttrsOwner)\n-                                    .map(|attr| InFile::new(file_id, attr)),\n-                            )\n+                            map.merge(AttrSourceMap::new(InFile::new(file_id, &file)));\n                         }\n-                        attrs\n+                        return map;\n                     }\n                     None => {\n                         let InFile { file_id, value } = mod_data.definition_source(db);\n-                        match &value {\n-                            ModuleSource::SourceFile(file) => {\n-                                collect_attrs(file as &dyn ast::AttrsOwner)\n-                            }\n-                            ModuleSource::Module(module) => {\n-                                collect_attrs(module as &dyn ast::AttrsOwner)\n-                            }\n-                            ModuleSource::BlockExpr(block) => {\n-                                collect_attrs(block as &dyn ast::AttrsOwner)\n-                            }\n-                        }\n-                        .map(|attr| InFile::new(file_id, attr))\n-                        .collect()\n+                        let attrs_owner = match &value {\n+                            ModuleSource::SourceFile(file) => file as &dyn ast::AttrsOwner,\n+                            ModuleSource::Module(module) => module as &dyn ast::AttrsOwner,\n+                            ModuleSource::BlockExpr(block) => block as &dyn ast::AttrsOwner,\n+                        };\n+                        return AttrSourceMap::new(InFile::new(file_id, attrs_owner));\n                     }\n-                };\n-                return AttrSourceMap { attrs };\n+                }\n             }\n             AttrDefId::FieldId(id) => {\n                 let map = db.fields_attrs_source_map(id.parent);\n@@ -462,11 +446,7 @@ impl AttrsWithOwner {\n             },\n         };\n \n-        AttrSourceMap {\n-            attrs: collect_attrs(&owner.value)\n-                .map(|attr| InFile::new(owner.file_id, attr))\n-                .collect(),\n-        }\n+        AttrSourceMap::new(owner.as_ref().map(|node| node as &dyn AttrsOwner))\n     }\n \n     pub fn docs_with_rangemap(\n@@ -518,7 +498,7 @@ impl AttrsWithOwner {\n         if buf.is_empty() {\n             None\n         } else {\n-            Some((Documentation(buf), DocsRangeMap { mapping, source: self.source_map(db).attrs }))\n+            Some((Documentation(buf), DocsRangeMap { mapping, source_map: self.source_map(db) }))\n         }\n     }\n }\n@@ -559,27 +539,59 @@ fn inner_attributes(\n }\n \n pub struct AttrSourceMap {\n-    attrs: Vec<InFile<Either<ast::Attr, ast::Comment>>>,\n+    attrs: Vec<InFile<ast::Attr>>,\n+    doc_comments: Vec<InFile<ast::Comment>>,\n }\n \n impl AttrSourceMap {\n+    fn new(owner: InFile<&dyn ast::AttrsOwner>) -> Self {\n+        let mut attrs = Vec::new();\n+        let mut doc_comments = Vec::new();\n+        for (_, attr) in collect_attrs(owner.value) {\n+            match attr {\n+                Either::Left(attr) => attrs.push(owner.with_value(attr)),\n+                Either::Right(comment) => doc_comments.push(owner.with_value(comment)),\n+            }\n+        }\n+\n+        Self { attrs, doc_comments }\n+    }\n+\n+    fn merge(&mut self, other: Self) {\n+        self.attrs.extend(other.attrs);\n+        self.doc_comments.extend(other.doc_comments);\n+    }\n+\n     /// Maps the lowered `Attr` back to its original syntax node.\n     ///\n     /// `attr` must come from the `owner` used for AttrSourceMap\n     ///\n     /// Note that the returned syntax node might be a `#[cfg_attr]`, or a doc comment, instead of\n     /// the attribute represented by `Attr`.\n-    pub fn source_of(&self, attr: &Attr) -> InFile<&Either<ast::Attr, ast::Comment>> {\n-        self.attrs\n-            .get(attr.id.0 as usize)\n-            .unwrap_or_else(|| panic!(\"cannot find `Attr` at index {:?}\", attr.id))\n-            .as_ref()\n+    pub fn source_of(&self, attr: &Attr) -> InFile<Either<ast::Attr, ast::Comment>> {\n+        self.source_of_id(attr.id)\n+    }\n+\n+    fn source_of_id(&self, id: AttrId) -> InFile<Either<ast::Attr, ast::Comment>> {\n+        if id.is_doc_comment {\n+            self.doc_comments\n+                .get(id.ast_index as usize)\n+                .unwrap_or_else(|| panic!(\"cannot find doc comment at index {:?}\", id))\n+                .clone()\n+                .map(|attr| Either::Right(attr))\n+        } else {\n+            self.attrs\n+                .get(id.ast_index as usize)\n+                .unwrap_or_else(|| panic!(\"cannot find `Attr` at index {:?}\", id))\n+                .clone()\n+                .map(|attr| Either::Left(attr))\n+        }\n     }\n }\n \n /// A struct to map text ranges from [`Documentation`] back to TextRanges in the syntax tree.\n pub struct DocsRangeMap {\n-    source: Vec<InFile<Either<ast::Attr, ast::Comment>>>,\n+    source_map: AttrSourceMap,\n     // (docstring-line-range, attr_index, attr-string-range)\n     // a mapping from the text range of a line of the [`Documentation`] to the attribute index and\n     // the original (untrimmed) syntax doc line\n@@ -596,7 +608,7 @@ impl DocsRangeMap {\n \n         let relative_range = range - line_docs_range.start();\n \n-        let &InFile { file_id, value: ref source } = &self.source[idx.0 as usize];\n+        let &InFile { file_id, value: ref source } = &self.source_map.source_of_id(idx);\n         match source {\n             Either::Left(_) => None, // FIXME, figure out a nice way to handle doc attributes here\n             // as well as for whats done in syntax highlight doc injection\n@@ -615,6 +627,12 @@ impl DocsRangeMap {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct AttrId {\n+    is_doc_comment: bool,\n+    pub(crate) ast_index: u32,\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Attr {\n     pub(crate) id: AttrId,\n@@ -749,22 +767,32 @@ fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase\n \n fn collect_attrs(\n     owner: &dyn ast::AttrsOwner,\n-) -> impl Iterator<Item = Either<ast::Attr, ast::Comment>> {\n+) -> impl Iterator<Item = (AttrId, Either<ast::Attr, ast::Comment>)> {\n     let (inner_attrs, inner_docs) = inner_attributes(owner.syntax())\n         .map_or((None, None), |(attrs, docs)| (Some(attrs), Some(docs)));\n \n     let outer_attrs = owner.attrs().filter(|attr| attr.kind().is_outer());\n-    let attrs = outer_attrs\n-        .chain(inner_attrs.into_iter().flatten())\n-        .map(|attr| (attr.syntax().text_range().start(), Either::Left(attr)));\n+    let attrs =\n+        outer_attrs.chain(inner_attrs.into_iter().flatten()).enumerate().map(|(idx, attr)| {\n+            (\n+                AttrId { ast_index: idx as u32, is_doc_comment: false },\n+                attr.syntax().text_range().start(),\n+                Either::Left(attr),\n+            )\n+        });\n \n     let outer_docs =\n         ast::CommentIter::from_syntax_node(owner.syntax()).filter(ast::Comment::is_outer);\n-    let docs = outer_docs\n-        .chain(inner_docs.into_iter().flatten())\n-        .map(|docs_text| (docs_text.syntax().text_range().start(), Either::Right(docs_text)));\n+    let docs =\n+        outer_docs.chain(inner_docs.into_iter().flatten()).enumerate().map(|(idx, docs_text)| {\n+            (\n+                AttrId { ast_index: idx as u32, is_doc_comment: true },\n+                docs_text.syntax().text_range().start(),\n+                Either::Right(docs_text),\n+            )\n+        });\n     // sort here by syntax node offset because the source can have doc attributes and doc strings be interleaved\n-    docs.chain(attrs).sorted_by_key(|&(offset, _)| offset).map(|(_, attr)| attr)\n+    docs.chain(attrs).sorted_by_key(|&(_, offset, _)| offset).map(|(id, _, attr)| (id, attr))\n }\n \n pub(crate) fn variants_attrs_source_map("}, {"sha": "a82ea5957e9943e12d6ae4388b43f8b796784984", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7", "patch": "@@ -62,14 +62,14 @@ use hir_expand::{\n     ast_id_map::FileAstId,\n     eager::{expand_eager_macro, ErrorEmitted, ErrorSink},\n     hygiene::Hygiene,\n-    AstId, AttrId, FragmentKind, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId,\n-    MacroDefKind,\n+    AstId, FragmentKind, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use la_arena::Idx;\n use nameres::DefMap;\n use path::ModPath;\n use syntax::ast;\n \n+use crate::attr::AttrId;\n use crate::builtin_type::BuiltinType;\n use item_tree::{\n     Const, Enum, Function, Impl, ItemTreeId, ItemTreeNode, ModItem, Static, Struct, Trait,\n@@ -753,7 +753,7 @@ fn derive_macro_as_call_id(\n             MacroCallKind::Derive {\n                 ast_id: item_attr.ast_id,\n                 derive_name: last_segment.to_string(),\n-                derive_attr,\n+                derive_attr_index: derive_attr.ast_index,\n             },\n         )\n         .into();"}, {"sha": "adfb78c942f8c34c32909b40595175f44ed0da75", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7", "patch": "@@ -13,14 +13,14 @@ use hir_expand::{\n     builtin_macro::find_builtin_macro,\n     name::{AsName, Name},\n     proc_macro::ProcMacroExpander,\n-    AttrId, FragmentKind, HirFileId, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+    FragmentKind, HirFileId, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use hir_expand::{InFile, MacroCallLoc};\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast;\n \n use crate::{\n-    attr::Attrs,\n+    attr::{AttrId, Attrs},\n     db::DefDatabase,\n     derive_macro_as_call_id,\n     intern::Interned,"}, {"sha": "b6a6d602f7f2727ab65498b0a63a556a8bef7e10", "filename": "crates/hir_expand/src/builtin_derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7", "patch": "@@ -269,7 +269,7 @@ mod tests {\n     use expect_test::{expect, Expect};\n     use name::AsName;\n \n-    use crate::{test_db::TestDB, AstId, AttrId, MacroCallId, MacroCallKind, MacroCallLoc};\n+    use crate::{test_db::TestDB, AstId, MacroCallId, MacroCallKind, MacroCallLoc};\n \n     use super::*;\n \n@@ -320,7 +320,7 @@ $0\n             kind: MacroCallKind::Derive {\n                 ast_id,\n                 derive_name: name.to_string(),\n-                derive_attr: AttrId(0),\n+                derive_attr_index: 0,\n             },\n         };\n "}, {"sha": "9fa419fcf149eaf3f1773349ac4e57831f9040bd", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7", "patch": "@@ -12,9 +12,9 @@ use syntax::{\n };\n \n use crate::{\n-    ast_id_map::AstIdMap, hygiene::HygieneFrame, BuiltinDeriveExpander, BuiltinFnLikeExpander,\n-    EagerCallLoc, EagerMacroId, HirFileId, HirFileIdRepr, LazyMacroId, MacroCallId, MacroCallLoc,\n-    MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n+    ast_id_map::AstIdMap, hygiene::HygieneFrame, input::process_macro_input, BuiltinDeriveExpander,\n+    BuiltinFnLikeExpander, EagerCallLoc, EagerMacroId, HirFileId, HirFileIdRepr, LazyMacroId,\n+    MacroCallId, MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n };\n \n /// Total limit on the number of tokens produced by any macro invocation.\n@@ -281,6 +281,7 @@ fn macro_arg_text(db: &dyn AstDatabase, id: MacroCallId) -> Option<GreenNode> {\n     };\n     let loc = db.lookup_intern_macro(id);\n     let arg = loc.kind.arg(db)?;\n+    let arg = process_macro_input(db, arg, id);\n     Some(arg.green().into())\n }\n "}, {"sha": "112216859cf23f3a771191ba9835f864a484b913", "filename": "crates/hir_expand/src/input.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_expand%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_expand%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Finput.rs?ref=6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7", "patch": "@@ -0,0 +1,94 @@\n+//! Macro input conditioning.\n+\n+use syntax::{\n+    ast::{self, AttrsOwner},\n+    AstNode, SyntaxNode,\n+};\n+\n+use crate::{\n+    db::AstDatabase,\n+    name::{name, AsName},\n+    LazyMacroId, MacroCallKind, MacroCallLoc,\n+};\n+\n+pub(crate) fn process_macro_input(\n+    db: &dyn AstDatabase,\n+    node: SyntaxNode,\n+    id: LazyMacroId,\n+) -> SyntaxNode {\n+    let loc: MacroCallLoc = db.lookup_intern_macro(id);\n+\n+    match loc.kind {\n+        MacroCallKind::FnLike { .. } => node,\n+        MacroCallKind::Derive { derive_attr_index, .. } => {\n+            let item = match ast::Item::cast(node.clone()) {\n+                Some(item) => item,\n+                None => return node,\n+            };\n+\n+            remove_derives_up_to(item, derive_attr_index as usize).syntax().clone()\n+        }\n+    }\n+}\n+\n+/// Removes `#[derive]` attributes from `item`, up to `attr_index`.\n+fn remove_derives_up_to(item: ast::Item, attr_index: usize) -> ast::Item {\n+    let item = item.clone_for_update();\n+    for attr in item.attrs().take(attr_index + 1) {\n+        if let Some(name) =\n+            attr.path().and_then(|path| path.as_single_segment()).and_then(|seg| seg.name_ref())\n+        {\n+            if name.as_name() == name![derive] {\n+                attr.syntax().detach();\n+            }\n+        }\n+    }\n+    item\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use base_db::fixture::WithFixture;\n+    use base_db::SourceDatabase;\n+    use expect_test::{expect, Expect};\n+\n+    use crate::test_db::TestDB;\n+\n+    use super::*;\n+\n+    fn test_remove_derives_up_to(attr: usize, ra_fixture: &str, expect: Expect) {\n+        let (db, file_id) = TestDB::with_single_file(&ra_fixture);\n+        let parsed = db.parse(file_id);\n+\n+        let mut items: Vec<_> =\n+            parsed.syntax_node().descendants().filter_map(ast::Item::cast).collect();\n+        assert_eq!(items.len(), 1);\n+\n+        let item = remove_derives_up_to(items.pop().unwrap(), attr);\n+        expect.assert_eq(&item.to_string());\n+    }\n+\n+    #[test]\n+    fn remove_derive() {\n+        test_remove_derives_up_to(\n+            2,\n+            r#\"\n+#[allow(unused)]\n+#[derive(Copy)]\n+#[derive(Hello)]\n+#[derive(Clone)]\n+struct A {\n+    bar: u32\n+}\n+        \"#,\n+            expect![[r#\"\n+#[allow(unused)]\n+\n+\n+#[derive(Clone)]\n+struct A {\n+    bar: u32\n+}\"#]],\n+        );\n+    }\n+}"}, {"sha": "5df11856e90c366059826f05396b23c8de561ef5", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7", "patch": "@@ -14,6 +14,7 @@ pub mod builtin_macro;\n pub mod proc_macro;\n pub mod quote;\n pub mod eager;\n+mod input;\n \n use either::Either;\n \n@@ -292,13 +293,21 @@ pub struct MacroCallLoc {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum MacroCallKind {\n-    FnLike { ast_id: AstId<ast::MacroCall>, fragment: FragmentKind },\n-    Derive { ast_id: AstId<ast::Item>, derive_name: String, derive_attr: AttrId },\n+    FnLike {\n+        ast_id: AstId<ast::MacroCall>,\n+        fragment: FragmentKind,\n+    },\n+    Derive {\n+        ast_id: AstId<ast::Item>,\n+        derive_name: String,\n+        /// Syntactical index of the invoking `#[derive]` attribute.\n+        ///\n+        /// Outer attributes are counted first, then inner attributes. This does not support\n+        /// out-of-line modules, which may have attributes spread across 2 files!\n+        derive_attr_index: u32,\n+    },\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct AttrId(pub u32);\n-\n impl MacroCallKind {\n     fn file_id(&self) -> HirFileId {\n         match self {"}, {"sha": "d5643393ae2fc564e20633561001e628ea22e777", "filename": "crates/hir_expand/src/proc_macro.rs", "status": "modified", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs?ref=6afd9b2b8dcfaa9338303f29d8fc6c90dbcdd6e7", "patch": "@@ -2,7 +2,6 @@\n \n use crate::db::AstDatabase;\n use base_db::{CrateId, ProcMacroId};\n-use tt::buffer::{Cursor, TokenBuffer};\n \n #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n pub struct ProcMacroExpander {\n@@ -44,9 +43,6 @@ impl ProcMacroExpander {\n                     .clone()\n                     .ok_or_else(|| err!(\"No derive macro found.\"))?;\n \n-                let tt = remove_derive_attrs(tt)\n-                    .ok_or_else(|| err!(\"Fail to remove derive for custom derive\"))?;\n-\n                 // Proc macros have access to the environment variables of the invoking crate.\n                 let env = &krate_graph[calling_crate].env;\n \n@@ -56,101 +52,3 @@ impl ProcMacroExpander {\n         }\n     }\n }\n-\n-fn eat_punct(cursor: &mut Cursor, c: char) -> bool {\n-    if let Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(punct), _)) = cursor.token_tree() {\n-        if punct.char == c {\n-            *cursor = cursor.bump();\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-fn eat_subtree(cursor: &mut Cursor, kind: tt::DelimiterKind) -> bool {\n-    if let Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) = cursor.token_tree() {\n-        if Some(kind) == subtree.delimiter_kind() {\n-            *cursor = cursor.bump_subtree();\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-fn eat_ident(cursor: &mut Cursor, t: &str) -> bool {\n-    if let Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Ident(ident), _)) = cursor.token_tree() {\n-        if t == ident.text.as_str() {\n-            *cursor = cursor.bump();\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-fn remove_derive_attrs(tt: &tt::Subtree) -> Option<tt::Subtree> {\n-    let buffer = TokenBuffer::from_tokens(&tt.token_trees);\n-    let mut p = buffer.begin();\n-    let mut result = tt::Subtree::default();\n-\n-    while !p.eof() {\n-        let curr = p;\n-\n-        if eat_punct(&mut p, '#') {\n-            eat_punct(&mut p, '!');\n-            let parent = p;\n-            if eat_subtree(&mut p, tt::DelimiterKind::Bracket) {\n-                if eat_ident(&mut p, \"derive\") {\n-                    p = parent.bump();\n-                    continue;\n-                }\n-            }\n-        }\n-\n-        result.token_trees.push(curr.token_tree()?.cloned());\n-        p = curr.bump();\n-    }\n-\n-    Some(result)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use test_utils::assert_eq_text;\n-\n-    #[test]\n-    fn test_remove_derive_attrs() {\n-        let tt = mbe::parse_to_token_tree(\n-            r#\"\n-    #[allow(unused)]\n-    #[derive(Copy)]\n-    #[derive(Hello)]\n-    struct A {\n-        bar: u32\n-    }\n-\"#,\n-        )\n-        .unwrap()\n-        .0;\n-        let result = format!(\"{:#?}\", remove_derive_attrs(&tt).unwrap());\n-\n-        assert_eq_text!(\n-            r#\"\n-SUBTREE $\n-  PUNCH   # [alone] 0\n-  SUBTREE [] 1\n-    IDENT   allow 2\n-    SUBTREE () 3\n-      IDENT   unused 4\n-  IDENT   struct 15\n-  IDENT   A 16\n-  SUBTREE {} 17\n-    IDENT   bar 18\n-    PUNCH   : [alone] 19\n-    IDENT   u32 20\n-\"#\n-            .trim(),\n-            &result\n-        );\n-    }\n-}"}]}