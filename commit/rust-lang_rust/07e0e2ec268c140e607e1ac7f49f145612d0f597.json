{"sha": "07e0e2ec268c140e607e1ac7f49f145612d0f597", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZTBlMmVjMjY4YzE0MGU2MDdlMWFjN2Y0OWYxNDU2MTJkMGY1OTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-24T20:51:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-24T20:51:37Z"}, "message": "Auto merge of #83220 - Aaron1011:fix/eval-region-cache, r=nikomatsakis\n\nUse `EvaluatedToOkModuloRegions` whenever we erase regions\n\nFixes #80691\n\nWhen we evaluate a trait predicate, we convert an\n`EvaluatedToOk` result to `EvaluatedToOkModuloRegions` if we erased any\nregions. We cache the result under a region-erased 'freshened'\npredicate, so `EvaluatedToOk` may not be correct for other predicates\nthat have the same cache key.", "tree": {"sha": "c6b200355ac74ca9f26c08442907f41c7ccc1fc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6b200355ac74ca9f26c08442907f41c7ccc1fc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07e0e2ec268c140e607e1ac7f49f145612d0f597", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07e0e2ec268c140e607e1ac7f49f145612d0f597", "html_url": "https://github.com/rust-lang/rust/commit/07e0e2ec268c140e607e1ac7f49f145612d0f597", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07e0e2ec268c140e607e1ac7f49f145612d0f597/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5fe425c925ef36d5f4c18cfa44173fc42de31b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5fe425c925ef36d5f4c18cfa44173fc42de31b8", "html_url": "https://github.com/rust-lang/rust/commit/f5fe425c925ef36d5f4c18cfa44173fc42de31b8"}, {"sha": "102b5789b266dc28d2781d6a8689ffdd3c0f9e47", "url": "https://api.github.com/repos/rust-lang/rust/commits/102b5789b266dc28d2781d6a8689ffdd3c0f9e47", "html_url": "https://github.com/rust-lang/rust/commit/102b5789b266dc28d2781d6a8689ffdd3c0f9e47"}], "stats": {"total": 199, "additions": 198, "deletions": 1}, "files": [{"sha": "bc8a0eae0e0ff97df8440c1b3aa62881c2489582", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/07e0e2ec268c140e607e1ac7f49f145612d0f597/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e0e2ec268c140e607e1ac7f49f145612d0f597/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=07e0e2ec268c140e607e1ac7f49f145612d0f597", "patch": "@@ -863,7 +863,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         stack: &TraitObligationStack<'o, 'tcx>,\n         candidate: &SelectionCandidate<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        let result = self.evaluation_probe(|this| {\n+        let mut result = self.evaluation_probe(|this| {\n             let candidate = (*candidate).clone();\n             match this.confirm_candidate(stack.obligation, candidate) {\n                 Ok(selection) => {\n@@ -876,6 +876,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Err(..) => Ok(EvaluatedToErr),\n             }\n         })?;\n+\n+        // If we erased any lifetimes, then we want to use\n+        // `EvaluatedToOkModuloRegions` instead of `EvaluatedToOk`\n+        // as your final result. The result will be cached using\n+        // the freshened trait predicate as a key, so we need\n+        // our result to be correct by *any* choice of original lifetimes,\n+        // not just the lifetime choice for this particular (non-erased)\n+        // predicate.\n+        // See issue #80691\n+        if stack.fresh_trait_ref.has_erased_regions() {\n+            result = result.max(EvaluatedToOkModuloRegions);\n+        }\n+\n         debug!(?result);\n         Ok(result)\n     }"}, {"sha": "1a644fd88d6ba4dbd74655e3541fe752d04f5883", "filename": "src/test/incremental/issue-80691-bad-eval-cache.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/07e0e2ec268c140e607e1ac7f49f145612d0f597/src%2Ftest%2Fincremental%2Fissue-80691-bad-eval-cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e0e2ec268c140e607e1ac7f49f145612d0f597/src%2Ftest%2Fincremental%2Fissue-80691-bad-eval-cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-80691-bad-eval-cache.rs?ref=07e0e2ec268c140e607e1ac7f49f145612d0f597", "patch": "@@ -0,0 +1,184 @@\n+// revisions: rfail1 rfail2\n+// failure-status: 101\n+// error-pattern: not implemented\n+\n+pub trait Interner {\n+    type InternedVariableKinds;\n+}\n+\n+trait RustIrDatabase<I: Interner> {\n+    fn associated_ty_data(&self) -> AssociatedTyDatum<I>;\n+    fn impl_datum(&self) -> ImplDatum<I>;\n+}\n+\n+trait Fold<I: Interner> {\n+    type Result;\n+}\n+impl<T, I: Interner> Fold<I> for Binders<T>\n+where\n+    T: HasInterner<Interner = I> + Fold<I>,\n+    <T as Fold<I>>::Result: HasInterner<Interner = I>,\n+    I: Interner,\n+{\n+    type Result = Binders<T::Result>;\n+}\n+impl<I: Interner> Fold<I> for WhereClause<I> {\n+    type Result = Binders<WhereClause<I>>;\n+}\n+\n+trait HasInterner {\n+    type Interner: Interner;\n+}\n+impl<T: HasInterner> HasInterner for Vec<T> {\n+    type Interner = T::Interner;\n+}\n+impl<T: HasInterner + ?Sized> HasInterner for &T {\n+    type Interner = T::Interner;\n+}\n+\n+pub struct VariableKind<I: Interner> {\n+    _marker: std::marker::PhantomData<I>,\n+}\n+\n+struct VariableKinds<I: Interner> {\n+    _interned: I::InternedVariableKinds,\n+}\n+\n+struct WhereClause<I: Interner> {\n+    _marker: std::marker::PhantomData<I>,\n+}\n+impl<I: Interner> HasInterner for WhereClause<I> {\n+    type Interner = I;\n+}\n+\n+struct Binders<T> {\n+    _marker: std::marker::PhantomData<T>,\n+}\n+impl<T: HasInterner> HasInterner for Binders<T> {\n+    type Interner = T::Interner;\n+}\n+impl<T> Binders<&T> {\n+    fn cloned(self) -> Binders<T> {\n+        unimplemented!()\n+    }\n+}\n+impl<T: HasInterner> Binders<T> {\n+    fn map_ref<'a, U, OP>(&'a self, _op: OP) -> Binders<U>\n+    where\n+        OP: FnOnce(&'a T) -> U,\n+        U: HasInterner<Interner = T::Interner>,\n+    {\n+        unimplemented!()\n+    }\n+}\n+impl<T, I: Interner> Binders<T>\n+where\n+    T: Fold<I> + HasInterner<Interner = I>,\n+    I: Interner,\n+{\n+    fn substitute(self) -> T::Result {\n+        unimplemented!()\n+    }\n+}\n+impl<V, U> IntoIterator for Binders<V>\n+where\n+    V: HasInterner + IntoIterator<Item = U>,\n+    U: HasInterner<Interner = V::Interner>,\n+{\n+    type Item = Binders<U>;\n+    type IntoIter = BindersIntoIterator<V>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        unimplemented!()\n+    }\n+}\n+struct BindersIntoIterator<V: HasInterner> {\n+    _binders: VariableKinds<V::Interner>,\n+}\n+impl<V> Iterator for BindersIntoIterator<V>\n+where\n+    V: HasInterner + IntoIterator,\n+    <V as IntoIterator>::Item: HasInterner<Interner = V::Interner>,\n+{\n+    type Item = Binders<<V as IntoIterator>::Item>;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        unimplemented!()\n+    }\n+}\n+\n+struct ImplDatum<I: Interner> {\n+    binders: Binders<ImplDatumBound<I>>,\n+}\n+struct ImplDatumBound<I: Interner> {\n+    where_clauses: Vec<Binders<WhereClause<I>>>,\n+}\n+impl<I: Interner> HasInterner for ImplDatumBound<I> {\n+    type Interner = I;\n+}\n+\n+struct AssociatedTyDatum<I: Interner> {\n+    binders: Binders<AssociatedTyDatumBound<I>>,\n+}\n+\n+struct AssociatedTyDatumBound<I: Interner> {\n+    where_clauses: Vec<Binders<WhereClause<I>>>,\n+}\n+impl<I: Interner> HasInterner for AssociatedTyDatumBound<I> {\n+    type Interner = I;\n+}\n+\n+struct ClauseBuilder<'me, I: Interner> {\n+    db: &'me dyn RustIrDatabase<I>,\n+}\n+impl<'me, I: Interner> ClauseBuilder<'me, I> {\n+    fn new() -> Self {\n+        unimplemented!()\n+    }\n+    fn push_clause(&mut self, _conditions: impl Iterator<Item = Binders<Binders<WhereClause<I>>>>) {\n+        unimplemented!()\n+    }\n+}\n+\n+pub(crate) struct Forest<I: Interner> {\n+    _marker: std::marker::PhantomData<I>,\n+}\n+\n+impl<I: Interner> Forest<I> {\n+    fn iter_answers<'f>(&'f self) {\n+        let builder = &mut ClauseBuilder::<I>::new();\n+        let impl_datum = builder.db.impl_datum();\n+        let impl_where_clauses = impl_datum\n+            .binders\n+            .map_ref(|b| &b.where_clauses)\n+            .into_iter()\n+            .map(|wc| wc.cloned().substitute());\n+        let associated_ty = builder.db.associated_ty_data();\n+        let assoc_ty_where_clauses = associated_ty\n+            .binders\n+            .map_ref(|b| &b.where_clauses)\n+            .into_iter()\n+            .map(|wc| wc.cloned().substitute());\n+        builder.push_clause(impl_where_clauses.chain(assoc_ty_where_clauses));\n+    }\n+}\n+\n+pub struct SLGSolver {\n+    pub(crate) forest: Forest<ChalkIr>,\n+}\n+impl SLGSolver {\n+    fn new() -> Self {\n+        unimplemented!()\n+    }\n+    fn solve_multiple(&self) {\n+        let _answers = self.forest.iter_answers();\n+    }\n+}\n+\n+pub struct ChalkIr;\n+impl Interner for ChalkIr {\n+    type InternedVariableKinds = Vec<VariableKind<ChalkIr>>;\n+}\n+\n+fn main() {\n+    let solver = SLGSolver::new();\n+    solver.solve_multiple();\n+}"}]}