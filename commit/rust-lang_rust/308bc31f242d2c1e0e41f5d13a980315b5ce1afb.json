{"sha": "308bc31f242d2c1e0e41f5d13a980315b5ce1afb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwOGJjMzFmMjQyZDJjMWUwZTQxZjVkMTNhOTgwMzE1YjVjZTFhZmI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-29T19:30:04Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-29T21:21:39Z"}, "message": "Encapsulate more crate meta calculations", "tree": {"sha": "fd9d9d167cec1cd892132e2c47a6818716881fd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd9d9d167cec1cd892132e2c47a6818716881fd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/308bc31f242d2c1e0e41f5d13a980315b5ce1afb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/308bc31f242d2c1e0e41f5d13a980315b5ce1afb", "html_url": "https://github.com/rust-lang/rust/commit/308bc31f242d2c1e0e41f5d13a980315b5ce1afb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/308bc31f242d2c1e0e41f5d13a980315b5ce1afb/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "325f46da06ccda82e465b0a1ba8449a04a89e601", "url": "https://api.github.com/repos/rust-lang/rust/commits/325f46da06ccda82e465b0a1ba8449a04a89e601", "html_url": "https://github.com/rust-lang/rust/commit/325f46da06ccda82e465b0a1ba8449a04a89e601"}], "stats": {"total": 158, "additions": 79, "deletions": 79}, "files": [{"sha": "648dcf298719c2c5a9e3c6439e5601daf4485634", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/308bc31f242d2c1e0e41f5d13a980315b5ce1afb/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308bc31f242d2c1e0e41f5d13a980315b5ce1afb/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=308bc31f242d2c1e0e41f5d13a980315b5ce1afb", "patch": "@@ -282,90 +282,91 @@ type link_meta = rec(str name,\n \n fn build_link_meta(&session::session sess, &ast::crate c,\n                    &str output, sha1 sha) -> link_meta {\n-    auto meta_info = crate_link_metas(c);\n \n-    auto name = crate_meta_name(sess, c, output);\n-    auto vers = crate_meta_vers(sess, c);\n-    auto extras_hash = crate_meta_extras_hash(sha, c);\n-\n-    ret rec(name = name, vers = vers, extras_hash = extras_hash);\n-}\n-\n-type link_metas = rec(option::t[str] name,\n-                      option::t[str] vers,\n-                      vec[@ast::meta_item] cmh_items);\n-\n-fn crate_link_metas(&ast::crate c) -> link_metas {\n-    let option::t[str] name = none;\n-    let option::t[str] vers = none;\n-    let vec[@ast::meta_item] cmh_items = [];\n-    for (@ast::meta_item meta in\n-             attr::find_linkage_metas(c.node.attrs)) {\n-        alt (meta.node) {\n-            case (ast::meta_name_value(\"name\", ?v)) {\n-                // FIXME: Should probably warn about duplicate name items\n-                name = some(v);\n-            }\n-            case (ast::meta_name_value(\"value\", ?v)) {\n-                // FIXME: Should probably warn about duplicate value items\n-                vers = some(v);\n-            }\n-            case (_) {\n-                cmh_items += [meta];\n+    type provided_metas = rec(option::t[str] name,\n+                              option::t[str] vers,\n+                              vec[@ast::meta_item] cmh_items);\n+\n+    fn provided_link_metas(&ast::crate c) -> provided_metas {\n+        let option::t[str] name = none;\n+        let option::t[str] vers = none;\n+        let vec[@ast::meta_item] cmh_items = [];\n+        for (@ast::meta_item meta in\n+                 attr::find_linkage_metas(c.node.attrs)) {\n+            alt (meta.node) {\n+                case (ast::meta_name_value(\"name\", ?v)) {\n+                    // FIXME: Should probably warn about duplicate name items\n+                    name = some(v);\n+                }\n+                case (ast::meta_name_value(\"value\", ?v)) {\n+                    // FIXME: Should probably warn about duplicate value items\n+                    vers = some(v);\n+                }\n+                case (_) {\n+                    cmh_items += [meta];\n+                }\n             }\n         }\n+        ret rec(name = name,\n+                vers = vers,\n+                cmh_items = cmh_items);\n     }\n-    ret rec(name = name,\n-            vers = vers,\n-            cmh_items = cmh_items);\n-}\n \n-// This calculates CMH as defined above\n-fn crate_meta_extras_hash(sha1 sha, &ast::crate crate) -> str {\n-    fn len_and_str(&str s) -> str { ret #fmt(\"%u_%s\", str::byte_len(s), s); }\n+    // This calculates CMH as defined above\n+    fn crate_meta_extras_hash(sha1 sha, &ast::crate crate,\n+                              &provided_metas metas) -> str {\n+        fn len_and_str(&str s) -> str {\n+            ret #fmt(\"%u_%s\", str::byte_len(s), s);\n+        }\n     \n-    auto cmh_items = {\n-        auto cmh_items = crate_link_metas(crate).cmh_items;\n-        attr::sort_meta_items(cmh_items)\n-    };\n-\n-    sha.reset();\n-    for (@ast::meta_item m_ in cmh_items) {\n-        auto m = m_;\n-        alt (m.node) {\n-            case (ast::meta_name_value(?key, ?value)) {\n-                sha.input_str(len_and_str(key));\n-                sha.input_str(len_and_str(value));\n-            }\n-            case (ast::meta_word(?name)) {\n-                sha.input_str(len_and_str(name));\n-            }\n-            case (ast::meta_list(_, _)) {\n-                fail \"unimplemented meta_item variant\";\n+        auto cmh_items = attr::sort_meta_items(metas.cmh_items);\n+\n+        sha.reset();\n+        for (@ast::meta_item m_ in cmh_items) {\n+            auto m = m_;\n+            alt (m.node) {\n+                case (ast::meta_name_value(?key, ?value)) {\n+                    sha.input_str(len_and_str(key));\n+                    sha.input_str(len_and_str(value));\n+                }\n+                case (ast::meta_word(?name)) {\n+                    sha.input_str(len_and_str(name));\n+                }\n+                case (ast::meta_list(_, _)) {\n+                    fail \"unimplemented meta_item variant\";\n+                }\n             }\n         }\n+        ret truncated_sha1_result(sha);\n     }\n-    ret truncated_sha1_result(sha);\n-}\n \n-fn crate_meta_name(&session::session sess, &ast::crate crate,\n-                   &str output) -> str {\n-    ret alt (crate_link_metas(crate).name) {\n-        case (some(?v)) { v }\n-        case (none) {\n-            auto os = str::split(fs::basename(output), '.' as u8);\n-            assert (vec::len(os) >= 2u);\n-            vec::pop(os);\n-            str::connect(os, \".\")\n-        }\n-    };\n-}\n+    fn crate_meta_name(&session::session sess, &ast::crate crate,\n+                       &str output, &provided_metas metas) -> str {\n+        ret alt (metas.name) {\n+            case (some(?v)) { v }\n+            case (none) {\n+                auto os = str::split(fs::basename(output), '.' as u8);\n+                assert (vec::len(os) >= 2u);\n+                vec::pop(os);\n+                str::connect(os, \".\")\n+            }\n+        };\n+    }\n \n-fn crate_meta_vers(&session::session sess, &ast::crate crate) -> str {\n-    ret alt (crate_link_metas(crate).vers) {\n-        case (some(?v)) { v }\n-        case (none) { \"0.0\" }\n-    };\n+    fn crate_meta_vers(&session::session sess, &ast::crate crate,\n+                       &provided_metas metas) -> str {\n+        ret alt (metas.vers) {\n+            case (some(?v)) { v }\n+            case (none) { \"0.0\" }\n+        };\n+    }\n+\n+    auto provided_metas = provided_link_metas(c);\n+    auto name = crate_meta_name(sess, c, output, provided_metas);\n+    auto vers = crate_meta_vers(sess, c, provided_metas);\n+    auto extras_hash = crate_meta_extras_hash(sha, c, provided_metas);\n+\n+    ret rec(name = name, vers = vers, extras_hash = extras_hash);\n }\n \n fn truncated_sha1_result(sha1 sha) -> str {\n@@ -374,8 +375,7 @@ fn truncated_sha1_result(sha1 sha) -> str {\n \n \n // This calculates STH for a symbol, as defined above\n-fn symbol_hash(ty::ctxt tcx, sha1 sha, &ty::t t, str crate_meta_name,\n-               str crate_meta_extras_hash) -> str {\n+fn symbol_hash(ty::ctxt tcx, sha1 sha, &ty::t t, &link_meta link_meta) -> str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n@@ -384,9 +384,10 @@ fn symbol_hash(ty::ctxt tcx, sha1 sha, &ty::t t, str crate_meta_name,\n              tcx=tcx,\n              abbrevs=metadata::tyencode::ac_no_abbrevs);\n     sha.reset();\n-    sha.input_str(crate_meta_name);\n+    sha.input_str(link_meta.name);\n     sha.input_str(\"-\");\n-    sha.input_str(crate_meta_name);\n+    // FIXME: This wants to be link_meta.meta_hash\n+    sha.input_str(link_meta.name);\n     sha.input_str(\"-\");\n     sha.input_str(metadata::tyencode::ty_str(cx, t));\n     auto hash = truncated_sha1_result(sha);\n@@ -402,8 +403,7 @@ fn get_symbol_hash(&@crate_ctxt ccx, &ty::t t) -> str {\n         case (none) {\n             hash =\n                 symbol_hash(ccx.tcx, ccx.sha, t,\n-                            ccx.link_meta.name,\n-                            ccx.link_meta.extras_hash);\n+                            ccx.link_meta);\n             ccx.type_sha1s.insert(t, hash);\n         }\n     }"}]}