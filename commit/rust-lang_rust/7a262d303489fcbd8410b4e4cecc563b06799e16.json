{"sha": "7a262d303489fcbd8410b4e4cecc563b06799e16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMjYyZDMwMzQ4OWZjYmQ4NDEwYjRlNGNlY2M1NjNiMDY3OTllMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-02T13:50:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-02T13:50:59Z"}, "message": "Auto merge of #34539 - arielb1:metadata-hash, r=alexcrichton\n\nMake the metadata lock more robust\n\nFixes #33778 and friends.\n\nI also needed to add a metadata encoding version to rlibs, as they did not have it before. To keep it backwards-compatible, I added 4 zeroes to the start of the metadata, which are treated as an empty length field by older rustcs.\n\nr? @alexcrichton", "tree": {"sha": "8d3e21b20c9d10c5037b6923ce051b2139c56a76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d3e21b20c9d10c5037b6923ce051b2139c56a76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a262d303489fcbd8410b4e4cecc563b06799e16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a262d303489fcbd8410b4e4cecc563b06799e16", "html_url": "https://github.com/rust-lang/rust/commit/7a262d303489fcbd8410b4e4cecc563b06799e16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a262d303489fcbd8410b4e4cecc563b06799e16/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40", "html_url": "https://github.com/rust-lang/rust/commit/8a50e295fa2f3e550e1c9c19e1a9cadb6323ff40"}, {"sha": "42b7c32ac8cdd08d3d396925f99d99286f581193", "url": "https://api.github.com/repos/rust-lang/rust/commits/42b7c32ac8cdd08d3d396925f99d99286f581193", "html_url": "https://github.com/rust-lang/rust/commit/42b7c32ac8cdd08d3d396925f99d99286f581193"}], "stats": {"total": 373, "additions": 214, "deletions": 159}, "files": [{"sha": "4e16fae187070ee13880b1a8c189cf91c724d409", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -118,8 +118,6 @@ impl DepGraphThreadData {\n     /// the buffer is full, this may swap.)\n     #[inline]\n     pub fn enqueue(&self, message: DepMessage) {\n-        debug!(\"enqueue: {:?} tasks_pushed={}\", message, self.tasks_pushed.get());\n-\n         // Regardless of whether dep graph construction is enabled, we\n         // still want to check that we always have a valid task on the\n         // stack when a read/write/etc event occurs."}, {"sha": "9123463149936da2b434d8e4c84c14288261f12f", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -15,6 +15,7 @@ use std::marker::PhantomData;\n use std::ops::{Index, IndexMut, Range};\n use std::fmt;\n use std::vec;\n+use std::u32;\n \n use rustc_serialize as serialize;\n \n@@ -31,6 +32,11 @@ impl Idx for usize {\n     fn index(self) -> usize { self }\n }\n \n+impl Idx for u32 {\n+    fn new(idx: usize) -> Self { assert!(idx <= u32::MAX as usize); idx as u32 }\n+    fn index(self) -> usize { self as usize }\n+}\n+\n #[derive(Clone)]\n pub struct IndexVec<I: Idx, T> {\n     pub raw: Vec<T>,"}, {"sha": "2d3302c2eef3a8078a4c6683a94f546770ed19b0", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -16,6 +16,7 @@ rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n serialize = { path = \"../libserialize\" }"}, {"sha": "2e8c5a7c23418ba137017befcbd86b4a57613481", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -60,7 +60,7 @@ use rustc_serialize::{Encodable, EncoderHelpers};\n \n struct DecodeContext<'a, 'b, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    cdata: &'b cstore::crate_metadata,\n+    cdata: &'b cstore::CrateMetadata,\n     from_id_range: IdRange,\n     to_id_range: IdRange,\n     // Cache the last used filemap for translating spans as an optimization.\n@@ -121,7 +121,7 @@ impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n \n /// Decodes an item from its AST in the cdata's metadata and adds it to the\n /// ast-map.\n-pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::crate_metadata,\n+pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n                                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      parent_def_path: ast_map::DefPath,\n                                      parent_did: DefId,\n@@ -246,7 +246,7 @@ impl<S:serialize::Encoder> def_id_encoder_helpers for S\n trait def_id_decoder_helpers {\n     fn read_def_id(&mut self, dcx: &DecodeContext) -> DefId;\n     fn read_def_id_nodcx(&mut self,\n-                         cdata: &cstore::crate_metadata) -> DefId;\n+                         cdata: &cstore::CrateMetadata) -> DefId;\n }\n \n impl<D:serialize::Decoder> def_id_decoder_helpers for D\n@@ -258,7 +258,7 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D\n     }\n \n     fn read_def_id_nodcx(&mut self,\n-                         cdata: &cstore::crate_metadata)\n+                         cdata: &cstore::CrateMetadata)\n                          -> DefId {\n         let did: DefId = Decodable::decode(self).unwrap();\n         decoder::translate_def_id(cdata, did)\n@@ -858,17 +858,17 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n     // Versions of the type reading functions that don't need the full\n     // DecodeContext.\n     fn read_ty_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         cdata: &cstore::crate_metadata) -> Ty<'tcx>;\n+                         cdata: &cstore::CrateMetadata) -> Ty<'tcx>;\n     fn read_tys_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>>;\n+                          cdata: &cstore::CrateMetadata) -> Vec<Ty<'tcx>>;\n     fn read_substs_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             cdata: &cstore::crate_metadata)\n+                             cdata: &cstore::CrateMetadata)\n                              -> subst::Substs<'tcx>;\n }\n \n impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_ty_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                         cdata: &cstore::crate_metadata)\n+                         cdata: &cstore::CrateMetadata)\n                          -> Ty<'tcx> {\n         self.read_opaque(|_, doc| {\n             Ok(\n@@ -879,15 +879,15 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     }\n \n     fn read_tys_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                          cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>> {\n+                          cdata: &cstore::CrateMetadata) -> Vec<Ty<'tcx>> {\n         self.read_to_vec(|this| Ok(this.read_ty_nodcx(tcx, cdata)) )\n             .unwrap()\n             .into_iter()\n             .collect()\n     }\n \n     fn read_substs_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                             cdata: &cstore::crate_metadata)\n+                             cdata: &cstore::CrateMetadata)\n                              -> subst::Substs<'tcx>\n     {\n         self.read_opaque(|_, doc| {"}, {"sha": "ff072cce5db9667ccd5cb998ee0cdcb6384cdd78", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -252,3 +252,7 @@ pub fn rustc_version() -> String {\n }\n \n pub const tag_panic_strategy: usize = 0x114;\n+\n+// NB: increment this if you change the format of metadata such that\n+// rustc_version can't be found.\n+pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2];"}, {"sha": "269e284b22d6cb268d3d5aceca737da1fc90be13", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 40, "deletions": 63, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -12,7 +12,6 @@\n \n //! Validates all used crates and extern libraries and loads their metadata\n \n-use common::rustc_version;\n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use decoder;\n use loader::{self, CratePaths};\n@@ -24,7 +23,7 @@ use rustc::session::{config, Session};\n use rustc::session::config::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n-use rustc::util::nodemap::FnvHashMap;\n+use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n use rustc::hir::map as hir_map;\n \n use std::cell::{RefCell, Cell};\n@@ -132,7 +131,7 @@ struct ExtensionCrate {\n }\n \n enum PMDSource {\n-    Registered(Rc<cstore::crate_metadata>),\n+    Registered(Rc<cstore::CrateMetadata>),\n     Owned(MetadataBlob),\n }\n \n@@ -236,25 +235,6 @@ impl<'a> CrateReader<'a> {\n         return ret;\n     }\n \n-    fn verify_rustc_version(&self,\n-                            name: &str,\n-                            span: Span,\n-                            metadata: &MetadataBlob) {\n-        let crate_rustc_version = decoder::crate_rustc_version(metadata.as_slice());\n-        if crate_rustc_version != Some(rustc_version()) {\n-            let mut err = struct_span_fatal!(self.sess, span, E0514,\n-                                             \"the crate `{}` has been compiled with {}, which is \\\n-                                              incompatible with this version of rustc\",\n-                                              name,\n-                                              crate_rustc_version\n-                                              .as_ref().map(|s| &**s)\n-                                              .unwrap_or(\"an old version of rustc\"));\n-            err.help(\"consider removing the compiled binaries and recompiling \\\n-                      with your current version of rustc\");\n-            err.emit();\n-        }\n-    }\n-\n     fn verify_no_symbol_conflicts(&self,\n                                   span: Span,\n                                   metadata: &MetadataBlob) {\n@@ -294,9 +274,8 @@ impl<'a> CrateReader<'a> {\n                       span: Span,\n                       lib: loader::Library,\n                       explicitly_linked: bool)\n-                      -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n+                      -> (ast::CrateNum, Rc<cstore::CrateMetadata>,\n                           cstore::CrateSource) {\n-        self.verify_rustc_version(name, span, &lib.metadata);\n         self.verify_no_symbol_conflicts(span, &lib.metadata);\n \n         // Claim this crate number and cache it\n@@ -318,10 +297,10 @@ impl<'a> CrateReader<'a> {\n \n         let loader::Library { dylib, rlib, metadata } = lib;\n \n-        let cnum_map = self.resolve_crate_deps(root, metadata.as_slice(), span);\n+        let cnum_map = self.resolve_crate_deps(root, metadata.as_slice(), cnum, span);\n         let staged_api = self.is_staged_api(metadata.as_slice());\n \n-        let cmeta = Rc::new(cstore::crate_metadata {\n+        let cmeta = Rc::new(cstore::CrateMetadata {\n             name: name.to_string(),\n             extern_crate: Cell::new(None),\n             index: decoder::load_index(metadata.as_slice()),\n@@ -364,7 +343,7 @@ impl<'a> CrateReader<'a> {\n                      span: Span,\n                      kind: PathKind,\n                      explicitly_linked: bool)\n-                     -> (ast::CrateNum, Rc<cstore::crate_metadata>, cstore::CrateSource) {\n+                     -> (ast::CrateNum, Rc<cstore::CrateMetadata>, cstore::CrateSource) {\n         let result = match self.existing_match(name, hash, kind) {\n             Some(cnum) => LoadResult::Previous(cnum),\n             None => {\n@@ -381,6 +360,7 @@ impl<'a> CrateReader<'a> {\n                     rejected_via_hash: vec!(),\n                     rejected_via_triple: vec!(),\n                     rejected_via_kind: vec!(),\n+                    rejected_via_version: vec!(),\n                     should_match_name: true,\n                 };\n                 match self.load(&mut load_ctxt) {\n@@ -438,8 +418,11 @@ impl<'a> CrateReader<'a> {\n \n     fn update_extern_crate(&mut self,\n                            cnum: ast::CrateNum,\n-                           mut extern_crate: ExternCrate)\n+                           mut extern_crate: ExternCrate,\n+                           visited: &mut FnvHashSet<(ast::CrateNum, bool)>)\n     {\n+        if !visited.insert((cnum, extern_crate.direct)) { return }\n+\n         let cmeta = self.cstore.get_crate_data(cnum);\n         let old_extern_crate = cmeta.extern_crate.get();\n \n@@ -458,24 +441,24 @@ impl<'a> CrateReader<'a> {\n         }\n \n         cmeta.extern_crate.set(Some(extern_crate));\n-\n         // Propagate the extern crate info to dependencies.\n         extern_crate.direct = false;\n-        for &dep_cnum in cmeta.cnum_map.borrow().values() {\n-            self.update_extern_crate(dep_cnum, extern_crate);\n+        for &dep_cnum in cmeta.cnum_map.borrow().iter() {\n+            self.update_extern_crate(dep_cnum, extern_crate, visited);\n         }\n     }\n \n     // Go through the crate metadata and load any crates that it references\n     fn resolve_crate_deps(&mut self,\n                           root: &Option<CratePaths>,\n                           cdata: &[u8],\n-                          span : Span)\n-                          -> cstore::cnum_map {\n+                          krate: ast::CrateNum,\n+                          span: Span)\n+                          -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n         // The map from crate numbers in the crate we're resolving to local crate\n         // numbers\n-        decoder::get_crate_deps(cdata).iter().map(|dep| {\n+        let map: FnvHashMap<_, _> = decoder::get_crate_deps(cdata).iter().map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, _, _) = self.resolve_crate(root,\n                                                         &dep.name,\n@@ -485,7 +468,13 @@ impl<'a> CrateReader<'a> {\n                                                         PathKind::Dependency,\n                                                         dep.explicitly_linked);\n             (dep.cnum, local_cnum)\n-        }).collect()\n+        }).collect();\n+\n+        let max_cnum = map.values().cloned().max().unwrap_or(0);\n+\n+        // we map 0 and all other holes in the map to our parent crate. The \"additional\"\n+        // self-dependencies should be harmless.\n+        (0..max_cnum+1).map(|cnum| map.get(&cnum).cloned().unwrap_or(krate)).collect()\n     }\n \n     fn read_extension_crate(&mut self, span: Span, info: &CrateInfo) -> ExtensionCrate {\n@@ -508,6 +497,7 @@ impl<'a> CrateReader<'a> {\n             rejected_via_hash: vec!(),\n             rejected_via_triple: vec!(),\n             rejected_via_kind: vec!(),\n+            rejected_via_version: vec!(),\n             should_match_name: true,\n         };\n         let library = self.load(&mut load_ctxt).or_else(|| {\n@@ -826,7 +816,7 @@ impl<'a> CrateReader<'a> {\n     fn inject_dependency_if(&self,\n                             krate: ast::CrateNum,\n                             what: &str,\n-                            needs_dep: &Fn(&cstore::crate_metadata) -> bool) {\n+                            needs_dep: &Fn(&cstore::CrateMetadata) -> bool) {\n         // don't perform this validation if the session has errors, as one of\n         // those errors may indicate a circular dependency which could cause\n         // this to stack overflow.\n@@ -837,7 +827,17 @@ impl<'a> CrateReader<'a> {\n         // Before we inject any dependencies, make sure we don't inject a\n         // circular dependency by validating that this crate doesn't\n         // transitively depend on any crates satisfying `needs_dep`.\n-        validate(self, krate, krate, what, needs_dep);\n+        for dep in self.cstore.crate_dependencies_in_rpo(krate) {\n+            let data = self.cstore.get_crate_data(dep);\n+            if needs_dep(&data) {\n+                self.sess.err(&format!(\"the crate `{}` cannot depend \\\n+                                        on a crate that needs {}, but \\\n+                                        it depends on `{}`\",\n+                                       self.cstore.get_crate_data(krate).name(),\n+                                       what,\n+                                       data.name()));\n+            }\n+        }\n \n         // All crates satisfying `needs_dep` do not explicitly depend on the\n         // crate provided for this compile, but in order for this compilation to\n@@ -849,32 +849,8 @@ impl<'a> CrateReader<'a> {\n             }\n \n             info!(\"injecting a dep from {} to {}\", cnum, krate);\n-            let mut cnum_map = data.cnum_map.borrow_mut();\n-            let remote_cnum = cnum_map.len() + 1;\n-            let prev = cnum_map.insert(remote_cnum as ast::CrateNum, krate);\n-            assert!(prev.is_none());\n+            data.cnum_map.borrow_mut().push(krate);\n         });\n-\n-        fn validate(me: &CrateReader,\n-                    krate: ast::CrateNum,\n-                    root: ast::CrateNum,\n-                    what: &str,\n-                    needs_dep: &Fn(&cstore::crate_metadata) -> bool) {\n-            let data = me.cstore.get_crate_data(krate);\n-            if needs_dep(&data) {\n-                let krate_name = data.name();\n-                let data = me.cstore.get_crate_data(root);\n-                let root_name = data.name();\n-                me.sess.err(&format!(\"the crate `{}` cannot depend \\\n-                                      on a crate that needs {}, but \\\n-                                      it depends on `{}`\", root_name, what,\n-                                      krate_name));\n-            }\n-\n-            for (_, &dep) in data.cnum_map.borrow().iter() {\n-                validate(me, dep, root, what, needs_dep);\n-            }\n-        }\n     }\n }\n \n@@ -948,7 +924,8 @@ impl<'a> LocalCrateReader<'a> {\n                                                          span: i.span,\n                                                          direct: true,\n                                                          path_len: len,\n-                                                     });\n+                                                     },\n+                                                     &mut FnvHashSet());\n                     self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n                 }\n             }"}, {"sha": "95e3c53ecb40245e420bff18e81a92d8c9bb6b2e", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use cstore;\n+use common;\n use decoder;\n use encoder;\n use loader;\n@@ -588,7 +589,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn metadata_encoding_version(&self) -> &[u8]\n     {\n-        encoder::metadata_encoding_version\n+        common::metadata_encoding_version\n     }\n \n     /// Returns a map from a sufficiently visible external item (i.e. an external item that is"}, {"sha": "774d0f7ea188608820c21df7a014c87ecdac6cfb", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -15,6 +15,7 @@\n \n pub use self::MetadataBlob::*;\n \n+use common;\n use creader;\n use decoder;\n use index;\n@@ -26,6 +27,7 @@ use rustc::hir::map::DefKey;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{ExternCrate};\n use rustc::session::config::PanicStrategy;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{RefCell, Ref, Cell};\n@@ -46,7 +48,7 @@ pub use middle::cstore::{CrateSource, LinkMeta};\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type cnum_map = FnvHashMap<ast::CrateNum, ast::CrateNum>;\n+pub type CrateNumMap = IndexVec<ast::CrateNum, ast::CrateNum>;\n \n pub enum MetadataBlob {\n     MetadataVec(Bytes),\n@@ -64,7 +66,7 @@ pub struct ImportedFileMap {\n     pub translated_filemap: Rc<syntax_pos::FileMap>\n }\n \n-pub struct crate_metadata {\n+pub struct CrateMetadata {\n     pub name: String,\n \n     /// Information about the extern crate that caused this crate to\n@@ -73,7 +75,7 @@ pub struct crate_metadata {\n     pub extern_crate: Cell<Option<ExternCrate>>,\n \n     pub data: MetadataBlob,\n-    pub cnum_map: RefCell<cnum_map>,\n+    pub cnum_map: RefCell<CrateNumMap>,\n     pub cnum: ast::CrateNum,\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n     pub staged_api: bool,\n@@ -97,7 +99,7 @@ pub struct crate_metadata {\n \n pub struct CStore {\n     pub dep_graph: DepGraph,\n-    metas: RefCell<FnvHashMap<ast::CrateNum, Rc<crate_metadata>>>,\n+    metas: RefCell<FnvHashMap<ast::CrateNum, Rc<CrateMetadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: RefCell<NodeMap<ast::CrateNum>>,\n     used_crate_sources: RefCell<Vec<CrateSource>>,\n@@ -128,7 +130,7 @@ impl CStore {\n         self.metas.borrow().len() as ast::CrateNum + 1\n     }\n \n-    pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<crate_metadata> {\n+    pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<CrateMetadata> {\n         self.metas.borrow().get(&cnum).unwrap().clone()\n     }\n \n@@ -137,12 +139,12 @@ impl CStore {\n         decoder::get_crate_hash(cdata.data())\n     }\n \n-    pub fn set_crate_data(&self, cnum: ast::CrateNum, data: Rc<crate_metadata>) {\n+    pub fn set_crate_data(&self, cnum: ast::CrateNum, data: Rc<CrateMetadata>) {\n         self.metas.borrow_mut().insert(cnum, data);\n     }\n \n     pub fn iter_crate_data<I>(&self, mut i: I) where\n-        I: FnMut(ast::CrateNum, &Rc<crate_metadata>),\n+        I: FnMut(ast::CrateNum, &Rc<CrateMetadata>),\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n             i(k, v);\n@@ -151,7 +153,7 @@ impl CStore {\n \n     /// Like `iter_crate_data`, but passes source paths (if available) as well.\n     pub fn iter_crate_data_origins<I>(&self, mut i: I) where\n-        I: FnMut(ast::CrateNum, &crate_metadata, Option<CrateSource>),\n+        I: FnMut(ast::CrateNum, &CrateMetadata, Option<CrateSource>),\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n             let origin = self.opt_used_crate_source(k);\n@@ -182,6 +184,30 @@ impl CStore {\n         self.statically_included_foreign_items.borrow_mut().clear();\n     }\n \n+    pub fn crate_dependencies_in_rpo(&self, krate: ast::CrateNum) -> Vec<ast::CrateNum>\n+    {\n+        let mut ordering = Vec::new();\n+        self.push_dependencies_in_postorder(&mut ordering, krate);\n+        ordering.reverse();\n+        ordering\n+    }\n+\n+    pub fn push_dependencies_in_postorder(&self,\n+                                          ordering: &mut Vec<ast::CrateNum>,\n+                                          krate: ast::CrateNum)\n+    {\n+        if ordering.contains(&krate) { return }\n+\n+        let data = self.get_crate_data(krate);\n+        for &dep in data.cnum_map.borrow().iter() {\n+            if dep != krate {\n+                self.push_dependencies_in_postorder(ordering, dep);\n+            }\n+        }\n+\n+        ordering.push(krate);\n+    }\n+\n     // This method is used when generating the command line to pass through to\n     // system linker. The linker expects undefined symbols on the left of the\n     // command line to be defined in libraries on the right, not the other way\n@@ -194,17 +220,8 @@ impl CStore {\n     pub fn do_get_used_crates(&self, prefer: LinkagePreference)\n                               -> Vec<(ast::CrateNum, Option<PathBuf>)> {\n         let mut ordering = Vec::new();\n-        fn visit(cstore: &CStore, cnum: ast::CrateNum,\n-                 ordering: &mut Vec<ast::CrateNum>) {\n-            if ordering.contains(&cnum) { return }\n-            let meta = cstore.get_crate_data(cnum);\n-            for (_, &dep) in meta.cnum_map.borrow().iter() {\n-                visit(cstore, dep, ordering);\n-            }\n-            ordering.push(cnum);\n-        }\n         for (&num, _) in self.metas.borrow().iter() {\n-            visit(self, num, &mut ordering);\n+            self.push_dependencies_in_postorder(&mut ordering, num);\n         }\n         info!(\"topological ordering: {:?}\", ordering);\n         ordering.reverse();\n@@ -264,7 +281,7 @@ impl CStore {\n     }\n }\n \n-impl crate_metadata {\n+impl CrateMetadata {\n     pub fn data<'a>(&'a self) -> &'a [u8] { self.data.as_slice() }\n     pub fn name(&self) -> &str { decoder::get_crate_name(self.data()) }\n     pub fn hash(&self) -> Svh { decoder::get_crate_hash(self.data()) }\n@@ -312,20 +329,25 @@ impl crate_metadata {\n }\n \n impl MetadataBlob {\n-    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n-        let slice = match *self {\n+    pub fn as_slice_raw<'a>(&'a self) -> &'a [u8] {\n+        match *self {\n             MetadataVec(ref vec) => &vec[..],\n             MetadataArchive(ref ar) => ar.as_slice(),\n-        };\n-        if slice.len() < 4 {\n+        }\n+    }\n+\n+    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n+        let slice = self.as_slice_raw();\n+        let len_offset = 4 + common::metadata_encoding_version.len();\n+        if slice.len() < len_offset+4 {\n             &[] // corrupt metadata\n         } else {\n-            let len = (((slice[0] as u32) << 24) |\n-                       ((slice[1] as u32) << 16) |\n-                       ((slice[2] as u32) << 8) |\n-                       ((slice[3] as u32) << 0)) as usize;\n-            if len + 4 <= slice.len() {\n-                &slice[4.. len + 4]\n+            let len = (((slice[len_offset+0] as u32) << 24) |\n+                       ((slice[len_offset+1] as u32) << 16) |\n+                       ((slice[len_offset+2] as u32) << 8) |\n+                       ((slice[len_offset+3] as u32) << 0)) as usize;\n+            if len <= slice.len() - 4 - len_offset {\n+                &slice[len_offset + 4..len_offset + len + 4]\n             } else {\n                 &[] // corrupt or old metadata\n             }"}, {"sha": "0a59c152ca379273cd99d7b9e369b542abf97fcb", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -15,7 +15,7 @@\n use self::Family::*;\n \n use astencode::decode_inlined_item;\n-use cstore::{self, crate_metadata};\n+use cstore::{self, CrateMetadata};\n use common::*;\n use def_key;\n use encoder::def_to_u64;\n@@ -30,7 +30,7 @@ use rustc::util::nodemap::FnvHashMap;\n use rustc::hir;\n use rustc::session::config::PanicStrategy;\n \n-use middle::cstore::{LOCAL_CRATE, FoundAst, InlinedItem, LinkagePreference};\n+use middle::cstore::{FoundAst, InlinedItem, LinkagePreference};\n use middle::cstore::{DefLike, DlDef, DlField, DlImpl, tls};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex};\n@@ -61,9 +61,9 @@ use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax_pos::{self, Span, BytePos, NO_EXPANSION};\n \n-pub type Cmd<'a> = &'a crate_metadata;\n+pub type Cmd<'a> = &'a CrateMetadata;\n \n-impl crate_metadata {\n+impl CrateMetadata {\n     fn get_item(&self, item_id: DefIndex) -> Option<rbml::Doc> {\n         self.index.lookup_item(self.data(), item_id).map(|pos| {\n             reader::doc_at(self.data(), pos as usize).unwrap().doc\n@@ -663,7 +663,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                                      mut get_crate_data: G,\n                                      mut callback: F) where\n     F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n+    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n {\n     // Iterate over all children.\n     for child_info_doc in reader::tagged_docs(item_doc, tag_mod_child) {\n@@ -758,7 +758,7 @@ pub fn each_child_of_item<F, G>(intr: Rc<IdentInterner>,\n                                get_crate_data: G,\n                                callback: F) where\n     F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n+    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n {\n     // Find the item.\n     let item_doc = match cdata.get_item(id) {\n@@ -779,7 +779,7 @@ pub fn each_top_level_item_of_crate<F, G>(intr: Rc<IdentInterner>,\n                                           get_crate_data: G,\n                                           callback: F) where\n     F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n+    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n {\n     let root_doc = rbml::Doc::new(cdata.data());\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n@@ -1348,25 +1348,16 @@ pub fn translate_def_id(cdata: Cmd, did: DefId) -> DefId {\n         return DefId { krate: cdata.cnum, index: did.index };\n     }\n \n-    match cdata.cnum_map.borrow().get(&did.krate) {\n-        Some(&n) => {\n-            DefId {\n-                krate: n,\n-                index: did.index,\n-            }\n-        }\n-        None => bug!(\"didn't find a crate in the cnum_map\")\n+    DefId {\n+        krate: cdata.cnum_map.borrow()[did.krate],\n+        index: did.index\n     }\n }\n \n // Translate a DefId from the current compilation environment to a DefId\n // for an external crate.\n fn reverse_translate_def_id(cdata: Cmd, did: DefId) -> Option<DefId> {\n-    if did.krate == cdata.cnum {\n-        return Some(DefId { krate: LOCAL_CRATE, index: did.index });\n-    }\n-\n-    for (&local, &global) in cdata.cnum_map.borrow().iter() {\n+    for (local, &global) in cdata.cnum_map.borrow().iter_enumerated() {\n         if global == did.krate {\n             return Some(DefId { krate: local, index: did.index });\n         }\n@@ -1545,10 +1536,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n         let cnum = spec.split(':').nth(0).unwrap();\n         let link = spec.split(':').nth(1).unwrap();\n         let cnum: ast::CrateNum = cnum.parse().unwrap();\n-        let cnum = match cdata.cnum_map.borrow().get(&cnum) {\n-            Some(&n) => n,\n-            None => bug!(\"didn't find a crate in the cnum_map\")\n-        };\n+        let cnum = cdata.cnum_map.borrow()[cnum];\n         result.push((cnum, if link == \"d\" {\n             LinkagePreference::RequireDynamic\n         } else {"}, {"sha": "b6f49569958d68189effffc864b47396c1029410", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -1351,6 +1351,7 @@ fn my_visit_expr(expr: &hir::Expr,\n \n             rbml_w.start_tag(tag_items_data_item);\n             encode_def_id_and_key(ecx, rbml_w, def_id);\n+            encode_name(rbml_w, syntax::parse::token::intern(\"<closure>\"));\n \n             rbml_w.start_tag(tag_items_closure_ty);\n             write_closure_type(ecx, rbml_w, &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n@@ -1505,7 +1506,7 @@ fn encode_polarity(rbml_w: &mut Encoder, polarity: hir::ImplPolarity) {\n \n fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n     fn get_ordered_deps(cstore: &cstore::CStore)\n-                        -> Vec<(CrateNum, Rc<cstore::crate_metadata>)> {\n+                        -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = Vec::new();\n         cstore.iter_crate_data(|cnum, val| {\n@@ -1736,7 +1737,7 @@ fn encode_reachable(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n }\n \n fn encode_crate_dep(rbml_w: &mut Encoder,\n-                    dep: &cstore::crate_metadata) {\n+                    dep: &cstore::CrateMetadata) {\n     rbml_w.start_tag(tag_crate_dep);\n     rbml_w.wr_tagged_str(tag_crate_dep_crate_name, &dep.name());\n     let hash = decoder::get_crate_hash(dep.data());\n@@ -1798,10 +1799,6 @@ fn encode_panic_strategy(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n     }\n }\n \n-// NB: Increment this as you change the metadata encoding version.\n-#[allow(non_upper_case_globals)]\n-pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2 ];\n-\n pub fn encode_metadata(ecx: EncodeContext, krate: &hir::Crate) -> Vec<u8> {\n     let mut wr = Cursor::new(Vec::new());\n \n@@ -1835,12 +1832,25 @@ pub fn encode_metadata(ecx: EncodeContext, krate: &hir::Crate) -> Vec<u8> {\n     // the length of the metadata to the start of the metadata. Later on this\n     // will allow us to slice the metadata to the precise length that we just\n     // generated regardless of trailing bytes that end up in it.\n-    let len = v.len() as u32;\n-    v.insert(0, (len >>  0) as u8);\n-    v.insert(0, (len >>  8) as u8);\n-    v.insert(0, (len >> 16) as u8);\n-    v.insert(0, (len >> 24) as u8);\n-    return v;\n+    //\n+    // We also need to store the metadata encoding version here, because\n+    // rlibs don't have it. To get older versions of rustc to ignore\n+    // this metadata, there are 4 zero bytes at the start, which are\n+    // treated as a length of 0 by old compilers.\n+\n+    let len = v.len();\n+    let mut result = vec![];\n+    result.push(0);\n+    result.push(0);\n+    result.push(0);\n+    result.push(0);\n+    result.extend(metadata_encoding_version.iter().cloned());\n+    result.push((len >> 24) as u8);\n+    result.push((len >> 16) as u8);\n+    result.push((len >>  8) as u8);\n+    result.push((len >>  0) as u8);\n+    result.extend(v);\n+    result\n }\n \n fn encode_metadata_inner(rbml_w: &mut Encoder,"}, {"sha": "cd92493e3db703adc8e7931d51357fbc6292406f", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -36,6 +36,7 @@ extern crate rustc_errors as errors;\n \n #[macro_use]\n extern crate rustc;\n+extern crate rustc_data_structures;\n extern crate rustc_back;\n extern crate rustc_llvm;\n extern crate rustc_const_math;"}, {"sha": "edfdbf2aeefa8ab201bc9b8a724723e56d9279ba", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -213,8 +213,8 @@\n //! metadata::loader or metadata::creader for all the juicy details!\n \n use cstore::{MetadataBlob, MetadataVec, MetadataArchive};\n+use common::{metadata_encoding_version, rustc_version};\n use decoder;\n-use encoder;\n \n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n@@ -260,6 +260,7 @@ pub struct Context<'a> {\n     pub rejected_via_hash: Vec<CrateMismatch>,\n     pub rejected_via_triple: Vec<CrateMismatch>,\n     pub rejected_via_kind: Vec<CrateMismatch>,\n+    pub rejected_via_version: Vec<CrateMismatch>,\n     pub should_match_name: bool,\n }\n \n@@ -336,6 +337,10 @@ impl<'a> Context<'a> {\n             struct_span_err!(self.sess, self.span, E0462,\n                              \"found staticlib `{}` instead of rlib or dylib{}\",\n                              self.ident, add)\n+        } else if !self.rejected_via_version.is_empty() {\n+            struct_span_err!(self.sess, self.span, E0514,\n+                             \"found crate `{}` compiled by an incompatible version of rustc{}\",\n+                             self.ident, add)\n         } else {\n             struct_span_err!(self.sess, self.span, E0463,\n                              \"can't find crate for `{}`{}\",\n@@ -350,7 +355,7 @@ impl<'a> Context<'a> {\n             }\n         }\n         if !self.rejected_via_hash.is_empty() {\n-            err.note(\"perhaps this crate needs to be recompiled?\");\n+            err.note(\"perhaps that crate needs to be recompiled?\");\n             let mismatches = self.rejected_via_hash.iter();\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n                 err.note(&format!(\"crate `{}` path #{}: {}\",\n@@ -367,13 +372,22 @@ impl<'a> Context<'a> {\n             }\n         }\n         if !self.rejected_via_kind.is_empty() {\n-            err.help(\"please recompile this crate using --crate-type lib\");\n+            err.help(\"please recompile that crate using --crate-type lib\");\n             let mismatches = self.rejected_via_kind.iter();\n             for (i, &CrateMismatch { ref path, .. }) in mismatches.enumerate() {\n                 err.note(&format!(\"crate `{}` path #{}: {}\",\n                                   self.ident, i+1, path.display()));\n             }\n         }\n+        if !self.rejected_via_version.is_empty() {\n+            err.help(&format!(\"please recompile that crate using this compiler ({})\",\n+                              rustc_version()));\n+            let mismatches = self.rejected_via_version.iter();\n+            for (i, &CrateMismatch { ref path, ref got }) in mismatches.enumerate() {\n+                err.note(&format!(\"crate `{}` path #{}: {} compiled by {:?}\",\n+                                  self.ident, i+1, path.display(), got));\n+            }\n+        }\n \n         err.emit();\n         self.sess.abort_if_errors();\n@@ -591,6 +605,17 @@ impl<'a> Context<'a> {\n     }\n \n     fn crate_matches(&mut self, crate_data: &[u8], libpath: &Path) -> Option<Svh> {\n+        let crate_rustc_version = decoder::crate_rustc_version(crate_data);\n+        if crate_rustc_version != Some(rustc_version()) {\n+            let message = crate_rustc_version.unwrap_or(format!(\"an unknown compiler\"));\n+            info!(\"Rejecting via version: expected {} got {}\", rustc_version(), message);\n+            self.rejected_via_version.push(CrateMismatch {\n+                path: libpath.to_path_buf(),\n+                got: message\n+            });\n+            return None;\n+        }\n+\n         if self.should_match_name {\n             match decoder::maybe_get_crate_name(crate_data) {\n                 Some(ref name) if self.crate_name == *name => {}\n@@ -742,6 +767,21 @@ impl ArchiveMetadata {\n     pub fn as_slice<'a>(&'a self) -> &'a [u8] { unsafe { &*self.data } }\n }\n \n+fn verify_decompressed_encoding_version(blob: &MetadataBlob, filename: &Path)\n+                                        -> Result<(), String>\n+{\n+    let data = blob.as_slice_raw();\n+    if data.len() < 4+metadata_encoding_version.len() ||\n+        !<[u8]>::eq(&data[..4], &[0, 0, 0, 0]) ||\n+        &data[4..4+metadata_encoding_version.len()] != metadata_encoding_version\n+    {\n+        Err((format!(\"incompatible metadata version found: '{}'\",\n+                     filename.display())))\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n // Just a small wrapper to time how long reading metadata takes.\n fn get_metadata_section(target: &Target, flavor: CrateFlavor, filename: &Path)\n                         -> Result<MetadataBlob, String> {\n@@ -772,7 +812,10 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n         return match ArchiveMetadata::new(archive).map(|ar| MetadataArchive(ar)) {\n             None => Err(format!(\"failed to read rlib metadata: '{}'\",\n                                 filename.display())),\n-            Some(blob) => Ok(blob)\n+            Some(blob) => {\n+                try!(verify_decompressed_encoding_version(&blob, filename));\n+                Ok(blob)\n+            }\n         };\n     }\n     unsafe {\n@@ -801,12 +844,12 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n                 let cvbuf: *const u8 = cbuf as *const u8;\n-                let vlen = encoder::metadata_encoding_version.len();\n+                let vlen = metadata_encoding_version.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);\n                 let minsz = cmp::min(vlen, csz);\n                 let buf0 = slice::from_raw_parts(cvbuf, minsz);\n-                let version_ok = buf0 == encoder::metadata_encoding_version;\n+                let version_ok = buf0 == metadata_encoding_version;\n                 if !version_ok {\n                     return Err((format!(\"incompatible metadata version found: '{}'\",\n                                         filename.display())));\n@@ -817,7 +860,11 @@ fn get_metadata_section_imp(target: &Target, flavor: CrateFlavor, filename: &Pat\n                        csz - vlen);\n                 let bytes = slice::from_raw_parts(cvbuf1, csz - vlen);\n                 match flate::inflate_bytes(bytes) {\n-                    Ok(inflated) => return Ok(MetadataVec(inflated)),\n+                    Ok(inflated) => {\n+                        let blob = MetadataVec(inflated);\n+                        try!(verify_decompressed_encoding_version(&blob, filename));\n+                        return Ok(blob);\n+                    }\n                     Err(_) => {}\n                 }\n             }"}, {"sha": "ab859b88a85972d55200ba32260199974fa94422", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -169,8 +169,7 @@ pub struct Instance<'tcx> {\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ppaux::parameterized(f, &self.substs, self.def, ppaux::Ns::Value, &[],\n-                             |tcx| Some(tcx.lookup_item_type(self.def).generics))\n+        ppaux::parameterized(f, &self.substs, self.def, ppaux::Ns::Value, &[], |_| None)\n     }\n }\n "}, {"sha": "c9d1eb39f0a3de464f6028d192e6ad4737ceb1e0", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -213,6 +213,7 @@ dependencies = [\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"serialize 0.0.0\","}, {"sha": "f74855a0849b15ac8698d4fad29c5a1b75c50963", "filename": "src/test/compile-fail/changing-crates.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fchanging-crates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fchanging-crates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchanging-crates.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -17,7 +17,7 @@\n \n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n-//~| NOTE: perhaps this crate needs to be recompiled\n+//~| NOTE: perhaps that crate needs to be recompiled\n //~| NOTE: crate `a` path #1:\n //~| NOTE: crate `b` path #1:\n "}, {"sha": "1638caaa9233740e63a0a19586448ccfcc447516", "filename": "src/test/compile-fail/svh-change-lit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fsvh-change-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fsvh-change-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-lit.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -17,7 +17,7 @@\n \n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n-//~| NOTE: perhaps this crate needs to be recompiled\n+//~| NOTE: perhaps that crate needs to be recompiled\n //~| NOTE: crate `a` path #1:\n //~| NOTE: crate `b` path #1:\n "}, {"sha": "99523ca699f0ead6f703b37835dc1916505f8cd1", "filename": "src/test/compile-fail/svh-change-significant-cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fsvh-change-significant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fsvh-change-significant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-significant-cfg.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -17,7 +17,7 @@\n \n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n-//~| NOTE: perhaps this crate needs to be recompiled\n+//~| NOTE: perhaps that crate needs to be recompiled\n //~| NOTE: crate `a` path #1:\n //~| NOTE: crate `b` path #1:\n "}, {"sha": "dcf4859792d280912295e2c0c7a1f6afafb3d7ad", "filename": "src/test/compile-fail/svh-change-trait-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fsvh-change-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fsvh-change-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-trait-bound.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -17,7 +17,7 @@\n \n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n-//~| NOTE: perhaps this crate needs to be recompiled\n+//~| NOTE: perhaps that crate needs to be recompiled\n //~| NOTE: crate `a` path #1:\n //~| NOTE: crate `b` path #1:\n "}, {"sha": "7e51ca456b21a4607bf75e4a92fbe92802200094", "filename": "src/test/compile-fail/svh-change-type-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-arg.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -17,7 +17,7 @@\n \n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n-//~| NOTE: perhaps this crate needs to be recompiled\n+//~| NOTE: perhaps that crate needs to be recompiled\n //~| NOTE: crate `a` path #1:\n //~| NOTE: crate `b` path #1:\n "}, {"sha": "54ca87d84c1ec371df5a16b03efbd17ddfcb51e0", "filename": "src/test/compile-fail/svh-change-type-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-ret.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -17,7 +17,7 @@\n \n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n-//~| NOTE: perhaps this crate needs to be recompiled\n+//~| NOTE: perhaps that crate needs to be recompiled\n //~| NOTE: crate `a` path #1:\n //~| NOTE: crate `b` path #1:\n "}, {"sha": "ea90faaf610888bdb402fd2b9298f873e541508b", "filename": "src/test/compile-fail/svh-change-type-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-static.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -17,7 +17,7 @@\n \n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n-//~| NOTE: perhaps this crate needs to be recompiled\n+//~| NOTE: perhaps that crate needs to be recompiled\n //~| NOTE: crate `a` path #1:\n //~| NOTE: crate `b` path #1:\n "}, {"sha": "c0a5a0a17eb2655c8d0d9bcd87b102cb7515a6e7", "filename": "src/test/compile-fail/svh-use-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fsvh-use-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Fcompile-fail%2Fsvh-use-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-use-trait.rs?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -22,7 +22,7 @@\n \n extern crate uta;\n extern crate utb; //~ ERROR: found possibly newer version of crate `uta` which `utb` depends\n-//~| NOTE: perhaps this crate needs to be recompiled?\n+//~| NOTE: perhaps that crate needs to be recompiled?\n //~| NOTE: crate `uta` path #1:\n //~| NOTE: crate `utb` path #1:\n "}, {"sha": "0da4af34ef03d9ae30dd28a9200174f47f21ee55", "filename": "src/test/run-make/many-crates-but-no-match/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7a262d303489fcbd8410b4e4cecc563b06799e16/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile?ref=7a262d303489fcbd8410b4e4cecc563b06799e16", "patch": "@@ -28,7 +28,7 @@ all:\n \t# Ensure crateC fails to compile since A1 is \"missing\" and A2/A3 hashes do not match\n \t$(RUSTC) -L $(A2) -L $(A3) crateC.rs >$(LOG) 2>&1 || true\n \tgrep \"error: found possibly newer version of crate \\`crateA\\` which \\`crateB\\` depends on\" $(LOG)\n-\tgrep \"note: perhaps this crate needs to be recompiled?\" $(LOG)\n+\tgrep \"note: perhaps that crate needs to be recompiled?\" $(LOG)\n \tgrep \"note: crate \\`crateA\\` path #1:\" $(LOG)\n \tgrep \"note: crate \\`crateA\\` path #2:\" $(LOG)\n \tgrep \"note: crate \\`crateB\\` path #1:\" $(LOG)"}]}