{"sha": "ec7ed054e06cb2e23fd3911932766b32014c8fa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjN2VkMDU0ZTA2Y2IyZTIzZmQzOTExOTMyNzY2YjMyMDE0YzhmYTE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-24T12:28:50Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-24T12:28:50Z"}, "message": "Functions use new id scheme", "tree": {"sha": "c06ed85f44afc261c483ff7b87e1a7aa33c198a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c06ed85f44afc261c483ff7b87e1a7aa33c198a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec7ed054e06cb2e23fd3911932766b32014c8fa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec7ed054e06cb2e23fd3911932766b32014c8fa1", "html_url": "https://github.com/rust-lang/rust/commit/ec7ed054e06cb2e23fd3911932766b32014c8fa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec7ed054e06cb2e23fd3911932766b32014c8fa1/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1959bbae0cf2f99e63d074278cec165c274b4e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1959bbae0cf2f99e63d074278cec165c274b4e5", "html_url": "https://github.com/rust-lang/rust/commit/f1959bbae0cf2f99e63d074278cec165c274b4e5"}], "stats": {"total": 498, "additions": 297, "deletions": 201}, "files": [{"sha": "9056151277e329b93fdf2a40229e458b8dba9ea2", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=ec7ed054e06cb2e23fd3911932766b32014c8fa1", "patch": "@@ -16,6 +16,7 @@ use crate::{\n     code_model_impl::def_id_to_ast,\n     docs::{Documentation, Docs, docs_from_ast},\n     module_tree::ModuleId,\n+    ids::FunctionId,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -49,7 +50,6 @@ pub enum Def {\n     Struct(Struct),\n     Enum(Enum),\n     EnumVariant(EnumVariant),\n-    Function(Function),\n     Const(Const),\n     Static(Static),\n     Trait(Trait),\n@@ -67,6 +67,7 @@ pub struct Module {\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum ModuleDef {\n     Module(Module),\n+    Function(Function),\n     Def(DefId),\n }\n \n@@ -76,6 +77,12 @@ impl Into<ModuleDef> for Module {\n     }\n }\n \n+impl Into<ModuleDef> for Function {\n+    fn into(self) -> ModuleDef {\n+        ModuleDef::Function(self)\n+    }\n+}\n+\n impl Into<ModuleDef> for DefId {\n     fn into(self) -> ModuleDef {\n         ModuleDef::Def(self)\n@@ -225,7 +232,7 @@ impl Struct {\n     }\n \n     pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n-        db.generic_params(self.def_id)\n+        db.generic_params(self.def_id.into())\n     }\n }\n \n@@ -262,7 +269,7 @@ impl Enum {\n     }\n \n     pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n-        db.generic_params(self.def_id)\n+        db.generic_params(self.def_id.into())\n     }\n }\n \n@@ -320,9 +327,9 @@ impl Docs for EnumVariant {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Function {\n-    pub(crate) def_id: DefId,\n+    pub(crate) id: FunctionId,\n }\n \n pub use crate::code_model_impl::function::ScopeEntryWithSyntax;\n@@ -359,37 +366,33 @@ impl FnSignature {\n }\n \n impl Function {\n-    pub fn def_id(&self) -> DefId {\n-        self.def_id\n-    }\n-\n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::FnDef>) {\n-        def_id_to_ast(db, self.def_id)\n+        self.id.loc(db).source(db)\n     }\n \n     pub fn body_syntax_mapping(&self, db: &impl HirDatabase) -> Arc<BodySyntaxMapping> {\n-        db.body_syntax_mapping(self.def_id)\n+        db.body_syntax_mapping(*self)\n     }\n \n     pub fn scopes(&self, db: &impl HirDatabase) -> ScopesWithSyntaxMapping {\n-        let scopes = db.fn_scopes(self.def_id);\n-        let syntax_mapping = db.body_syntax_mapping(self.def_id);\n+        let scopes = db.fn_scopes(*self);\n+        let syntax_mapping = db.body_syntax_mapping(*self);\n         ScopesWithSyntaxMapping {\n             scopes,\n             syntax_mapping,\n         }\n     }\n \n     pub fn signature(&self, db: &impl HirDatabase) -> Arc<FnSignature> {\n-        db.fn_signature(self.def_id)\n+        db.fn_signature(*self)\n     }\n \n     pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n-        db.infer(self.def_id)\n+        db.infer(*self)\n     }\n \n     pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n-        db.generic_params(self.def_id)\n+        db.generic_params((*self).into())\n     }\n }\n \n@@ -456,7 +459,7 @@ impl Trait {\n     }\n \n     pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n-        db.generic_params(self.def_id)\n+        db.generic_params(self.def_id.into())\n     }\n }\n \n@@ -481,7 +484,7 @@ impl Type {\n     }\n \n     pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n-        db.generic_params(self.def_id)\n+        db.generic_params(self.def_id.into())\n     }\n }\n "}, {"sha": "d8dafb10e4eab0c91f52b5858f2e314fa87e73e9", "filename": "crates/ra_hir/src/code_model_impl/function.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs?ref=ec7ed054e06cb2e23fd3911932766b32014c8fa1", "patch": "@@ -2,41 +2,48 @@ mod scope;\n \n use std::sync::Arc;\n \n-use ra_syntax::{TreeArc, ast::{self, NameOwner}};\n+use ra_syntax::ast::{self, NameOwner};\n \n use crate::{\n-    DefId, HirDatabase, Name, AsName, Function, FnSignature, Module,\n+    HirDatabase, Name, AsName, Function, FnSignature, Module, HirFileId,\n     type_ref::{TypeRef, Mutability},\n     expr::Body,\n     impl_block::ImplBlock,\n-    code_model_impl::def_id_to_ast,\n+    ids::FunctionLoc,\n };\n \n pub use self::scope::{FnScopes, ScopesWithSyntaxMapping, ScopeEntryWithSyntax};\n \n impl Function {\n-    pub(crate) fn new(def_id: DefId) -> Function {\n-        Function { def_id }\n+    pub(crate) fn from_ast(\n+        db: &impl HirDatabase,\n+        module: Module,\n+        file_id: HirFileId,\n+        ast: &ast::FnDef,\n+    ) -> Function {\n+        let loc: FunctionLoc = FunctionLoc::from_ast(db, module, file_id, ast);\n+        let id = loc.id(db);\n+        Function { id }\n     }\n \n     pub(crate) fn body(&self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body_hir(self.def_id)\n+        db.body_hir(*self)\n     }\n \n     pub(crate) fn module(&self, db: &impl HirDatabase) -> Module {\n-        self.def_id.module(db)\n+        self.id.loc(db).module\n     }\n \n     /// The containing impl block, if this is a method.\n     pub(crate) fn impl_block(&self, db: &impl HirDatabase) -> Option<ImplBlock> {\n-        self.def_id.impl_block(db)\n+        let module_impls = db.impls_in_module(self.module(db));\n+        ImplBlock::containing(module_impls, (*self).into())\n     }\n }\n \n impl FnSignature {\n-    pub(crate) fn fn_signature_query(db: &impl HirDatabase, def_id: DefId) -> Arc<FnSignature> {\n-        // FIXME: we're using def_id_to_ast here to avoid returning Cancelable... this is a bit hacky\n-        let node: TreeArc<ast::FnDef> = def_id_to_ast(db, def_id).1;\n+    pub(crate) fn fn_signature_query(db: &impl HirDatabase, func: Function) -> Arc<FnSignature> {\n+        let (_, node) = func.source(db);\n         let name = node\n             .name()\n             .map(|n| n.as_name())"}, {"sha": "b2828c7be0a9c25fb1384d84b467470bab1dd696", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=ec7ed054e06cb2e23fd3911932766b32014c8fa1", "patch": "@@ -135,6 +135,7 @@ impl Module {\n                         None => PerNs::none(),\n                     }\n                 }\n+                ModuleDef::Function(_) => PerNs::none(),\n                 ModuleDef::Def(def) => {\n                     match def.resolve(db) {\n                         Def::Enum(e) => {"}, {"sha": "97de7da317761cdf9964e2d8469b098f0261b79b", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=ec7ed054e06cb2e23fd3911932766b32014c8fa1", "patch": "@@ -7,14 +7,14 @@ use crate::{\n     DefId, MacroCallId, Name, HirFileId,\n     SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n     query_definitions,\n-    FnSignature, FnScopes,\n+    Function, FnSignature, FnScopes,\n     macros::MacroExpansion,\n     module_tree::ModuleTree,\n     nameres::{ItemMap, lower::{LoweredModule, ImportSourceMap}},\n-    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks},\n+    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef},\n     adt::{StructData, EnumData, EnumVariantData},\n     impl_block::ModuleImplBlocks,\n-    generics::GenericParams,\n+    generics::{GenericParams, GenericDef},\n };\n \n #[salsa::query_group]\n@@ -26,7 +26,7 @@ pub trait HirDatabase: SyntaxDatabase + AsRef<HirInterner> {\n     fn expand_macro_invocation(&self, invoc: MacroCallId) -> Option<Arc<MacroExpansion>>;\n \n     #[salsa::invoke(query_definitions::fn_scopes)]\n-    fn fn_scopes(&self, def_id: DefId) -> Arc<FnScopes>;\n+    fn fn_scopes(&self, func: Function) -> Arc<FnScopes>;\n \n     #[salsa::invoke(crate::adt::StructData::struct_data_query)]\n     fn struct_data(&self, def_id: DefId) -> Arc<StructData>;\n@@ -38,10 +38,10 @@ pub trait HirDatabase: SyntaxDatabase + AsRef<HirInterner> {\n     fn enum_variant_data(&self, def_id: DefId) -> Arc<EnumVariantData>;\n \n     #[salsa::invoke(crate::ty::infer)]\n-    fn infer(&self, def_id: DefId) -> Arc<InferenceResult>;\n+    fn infer(&self, func: Function) -> Arc<InferenceResult>;\n \n     #[salsa::invoke(crate::ty::type_for_def)]\n-    fn type_for_def(&self, def_id: DefId) -> Ty;\n+    fn type_for_def(&self, def: TypableDef) -> Ty;\n \n     #[salsa::invoke(crate::ty::type_for_field)]\n     fn type_for_field(&self, def_id: DefId, field: Name) -> Option<Ty>;\n@@ -77,14 +77,14 @@ pub trait HirDatabase: SyntaxDatabase + AsRef<HirInterner> {\n     fn impls_in_crate(&self, krate: Crate) -> Arc<CrateImplBlocks>;\n \n     #[salsa::invoke(crate::expr::body_hir)]\n-    fn body_hir(&self, def_id: DefId) -> Arc<crate::expr::Body>;\n+    fn body_hir(&self, func: Function) -> Arc<crate::expr::Body>;\n \n     #[salsa::invoke(crate::expr::body_syntax_mapping)]\n-    fn body_syntax_mapping(&self, def_id: DefId) -> Arc<crate::expr::BodySyntaxMapping>;\n+    fn body_syntax_mapping(&self, func: Function) -> Arc<crate::expr::BodySyntaxMapping>;\n \n     #[salsa::invoke(crate::generics::GenericParams::generic_params_query)]\n-    fn generic_params(&self, def_id: DefId) -> Arc<GenericParams>;\n+    fn generic_params(&self, def: GenericDef) -> Arc<GenericParams>;\n \n     #[salsa::invoke(crate::FnSignature::fn_signature_query)]\n-    fn fn_signature(&self, def_id: DefId) -> Arc<FnSignature>;\n+    fn fn_signature(&self, func: Function) -> Arc<FnSignature>;\n }"}, {"sha": "29469af2cf3021f87bf0183f52f3fea10c6b9d6c", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=ec7ed054e06cb2e23fd3911932766b32014c8fa1", "patch": "@@ -9,7 +9,11 @@ use ra_syntax::{\n     ast::{self, LoopBodyOwner, ArgListOwner, NameOwner, LiteralFlavor}\n };\n \n-use crate::{Path, type_ref::{Mutability, TypeRef}, Name, HirDatabase, DefId, Def, name::AsName};\n+use crate::{\n+    Path, Name, HirDatabase, Function,\n+    name::AsName,\n+    type_ref::{Mutability, TypeRef},\n+};\n use crate::ty::primitive::{UintTy, UncertainIntTy, UncertainFloatTy};\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -435,8 +439,8 @@ impl Pat {\n \n // Queries\n \n-pub(crate) fn body_hir(db: &impl HirDatabase, def_id: DefId) -> Arc<Body> {\n-    Arc::clone(&body_syntax_mapping(db, def_id).body)\n+pub(crate) fn body_hir(db: &impl HirDatabase, func: Function) -> Arc<Body> {\n+    Arc::clone(&body_syntax_mapping(db, func).body)\n }\n \n struct ExprCollector {\n@@ -955,14 +959,8 @@ pub(crate) fn collect_fn_body_syntax(node: &ast::FnDef) -> BodySyntaxMapping {\n     collector.into_body_syntax_mapping(params, body)\n }\n \n-pub(crate) fn body_syntax_mapping(db: &impl HirDatabase, def_id: DefId) -> Arc<BodySyntaxMapping> {\n-    let def = def_id.resolve(db);\n-\n-    let body_syntax_mapping = match def {\n-        Def::Function(f) => collect_fn_body_syntax(&f.source(db).1),\n-        // TODO: consts, etc.\n-        _ => panic!(\"Trying to get body for item type without body\"),\n-    };\n-\n+pub(crate) fn body_syntax_mapping(db: &impl HirDatabase, func: Function) -> Arc<BodySyntaxMapping> {\n+    let (_, fn_def) = func.source(db);\n+    let body_syntax_mapping = collect_fn_body_syntax(&fn_def);\n     Arc::new(body_syntax_mapping)\n }"}, {"sha": "88c53705fa4ba1a0ea93b97138cbc83a3755d488", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=ec7ed054e06cb2e23fd3911932766b32014c8fa1", "patch": "@@ -5,9 +5,9 @@\n \n use std::sync::Arc;\n \n-use ra_syntax::ast::{TypeParamList, AstNode, NameOwner};\n+use ra_syntax::ast::{self, AstNode, NameOwner, TypeParamsOwner};\n \n-use crate::{db::HirDatabase, DefId, Name, AsName};\n+use crate::{db::HirDatabase, DefId, Name, AsName, Function};\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -22,26 +22,62 @@ pub struct GenericParams {\n     pub(crate) params: Vec<GenericParam>,\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n+pub enum GenericDef {\n+    Function(Function),\n+    Def(DefId),\n+}\n+\n+impl From<Function> for GenericDef {\n+    fn from(func: Function) -> GenericDef {\n+        GenericDef::Function(func)\n+    }\n+}\n+\n+impl From<DefId> for GenericDef {\n+    fn from(def_id: DefId) -> GenericDef {\n+        GenericDef::Def(def_id)\n+    }\n+}\n+\n impl GenericParams {\n-    pub(crate) fn generic_params_query(db: &impl HirDatabase, def_id: DefId) -> Arc<GenericParams> {\n-        let (_file_id, node) = def_id.source(db);\n+    pub(crate) fn generic_params_query(\n+        db: &impl HirDatabase,\n+        def: GenericDef,\n+    ) -> Arc<GenericParams> {\n         let mut generics = GenericParams::default();\n-        if let Some(type_param_list) = node.children().find_map(TypeParamList::cast) {\n-            for (idx, type_param) in type_param_list.type_params().enumerate() {\n-                let name = type_param\n-                    .name()\n-                    .map(AsName::as_name)\n-                    .unwrap_or_else(Name::missing);\n-                let param = GenericParam {\n-                    idx: idx as u32,\n-                    name,\n-                };\n-                generics.params.push(param);\n+        match def {\n+            GenericDef::Function(func) => {\n+                let (_, fn_def) = func.source(db);\n+                if let Some(type_param_list) = fn_def.type_param_list() {\n+                    generics.fill(type_param_list)\n+                }\n+            }\n+            GenericDef::Def(def_id) => {\n+                let (_file_id, node) = def_id.source(db);\n+                if let Some(type_param_list) = node.children().find_map(ast::TypeParamList::cast) {\n+                    generics.fill(type_param_list)\n+                }\n             }\n         }\n+\n         Arc::new(generics)\n     }\n \n+    fn fill(&mut self, params: &ast::TypeParamList) {\n+        for (idx, type_param) in params.type_params().enumerate() {\n+            let name = type_param\n+                .name()\n+                .map(AsName::as_name)\n+                .unwrap_or_else(Name::missing);\n+            let param = GenericParam {\n+                idx: idx as u32,\n+                name,\n+            };\n+            self.params.push(param);\n+        }\n+    }\n+\n     pub(crate) fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {\n         self.params.iter().find(|p| &p.name == name)\n     }"}, {"sha": "913341bd51141574b2d4293bae778c3141bdf2fe", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=ec7ed054e06cb2e23fd3911932766b32014c8fa1", "patch": "@@ -1,9 +1,11 @@\n+use std::marker::PhantomData;\n+\n use ra_db::{LocationIntener, FileId};\n use ra_syntax::{TreeArc, SyntaxNode, SourceFile, AstNode, ast};\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n use crate::{\n-    HirDatabase, Def, Function, Struct, Enum, EnumVariant, ImplBlock, Crate,\n+    HirDatabase, Def, Struct, Enum, EnumVariant, Crate,\n     Module, Trait, Type, Static, Const,\n };\n \n@@ -129,15 +131,56 @@ impl MacroCallLoc {\n     }\n }\n \n+#[derive(Debug, PartialEq, Eq, Hash)]\n+pub struct ItemLoc<N: AstNode> {\n+    pub(crate) module: Module,\n+    raw: SourceItemId,\n+    _ty: PhantomData<N>,\n+}\n+\n+impl<N: AstNode> ItemLoc<N> {\n+    pub(crate) fn from_ast(\n+        db: &impl HirDatabase,\n+        module: Module,\n+        file_id: HirFileId,\n+        ast: &N,\n+    ) -> ItemLoc<N> {\n+        let items = db.file_items(file_id);\n+        let raw = SourceItemId {\n+            file_id,\n+            item_id: Some(items.id_of(file_id, ast.syntax())),\n+        };\n+        ItemLoc {\n+            module,\n+            raw,\n+            _ty: PhantomData,\n+        }\n+    }\n+\n+    pub(crate) fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<N>) {\n+        let syntax = db.file_item(self.raw);\n+        let ast = N::cast(&syntax)\n+            .unwrap_or_else(|| panic!(\"invalid ItemLoc: {:?}\", self.raw))\n+            .to_owned();\n+        (self.raw.file_id, ast)\n+    }\n+}\n+\n+impl<N: AstNode> Clone for ItemLoc<N> {\n+    fn clone(&self) -> ItemLoc<N> {\n+        ItemLoc {\n+            module: self.module,\n+            raw: self.raw,\n+            _ty: PhantomData,\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct FunctionId(RawId);\n impl_arena_id!(FunctionId);\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct FunctionLoc {\n-    pub(crate) module: Module,\n-    pub(crate) source_item_id: SourceItemId,\n-}\n+pub(crate) type FunctionLoc = ItemLoc<ast::FnDef>;\n \n impl FunctionId {\n     pub(crate) fn loc(self, db: &impl AsRef<HirInterner>) -> FunctionLoc {\n@@ -196,10 +239,7 @@ impl DefId {\n     pub fn resolve(self, db: &impl HirDatabase) -> Def {\n         let loc = self.loc(db);\n         match loc.kind {\n-            DefKind::Function => {\n-                let function = Function::new(self);\n-                Def::Function(function)\n-            }\n+            DefKind::Function => unreachable!(),\n             DefKind::Struct => {\n                 let struct_def = Struct::new(self);\n                 Def::Struct(struct_def)\n@@ -243,12 +283,6 @@ impl DefId {\n     pub fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n         self.module(db).krate(db)\n     }\n-\n-    /// Returns the containing impl block, if this is an impl item.\n-    pub fn impl_block(self, db: &impl HirDatabase) -> Option<ImplBlock> {\n-        let module_impls = db.impls_in_module(self.loc(db).module);\n-        ImplBlock::containing(module_impls, self)\n-    }\n }\n \n impl DefLoc {"}, {"sha": "29becd317613e0aa8da8c1645834952f55ea8966", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=ec7ed054e06cb2e23fd3911932766b32014c8fa1", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::ast::{self, AstNode};\n \n use crate::{\n     DefId, DefLoc, DefKind, SourceItemId, SourceFileItems,\n-    Function, HirFileId, HirInterner,\n+    Function, HirFileId,\n     db::HirDatabase,\n     type_ref::TypeRef,\n };\n@@ -22,9 +22,9 @@ pub struct ImplBlock {\n impl ImplBlock {\n     pub(crate) fn containing(\n         module_impl_blocks: Arc<ModuleImplBlocks>,\n-        def_id: DefId,\n+        item: ImplItem,\n     ) -> Option<ImplBlock> {\n-        let impl_id = *module_impl_blocks.impls_by_def.get(&def_id)?;\n+        let impl_id = *module_impl_blocks.impls_by_def.get(&item)?;\n         Some(ImplBlock {\n             module_impl_blocks,\n             impl_id,\n@@ -64,7 +64,7 @@ pub struct ImplData {\n \n impl ImplData {\n     pub(crate) fn from_ast(\n-        db: &impl AsRef<HirInterner>,\n+        db: &impl HirDatabase,\n         file_id: HirFileId,\n         file_items: &SourceFileItems,\n         module: Module,\n@@ -93,7 +93,9 @@ impl ImplData {\n                     };\n                     let def_id = def_loc.id(db);\n                     match item_node.kind() {\n-                        ast::ImplItemKind::FnDef(..) => ImplItem::Method(Function::new(def_id)),\n+                        ast::ImplItemKind::FnDef(it) => {\n+                            ImplItem::Method(Function::from_ast(db, module, file_id, it))\n+                        }\n                         ast::ImplItemKind::ConstDef(..) => ImplItem::Const(def_id),\n                         ast::ImplItemKind::TypeDef(..) => ImplItem::Type(def_id),\n                     }\n@@ -122,7 +124,8 @@ impl ImplData {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+//TODO: rename to ImplDef?\n pub enum ImplItem {\n     Method(Function),\n     // these don't have their own types yet\n@@ -131,13 +134,9 @@ pub enum ImplItem {\n     // Existential\n }\n \n-impl ImplItem {\n-    pub fn def_id(&self) -> DefId {\n-        match self {\n-            ImplItem::Method(f) => f.def_id(),\n-            ImplItem::Const(def_id) => *def_id,\n-            ImplItem::Type(def_id) => *def_id,\n-        }\n+impl From<Function> for ImplItem {\n+    fn from(func: Function) -> ImplItem {\n+        ImplItem::Method(func)\n     }\n }\n \n@@ -153,7 +152,7 @@ impl_arena_id!(ImplId);\n #[derive(Debug, PartialEq, Eq)]\n pub struct ModuleImplBlocks {\n     pub(crate) impls: Arena<ImplId, ImplData>,\n-    impls_by_def: FxHashMap<DefId, ImplId>,\n+    impls_by_def: FxHashMap<ImplItem, ImplId>,\n }\n \n impl ModuleImplBlocks {\n@@ -181,8 +180,8 @@ impl ModuleImplBlocks {\n             let impl_block =\n                 ImplData::from_ast(db, file_id, &source_file_items, module, impl_block_ast);\n             let id = self.impls.alloc(impl_block);\n-            for impl_item in &self.impls[id].items {\n-                self.impls_by_def.insert(impl_item.def_id(), id);\n+            for &impl_item in &self.impls[id].items {\n+                self.impls_by_def.insert(impl_item, id);\n             }\n         }\n     }"}, {"sha": "1f8adc7eb18fdc23ad2bf29e53ea986f7e381103", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=ec7ed054e06cb2e23fd3911932766b32014c8fa1", "patch": "@@ -9,7 +9,7 @@ use rustc_hash::FxHashMap;\n \n use crate::{\n     SourceItemId, Path, ModuleSource, HirDatabase, Name, SourceFileItems,\n-    HirFileId, MacroCallLoc, AsName, PerNs, DefKind, DefLoc,\n+    HirFileId, MacroCallLoc, AsName, PerNs, DefKind, DefLoc, Function,\n     ModuleDef, Module,\n };\n \n@@ -149,7 +149,14 @@ impl LoweredModule {\n         let name = match item.kind() {\n             ast::ModuleItemKind::StructDef(it) => it.name(),\n             ast::ModuleItemKind::EnumDef(it) => it.name(),\n-            ast::ModuleItemKind::FnDef(it) => it.name(),\n+            ast::ModuleItemKind::FnDef(it) => {\n+                if let Some(name) = it.name() {\n+                    let func = Function::from_ast(db, module, file_id, it);\n+                    self.declarations\n+                        .insert(name.as_name(), PerNs::values(func.into()));\n+                }\n+                return;\n+            }\n             ast::ModuleItemKind::TraitDef(it) => it.name(),\n             ast::ModuleItemKind::TypeDef(it) => it.name(),\n             ast::ModuleItemKind::ImplBlock(_) => {\n@@ -218,7 +225,7 @@ fn assign_def_id(\n impl DefKind {\n     fn for_syntax_kind(kind: SyntaxKind) -> PerNs<DefKind> {\n         match kind {\n-            SyntaxKind::FN_DEF => PerNs::values(DefKind::Function),\n+            SyntaxKind::FN_DEF => unreachable!(),\n             SyntaxKind::STRUCT_DEF => PerNs::both(DefKind::Struct, DefKind::StructCtor),\n             SyntaxKind::ENUM_DEF => PerNs::types(DefKind::Enum),\n             SyntaxKind::TRAIT_DEF => PerNs::types(DefKind::Trait),"}, {"sha": "cf8c7e4354580e53d6264c0675903813be0cecf3", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=ec7ed054e06cb2e23fd3911932766b32014c8fa1", "patch": "@@ -10,14 +10,14 @@ use ra_syntax::{\n use ra_db::{CrateId};\n \n use crate::{\n-    SourceFileItems, SourceItemId, DefId, HirFileId,\n-    FnScopes, Module,\n+    SourceFileItems, SourceItemId, HirFileId,\n+    Function, FnScopes, Module,\n     db::HirDatabase,\n     nameres::{ItemMap, Resolver},\n };\n \n-pub(super) fn fn_scopes(db: &impl HirDatabase, def_id: DefId) -> Arc<FnScopes> {\n-    let body = db.body_hir(def_id);\n+pub(super) fn fn_scopes(db: &impl HirDatabase, func: Function) -> Arc<FnScopes> {\n+    let body = db.body_hir(func);\n     let res = FnScopes::new(body);\n     Arc::new(res)\n }"}, {"sha": "d1bf163d1460f34ca4ca61615ca24f201ce5aca7", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=ec7ed054e06cb2e23fd3911932766b32014c8fa1", "patch": "@@ -14,7 +14,7 @@ use ra_syntax::{\n \n use crate::{\n     HirDatabase, Function, SourceItemId, ModuleDef,\n-    DefKind, DefLoc, AsName, Module,\n+    AsName, Module,\n };\n \n /// Locates the module by `FileId`. Picks topmost module in the file.\n@@ -105,29 +105,18 @@ pub fn function_from_source(\n     fn_def: &ast::FnDef,\n ) -> Option<Function> {\n     let module = module_from_child_node(db, file_id, fn_def.syntax())?;\n-    let res = function_from_module(db, &module, fn_def);\n+    let res = function_from_module(db, module, fn_def);\n     Some(res)\n }\n \n pub fn function_from_module(\n     db: &impl HirDatabase,\n-    module: &Module,\n+    module: Module,\n     fn_def: &ast::FnDef,\n ) -> Function {\n     let (file_id, _) = module.definition_source(db);\n     let file_id = file_id.into();\n-    let file_items = db.file_items(file_id);\n-    let item_id = file_items.id_of(file_id, fn_def.syntax());\n-    let source_item_id = SourceItemId {\n-        file_id,\n-        item_id: Some(item_id),\n-    };\n-    let def_loc = DefLoc {\n-        module: module.clone(),\n-        kind: DefKind::Function,\n-        source_item_id,\n-    };\n-    Function::new(def_loc.id(db))\n+    Function::from_ast(db, module, file_id, fn_def)\n }\n \n pub fn function_from_child_node("}, {"sha": "f9cdbcab333827c2fa1fcfb5b4f54c93e049e4dc", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 101, "deletions": 79, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=ec7ed054e06cb2e23fd3911932766b32014c8fa1", "patch": "@@ -382,7 +382,8 @@ impl Ty {\n \n         // Resolve in module (in type namespace)\n         let resolved = match module.resolve_path(db, path).take_types() {\n-            Some(ModuleDef::Def(r)) => r,\n+            Some(ModuleDef::Def(r)) => r.into(),\n+            Some(ModuleDef::Function(f)) => f.into(),\n             None | Some(ModuleDef::Module(_)) => return Ty::Unknown,\n         };\n         let ty = db.type_for_def(resolved);\n@@ -399,36 +400,38 @@ impl Ty {\n         impl_block: Option<&ImplBlock>,\n         outer_generics: &GenericParams,\n         path: &Path,\n-        resolved: DefId,\n+        resolved: TypableDef,\n     ) -> Substs {\n         let mut substs = Vec::new();\n-        let def = resolved.resolve(db);\n         let last = path\n             .segments\n             .last()\n             .expect(\"path should have at least one segment\");\n-        let (def_generics, segment) = match def {\n-            Def::Struct(s) => (s.generic_params(db), last),\n-            Def::Enum(e) => (e.generic_params(db), last),\n-            Def::Function(f) => (f.generic_params(db), last),\n-            Def::Trait(t) => (t.generic_params(db), last),\n-            Def::EnumVariant(ev) => {\n-                // the generic args for an enum variant may be either specified\n-                // on the segment referring to the enum, or on the segment\n-                // referring to the variant. So `Option::<T>::None` and\n-                // `Option::None::<T>` are both allowed (though the former is\n-                // preferred). See also `def_ids_for_path_segments` in rustc.\n-                let len = path.segments.len();\n-                let segment = if len >= 2 && path.segments[len - 2].args_and_bindings.is_some() {\n-                    // Option::<T>::None\n-                    &path.segments[len - 2]\n-                } else {\n-                    // Option::None::<T>\n-                    last\n-                };\n-                (ev.parent_enum(db).generic_params(db), segment)\n-            }\n-            _ => return Substs::empty(),\n+        let (def_generics, segment) = match resolved {\n+            TypableDef::Function(func) => (func.generic_params(db), last),\n+            TypableDef::Def(def_id) => match def_id.resolve(db) {\n+                Def::Struct(s) => (s.generic_params(db), last),\n+                Def::Enum(e) => (e.generic_params(db), last),\n+                Def::Trait(t) => (t.generic_params(db), last),\n+                Def::EnumVariant(ev) => {\n+                    // the generic args for an enum variant may be either specified\n+                    // on the segment referring to the enum, or on the segment\n+                    // referring to the variant. So `Option::<T>::None` and\n+                    // `Option::None::<T>` are both allowed (though the former is\n+                    // preferred). See also `def_ids_for_path_segments` in rustc.\n+                    let len = path.segments.len();\n+                    let segment = if len >= 2 && path.segments[len - 2].args_and_bindings.is_some()\n+                    {\n+                        // Option::<T>::None\n+                        &path.segments[len - 2]\n+                    } else {\n+                        // Option::None::<T>\n+                        last\n+                    };\n+                    (ev.parent_enum(db).generic_params(db), segment)\n+                }\n+                _ => return Substs::empty(),\n+            },\n         };\n         // substs_from_path\n         if let Some(generic_args) = &segment.args_and_bindings {\n@@ -660,21 +663,40 @@ pub(crate) fn type_for_enum_variant(db: &impl HirDatabase, ev: EnumVariant) -> T\n     type_for_enum(db, enum_parent)\n }\n \n-pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Ty {\n-    let def = def_id.resolve(db);\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum TypableDef {\n+    Function(Function),\n+    Def(DefId),\n+}\n+\n+impl From<Function> for TypableDef {\n+    fn from(func: Function) -> TypableDef {\n+        TypableDef::Function(func)\n+    }\n+}\n+\n+impl From<DefId> for TypableDef {\n+    fn from(func: DefId) -> TypableDef {\n+        TypableDef::Def(func)\n+    }\n+}\n+\n+pub(super) fn type_for_def(db: &impl HirDatabase, def: TypableDef) -> Ty {\n     match def {\n-        Def::Function(f) => type_for_fn(db, f),\n-        Def::Struct(s) => type_for_struct(db, s),\n-        Def::Enum(e) => type_for_enum(db, e),\n-        Def::EnumVariant(ev) => type_for_enum_variant(db, ev),\n-        _ => {\n-            log::debug!(\n-                \"trying to get type for item of unknown type {:?} {:?}\",\n-                def_id,\n-                def\n-            );\n-            Ty::Unknown\n-        }\n+        TypableDef::Function(f) => type_for_fn(db, f),\n+        TypableDef::Def(def_id) => match def_id.resolve(db) {\n+            Def::Struct(s) => type_for_struct(db, s),\n+            Def::Enum(e) => type_for_enum(db, e),\n+            Def::EnumVariant(ev) => type_for_enum_variant(db, ev),\n+            _ => {\n+                log::debug!(\n+                    \"trying to get type for item of unknown type {:?} {:?}\",\n+                    def_id,\n+                    def\n+                );\n+                Ty::Unknown\n+            }\n+        },\n     }\n }\n \n@@ -694,28 +716,23 @@ pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name)\n         ),\n     };\n     let module = def_id.module(db);\n-    let impl_block = def_id.impl_block(db);\n+    // We can't have an impl block ere, right?\n+    // let impl_block = def_id.impl_block(db);\n     let type_ref = variant_data.get_field_type_ref(&field)?;\n-    Some(Ty::from_hir(\n-        db,\n-        &module,\n-        impl_block.as_ref(),\n-        &generics,\n-        &type_ref,\n-    ))\n+    Some(Ty::from_hir(db, &module, None, &generics, &type_ref))\n }\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n     /// For each method call expr, record the function it resolved to.\n-    method_resolutions: FxHashMap<ExprId, DefId>,\n+    method_resolutions: FxHashMap<ExprId, Function>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n }\n \n impl InferenceResult {\n-    pub fn method_resolution(&self, expr: ExprId) -> Option<DefId> {\n+    pub fn method_resolution(&self, expr: ExprId) -> Option<Function> {\n         self.method_resolutions.get(&expr).map(|it| *it)\n     }\n }\n@@ -745,7 +762,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     module: Module,\n     impl_block: Option<ImplBlock>,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n-    method_resolutions: FxHashMap<ExprId, DefId>,\n+    method_resolutions: FxHashMap<ExprId, Function>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n     /// The return type of the function being inferred.\n@@ -871,8 +888,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.type_of_expr.insert(expr, ty);\n     }\n \n-    fn write_method_resolution(&mut self, expr: ExprId, def_id: DefId) {\n-        self.method_resolutions.insert(expr, def_id);\n+    fn write_method_resolution(&mut self, expr: ExprId, func: Function) {\n+        self.method_resolutions.insert(expr, func);\n     }\n \n     fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n@@ -1060,7 +1077,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n         // resolve in module\n         let resolved = match self.module.resolve_path(self.db, &path).take_values()? {\n-            ModuleDef::Def(it) => it,\n+            ModuleDef::Def(it) => it.into(),\n+            ModuleDef::Function(func) => func.into(),\n             ModuleDef::Module(_) => return None,\n         };\n         let ty = self.db.type_for_def(resolved);\n@@ -1073,8 +1091,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Some(path) => path,\n             None => return (Ty::Unknown, None),\n         };\n-        let def_id = match self.module.resolve_path(self.db, &path).take_types() {\n-            Some(ModuleDef::Def(def_id)) => def_id,\n+        let def = match self.module.resolve_path(self.db, &path).take_types() {\n+            Some(ModuleDef::Def(def_id)) => def_id.into(),\n+            Some(ModuleDef::Function(func)) => func.into(),\n             _ => return (Ty::Unknown, None),\n         };\n         // TODO remove the duplication between here and `Ty::from_path`?\n@@ -1086,20 +1105,23 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             self.impl_block.as_ref(),\n             &generics,\n             path,\n-            def_id,\n+            def,\n         );\n-        match def_id.resolve(self.db) {\n-            Def::Struct(s) => {\n-                let ty = type_for_struct(self.db, s);\n-                let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                (ty, Some(def_id))\n-            }\n-            Def::EnumVariant(ev) => {\n-                let ty = type_for_enum_variant(self.db, ev);\n-                let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                (ty, Some(def_id))\n-            }\n-            _ => (Ty::Unknown, None),\n+        match def {\n+            TypableDef::Def(def_id) => match def_id.resolve(self.db) {\n+                Def::Struct(s) => {\n+                    let ty = type_for_struct(self.db, s);\n+                    let ty = self.insert_type_vars(ty.apply_substs(substs));\n+                    (ty, Some(def_id))\n+                }\n+                Def::EnumVariant(ev) => {\n+                    let ty = type_for_enum_variant(self.db, ev);\n+                    let ty = self.insert_type_vars(ty.apply_substs(substs));\n+                    (ty, Some(def_id))\n+                }\n+                _ => (Ty::Unknown, None),\n+            },\n+            TypableDef::Function(_) => (Ty::Unknown, None),\n         }\n     }\n \n@@ -1216,7 +1238,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .resolve_path(self.db, &path)\n                 .take_values()\n                 .and_then(|module_def| match module_def {\n-                    ModuleDef::Def(it) => Some(it),\n+                    ModuleDef::Def(it) => Some(it.into()),\n+                    ModuleDef::Function(func) => Some(func.into()),\n                     ModuleDef::Module(_) => None,\n                 })\n                 .map_or(Ty::Unknown, |resolved| self.db.type_for_def(resolved)),\n@@ -1339,9 +1362,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let receiver_ty = self.infer_expr(*receiver, &Expectation::none());\n                 let resolved = receiver_ty.clone().lookup_method(self.db, method_name);\n                 let method_ty = match resolved {\n-                    Some(def_id) => {\n-                        self.write_method_resolution(expr, def_id);\n-                        self.db.type_for_def(def_id)\n+                    Some(func) => {\n+                        self.write_method_resolution(expr, func);\n+                        self.db.type_for_def(func.into())\n                     }\n                     None => Ty::Unknown,\n                 };\n@@ -1610,16 +1633,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n }\n \n-pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Arc<InferenceResult> {\n+pub fn infer(db: &impl HirDatabase, func: Function) -> Arc<InferenceResult> {\n     db.check_canceled();\n-    let function = Function::new(def_id); // TODO: consts also need inference\n-    let body = function.body(db);\n-    let scopes = db.fn_scopes(def_id);\n-    let module = function.module(db);\n-    let impl_block = function.impl_block(db);\n+    let body = func.body(db);\n+    let scopes = db.fn_scopes(func);\n+    let module = func.module(db);\n+    let impl_block = func.impl_block(db);\n     let mut ctx = InferenceContext::new(db, body, scopes, module, impl_block);\n \n-    let signature = function.signature(db);\n+    let signature = func.signature(db);\n     ctx.collect_fn_signature(&signature);\n \n     ctx.infer_body();"}, {"sha": "0084b24dc7434888f603a0719e763a543cae3f4a", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7ed054e06cb2e23fd3911932766b32014c8fa1/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=ec7ed054e06cb2e23fd3911932766b32014c8fa1", "patch": "@@ -118,11 +118,11 @@ impl Ty {\n     // TODO: cache this as a query?\n     // - if so, what signature? (TyFingerprint, Name)?\n     // - or maybe cache all names and def_ids of methods per fingerprint?\n-    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Option<DefId> {\n+    pub fn lookup_method(self, db: &impl HirDatabase, name: &Name) -> Option<Function> {\n         self.iterate_methods(db, |f| {\n             let sig = f.signature(db);\n             if sig.name() == name && sig.has_self_param() {\n-                Some(f.def_id())\n+                Some(f)\n             } else {\n                 None\n             }"}]}