{"sha": "4f7b922afe7cca0ecdd4dd1124935d89122cb904", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmN2I5MjJhZmU3Y2NhMGVjZGQ0ZGQxMTI0OTM1ZDg5MTIyY2I5MDQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-10-25T09:27:36Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-10-25T09:27:36Z"}, "message": "refactor: move structural_match analysis into its own module.", "tree": {"sha": "a9694ea63060e3c2a72f144ac9c75e95207e00e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9694ea63060e3c2a72f144ac9c75e95207e00e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f7b922afe7cca0ecdd4dd1124935d89122cb904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f7b922afe7cca0ecdd4dd1124935d89122cb904", "html_url": "https://github.com/rust-lang/rust/commit/4f7b922afe7cca0ecdd4dd1124935d89122cb904", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f7b922afe7cca0ecdd4dd1124935d89122cb904/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0e370f067325f40b0875f06b2e31ce3dae32377", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0e370f067325f40b0875f06b2e31ce3dae32377", "html_url": "https://github.com/rust-lang/rust/commit/f0e370f067325f40b0875f06b2e31ce3dae32377"}], "stats": {"total": 260, "additions": 135, "deletions": 125}, "files": [{"sha": "a9415faf3312c1eb3f0092fba29dba21a9e1cff9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 125, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/4f7b922afe7cca0ecdd4dd1124935d89122cb904/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7b922afe7cca0ecdd4dd1124935d89122cb904/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4f7b922afe7cca0ecdd4dd1124935d89122cb904", "patch": "@@ -51,7 +51,7 @@ use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n \n use smallvec;\n-use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::{FxIndexMap};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_index::vec::{Idx, IndexVec};\n \n@@ -84,6 +84,8 @@ pub use self::context::{\n \n pub use self::instance::{Instance, InstanceDef};\n \n+pub use self::structural_match::{search_for_structural_match_violation, NonStructuralMatchTy};\n+\n pub use self::trait_def::TraitDef;\n \n pub use self::query::queries;\n@@ -116,6 +118,7 @@ pub mod util;\n mod context;\n mod instance;\n mod structural_impls;\n+mod structural_match;\n mod sty;\n \n // Data types\n@@ -3395,130 +3398,6 @@ fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n     fn_like.asyncness()\n }\n \n-pub enum NonStructuralMatchTy<'tcx> {\n-    Adt(&'tcx AdtDef),\n-    Param,\n-}\n-\n-/// This method traverses the structure of `ty`, trying to find an\n-/// instance of an ADT (i.e. struct or enum) that was declared without\n-/// the `#[structural_match]` attribute, or a generic type parameter\n-/// (which cannot be determined to be `structural_match`).\n-///\n-/// The \"structure of a type\" includes all components that would be\n-/// considered when doing a pattern match on a constant of that\n-/// type.\n-///\n-///  * This means this method descends into fields of structs/enums,\n-///    and also descends into the inner type `T` of `&T` and `&mut T`\n-///\n-///  * The traversal doesn't dereference unsafe pointers (`*const T`,\n-///    `*mut T`), and it does not visit the type arguments of an\n-///    instantiated generic like `PhantomData<T>`.\n-///\n-/// The reason we do this search is Rust currently require all ADTs\n-/// reachable from a constant's type to be annotated with\n-/// `#[structural_match]`, an attribute which essentially says that\n-/// the implementation of `PartialEq::eq` behaves *equivalently* to a\n-/// comparison against the unfolded structure.\n-///\n-/// For more background on why Rust has this requirement, and issues\n-/// that arose when the requirement was not enforced completely, see\n-/// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n-pub fn search_for_structural_match_violation<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Option<NonStructuralMatchTy<'tcx>> {\n-    let mut search = Search { tcx, found: None, seen: FxHashSet::default() };\n-    ty.visit_with(&mut search);\n-    return search.found;\n-\n-    struct Search<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-\n-        // Records the first ADT or type parameter we find without `#[structural_match`.\n-        found: Option<NonStructuralMatchTy<'tcx>>,\n-\n-        // Tracks ADTs previously encountered during search, so that\n-        // we will not recurse on them again.\n-        seen: FxHashSet<hir::def_id::DefId>,\n-    }\n-\n-    impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n-        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-            debug!(\"Search visiting ty: {:?}\", ty);\n-\n-            let (adt_def, substs) = match ty.kind {\n-                ty::Adt(adt_def, substs) => (adt_def, substs),\n-                ty::Param(_) => {\n-                    self.found = Some(NonStructuralMatchTy::Param);\n-                    return true; // Stop visiting.\n-                }\n-                ty::RawPtr(..) => {\n-                    // `#[structural_match]` ignores substructure of\n-                    // `*const _`/`*mut _`, so skip super_visit_with\n-                    //\n-                    // (But still tell caller to continue search.)\n-                    return false;\n-                }\n-                ty::FnDef(..) | ty::FnPtr(..) => {\n-                    // types of formals and return in `fn(_) -> _` are also irrelevant\n-                    //\n-                    // (But still tell caller to continue search.)\n-                    return false;\n-                }\n-                ty::Array(_, n) if n.try_eval_usize(self.tcx, ty::ParamEnv::reveal_all()) == Some(0)\n-                => {\n-                    // rust-lang/rust#62336: ignore type of contents\n-                    // for empty array.\n-                    return false;\n-                }\n-                _ => {\n-                    ty.super_visit_with(self);\n-                    return false;\n-                }\n-            };\n-\n-            if !self.tcx.has_attr(adt_def.did, sym::structural_match) {\n-                self.found = Some(NonStructuralMatchTy::Adt(&adt_def));\n-                debug!(\"Search found adt_def: {:?}\", adt_def);\n-                return true; // Stop visiting.\n-            }\n-\n-            if !self.seen.insert(adt_def.did) {\n-                debug!(\"Search already seen adt_def: {:?}\", adt_def);\n-                // let caller continue its search\n-                return false;\n-            }\n-\n-            // `#[structural_match]` does not care about the\n-            // instantiation of the generics in an ADT (it\n-            // instead looks directly at its fields outside\n-            // this match), so we skip super_visit_with.\n-            //\n-            // (Must not recur on substs for `PhantomData<T>` cf\n-            // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n-            // want to skip substs when only uses of generic are\n-            // behind unsafe pointers `*const T`/`*mut T`.)\n-\n-            // even though we skip super_visit_with, we must recur on\n-            // fields of ADT.\n-            let tcx = self.tcx;\n-            for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n-                if field_ty.visit_with(self) {\n-                    // found an ADT without `#[structural_match]`; halt visiting!\n-                    assert!(self.found.is_some());\n-                    return true;\n-                }\n-            }\n-\n-            // Even though we do not want to recur on substs, we do\n-            // want our caller to continue its own search.\n-            false\n-        }\n-    }\n-}\n-\n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);\n     erase_regions::provide(providers);"}, {"sha": "83f0feda168ebebf81604d55edf7375a35bf720b", "filename": "src/librustc/ty/structural_match.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/4f7b922afe7cca0ecdd4dd1124935d89122cb904/src%2Flibrustc%2Fty%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7b922afe7cca0ecdd4dd1124935d89122cb904/src%2Flibrustc%2Fty%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_match.rs?ref=4f7b922afe7cca0ecdd4dd1124935d89122cb904", "patch": "@@ -0,0 +1,131 @@\n+use crate::hir;\n+use rustc_data_structures::fx::{FxHashSet};\n+\n+use syntax::symbol::{sym};\n+\n+use crate::ty::{self, AdtDef, Ty, TyCtxt};\n+use crate::ty::fold::{TypeFoldable, TypeVisitor};\n+\n+pub enum NonStructuralMatchTy<'tcx> {\n+    Adt(&'tcx AdtDef),\n+    Param,\n+}\n+\n+/// This method traverses the structure of `ty`, trying to find an\n+/// instance of an ADT (i.e. struct or enum) that was declared without\n+/// the `#[structural_match]` attribute, or a generic type parameter\n+/// (which cannot be determined to be `structural_match`).\n+///\n+/// The \"structure of a type\" includes all components that would be\n+/// considered when doing a pattern match on a constant of that\n+/// type.\n+///\n+///  * This means this method descends into fields of structs/enums,\n+///    and also descends into the inner type `T` of `&T` and `&mut T`\n+///\n+///  * The traversal doesn't dereference unsafe pointers (`*const T`,\n+///    `*mut T`), and it does not visit the type arguments of an\n+///    instantiated generic like `PhantomData<T>`.\n+///\n+/// The reason we do this search is Rust currently require all ADTs\n+/// reachable from a constant's type to be annotated with\n+/// `#[structural_match]`, an attribute which essentially says that\n+/// the implementation of `PartialEq::eq` behaves *equivalently* to a\n+/// comparison against the unfolded structure.\n+///\n+/// For more background on why Rust has this requirement, and issues\n+/// that arose when the requirement was not enforced completely, see\n+/// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n+pub fn search_for_structural_match_violation<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<NonStructuralMatchTy<'tcx>> {\n+    let mut search = Search { tcx, found: None, seen: FxHashSet::default() };\n+    ty.visit_with(&mut search);\n+    return search.found;\n+\n+    struct Search<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+\n+        // Records the first ADT or type parameter we find without `#[structural_match`.\n+        found: Option<NonStructuralMatchTy<'tcx>>,\n+\n+        // Tracks ADTs previously encountered during search, so that\n+        // we will not recurse on them again.\n+        seen: FxHashSet<hir::def_id::DefId>,\n+    }\n+\n+    impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n+        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+            debug!(\"Search visiting ty: {:?}\", ty);\n+\n+            let (adt_def, substs) = match ty.kind {\n+                ty::Adt(adt_def, substs) => (adt_def, substs),\n+                ty::Param(_) => {\n+                    self.found = Some(NonStructuralMatchTy::Param);\n+                    return true; // Stop visiting.\n+                }\n+                ty::RawPtr(..) => {\n+                    // `#[structural_match]` ignores substructure of\n+                    // `*const _`/`*mut _`, so skip super_visit_with\n+                    //\n+                    // (But still tell caller to continue search.)\n+                    return false;\n+                }\n+                ty::FnDef(..) | ty::FnPtr(..) => {\n+                    // types of formals and return in `fn(_) -> _` are also irrelevant\n+                    //\n+                    // (But still tell caller to continue search.)\n+                    return false;\n+                }\n+                ty::Array(_, n) if n.try_eval_usize(self.tcx, ty::ParamEnv::reveal_all()) == Some(0)\n+                => {\n+                    // rust-lang/rust#62336: ignore type of contents\n+                    // for empty array.\n+                    return false;\n+                }\n+                _ => {\n+                    ty.super_visit_with(self);\n+                    return false;\n+                }\n+            };\n+\n+            if !self.tcx.has_attr(adt_def.did, sym::structural_match) {\n+                self.found = Some(NonStructuralMatchTy::Adt(&adt_def));\n+                debug!(\"Search found adt_def: {:?}\", adt_def);\n+                return true; // Stop visiting.\n+            }\n+\n+            if !self.seen.insert(adt_def.did) {\n+                debug!(\"Search already seen adt_def: {:?}\", adt_def);\n+                // let caller continue its search\n+                return false;\n+            }\n+\n+            // `#[structural_match]` does not care about the\n+            // instantiation of the generics in an ADT (it\n+            // instead looks directly at its fields outside\n+            // this match), so we skip super_visit_with.\n+            //\n+            // (Must not recur on substs for `PhantomData<T>` cf\n+            // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n+            // want to skip substs when only uses of generic are\n+            // behind unsafe pointers `*const T`/`*mut T`.)\n+\n+            // even though we skip super_visit_with, we must recur on\n+            // fields of ADT.\n+            let tcx = self.tcx;\n+            for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n+                if field_ty.visit_with(self) {\n+                    // found an ADT without `#[structural_match]`; halt visiting!\n+                    assert!(self.found.is_some());\n+                    return true;\n+                }\n+            }\n+\n+            // Even though we do not want to recur on substs, we do\n+            // want our caller to continue its own search.\n+            false\n+        }\n+    }\n+}"}]}