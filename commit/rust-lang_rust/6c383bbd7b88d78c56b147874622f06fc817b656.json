{"sha": "6c383bbd7b88d78c56b147874622f06fc817b656", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMzgzYmJkN2I4OGQ3OGM1NmIxNDc4NzQ2MjJmMDZmYzgxN2I2NTY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-31T19:24:59Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-31T19:24:59Z"}, "message": "rustc: Index only the local part of definition IDs", "tree": {"sha": "f617aeff8ff9cef2e8ab3b96709accf19d2d7edc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f617aeff8ff9cef2e8ab3b96709accf19d2d7edc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c383bbd7b88d78c56b147874622f06fc817b656", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c383bbd7b88d78c56b147874622f06fc817b656", "html_url": "https://github.com/rust-lang/rust/commit/6c383bbd7b88d78c56b147874622f06fc817b656", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c383bbd7b88d78c56b147874622f06fc817b656/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3945ace520ff93e6edc03c75141cfaff3fbb832c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3945ace520ff93e6edc03c75141cfaff3fbb832c", "html_url": "https://github.com/rust-lang/rust/commit/3945ace520ff93e6edc03c75141cfaff3fbb832c"}], "stats": {"total": 37, "additions": 21, "deletions": 16}, "files": [{"sha": "5b3bd2090684a689d6b7e0e753f4269acb74e97b", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6c383bbd7b88d78c56b147874622f06fc817b656/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c383bbd7b88d78c56b147874622f06fc817b656/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=6c383bbd7b88d78c56b147874622f06fc817b656", "patch": "@@ -423,17 +423,17 @@ fn encode_info_for_native_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n }\n \n fn encode_info_for_items(@trans.crate_ctxt cx, &ebml.writer ebml_w)\n-        -> vec[tup(ast.def_id, uint)] {\n-    let vec[tup(ast.def_id, uint)] index = vec();\n+        -> vec[tup(int, uint)] {\n+    let vec[tup(int, uint)] index = vec();\n \n-    ebml.start_tag(ebml_w, tag_items);\n+    ebml.start_tag(ebml_w, tag_items_data);\n     for each (@tup(ast.def_id, @ast.item) kvp in cx.items.items()) {\n-        index += vec(tup(kvp._0, ebml_w.writer.tell()));\n+        index += vec(tup(kvp._0._1, ebml_w.writer.tell()));\n         encode_info_for_item(cx, ebml_w, kvp._1);\n     }\n     for each (@tup(ast.def_id, @ast.native_item) kvp in\n             cx.native_items.items()) {\n-        index += vec(tup(kvp._0, ebml_w.writer.tell()));\n+        index += vec(tup(kvp._0._1, ebml_w.writer.tell()));\n         encode_info_for_native_item(cx, ebml_w, kvp._1);\n     }\n     ebml.end_tag(ebml_w);\n@@ -444,24 +444,26 @@ fn encode_info_for_items(@trans.crate_ctxt cx, &ebml.writer ebml_w)\n \n // Definition ID indexing\n \n-fn create_index(vec[tup(ast.def_id, uint)] index)\n-        -> vec[vec[tup(ast.def_id, uint)]] {\n-    let vec[vec[tup(ast.def_id, uint)]] buckets = vec();\n+fn hash_def_num(int def_num) -> uint {\n+    ret 177573u ^ (def_num as uint);\n+}\n+\n+fn create_index(vec[tup(int, uint)] index) -> vec[vec[tup(int, uint)]] {\n+    let vec[vec[tup(int, uint)]] buckets = vec();\n     for each (uint i in _uint.range(0u, 256u)) {\n-        let vec[tup(ast.def_id, uint)] bucket = vec();\n+        let vec[tup(int, uint)] bucket = vec();\n         buckets += vec(bucket);\n     }\n \n-    for (tup(ast.def_id, uint) elt in index) {\n-        auto h = common.hash_def(elt._0);\n+    for (tup(int, uint) elt in index) {\n+        auto h = hash_def_num(elt._0);\n         buckets.(h % 256u) += vec(elt);\n     }\n \n     ret buckets;\n }\n \n-impure fn encode_index(&ebml.writer ebml_w,\n-                       vec[tup(ast.def_id, uint)] index) {\n+impure fn encode_index(&ebml.writer ebml_w, vec[tup(int, uint)] index) {\n     auto writer = io.new_writer_(ebml_w.writer);\n \n     auto buckets = create_index(index);\n@@ -470,14 +472,14 @@ impure fn encode_index(&ebml.writer ebml_w,\n \n     let vec[uint] bucket_locs = vec();\n     ebml.start_tag(ebml_w, tag_items_index_buckets);\n-    for (vec[tup(ast.def_id, uint)] bucket in buckets) {\n+    for (vec[tup(int, uint)] bucket in buckets) {\n         bucket_locs += vec(ebml_w.writer.tell());\n \n         ebml.start_tag(ebml_w, tag_items_index_buckets_bucket);\n-        for (tup(ast.def_id, uint) elt in bucket) {\n+        for (tup(int, uint) elt in bucket) {\n             ebml.start_tag(ebml_w, tag_items_index_buckets_bucket_elt);\n             writer.write_be_uint(elt._1, 4u);\n-            writer.write_str(def_to_str(elt._0));\n+            writer.write_be_uint(elt._0 as uint, 4u);\n             ebml.end_tag(ebml_w);\n         }\n         ebml.end_tag(ebml_w);\n@@ -501,8 +503,11 @@ impure fn encode_metadata(@trans.crate_ctxt cx, @ast.crate crate)\n     auto ebml_w = ebml.create_writer(buf_w);\n \n     encode_item_paths(ebml_w, crate);\n+\n+    ebml.start_tag(ebml_w, tag_items);\n     auto index = encode_info_for_items(cx, ebml_w);\n     encode_index(ebml_w, index);\n+    ebml.end_tag(ebml_w);\n \n     ret C_postr(string_w.get_str());\n }"}]}