{"sha": "2da942f32802c8233a09744024dfbc34431adf65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkYTk0MmYzMjgwMmM4MjMzYTA5NzQ0MDI0ZGZiYzM0NDMxYWRmNjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-02T11:43:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-02T11:43:50Z"}, "message": "Auto merge of #66874 - RalfJung:miri-assert-panic, r=oli-obk\n\nMiri engine: proper support for `Assert` MIR terminators\n\nThis puts down the basis for https://github.com/rust-lang/miri/issues/1070, and I also did some clean-up. The Miri side of this is at https://github.com/rust-lang/miri/pull/1084.\n\nr? @oli-obk", "tree": {"sha": "f8dc4421da3bd87eb86b895597c024337e961ada", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8dc4421da3bd87eb86b895597c024337e961ada"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2da942f32802c8233a09744024dfbc34431adf65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2da942f32802c8233a09744024dfbc34431adf65", "html_url": "https://github.com/rust-lang/rust/commit/2da942f32802c8233a09744024dfbc34431adf65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2da942f32802c8233a09744024dfbc34431adf65/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4af3ee8ee2a2bc1286b021db7600ba990359cf3f", "html_url": "https://github.com/rust-lang/rust/commit/4af3ee8ee2a2bc1286b021db7600ba990359cf3f"}, {"sha": "5e51a153f97b141dfeef795d22ec9e47967764f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e51a153f97b141dfeef795d22ec9e47967764f2", "html_url": "https://github.com/rust-lang/rust/commit/5e51a153f97b141dfeef795d22ec9e47967764f2"}], "stats": {"total": 313, "additions": 195, "deletions": 118}, "files": [{"sha": "a038ca23ae92d6e1939d420cb937fec91148cf7b", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=2da942f32802c8233a09744024dfbc34431adf65", "patch": "@@ -471,6 +471,13 @@ impl<Tag> From<Scalar<Tag>> for ScalarMaybeUndef<Tag> {\n     }\n }\n \n+impl<Tag> From<Pointer<Tag>> for ScalarMaybeUndef<Tag> {\n+    #[inline(always)]\n+    fn from(s: Pointer<Tag>) -> Self {\n+        ScalarMaybeUndef::Scalar(s.into())\n+    }\n+}\n+\n impl<Tag: fmt::Debug, Id: fmt::Debug> fmt::Debug for ScalarMaybeUndef<Tag, Id> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {"}, {"sha": "ff0cf6f4fdd218dc3b1abf68aeb1109c8fa141ae", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=2da942f32802c8233a09744024dfbc34431adf65", "patch": "@@ -23,7 +23,7 @@ use syntax::{source_map::{Span, DUMMY_SP}, symbol::Symbol};\n use crate::interpret::{self,\n     PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar, Pointer,\n     RawConst, ConstValue, Machine,\n-    InterpResult, InterpErrorInfo, GlobalId, InterpCx, StackPopCleanup,\n+    InterpResult, InterpErrorInfo, GlobalId, InterpCx, StackPopCleanup, AssertMessage,\n     Allocation, AllocId, MemoryKind, Memory,\n     snapshot, RefTracking, intern_const_alloc_recursive,\n };\n@@ -395,6 +395,40 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         )\n     }\n \n+    fn assert_panic(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _span: Span,\n+        msg: &AssertMessage<'tcx>,\n+        _unwind: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        use rustc::mir::interpret::PanicInfo::*;\n+        Err(match msg {\n+            BoundsCheck { ref len, ref index } => {\n+                let len = ecx\n+                    .read_immediate(ecx.eval_operand(len, None)?)\n+                    .expect(\"can't eval len\")\n+                    .to_scalar()?\n+                    .to_machine_usize(&*ecx)?;\n+                let index = ecx\n+                    .read_immediate(ecx.eval_operand(index, None)?)\n+                    .expect(\"can't eval index\")\n+                    .to_scalar()?\n+                    .to_machine_usize(&*ecx)?;\n+                err_panic!(BoundsCheck { len, index })\n+            }\n+            Overflow(op) => err_panic!(Overflow(*op)),\n+            OverflowNeg => err_panic!(OverflowNeg),\n+            DivisionByZero => err_panic!(DivisionByZero),\n+            RemainderByZero => err_panic!(RemainderByZero),\n+            ResumedAfterReturn(generator_kind)\n+                => err_panic!(ResumedAfterReturn(*generator_kind)),\n+            ResumedAfterPanic(generator_kind)\n+                => err_panic!(ResumedAfterPanic(*generator_kind)),\n+            Panic { .. } => bug!(\"`Panic` variant cannot occur in MIR\"),\n+        }\n+        .into())\n+    }\n+\n     fn ptr_to_int(\n         _mem: &Memory<'mir, 'tcx, Self>,\n         _ptr: Pointer,\n@@ -423,7 +457,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     #[inline(always)]\n-    fn tag_allocation<'b>(\n+    fn init_allocation_extra<'b>(\n         _memory_extra: &(),\n         _id: AllocId,\n         alloc: Cow<'b, Allocation>,\n@@ -518,7 +552,7 @@ pub fn const_caller_location<'tcx>(\n         tcx.type_of(tcx.require_lang_item(PanicLocationLangItem, None))\n             .subst(tcx, tcx.mk_substs([tcx.lifetimes.re_static.into()].iter())),\n     );\n-    let loc_place = ecx.alloc_caller_location(file, line, col).unwrap();\n+    let loc_place = ecx.alloc_caller_location(file, line, col);\n     intern_const_alloc_recursive(&mut ecx, None, loc_place).unwrap();\n     let loc_const = ty::Const {\n         ty: loc_ty,"}, {"sha": "e9602ecfa4c72be193daf751b0d1d4249c9a3c66", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=2da942f32802c8233a09744024dfbc34431adf65", "patch": "@@ -55,7 +55,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         ).ok_or_else(|| err_inval!(TooGeneric))?;\n \n                         let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n-                        self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n+                        self.write_scalar(fn_ptr, dest)?;\n                     }\n                     _ => bug!(\"reify fn pointer on {:?}\", src.layout.ty),\n                 }\n@@ -88,8 +88,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             ty::ClosureKind::FnOnce,\n                         );\n                         let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n-                        let val = Immediate::Scalar(Scalar::Ptr(fn_ptr.into()).into());\n-                        self.write_immediate(val, dest)?;\n+                        self.write_scalar(fn_ptr, dest)?;\n                     }\n                     _ => bug!(\"closure fn pointer on {:?}\", src.layout.ty),\n                 }"}, {"sha": "8250cadb01d443a1aa2133b59af731d1b327c7ee", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=2da942f32802c8233a09744024dfbc34431adf65", "patch": "@@ -164,6 +164,20 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     }\n }\n \n+impl<'mir, 'tcx, Tag, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n+    /// Return the `SourceInfo` of the current instruction.\n+    pub fn current_source_info(&self) -> Option<mir::SourceInfo> {\n+        self.block.map(|block| {\n+            let block = &self.body.basic_blocks()[block];\n+            if self.stmt < block.statements.len() {\n+                block.statements[self.stmt].source_info\n+            } else {\n+                block.terminator().source_info\n+            }\n+        })\n+    }\n+}\n+\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n@@ -236,6 +250,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.memory.force_bits(scalar, size)\n     }\n \n+    /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n+    /// the *canonical* machine pointer to the allocation.  Must never be used\n+    /// for any other pointers!\n+    ///\n+    /// This represents a *direct* access to that memory, as opposed to access\n+    /// through a pointer that was created by the program.\n     #[inline(always)]\n     pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n         self.memory.tag_static_base_pointer(ptr)\n@@ -828,34 +848,28 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn generate_stacktrace(&self, explicit_span: Option<Span>) -> Vec<FrameInfo<'tcx>> {\n         let mut last_span = None;\n         let mut frames = Vec::new();\n-        for &Frame { instance, span, body, block, stmt, .. } in self.stack().iter().rev() {\n+        for frame in self.stack().iter().rev() {\n             // make sure we don't emit frames that are duplicates of the previous\n-            if explicit_span == Some(span) {\n-                last_span = Some(span);\n+            if explicit_span == Some(frame.span) {\n+                last_span = Some(frame.span);\n                 continue;\n             }\n             if let Some(last) = last_span {\n-                if last == span {\n+                if last == frame.span {\n                     continue;\n                 }\n             } else {\n-                last_span = Some(span);\n+                last_span = Some(frame.span);\n             }\n \n-            let lint_root = block.and_then(|block| {\n-                let block = &body.basic_blocks()[block];\n-                let source_info = if stmt < block.statements.len() {\n-                    block.statements[stmt].source_info\n-                } else {\n-                    block.terminator().source_info\n-                };\n-                match &body.source_scopes[source_info.scope].local_data {\n+            let lint_root = frame.current_source_info().and_then(|source_info| {\n+                match &frame.body.source_scopes[source_info.scope].local_data {\n                     mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n                     mir::ClearCrossCrate::Clear => None,\n                 }\n             });\n \n-            frames.push(FrameInfo { call_site: span, instance, lint_root });\n+            frames.push(FrameInfo { call_site: frame.span, instance: frame.instance, lint_root });\n         }\n         trace!(\"generate stacktrace: {:#?}, {:?}\", frames, explicit_span);\n         frames"}, {"sha": "118dfcb3d9a0125db87b29e4ba2183e71faa0f84", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=2da942f32802c8233a09744024dfbc34431adf65", "patch": "@@ -110,13 +110,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         match intrinsic_name {\n             \"caller_location\" => {\n-                let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n-                let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n-                let location = self.alloc_caller_location(\n-                    Symbol::intern(&caller.file.name.to_string()),\n-                    caller.line as u32,\n-                    caller.col_display as u32 + 1,\n-                )?;\n+                let location = self.alloc_caller_location_for_span(span);\n                 self.write_scalar(location.ptr, dest)?;\n             }\n "}, {"sha": "ecf4b7a39b7265edeffd5eaea711f101fdbff917", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=2da942f32802c8233a09744024dfbc34431adf65", "patch": "@@ -1,50 +1,48 @@\n use rustc::middle::lang_items::PanicLocationLangItem;\n-use rustc::mir::interpret::{Pointer, PointerArithmetic, Scalar};\n use rustc::ty::subst::Subst;\n-use rustc_target::abi::{LayoutOf, Size};\n-use syntax_pos::Symbol;\n+use rustc_target::abi::LayoutOf;\n+use syntax_pos::{Symbol, Span};\n \n-use crate::interpret::{MemoryKind, MPlaceTy, intrinsics::{InterpCx, InterpResult, Machine}};\n+use crate::interpret::{Scalar, MemoryKind, MPlaceTy, intrinsics::{InterpCx, Machine}};\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    pub fn alloc_caller_location(\n+    crate fn alloc_caller_location(\n         &mut self,\n         filename: Symbol,\n         line: u32,\n         col: u32,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+    ) -> MPlaceTy<'tcx, M::PointerTag> {\n+        let file = self.allocate_str(&filename.as_str(), MemoryKind::CallerLocation);\n         let line = Scalar::from_u32(line);\n         let col = Scalar::from_u32(col);\n \n-        let ptr_size = self.pointer_size();\n-        let u32_size = Size::from_bits(32);\n-\n+        // Allocate memory for `CallerLocation` struct.\n         let loc_ty = self.tcx.type_of(self.tcx.require_lang_item(PanicLocationLangItem, None))\n             .subst(*self.tcx, self.tcx.mk_substs([self.tcx.lifetimes.re_static.into()].iter()));\n-        let loc_layout = self.layout_of(loc_ty)?;\n-\n-        let file_alloc = self.tcx.allocate_bytes(filename.as_str().as_bytes());\n-        let file_ptr = Pointer::new(file_alloc, Size::ZERO);\n-        let file = Scalar::Ptr(self.tag_static_base_pointer(file_ptr));\n-        let file_len = Scalar::from_uint(filename.as_str().len() as u128, ptr_size);\n-\n+        let loc_layout = self.layout_of(loc_ty).unwrap();\n         let location = self.allocate(loc_layout, MemoryKind::CallerLocation);\n \n-        let file_out = self.mplace_field(location, 0)?;\n-        let file_ptr_out = self.force_ptr(self.mplace_field(file_out, 0)?.ptr)?;\n-        let file_len_out = self.force_ptr(self.mplace_field(file_out, 1)?.ptr)?;\n-        let line_out = self.force_ptr(self.mplace_field(location, 1)?.ptr)?;\n-        let col_out = self.force_ptr(self.mplace_field(location, 2)?.ptr)?;\n+        // Initialize fields.\n+        self.write_immediate(file.to_ref(), self.mplace_field(location, 0).unwrap().into())\n+            .expect(\"writing to memory we just allocated cannot fail\");\n+        self.write_scalar(line, self.mplace_field(location, 1).unwrap().into())\n+            .expect(\"writing to memory we just allocated cannot fail\");\n+        self.write_scalar(col, self.mplace_field(location, 2).unwrap().into())\n+            .expect(\"writing to memory we just allocated cannot fail\");\n \n-        let layout = &self.tcx.data_layout;\n-        // We just allocated this, so we can skip the bounds checks.\n-        let alloc = self.memory.get_raw_mut(file_ptr_out.alloc_id)?;\n-\n-        alloc.write_scalar(layout, file_ptr_out, file.into(), ptr_size)?;\n-        alloc.write_scalar(layout, file_len_out, file_len.into(), ptr_size)?;\n-        alloc.write_scalar(layout, line_out, line.into(), u32_size)?;\n-        alloc.write_scalar(layout, col_out, col.into(), u32_size)?;\n+        location\n+    }\n \n-        Ok(location)\n+    pub fn alloc_caller_location_for_span(\n+        &mut self,\n+        span: Span,\n+    ) -> MPlaceTy<'tcx, M::PointerTag> {\n+        let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n+        let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n+        self.alloc_caller_location(\n+            Symbol::intern(&caller.file.name.to_string()),\n+            caller.line as u32,\n+            caller.col_display as u32 + 1,\n+        )\n     }\n }"}, {"sha": "2ecc8d88ad398c6e0a59231a71024f8acd54f43f", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=2da942f32802c8233a09744024dfbc34431adf65", "patch": "@@ -11,7 +11,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use syntax_pos::Span;\n \n use super::{\n-    Allocation, AllocId, InterpResult, Scalar, AllocationExtra,\n+    Allocation, AllocId, InterpResult, Scalar, AllocationExtra, AssertMessage,\n     InterpCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory,\n     Frame, Operand,\n };\n@@ -175,6 +175,14 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx>;\n \n+    /// Called to evaluate `Assert` MIR terminators that trigger a panic.\n+    fn assert_panic(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        span: Span,\n+        msg: &AssertMessage<'tcx>,\n+        unwind: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx>;\n+\n     /// Called for read access to a foreign static item.\n     ///\n     /// This will only be called once per static and machine; the result is cached in\n@@ -233,20 +241,19 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n     ///\n-    /// For static allocations, the tag returned must be the same as the one returned by\n-    /// `tag_static_base_pointer`.\n-    fn tag_allocation<'b>(\n+    /// Also return the \"base\" tag to use for this allocation: the one that is used for direct\n+    /// accesses to this allocation. If `kind == STATIC_KIND`, this tag must be consistent\n+    /// with `tag_static_base_pointer`.\n+    fn init_allocation_extra<'b>(\n         memory_extra: &Self::MemoryExtra,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKinds>>,\n     ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag);\n \n-    /// Return the \"base\" tag for the given static allocation: the one that is used for direct\n-    /// accesses to this static/const/fn allocation.\n-    ///\n-    /// Be aware that requesting the `Allocation` for that `id` will lead to cycles\n-    /// for cyclic statics!\n+    /// Return the \"base\" tag for the given *static* allocation: the one that is used for direct\n+    /// accesses to this static/const/fn allocation. If `id` is not a static allocation,\n+    /// this will return an unusable tag (i.e., accesses will be UB)!\n     fn tag_static_base_pointer(\n         memory_extra: &Self::MemoryExtra,\n         id: AllocId,"}, {"sha": "ee7fb18fd05a544fb5133f32c1094ff04b68f8be", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=2da942f32802c8233a09744024dfbc34431adf65", "patch": "@@ -143,6 +143,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n+    /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n+    /// the *canonical* machine pointer to the allocation.  Must never be used\n+    /// for any other pointers!\n+    ///\n+    /// This represents a *direct* access to that memory, as opposed to access\n+    /// through a pointer that was created by the program.\n     #[inline]\n     pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n         ptr.with_tag(M::tag_static_base_pointer(&self.extra, ptr.alloc_id))\n@@ -191,7 +197,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> Pointer<M::PointerTag> {\n         let id = self.tcx.alloc_map.lock().reserve();\n-        let (alloc, tag) = M::tag_allocation(&self.extra, id, Cow::Owned(alloc), Some(kind));\n+        debug_assert_ne!(Some(kind), M::STATIC_KIND.map(MemoryKind::Machine),\n+            \"dynamically allocating static memory\");\n+        let (alloc, tag) = M::init_allocation_extra(&self.extra, id, Cow::Owned(alloc), Some(kind));\n         self.alloc_map.insert(id, (kind, alloc.into_owned()));\n         Pointer::from(id).with_tag(tag)\n     }\n@@ -350,7 +358,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             sptr\n         } else {\n             // A \"real\" access, we must get a pointer.\n-            Scalar::Ptr(self.force_ptr(sptr)?)\n+            Scalar::from(self.force_ptr(sptr)?)\n         };\n         Ok(match normalized.to_bits_or_ptr(self.pointer_size(), self) {\n             Ok(bits) => {\n@@ -473,14 +481,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 }\n             }\n         };\n-        // We got tcx memory. Let the machine figure out whether and how to\n-        // turn that into memory with the right pointer tag.\n-        Ok(M::tag_allocation(\n+        // We got tcx memory. Let the machine initialize its \"extra\" stuff.\n+        let (alloc, tag) = M::init_allocation_extra(\n             memory_extra,\n             id, // always use the ID we got as input, not the \"hidden\" one.\n             alloc,\n             M::STATIC_KIND.map(MemoryKind::Machine),\n-        ).0)\n+        );\n+        debug_assert_eq!(tag, M::tag_static_base_pointer(memory_extra, id));\n+        Ok(alloc)\n     }\n \n     /// Gives raw access to the `Allocation`, without bounds or alignment checks."}, {"sha": "9e94ae2c1608131cebb5c9465d687bd9920960af", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=2da942f32802c8233a09744024dfbc34431adf65", "patch": "@@ -24,7 +24,7 @@ use rustc_macros::HashStable;\n ///\n /// For optimization of a few very common cases, there is also a representation for a pair of\n /// primitive values (`ScalarPair`). It allows Miri to avoid making allocations for checked binary\n-/// operations and fat pointers. This idea was taken from rustc's codegen.\n+/// operations and wide pointers. This idea was taken from rustc's codegen.\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n /// defined on `Immediate`, and do not have to work with a `Place`.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, Hash)]\n@@ -47,6 +47,13 @@ impl<Tag> From<Scalar<Tag>> for Immediate<Tag> {\n     }\n }\n \n+impl<Tag> From<Pointer<Tag>> for Immediate<Tag> {\n+    #[inline(always)]\n+    fn from(val: Pointer<Tag>) -> Self {\n+        Immediate::Scalar(Scalar::from(val).into())\n+    }\n+}\n+\n impl<'tcx, Tag> Immediate<Tag> {\n     pub fn new_slice(\n         val: Scalar<Tag>,\n@@ -60,14 +67,14 @@ impl<'tcx, Tag> Immediate<Tag> {\n     }\n \n     pub fn new_dyn_trait(val: Scalar<Tag>, vtable: Pointer<Tag>) -> Self {\n-        Immediate::ScalarPair(val.into(), Scalar::Ptr(vtable).into())\n+        Immediate::ScalarPair(val.into(), vtable.into())\n     }\n \n     #[inline]\n     pub fn to_scalar_or_undef(self) -> ScalarMaybeUndef<Tag> {\n         match self {\n             Immediate::Scalar(val) => val,\n-            Immediate::ScalarPair(..) => bug!(\"Got a fat pointer where a scalar was expected\"),\n+            Immediate::ScalarPair(..) => bug!(\"Got a wide pointer where a scalar was expected\"),\n         }\n     }\n \n@@ -324,7 +331,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(self.read_immediate(op)?.to_scalar_or_undef())\n     }\n \n-    // Turn the MPlace into a string (must already be dereferenced!)\n+    // Turn the wide MPlace into a string (must already be dereferenced!)\n     pub fn read_str(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>,"}, {"sha": "da601c3a9f0a303f9e0c5a08ccbcfcd8a6a87dc4", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=2da942f32802c8233a09744024dfbc34431adf65", "patch": "@@ -125,7 +125,7 @@ impl<Tag> MemPlace<Tag> {\n         Self::from_scalar_ptr(ptr.into(), align)\n     }\n \n-    /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n+    /// Turn a mplace into a (thin or wide) pointer, as a reference, pointing to the same space.\n     /// This is the inverse of `ref_to_mplace`.\n     #[inline(always)]\n     pub fn to_ref(self) -> Immediate<Tag> {\n@@ -278,7 +278,7 @@ where\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n     M::AllocExtra: AllocationExtra<Tag>,\n {\n-    /// Take a value, which represents a (thin or fat) reference, and make it a place.\n+    /// Take a value, which represents a (thin or wide) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n     ///\n     /// Only call this if you are sure the place is \"valid\" (aligned and inbounds), or do not\n@@ -694,6 +694,7 @@ where\n     }\n \n     /// Write a scalar to a place\n+    #[inline(always)]\n     pub fn write_scalar(\n         &mut self,\n         val: impl Into<ScalarMaybeUndef<M::PointerTag>>,\n@@ -1041,6 +1042,24 @@ where\n         MPlaceTy::from_aligned_ptr(ptr, layout)\n     }\n \n+    /// Returns a wide MPlace.\n+    pub fn allocate_str(\n+        &mut self,\n+        str: &str,\n+        kind: MemoryKind<M::MemoryKinds>,\n+    ) -> MPlaceTy<'tcx, M::PointerTag> {\n+        let ptr = self.memory.allocate_static_bytes(str.as_bytes(), kind);\n+        let meta = Scalar::from_uint(str.len() as u128, self.pointer_size());\n+        let mplace = MemPlace {\n+            ptr: ptr.into(),\n+            align: Align::from_bytes(1).unwrap(),\n+            meta: Some(meta),\n+        };\n+\n+        let layout = self.layout_of(self.tcx.mk_static_str()).unwrap();\n+        MPlaceTy { mplace, layout }\n+    }\n+\n     pub fn write_discriminant_index(\n         &mut self,\n         variant_index: VariantIdx,"}, {"sha": "06c3969fbc542c1a0e43899e7a6589251d78c199", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 17, "deletions": 37, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=2da942f32802c8233a09744024dfbc34431adf65", "patch": "@@ -7,8 +7,8 @@ use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n use super::{\n-    GlobalId, InterpResult, PointerArithmetic,\n-    InterpCx, Machine, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n+    GlobalId, InterpResult, InterpCx, Machine,\n+    OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n };\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -115,40 +115,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 expected,\n                 ref msg,\n                 target,\n-                ..\n+                cleanup,\n             } => {\n                 let cond_val = self.read_immediate(self.eval_operand(cond, None)?)?\n                     .to_scalar()?.to_bool()?;\n                 if expected == cond_val {\n                     self.go_to_block(target);\n                 } else {\n-                    // Compute error message\n-                    use rustc::mir::interpret::PanicInfo::*;\n-                    return Err(match msg {\n-                        BoundsCheck { ref len, ref index } => {\n-                            let len = self\n-                                .read_immediate(self.eval_operand(len, None)?)\n-                                .expect(\"can't eval len\")\n-                                .to_scalar()?\n-                                .to_bits(self.memory.pointer_size())? as u64;\n-                            let index = self\n-                                .read_immediate(self.eval_operand(index, None)?)\n-                                .expect(\"can't eval index\")\n-                                .to_scalar()?\n-                                .to_bits(self.memory.pointer_size())? as u64;\n-                            err_panic!(BoundsCheck { len, index })\n-                        }\n-                        Overflow(op) => err_panic!(Overflow(*op)),\n-                        OverflowNeg => err_panic!(OverflowNeg),\n-                        DivisionByZero => err_panic!(DivisionByZero),\n-                        RemainderByZero => err_panic!(RemainderByZero),\n-                        ResumedAfterReturn(generator_kind)\n-                            => err_panic!(ResumedAfterReturn(*generator_kind)),\n-                        ResumedAfterPanic(generator_kind)\n-                            => err_panic!(ResumedAfterPanic(*generator_kind)),\n-                        Panic { .. } => bug!(\"`Panic` variant cannot occur in MIR\"),\n-                    }\n-                    .into());\n+                    M::assert_panic(self, terminator.source_info.span, msg, cleanup)?;\n                 }\n             }\n \n@@ -164,15 +138,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 return Ok(())\n             },\n \n+            // It is UB to ever encounter this.\n+            Unreachable => throw_ub!(Unreachable),\n+\n+            // These should never occur for MIR we actually run.\n+            DropAndReplace { .. } |\n+            FalseEdges { .. } |\n+            FalseUnwind { .. } =>\n+                bug!(\"{:#?} should have been eliminated by MIR pass\", terminator.kind),\n+\n+            // These are not (yet) supported. It is unclear if they even can occur in\n+            // MIR that we actually run.\n             Yield { .. } |\n             GeneratorDrop |\n-            DropAndReplace { .. } |\n-            Abort => unimplemented!(\"{:#?}\", terminator.kind),\n-            FalseEdges { .. } => bug!(\"should have been eliminated by\\\n-                                      `simplify_branches` mir pass\"),\n-            FalseUnwind { .. } => bug!(\"should have been eliminated by\\\n-                                       `simplify_branches` mir pass\"),\n-            Unreachable => throw_ub!(Unreachable),\n+            Abort =>\n+                throw_unsup_format!(\"Unsupported terminator kind: {:#?}\", terminator.kind),\n         }\n \n         Ok(())"}, {"sha": "efa0d266cbc21c410e70a65c2ccd4634a09ad917", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=2da942f32802c8233a09744024dfbc34431adf65", "patch": "@@ -67,7 +67,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // allocation is correctly aligned as we created it above. Also we're only offsetting by\n         // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n         let vtable_alloc = self.memory.get_raw_mut(vtable.alloc_id)?;\n-        vtable_alloc.write_ptr_sized(tcx, vtable, Scalar::Ptr(drop).into())?;\n+        vtable_alloc.write_ptr_sized(tcx, vtable, drop.into())?;\n \n         let size_ptr = vtable.offset(ptr_size, tcx)?;\n         vtable_alloc.write_ptr_sized(tcx, size_ptr, Scalar::from_uint(size, ptr_size).into())?;\n@@ -87,7 +87,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // We cannot use `vtable_allic` as we are creating fn ptrs in this loop.\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), tcx)?;\n                 self.memory.get_raw_mut(vtable.alloc_id)?\n-                    .write_ptr_sized(tcx, method_ptr, Scalar::Ptr(fn_ptr).into())?;\n+                    .write_ptr_sized(tcx, method_ptr, fn_ptr.into())?;\n             }\n         }\n "}, {"sha": "bbbaac145f559028991ca4adb4d7cbbf3fc910e6", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2da942f32802c8233a09744024dfbc34431adf65/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=2da942f32802c8233a09744024dfbc34431adf65", "patch": "@@ -156,6 +156,15 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         throw_unsup!(ConstPropUnsupported(\"calling intrinsics isn't supported in ConstProp\"));\n     }\n \n+    fn assert_panic(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _span: Span,\n+        _msg: &rustc::mir::interpret::AssertMessage<'tcx>,\n+        _unwind: Option<rustc::mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        bug!(\"panics terminators are not evaluated in ConstProp\");\n+    }\n+\n     fn ptr_to_int(\n         _mem: &Memory<'mir, 'tcx, Self>,\n         _ptr: Pointer,\n@@ -182,7 +191,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     }\n \n     #[inline(always)]\n-    fn tag_allocation<'b>(\n+    fn init_allocation_extra<'b>(\n         _memory_extra: &(),\n         _id: AllocId,\n         alloc: Cow<'b, Allocation>,"}]}