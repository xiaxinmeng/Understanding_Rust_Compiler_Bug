{"sha": "4991cc5d19a61da91345e9a324c0ea4b8d1b923d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5OTFjYzVkMTlhNjFkYTkxMzQ1ZTlhMzI0YzBlYTRiOGQxYjkyM2Q=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-01T22:23:21Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-01T22:24:11Z"}, "message": "rustc: Translate by-value pattern bindings", "tree": {"sha": "3788c62c410de31677a22e12deda3e6ef912fb0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3788c62c410de31677a22e12deda3e6ef912fb0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4991cc5d19a61da91345e9a324c0ea4b8d1b923d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4991cc5d19a61da91345e9a324c0ea4b8d1b923d", "html_url": "https://github.com/rust-lang/rust/commit/4991cc5d19a61da91345e9a324c0ea4b8d1b923d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4991cc5d19a61da91345e9a324c0ea4b8d1b923d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f60c56c3e1abfc9cae313ba8d0ed26ff455a9c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f60c56c3e1abfc9cae313ba8d0ed26ff455a9c1", "html_url": "https://github.com/rust-lang/rust/commit/7f60c56c3e1abfc9cae313ba8d0ed26ff455a9c1"}], "stats": {"total": 155, "additions": 120, "deletions": 35}, "files": [{"sha": "62b7c247784747120f77e1bcebde8502c84c2a47", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 120, "deletions": 35, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/4991cc5d19a61da91345e9a324c0ea4b8d1b923d/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4991cc5d19a61da91345e9a324c0ea4b8d1b923d/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=4991cc5d19a61da91345e9a324c0ea4b8d1b923d", "patch": "@@ -79,17 +79,24 @@ fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> opt {\n     core::unreachable();\n }\n \n+struct binding {\n+    val: ValueRef;\n+    mode: ast::binding_mode;\n+    ty: ty::t;\n+}\n+\n type bind_map = ~[{\n     ident: ast::ident,\n-    val: ValueRef,\n-    mode: ast::binding_mode\n+    binding: binding\n }];\n \n-fn assoc(key: ast::ident, list: bind_map) -> option<ValueRef> {\n+fn assoc(key: ast::ident, list: bind_map) -> option<binding> {\n     for vec::each(list) |elt| {\n-        if str::eq(*elt.ident, *key) { ret some(elt.val); }\n+        if str::eq(*elt.ident, *key) {\n+            return some(elt.binding);\n+        }\n     }\n-    ret none;\n+    return none;\n }\n \n type match_branch =\n@@ -110,7 +117,9 @@ fn has_nested_bindings(m: match_, col: uint) -> bool {\n     ret false;\n }\n \n-fn expand_nested_bindings(m: match_, col: uint, val: ValueRef) -> match_ {\n+fn expand_nested_bindings(bcx: block, m: match_, col: uint, val: ValueRef)\n+                       -> match_ {\n+\n     let mut result = ~[];\n     for vec::each(m) |br| {\n       alt br.pats[col].node {\n@@ -123,8 +132,12 @@ fn expand_nested_bindings(m: match_, col: uint, val: ValueRef) -> match_ {\n                       @{pats: pats,\n                         bound: vec::append(\n                             br.bound, ~[{ident: path_to_ident(name),\n-                                        val: val,\n-                                        mode: mode}])\n+                                         binding: binding {\n+                                            val: val,\n+                                            mode: mode,\n+                                            ty: node_id_type(bcx,\n+                                                             br.pats[col].id)\n+                                         }}])\n                                 with *br});\n           }\n           _ { vec::push(result, br); }\n@@ -135,7 +148,7 @@ fn expand_nested_bindings(m: match_, col: uint, val: ValueRef) -> match_ {\n \n type enter_pat = fn(@ast::pat) -> option<~[@ast::pat]>;\n \n-fn enter_match(dm: DefMap, m: match_, col: uint, val: ValueRef,\n+fn enter_match(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef,\n                e: enter_pat) -> match_ {\n     let mut result = ~[];\n     for vec::each(m) |br| {\n@@ -149,8 +162,11 @@ fn enter_match(dm: DefMap, m: match_, col: uint, val: ValueRef,\n               ast::pat_ident(mode, name, none) if !pat_is_variant(dm, self) {\n                 vec::append(br.bound,\n                             ~[{ident: path_to_ident(name),\n-                               val: val,\n-                               mode: mode}])\n+                               binding: binding {\n+                                   val: val,\n+                                   mode: mode,\n+                                   ty: node_id_type(bcx, br.pats[col].id)\n+                               }}])\n               }\n               _ { br.bound }\n             };\n@@ -162,8 +178,10 @@ fn enter_match(dm: DefMap, m: match_, col: uint, val: ValueRef,\n     ret result;\n }\n \n-fn enter_default(dm: DefMap, m: match_, col: uint, val: ValueRef) -> match_ {\n-    do enter_match(dm, m, col, val) |p| {\n+fn enter_default(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n+              -> match_ {\n+\n+    do enter_match(bcx, dm, m, col, val) |p| {\n         alt p.node {\n           ast::pat_wild | ast::pat_rec(_, _) | ast::pat_tup(_) { some(~[]) }\n           ast::pat_ident(_, _, none) if !pat_is_variant(dm, p) {\n@@ -174,10 +192,11 @@ fn enter_default(dm: DefMap, m: match_, col: uint, val: ValueRef) -> match_ {\n     }\n }\n \n-fn enter_opt(tcx: ty::ctxt, m: match_, opt: opt, col: uint,\n+fn enter_opt(bcx: block, m: match_, opt: opt, col: uint,\n              variant_size: uint, val: ValueRef) -> match_ {\n+    let tcx = bcx.tcx();\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    do enter_match(tcx.def_map, m, col, val) |p| {\n+    do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n         alt p.node {\n           ast::pat_enum(_, subpats) {\n             if opt_eq(tcx, variant_opt(tcx, p.id), opt) {\n@@ -200,10 +219,10 @@ fn enter_opt(tcx: ty::ctxt, m: match_, opt: opt, col: uint,\n     }\n }\n \n-fn enter_rec(dm: DefMap, m: match_, col: uint, fields: ~[ast::ident],\n-             val: ValueRef) -> match_ {\n+fn enter_rec(bcx: block, dm: DefMap, m: match_, col: uint,\n+             fields: ~[ast::ident], val: ValueRef) -> match_ {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    do enter_match(dm, m, col, val) |p| {\n+    do enter_match(bcx, dm, m, col, val) |p| {\n         alt p.node {\n           ast::pat_rec(fpats, _) {\n             let mut pats = ~[];\n@@ -221,30 +240,32 @@ fn enter_rec(dm: DefMap, m: match_, col: uint, fields: ~[ast::ident],\n     }\n }\n \n-fn enter_tup(dm: DefMap, m: match_, col: uint, val: ValueRef,\n+fn enter_tup(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef,\n              n_elts: uint) -> match_ {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    do enter_match(dm, m, col, val) |p| {\n+    do enter_match(bcx, dm, m, col, val) |p| {\n         alt p.node {\n           ast::pat_tup(elts) { some(elts) }\n           _ { some(vec::from_elem(n_elts, dummy)) }\n         }\n     }\n }\n \n-fn enter_box(dm: DefMap, m: match_, col: uint, val: ValueRef) -> match_ {\n+fn enter_box(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n+          -> match_ {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    do enter_match(dm, m, col, val) |p| {\n+    do enter_match(bcx, dm, m, col, val) |p| {\n         alt p.node {\n           ast::pat_box(sub) { some(~[sub]) }\n           _ { some(~[dummy]) }\n         }\n     }\n }\n \n-fn enter_uniq(dm: DefMap, m: match_, col: uint, val: ValueRef) -> match_ {\n+fn enter_uniq(bcx: block, dm: DefMap, m: match_, col: uint, val: ValueRef)\n+           -> match_ {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    do enter_match(dm, m, col, val) |p| {\n+    do enter_match(bcx, dm, m, col, val) |p| {\n         alt p.node {\n           ast::pat_uniq(sub) { some(~[sub]) }\n           _ { some(~[dummy]) }\n@@ -407,9 +428,24 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n           some(e) {\n             // Temporarily set bindings. They'll be rewritten to PHI nodes\n             // for the actual arm block.\n+            //\n+            // Also, in the case of by-value, do the copy now.\n+\n             for data.id_map.each |key, val| {\n-                let loc = local_mem(option::get(assoc(key, m[0].bound)));\n-                bcx.fcx.lllocals.insert(val, loc);\n+                let binding = assoc(key, m[0].bound).get();\n+                let (llval, mode) = (binding.val, binding.mode);\n+                let ty = binding.ty;\n+\n+                if mode == ast::bind_by_value {\n+                    let llty = type_of::type_of(bcx.fcx.ccx, ty);\n+                    let alloc = alloca(bcx, llty);\n+                    bcx = copy_val(bcx, INIT, alloc,\n+                                   load_if_immediate(bcx, llval, ty), ty);\n+                    bcx.fcx.lllocals.insert(val, local_mem(alloc));\n+                    add_clean(bcx, alloc, ty);\n+                } else {\n+                    bcx.fcx.lllocals.insert(val, local_mem(llval));\n+                }\n             };\n             let {bcx: guard_cx, val} = {\n                 do with_scope_result(bcx, e.info(), ~\"guard\") |bcx| {\n@@ -434,7 +470,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n     let col = pick_col(m);\n     let val = vals[col];\n     let m = if has_nested_bindings(m, col) {\n-                expand_nested_bindings(m, col, val)\n+                expand_nested_bindings(bcx, m, col, val)\n             } else { m };\n \n     let vals_left = vec::append(vec::slice(vals, 0u, col),\n@@ -458,7 +494,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n             let ix = option::get(ty::field_idx(field_name, fields));\n             vec::push(rec_vals, GEPi(bcx, val, ~[0u, ix]));\n         }\n-        compile_submatch(bcx, enter_rec(dm, m, col, rec_fields, val),\n+        compile_submatch(bcx, enter_rec(bcx, dm, m, col, rec_fields, val),\n                          vec::append(rec_vals, vals_left), chk, exits);\n         ret;\n     }\n@@ -474,7 +510,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n             vec::push(tup_vals, GEPi(bcx, val, ~[0u, i]));\n             i += 1u;\n         }\n-        compile_submatch(bcx, enter_tup(dm, m, col, val, n_tup_elts),\n+        compile_submatch(bcx, enter_tup(bcx, dm, m, col, val, n_tup_elts),\n                          vec::append(tup_vals, vals_left), chk, exits);\n         ret;\n     }\n@@ -485,7 +521,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         let box_no_addrspace = non_gc_box_cast(bcx, llbox);\n         let unboxed =\n             GEPi(bcx, box_no_addrspace, ~[0u, abi::box_field_body]);\n-        compile_submatch(bcx, enter_box(dm, m, col, val),\n+        compile_submatch(bcx, enter_box(bcx, dm, m, col, val),\n                          vec::append(~[unboxed], vals_left), chk, exits);\n         ret;\n     }\n@@ -495,7 +531,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         let box_no_addrspace = non_gc_box_cast(bcx, llbox);\n         let unboxed =\n             GEPi(bcx, box_no_addrspace, ~[0u, abi::box_field_body]);\n-        compile_submatch(bcx, enter_uniq(dm, m, col, val),\n+        compile_submatch(bcx, enter_uniq(bcx, dm, m, col, val),\n                          vec::append(~[unboxed], vals_left), chk, exits);\n         ret;\n     }\n@@ -544,7 +580,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         Switch(bcx, test_val, else_cx.llbb, opts.len())\n     } else { C_int(ccx, 0) }; // Placeholder for when not using a switch\n \n-    let defaults = enter_default(dm, m, col, val);\n+    let defaults = enter_default(bcx, dm, m, col, val);\n     let exhaustive = option::is_none(chk) && defaults.len() == 0u;\n     let len = opts.len();\n     let mut i = 0u;\n@@ -599,7 +635,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n           }\n           lit(_) | range(_, _) { }\n         }\n-        compile_submatch(opt_cx, enter_opt(tcx, m, opt, col, size, val),\n+        compile_submatch(opt_cx, enter_opt(bcx, m, opt, col, size, val),\n                          vec::append(unpacked, vals_left), chk, exits);\n     }\n \n@@ -624,9 +660,9 @@ fn make_phi_bindings(bcx: block, map: ~[exit_node],\n         for vec::each(map) |ex| {\n             if ex.to as uint == our_block {\n                 alt assoc(name, ex.bound) {\n-                  some(val) {\n+                  some(binding) {\n                     vec::push(llbbs, ex.from);\n-                    vec::push(vals, val);\n+                    vec::push(vals, binding.val);\n                   }\n                   none { }\n                 }\n@@ -643,6 +679,54 @@ fn make_phi_bindings(bcx: block, map: ~[exit_node],\n     ret success;\n }\n \n+// Copies by-value bindings into their homes.\n+fn copy_by_value_bindings(bcx: block,\n+                          exit_node_map: &[exit_node],\n+                          pat_ids: pat_util::pat_id_map)\n+                       -> block {\n+    let mut bcx = bcx;\n+    let our_block = bcx.llbb as uint;\n+    for pat_ids.each |name, node_id| {\n+        let bindings = dvec::dvec();\n+        for exit_node_map.each |exit_node| {\n+            if exit_node.to as uint == our_block {\n+                match assoc(name, exit_node.bound) {\n+                    none => {}\n+                    some(binding) => bindings.push(binding)\n+                }\n+            }\n+        }\n+\n+        if bindings.len() == 0 {\n+            again;\n+        }\n+\n+        let binding = bindings[0];\n+        match binding.mode {\n+            ast::bind_by_ref => {}\n+            ast::bind_by_value => {\n+                let llvalue;\n+                match bcx.fcx.lllocals.get(node_id) {\n+                    local_mem(llval) =>\n+                        llvalue = llval,\n+                    local_imm(_) =>\n+                        bcx.sess().bug(~\"local_imm unexpected here\")\n+                }\n+\n+                let lltype = type_of::type_of(bcx.fcx.ccx, binding.ty);\n+                let allocation = alloca(bcx, lltype);\n+                let ty = binding.ty;\n+                bcx = copy_val(bcx, INIT, allocation,\n+                               load_if_immediate(bcx, llvalue, ty), ty);\n+                bcx.fcx.lllocals.insert(node_id, local_mem(allocation));\n+                add_clean(bcx, allocation, ty);\n+            }\n+        }\n+    }\n+\n+    return bcx;\n+}\n+\n fn trans_alt(bcx: block,\n              alt_expr: @ast::expr,\n              expr: @ast::expr,\n@@ -713,6 +797,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n         let body_cx = bodies[i];\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n         if make_phi_bindings(body_cx, exit_map, id_map) {\n+            let body_cx = copy_by_value_bindings(body_cx, exit_map, id_map);\n             let arm_dest = dup_for_join(dest);\n             vec::push(arm_dests, arm_dest);\n             let mut arm_cx = trans_block(body_cx, a.body, arm_dest);"}]}