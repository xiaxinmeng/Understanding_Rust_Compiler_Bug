{"sha": "daf48b82abd87b6f2016881528be2e978fd5def7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZjQ4YjgyYWJkODdiNmYyMDE2ODgxNTI4YmUyZTk3OGZkNWRlZjc=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-10-05T09:04:25Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-10-05T09:04:25Z"}, "message": "inliner: use caller param_env", "tree": {"sha": "456c509b79542b02a89b3d07a844539732114847", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/456c509b79542b02a89b3d07a844539732114847"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daf48b82abd87b6f2016881528be2e978fd5def7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daf48b82abd87b6f2016881528be2e978fd5def7", "html_url": "https://github.com/rust-lang/rust/commit/daf48b82abd87b6f2016881528be2e978fd5def7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daf48b82abd87b6f2016881528be2e978fd5def7/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efbaa413061c2a6e52f06f00a60ee7830fcf3ea5", "url": "https://api.github.com/repos/rust-lang/rust/commits/efbaa413061c2a6e52f06f00a60ee7830fcf3ea5", "html_url": "https://github.com/rust-lang/rust/commit/efbaa413061c2a6e52f06f00a60ee7830fcf3ea5"}], "stats": {"total": 70, "additions": 53, "deletions": 17}, "files": [{"sha": "bec1eb790478c10d6ed1f51c446dcc523078064e", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/daf48b82abd87b6f2016881528be2e978fd5def7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf48b82abd87b6f2016881528be2e978fd5def7/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=daf48b82abd87b6f2016881528be2e978fd5def7", "patch": "@@ -45,15 +45,20 @@ impl<'tcx> MirPass<'tcx> for Inline {\n                 // based function.\n                 debug!(\"function inlining is disabled when compiling with `instrument_coverage`\");\n             } else {\n-                Inliner { tcx, codegen_fn_attrs: tcx.codegen_fn_attrs(body.source.def_id()) }\n-                    .run_pass(body);\n+                Inliner {\n+                    tcx,\n+                    param_env: tcx.param_env_reveal_all_normalized(body.source.def_id()),\n+                    codegen_fn_attrs: tcx.codegen_fn_attrs(body.source.def_id()),\n+                }\n+                .run_pass(body);\n             }\n         }\n     }\n }\n \n struct Inliner<'tcx> {\n     tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     codegen_fn_attrs: &'tcx CodegenFnAttrs,\n }\n \n@@ -75,17 +80,13 @@ impl Inliner<'tcx> {\n \n         let def_id = caller_body.source.def_id();\n \n-        let param_env = self.tcx.param_env_reveal_all_normalized(def_id);\n-\n         // Only do inlining into fn bodies.\n         let self_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         if self.tcx.hir().body_owner_kind(self_hir_id).is_fn_or_closure()\n             && caller_body.source.promoted.is_none()\n         {\n             for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated() {\n-                if let Some(callsite) =\n-                    self.get_valid_function_call(bb, bb_data, caller_body, param_env)\n-                {\n+                if let Some(callsite) = self.get_valid_function_call(bb, bb_data, caller_body) {\n                     callsites.push_back(callsite);\n                 }\n             }\n@@ -131,7 +132,7 @@ impl Inliner<'tcx> {\n                 let callee_body = if self.consider_optimizing(callsite, callee_body) {\n                     self.tcx.subst_and_normalize_erasing_regions(\n                         &callsite.substs,\n-                        param_env,\n+                        self.param_env,\n                         callee_body,\n                     )\n                 } else {\n@@ -159,7 +160,7 @@ impl Inliner<'tcx> {\n                 // Add callsites from inlined function\n                 for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated().skip(start) {\n                     if let Some(new_callsite) =\n-                        self.get_valid_function_call(bb, bb_data, caller_body, param_env)\n+                        self.get_valid_function_call(bb, bb_data, caller_body)\n                     {\n                         // Don't inline the same function multiple times.\n                         if callsite.callee != new_callsite.callee {\n@@ -190,7 +191,6 @@ impl Inliner<'tcx> {\n         bb: BasicBlock,\n         bb_data: &BasicBlockData<'tcx>,\n         caller_body: &Body<'tcx>,\n-        param_env: ParamEnv<'tcx>,\n     ) -> Option<CallSite<'tcx>> {\n         // Don't inline calls that are in cleanup blocks.\n         if bb_data.is_cleanup {\n@@ -201,8 +201,9 @@ impl Inliner<'tcx> {\n         let terminator = bb_data.terminator();\n         if let TerminatorKind::Call { func: ref op, .. } = terminator.kind {\n             if let ty::FnDef(callee_def_id, substs) = *op.ty(caller_body, self.tcx).kind() {\n-                let instance =\n-                    Instance::resolve(self.tcx, param_env, callee_def_id, substs).ok().flatten()?;\n+                let instance = Instance::resolve(self.tcx, self.param_env, callee_def_id, substs)\n+                    .ok()\n+                    .flatten()?;\n \n                 if let InstanceDef::Virtual(..) = instance.def {\n                     return None;\n@@ -300,9 +301,6 @@ impl Inliner<'tcx> {\n         debug!(\"    final inline threshold = {}\", threshold);\n \n         // FIXME: Give a bonus to functions with only a single caller\n-\n-        let param_env = tcx.param_env(callee_body.source.def_id());\n-\n         let mut first_block = true;\n         let mut cost = 0;\n \n@@ -335,7 +333,7 @@ impl Inliner<'tcx> {\n                     // If the place doesn't actually need dropping, treat it like\n                     // a regular goto.\n                     let ty = place.ty(callee_body, tcx).subst(tcx, callsite.substs).ty;\n-                    if ty.needs_drop(tcx, param_env) {\n+                    if ty.needs_drop(tcx, self.param_env) {\n                         cost += CALL_PENALTY;\n                         if let Some(unwind) = unwind {\n                             cost += LANDINGPAD_PENALTY;\n@@ -400,7 +398,7 @@ impl Inliner<'tcx> {\n             let ty = v.ty.subst(tcx, callsite.substs);\n             // Cost of the var is the size in machine-words, if we know\n             // it.\n-            if let Some(size) = type_size_of(tcx, param_env, ty) {\n+            if let Some(size) = type_size_of(tcx, self.param_env, ty) {\n                 cost += (size / ptr_size) as usize;\n             } else {\n                 cost += UNKNOWN_SIZE_COST;"}, {"sha": "262402df2cc5ae4a05aa9b919aade9cd66ab6e78", "filename": "src/test/ui/mir/mir-inlining/ice-issue-77564.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/daf48b82abd87b6f2016881528be2e978fd5def7/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Fice-issue-77564.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf48b82abd87b6f2016881528be2e978fd5def7/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Fice-issue-77564.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Fice-issue-77564.rs?ref=daf48b82abd87b6f2016881528be2e978fd5def7", "patch": "@@ -0,0 +1,38 @@\n+// run-pass\n+// compile-flags:-Zmir-opt-level=2\n+\n+use std::mem::MaybeUninit;\n+const N: usize = 2;\n+\n+trait CollectArray<A>: Iterator<Item = A> {\n+    fn inner_array(&mut self) -> [A; N];\n+    fn collect_array(&mut self) -> [A; N] {\n+        let result = self.inner_array();\n+        assert!(self.next().is_none());\n+        result\n+    }\n+}\n+\n+impl<A, I: ?Sized> CollectArray<A> for I\n+where\n+    I: Iterator<Item = A>,\n+{\n+    fn inner_array(&mut self) -> [A; N] {\n+        let mut result: [MaybeUninit<A>; N] = unsafe { MaybeUninit::uninit().assume_init() };\n+        for (dest, item) in result.iter_mut().zip(self) {\n+            *dest = MaybeUninit::new(item);\n+        }\n+        let temp_ptr: *const [MaybeUninit<A>; N] = &result;\n+        unsafe { std::ptr::read(temp_ptr as *const [A; N]) }\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(\n+        [[1, 2], [3, 4]]\n+            .iter()\n+            .map(|row| row.iter().collect_array())\n+            .collect_array(),\n+        [[&1, &2], [&3, &4]]\n+    );\n+}"}]}