{"sha": "74de79b1daeefb4868ce34e03e84949d33d3dd1e", "node_id": "C_kwDOAAsO6NoAKDc0ZGU3OWIxZGFlZWZiNDg2OGNlMzRlMDNlODQ5NDlkMzNkM2RkMWU", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-12-25T18:59:02Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-12-25T19:02:26Z"}, "message": "internal: rename", "tree": {"sha": "ee48d79b7998c9ebc3a339b32fc0eb7cf943ec50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee48d79b7998c9ebc3a339b32fc0eb7cf943ec50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74de79b1daeefb4868ce34e03e84949d33d3dd1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74de79b1daeefb4868ce34e03e84949d33d3dd1e", "html_url": "https://github.com/rust-lang/rust/commit/74de79b1daeefb4868ce34e03e84949d33d3dd1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74de79b1daeefb4868ce34e03e84949d33d3dd1e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0d05075ed52aa22dfec36b5a7b23e6a1a554496", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0d05075ed52aa22dfec36b5a7b23e6a1a554496", "html_url": "https://github.com/rust-lang/rust/commit/d0d05075ed52aa22dfec36b5a7b23e6a1a554496"}], "stats": {"total": 195, "additions": 106, "deletions": 89}, "files": [{"sha": "5e14a3fb590264a75b84770996e02a88aa872a56", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=74de79b1daeefb4868ce34e03e84949d33d3dd1e", "patch": "@@ -10,7 +10,7 @@ mod parser;\n mod expander;\n mod syntax_bridge;\n mod tt_iter;\n-mod to_parser_tokens;\n+mod to_parser_input;\n \n #[cfg(test)]\n mod benchmark;"}, {"sha": "f0c1f806ffae9c9354da9eb1cb633fb354c321ca", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=74de79b1daeefb4868ce34e03e84949d33d3dd1e", "patch": "@@ -10,7 +10,7 @@ use syntax::{\n use tt::buffer::{Cursor, TokenBuffer};\n \n use crate::{\n-    to_parser_tokens::to_parser_tokens, tt_iter::TtIter, ExpandError, ParserEntryPoint, TokenMap,\n+    to_parser_input::to_parser_input, tt_iter::TtIter, ExpandError, ParserEntryPoint, TokenMap,\n };\n \n /// Convert the syntax node to a `TokenTree` (what macro\n@@ -54,17 +54,17 @@ pub fn token_tree_to_syntax_node(\n         }\n         _ => TokenBuffer::from_subtree(tt),\n     };\n-    let parser_tokens = to_parser_tokens(&buffer);\n-    let tree_traversal = parser::parse(&parser_tokens, entry_point);\n+    let parser_input = to_parser_input(&buffer);\n+    let parser_output = parser::parse(&parser_input, entry_point);\n     let mut tree_sink = TtTreeSink::new(buffer.begin());\n-    for event in tree_traversal.iter() {\n+    for event in parser_output.iter() {\n         match event {\n-            parser::TraversalStep::Token { kind, n_raw_tokens } => {\n+            parser::Step::Token { kind, n_input_tokens: n_raw_tokens } => {\n                 tree_sink.token(kind, n_raw_tokens)\n             }\n-            parser::TraversalStep::EnterNode { kind } => tree_sink.start_node(kind),\n-            parser::TraversalStep::LeaveNode => tree_sink.finish_node(),\n-            parser::TraversalStep::Error { msg } => tree_sink.error(msg.to_string()),\n+            parser::Step::Enter { kind } => tree_sink.start_node(kind),\n+            parser::Step::Exit => tree_sink.finish_node(),\n+            parser::Step::Error { msg } => tree_sink.error(msg.to_string()),\n         }\n     }\n     if tree_sink.roots.len() != 1 {"}, {"sha": "6faa147218e1d14f96c2da53dc2d10216dd40839", "filename": "crates/mbe/src/to_parser_input.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fto_parser_input.rs?ref=74de79b1daeefb4868ce34e03e84949d33d3dd1e", "patch": "@@ -4,8 +4,8 @@\n use syntax::{SyntaxKind, SyntaxKind::*, T};\n use tt::buffer::TokenBuffer;\n \n-pub(crate) fn to_parser_tokens(buffer: &TokenBuffer) -> parser::Tokens {\n-    let mut res = parser::Tokens::default();\n+pub(crate) fn to_parser_input(buffer: &TokenBuffer) -> parser::Input {\n+    let mut res = parser::Input::default();\n \n     let mut current = buffer.begin();\n ", "previous_filename": "crates/mbe/src/to_parser_tokens.rs"}, {"sha": "2d2dbd8994f6419aa1ce025994be158839ed08ad", "filename": "crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=74de79b1daeefb4868ce34e03e84949d33d3dd1e", "patch": "@@ -1,7 +1,7 @@\n //! A \"Parser\" structure for token trees. We use this when parsing a declarative\n //! macro definition into a list of patterns and templates.\n \n-use crate::{to_parser_tokens::to_parser_tokens, ExpandError, ExpandResult, ParserEntryPoint};\n+use crate::{to_parser_input::to_parser_input, ExpandError, ExpandResult, ParserEntryPoint};\n \n use syntax::SyntaxKind;\n use tt::buffer::TokenBuffer;\n@@ -94,23 +94,23 @@ impl<'a> TtIter<'a> {\n         entry_point: ParserEntryPoint,\n     ) -> ExpandResult<Option<tt::TokenTree>> {\n         let buffer = TokenBuffer::from_tokens(self.inner.as_slice());\n-        let parser_tokens = to_parser_tokens(&buffer);\n-        let tree_traversal = parser::parse(&parser_tokens, entry_point);\n+        let parser_input = to_parser_input(&buffer);\n+        let tree_traversal = parser::parse(&parser_input, entry_point);\n \n         let mut cursor = buffer.begin();\n         let mut error = false;\n         for step in tree_traversal.iter() {\n             match step {\n-                parser::TraversalStep::Token { kind, mut n_raw_tokens } => {\n+                parser::Step::Token { kind, mut n_input_tokens } => {\n                     if kind == SyntaxKind::LIFETIME_IDENT {\n-                        n_raw_tokens = 2;\n+                        n_input_tokens = 2;\n                     }\n-                    for _ in 0..n_raw_tokens {\n+                    for _ in 0..n_input_tokens {\n                         cursor = cursor.bump_subtree();\n                     }\n                 }\n-                parser::TraversalStep::EnterNode { .. } | parser::TraversalStep::LeaveNode => (),\n-                parser::TraversalStep::Error { .. } => error = true,\n+                parser::Step::Enter { .. } | parser::Step::Exit => (),\n+                parser::Step::Error { .. } => error = true,\n             }\n         }\n "}, {"sha": "b0e70e794303c6219e70eb582d0e019c75ad61d0", "filename": "crates/parser/src/event.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fparser%2Fsrc%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fparser%2Fsrc%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fevent.rs?ref=74de79b1daeefb4868ce34e03e84949d33d3dd1e", "patch": "@@ -10,7 +10,7 @@\n use std::mem;\n \n use crate::{\n-    tree_traversal::TreeTraversal,\n+    output::Output,\n     SyntaxKind::{self, *},\n };\n \n@@ -87,8 +87,8 @@ impl Event {\n }\n \n /// Generate the syntax tree with the control of events.\n-pub(super) fn process(mut events: Vec<Event>) -> TreeTraversal {\n-    let mut res = TreeTraversal::default();\n+pub(super) fn process(mut events: Vec<Event>) -> Output {\n+    let mut res = Output::default();\n     let mut forward_parents = Vec::new();\n \n     for i in 0..events.len() {"}, {"sha": "9504bd4d9ec83f6dda167aafab091dfeec60e8f3", "filename": "crates/parser/src/input.rs", "status": "renamed", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fparser%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fparser%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Finput.rs?ref=74de79b1daeefb4868ce34e03e84949d33d3dd1e", "patch": "@@ -1,26 +1,26 @@\n-//! Input for the parser -- a sequence of tokens.\n-//!\n-//! As of now, parser doesn't have access to the *text* of the tokens, and makes\n-//! decisions based solely on their classification. Unlike `LexerToken`, the\n-//! `Tokens` doesn't include whitespace and comments.\n+//! See [`Input`].\n \n use crate::SyntaxKind;\n \n #[allow(non_camel_case_types)]\n type bits = u64;\n \n-/// Main input to the parser.\n+/// Input for the parser -- a sequence of tokens.\n ///\n-/// A sequence of tokens represented internally as a struct of arrays.\n+/// As of now, parser doesn't have access to the *text* of the tokens, and makes\n+/// decisions based solely on their classification. Unlike `LexerToken`, the\n+/// `Tokens` doesn't include whitespace and comments. Main input to the parser.\n+///\n+/// Struct of arrays internally, but this shouldn't really matter.\n #[derive(Default)]\n-pub struct Tokens {\n+pub struct Input {\n     kind: Vec<SyntaxKind>,\n     joint: Vec<bits>,\n     contextual_kind: Vec<SyntaxKind>,\n }\n \n /// `pub` impl used by callers to create `Tokens`.\n-impl Tokens {\n+impl Input {\n     #[inline]\n     pub fn push(&mut self, kind: SyntaxKind) {\n         self.push_impl(kind, SyntaxKind::EOF)\n@@ -63,7 +63,7 @@ impl Tokens {\n }\n \n /// pub(crate) impl used by the parser to consume `Tokens`.\n-impl Tokens {\n+impl Input {\n     pub(crate) fn kind(&self, idx: usize) -> SyntaxKind {\n         self.kind.get(idx).copied().unwrap_or(SyntaxKind::EOF)\n     }\n@@ -76,7 +76,7 @@ impl Tokens {\n     }\n }\n \n-impl Tokens {\n+impl Input {\n     fn bit_index(&self, n: usize) -> (usize, usize) {\n         let idx = n / (bits::BITS as usize);\n         let b_idx = n % (bits::BITS as usize);", "previous_filename": "crates/parser/src/tokens.rs"}, {"sha": "f17aae1d3140a35f953ac006696ba178a76f227e", "filename": "crates/parser/src/lexed_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fparser%2Fsrc%2Flexed_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fparser%2Fsrc%2Flexed_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flexed_str.rs?ref=74de79b1daeefb4868ce34e03e84949d33d3dd1e", "patch": "@@ -122,8 +122,8 @@ impl<'a> LexedStr<'a> {\n         self.error.iter().map(|it| (it.token as usize, it.msg.as_str()))\n     }\n \n-    pub fn to_tokens(&self) -> crate::Tokens {\n-        let mut res = crate::Tokens::default();\n+    pub fn to_input(&self) -> crate::Input {\n+        let mut res = crate::Input::default();\n         let mut was_joint = false;\n         for i in 0..self.len() {\n             let kind = self.kind(i);"}, {"sha": "da78889f350040bf31b15454c342bb535d84e19e", "filename": "crates/parser/src/lib.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fparser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fparser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flib.rs?ref=74de79b1daeefb4868ce34e03e84949d33d3dd1e", "patch": "@@ -24,19 +24,19 @@ mod syntax_kind;\n mod event;\n mod parser;\n mod grammar;\n-mod tokens;\n-mod tree_traversal;\n+mod input;\n+mod output;\n \n #[cfg(test)]\n mod tests;\n \n pub(crate) use token_set::TokenSet;\n \n pub use crate::{\n+    input::Input,\n     lexed_str::LexedStr,\n+    output::{Output, Step},\n     syntax_kind::SyntaxKind,\n-    tokens::Tokens,\n-    tree_traversal::{TraversalStep, TreeTraversal},\n };\n \n /// rust-analyzer parser allows you to choose one of the possible entry points.\n@@ -62,11 +62,19 @@ pub enum ParserEntryPoint {\n }\n \n /// Parse given tokens into the given sink as a rust file.\n-pub fn parse_source_file(tokens: &Tokens) -> TreeTraversal {\n-    parse(tokens, ParserEntryPoint::SourceFile)\n+pub fn parse_source_file(inp: &Input) -> Output {\n+    parse(inp, ParserEntryPoint::SourceFile)\n }\n \n-pub fn parse(tokens: &Tokens, entry_point: ParserEntryPoint) -> TreeTraversal {\n+/// Parses the given [`Input`] into [`Output`] assuming that the top-level\n+/// syntactic construct is the given [`ParserEntryPoint`].\n+///\n+/// Both input and output here are fairly abstract. The overall flow is that the\n+/// caller has some \"real\" tokens, converts them to [`Input`], parses them to\n+/// [`Output`], and then converts that into a \"real\" tree. The \"real\" tree is\n+/// made of \"real\" tokens, so this all hinges on rather tight coordination of\n+/// indices between the four stages.\n+pub fn parse(inp: &Input, entry_point: ParserEntryPoint) -> Output {\n     let entry_point: fn(&'_ mut parser::Parser) = match entry_point {\n         ParserEntryPoint::SourceFile => grammar::entry_points::source_file,\n         ParserEntryPoint::Path => grammar::entry_points::path,\n@@ -84,7 +92,7 @@ pub fn parse(tokens: &Tokens, entry_point: ParserEntryPoint) -> TreeTraversal {\n         ParserEntryPoint::Attr => grammar::entry_points::attr,\n     };\n \n-    let mut p = parser::Parser::new(tokens);\n+    let mut p = parser::Parser::new(inp);\n     entry_point(&mut p);\n     let events = p.finish();\n     event::process(events)\n@@ -107,7 +115,7 @@ impl Reparser {\n     ///\n     /// Tokens must start with `{`, end with `}` and form a valid brace\n     /// sequence.\n-    pub fn parse(self, tokens: &Tokens) -> TreeTraversal {\n+    pub fn parse(self, tokens: &Input) -> Output {\n         let Reparser(r) = self;\n         let mut p = parser::Parser::new(tokens);\n         r(&mut p);"}, {"sha": "b613df029f8206097f0449a6ef41b3ba5a0f2496", "filename": "crates/parser/src/output.rs", "status": "renamed", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fparser%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fparser%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Foutput.rs?ref=74de79b1daeefb4868ce34e03e84949d33d3dd1e", "patch": "@@ -1,43 +1,52 @@\n-//! TODO\n+//! See [`Output`]\n+\n use crate::SyntaxKind;\n \n-/// Output of the parser.\n+/// Output of the parser -- a DFS traversal of a concrete syntax tree.\n+///\n+/// Use the [`Output::iter`] method to iterate over traversal steps and consume\n+/// a syntax tree.\n+///\n+/// In a sense, this is just a sequence of [`SyntaxKind`]-colored parenthesis\n+/// interspersed into the original [`crate::Input`]. The output is fundamentally\n+/// coordinated with the input and `n_input_tokens` refers to the number of\n+/// times [`crate::Input::push`] was called.\n #[derive(Default)]\n-pub struct TreeTraversal {\n+pub struct Output {\n     /// 32-bit encoding of events. If LSB is zero, then that's an index into the\n     /// error vector. Otherwise, it's one of the thee other variants, with data encoded as\n     ///\n-    ///     |16 bit kind|8 bit n_raw_tokens|4 bit tag|4 bit leftover|\n+    ///     |16 bit kind|8 bit n_input_tokens|4 bit tag|4 bit leftover|\n     ///\n     event: Vec<u32>,\n     error: Vec<String>,\n }\n \n-pub enum TraversalStep<'a> {\n-    Token { kind: SyntaxKind, n_raw_tokens: u8 },\n-    EnterNode { kind: SyntaxKind },\n-    LeaveNode,\n+pub enum Step<'a> {\n+    Token { kind: SyntaxKind, n_input_tokens: u8 },\n+    Enter { kind: SyntaxKind },\n+    Exit,\n     Error { msg: &'a str },\n }\n \n-impl TreeTraversal {\n-    pub fn iter(&self) -> impl Iterator<Item = TraversalStep<'_>> {\n+impl Output {\n+    pub fn iter(&self) -> impl Iterator<Item = Step<'_>> {\n         self.event.iter().map(|&event| {\n             if event & 0b1 == 0 {\n-                return TraversalStep::Error { msg: self.error[(event as usize) >> 1].as_str() };\n+                return Step::Error { msg: self.error[(event as usize) >> 1].as_str() };\n             }\n             let tag = ((event & 0x0000_00F0) >> 4) as u8;\n             match tag {\n                 0 => {\n                     let kind: SyntaxKind = (((event & 0xFFFF_0000) >> 16) as u16).into();\n-                    let n_raw_tokens = ((event & 0x0000_FF00) >> 8) as u8;\n-                    TraversalStep::Token { kind, n_raw_tokens }\n+                    let n_input_tokens = ((event & 0x0000_FF00) >> 8) as u8;\n+                    Step::Token { kind, n_input_tokens }\n                 }\n                 1 => {\n                     let kind: SyntaxKind = (((event & 0xFFFF_0000) >> 16) as u16).into();\n-                    TraversalStep::EnterNode { kind }\n+                    Step::Enter { kind }\n                 }\n-                2 => TraversalStep::LeaveNode,\n+                2 => Step::Exit,\n                 _ => unreachable!(),\n             }\n         })", "previous_filename": "crates/parser/src/tree_traversal.rs"}, {"sha": "d4aecf9b446a36216f7a9afec4a2af848395b27d", "filename": "crates/parser/src/parser.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fparser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fparser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fparser.rs?ref=74de79b1daeefb4868ce34e03e84949d33d3dd1e", "patch": "@@ -7,7 +7,7 @@ use limit::Limit;\n \n use crate::{\n     event::Event,\n-    tokens::Tokens,\n+    input::Input,\n     SyntaxKind::{self, EOF, ERROR, TOMBSTONE},\n     TokenSet, T,\n };\n@@ -22,7 +22,7 @@ use crate::{\n /// \"start expression, consume number literal,\n /// finish expression\". See `Event` docs for more.\n pub(crate) struct Parser<'t> {\n-    tokens: &'t Tokens,\n+    inp: &'t Input,\n     pos: usize,\n     events: Vec<Event>,\n     steps: Cell<u32>,\n@@ -31,8 +31,8 @@ pub(crate) struct Parser<'t> {\n static PARSER_STEP_LIMIT: Limit = Limit::new(15_000_000);\n \n impl<'t> Parser<'t> {\n-    pub(super) fn new(tokens: &'t Tokens) -> Parser<'t> {\n-        Parser { tokens, pos: 0, events: Vec::new(), steps: Cell::new(0) }\n+    pub(super) fn new(inp: &'t Input) -> Parser<'t> {\n+        Parser { inp, pos: 0, events: Vec::new(), steps: Cell::new(0) }\n     }\n \n     pub(crate) fn finish(self) -> Vec<Event> {\n@@ -55,7 +55,7 @@ impl<'t> Parser<'t> {\n         assert!(PARSER_STEP_LIMIT.check(steps as usize).is_ok(), \"the parser seems stuck\");\n         self.steps.set(steps + 1);\n \n-        self.tokens.kind(self.pos + n)\n+        self.inp.kind(self.pos + n)\n     }\n \n     /// Checks if the current token is `kind`.\n@@ -91,7 +91,7 @@ impl<'t> Parser<'t> {\n             T![<<=] => self.at_composite3(n, T![<], T![<], T![=]),\n             T![>>=] => self.at_composite3(n, T![>], T![>], T![=]),\n \n-            _ => self.tokens.kind(self.pos + n) == kind,\n+            _ => self.inp.kind(self.pos + n) == kind,\n         }\n     }\n \n@@ -130,17 +130,17 @@ impl<'t> Parser<'t> {\n     }\n \n     fn at_composite2(&self, n: usize, k1: SyntaxKind, k2: SyntaxKind) -> bool {\n-        self.tokens.kind(self.pos + n) == k1\n-            && self.tokens.kind(self.pos + n + 1) == k2\n-            && self.tokens.is_joint(self.pos + n)\n+        self.inp.kind(self.pos + n) == k1\n+            && self.inp.kind(self.pos + n + 1) == k2\n+            && self.inp.is_joint(self.pos + n)\n     }\n \n     fn at_composite3(&self, n: usize, k1: SyntaxKind, k2: SyntaxKind, k3: SyntaxKind) -> bool {\n-        self.tokens.kind(self.pos + n) == k1\n-            && self.tokens.kind(self.pos + n + 1) == k2\n-            && self.tokens.kind(self.pos + n + 2) == k3\n-            && self.tokens.is_joint(self.pos + n)\n-            && self.tokens.is_joint(self.pos + n + 1)\n+        self.inp.kind(self.pos + n) == k1\n+            && self.inp.kind(self.pos + n + 1) == k2\n+            && self.inp.kind(self.pos + n + 2) == k3\n+            && self.inp.is_joint(self.pos + n)\n+            && self.inp.is_joint(self.pos + n + 1)\n     }\n \n     /// Checks if the current token is in `kinds`.\n@@ -150,7 +150,7 @@ impl<'t> Parser<'t> {\n \n     /// Checks if the current token is contextual keyword with text `t`.\n     pub(crate) fn at_contextual_kw(&self, kw: SyntaxKind) -> bool {\n-        self.tokens.contextual_kind(self.pos) == kw\n+        self.inp.contextual_kind(self.pos) == kw\n     }\n \n     /// Starts a new node in the syntax tree. All nodes and tokens"}, {"sha": "20c7101a0324cfa1d9d350e6a77b99c8ae09dcd1", "filename": "crates/syntax/src/parsing.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fsyntax%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fsyntax%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fparsing.rs?ref=74de79b1daeefb4868ce34e03e84949d33d3dd1e", "patch": "@@ -12,9 +12,9 @@ pub(crate) use crate::parsing::reparsing::incremental_reparse;\n \n pub(crate) fn parse_text(text: &str) -> (GreenNode, Vec<SyntaxError>) {\n     let lexed = parser::LexedStr::new(text);\n-    let parser_tokens = lexed.to_tokens();\n-    let tree_traversal = parser::parse_source_file(&parser_tokens);\n-    let (node, errors, _eof) = build_tree(lexed, tree_traversal, false);\n+    let parser_input = lexed.to_input();\n+    let parser_output = parser::parse_source_file(&parser_input);\n+    let (node, errors, _eof) = build_tree(lexed, parser_output, false);\n     (node, errors)\n }\n \n@@ -27,9 +27,9 @@ pub(crate) fn parse_text_as<T: AstNode>(\n     if lexed.errors().next().is_some() {\n         return Err(());\n     }\n-    let parser_tokens = lexed.to_tokens();\n-    let tree_traversal = parser::parse(&parser_tokens, entry_point);\n-    let (node, errors, eof) = build_tree(lexed, tree_traversal, true);\n+    let parser_input = lexed.to_input();\n+    let parser_output = parser::parse(&parser_input, entry_point);\n+    let (node, errors, eof) = build_tree(lexed, parser_output, true);\n \n     if !errors.is_empty() || !eof {\n         return Err(());"}, {"sha": "bbe7209e726eea9abdde2efe6c820f99f7fc15a0", "filename": "crates/syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=74de79b1daeefb4868ce34e03e84949d33d3dd1e", "patch": "@@ -89,7 +89,7 @@ fn reparse_block(\n     let text = get_text_after_edit(node.clone().into(), edit);\n \n     let lexed = parser::LexedStr::new(text.as_str());\n-    let parser_tokens = lexed.to_tokens();\n+    let parser_input = lexed.to_input();\n     if !is_balanced(&lexed) {\n         return None;\n     }"}, {"sha": "a5bc3f58dc632f5d42b2346de41fd8367920c849", "filename": "crates/syntax/src/parsing/text_tree_sink.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fsyntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74de79b1daeefb4868ce34e03e84949d33d3dd1e/crates%2Fsyntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs?ref=74de79b1daeefb4868ce34e03e84949d33d3dd1e", "patch": "@@ -2,7 +2,7 @@\n \n use std::mem;\n \n-use parser::{LexedStr, TreeTraversal};\n+use parser::LexedStr;\n \n use crate::{\n     ast,\n@@ -14,7 +14,7 @@ use crate::{\n \n pub(crate) fn build_tree(\n     lexed: LexedStr<'_>,\n-    tree_traversal: TreeTraversal,\n+    parser_output: parser::Output,\n     synthetic_root: bool,\n ) -> (GreenNode, Vec<SyntaxError>, bool) {\n     let mut builder = TextTreeSink::new(lexed);\n@@ -23,14 +23,14 @@ pub(crate) fn build_tree(\n         builder.start_node(SyntaxKind::SOURCE_FILE);\n     }\n \n-    for event in tree_traversal.iter() {\n+    for event in parser_output.iter() {\n         match event {\n-            parser::TraversalStep::Token { kind, n_raw_tokens } => {\n+            parser::Step::Token { kind, n_input_tokens: n_raw_tokens } => {\n                 builder.token(kind, n_raw_tokens)\n             }\n-            parser::TraversalStep::EnterNode { kind } => builder.start_node(kind),\n-            parser::TraversalStep::LeaveNode => builder.finish_node(),\n-            parser::TraversalStep::Error { msg } => {\n+            parser::Step::Enter { kind } => builder.start_node(kind),\n+            parser::Step::Exit => builder.finish_node(),\n+            parser::Step::Error { msg } => {\n                 let text_pos = builder.lexed.text_start(builder.pos).try_into().unwrap();\n                 builder.inner.error(msg.to_string(), text_pos);\n             }\n@@ -45,7 +45,7 @@ pub(crate) fn build_tree(\n /// Bridges the parser with our specific syntax tree representation.\n ///\n /// `TextTreeSink` also handles attachment of trivia (whitespace) to nodes.\n-pub(crate) struct TextTreeSink<'a> {\n+struct TextTreeSink<'a> {\n     lexed: LexedStr<'a>,\n     pos: usize,\n     state: State,"}]}