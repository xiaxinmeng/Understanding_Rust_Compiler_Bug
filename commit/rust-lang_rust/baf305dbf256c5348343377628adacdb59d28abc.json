{"sha": "baf305dbf256c5348343377628adacdb59d28abc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZjMwNWRiZjI1NmM1MzQ4MzQzMzc3NjI4YWRhY2RiNTlkMjhhYmM=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-08-11T04:19:03Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-08-14T20:04:56Z"}, "message": "Guide: iterators", "tree": {"sha": "f064de9d259e3967bfc1f2db83b5d5a7da06c34d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f064de9d259e3967bfc1f2db83b5d5a7da06c34d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/baf305dbf256c5348343377628adacdb59d28abc", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/baf305dbf256c5348343377628adacdb59d28abc", "html_url": "https://github.com/rust-lang/rust/commit/baf305dbf256c5348343377628adacdb59d28abc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/baf305dbf256c5348343377628adacdb59d28abc/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7d0b5259d95ab4ef821bdf93a434538c3a84dad", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7d0b5259d95ab4ef821bdf93a434538c3a84dad", "html_url": "https://github.com/rust-lang/rust/commit/c7d0b5259d95ab4ef821bdf93a434538c3a84dad"}], "stats": {"total": 338, "additions": 336, "deletions": 2}, "files": [{"sha": "83438714fbe5bc598934baec878b5c2d85bf5b13", "filename": "src/doc/guide.md", "status": "modified", "additions": 336, "deletions": 2, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/baf305dbf256c5348343377628adacdb59d28abc/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/baf305dbf256c5348343377628adacdb59d28abc/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=baf305dbf256c5348343377628adacdb59d28abc", "patch": "@@ -4049,9 +4049,343 @@ Doing this is not particularly common, but every once in a while, it's useful.\n That's all you need to get the hang of closures! Closures are a little bit\n strange at first, but once you're used to using them, you'll miss them in any\n language that doesn't have them. Passing functions to other functions is\n-incredibly powerful.  Next, let's look at one of those things: iterators.\n+incredibly powerful. Next, let's look at one of those things: iterators.\n \n-# iterators\n+# Iterators\n+\n+Let's talk about loops.\n+\n+Remember Rust's `for` loop? Here's an example:\n+\n+```{rust}\n+for x in range(0i, 10i) {\n+    println!(\"{:d}\", x);\n+}\n+```\n+\n+Now that you know more Rust, we can talk in detail about how this works. The\n+`range` function returns an **iterator**. An iterator is something that we can\n+call the `.next()` method on repeatedly, and it gives us a sequence of things.\n+\n+Like this:\n+\n+```{rust}\n+let mut range = range(0i, 10i);\n+\n+loop {\n+    match range.next() {\n+        Some(x) => {\n+            println!(\"{}\", x);\n+        }\n+        None => { break }\n+    }\n+}\n+```\n+\n+We make a mutable binding to the return value of `range`, which is our iterator.\n+We then `loop`, with an inner `match`. This `match` is used on the result of\n+`range.next()`, which gives us a reference to the next value of the iterator.\n+`next` returns an `Option<int>`, in this case, which will be `Some(int)` when\n+we have a value and `None` once we run out. If we get `Some(int)`, we print it\n+out, and if we get `None`, we `break` out of the loop.\n+\n+This code sample is basically the same as our `for` loop version. The `for`\n+loop is just a handy way to write this `loop`/`match`/`break` construct.\n+\n+`for` loops aren't the only thing that uses iterators, however. Writing your\n+own iterator involves implementing the `Iterator` trait. While doing that is\n+outside of the scope of this guide, Rust provides a number of useful iterators\n+to accomplish various tasks. Before we talk about those, we should talk about a\n+Rust anti-pattern. And that's `range`.\n+\n+Yes, we just talked about how `range` is cool. But `range` is also very\n+primitive. For example, if you needed to iterate over the contents of\n+a vector, you may be tempted to write this:\n+\n+```{rust}\n+let nums = vec![1i, 2i, 3i];\n+\n+for i in range(0u, nums.len()) {\n+    println!(\"{}\", nums[i]);\n+}\n+```\n+\n+This is strictly worse than using an actual iterator. The `.iter()` method on\n+vectors returns an iterator which iterates through a reference to each element\n+of the vector in turn. So write this:\n+\n+```{rust}\n+let nums = vec![1i, 2i, 3i];\n+\n+for num in nums.iter() {\n+    println!(\"{}\", num);\n+}\n+```\n+\n+There are two reasons for this. First, this is more semantic. We iterate\n+through the entire vector, rather than iterating through indexes, and then\n+indexing the vector. Second, this version is more efficient: the first version\n+will have extra bounds checking because it used indexing, `nums[i]`. But since\n+we yield a reference to each element of the vector in turn with the iterator,\n+there's no bounds checking in the second example. This is very common with\n+iterators: we can ignore unnecessary bounds checks, but still know that we're\n+safe.\n+\n+There's another detail here that's not 100% clear because of how `println!`\n+works. `num` is actually of type `&int`, that is, it's a reference to an `int`,\n+not an `int` itself. `println!` handles the dereferencing for us, so we don't\n+see it. This code works fine too:\n+\n+```{rust}\n+let nums = vec![1i, 2i, 3i];\n+\n+for num in nums.iter() {\n+    println!(\"{}\", *num);\n+}\n+```\n+\n+Now we're explicitly dereferencing `num`. Why does `iter()` give us references?\n+Well, if it gave us the data itself, we would have to be its owner, which would\n+involve making a copy of the data and giving us the copy. With references,\n+we're just borrowing a reference to the data, and so it's just passing\n+a reference, without needing to do the copy.\n+\n+So, now that we've established that `range` is often not what you want, let's\n+talk about what you do want instead.\n+\n+There are three broad classes of things that are relevant here: iterators,\n+**iterator adapters**, and **consumers**. Here's some definitions:\n+\n+* 'iterators' give you a sequence of values.\n+* 'iterator adapters' operate on an iterator, producing a new iterator with a\n+  different output sequence.\n+* 'consumers' operate on an iterator, producing some final set of values.\n+\n+Let's talk about consumers first, since you've already seen an iterator,\n+`range`.\n+\n+## Consumers\n+\n+A 'consumer' operates on an iterator, returning some kind of value or values.\n+The most common consumer is `collect()`. This code doesn't quite compile,\n+but it shows the intention:\n+\n+```{rust,ignore}\n+let one_to_one_hundred = range(0i, 100i).collect();\n+```\n+\n+As you can see, we call `collect()` on our iterator. `collect()` takes\n+as many values as the iterator will give it, and returns a collection \n+of the results. So why won't this compile? Rust can't determine what\n+type of things you want to collect, and so you need to let it know.\n+Here's the version that does compile:\n+\n+```{rust}\n+let one_to_one_hundred = range(0i, 100i).collect::<Vec<int>>();\n+```\n+\n+If you remember, the `::<>` syntax allows us to give a type hint,\n+and so we tell it that we want a vector of integers.\n+\n+`collect()` is the most common consumer, but there are others too. `find()`\n+is one:\n+\n+```{rust}\n+let one_to_one_hundred = range(0i, 100i);\n+\n+let greater_than_forty_two = range(0i, 100i)\n+                             .find(|x| *x >= 42);\n+\n+match greater_than_forty_two {\n+    Some(_) => println!(\"We got some numbers!\"),\n+    None    => println!(\"No numbers found :(\"),\n+}\n+```\n+\n+`find` takes a closure, and works on a reference to each element of an\n+iterator. This closure returns `true` if the element is the element we're\n+looking for, and `false` otherwise. Because we might not find a matching\n+element, `find` returns an `Option` rather than the element itself.\n+\n+Another important consumer is `fold`. Here's what it looks like:\n+\n+```{rust}\n+let sum = range(1i, 100i)\n+              .fold(0i, |sum, x| sum + x);\n+```\n+\n+`fold()` is a consumer that looks like this:\n+`fold(base, |accumulator, element| ...)`. It takes two arguments: the first\n+is an element called the \"base\". The second is a closure that itself takes two\n+arguments: the first is called the \"accumulator,\" and the second is an\n+\"element.\" Upon each iteration, the closure is called, and the result is the\n+value of the accumulator on the next iteration. On the first iteration, the\n+base is the value of the accumulator.\n+\n+Okay, that's a bit confusing. Let's examine the values of all of these things\n+in this iterator:\n+\n+| base | accumulator | element | closure result |\n+|------|-------------|---------|----------------|\n+| 0i   | 0i          | 1i      | 1i             |\n+| 0i   | 1i          | 2i      | 3i             |\n+| 0i   | 3i          | 3i      | 6i             |\n+\n+We called `fold()` with these arguments:\n+\n+```{rust}\n+# range(1i, 5i)\n+.fold(0i, |sum, x| sum + x);\n+```\n+\n+So, `0i` is our base, `sum` is our accumulator, and `x` is our element.  On the\n+first iteration, we set `sum` to `0i`, and `x` is the first element of `nums`,\n+`1i`. We then add `sum` and `x`, which gives us `0i + 1i = 1i`. On the second\n+iteration, that value becomes our accumulator, `sum`, and the element is\n+the second element of the array, `2i`. `1i + 2i = 3i`, and so that becomes\n+the value of the accumulator for the last iteration. On that iteration,\n+`x` is the last element, `3i`, and `3i + 3i = 6i`, which is our final\n+result for our sum. `1 + 2 + 3 = 6`, and that's the result we got.\n+\n+Whew. `fold` can be a bit strange the first few times you see it, but once it\n+clicks, you can use it all over the place. Any time you have a list of things,\n+and you want a single result, `fold` is appropriate.\n+\n+Consumers are important due to one additional property of iterators we haven't\n+talked about yet: laziness. Let's talk some more about iterators, and you'll\n+see why consumers matter.\n+\n+## Iterators\n+\n+As we've said before, an iterator is something that we can call the `.next()`\n+method on repeatedly, and it gives us a sequence of things. Because you need\n+to call the method, this means that iterators are **lazy**. This code, for\n+example, does not actually generate the numbers `1-100`, and just creates a\n+value that represents the sequence:\n+\n+```{rust}\n+let nums = range(1i, 100i);\n+```\n+\n+Since we didn't do anything with the range, it didn't generate the sequence.\n+Once we add the consumer:\n+\n+```{rust}\n+let nums = range(1i, 100i).collect::<Vec<int>>();\n+```\n+\n+Now, `collect()` will require that `range()` give it some numbers, and so\n+it will do the work of generating the sequence.\n+\n+`range` is one of two basic iterators that you'll see. The other is `iter()`,\n+which you've used before. `iter()` can turn a vector into a simple iterator\n+that gives you each element in turn:\n+\n+```{rust}\n+let nums = [1i, 2i, 3i];\n+\n+for num in nums.iter() {\n+   println!(\"{}\", num);\n+}\n+```\n+\n+These two basic iterators should serve you well. There are some more\n+advanced iterators, including ones that are infinite. Like `count`:\n+\n+```{rust}\n+std::iter::count(1i, 5i);\n+```\n+\n+This iterator counts up from one, adding five each time. It will give\n+you a new integer every time, forever. Well, technically, until the\n+maximum number that an `int` can represent. But since iterators are lazy,\n+that's okay! You probably don't want to use `collect()` on it, though...\n+\n+That's enough about iterators. Iterator adapters are the last concept\n+we need to talk about with regards to iterators. Let's get to it!\n+\n+## Iterator adapters\n+\n+\"Iterator adapters\" take an iterator and modify it somehow, producing\n+a new iterator. The simplest one is called `map`:\n+\n+```{rust,ignore}\n+range(1i, 100i).map(|x| x + 1i);\n+```\n+\n+`map` is called upon another iterator, and produces a new iterator where each\n+element reference has the closure it's been given as an argument called on it.\n+So this would give us the numbers from `2-101`. Well, almost! If you\n+compile the example, you'll get a warning:\n+\n+```{notrust,ignore}\n+2:37 warning: unused result which must be used: iterator adaptors are lazy and\n+              do nothing unless consumed, #[warn(unused_must_use)] on by default\n+ range(1i, 100i).map(|x| x + 1i);\n+ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+```\n+\n+Laziness strikes again! That closure will never execute. This example\n+doesn't print any numbers:\n+\n+```{rust,ignore}\n+range(1i, 100i).map(|x| println!(\"{}\", x));\n+```\n+\n+If you are trying to execute a closure on an iterator for its side effects,\n+just use `for` instead.\n+\n+There are tons of interesting iterator adapters. `take(n)` will get the\n+first `n` items out of an iterator, and return them as a list. Let's\n+try it out with our infinite iterator from before, `count()`:\n+\n+```{rust}\n+for i in std::iter::count(1i, 5i).take(5) {\n+    println!(\"{}\", i);\n+}\n+```\n+\n+This will print\n+\n+```{notrust,ignore}\n+1\n+6\n+11\n+16\n+21\n+```\n+\n+`filter()` is an adapter that takes a closure as an argument. This closure\n+returns `true` or `false`. The new iterator `filter()` produces returns\n+only the elements that that closure returned `true` for:\n+\n+```{rust}\n+for i in range(1i, 100i).filter(|x| x % 2 == 0) {\n+    println!(\"{}\", i);\n+}\n+```\n+\n+This will print all of the even numbers between one and a hundred.\n+\n+You can chain all three things together: start with an iterator, adapt it\n+a few times, and then consume the result. Check it out:\n+\n+```{rust}\n+range(1i, 1000i)\n+    .filter(|x| x % 2 == 0)\n+    .filter(|x| x % 3 == 0)\n+    .take(5)\n+    .collect::<Vec<int>>();\n+```\n+\n+This will give you a vector containing `6`, `12`, `18`, `24`, and `30`.\n+\n+This is just a small taste of what iterators, iterator adapters, and consumers\n+can help you with. There are a number of really useful iterators, and you can\n+write your own as well. Iterators provide a safe, efficient way to manipulate\n+all kinds of lists. They're a little unusual at first, but if you play with\n+them, you'll get hooked. For a full list of the different iterators and\n+consumers, check out the [iterator module documentation](std/iter/index.html).\n \n # Generics\n "}]}