{"sha": "6133e6a002037bfae8e9ff3fbd0fa7c92c5ee68b", "node_id": "C_kwDOAAsO6NoAKDYxMzNlNmEwMDIwMzdiZmFlOGU5ZmYzZmJkMGZhN2M5MmM1ZWU2OGI", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-03-20T12:42:47Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-03-21T15:45:30Z"}, "message": "Extract coercion logic to InferenceTable\n\nTo make it accessible without an InferenceContext.", "tree": {"sha": "b677d252d71aab0811c1060a1f8d541f71084b3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b677d252d71aab0811c1060a1f8d541f71084b3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6133e6a002037bfae8e9ff3fbd0fa7c92c5ee68b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6133e6a002037bfae8e9ff3fbd0fa7c92c5ee68b", "html_url": "https://github.com/rust-lang/rust/commit/6133e6a002037bfae8e9ff3fbd0fa7c92c5ee68b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6133e6a002037bfae8e9ff3fbd0fa7c92c5ee68b/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a0b199c8232a62227fe2785ea6b8e7a4924fb3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a0b199c8232a62227fe2785ea6b8e7a4924fb3e", "html_url": "https://github.com/rust-lang/rust/commit/6a0b199c8232a62227fe2785ea6b8e7a4924fb3e"}], "stats": {"total": 52, "additions": 34, "deletions": 18}, "files": [{"sha": "1275d596734bfad5c8f2e4f19aa963b6c16142a8", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6133e6a002037bfae8e9ff3fbd0fa7c92c5ee68b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6133e6a002037bfae8e9ff3fbd0fa7c92c5ee68b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=6133e6a002037bfae8e9ff3fbd0fa7c92c5ee68b", "patch": "@@ -22,6 +22,8 @@ use crate::{\n     Solution, Substitution, Ty, TyBuilder, TyExt, TyKind,\n };\n \n+use super::unify::InferenceTable;\n+\n pub(crate) type CoerceResult = Result<InferOk<(Vec<Adjustment>, Ty)>, TypeError>;\n \n /// Do not require any adjustments, i.e. coerce `x -> x`.\n@@ -84,8 +86,8 @@ impl CoerceMany {\n         };\n         if let Some(sig) = sig {\n             let target_ty = TyKind::Function(sig.to_fn_ptr()).intern(Interner);\n-            let result1 = ctx.coerce_inner(self.expected_ty.clone(), &target_ty);\n-            let result2 = ctx.coerce_inner(expr_ty.clone(), &target_ty);\n+            let result1 = ctx.table.coerce_inner(self.expected_ty.clone(), &target_ty);\n+            let result2 = ctx.table.coerce_inner(expr_ty.clone(), &target_ty);\n             if let (Ok(result1), Ok(result2)) = (result1, result2) {\n                 ctx.table.register_infer_ok(result1);\n                 ctx.table.register_infer_ok(result2);\n@@ -126,16 +128,31 @@ impl<'a> InferenceContext<'a> {\n         expr: Option<ExprId>,\n         from_ty: &Ty,\n         to_ty: &Ty,\n-    ) -> InferResult<Ty> {\n+    ) -> Result<Ty, TypeError> {\n+        let from_ty = self.resolve_ty_shallow(from_ty);\n+        let to_ty = self.resolve_ty_shallow(to_ty);\n+        let (adjustments, ty) = self.table.coerce(&from_ty, &to_ty)?;\n+        if let Some(expr) = expr {\n+            self.write_expr_adj(expr, adjustments);\n+        }\n+        Ok(ty)\n+    }\n+}\n+\n+impl<'a> InferenceTable<'a> {\n+    /// Unify two types, but may coerce the first one to the second one\n+    /// using \"implicit coercion rules\" if needed.\n+    pub(crate) fn coerce(\n+        &mut self,\n+        from_ty: &Ty,\n+        to_ty: &Ty,\n+    ) -> Result<(Vec<Adjustment>, Ty), TypeError> {\n         let from_ty = self.resolve_ty_shallow(from_ty);\n         let to_ty = self.resolve_ty_shallow(to_ty);\n         match self.coerce_inner(from_ty, &to_ty) {\n             Ok(InferOk { value: (adjustments, ty), goals }) => {\n-                if let Some(expr) = expr {\n-                    self.write_expr_adj(expr, adjustments);\n-                }\n-                self.table.register_infer_ok(InferOk { value: (), goals });\n-                Ok(InferOk { value: ty, goals: Vec::new() })\n+                self.register_infer_ok(InferOk { value: (), goals });\n+                Ok((adjustments, ty))\n             }\n             Err(e) => {\n                 // FIXME deal with error\n@@ -154,7 +171,7 @@ impl<'a> InferenceContext<'a> {\n             //\n             // here, we would coerce from `!` to `?T`.\n             if let TyKind::InferenceVar(tv, TyVariableKind::General) = to_ty.kind(Interner) {\n-                self.table.set_diverging(*tv, true);\n+                self.set_diverging(*tv, true);\n             }\n             return success(simple(Adjust::NeverToAny)(to_ty.clone()), to_ty.clone(), vec![]);\n         }\n@@ -203,8 +220,7 @@ impl<'a> InferenceContext<'a> {\n     where\n         F: FnOnce(Ty) -> Vec<Adjustment>,\n     {\n-        self.table\n-            .try_unify(t1, t2)\n+        self.try_unify(t1, t2)\n             .and_then(|InferOk { goals, .. }| success(f(t1.clone()), t1.clone(), goals))\n     }\n \n@@ -259,9 +275,9 @@ impl<'a> InferenceContext<'a> {\n         // details of coercion errors though, so I think it's useful to leave\n         // the structure like it is.\n \n-        let snapshot = self.table.snapshot();\n+        let snapshot = self.snapshot();\n \n-        let mut autoderef = Autoderef::new(&mut self.table, from_ty.clone());\n+        let mut autoderef = Autoderef::new(self, from_ty.clone());\n         let mut first_error = None;\n         let mut found = None;\n \n@@ -317,7 +333,7 @@ impl<'a> InferenceContext<'a> {\n         let InferOk { value: ty, goals } = match found {\n             Some(d) => d,\n             None => {\n-                self.table.rollback_to(snapshot);\n+                self.rollback_to(snapshot);\n                 let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n                 return Err(err);\n             }\n@@ -513,7 +529,7 @@ impl<'a> InferenceContext<'a> {\n         let coerce_from =\n             reborrow.as_ref().map_or_else(|| from_ty.clone(), |(_, adj)| adj.target.clone());\n \n-        let krate = self.resolver.krate().unwrap();\n+        let krate = self.trait_env.krate;\n         let coerce_unsized_trait =\n             match self.db.lang_item(krate, SmolStr::new_inline(\"coerce_unsized\")) {\n                 Some(LangItemTarget::TraitId(trait_)) => trait_,\n@@ -546,7 +562,7 @@ impl<'a> InferenceContext<'a> {\n         match solution {\n             Solution::Unique(v) => {\n                 canonicalized.apply_solution(\n-                    &mut self.table,\n+                    self,\n                     Canonical {\n                         binders: v.binders,\n                         // FIXME handle constraints\n@@ -556,7 +572,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Solution::Ambig(Guidance::Definite(subst)) => {\n                 // FIXME need to record an obligation here\n-                canonicalized.apply_solution(&mut self.table, subst)\n+                canonicalized.apply_solution(self, subst)\n             }\n             // FIXME actually we maybe should also accept unknown guidance here\n             _ => return Err(TypeError),"}, {"sha": "be00d8ab376942805bf000ee6d528426920ed0c4", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6133e6a002037bfae8e9ff3fbd0fa7c92c5ee68b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6133e6a002037bfae8e9ff3fbd0fa7c92c5ee68b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=6133e6a002037bfae8e9ff3fbd0fa7c92c5ee68b", "patch": "@@ -67,7 +67,7 @@ impl<'a> InferenceContext<'a> {\n         let ty = self.infer_expr_inner(expr, expected);\n         if let Some(target) = expected.only_has_type(&mut self.table) {\n             match self.coerce(Some(expr), &ty, &target) {\n-                Ok(res) => res.value,\n+                Ok(res) => res,\n                 Err(_) => {\n                     self.result\n                         .type_mismatches"}]}