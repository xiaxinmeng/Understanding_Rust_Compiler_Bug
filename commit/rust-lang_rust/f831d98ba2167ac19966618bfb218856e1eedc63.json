{"sha": "f831d98ba2167ac19966618bfb218856e1eedc63", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MzFkOThiYTIxNjdhYzE5OTY2NjE4YmZiMjE4ODU2ZTFlZWRjNjM=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2016-02-09T20:09:37Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2016-02-12T18:28:42Z"}, "message": "Autoderef in librustc_typeck", "tree": {"sha": "61c5fe410487d672707e474875b70e8d89365c83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61c5fe410487d672707e474875b70e8d89365c83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f831d98ba2167ac19966618bfb218856e1eedc63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f831d98ba2167ac19966618bfb218856e1eedc63", "html_url": "https://github.com/rust-lang/rust/commit/f831d98ba2167ac19966618bfb218856e1eedc63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f831d98ba2167ac19966618bfb218856e1eedc63/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c877d61b15bf0098d7dfbde3e74052a3559ad028", "url": "https://api.github.com/repos/rust-lang/rust/commits/c877d61b15bf0098d7dfbde3e74052a3559ad028", "html_url": "https://github.com/rust-lang/rust/commit/c877d61b15bf0098d7dfbde3e74052a3559ad028"}], "stats": {"total": 390, "additions": 195, "deletions": 195}, "files": [{"sha": "4061d3a2028c77989700dd6f987ed9134304aaee", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f831d98ba2167ac19966618bfb218856e1eedc63", "patch": "@@ -562,7 +562,7 @@ fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx>,\n     let assoc_bindings: Vec<_> =\n         data.bindings.iter()\n                      .map(|b| ConvertedBinding { item_name: b.name,\n-                                                 ty: ast_ty_to_ty(this, rscope, &*b.ty),\n+                                                 ty: ast_ty_to_ty(this, rscope, &b.ty),\n                                                  span: b.span })\n                      .collect();\n \n@@ -1064,7 +1064,7 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n                     err.span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n                                         format!(\"&{}({} +{})\",\n                                                 mutbl_str,\n-                                                pprust::ty_to_string(&*mut_ty.ty),\n+                                                pprust::ty_to_string(&mut_ty.ty),\n                                                 pprust::bounds_to_string(bounds)));\n                 }\n                 (&hir::TyRptr(Some(ref lt), ref mut_ty), Some(full_span)) => {\n@@ -1073,7 +1073,7 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n                                         format!(\"&{} {}({} +{})\",\n                                                 pprust::lifetime_to_string(lt),\n                                                 mutbl_str,\n-                                                pprust::ty_to_string(&*mut_ty.ty),\n+                                                pprust::ty_to_string(&mut_ty.ty),\n                                                 pprust::bounds_to_string(bounds)));\n                 }\n \n@@ -1596,10 +1596,10 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     let typ = match ast_ty.node {\n         hir::TyVec(ref ty) => {\n-            tcx.mk_slice(ast_ty_to_ty(this, rscope, &**ty))\n+            tcx.mk_slice(ast_ty_to_ty(this, rscope, &ty))\n         }\n         hir::TyObjectSum(ref ty, ref bounds) => {\n-            match ast_ty_to_trait_ref(this, rscope, &**ty, bounds) {\n+            match ast_ty_to_trait_ref(this, rscope, &ty, bounds) {\n                 Ok((trait_ref, projection_bounds)) => {\n                     trait_ref_to_object_type(this,\n                                              rscope,\n@@ -1615,7 +1615,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n         hir::TyPtr(ref mt) => {\n             tcx.mk_ptr(ty::TypeAndMut {\n-                ty: ast_ty_to_ty(this, rscope, &*mt.ty),\n+                ty: ast_ty_to_ty(this, rscope, &mt.ty),\n                 mutbl: mt.mutbl\n             })\n         }\n@@ -1626,18 +1626,18 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 &ObjectLifetimeDefaultRscope::new(\n                     rscope,\n                     ty::ObjectLifetimeDefault::Specific(r));\n-            let t = ast_ty_to_ty(this, rscope1, &*mt.ty);\n+            let t = ast_ty_to_ty(this, rscope1, &mt.ty);\n             tcx.mk_ref(tcx.mk_region(r), ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n         }\n         hir::TyTup(ref fields) => {\n             let flds = fields.iter()\n-                             .map(|t| ast_ty_to_ty(this, rscope, &**t))\n+                             .map(|t| ast_ty_to_ty(this, rscope, &t))\n                              .collect();\n             tcx.mk_tup(flds)\n         }\n         hir::TyBareFn(ref bf) => {\n             require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n-            let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl);\n+            let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &bf.decl);\n             tcx.mk_fn(None, tcx.mk_bare_fn(bare_fn))\n         }\n         hir::TyPolyTraitRef(ref bounds) => {\n@@ -1687,10 +1687,10 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 Ok(r) => {\n                     match r {\n                         ConstVal::Int(i) =>\n-                            tcx.mk_array(ast_ty_to_ty(this, rscope, &**ty),\n+                            tcx.mk_array(ast_ty_to_ty(this, rscope, &ty),\n                                          i as usize),\n                         ConstVal::Uint(i) =>\n-                            tcx.mk_array(ast_ty_to_ty(this, rscope, &**ty),\n+                            tcx.mk_array(ast_ty_to_ty(this, rscope, &ty),\n                                          i as usize),\n                         _ => {\n                             span_err!(tcx.sess, ast_ty.span, E0249,\n@@ -1740,7 +1740,7 @@ pub fn ty_of_arg<'tcx>(this: &AstConv<'tcx>,\n     match a.ty.node {\n         hir::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n         hir::TyInfer => this.ty_infer(None, None, None, a.ty.span),\n-        _ => ast_ty_to_ty(this, rscope, &*a.ty),\n+        _ => ast_ty_to_ty(this, rscope, &a.ty),\n     }\n }\n \n@@ -1804,7 +1804,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     let arg_tys: Vec<Ty> =\n         arg_params.iter().map(|a| ty_of_arg(this, &rb, a, None)).collect();\n     let arg_pats: Vec<String> =\n-        arg_params.iter().map(|a| pprust::pat_to_string(&*a.pat)).collect();\n+        arg_params.iter().map(|a| pprust::pat_to_string(&a.pat)).collect();\n \n     // Second, if there was exactly one lifetime (either a substitution or a\n     // reference) in the arguments, then any anonymous regions in the output\n@@ -1860,7 +1860,7 @@ fn determine_self_type<'a, 'tcx>(this: &AstConv<'tcx>,\n              Some(ty::ExplicitSelfCategory::ByReference(region, mutability)))\n         }\n         hir::SelfExplicit(ref ast_type, _) => {\n-            let explicit_type = ast_ty_to_ty(this, rscope, &**ast_type);\n+            let explicit_type = ast_ty_to_ty(this, rscope, &ast_type);\n \n             // We wish to (for now) categorize an explicit self\n             // declaration like `self: SomeType` into either `self`,\n@@ -1967,7 +1967,7 @@ pub fn ty_of_closure<'tcx>(\n         _ if is_infer =>\n             ty::FnConverging(this.ty_infer(None, None, None, decl.output.span())),\n         hir::Return(ref output) =>\n-            ty::FnConverging(ast_ty_to_ty(this, &rb, &**output)),\n+            ty::FnConverging(ast_ty_to_ty(this, &rb, &output)),\n         hir::DefaultReturn(..) => unreachable!(),\n         hir::NoReturn(..) => ty::FnDiverging\n     };"}, {"sha": "6ca48f2d8d484c9c0a42573c0a3998ed8e3aa7cb", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=f831d98ba2167ac19966618bfb218856e1eedc63", "patch": "@@ -50,8 +50,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             fcx.write_ty(pat.id, expected);\n         }\n         hir::PatLit(ref lt) => {\n-            check_expr(fcx, &**lt);\n-            let expr_ty = fcx.expr_ty(&**lt);\n+            check_expr(fcx, &lt);\n+            let expr_ty = fcx.expr_ty(&lt);\n \n             // Byte string patterns behave the same way as array patterns\n             // They can denote both statically and dynamically sized byte arrays\n@@ -198,7 +198,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 }\n \n                 if let Some(ref p) = *sub {\n-                    check_pat(pcx, &**p, expected);\n+                    check_pat(pcx, &p, expected);\n                 }\n             }\n         }\n@@ -259,28 +259,28 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             fcx.write_ty(pat.id, pat_ty);\n             demand::eqtype(fcx, pat.span, expected, pat_ty);\n             for (element_pat, element_ty) in elements.iter().zip(element_tys) {\n-                check_pat(pcx, &**element_pat, element_ty);\n+                check_pat(pcx, &element_pat, element_ty);\n             }\n         }\n         hir::PatBox(ref inner) => {\n             let inner_ty = fcx.infcx().next_ty_var();\n             let uniq_ty = tcx.mk_box(inner_ty);\n \n-            if check_dereferencable(pcx, pat.span, expected, &**inner) {\n+            if check_dereferencable(pcx, pat.span, expected, &inner) {\n                 // Here, `demand::subtype` is good enough, but I don't\n                 // think any errors can be introduced by using\n                 // `demand::eqtype`.\n                 demand::eqtype(fcx, pat.span, expected, uniq_ty);\n                 fcx.write_ty(pat.id, uniq_ty);\n-                check_pat(pcx, &**inner, inner_ty);\n+                check_pat(pcx, &inner, inner_ty);\n             } else {\n                 fcx.write_error(pat.id);\n-                check_pat(pcx, &**inner, tcx.types.err);\n+                check_pat(pcx, &inner, tcx.types.err);\n             }\n         }\n         hir::PatRegion(ref inner, mutbl) => {\n             let expected = fcx.infcx().shallow_resolve(expected);\n-            if check_dereferencable(pcx, pat.span, expected, &**inner) {\n+            if check_dereferencable(pcx, pat.span, expected, &inner) {\n                 // `demand::subtype` would be good enough, but using\n                 // `eqtype` turns out to be equally general. See (*)\n                 // below for details.\n@@ -304,10 +304,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 };\n \n                 fcx.write_ty(pat.id, rptr_ty);\n-                check_pat(pcx, &**inner, inner_ty);\n+                check_pat(pcx, &inner, inner_ty);\n             } else {\n                 fcx.write_error(pat.id);\n-                check_pat(pcx, &**inner, tcx.types.err);\n+                check_pat(pcx, &inner, tcx.types.err);\n             }\n         }\n         hir::PatVec(ref before, ref slice, ref after) => {\n@@ -339,7 +339,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n             for elt in before {\n-                check_pat(pcx, &**elt, inner_ty);\n+                check_pat(pcx, &elt, inner_ty);\n             }\n             if let Some(ref slice) = *slice {\n                 let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n@@ -350,10 +350,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     ty: tcx.mk_slice(inner_ty),\n                     mutbl: mutbl\n                 });\n-                check_pat(pcx, &**slice, slice_ty);\n+                check_pat(pcx, &slice, slice_ty);\n             }\n             for elt in after {\n-                check_pat(pcx, &**elt, inner_ty);\n+                check_pat(pcx, &elt, inner_ty);\n             }\n         }\n     }\n@@ -482,10 +482,10 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     for arm in arms {\n         let mut pcx = pat_ctxt {\n             fcx: fcx,\n-            map: pat_id_map(&tcx.def_map, &*arm.pats[0]),\n+            map: pat_id_map(&tcx.def_map, &arm.pats[0]),\n         };\n         for p in &arm.pats {\n-            check_pat(&mut pcx, &**p, discrim_ty);\n+            check_pat(&mut pcx, &p, discrim_ty);\n         }\n     }\n \n@@ -507,17 +507,17 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // arm for inconsistent arms or to the whole match when a `()` type\n             // is required).\n             Expectation::ExpectHasType(ety) if ety != fcx.tcx().mk_nil() => {\n-                check_expr_coercable_to_type(fcx, &*arm.body, ety);\n+                check_expr_coercable_to_type(fcx, &arm.body, ety);\n                 ety\n             }\n             _ => {\n-                check_expr_with_expectation(fcx, &*arm.body, expected);\n+                check_expr_with_expectation(fcx, &arm.body, expected);\n                 fcx.node_ty(arm.body.id)\n             }\n         };\n \n         if let Some(ref e) = arm.guard {\n-            check_expr_has_type(fcx, &**e, tcx.types.bool);\n+            check_expr_has_type(fcx, &e, tcx.types.bool);\n         }\n \n         if result_ty.references_error() || bty.references_error() {\n@@ -622,7 +622,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             if let Some(subpats) = subpats {\n                 for pat in subpats {\n-                    check_pat(pcx, &**pat, tcx.types.err);\n+                    check_pat(pcx, &pat, tcx.types.err);\n                 }\n             }\n \n@@ -670,7 +670,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         fcx.write_error(pat.id);\n         if let Some(subpats) = subpats {\n             for pat in subpats {\n-                check_pat(pcx, &**pat, tcx.types.err);\n+                check_pat(pcx, &pat, tcx.types.err);\n             }\n         }\n     };\n@@ -742,15 +742,15 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     if let Some(subpats) = subpats {\n         if subpats.len() == arg_tys.len() {\n             for (subpat, arg_ty) in subpats.iter().zip(arg_tys) {\n-                check_pat(pcx, &**subpat, arg_ty);\n+                check_pat(pcx, &subpat, arg_ty);\n             }\n         } else if arg_tys.is_empty() {\n             span_err!(tcx.sess, pat.span, E0024,\n                       \"this pattern has {} field{}, but the corresponding {} has no fields\",\n                       subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"}, kind_name);\n \n             for pat in subpats {\n-                check_pat(pcx, &**pat, tcx.types.err);\n+                check_pat(pcx, &pat, tcx.types.err);\n             }\n         } else {\n             span_err!(tcx.sess, pat.span, E0023,\n@@ -760,7 +760,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                       arg_tys.len(), if arg_tys.len() == 1 {\"\"} else {\"s\"});\n \n             for pat in subpats {\n-                check_pat(pcx, &**pat, tcx.types.err);\n+                check_pat(pcx, &pat, tcx.types.err);\n             }\n         }\n     }\n@@ -815,7 +815,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             }\n         };\n \n-        check_pat(pcx, &*field.pat, field_ty);\n+        check_pat(pcx, &field.pat, field_ty);\n     }\n \n     // Report an error if not all the fields were specified."}, {"sha": "42ea3cc2aaa7ba1d72537b25badfe7d7f90d4819", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=f831d98ba2167ac19966618bfb218856e1eedc63", "patch": "@@ -199,7 +199,7 @@ fn try_overloaded_call_traits<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         match method::lookup_in_trait_adjusted(fcx,\n                                                call_expr.span,\n-                                               Some(&*callee_expr),\n+                                               Some(&callee_expr),\n                                                method_name,\n                                                trait_def_id,\n                                                autoderefs,\n@@ -304,12 +304,12 @@ fn confirm_deferred_closure_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                    call_expr.span,\n                                    expected,\n                                    fn_sig.output.clone(),\n-                                   &*fn_sig.inputs);\n+                                   &fn_sig.inputs);\n \n     check_argument_types(fcx,\n                          call_expr.span,\n-                         &*fn_sig.inputs,\n-                         &*expected_arg_tys,\n+                         &fn_sig.inputs,\n+                         &expected_arg_tys,\n                          arg_exprs,\n                          fn_sig.variadic,\n                          TupleArgumentsFlag::TupleArguments);"}, {"sha": "d3e66bde4f4c38ce66aa968b367111b39e215fa8", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=f831d98ba2167ac19966618bfb218856e1eedc63", "patch": "@@ -83,7 +83,7 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n              &fn_sig,\n              decl,\n              expr.id,\n-             &*body,\n+             &body,\n              fcx.inh);\n \n     // Tuple up the arguments and insert the resulting function type into"}, {"sha": "bf08989bc0a1275654c00309f058212285a38d9b", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=f831d98ba2167ac19966618bfb218856e1eedc63", "patch": "@@ -269,7 +269,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             probe::WhereClausePick(ref poly_trait_ref) => {\n                 // Where clauses can have bound regions in them. We need to instantiate\n                 // those to convert from a poly-trait-ref to a trait-ref.\n-                self.replace_late_bound_regions_with_fresh_var(&*poly_trait_ref).substs.clone()\n+                self.replace_late_bound_regions_with_fresh_var(&poly_trait_ref).substs.clone()\n             }\n         }\n     }\n@@ -290,7 +290,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                               NoPreference,\n                                               |ty, _| {\n             match ty.sty {\n-                ty::TyTrait(ref data) => Some(closure(self, ty, &**data)),\n+                ty::TyTrait(ref data) => Some(closure(self, ty, &data)),\n                 _ => None,\n             }\n         });\n@@ -478,7 +478,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 hir::ExprField(ref expr, _) |\n                 hir::ExprTupField(ref expr, _) |\n                 hir::ExprIndex(ref expr, _) |\n-                hir::ExprUnary(hir::UnDeref, ref expr) => exprs.push(&**expr),\n+                hir::ExprUnary(hir::UnDeref, ref expr) => exprs.push(&expr),\n                 _ => break,\n             }\n         }\n@@ -570,13 +570,13 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                     unsize: None\n                                 }))), false)\n                         };\n-                        let index_expr_ty = self.fcx.expr_ty(&**index_expr);\n+                        let index_expr_ty = self.fcx.expr_ty(&index_expr);\n \n                         let result = check::try_index_step(\n                             self.fcx,\n                             ty::MethodCall::expr(expr.id),\n                             expr,\n-                            &**base_expr,\n+                            &base_expr,\n                             adjusted_base_ty,\n                             autoderefs,\n                             unsize,\n@@ -586,7 +586,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         if let Some((input_ty, return_ty)) = result {\n                             demand::suptype(self.fcx, index_expr.span, input_ty, index_expr_ty);\n \n-                            let expr_ty = self.fcx.expr_ty(&*expr);\n+                            let expr_ty = self.fcx.expr_ty(&expr);\n                             demand::suptype(self.fcx, expr.span, expr_ty, return_ty);\n                         }\n                     }\n@@ -599,8 +599,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                 self.fcx,\n                                 expr.span,\n                                 Some(method_call),\n-                                Some(&**base_expr),\n-                                self.fcx.expr_ty(&**base_expr),\n+                                Some(&base_expr),\n+                                self.fcx.expr_ty(&base_expr),\n                                 PreferMutLvalue);\n                         }\n                     }"}, {"sha": "1367db16314e2f53e3cbae16406546d320b5d5af", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f831d98ba2167ac19966618bfb218856e1eedc63", "patch": "@@ -271,7 +271,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         for (i, trait_did) in candidates.iter().enumerate() {\n             err.fileline_help(span,\n-                              &*format!(\"candidate #{}: use `{}`\",\n+                              &format!(\"candidate #{}: use `{}`\",\n                                         i + 1,\n                                         fcx.tcx().item_path_str(*trait_did)));\n         }\n@@ -316,7 +316,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         for (i, trait_info) in candidates.iter().enumerate() {\n             err.fileline_help(span,\n-                              &*format!(\"candidate #{}: `{}`\",\n+                              &format!(\"candidate #{}: `{}`\",\n                                         i + 1,\n                                         fcx.tcx().item_path_str(trait_info.def_id)));\n         }"}, {"sha": "e485bdd66fc9f265ca8f27fb9511eedbb480380d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f831d98ba2167ac19966618bfb218856e1eedc63", "patch": "@@ -368,7 +368,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         match t.node {\n             hir::TyFixedLengthVec(_, ref expr) => {\n-                check_const_in_type(self.ccx, &**expr, self.ccx.tcx.types.usize);\n+                check_const_in_type(self.ccx, &expr, self.ccx.tcx.types.usize);\n             }\n             _ => {}\n         }\n@@ -491,7 +491,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &'tcx hir::Local) {\n         let o_ty = match local.ty {\n-            Some(ref ty) => Some(self.fcx.to_ty(&**ty)),\n+            Some(ref ty) => Some(self.fcx.to_ty(&ty)),\n             None => None\n         };\n         self.assign(local.span, local.id, o_ty);\n@@ -533,8 +533,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         match t.node {\n             hir::TyFixedLengthVec(ref ty, ref count_expr) => {\n-                self.visit_ty(&**ty);\n-                check_expr_with_hint(self.fcx, &**count_expr, self.fcx.tcx().types.usize);\n+                self.visit_ty(&ty);\n+                check_expr_with_hint(self.fcx, &count_expr, self.fcx.tcx().types.usize);\n             }\n             hir::TyBareFn(ref function_declaration) => {\n                 intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n@@ -612,7 +612,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n             // Create type variables for each argument.\n             pat_util::pat_bindings(\n                 &tcx.def_map,\n-                &*input.pat,\n+                &input.pat,\n                 |_bm, pat_id, sp, _path| {\n                     let var_ty = visit.assign(sp, pat_id, None);\n                     fcx.require_type_is_sized(var_ty, sp,\n@@ -622,9 +622,9 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n             // Check the pattern.\n             let pcx = pat_ctxt {\n                 fcx: &fcx,\n-                map: pat_id_map(&tcx.def_map, &*input.pat),\n+                map: pat_id_map(&tcx.def_map, &input.pat),\n             };\n-            _match::check_pat(&pcx, &*input.pat, *arg_ty);\n+            _match::check_pat(&pcx, &input.pat, *arg_ty);\n         }\n \n         visit.visit_block(body);\n@@ -660,7 +660,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n       hir::ItemStatic(_, _, ref e) |\n-      hir::ItemConst(_, ref e) => check_const(ccx, it.span, &**e, it.id),\n+      hir::ItemConst(_, ref e) => check_const(ccx, it.span, &e, it.id),\n       hir::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n@@ -730,7 +730,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       hir::ItemFn(ref decl, _, _, _, _, ref body) => {\n         let fn_pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(it.id));\n         let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n-        check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n+        check_bare_fn(ccx, &decl, &body, it.id, it.span, fn_pty.ty, param_env);\n       }\n       hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n         debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n@@ -740,7 +740,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         for impl_item in impl_items {\n             match impl_item.node {\n                 hir::ImplItemKind::Const(_, ref expr) => {\n-                    check_const(ccx, impl_item.span, &*expr, impl_item.id)\n+                    check_const(ccx, impl_item.span, &expr, impl_item.id)\n                 }\n                 hir::ImplItemKind::Method(ref sig, ref body) => {\n                     check_method_body(ccx, &impl_pty.generics, sig, body,\n@@ -757,7 +757,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         for trait_item in trait_items {\n             match trait_item.node {\n                 hir::ConstTraitItem(_, Some(ref expr)) => {\n-                    check_const(ccx, trait_item.span, &*expr, trait_item.id)\n+                    check_const(ccx, trait_item.span, &expr, trait_item.id)\n                 }\n                 hir::MethodTraitItem(ref sig, Some(ref body)) => {\n                     check_trait_fn_not_const(ccx, trait_item.span, sig.constness);\n@@ -801,7 +801,7 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }) {\n         if let Some(ref istring) = attr.value_str() {\n             let parser = Parser::new(&istring);\n-            let types = &*generics.ty_params;\n+            let types = &generics.ty_params;\n             for token in parser {\n                 match token {\n                     Piece::String(_) => (), // Normal string, no need to check it\n@@ -890,7 +890,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            &impl_const,\n                                            impl_item.span,\n                                            trait_const,\n-                                           &*impl_trait_ref);\n+                                           &impl_trait_ref);\n                     } else {\n                         span_err!(tcx.sess, impl_item.span, E0323,\n                                   \"item `{}` is an associated const, \\\n@@ -2279,7 +2279,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         (PreferMutLvalue, Some(trait_did)) => {\n             method::lookup_in_trait_adjusted(fcx,\n                                              expr.span,\n-                                             Some(&*base_expr),\n+                                             Some(&base_expr),\n                                              token::intern(\"index_mut\"),\n                                              trait_did,\n                                              autoderefs,\n@@ -2295,7 +2295,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         (None, Some(trait_did)) => {\n             method::lookup_in_trait_adjusted(fcx,\n                                              expr.span,\n-                                             Some(&*base_expr),\n+                                             Some(&base_expr),\n                                              token::intern(\"index\"),\n                                              trait_did,\n                                              autoderefs,\n@@ -2409,7 +2409,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 } else {\n                     expected_arg_tys = match expected_arg_tys.get(0) {\n                         Some(&ty) => match ty.sty {\n-                            ty::TyTuple(ref tys) => &**tys,\n+                            ty::TyTuple(ref tys) => &tys,\n                             _ => &[]\n                         },\n                         None => &[]\n@@ -2512,14 +2512,14 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 });\n \n                 check_expr_with_unifier(fcx,\n-                                        &**arg,\n+                                        &arg,\n                                         expected.unwrap_or(ExpectHasType(formal_ty)),\n                                         NoPreference, || {\n                     // 2. Coerce to the most detailed type that could be coerced\n                     //    to, which is `expected_ty` if `rvalue_hint` returns an\n                     //    `ExprHasType(expected_ty)`, or the `formal_ty` otherwise.\n                     let coerce_ty = expected.and_then(|e| e.only_has_type(fcx));\n-                    demand::coerce(fcx, arg.span, coerce_ty.unwrap_or(formal_ty), &**arg);\n+                    demand::coerce(fcx, arg.span, coerce_ty.unwrap_or(formal_ty), &arg);\n \n                     // 3. Relate the expected type and the formal one,\n                     //    if the expected type was used for the coercion.\n@@ -2549,12 +2549,12 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // arguments which we skipped above.\n     if variadic {\n         for arg in args.iter().skip(expected_arg_count) {\n-            check_expr(fcx, &**arg);\n+            check_expr(fcx, &arg);\n \n             // There are a few types which get autopromoted when passed via varargs\n             // in C but we just error out instead and require explicit casts.\n             let arg_ty = structurally_resolved_type(fcx, arg.span,\n-                                                    fcx.expr_ty(&**arg));\n+                                                    fcx.expr_ty(&arg));\n             match arg_ty.sty {\n                 ty::TyFloat(ast::FloatTy::F32) => {\n                     fcx.type_error_message(arg.span,\n@@ -2816,15 +2816,15 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                    tps: &[P<hir::Ty>],\n                                    expected: Expectation<'tcx>,\n                                    lvalue_pref: LvaluePreference) {\n-        let rcvr = &*args[0];\n-        check_expr_with_lvalue_pref(fcx, &*rcvr, lvalue_pref);\n+        let rcvr = &args[0];\n+        check_expr_with_lvalue_pref(fcx, &rcvr, lvalue_pref);\n \n         // no need to check for bot/err -- callee does that\n         let expr_t = structurally_resolved_type(fcx,\n                                                 expr.span,\n-                                                fcx.expr_ty(&*rcvr));\n+                                                fcx.expr_ty(&rcvr));\n \n-        let tps = tps.iter().map(|ast_ty| fcx.to_ty(&**ast_ty)).collect::<Vec<_>>();\n+        let tps = tps.iter().map(|ast_ty| fcx.to_ty(&ast_ty)).collect::<Vec<_>>();\n         let fn_ty = match method::lookup(fcx,\n                                          method_name.span,\n                                          method_name.node,\n@@ -2877,8 +2877,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let branches_ty = match opt_else_expr {\n             Some(ref else_expr) => {\n-                check_expr_with_expectation(fcx, &**else_expr, expected);\n-                let else_ty = fcx.expr_ty(&**else_expr);\n+                check_expr_with_expectation(fcx, &else_expr, expected);\n+                let else_ty = fcx.expr_ty(&else_expr);\n                 infer::common_supertype(fcx.infcx(),\n                                         TypeOrigin::IfExpression(sp),\n                                         true,\n@@ -3128,7 +3128,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n             // Make sure to give a type to the field even if there's\n             // an error, so we can continue typechecking\n-            check_expr_coercable_to_type(fcx, &*field.expr, expected_field_type);\n+            check_expr_coercable_to_type(fcx, &field.expr, expected_field_type);\n         }\n \n             // Make sure the programmer specified all the fields.\n@@ -3156,10 +3156,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // otherwise we might ICE\n         fcx.write_error(id);\n         for field in fields {\n-            check_expr(fcx, &*field.expr);\n+            check_expr(fcx, &field.expr);\n         }\n         match *base_expr {\n-            Some(ref base) => check_expr(fcx, &**base),\n+            Some(ref base) => check_expr(fcx, &base),\n             None => {}\n         }\n     }\n@@ -3217,12 +3217,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         });\n         check_expr_with_expectation(fcx, subexpr, expected_inner);\n-        let referent_ty = fcx.expr_ty(&**subexpr);\n+        let referent_ty = fcx.expr_ty(&subexpr);\n         fcx.write_ty(id, tcx.mk_box(referent_ty));\n       }\n \n       hir::ExprLit(ref lit) => {\n-        let typ = check_lit(fcx, &**lit, expected);\n+        let typ = check_lit(fcx, &lit, expected);\n         fcx.write_ty(id, typ);\n       }\n       hir::ExprBinary(op, ref lhs, ref rhs) => {\n@@ -3245,8 +3245,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             _ => NoPreference\n         };\n         check_expr_with_expectation_and_lvalue_pref(\n-            fcx, &**oprnd, expected_inner, lvalue_pref);\n-        let mut oprnd_t = fcx.expr_ty(&**oprnd);\n+            fcx, &oprnd, expected_inner, lvalue_pref);\n+        let mut oprnd_t = fcx.expr_ty(&oprnd);\n \n         if !oprnd_t.references_error() {\n             match unop {\n@@ -3256,7 +3256,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         Some(mt) => mt.ty,\n                         None => match try_overloaded_deref(fcx, expr.span,\n                                                            Some(MethodCall::expr(expr.id)),\n-                                                           Some(&**oprnd), oprnd_t, lvalue_pref) {\n+                                                           Some(&oprnd), oprnd_t, lvalue_pref) {\n                             Some(mt) => mt.ty,\n                             None => {\n                                 fcx.type_error_message(expr.span, |actual| {\n@@ -3274,7 +3274,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     if !(oprnd_t.is_integral() || oprnd_t.sty == ty::TyBool) {\n                         oprnd_t = op::check_user_unop(fcx, \"!\", \"not\",\n                                                       tcx.lang_items.not_trait(),\n-                                                      expr, &**oprnd, oprnd_t, unop);\n+                                                      expr, &oprnd, oprnd_t, unop);\n                     }\n                 }\n                 hir::UnNeg => {\n@@ -3283,7 +3283,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     if !(oprnd_t.is_integral() || oprnd_t.is_fp()) {\n                         oprnd_t = op::check_user_unop(fcx, \"-\", \"neg\",\n                                                       tcx.lang_items.neg_trait(),\n-                                                      expr, &**oprnd, oprnd_t, unop);\n+                                                      expr, &oprnd, oprnd_t, unop);\n                     }\n                 }\n             }\n@@ -3294,7 +3294,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let hint = expected.only_has_type(fcx).map_or(NoExpectation, |ty| {\n             match ty.sty {\n                 ty::TyRef(_, ref mt) | ty::TyRawPtr(ref mt) => {\n-                    if fcx.tcx().expr_is_lval(&**oprnd) {\n+                    if fcx.tcx().expr_is_lval(&oprnd) {\n                         // Lvalues may legitimately have unsized types.\n                         // For example, dereferences of a fat pointer and\n                         // the last field of a struct can be unsized.\n@@ -3308,11 +3308,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         });\n         let lvalue_pref = LvaluePreference::from_mutbl(mutbl);\n         check_expr_with_expectation_and_lvalue_pref(fcx,\n-                                                    &**oprnd,\n+                                                    &oprnd,\n                                                     hint,\n                                                     lvalue_pref);\n \n-        let tm = ty::TypeAndMut { ty: fcx.expr_ty(&**oprnd), mutbl: mutbl };\n+        let tm = ty::TypeAndMut { ty: fcx.expr_ty(&oprnd), mutbl: mutbl };\n         let oprnd_t = if tm.ty.references_error() {\n             tcx.types.err\n         } else {\n@@ -3381,10 +3381,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       hir::ExprInlineAsm(ref ia) => {\n           for &(_, ref input) in &ia.inputs {\n-              check_expr(fcx, &**input);\n+              check_expr(fcx, &input);\n           }\n           for out in &ia.outputs {\n-              check_expr(fcx, &*out.expr);\n+              check_expr(fcx, &out.expr);\n           }\n           fcx.write_nil(id);\n       }\n@@ -3402,13 +3402,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  not `()`\");\n                         },\n                     Some(ref e) => {\n-                        check_expr_coercable_to_type(fcx, &**e, result_type);\n+                        check_expr_coercable_to_type(fcx, &e, result_type);\n                     }\n                 }\n             }\n             ty::FnDiverging => {\n                 if let Some(ref e) = *expr_opt {\n-                    check_expr(fcx, &**e);\n+                    check_expr(fcx, &e);\n                 }\n                 span_err!(tcx.sess, expr.span, E0166,\n                     \"`return` in a function declared as diverging\");\n@@ -3417,19 +3417,19 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, fcx.infcx().next_diverging_ty_var());\n       }\n       hir::ExprAssign(ref lhs, ref rhs) => {\n-        check_expr_with_lvalue_pref(fcx, &**lhs, PreferMutLvalue);\n+        check_expr_with_lvalue_pref(fcx, &lhs, PreferMutLvalue);\n \n         let tcx = fcx.tcx();\n-        if !tcx.expr_is_lval(&**lhs) {\n+        if !tcx.expr_is_lval(&lhs) {\n             span_err!(tcx.sess, expr.span, E0070,\n                 \"invalid left-hand side expression\");\n         }\n \n-        let lhs_ty = fcx.expr_ty(&**lhs);\n-        check_expr_coercable_to_type(fcx, &**rhs, lhs_ty);\n-        let rhs_ty = fcx.expr_ty(&**rhs);\n+        let lhs_ty = fcx.expr_ty(&lhs);\n+        check_expr_coercable_to_type(fcx, &rhs, lhs_ty);\n+        let rhs_ty = fcx.expr_ty(&rhs);\n \n-        fcx.require_expr_have_sized_type(&**lhs, traits::AssignmentLhsSized);\n+        fcx.require_expr_have_sized_type(&lhs, traits::AssignmentLhsSized);\n \n         if lhs_ty.references_error() || rhs_ty.references_error() {\n             fcx.write_error(id);\n@@ -3438,13 +3438,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       hir::ExprIf(ref cond, ref then_blk, ref opt_else_expr) => {\n-        check_then_else(fcx, &**cond, &**then_blk, opt_else_expr.as_ref().map(|e| &**e),\n+        check_then_else(fcx, &cond, &then_blk, opt_else_expr.as_ref().map(|e| &**e),\n                         id, expr.span, expected);\n       }\n       hir::ExprWhile(ref cond, ref body, _) => {\n-        check_expr_has_type(fcx, &**cond, tcx.types.bool);\n-        check_block_no_value(fcx, &**body);\n-        let cond_ty = fcx.expr_ty(&**cond);\n+        check_expr_has_type(fcx, &cond, tcx.types.bool);\n+        check_block_no_value(fcx, &body);\n+        let cond_ty = fcx.expr_ty(&cond);\n         let body_ty = fcx.node_ty(body.id);\n         if cond_ty.references_error() || body_ty.references_error() {\n             fcx.write_error(id);\n@@ -3454,41 +3454,41 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       hir::ExprLoop(ref body, _) => {\n-        check_block_no_value(fcx, &**body);\n-        if !may_break(tcx, expr.id, &**body) {\n+        check_block_no_value(fcx, &body);\n+        if !may_break(tcx, expr.id, &body) {\n             fcx.write_ty(id, fcx.infcx().next_diverging_ty_var());\n         } else {\n             fcx.write_nil(id);\n         }\n       }\n       hir::ExprMatch(ref discrim, ref arms, match_src) => {\n-        _match::check_match(fcx, expr, &**discrim, arms, expected, match_src);\n+        _match::check_match(fcx, expr, &discrim, arms, expected, match_src);\n       }\n       hir::ExprClosure(capture, ref decl, ref body) => {\n-          closure::check_expr_closure(fcx, expr, capture, &**decl, &**body, expected);\n+          closure::check_expr_closure(fcx, expr, capture, &decl, &body, expected);\n       }\n       hir::ExprBlock(ref b) => {\n-        check_block_with_expected(fcx, &**b, expected);\n+        check_block_with_expected(fcx, &b, expected);\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n       hir::ExprCall(ref callee, ref args) => {\n-          callee::check_call(fcx, expr, &**callee, &args[..], expected);\n+          callee::check_call(fcx, expr, &callee, &args[..], expected);\n \n           // we must check that return type of called functions is WF:\n           let ret_ty = fcx.expr_ty(expr);\n           fcx.register_wf_obligation(ret_ty, expr.span, traits::MiscObligation);\n       }\n       hir::ExprMethodCall(name, ref tps, ref args) => {\n           check_method_call(fcx, expr, name, &args[..], &tps[..], expected, lvalue_pref);\n-          let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n+          let arg_tys = args.iter().map(|a| fcx.expr_ty(&a));\n           let args_err = arg_tys.fold(false, |rest_err, a| rest_err || a.references_error());\n           if args_err {\n               fcx.write_error(id);\n           }\n       }\n       hir::ExprCast(ref e, ref t) => {\n         if let hir::TyFixedLengthVec(_, ref count_expr) = t.node {\n-            check_expr_with_hint(fcx, &**count_expr, tcx.types.usize);\n+            check_expr_with_hint(fcx, &count_expr, tcx.types.usize);\n         }\n \n         // Find the type of `e`. Supply hints based on the type we are casting to,\n@@ -3516,8 +3516,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       hir::ExprType(ref e, ref t) => {\n-        let typ = fcx.to_ty(&**t);\n-        check_expr_eq_type(fcx, &**e, typ);\n+        let typ = fcx.to_ty(&t);\n+        check_expr_eq_type(fcx, &e, typ);\n         fcx.write_ty(id, typ);\n       }\n       hir::ExprVec(ref args) => {\n@@ -3531,14 +3531,14 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let typ = match uty {\n             Some(uty) => {\n                 for e in args {\n-                    check_expr_coercable_to_type(fcx, &**e, uty);\n+                    check_expr_coercable_to_type(fcx, &e, uty);\n                 }\n                 uty\n             }\n             None => {\n                 let t: Ty = fcx.infcx().next_ty_var();\n                 for e in args {\n-                    check_expr_has_type(fcx, &**e, t);\n+                    check_expr_has_type(fcx, &e, t);\n                 }\n                 t\n             }\n@@ -3547,8 +3547,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, typ);\n       }\n       hir::ExprRepeat(ref element, ref count_expr) => {\n-        check_expr_has_type(fcx, &**count_expr, tcx.types.usize);\n-        let count = fcx.tcx().eval_repeat_count(&**count_expr);\n+        check_expr_has_type(fcx, &count_expr, tcx.types.usize);\n+        let count = fcx.tcx().eval_repeat_count(&count_expr);\n \n         let uty = match expected {\n             ExpectHasType(uty) => {\n@@ -3562,13 +3562,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let (element_ty, t) = match uty {\n             Some(uty) => {\n-                check_expr_coercable_to_type(fcx, &**element, uty);\n+                check_expr_coercable_to_type(fcx, &element, uty);\n                 (uty, uty)\n             }\n             None => {\n                 let t: Ty = fcx.infcx().next_ty_var();\n-                check_expr_has_type(fcx, &**element, t);\n-                (fcx.expr_ty(&**element), t)\n+                check_expr_has_type(fcx, &element, t);\n+                (fcx.expr_ty(&element), t)\n             }\n         };\n \n@@ -3602,12 +3602,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             let t = match flds {\n                 Some(ref fs) if i < fs.len() => {\n                     let ety = fs[i];\n-                    check_expr_coercable_to_type(fcx, &**e, ety);\n+                    check_expr_coercable_to_type(fcx, &e, ety);\n                     ety\n                 }\n                 _ => {\n-                    check_expr_with_expectation(fcx, &**e, NoExpectation);\n-                    fcx.expr_ty(&**e)\n+                    check_expr_with_expectation(fcx, &e, NoExpectation);\n+                    fcx.expr_ty(&e)\n                 }\n             };\n             err_field = err_field || t.references_error();\n@@ -3626,17 +3626,17 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.require_expr_have_sized_type(expr, traits::StructInitializerSized);\n       }\n       hir::ExprField(ref base, ref field) => {\n-        check_field(fcx, expr, lvalue_pref, &**base, field);\n+        check_field(fcx, expr, lvalue_pref, &base, field);\n       }\n       hir::ExprTupField(ref base, idx) => {\n-        check_tup_field(fcx, expr, lvalue_pref, &**base, idx);\n+        check_tup_field(fcx, expr, lvalue_pref, &base, idx);\n       }\n       hir::ExprIndex(ref base, ref idx) => {\n-          check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n-          check_expr(fcx, &**idx);\n+          check_expr_with_lvalue_pref(fcx, &base, lvalue_pref);\n+          check_expr(fcx, &idx);\n \n-          let base_t = fcx.expr_ty(&**base);\n-          let idx_t = fcx.expr_ty(&**idx);\n+          let base_t = fcx.expr_ty(&base);\n+          let idx_t = fcx.expr_ty(&idx);\n \n           if base_t.references_error() {\n               fcx.write_ty(id, base_t);\n@@ -3651,7 +3651,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                       fcx.write_ty(id, element_ty);\n                   }\n                   None => {\n-                      check_expr_has_type(fcx, &**idx, fcx.tcx().types.err);\n+                      check_expr_has_type(fcx, &idx, fcx.tcx().types.err);\n                       fcx.type_error_message(\n                           expr.span,\n                           |actual| {\n@@ -3667,12 +3667,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n        }\n        hir::ExprRange(ref start, ref end) => {\n           let t_start = start.as_ref().map(|e| {\n-            check_expr(fcx, &**e);\n-            fcx.expr_ty(&**e)\n+            check_expr(fcx, &e);\n+            fcx.expr_ty(&e)\n           });\n           let t_end = end.as_ref().map(|e| {\n-            check_expr(fcx, &**e);\n-            fcx.expr_ty(&**e)\n+            check_expr(fcx, &e);\n+            fcx.expr_ty(&e)\n           });\n \n           let idx_type = match (t_start, t_end) {\n@@ -3905,18 +3905,18 @@ pub fn check_decl_local<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, local: &'tcx hir::Local)\n     fcx.write_ty(local.id, t);\n \n     if let Some(ref init) = local.init {\n-        check_decl_initializer(fcx, local, &**init);\n-        let init_ty = fcx.expr_ty(&**init);\n+        check_decl_initializer(fcx, local, &init);\n+        let init_ty = fcx.expr_ty(&init);\n         if init_ty.references_error() {\n             fcx.write_ty(local.id, init_ty);\n         }\n     }\n \n     let pcx = pat_ctxt {\n         fcx: fcx,\n-        map: pat_id_map(&tcx.def_map, &*local.pat),\n+        map: pat_id_map(&tcx.def_map, &local.pat),\n     };\n-    _match::check_pat(&pcx, &*local.pat, t);\n+    _match::check_pat(&pcx, &local.pat, t);\n     let pat_ty = fcx.node_ty(local.pat.id);\n     if pat_ty.references_error() {\n         fcx.write_ty(local.id, pat_ty);\n@@ -3932,7 +3932,7 @@ pub fn check_stmt<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, stmt: &'tcx hir::Stmt)  {\n         node_id = id;\n         match decl.node {\n           hir::DeclLocal(ref l) => {\n-              check_decl_local(fcx, &**l);\n+              check_decl_local(fcx, &l);\n               let l_t = fcx.node_ty(l.id);\n               saw_bot = saw_bot || fcx.infcx().type_var_diverges(l_t);\n               saw_err = saw_err || l_t.references_error();\n@@ -3943,15 +3943,15 @@ pub fn check_stmt<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, stmt: &'tcx hir::Stmt)  {\n       hir::StmtExpr(ref expr, id) => {\n         node_id = id;\n         // Check with expected type of ()\n-        check_expr_has_type(fcx, &**expr, fcx.tcx().mk_nil());\n-        let expr_ty = fcx.expr_ty(&**expr);\n+        check_expr_has_type(fcx, &expr, fcx.tcx().mk_nil());\n+        let expr_ty = fcx.expr_ty(&expr);\n         saw_bot = saw_bot || fcx.infcx().type_var_diverges(expr_ty);\n         saw_err = saw_err || expr_ty.references_error();\n       }\n       hir::StmtSemi(ref expr, id) => {\n         node_id = id;\n-        check_expr(fcx, &**expr);\n-        let expr_ty = fcx.expr_ty(&**expr);\n+        check_expr(fcx, &expr);\n+        let expr_ty = fcx.expr_ty(&expr);\n         saw_bot |= fcx.infcx().type_var_diverges(expr_ty);\n         saw_err |= expr_ty.references_error();\n       }\n@@ -4035,12 +4035,12 @@ fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n             let ety = match expected {\n                 ExpectHasType(ety) => {\n-                    check_expr_coercable_to_type(fcx, &**e, ety);\n+                    check_expr_coercable_to_type(fcx, &e, ety);\n                     ety\n                 }\n                 _ => {\n-                    check_expr_with_expectation(fcx, &**e, expected);\n-                    fcx.expr_ty(&**e)\n+                    check_expr_with_expectation(fcx, &e, expected);\n+                    fcx.expr_ty(&e)\n                 }\n             };\n \n@@ -4608,7 +4608,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let type_count = type_defs.len(space);\n             assert_eq!(substs.types.len(space), 0);\n             for (i, typ) in data.types.iter().enumerate() {\n-                let t = fcx.to_ty(&**typ);\n+                let t = fcx.to_ty(&typ);\n                 if i < type_count {\n                     substs.types.push(space, t);\n                 } else if i == type_count {\n@@ -4677,7 +4677,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         let input_tys: Vec<Ty> =\n-            data.inputs.iter().map(|ty| fcx.to_ty(&**ty)).collect();\n+            data.inputs.iter().map(|ty| fcx.to_ty(&ty)).collect();\n \n         let tuple_ty = fcx.tcx().mk_tup(input_tys);\n \n@@ -4686,7 +4686,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         let output_ty: Option<Ty> =\n-            data.output.as_ref().map(|ty| fcx.to_ty(&**ty));\n+            data.output.as_ref().map(|ty| fcx.to_ty(&ty));\n \n         let output_ty =\n             output_ty.unwrap_or(fcx.tcx().mk_nil());\n@@ -4848,7 +4848,7 @@ pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &hir::Block) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n-    (loop_query(&*b, |e| {\n+    (loop_query(&b, |e| {\n         match *e {\n             hir::ExprBreak(None) => true,\n             _ => false"}, {"sha": "1ee0542f633372c405d6e6f1b5b94c70bd868e13", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=f831d98ba2167ac19966618bfb218856e1eedc63", "patch": "@@ -489,15 +489,15 @@ fn visit_block(rcx: &mut Rcx, b: &hir::Block) {\n fn visit_arm(rcx: &mut Rcx, arm: &hir::Arm) {\n     // see above\n     for p in &arm.pats {\n-        constrain_bindings_in_pat(&**p, rcx);\n+        constrain_bindings_in_pat(&p, rcx);\n     }\n \n     intravisit::walk_arm(rcx, arm);\n }\n \n fn visit_local(rcx: &mut Rcx, l: &hir::Local) {\n     // see above\n-    constrain_bindings_in_pat(&*l.pat, rcx);\n+    constrain_bindings_in_pat(&l.pat, rcx);\n     link_local(rcx, l);\n     intravisit::walk_local(rcx, l);\n }\n@@ -656,10 +656,10 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n \n         hir::ExprCall(ref callee, ref args) => {\n             if has_method_map {\n-                constrain_call(rcx, expr, Some(&**callee),\n+                constrain_call(rcx, expr, Some(&callee),\n                                args.iter().map(|e| &**e), false);\n             } else {\n-                constrain_callee(rcx, callee.id, expr, &**callee);\n+                constrain_callee(rcx, callee.id, expr, &callee);\n                 constrain_call(rcx, expr, None,\n                                args.iter().map(|e| &**e), false);\n             }\n@@ -668,23 +668,23 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n         }\n \n         hir::ExprMethodCall(_, _, ref args) => {\n-            constrain_call(rcx, expr, Some(&*args[0]),\n+            constrain_call(rcx, expr, Some(&args[0]),\n                            args[1..].iter().map(|e| &**e), false);\n \n             intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n             if has_method_map {\n-                constrain_call(rcx, expr, Some(&**lhs),\n+                constrain_call(rcx, expr, Some(&lhs),\n                                Some(&**rhs).into_iter(), false);\n             }\n \n             intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprIndex(ref lhs, ref rhs) if has_method_map => {\n-            constrain_call(rcx, expr, Some(&**lhs),\n+            constrain_call(rcx, expr, Some(&lhs),\n                            Some(&**rhs).into_iter(), true);\n \n             intravisit::walk_expr(rcx, expr);\n@@ -697,7 +697,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n             // overloaded op.  Note that we (sadly) currently use an\n             // implicit \"by ref\" sort of passing style here.  This\n             // should be converted to an adjustment!\n-            constrain_call(rcx, expr, Some(&**lhs),\n+            constrain_call(rcx, expr, Some(&lhs),\n                            Some(&**rhs).into_iter(), implicitly_ref_args);\n \n             intravisit::walk_expr(rcx, expr);\n@@ -706,8 +706,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n         hir::ExprBinary(_, ref lhs, ref rhs) => {\n             // If you do `x OP y`, then the types of `x` and `y` must\n             // outlive the operation you are performing.\n-            let lhs_ty = rcx.resolve_expr_type_adjusted(&**lhs);\n-            let rhs_ty = rcx.resolve_expr_type_adjusted(&**rhs);\n+            let lhs_ty = rcx.resolve_expr_type_adjusted(&lhs);\n+            let rhs_ty = rcx.resolve_expr_type_adjusted(&rhs);\n             for &ty in &[lhs_ty, rhs_ty] {\n                 type_must_outlive(rcx,\n                                   infer::Operand(expr.span),\n@@ -721,7 +721,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n             let implicitly_ref_args = !hir_util::is_by_value_unop(op);\n \n             // As above.\n-            constrain_call(rcx, expr, Some(&**lhs),\n+            constrain_call(rcx, expr, Some(&lhs),\n                            None::<hir::Expr>.iter(), implicitly_ref_args);\n \n             intravisit::walk_expr(rcx, expr);\n@@ -732,7 +732,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n             let method_call = MethodCall::expr(expr.id);\n             let base_ty = match rcx.fcx.inh.tables.borrow().method_map.get(&method_call) {\n                 Some(method) => {\n-                    constrain_call(rcx, expr, Some(&**base),\n+                    constrain_call(rcx, expr, Some(&base),\n                                    None::<hir::Expr>.iter(), true);\n                     let fn_ret = // late-bound regions in overloaded method calls are instantiated\n                         rcx.tcx().no_late_bound_regions(&method.ty.fn_ret()).unwrap();\n@@ -750,7 +750,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n \n         hir::ExprIndex(ref vec_expr, _) => {\n             // For a[b], the lifetime of a must enclose the deref\n-            let vec_type = rcx.resolve_expr_type_adjusted(&**vec_expr);\n+            let vec_type = rcx.resolve_expr_type_adjusted(&vec_expr);\n             constrain_index(rcx, expr, vec_type);\n \n             intravisit::walk_expr(rcx, expr);\n@@ -760,12 +760,12 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n             // Determine if we are casting `source` to a trait\n             // instance.  If so, we have to be sure that the type of\n             // the source obeys the trait's region bound.\n-            constrain_cast(rcx, expr, &**source);\n+            constrain_cast(rcx, expr, &source);\n             intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprAddrOf(m, ref base) => {\n-            link_addr_of(rcx, expr, m, &**base);\n+            link_addr_of(rcx, expr, m, &base);\n \n             // Require that when you write a `&expr` expression, the\n             // resulting pointer has a lifetime that encompasses the\n@@ -780,13 +780,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n         }\n \n         hir::ExprMatch(ref discr, ref arms, _) => {\n-            link_match(rcx, &**discr, &arms[..]);\n+            link_match(rcx, &discr, &arms[..]);\n \n             intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprClosure(_, _, ref body) => {\n-            check_expr_fn_block(rcx, expr, &**body);\n+            check_expr_fn_block(rcx, expr, &body);\n         }\n \n         hir::ExprLoop(ref body, _) => {\n@@ -797,10 +797,10 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n \n         hir::ExprWhile(ref cond, ref body, _) => {\n             let repeating_scope = rcx.set_repeating_scope(cond.id);\n-            rcx.visit_expr(&**cond);\n+            rcx.visit_expr(&cond);\n \n             rcx.set_repeating_scope(body.id);\n-            rcx.visit_block(&**body);\n+            rcx.visit_block(&body);\n \n             rcx.set_repeating_scope(repeating_scope);\n         }\n@@ -945,7 +945,7 @@ fn constrain_call<'a, I: Iterator<Item=&'a hir::Expr>>(rcx: &mut Rcx,\n             rcx, infer::CallRcvr(r.span),\n             r.id, callee_region);\n         if implicitly_ref_args {\n-            link_by_ref(rcx, &*r, callee_scope);\n+            link_by_ref(rcx, &r, callee_scope);\n         }\n     }\n }\n@@ -1143,7 +1143,7 @@ fn link_local(rcx: &Rcx, local: &hir::Local) {\n     };\n     let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n     let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n-    link_pattern(rcx, mc, discr_cmt, &*local.pat);\n+    link_pattern(rcx, mc, discr_cmt, &local.pat);\n }\n \n /// Computes the guarantors for any ref bindings in a match and\n@@ -1156,7 +1156,7 @@ fn link_match(rcx: &Rcx, discr: &hir::Expr, arms: &[hir::Arm]) {\n     debug!(\"discr_cmt={:?}\", discr_cmt);\n     for arm in arms {\n         for root_pat in &arm.pats {\n-            link_pattern(rcx, mc, discr_cmt.clone(), &**root_pat);\n+            link_pattern(rcx, mc, discr_cmt.clone(), &root_pat);\n         }\n     }\n }\n@@ -1175,7 +1175,7 @@ fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[hir::Arg]) {\n                arg_ty,\n                arg_cmt,\n                arg);\n-        link_pattern(rcx, mc, arg_cmt, &*arg.pat);\n+        link_pattern(rcx, mc, arg_cmt, &arg.pat);\n     }\n }\n \n@@ -1199,7 +1199,7 @@ fn link_pattern<'t, 'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n                 // `[_, ..slice, _]` pattern\n                 hir::PatVec(_, Some(ref slice_pat), _) => {\n-                    match mc.cat_slice_pattern(sub_cmt, &**slice_pat) {\n+                    match mc.cat_slice_pattern(sub_cmt, &slice_pat) {\n                         Ok((slice_cmt, slice_mutbl, slice_r)) => {\n                             link_region(rcx, sub_pat.span, &slice_r,\n                                         ty::BorrowKind::from_mutbl(slice_mutbl),"}, {"sha": "bc4ec3adbc1853b820fccdc429856bb8ba432c80", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=f831d98ba2167ac19966618bfb218856e1eedc63", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprClosure(cc, _, ref body) => {\n-                self.check_closure(expr, cc, &**body);\n+                self.check_closure(expr, cc, &body);\n             }\n \n             _ => { }"}, {"sha": "e663e449cfc4a3cd922e636ed4ef7f3796daa680", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=f831d98ba2167ac19966618bfb218856e1eedc63", "patch": "@@ -53,10 +53,10 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     wbcx.visit_block(blk);\n     for arg in &decl.inputs {\n         wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n-        wbcx.visit_pat(&*arg.pat);\n+        wbcx.visit_pat(&arg.pat);\n \n         // Privacy needs the type for the whole pattern, not just each binding\n-        if !pat_util::pat_is_binding(&fcx.tcx().def_map.borrow(), &*arg.pat) {\n+        if !pat_util::pat_is_binding(&fcx.tcx().def_map.borrow(), &arg.pat) {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span),\n                                arg.pat.id);\n         }\n@@ -221,7 +221,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n     fn visit_ty(&mut self, t: &hir::Ty) {\n         match t.node {\n             hir::TyFixedLengthVec(ref ty, ref count_expr) => {\n-                self.visit_ty(&**ty);\n+                self.visit_ty(&ty);\n                 write_ty_to_tcx(self.tcx(), count_expr.id, self.tcx().types.usize);\n             }\n             hir::TyBareFn(ref function_declaration) => {"}, {"sha": "cae2d9d890d7931329ae8b02e87afa25b5a1a1a8", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f831d98ba2167ac19966618bfb218856e1eedc63/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f831d98ba2167ac19966618bfb218856e1eedc63", "patch": "@@ -273,7 +273,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                 _ => tcx.sess.bug(&format!(\"get_trait_def({:?}): not an item\", trait_id))\n             };\n \n-            trait_def_of_item(self, &*item)\n+            trait_def_of_item(self, &item)\n         } else {\n             tcx.lookup_trait_def(trait_id)\n         }\n@@ -577,7 +577,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            v: &hir::StructField,\n                            ty_f: ty::FieldDefMaster<'tcx>)\n {\n-    let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &*v.node.ty);\n+    let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &v.node.ty);\n     ty_f.fulfill_ty(tt);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n \n@@ -709,7 +709,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n-            let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &**selfty);\n+            let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n             tcx.register_item_type(def_id,\n@@ -768,7 +768,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                 if let hir::ImplItemKind::Const(ref ty, _) = impl_item.node {\n                     let ty = ccx.icx(&ty_predicates)\n-                                .to_ty(&ExplicitRscope, &*ty);\n+                                .to_ty(&ExplicitRscope, &ty);\n                     tcx.register_item_type(ccx.tcx.map.local_def_id(impl_item.id),\n                                            TypeScheme {\n                                                generics: ty_generics.clone(),\n@@ -1399,11 +1399,11 @@ fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     if let Some(node_id) = ccx.tcx.map.as_local_node_id(def_id) {\n         match ccx.tcx.map.find(node_id) {\n             Some(hir_map::NodeItem(item)) => {\n-                type_scheme_of_item(ccx, &*item)\n+                type_scheme_of_item(ccx, &item)\n             }\n             Some(hir_map::NodeForeignItem(foreign_item)) => {\n                 let abi = ccx.tcx.map.get_foreign_abi(node_id);\n-                type_scheme_of_foreign_item(ccx, &*foreign_item, abi)\n+                type_scheme_of_foreign_item(ccx, &foreign_item, abi)\n             }\n             x => {\n                 ccx.tcx.sess.bug(&format!(\"unexpected sort of node \\\n@@ -1437,18 +1437,18 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let tcx = ccx.tcx;\n     match it.node {\n         hir::ItemStatic(ref t, _, _) | hir::ItemConst(ref t, _) => {\n-            let ty = ccx.icx(&()).to_ty(&ExplicitRscope, &**t);\n+            let ty = ccx.icx(&()).to_ty(&ExplicitRscope, &t);\n             ty::TypeScheme { ty: ty, generics: ty::Generics::empty() }\n         }\n         hir::ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n-            let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &**decl);\n+            let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl);\n             let ty = tcx.mk_fn(Some(ccx.tcx.map.local_def_id(it.id)), tcx.mk_bare_fn(tofd));\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         hir::ItemTy(ref t, ref generics) => {\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n-            let ty = ccx.icx(generics).to_ty(&ExplicitRscope, &**t);\n+            let ty = ccx.icx(generics).to_ty(&ExplicitRscope, &t);\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         hir::ItemEnum(ref ei, ref generics) => {\n@@ -1777,7 +1777,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n                 let ty = ast_ty_to_ty(&ccx.icx(&(base_predicates, ast_generics)),\n                                       &ExplicitRscope,\n-                                      &*bound_pred.bounded_ty);\n+                                      &bound_pred.bounded_ty);\n \n                 for bound in bound_pred.bounds.iter() {\n                     match bound {\n@@ -2120,11 +2120,11 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     -> ty::TypeScheme<'tcx>\n {\n     for i in &decl.inputs {\n-        match (*i).pat.node {\n+        match i.pat.node {\n             hir::PatIdent(_, _, _) => (),\n             hir::PatWild => (),\n             _ => {\n-                span_err!(ccx.tcx.sess, (*i).pat.span, E0130,\n+                span_err!(ccx.tcx.sess, i.pat.span, E0130,\n                           \"patterns aren't allowed in foreign function declarations\");\n             }\n         }\n@@ -2140,7 +2140,7 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n \n     let output = match decl.output {\n         hir::Return(ref ty) =>\n-            ty::FnConverging(ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &**ty)),\n+            ty::FnConverging(ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &ty)),\n         hir::DefaultReturn(..) =>\n             ty::FnConverging(ccx.tcx.mk_nil()),\n         hir::NoReturn(..) =>"}]}