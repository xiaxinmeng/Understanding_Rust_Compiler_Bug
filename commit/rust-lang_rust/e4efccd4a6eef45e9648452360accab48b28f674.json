{"sha": "e4efccd4a6eef45e9648452360accab48b28f674", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZWZjY2Q0YTZlZWY0NWU5NjQ4NDUyMzYwYWNjYWI0OGIyOGY2NzQ=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-01-25T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-02-09T07:15:37Z"}, "message": "Fix derived PartialOrd operators\n\nThe derived implementation of `partial_cmp` compares matching fields one\nby one, stopping the computation when the result of a comparison is not\nequal to `Some(Equal)`.\n\nOn the other hand the derived implementation for `lt`, `le`, `gt` and\n`ge` continues the computation when the result of a field comparison is\n`None`, consequently those operators are not transitive and inconsistent\nwith `partial_cmp`.\n\nFix the inconsistency by using the default implementation that fall-backs\nto the `partial_cmp`. This also avoids creating very deeply nested\nclosures that were quite costly to compile.", "tree": {"sha": "6ea614450c1e1fff32e46b9ad9e37f2b09117f5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ea614450c1e1fff32e46b9ad9e37f2b09117f5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4efccd4a6eef45e9648452360accab48b28f674", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4efccd4a6eef45e9648452360accab48b28f674", "html_url": "https://github.com/rust-lang/rust/commit/e4efccd4a6eef45e9648452360accab48b28f674", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4efccd4a6eef45e9648452360accab48b28f674/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "921ec4b3fca17cc777766c240038d7d50ba98e0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/921ec4b3fca17cc777766c240038d7d50ba98e0d", "html_url": "https://github.com/rust-lang/rust/commit/921ec4b3fca17cc777766c240038d7d50ba98e0d"}], "stats": {"total": 257, "additions": 67, "deletions": 190}, "files": [{"sha": "db808bf2ff51e54776e19db62b9a91a4418339ed", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 7, "deletions": 190, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/e4efccd4a6eef45e9648452360accab48b28f674/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efccd4a6eef45e9648452360accab48b28f674/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=e4efccd4a6eef45e9648452360accab48b28f674", "patch": "@@ -1,13 +1,11 @@\n-pub use OrderingOp::*;\n-\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n-use crate::deriving::{path_local, path_std, pathvec_std};\n+use crate::deriving::{path_std, pathvec_std};\n \n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, BinOpKind, Expr, MetaItem};\n+use rustc_ast::{Expr, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n \n pub fn expand_deriving_partial_ord(\n@@ -17,26 +15,6 @@ pub fn expand_deriving_partial_ord(\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    macro_rules! md {\n-        ($name:expr, $op:expr, $equal:expr) => {{\n-            let inline = cx.meta_word(span, sym::inline);\n-            let attrs = vec![cx.attribute(inline)];\n-            MethodDef {\n-                name: $name,\n-                generics: Bounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: vec![(borrowed_self(), sym::other)],\n-                ret_ty: Literal(path_local!(bool)),\n-                attributes: attrs,\n-                is_unsafe: false,\n-                unify_fieldless_variants: true,\n-                combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n-                    cs_op($op, $equal, cx, span, substr)\n-                })),\n-            }\n-        }};\n-    }\n-\n     let ordering_ty = Literal(path_std!(cmp::Ordering));\n     let ret_ty = Literal(Path::new_(\n         pathvec_std!(option::Option),\n@@ -62,21 +40,6 @@ pub fn expand_deriving_partial_ord(\n         })),\n     };\n \n-    // avoid defining extra methods if we can\n-    // c-like enums, enums without any fields and structs without fields\n-    // can safely define only `partial_cmp`.\n-    let methods = if is_type_without_fields(item) {\n-        vec![partial_cmp_def]\n-    } else {\n-        vec![\n-            partial_cmp_def,\n-            md!(sym::lt, true, false),\n-            md!(sym::le, true, true),\n-            md!(sym::gt, false, false),\n-            md!(sym::ge, false, true),\n-        ]\n-    };\n-\n     let trait_def = TraitDef {\n         span,\n         attributes: vec![],\n@@ -85,39 +48,12 @@ pub fn expand_deriving_partial_ord(\n         generics: Bounds::empty(),\n         is_unsafe: false,\n         supports_unions: false,\n-        methods,\n+        methods: vec![partial_cmp_def],\n         associated_types: Vec::new(),\n     };\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-#[derive(Copy, Clone)]\n-pub enum OrderingOp {\n-    PartialCmpOp,\n-    LtOp,\n-    LeOp,\n-    GtOp,\n-    GeOp,\n-}\n-\n-pub fn some_ordering_collapsed(\n-    cx: &mut ExtCtxt<'_>,\n-    span: Span,\n-    op: OrderingOp,\n-    self_arg_tags: &[Ident],\n-) -> P<ast::Expr> {\n-    let lft = cx.expr_ident(span, self_arg_tags[0]);\n-    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n-    let op_sym = match op {\n-        PartialCmpOp => sym::partial_cmp,\n-        LtOp => sym::lt,\n-        LeOp => sym::le,\n-        GtOp => sym::gt,\n-        GeOp => sym::ge,\n-    };\n-    cx.expr_method_call(span, lft, Ident::new(op_sym, span), vec![rgt])\n-}\n-\n pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n     let test_id = Ident::new(sym::cmp, span);\n     let ordering = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n@@ -171,132 +107,13 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n             if self_args.len() != 2 {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n             } else {\n-                some_ordering_collapsed(cx, span, PartialCmpOp, tag_tuple)\n+                let lft = cx.expr_ident(span, tag_tuple[0]);\n+                let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n+                cx.expr_method_call(span, lft, Ident::new(sym::partial_cmp, span), vec![rgt])\n             }\n         }),\n         cx,\n         span,\n         substr,\n     )\n }\n-\n-/// Strict inequality.\n-fn cs_op(\n-    less: bool,\n-    inclusive: bool,\n-    cx: &mut ExtCtxt<'_>,\n-    span: Span,\n-    substr: &Substructure<'_>,\n-) -> P<Expr> {\n-    let ordering_path = |cx: &mut ExtCtxt<'_>, name: &str| {\n-        cx.expr_path(\n-            cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, Symbol::intern(name)])),\n-        )\n-    };\n-\n-    let par_cmp = |cx: &mut ExtCtxt<'_>, span, self_f: P<Expr>, other_fs: &[P<Expr>], default| {\n-        let other_f = match other_fs {\n-            [o_f] => o_f,\n-            _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-        };\n-\n-        // `PartialOrd::partial_cmp(self.fi, other.fi)`\n-        let cmp_path = cx.expr_path(\n-            cx.path_global(span, cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp])),\n-        );\n-        let cmp = cx.expr_call(\n-            span,\n-            cmp_path,\n-            vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())],\n-        );\n-\n-        let default = ordering_path(cx, default);\n-        // `Option::unwrap_or(_, Ordering::Equal)`\n-        let unwrap_path = cx.expr_path(\n-            cx.path_global(span, cx.std_path(&[sym::option, sym::Option, sym::unwrap_or])),\n-        );\n-        cx.expr_call(span, unwrap_path, vec![cmp, default])\n-    };\n-\n-    let fold = cs_fold1(\n-        false, // need foldr\n-        |cx, span, subexpr, self_f, other_fs| {\n-            // build up a series of `partial_cmp`s from the inside\n-            // out (hence foldr) to get lexical ordering, i.e., for op ==\n-            // `ast::lt`\n-            //\n-            // ```\n-            // Ordering::then_with(\n-            //    Option::unwrap_or(\n-            //        PartialOrd::partial_cmp(self.f1, other.f1), Ordering::Equal)\n-            //    ),\n-            //    Option::unwrap_or(\n-            //        PartialOrd::partial_cmp(self.f2, other.f2), Ordering::Greater)\n-            //    )\n-            // )\n-            // == Ordering::Less\n-            // ```\n-            //\n-            // and for op ==\n-            // `ast::le`\n-            //\n-            // ```\n-            // Ordering::then_with(\n-            //    Option::unwrap_or(\n-            //        PartialOrd::partial_cmp(self.f1, other.f1), Ordering::Equal)\n-            //    ),\n-            //    Option::unwrap_or(\n-            //        PartialOrd::partial_cmp(self.f2, other.f2), Ordering::Greater)\n-            //    )\n-            // )\n-            // != Ordering::Greater\n-            // ```\n-            //\n-            // The optimiser should remove the redundancy. We explicitly\n-            // get use the binops to avoid auto-deref dereferencing too many\n-            // layers of pointers, if the type includes pointers.\n-\n-            // `Option::unwrap_or(PartialOrd::partial_cmp(self.fi, other.fi), Ordering::Equal)`\n-            let par_cmp = par_cmp(cx, span, self_f, other_fs, \"Equal\");\n-\n-            // `Ordering::then_with(Option::unwrap_or(..), ..)`\n-            let then_with_path = cx.expr_path(\n-                cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::then_with])),\n-            );\n-            cx.expr_call(span, then_with_path, vec![par_cmp, cx.lambda0(span, subexpr)])\n-        },\n-        |cx, args| match args {\n-            Some((span, self_f, other_fs)) => {\n-                let opposite = if less { \"Greater\" } else { \"Less\" };\n-                par_cmp(cx, span, self_f, other_fs, opposite)\n-            }\n-            None => cx.expr_bool(span, inclusive),\n-        },\n-        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n-            if self_args.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n-            } else {\n-                let op = match (less, inclusive) {\n-                    (false, false) => GtOp,\n-                    (false, true) => GeOp,\n-                    (true, false) => LtOp,\n-                    (true, true) => LeOp,\n-                };\n-                some_ordering_collapsed(cx, span, op, tag_tuple)\n-            }\n-        }),\n-        cx,\n-        span,\n-        substr,\n-    );\n-\n-    match *substr.fields {\n-        EnumMatching(.., ref all_fields) | Struct(.., ref all_fields) if !all_fields.is_empty() => {\n-            let ordering = ordering_path(cx, if less ^ inclusive { \"Less\" } else { \"Greater\" });\n-            let comp_op = if inclusive { BinOpKind::Ne } else { BinOpKind::Eq };\n-\n-            cx.expr_binary(span, comp_op, fold, ordering)\n-        }\n-        _ => fold,\n-    }\n-}"}, {"sha": "9078a7ffa4fd70efe0f435172ad5f238a65e8b49", "filename": "src/test/ui/derives/derive-partial-ord.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e4efccd4a6eef45e9648452360accab48b28f674/src%2Ftest%2Fui%2Fderives%2Fderive-partial-ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efccd4a6eef45e9648452360accab48b28f674/src%2Ftest%2Fui%2Fderives%2Fderive-partial-ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-partial-ord.rs?ref=e4efccd4a6eef45e9648452360accab48b28f674", "patch": "@@ -0,0 +1,60 @@\n+// Checks that in a derived implementation of PartialOrd the lt, le, ge, gt methods are consistent\n+// with partial_cmp. Also verifies that implementation is consistent with that for tuples.\n+//\n+// run-pass\n+\n+#[derive(PartialEq, PartialOrd)]\n+struct P(f64, f64);\n+\n+fn main() {\n+    let values: &[f64] = &[1.0, 2.0, f64::NAN];\n+    for a in values {\n+        for b in values {\n+            for c in values {\n+                for d in values {\n+                    // Check impl for a tuple.\n+                    check(&(*a, *b), &(*c, *d));\n+\n+                    // Check derived impl.\n+                    check(&P(*a, *b), &P(*c, *d));\n+\n+                    // Check that impls agree with each other.\n+                    assert_eq!(\n+                        PartialOrd::partial_cmp(&(*a, *b), &(*c, *d)),\n+                        PartialOrd::partial_cmp(&P(*a, *b), &P(*c, *d)),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn check<T: PartialOrd>(a: &T, b: &T) {\n+    use std::cmp::Ordering::*;\n+    match PartialOrd::partial_cmp(a, b) {\n+        None => {\n+            assert!(!(a < b));\n+            assert!(!(a <= b));\n+            assert!(!(a > b));\n+            assert!(!(a >= b));\n+        }\n+        Some(Equal) => {\n+            assert!(!(a < b));\n+            assert!(a <= b);\n+            assert!(!(a > b));\n+            assert!(a >= b);\n+        }\n+        Some(Less) => {\n+            assert!(a < b);\n+            assert!(a <= b);\n+            assert!(!(a > b));\n+            assert!(!(a >= b));\n+        }\n+        Some(Greater) => {\n+            assert!(!(a < b));\n+            assert!(!(a <= b));\n+            assert!(a > b);\n+            assert!(a >= b);\n+        }\n+    }\n+}"}]}