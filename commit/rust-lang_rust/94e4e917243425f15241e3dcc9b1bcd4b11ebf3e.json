{"sha": "94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ZTRlOTE3MjQzNDI1ZjE1MjQxZTNkY2M5YjFiY2Q0YjExZWJmM2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-23T00:21:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-23T00:21:51Z"}, "message": "auto merge of #13087 : eddyb/rust/fix-autoderef, r=cmr\n\nImplements vtable support for generic Deref impls with trait bounds.\r\nAlso fixes cross-crate inlining when using autoderef.", "tree": {"sha": "0aa37777f233254ed95928d3a05e1c538b4da5ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0aa37777f233254ed95928d3a05e1c538b4da5ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "html_url": "https://github.com/rust-lang/rust/commit/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e68550e7ac3d1fe8bdd58d1eb6dd12fe371f28b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e68550e7ac3d1fe8bdd58d1eb6dd12fe371f28b4", "html_url": "https://github.com/rust-lang/rust/commit/e68550e7ac3d1fe8bdd58d1eb6dd12fe371f28b4"}, {"sha": "087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8", "html_url": "https://github.com/rust-lang/rust/commit/087ec2aa2450e1f3a1c7b81a98b58cc1ce78e3d8"}], "stats": {"total": 349, "additions": 264, "deletions": 85}, "files": [{"sha": "94947b95cd38f9833e280b4e5d07a1d91e2dfc94", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 94, "deletions": 21, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "patch": "@@ -581,41 +581,48 @@ impl tr for moves::CaptureVar {\n // Encoding and decoding of MethodCallee\n \n trait read_method_callee_helper {\n-    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext) -> MethodCallee;\n+    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext) -> (u32, MethodCallee);\n }\n \n fn encode_method_callee(ecx: &e::EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n+                        autoderef: u32,\n                         method: &MethodCallee) {\n-    ebml_w.emit_struct(\"MethodCallee\", 3, |ebml_w| {\n-        ebml_w.emit_struct_field(\"origin\", 0u, |ebml_w| {\n+    ebml_w.emit_struct(\"MethodCallee\", 4, |ebml_w| {\n+        ebml_w.emit_struct_field(\"autoderef\", 0u, |ebml_w| {\n+            autoderef.encode(ebml_w);\n+        });\n+        ebml_w.emit_struct_field(\"origin\", 1u, |ebml_w| {\n             method.origin.encode(ebml_w);\n         });\n-        ebml_w.emit_struct_field(\"ty\", 1u, |ebml_w| {\n+        ebml_w.emit_struct_field(\"ty\", 2u, |ebml_w| {\n             ebml_w.emit_ty(ecx, method.ty);\n         });\n-        ebml_w.emit_struct_field(\"substs\", 2u, |ebml_w| {\n+        ebml_w.emit_struct_field(\"substs\", 3u, |ebml_w| {\n             ebml_w.emit_substs(ecx, &method.substs);\n         });\n     })\n }\n \n impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n-    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext) -> MethodCallee {\n-        self.read_struct(\"MethodCallee\", 3, |this| {\n-            MethodCallee {\n-                origin: this.read_struct_field(\"origin\", 0, |this| {\n+    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext) -> (u32, MethodCallee) {\n+        self.read_struct(\"MethodCallee\", 4, |this| {\n+            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n+                Decodable::decode(this)\n+            });\n+            (autoderef, MethodCallee {\n+                origin: this.read_struct_field(\"origin\", 1, |this| {\n                     let method_origin: MethodOrigin =\n                         Decodable::decode(this);\n                     method_origin.tr(xcx)\n                 }),\n-                ty: this.read_struct_field(\"ty\", 1, |this| {\n+                ty: this.read_struct_field(\"ty\", 2, |this| {\n                     this.read_ty(xcx)\n                 }),\n-                substs: this.read_struct_field(\"substs\", 2, |this| {\n+                substs: this.read_struct_field(\"substs\", 3, |this| {\n                     this.read_substs(xcx)\n                 })\n-            }\n+            })\n         })\n     }\n }\n@@ -647,6 +654,20 @@ impl tr for MethodOrigin {\n // ______________________________________________________________________\n // Encoding and decoding vtable_res\n \n+fn encode_vtable_res_with_key(ecx: &e::EncodeContext,\n+                              ebml_w: &mut writer::Encoder,\n+                              autoderef: u32,\n+                              dr: typeck::vtable_res) {\n+    ebml_w.emit_struct(\"VtableWithKey\", 2, |ebml_w| {\n+        ebml_w.emit_struct_field(\"autoderef\", 0u, |ebml_w| {\n+            autoderef.encode(ebml_w);\n+        });\n+        ebml_w.emit_struct_field(\"vtable_res\", 1u, |ebml_w| {\n+            encode_vtable_res(ecx, ebml_w, dr);\n+        });\n+    })\n+}\n+\n pub fn encode_vtable_res(ecx: &e::EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      dr: typeck::vtable_res) {\n@@ -701,6 +722,10 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n }\n \n pub trait vtable_decoder_helpers {\n+    fn read_vtable_res_with_key(&mut self,\n+                                tcx: &ty::ctxt,\n+                                cdata: @cstore::crate_metadata)\n+                                -> (u32, typeck::vtable_res);\n     fn read_vtable_res(&mut self,\n                        tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_res;\n@@ -713,6 +738,20 @@ pub trait vtable_decoder_helpers {\n }\n \n impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n+    fn read_vtable_res_with_key(&mut self,\n+                                tcx: &ty::ctxt,\n+                                cdata: @cstore::crate_metadata)\n+                                -> (u32, typeck::vtable_res) {\n+        self.read_struct(\"VtableWithKey\", 2, |this| {\n+            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n+                Decodable::decode(this)\n+            });\n+            (autoderef, this.read_struct_field(\"vtable_res\", 1, |this| {\n+                this.read_vtable_res(tcx, cdata)\n+            }))\n+        })\n+    }\n+\n     fn read_vtable_res(&mut self,\n                        tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_res {\n@@ -1018,21 +1057,48 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                encode_method_callee(ecx, ebml_w, method)\n+                encode_method_callee(ecx, ebml_w, method_call.autoderef, method)\n             })\n         })\n     }\n \n-    for &dr in maps.vtable_map.borrow().find(&id).iter() {\n+    for &dr in maps.vtable_map.borrow().find(&method_call).iter() {\n         ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                encode_vtable_res(ecx, ebml_w, *dr);\n+                encode_vtable_res_with_key(ecx, ebml_w, method_call.autoderef, *dr);\n             })\n         })\n     }\n \n     for adj in tcx.adjustments.borrow().find(&id).iter() {\n+        match ***adj {\n+            ty::AutoDerefRef(adj) => {\n+                for autoderef in range(0, adj.autoderefs) {\n+                    let method_call = MethodCall::autoderef(id, autoderef as u32);\n+                    for &method in maps.method_map.borrow().find(&method_call).iter() {\n+                        ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n+                            ebml_w.id(id);\n+                            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                                encode_method_callee(ecx, ebml_w, method_call.autoderef, method)\n+                            })\n+                        })\n+                    }\n+\n+                    for &dr in maps.vtable_map.borrow().find(&method_call).iter() {\n+                        ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n+                            ebml_w.id(id);\n+                            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                                encode_vtable_res_with_key(ecx, ebml_w,\n+                                                           method_call.autoderef, *dr);\n+                            })\n+                        })\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+\n         ebml_w.tag(c::tag_table_adjustments, |ebml_w| {\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n@@ -1336,15 +1402,22 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                         dcx.tcx.ty_param_defs.borrow_mut().insert(id, bounds);\n                     }\n                     c::tag_table_method_map => {\n-                        let method = val_dsr.read_method_callee(xcx);\n-                        let method_call = MethodCall::expr(id);\n+                        let (autoderef, method) = val_dsr.read_method_callee(xcx);\n+                        let method_call = MethodCall {\n+                            expr_id: id,\n+                            autoderef: autoderef\n+                        };\n                         dcx.maps.method_map.borrow_mut().insert(method_call, method);\n                     }\n                     c::tag_table_vtable_map => {\n-                        let vtable_res =\n-                            val_dsr.read_vtable_res(xcx.dcx.tcx,\n-                                                    xcx.dcx.cdata);\n-                        dcx.maps.vtable_map.borrow_mut().insert(id, vtable_res);\n+                        let (autoderef, vtable_res) =\n+                            val_dsr.read_vtable_res_with_key(xcx.dcx.tcx,\n+                                                             xcx.dcx.cdata);\n+                        let vtable_key = MethodCall {\n+                            expr_id: id,\n+                            autoderef: autoderef\n+                        };\n+                        dcx.maps.vtable_map.borrow_mut().insert(vtable_key, vtable_res);\n                     }\n                     c::tag_table_adjustments => {\n                         let adj: @ty::AutoAdjustment = @val_dsr.read_auto_adjustment(xcx);"}, {"sha": "8d7cff98f42befdb9912939f7ab5b4214ad8d690", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "patch": "@@ -129,7 +129,7 @@ pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n         let maps = astencode::Maps {\n             root_map: @RefCell::new(HashMap::new()),\n             method_map: @RefCell::new(FnvHashMap::new()),\n-            vtable_map: @RefCell::new(NodeMap::new()),\n+            vtable_map: @RefCell::new(FnvHashMap::new()),\n             capture_map: RefCell::new(NodeMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n@@ -170,7 +170,7 @@ pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n         let maps = astencode::Maps {\n             root_map: @RefCell::new(HashMap::new()),\n             method_map: @RefCell::new(FnvHashMap::new()),\n-            vtable_map: @RefCell::new(NodeMap::new()),\n+            vtable_map: @RefCell::new(FnvHashMap::new()),\n             capture_map: RefCell::new(NodeMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, def_id,"}, {"sha": "92b97cdfc9f028c713306c60622334c73ce45364", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "patch": "@@ -170,16 +170,11 @@ pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId, node: ExprOrMethodCall) ->\n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n     let type_params = node_id_type_params(bcx, node);\n-    let vtables = match node {\n-        ExprId(id) => node_vtables(bcx, id),\n-        MethodCall(ref method_call) => {\n-            if method_call.autoderef == 0 {\n-                node_vtables(bcx, method_call.expr_id)\n-            } else {\n-                None\n-            }\n-        }\n+    let vtable_key = match node {\n+        ExprId(id) => MethodCall::expr(id),\n+        MethodCall(method_call) => method_call\n     };\n+    let vtables = node_vtables(bcx, vtable_key);\n     debug!(\"trans_fn_ref(def_id={}, node={:?}, type_params={}, vtables={})\",\n            def_id.repr(bcx.tcx()), node, type_params.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));"}, {"sha": "9787e9228bf9105d4896e9d40634eff3b003f716", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "patch": "@@ -829,7 +829,7 @@ pub fn node_id_type_params(bcx: &Block, node: ExprOrMethodCall) -> Vec<ty::t> {\n     }\n }\n \n-pub fn node_vtables(bcx: &Block, id: ast::NodeId)\n+pub fn node_vtables(bcx: &Block, id: typeck::MethodCall)\n                  -> Option<typeck::vtable_res> {\n     let vtable_map = bcx.ccx().maps.vtable_map.borrow();\n     let raw_vtables = vtable_map.find(&id);"}, {"sha": "4701f38c09a8b330e0dbc7db443bfe5207197da2", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "patch": "@@ -208,7 +208,8 @@ pub fn trans_static_method_callee(bcx: &Block,\n     debug!(\"trans_static_method_callee: method_id={:?}, expr_id={:?}, \\\n             name={}\", method_id, expr_id, token::get_name(mname));\n \n-    let vtbls = ccx.maps.vtable_map.borrow().get_copy(&expr_id);\n+    let vtable_key = MethodCall::expr(expr_id);\n+    let vtbls = ccx.maps.vtable_map.borrow().get_copy(&vtable_key);\n     let vtbls = resolve_vtables_in_fn_ctxt(bcx.fcx, vtbls);\n \n     match vtbls.get(bound_index).get(0) {\n@@ -327,16 +328,11 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n \n     // Now, do the same work for the vtables.  The vtables might not\n     // exist, in which case we need to make them.\n-    let vtables = match node {\n-        ExprId(id) => node_vtables(bcx, id),\n-        MethodCall(method_call) => {\n-            if method_call.autoderef == 0 {\n-                node_vtables(bcx, method_call.expr_id)\n-            } else {\n-                None\n-            }\n-        }\n+    let vtable_key = match node {\n+        ExprId(id) => MethodCall::expr(id),\n+        MethodCall(method_call) => method_call\n     };\n+    let vtables = node_vtables(bcx, vtable_key);\n     let r_m_origins = match vtables {\n         Some(vt) => vt,\n         None => @Vec::from_elem(node_substs.len(), @Vec::new())\n@@ -597,10 +593,8 @@ pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n     bcx = datum.store_to(bcx, llboxdest);\n \n     // Store the vtable into the second half of pair.\n-    // This is structured a bit funny because of dynamic borrow failures.\n-    let res = *ccx.maps.vtable_map.borrow().get(&id);\n-    let res = resolve_vtables_in_fn_ctxt(bcx.fcx, res);\n-    let origins = *res.get(0);\n+    let res = *ccx.maps.vtable_map.borrow().get(&MethodCall::expr(id));\n+    let origins = *resolve_vtables_in_fn_ctxt(bcx.fcx, res).get(0);\n     let vtable = get_vtable(bcx, v_ty, origins);\n     let llvtabledest = GEPi(bcx, lldest, [0u, abi::trt_field_vtable]);\n     let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());"}, {"sha": "2410390b5e74d4c552d469bb8956472fef2d7d88", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "patch": "@@ -267,7 +267,7 @@ impl<'a> Inherited<'a> {\n             node_type_substs: RefCell::new(NodeMap::new()),\n             adjustments: RefCell::new(NodeMap::new()),\n             method_map: @RefCell::new(FnvHashMap::new()),\n-            vtable_map: @RefCell::new(NodeMap::new()),\n+            vtable_map: @RefCell::new(FnvHashMap::new()),\n             upvar_borrow_map: RefCell::new(HashMap::new()),\n         }\n     }"}, {"sha": "15de3bf2b5f8e59fbc7b986e9baecb48d56c6d1a", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "patch": "@@ -516,10 +516,10 @@ fn connect_trait_tps(vcx: &VtableContext,\n     relate_trait_refs(vcx, span, impl_trait_ref, trait_ref);\n }\n \n-fn insert_vtables(fcx: &FnCtxt, expr_id: ast::NodeId, vtables: vtable_res) {\n-    debug!(\"insert_vtables(expr_id={}, vtables={:?})\",\n-           expr_id, vtables.repr(fcx.tcx()));\n-    fcx.inh.vtable_map.borrow_mut().insert(expr_id, vtables);\n+fn insert_vtables(fcx: &FnCtxt, vtable_key: MethodCall, vtables: vtable_res) {\n+    debug!(\"insert_vtables(vtable_key={}, vtables={:?})\",\n+           vtable_key, vtables.repr(fcx.tcx()));\n+    fcx.inh.vtable_map.borrow_mut().insert(vtable_key, vtables);\n }\n \n pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n@@ -591,7 +591,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                                                      is_early);\n \n                       if !is_early {\n-                          insert_vtables(fcx, ex.id, @vec!(vtables));\n+                          insert_vtables(fcx, MethodCall::expr(ex.id), @vec!(vtables));\n                       }\n \n                       // Now, if this is &trait, we need to link the\n@@ -648,7 +648,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                                            item_ty.generics.type_param_defs(),\n                                            substs, is_early);\n                 if !is_early {\n-                    insert_vtables(fcx, ex.id, vtbls);\n+                    insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);\n                 }\n             }\n             true\n@@ -673,7 +673,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                                            type_param_defs.as_slice(),\n                                            &substs, is_early);\n                 if !is_early {\n-                    insert_vtables(fcx, ex.id, vtbls);\n+                    insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);\n                 }\n             }\n           }\n@@ -692,6 +692,30 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     match fcx.inh.adjustments.borrow().find(&ex.id) {\n         Some(adjustment) => {\n             match **adjustment {\n+                AutoDerefRef(adj) => {\n+                    for autoderef in range(0, adj.autoderefs) {\n+                        let method_call = MethodCall::autoderef(ex.id, autoderef as u32);\n+                        match fcx.inh.method_map.borrow().find(&method_call) {\n+                            Some(method) => {\n+                                debug!(\"vtable resolution on parameter bounds for autoderef {}\",\n+                                       ex.repr(fcx.tcx()));\n+                                let type_param_defs =\n+                                    ty::method_call_type_param_defs(cx.tcx, method.origin);\n+                                if has_trait_bounds(type_param_defs.deref().as_slice()) {\n+                                    let vcx = fcx.vtable_context();\n+                                    let vtbls = lookup_vtables(&vcx, ex.span,\n+                                                               type_param_defs.deref()\n+                                                               .as_slice(),\n+                                                               &method.substs, is_early);\n+                                    if !is_early {\n+                                        insert_vtables(fcx, method_call, vtbls);\n+                                    }\n+                                }\n+                            }\n+                            None => {}\n+                        }\n+                    }\n+                }\n                 AutoObject(ref sigil,\n                            ref region,\n                            m,\n@@ -713,7 +737,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                                                                b);\n                     resolve_object_cast(ex, object_ty);\n                 }\n-                AutoAddEnv(..) | AutoDerefRef(..) => {}\n+                AutoAddEnv(..) => {}\n             }\n         }\n         None => {}"}, {"sha": "31d74a1e938aa952e0185f4aeb715d21180c408a", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "patch": "@@ -21,8 +21,7 @@ use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n use middle::typeck::{MethodCall, MethodCallee};\n-use middle::typeck::{vtable_res, vtable_origin};\n-use middle::typeck::{vtable_static, vtable_param};\n+use middle::typeck::{vtable_res, vtable_static, vtable_param};\n use middle::typeck::write_substs_to_tcx;\n use middle::typeck::write_ty_to_tcx;\n use util::ppaux;\n@@ -100,38 +99,34 @@ fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, method_call: MethodCall\n     }\n }\n \n-fn resolve_vtable_map_entry(fcx: &FnCtxt, sp: Span, id: ast::NodeId) {\n+fn resolve_vtable_map_entry(fcx: &FnCtxt, sp: Span, vtable_key: MethodCall) {\n     // Resolve any vtable map entry\n-    match fcx.inh.vtable_map.borrow().find_copy(&id) {\n+    match fcx.inh.vtable_map.borrow().find_copy(&vtable_key) {\n         Some(origins) => {\n             let r_origins = resolve_origins(fcx, sp, origins);\n-            fcx.ccx.vtable_map.borrow_mut().insert(id, r_origins);\n-            debug!(\"writeback::resolve_vtable_map_entry(id={}, vtables={:?})\",\n-                    id, r_origins.repr(fcx.tcx()));\n+            fcx.ccx.vtable_map.borrow_mut().insert(vtable_key, r_origins);\n+            debug!(\"writeback::resolve_vtable_map_entry(vtable_key={}, vtables={:?})\",\n+                    vtable_key, r_origins.repr(fcx.tcx()));\n         }\n         None => {}\n     }\n \n     fn resolve_origins(fcx: &FnCtxt, sp: Span,\n                        vtbls: vtable_res) -> vtable_res {\n-        @vtbls.map(|os| @os.map(|o| resolve_origin(fcx, sp, o)))\n-    }\n-\n-    fn resolve_origin(fcx: &FnCtxt,\n-                      sp: Span,\n-                      origin: &vtable_origin) -> vtable_origin {\n-        match origin {\n-            &vtable_static(def_id, ref tys, origins) => {\n-                let r_tys = resolve_type_vars_in_types(fcx,\n-                                                       sp,\n-                                                       tys.as_slice());\n-                let r_origins = resolve_origins(fcx, sp, origins);\n-                vtable_static(def_id, r_tys, r_origins)\n-            }\n-            &vtable_param(n, b) => {\n-                vtable_param(n, b)\n+        @vtbls.map(|os| @os.map(|origin| {\n+            match origin {\n+                &vtable_static(def_id, ref tys, origins) => {\n+                    let r_tys = resolve_type_vars_in_types(fcx,\n+                                                           sp,\n+                                                           tys.as_slice());\n+                    let r_origins = resolve_origins(fcx, sp, origins);\n+                    vtable_static(def_id, r_tys, r_origins)\n+                }\n+                &vtable_param(n, b) => {\n+                    vtable_param(n, b)\n+                }\n             }\n-        }\n+        }))\n     }\n }\n \n@@ -183,6 +178,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                     for autoderef in range(0, adj.autoderefs) {\n                         let method_call = MethodCall::autoderef(id, autoderef as u32);\n                         resolve_method_map_entry(wbcx, sp, method_call);\n+                        resolve_vtable_map_entry(wbcx.fcx, sp, method_call);\n                     }\n \n                     let fixup_region = |r| {\n@@ -273,7 +269,7 @@ fn visit_expr(e: &ast::Expr, wbcx: &mut WbCtxt) {\n \n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n     resolve_method_map_entry(wbcx, e.span, MethodCall::expr(e.id));\n-    resolve_vtable_map_entry(wbcx.fcx, e.span, e.id);\n+    resolve_vtable_map_entry(wbcx.fcx, e.span, MethodCall::expr(e.id));\n \n     match e.node {\n         ast::ExprFnBlock(ref decl, _) | ast::ExprProc(ref decl, _) => {"}, {"sha": "b33819ff7f464f4a43f8c77afb7bc094e7f7d2c7", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "patch": "@@ -68,7 +68,7 @@ use middle::ty;\n use util::common::time;\n use util::ppaux::Repr;\n use util::ppaux;\n-use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n+use util::nodemap::{DefIdMap, FnvHashMap};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n@@ -148,7 +148,7 @@ pub struct MethodCallee {\n     substs: ty::substs\n }\n \n-#[deriving(Clone, Eq, Hash)]\n+#[deriving(Clone, Eq, Hash, Show)]\n pub struct MethodCall {\n     expr_id: ast::NodeId,\n     autoderef: u32\n@@ -216,7 +216,7 @@ impl Repr for vtable_origin {\n     }\n }\n \n-pub type vtable_map = @RefCell<NodeMap<vtable_res>>;\n+pub type vtable_map = @RefCell<FnvHashMap<MethodCall, vtable_res>>;\n \n \n // Information about the vtable resolutions for a trait impl.\n@@ -461,7 +461,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n     let ccx = CrateCtxt {\n         trait_map: trait_map,\n         method_map: @RefCell::new(FnvHashMap::new()),\n-        vtable_map: @RefCell::new(NodeMap::new()),\n+        vtable_map: @RefCell::new(FnvHashMap::new()),\n         tcx: tcx\n     };\n "}, {"sha": "65a404d1ff36209b16d57b36f351233569022168", "filename": "src/test/auxiliary/overloaded_autoderef_xc.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Foverloaded_autoderef_xc.rs?ref=94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Deref;\n+\n+struct DerefWithHelper<H, T> {\n+    helper: H\n+}\n+\n+trait Helper<T> {\n+    fn helper_borrow<'a>(&'a self) -> &'a T;\n+}\n+\n+impl<T> Helper<T> for Option<T> {\n+    fn helper_borrow<'a>(&'a self) -> &'a T {\n+        self.as_ref().unwrap()\n+    }\n+}\n+\n+impl<T, H: Helper<T>> Deref<T> for DerefWithHelper<H, T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        self.helper.helper_borrow()\n+    }\n+}\n+\n+// Test cross-crate autoderef + vtable.\n+pub fn check<T: Eq>(x: T, y: T) -> bool {\n+    let d: DerefWithHelper<Option<T>, T> = DerefWithHelper { helper: Some(x) };\n+    d.eq(&y)\n+}"}, {"sha": "15b5cca9cf83ea681c2899b0b9067e2a3b2723b1", "filename": "src/test/run-pass/overloaded-autoderef-vtable.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-vtable.rs?ref=94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Deref;\n+\n+struct DerefWithHelper<H, T> {\n+    helper: H\n+}\n+\n+trait Helper<T> {\n+    fn helper_borrow<'a>(&'a self) -> &'a T;\n+}\n+\n+impl<T> Helper<T> for Option<T> {\n+    fn helper_borrow<'a>(&'a self) -> &'a T {\n+        self.as_ref().unwrap()\n+    }\n+}\n+\n+impl<T, H: Helper<T>> Deref<T> for DerefWithHelper<H, T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        self.helper.helper_borrow()\n+    }\n+}\n+\n+struct Foo {x: int}\n+\n+impl Foo {\n+    fn foo(&self) -> int {self.x}\n+}\n+\n+pub fn main() {\n+    let x: DerefWithHelper<Option<Foo>, Foo> = DerefWithHelper { helper: Some(Foo {x: 5}) };\n+    assert!(x.foo() == 5);\n+}"}, {"sha": "fc969093d23a913f25fbecb2dc3d3b12104e028b", "filename": "src/test/run-pass/overloaded-autoderef-xcrate.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94e4e917243425f15241e3dcc9b1bcd4b11ebf3e/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-xcrate.rs?ref=94e4e917243425f15241e3dcc9b1bcd4b11ebf3e", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast\n+// aux-build:overloaded_autoderef_xc.rs\n+\n+extern crate overloaded_autoderef_xc;\n+\n+fn main() {\n+    assert!(overloaded_autoderef_xc::check(5, 5));\n+}"}]}