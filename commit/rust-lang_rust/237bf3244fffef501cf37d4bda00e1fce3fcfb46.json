{"sha": "237bf3244fffef501cf37d4bda00e1fce3fcfb46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzN2JmMzI0NGZmZmVmNTAxY2YzN2Q0YmRhMDBlMWZjZTNmY2ZiNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-28T08:56:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-28T08:56:34Z"}, "message": "Auto merge of #59478 - Centril:rollup, r=Centril\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #57987 (Fix some AArch64 typos)\n - #58581 (Refactor generic parameter encoder functions)\n - #58803 (fs::copy() unix: set file mode early)\n - #58848 (Prevent cache issues on version updates)\n - #59198 (Do not complain about unmentioned fields in recovered patterns)\n - #59351 (Include llvm-ar with llvm-tools component)\n - #59413 (HirIdify hir::ItemId)\n - #59441 (Remove the block on natvis for lld-link.)\n - #59448 (Use consistent phrasing for all macro summaries)\n - #59456 (Add documentation about `for` used as higher ranked trait bounds)\n - #59472 (Document that `std::io::BufReader` discards contents on drop)\n - #59474 (Fix link capitalization in documentation of std::io::BufWriter.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "ca483d5330b97887970dca2110c007a1084e4aa1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca483d5330b97887970dca2110c007a1084e4aa1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/237bf3244fffef501cf37d4bda00e1fce3fcfb46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/237bf3244fffef501cf37d4bda00e1fce3fcfb46", "html_url": "https://github.com/rust-lang/rust/commit/237bf3244fffef501cf37d4bda00e1fce3fcfb46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/237bf3244fffef501cf37d4bda00e1fce3fcfb46/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bfe4b7b51f47ca014d535506cbc5682f00d8d2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bfe4b7b51f47ca014d535506cbc5682f00d8d2a", "html_url": "https://github.com/rust-lang/rust/commit/6bfe4b7b51f47ca014d535506cbc5682f00d8d2a"}, {"sha": "d403cd787c98610cf5287301820ad3353b35481d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d403cd787c98610cf5287301820ad3353b35481d", "html_url": "https://github.com/rust-lang/rust/commit/d403cd787c98610cf5287301820ad3353b35481d"}], "stats": {"total": 639, "additions": 341, "deletions": 298}, "files": [{"sha": "1c9f6e1ab285c67a71c5d6cb6b03ad3de13a826a", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -69,6 +69,17 @@ fn main() {\n                .arg(\"unstable-options\");\n         }\n         cmd.arg(\"--generate-redirect-pages\");\n+        has_unstable = true;\n+    }\n+\n+    // Needed to be able to run all rustdoc tests.\n+    if let Some(ref x) = env::var_os(\"RUSTDOC_RESOURCE_SUFFIX\") {\n+        // This \"unstable-options\" can be removed when `--resource-suffix` is stabilized\n+        if !has_unstable {\n+            cmd.arg(\"-Z\")\n+               .arg(\"unstable-options\");\n+        }\n+        cmd.arg(\"--resource-suffix\").arg(x);\n     }\n \n     if verbose > 1 {"}, {"sha": "d831d2f1af2dd77c61db230f65db0d515fd517f9", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -343,12 +343,9 @@ fn invoke_rustdoc(\n         .arg(\"--html-before-content\").arg(&version_info)\n         .arg(\"--html-in-header\").arg(&header)\n         .arg(\"--markdown-no-toc\")\n-        .arg(\"--markdown-playground-url\")\n-        .arg(\"https://play.rust-lang.org/\")\n-        .arg(\"-o\").arg(&out)\n-        .arg(&path)\n-        .arg(\"--markdown-css\")\n-        .arg(\"../rust.css\");\n+        .arg(\"--markdown-playground-url\").arg(\"https://play.rust-lang.org/\")\n+        .arg(\"-o\").arg(&out).arg(&path)\n+        .arg(\"--markdown-css\").arg(\"../rust.css\");\n \n     builder.run(&mut cmd);\n }\n@@ -431,8 +428,7 @@ impl Step for Standalone {\n                .arg(\"--html-in-header\").arg(&favicon)\n                .arg(\"--markdown-no-toc\")\n                .arg(\"--index-page\").arg(&builder.src.join(\"src/doc/index.md\"))\n-               .arg(\"--markdown-playground-url\")\n-               .arg(\"https://play.rust-lang.org/\")\n+               .arg(\"--markdown-playground-url\").arg(\"https://play.rust-lang.org/\")\n                .arg(\"-o\").arg(&out)\n                .arg(&path);\n \n@@ -523,6 +519,7 @@ impl Step for Std {\n                  .arg(\"--markdown-css\").arg(\"rust.css\")\n                  .arg(\"--markdown-no-toc\")\n                  .arg(\"--generate-redirect-pages\")\n+                 .arg(\"--resource-suffix\").arg(crate::channel::CFG_RELEASE_NUM)\n                  .arg(\"--index-page\").arg(&builder.src.join(\"src/doc/index.md\"));\n \n             builder.run(&mut cargo);\n@@ -589,6 +586,7 @@ impl Step for Test {\n \n         cargo.arg(\"--no-deps\")\n              .arg(\"-p\").arg(\"test\")\n+             .env(\"RUSTDOC_RESOURCE_SUFFIX\", crate::channel::CFG_RELEASE_NUM)\n              .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n \n         builder.run(&mut cargo);\n@@ -660,6 +658,7 @@ impl Step for WhitelistedRustc {\n         // for which docs must be built.\n         for krate in &[\"proc_macro\"] {\n             cargo.arg(\"-p\").arg(krate)\n+                 .env(\"RUSTDOC_RESOURCE_SUFFIX\", crate::channel::CFG_RELEASE_NUM)\n                  .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n         }\n \n@@ -890,6 +889,7 @@ impl Step for ErrorIndex {\n         );\n         index.arg(\"html\");\n         index.arg(out.join(\"error-index.html\"));\n+        index.arg(crate::channel::CFG_RELEASE_NUM);\n \n         // FIXME: shouldn't have to pass this env var\n         index.env(\"CFG_BUILD\", &builder.config.build)"}, {"sha": "d245b3e98d3193125b83b15fd353983b416190f0", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -190,6 +190,7 @@ const LLVM_TOOLS: &[&str] = &[\n     \"llvm-readobj\", // used to get information from ELFs/objects that the other tools don't provide\n     \"llvm-size\", // used to prints the size of the linker sections of a program\n     \"llvm-strip\", // used to discard symbols from binary files to reduce their size\n+    \"llvm-ar\" // used for creating and modifying archive files\n ];\n \n /// A structure representing a Rust compiler."}, {"sha": "231a1f199bdd69557ec44fc5fc61bacab9936c8c", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -47,7 +47,7 @@ impl fmt::Debug for c_void {\n /// Basic implementation of a `va_list`.\n #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n               not(target_arch = \"x86_64\")),\n-          all(target_arch = \"aarch4\", target_os = \"ios\"),\n+          all(target_arch = \"aarch64\", target_os = \"ios\"),\n           windows))]\n #[unstable(feature = \"c_variadic\",\n            reason = \"the `c_variadic` feature has not been properly tested on \\\n@@ -59,6 +59,7 @@ extern {\n \n #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n               not(target_arch = \"x86_64\")),\n+          all(target_arch = \"aarch64\", target_os = \"ios\"),\n           windows))]\n impl fmt::Debug for VaListImpl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -67,11 +68,11 @@ impl fmt::Debug for VaListImpl {\n }\n \n /// AArch64 ABI implementation of a `va_list`. See the\n-/// [Aarch64 Procedure Call Standard] for more details.\n+/// [AArch64 Procedure Call Standard] for more details.\n ///\n /// [AArch64 Procedure Call Standard]:\n /// http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf\n-#[cfg(all(target_arch = \"aarch64\", not(windows)))]\n+#[cfg(all(target_arch = \"aarch64\", not(target_os = \"ios\"), not(windows)))]\n #[repr(C)]\n #[derive(Debug)]\n #[unstable(feature = \"c_variadic\",\n@@ -193,14 +194,14 @@ impl<'a> VaList<'a> {\n             where F: for<'copy> FnOnce(VaList<'copy>) -> R {\n         #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n                       not(target_arch = \"x86_64\")),\n-                  all(target_arch = \"aarch4\", target_os = \"ios\"),\n+                  all(target_arch = \"aarch64\", target_os = \"ios\"),\n                   windows))]\n         let mut ap = va_copy(self);\n         #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n-                  not(windows)))]\n+                  not(windows), not(all(target_arch = \"aarch64\", target_os = \"ios\"))))]\n         let mut ap_inner = va_copy(self);\n         #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n-                  not(windows)))]\n+                  not(windows), not(all(target_arch = \"aarch64\", target_os = \"ios\"))))]\n         let mut ap = VaList(&mut ap_inner);\n         let ret = f(VaList(ap.0));\n         va_end(&mut ap);\n@@ -216,10 +217,11 @@ extern \"rust-intrinsic\" {\n     /// Copies the current location of arglist `src` to the arglist `dst`.\n     #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n                   not(target_arch = \"x86_64\")),\n+              all(target_arch = \"aarch64\", target_os = \"ios\"),\n               windows))]\n     fn va_copy<'a>(src: &VaList<'a>) -> VaList<'a>;\n     #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n-              not(windows)))]\n+              not(windows), not(all(target_arch = \"aarch64\", target_os = \"ios\"))))]\n     fn va_copy(src: &VaList) -> VaListImpl;\n \n     /// Loads an argument of type `T` from the `va_list` `ap` and increment the"}, {"sha": "d2ee9b11b3640c2ffd32c64e9e0fc26ee809a2c6", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -1,4 +1,6 @@\n-/// Entry point of thread panic. For details, see `std::macros`.\n+/// Panics the current thread.\n+///\n+/// For details, see `std::macros`.\n #[macro_export]\n #[allow_internal_unstable(core_panic, __rust_unstable_column)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -132,7 +134,7 @@ macro_rules! assert_ne {\n     });\n }\n \n-/// Ensure that a boolean expression is `true` at runtime.\n+/// Asserts that a boolean expression is `true` at runtime.\n ///\n /// This will invoke the [`panic!`] macro if the provided expression cannot be\n /// evaluated to `true` at runtime.\n@@ -236,8 +238,7 @@ macro_rules! debug_assert_ne {\n     ($($arg:tt)*) => (if cfg!(debug_assertions) { assert_ne!($($arg)*); })\n }\n \n-/// Helper macro for reducing boilerplate code for matching `Result` together\n-/// with converting downstream errors.\n+/// Unwraps a result or propagates its error.\n ///\n /// The `?` operator was added to replace `try!` and should be used instead.\n /// Furthermore, `try` is a reserved word in Rust 2018, so if you must use\n@@ -312,7 +313,7 @@ macro_rules! r#try {\n     ($expr:expr,) => (r#try!($expr));\n }\n \n-/// Write formatted data into a buffer.\n+/// Writes formatted data into a buffer.\n ///\n /// This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be\n /// formatted according to the specified format string and the result will be passed to the writer.\n@@ -434,7 +435,7 @@ macro_rules! writeln {\n     );\n }\n \n-/// A utility macro for indicating unreachable code.\n+/// Indicates unreachable code.\n ///\n /// This is useful any time that the compiler can't determine that some code is unreachable. For\n /// example:\n@@ -502,7 +503,7 @@ macro_rules! unreachable {\n     });\n }\n \n-/// A standardized placeholder for marking unfinished code.\n+/// Indicates unfinished code.\n ///\n /// This can be useful if you are prototyping and are just looking to have your\n /// code type-check, or if you're implementing a trait that requires multiple\n@@ -559,10 +560,10 @@ macro_rules! unimplemented {\n     ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", format_args!($($arg)*)));\n }\n \n-/// A standardized placeholder for marking unfinished code.\n+/// Indicates unfinished code.\n ///\n /// This can be useful if you are prototyping and are just looking to have your\n-/// code typecheck. `todo!` works exactly like `unimplemented!`, there only\n+/// code typecheck. `todo!` works exactly like `unimplemented!`. The only\n /// difference between the two macros is the name.\n ///\n /// # Panics\n@@ -618,7 +619,7 @@ macro_rules! todo {\n     ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", format_args!($($arg)*)));\n }\n \n-/// A macro to create an array of [`MaybeUninit`]\n+/// Creates an array of [`MaybeUninit`].\n ///\n /// This macro constructs an uninitialized array of the type `[MaybeUninit<K>; N]`.\n ///\n@@ -645,7 +646,7 @@ macro_rules! uninitialized_array {\n #[cfg(rustdoc)]\n mod builtin {\n \n-    /// Unconditionally causes compilation to fail with the given error message when encountered.\n+    /// Causes compilation to fail with the given error message when encountered.\n     ///\n     /// For more information, see the documentation for [`std::compile_error!`].\n     ///\n@@ -657,7 +658,7 @@ mod builtin {\n         ($msg:expr,) => ({ /* compiler built-in */ });\n     }\n \n-    /// The core macro for formatted string creation & output.\n+    /// Constructs parameters for the other string-formatting macros.\n     ///\n     /// For more information, see the documentation for [`std::format_args!`].\n     ///\n@@ -669,7 +670,7 @@ mod builtin {\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ });\n     }\n \n-    /// Inspect an environment variable at compile time.\n+    /// Inspects an environment variable at compile time.\n     ///\n     /// For more information, see the documentation for [`std::env!`].\n     ///\n@@ -681,7 +682,7 @@ mod builtin {\n         ($name:expr,) => ({ /* compiler built-in */ });\n     }\n \n-    /// Optionally inspect an environment variable at compile time.\n+    /// Optionally inspects an environment variable at compile time.\n     ///\n     /// For more information, see the documentation for [`std::option_env!`].\n     ///\n@@ -693,7 +694,7 @@ mod builtin {\n         ($name:expr,) => ({ /* compiler built-in */ });\n     }\n \n-    /// Concatenate identifiers into one identifier.\n+    /// Concatenates identifiers into one identifier.\n     ///\n     /// For more information, see the documentation for [`std::concat_idents!`].\n     ///\n@@ -717,7 +718,7 @@ mod builtin {\n         ($($e:expr,)*) => ({ /* compiler built-in */ });\n     }\n \n-    /// A macro which expands to the line number on which it was invoked.\n+    /// Expands to the line number on which it was invoked.\n     ///\n     /// For more information, see the documentation for [`std::line!`].\n     ///\n@@ -726,7 +727,7 @@ mod builtin {\n     #[rustc_doc_only_macro]\n     macro_rules! line { () => ({ /* compiler built-in */ }) }\n \n-    /// A macro which expands to the column number on which it was invoked.\n+    /// Expands to the column number on which it was invoked.\n     ///\n     /// For more information, see the documentation for [`std::column!`].\n     ///\n@@ -735,7 +736,7 @@ mod builtin {\n     #[rustc_doc_only_macro]\n     macro_rules! column { () => ({ /* compiler built-in */ }) }\n \n-    /// A macro which expands to the file name from which it was invoked.\n+    /// Expands to the file name from which it was invoked.\n     ///\n     /// For more information, see the documentation for [`std::file!`].\n     ///\n@@ -744,7 +745,7 @@ mod builtin {\n     #[rustc_doc_only_macro]\n     macro_rules! file { () => ({ /* compiler built-in */ }) }\n \n-    /// A macro which stringifies its arguments.\n+    /// Stringifies its arguments.\n     ///\n     /// For more information, see the documentation for [`std::stringify!`].\n     ///\n@@ -786,7 +787,7 @@ mod builtin {\n     #[rustc_doc_only_macro]\n     macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n \n-    /// Boolean evaluation of configuration flags, at compile-time.\n+    /// Evaluates boolean combinations of configuration flags, at compile-time.\n     ///\n     /// For more information, see the documentation for [`std::cfg!`].\n     ///\n@@ -795,7 +796,7 @@ mod builtin {\n     #[rustc_doc_only_macro]\n     macro_rules! cfg { ($($cfg:tt)*) => ({ /* compiler built-in */ }) }\n \n-    /// Parse a file as an expression or an item according to the context.\n+    /// Parses a file as an expression or an item according to the context.\n     ///\n     /// For more information, see the documentation for [`std::include!`].\n     ///\n@@ -807,7 +808,7 @@ mod builtin {\n         ($file:expr,) => ({ /* compiler built-in */ });\n     }\n \n-    /// Ensure that a boolean expression is `true` at runtime.\n+    /// Asserts that a boolean expression is `true` at runtime.\n     ///\n     /// For more information, see the documentation for [`std::assert!`].\n     ///"}, {"sha": "39069b66f2904c32895709fb25f02e75f93d0b4d", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -163,7 +163,7 @@ pub trait Visitor<'v> : Sized {\n     /// but cannot supply a `Map`; see `nested_visit_map` for advice.\n     #[allow(unused_variables)]\n     fn visit_nested_item(&mut self, id: ItemId) {\n-        let opt_item = self.nested_visit_map().inter().map(|map| map.expect_item(id.id));\n+        let opt_item = self.nested_visit_map().inter().map(|map| map.expect_item_by_hir_id(id.id));\n         if let Some(item) = opt_item {\n             self.visit_item(item);\n         }"}, {"sha": "7dfb16602a3d44d911d9d05c451dc10f9053e3e4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 75, "deletions": 50, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -51,7 +51,6 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::sync::Lrc;\n \n use std::collections::{BTreeSet, BTreeMap};\n-use std::fmt::Debug;\n use std::mem;\n use smallvec::SmallVec;\n use syntax::attr;\n@@ -82,7 +81,7 @@ pub struct LoweringContext<'a> {\n     resolver: &'a mut dyn Resolver,\n \n     /// The items being lowered are collected here.\n-    items: BTreeMap<NodeId, hir::Item>,\n+    items: BTreeMap<hir::HirId, hir::Item>,\n \n     trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem>,\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n@@ -321,7 +320,7 @@ enum AnonymousLifetimeMode {\n     PassThrough,\n }\n \n-struct ImplTraitTypeIdVisitor<'a> { ids: &'a mut SmallVec<[hir::ItemId; 1]> }\n+struct ImplTraitTypeIdVisitor<'a> { ids: &'a mut SmallVec<[NodeId; 1]> }\n \n impl<'a, 'b> Visitor<'a> for ImplTraitTypeIdVisitor<'b> {\n     fn visit_ty(&mut self, ty: &'a Ty) {\n@@ -330,7 +329,7 @@ impl<'a, 'b> Visitor<'a> for ImplTraitTypeIdVisitor<'b> {\n             | TyKind::BareFn(_)\n             => return,\n \n-            TyKind::ImplTrait(id, _) => self.ids.push(hir::ItemId { id }),\n+            TyKind::ImplTrait(id, _) => self.ids.push(id),\n             _ => {},\n         }\n         visit::walk_ty(self, ty);\n@@ -361,9 +360,40 @@ impl<'a> LoweringContext<'a> {\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n \n+        impl MiscCollector<'_, '_> {\n+            fn allocate_use_tree_hir_id_counters(\n+                &mut self,\n+                tree: &UseTree,\n+                owner: DefIndex,\n+            ) {\n+                match tree.kind {\n+                    UseTreeKind::Simple(_, id1, id2) => {\n+                        for &id in &[id1, id2] {\n+                            self.lctx.resolver.definitions().create_def_with_parent(\n+                                owner,\n+                                id,\n+                                DefPathData::Misc,\n+                                DefIndexAddressSpace::High,\n+                                Mark::root(),\n+                                tree.prefix.span,\n+                            );\n+                            self.lctx.allocate_hir_id_counter(id);\n+                        }\n+                    }\n+                    UseTreeKind::Glob => (),\n+                    UseTreeKind::Nested(ref trees) => {\n+                        for &(ref use_tree, id) in trees {\n+                            let hir_id = self.lctx.allocate_hir_id_counter(id).hir_id;\n+                            self.allocate_use_tree_hir_id_counters(use_tree, hir_id.owner);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         impl<'lcx, 'interner> Visitor<'lcx> for MiscCollector<'lcx, 'interner> {\n             fn visit_item(&mut self, item: &'lcx Item) {\n-                self.lctx.allocate_hir_id_counter(item.id, item);\n+                let hir_id = self.lctx.allocate_hir_id_counter(item.id).hir_id;\n \n                 match item.node {\n                     ItemKind::Struct(_, ref generics)\n@@ -383,18 +413,21 @@ impl<'a> LoweringContext<'a> {\n                             .count();\n                         self.lctx.type_def_lifetime_params.insert(def_id, count);\n                     }\n+                    ItemKind::Use(ref use_tree) => {\n+                        self.allocate_use_tree_hir_id_counters(use_tree, hir_id.owner);\n+                    }\n                     _ => {}\n                 }\n                 visit::walk_item(self, item);\n             }\n \n             fn visit_trait_item(&mut self, item: &'lcx TraitItem) {\n-                self.lctx.allocate_hir_id_counter(item.id, item);\n+                self.lctx.allocate_hir_id_counter(item.id);\n                 visit::walk_trait_item(self, item);\n             }\n \n             fn visit_impl_item(&mut self, item: &'lcx ImplItem) {\n-                self.lctx.allocate_hir_id_counter(item.id, item);\n+                self.lctx.allocate_hir_id_counter(item.id);\n                 visit::walk_impl_item(self, item);\n             }\n         }\n@@ -434,17 +467,16 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             fn visit_item(&mut self, item: &'lcx Item) {\n-                let mut item_lowered = true;\n+                let mut item_hir_id = None;\n                 self.lctx.with_hir_id_owner(item.id, |lctx| {\n                     if let Some(hir_item) = lctx.lower_item(item) {\n-                        lctx.insert_item(item.id, hir_item);\n-                    } else {\n-                        item_lowered = false;\n+                        item_hir_id = Some(hir_item.hir_id);\n+                        lctx.insert_item(hir_item);\n                     }\n                 });\n \n-                if item_lowered {\n-                    let item_generics = match self.lctx.items.get(&item.id).unwrap().node {\n+                if let Some(hir_id) = item_hir_id {\n+                    let item_generics = match self.lctx.items.get(&hir_id).unwrap().node {\n                         hir::ItemKind::Impl(_, _, _, ref generics, ..)\n                         | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n                             generics.params.clone()\n@@ -516,20 +548,21 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn insert_item(&mut self, id: NodeId, item: hir::Item) {\n+    fn insert_item(&mut self, item: hir::Item) {\n+        let id = item.hir_id;\n+        // FIXME: Use debug_asset-rt\n+        assert_eq!(id.local_id, hir::ItemLocalId::from_u32(0));\n         self.items.insert(id, item);\n         self.modules.get_mut(&self.current_module).unwrap().items.insert(id);\n     }\n \n-    fn allocate_hir_id_counter<T: Debug>(&mut self, owner: NodeId, debug: &T) -> LoweredNodeId {\n-        if self.item_local_id_counters.insert(owner, 0).is_some() {\n-            bug!(\n-                \"Tried to allocate item_local_id_counter for {:?} twice\",\n-                debug\n-            );\n-        }\n+    fn allocate_hir_id_counter(&mut self, owner: NodeId) -> LoweredNodeId {\n+        // Setup the counter if needed\n+        self.item_local_id_counters.entry(owner).or_insert(0);\n         // Always allocate the first `HirId` for the owner itself.\n-        self.lower_node_id_with_owner(owner, owner)\n+        let lowered = self.lower_node_id_with_owner(owner, owner);\n+        debug_assert_eq!(lowered.hir_id.local_id.as_u32(), 0);\n+        lowered\n     }\n \n     fn lower_node_id_generic<F>(&mut self, ast_node_id: NodeId, alloc_hir_id: F) -> LoweredNodeId\n@@ -1381,7 +1414,7 @@ impl<'a> LoweringContext<'a> {\n             .opt_def_index(exist_ty_node_id)\n             .unwrap();\n \n-        self.allocate_hir_id_counter(exist_ty_node_id, &\"existential impl trait\");\n+        self.allocate_hir_id_counter(exist_ty_node_id);\n \n         let hir_bounds = self.with_hir_id_owner(exist_ty_node_id, lower_bounds);\n \n@@ -1422,10 +1455,10 @@ impl<'a> LoweringContext<'a> {\n             // Insert the item into the global list. This usually happens\n             // automatically for all AST items. But this existential type item\n             // does not actually exist in the AST.\n-            lctx.insert_item(exist_ty_id.node_id, exist_ty_item);\n+            lctx.insert_item(exist_ty_item);\n \n             // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n-            hir::TyKind::Def(hir::ItemId { id: exist_ty_id.node_id }, lifetimes)\n+            hir::TyKind::Def(hir::ItemId { id: exist_ty_id.hir_id }, lifetimes)\n         })\n     }\n \n@@ -2002,9 +2035,9 @@ impl<'a> LoweringContext<'a> {\n         )\n     }\n \n-    fn lower_local(&mut self, l: &Local) -> (hir::Local, SmallVec<[hir::ItemId; 1]>) {\n+    fn lower_local(&mut self, l: &Local) -> (hir::Local, SmallVec<[NodeId; 1]>) {\n         let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(l.id);\n-        let mut ids = SmallVec::<[hir::ItemId; 1]>::new();\n+        let mut ids = SmallVec::<[NodeId; 1]>::new();\n         if self.sess.features_untracked().impl_trait_in_bindings {\n             if let Some(ref ty) = l.ty {\n                 let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n@@ -3065,7 +3098,6 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n \n-                let parent_def_index = self.current_hir_id_owner.last().unwrap().0;\n                 let mut defs = self.expect_full_def_from_use(id);\n                 // We want to return *something* from this function, so hold onto the first item\n                 // for later.\n@@ -3084,14 +3116,6 @@ impl<'a> LoweringContext<'a> {\n                         seg.id = self.sess.next_node_id();\n                     }\n                     let span = path.span;\n-                    self.resolver.definitions().create_def_with_parent(\n-                        parent_def_index,\n-                        new_node_id,\n-                        DefPathData::Misc,\n-                        DefIndexAddressSpace::High,\n-                        Mark::root(),\n-                        span);\n-                    self.allocate_hir_id_counter(new_node_id, &path);\n \n                     self.with_hir_id_owner(new_node_id, |this| {\n                         let new_id = this.lower_node_id(new_node_id);\n@@ -3114,7 +3138,6 @@ impl<'a> LoweringContext<'a> {\n                         let vis = respan(vis.span, vis_kind);\n \n                         this.insert_item(\n-                            new_id.node_id,\n                             hir::Item {\n                                 hir_id: new_id.hir_id,\n                                 ident,\n@@ -3174,8 +3197,6 @@ impl<'a> LoweringContext<'a> {\n \n                 // Add all the nested `PathListItem`s to the HIR.\n                 for &(ref use_tree, id) in trees {\n-                    self.allocate_hir_id_counter(id, &use_tree);\n-\n                     let LoweredNodeId {\n                         node_id: new_id,\n                         hir_id: new_hir_id,\n@@ -3219,7 +3240,6 @@ impl<'a> LoweringContext<'a> {\n                         let vis = respan(vis.span, vis_kind);\n \n                         this.insert_item(\n-                            new_id,\n                             hir::Item {\n                                 hir_id: new_hir_id,\n                                 ident,\n@@ -3443,43 +3463,47 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_item_id(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n-        match i.node {\n+        let node_ids = match i.node {\n             ItemKind::Use(ref use_tree) => {\n-                let mut vec = smallvec![hir::ItemId { id: i.id }];\n+                let mut vec = smallvec![i.id];\n                 self.lower_item_id_use_tree(use_tree, i.id, &mut vec);\n                 vec\n             }\n             ItemKind::MacroDef(..) => SmallVec::new(),\n             ItemKind::Fn(..) |\n-            ItemKind::Impl(.., None, _, _) => smallvec![hir::ItemId { id: i.id }],\n+            ItemKind::Impl(.., None, _, _) => smallvec![i.id],\n             ItemKind::Static(ref ty, ..) => {\n-                let mut ids = smallvec![hir::ItemId { id: i.id }];\n+                let mut ids = smallvec![i.id];\n                 if self.sess.features_untracked().impl_trait_in_bindings {\n                     let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n                     visitor.visit_ty(ty);\n                 }\n                 ids\n             },\n             ItemKind::Const(ref ty, ..) => {\n-                let mut ids = smallvec![hir::ItemId { id: i.id }];\n+                let mut ids = smallvec![i.id];\n                 if self.sess.features_untracked().impl_trait_in_bindings {\n                     let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n                     visitor.visit_ty(ty);\n                 }\n                 ids\n             },\n-            _ => smallvec![hir::ItemId { id: i.id }],\n-        }\n+            _ => smallvec![i.id],\n+        };\n+\n+        node_ids.into_iter().map(|node_id| hir::ItemId {\n+            id: self.allocate_hir_id_counter(node_id).hir_id\n+        }).collect()\n     }\n \n     fn lower_item_id_use_tree(&mut self,\n                               tree: &UseTree,\n                               base_id: NodeId,\n-                              vec: &mut SmallVec<[hir::ItemId; 1]>)\n+                              vec: &mut SmallVec<[NodeId; 1]>)\n     {\n         match tree.kind {\n             UseTreeKind::Nested(ref nested_vec) => for &(ref nested, id) in nested_vec {\n-                vec.push(hir::ItemId { id });\n+                vec.push(id);\n                 self.lower_item_id_use_tree(nested, id, vec);\n             },\n             UseTreeKind::Glob => {}\n@@ -3488,7 +3512,7 @@ impl<'a> LoweringContext<'a> {\n                                     .skip(1)\n                                     .zip([id1, id2].iter())\n                 {\n-                    vec.push(hir::ItemId { id });\n+                    vec.push(id);\n                 }\n             },\n         }\n@@ -4604,6 +4628,7 @@ impl<'a> LoweringContext<'a> {\n                 let mut ids: SmallVec<[hir::Stmt; 1]> = item_ids\n                     .into_iter()\n                     .map(|item_id| {\n+                        let item_id = hir::ItemId { id: self.lower_node_id(item_id).hir_id };\n                         let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n                         hir::Stmt {"}, {"sha": "f906ff9963d9ac3157c595192a7bb8fb652d52bc", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -609,7 +609,7 @@ impl<'hir> Map<'hir> {\n         let module = &self.forest.krate.modules[&node_id];\n \n         for id in &module.items {\n-            visitor.visit_item(self.expect_item(*id));\n+            visitor.visit_item(self.expect_item_by_hir_id(*id));\n         }\n \n         for id in &module.trait_items {\n@@ -1293,7 +1293,7 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n impl<'hir> print::PpAnn for Map<'hir> {\n     fn nested(&self, state: &mut print::State<'_>, nested: print::Nested) -> io::Result<()> {\n         match nested {\n-            Nested::Item(id) => state.print_item(self.expect_item(id.id)),\n+            Nested::Item(id) => state.print_item(self.expect_item_by_hir_id(id.id)),\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::Body(id) => state.print_expr(&self.body(id).value),"}, {"sha": "8509ddaccf7b49e35914278a5ccec84d71a17a8a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -698,7 +698,7 @@ pub struct WhereEqPredicate {\n pub struct ModuleItems {\n     // Use BTreeSets here so items are in the same order as in the\n     // list of all items in Crate\n-    pub items: BTreeSet<NodeId>,\n+    pub items: BTreeSet<HirId>,\n     pub trait_items: BTreeSet<TraitItemId>,\n     pub impl_items: BTreeSet<ImplItemId>,\n }\n@@ -722,7 +722,7 @@ pub struct Crate {\n     // does, because it can affect the order in which errors are\n     // detected, which in turn can make compile-fail tests yield\n     // slightly different results.\n-    pub items: BTreeMap<NodeId, Item>,\n+    pub items: BTreeMap<HirId, Item>,\n \n     pub trait_items: BTreeMap<TraitItemId, TraitItem>,\n     pub impl_items: BTreeMap<ImplItemId, ImplItem>,\n@@ -741,7 +741,7 @@ pub struct Crate {\n }\n \n impl Crate {\n-    pub fn item(&self, id: NodeId) -> &Item {\n+    pub fn item(&self, id: HirId) -> &Item {\n         &self.items[&id]\n     }\n \n@@ -2215,7 +2215,7 @@ impl VariantData {\n // so it can fetched later.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ItemId {\n-    pub id: NodeId,\n+    pub id: HirId,\n }\n \n /// An item"}, {"sha": "0a65473de8ff1f8a5ab708f24dfe8adae79f32c5", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -48,7 +48,7 @@ pub trait PpAnn {\n     fn post(&self, _state: &mut State<'_>, _node: AnnNode<'_>) -> io::Result<()> {\n         Ok(())\n     }\n-    fn try_fetch_item(&self, _: ast::NodeId) -> Option<&hir::Item> {\n+    fn try_fetch_item(&self, _: hir::HirId) -> Option<&hir::Item> {\n         None\n     }\n }\n@@ -58,7 +58,7 @@ impl PpAnn for NoAnn {}\n pub const NO_ANN: &dyn PpAnn = &NoAnn;\n \n impl PpAnn for hir::Crate {\n-    fn try_fetch_item(&self, item: ast::NodeId) -> Option<&hir::Item> {\n+    fn try_fetch_item(&self, item: hir::HirId) -> Option<&hir::Item> {\n         Some(self.item(item))\n     }\n     fn nested(&self, state: &mut State<'_>, nested: Nested) -> io::Result<()> {"}, {"sha": "0a0a1dee7f07c52fdae3e01b46f8a0afc7fa505a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -292,7 +292,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         match ty.node {\n             TyKind::Def(item_id, _) => {\n-                let item = self.tcx.hir().expect_item(item_id.id);\n+                let item = self.tcx.hir().expect_item_by_hir_id(item_id.id);\n                 intravisit::walk_item(self, item);\n             }\n             _ => ()"}, {"sha": "73e232a6a4ff24a7007a4b39fcf25651c835319d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -638,7 +638,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n                 //                          ^            ^ this gets resolved in the scope of\n                 //                                         the exist_ty generics\n-                let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).node {\n+                let (generics, bounds) = match self.tcx.hir().expect_item_by_hir_id(item_id.id).node\n+                {\n                     // named existential types are reached via TyKind::Path\n                     // this arm is for `impl Trait` in the types of statics, constants and locals\n                     hir::ItemKind::Existential(hir::ExistTy {\n@@ -678,8 +679,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 let parent_impl_id = hir::ImplItemId { hir_id: parent_id };\n                                 let parent_trait_id = hir::TraitItemId { hir_id: parent_id };\n                                 let krate = self.tcx.hir().forest.krate();\n-                                let parent_node_id = self.tcx.hir().hir_to_node_id(parent_id);\n-                                if !(krate.items.contains_key(&parent_node_id)\n+\n+                                if !(krate.items.contains_key(&parent_id)\n                                     || krate.impl_items.contains_key(&parent_impl_id)\n                                     || krate.trait_items.contains_key(&parent_trait_id))\n                                 {"}, {"sha": "7fc17d17f99df4c4a0e4d512d8e4c1e2f81c304b", "filename": "src/librustc_codegen_llvm/va_arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fva_arg.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -108,12 +108,12 @@ pub(super) fn emit_va_arg(\n             emit_ptr_va_arg(bx, addr, target_ty, false,\n                             Align::from_bytes(4).unwrap(), true)\n         }\n-        // Windows Aarch64\n+        // Windows AArch64\n         (\"aarch64\", true) => {\n             emit_ptr_va_arg(bx, addr, target_ty, false,\n                             Align::from_bytes(8).unwrap(), false)\n         }\n-        // iOS Aarch64\n+        // iOS AArch64\n         (\"aarch64\", _) if target.target_os == \"ios\" => {\n             emit_ptr_va_arg(bx, addr, target_ty, false,\n                             Align::from_bytes(8).unwrap(), true)"}, {"sha": "244505976b6c289804383cd3d251a5ba2bd0a92f", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -596,18 +596,6 @@ impl<'a> Linker for MsvcLinker<'a> {\n         // This will cause the Microsoft linker to embed .natvis info into the PDB file\n         let natvis_dir_path = self.sess.sysroot.join(\"lib\\\\rustlib\\\\etc\");\n         if let Ok(natvis_dir) = fs::read_dir(&natvis_dir_path) {\n-            // LLVM 5.0.0's lld-link frontend doesn't yet recognize, and chokes\n-            // on, the /NATVIS:... flags.  LLVM 6 (or earlier) should at worst ignore\n-            // them, eventually mooting this workaround, per this landed patch:\n-            // https://github.com/llvm-mirror/lld/commit/27b9c4285364d8d76bb43839daa100\n-            if let Some(ref linker_path) = self.sess.opts.cg.linker {\n-                if let Some(linker_name) = Path::new(&linker_path).file_stem() {\n-                    if linker_name.to_str().unwrap().to_lowercase() == \"lld-link\" {\n-                        self.sess.warn(\"not embedding natvis: lld-link may not support the flag\");\n-                        return;\n-                    }\n-                }\n-            }\n             for entry in natvis_dir {\n                 match entry {\n                     Ok(entry) => {"}, {"sha": "f456a5c1619c5a06ed6874bd874080af2a5b1adb", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -413,6 +413,8 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::ForeignFn(_) => Def::Fn(did),\n             EntryKind::Method(_) => Def::Method(did),\n             EntryKind::Type => Def::TyAlias(did),\n+            EntryKind::TypeParam => Def::TyParam(did),\n+            EntryKind::ConstParam => Def::ConstParam(did),\n             EntryKind::Existential => Def::Existential(did),\n             EntryKind::AssociatedType(_) => Def::AssociatedTy(did),\n             EntryKind::AssociatedExistential(_) => Def::AssociatedExistential(did),"}, {"sha": "9c908176a6d3af38564adbbdd15da24bdef1086e", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -7,6 +7,7 @@ use rustc::middle::cstore::{LinkagePreference, NativeLibrary,\n                             EncodedMetadata, ForeignModule};\n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LocalDefId, LOCAL_CRATE};\n+use rustc::hir::GenericParamKind;\n use rustc::hir::map::definitions::DefPathTable;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::middle::dependency_format::Linkage;\n@@ -692,7 +693,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: self.encode_attributes(attrs),\n             children: self.lazy_seq(md.item_ids.iter().map(|item_id| {\n-                tcx.hir().local_def_id(item_id.id).index\n+                tcx.hir().local_def_id_from_hir_id(item_id.id).index\n             })),\n             stability: self.encode_stability(def_id),\n             deprecation: self.encode_deprecation(def_id),\n@@ -1352,25 +1353,22 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn encode_info_for_ty_param(&mut self,\n-                                (def_id, Untracked(has_default)): (DefId, Untracked<bool>))\n-                                -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_ty_param({:?})\", def_id);\n+    fn encode_info_for_generic_param(\n+        &mut self,\n+        def_id: DefId,\n+        entry_kind: EntryKind<'tcx>,\n+        encode_type: bool,\n+    ) -> Entry<'tcx> {\n         let tcx = self.tcx;\n         Entry {\n-            kind: EntryKind::Type,\n+            kind: entry_kind,\n             visibility: self.lazy(&ty::Visibility::Public),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n             stability: None,\n             deprecation: None,\n-\n-            ty: if has_default {\n-                Some(self.encode_item_type(def_id))\n-            } else {\n-                None\n-            },\n+            ty: if encode_type { Some(self.encode_item_type(def_id)) } else { None },\n             inherent_impls: LazySeq::empty(),\n             variances: LazySeq::empty(),\n             generics: None,\n@@ -1381,27 +1379,20 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn encode_info_for_const_param(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"IsolatedEncoder::encode_info_for_const_param({:?})\", def_id);\n-        let tcx = self.tcx;\n-        Entry {\n-            kind: EntryKind::Type,\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n-            stability: None,\n-            deprecation: None,\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n-            generics: None,\n-            predicates: None,\n-            predicates_defined_on: None,\n+    fn encode_info_for_ty_param(\n+        &mut self,\n+        (def_id, Untracked(encode_type)): (DefId, Untracked<bool>),\n+    ) -> Entry<'tcx> {\n+        debug!(\"IsolatedEncoder::encode_info_for_ty_param({:?})\", def_id);\n+        self.encode_info_for_generic_param(def_id, EntryKind::TypeParam, encode_type)\n+    }\n \n-            mir: None,\n-        }\n+    fn encode_info_for_const_param(\n+        &mut self,\n+        def_id: DefId,\n+    ) -> Entry<'tcx> {\n+        debug!(\"IsolatedEncoder::encode_info_for_const_param({:?})\", def_id);\n+        self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true)\n     }\n \n     fn encode_info_for_closure(&mut self, def_id: DefId) -> Entry<'tcx> {\n@@ -1748,18 +1739,18 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_generics(&mut self, generics: &hir::Generics) {\n         for param in &generics.params {\n+            let def_id = self.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n             match param.kind {\n-                hir::GenericParamKind::Lifetime { .. } => {}\n-                hir::GenericParamKind::Type { ref default, .. } => {\n-                    let def_id = self.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n-                    let has_default = Untracked(default.is_some());\n-                    let encode_info = IsolatedEncoder::encode_info_for_ty_param;\n-                    self.record(def_id, encode_info, (def_id, has_default));\n+                GenericParamKind::Lifetime { .. } => continue,\n+                GenericParamKind::Type { ref default, .. } => {\n+                    self.record(\n+                        def_id,\n+                        IsolatedEncoder::encode_info_for_ty_param,\n+                        (def_id, Untracked(default.is_some())),\n+                    );\n                 }\n-                hir::GenericParamKind::Const { .. } => {\n-                    let def_id = self.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n-                    let encode_info = IsolatedEncoder::encode_info_for_const_param;\n-                    self.record(def_id, encode_info, def_id);\n+                GenericParamKind::Const { .. } => {\n+                    self.record(def_id, IsolatedEncoder::encode_info_for_const_param, def_id);\n                 }\n             }\n         }"}, {"sha": "fe2ea26c327410a1edfd376b6796c48eaee89820", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -299,6 +299,8 @@ pub enum EntryKind<'tcx> {\n     ForeignType,\n     GlobalAsm,\n     Type,\n+    TypeParam,\n+    ConstParam,\n     Existential,\n     Enum(ReprOptions),\n     Field,\n@@ -335,7 +337,9 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for EntryKind<'gcx> {\n             EntryKind::ForeignType      |\n             EntryKind::Field |\n             EntryKind::Existential |\n-            EntryKind::Type => {\n+            EntryKind::Type |\n+            EntryKind::TypeParam |\n+            EntryKind::ConstParam => {\n                 // Nothing else to hash here.\n             }\n             EntryKind::Const(qualif, ref const_data) => {"}, {"sha": "f155beaaff2205a766db07edfb20ecfc7b0d746e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -472,8 +472,8 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n              {\n                 if let hir::ItemKind::Mod(m) = &item.node {\n                     for item_id in m.item_ids.as_ref() {\n-                        let item = self.tcx.hir().expect_item(item_id.id);\n-                        let def_id = self.tcx.hir().local_def_id(item_id.id);\n+                        let item = self.tcx.hir().expect_item_by_hir_id(item_id.id);\n+                        let def_id = self.tcx.hir().local_def_id_from_hir_id(item_id.id);\n                         if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id) { continue; }\n                         if let hir::ItemKind::Use(..) = item.node {\n                             self.update(item.hir_id, Some(AccessLevel::Exported));\n@@ -737,8 +737,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                 unreachable!()\n             };\n             for id in &module.item_ids {\n-                let hir_id = self.tcx.hir().node_to_hir_id(id.id);\n-                self.update(hir_id, level);\n+                self.update(id.id, level);\n             }\n             let def_id = self.tcx.hir().local_def_id_from_hir_id(module_id);\n             if let Some(exports) = self.tcx.module_exports(def_id) {"}, {"sha": "fba4414c1275c88237c39a8aa05f34ca33a76464", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -1817,7 +1817,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 self.def_to_ty(opt_self_ty, path, false)\n             }\n             hir::TyKind::Def(item_id, ref lifetimes) => {\n-                let did = tcx.hir().local_def_id(item_id.id);\n+                let did = tcx.hir().local_def_id_from_hir_id(item_id.id);\n                 self.impl_trait_ty_to_ty(did, lifetimes)\n             },\n             hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {"}, {"sha": "fde0e47650d8096a1cdec6574db9866329396a92", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -853,7 +853,7 @@ impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, '\n         }\n         // Find a `use` statement.\n         for item_id in &module.item_ids {\n-            let item = self.tcx.hir().expect_item(item_id.id);\n+            let item = self.tcx.hir().expect_item_by_hir_id(item_id.id);\n             match item.node {\n                 hir::ItemKind::Use(..) => {\n                     // Don't suggest placing a `use` before the prelude"}, {"sha": "396488c981dfdad7c3dd908409bd2dbbd7ee4408", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -278,16 +278,16 @@ impl Clean<ExternalCrate> for CrateNum {\n         };\n         let primitives = if root.is_local() {\n             cx.tcx.hir().krate().module.item_ids.iter().filter_map(|&id| {\n-                let item = cx.tcx.hir().expect_item(id.id);\n+                let item = cx.tcx.hir().expect_item_by_hir_id(id.id);\n                 match item.node {\n                     hir::ItemKind::Mod(_) => {\n-                        as_primitive(Def::Mod(cx.tcx.hir().local_def_id(id.id)))\n+                        as_primitive(Def::Mod(cx.tcx.hir().local_def_id_from_hir_id(id.id)))\n                     }\n                     hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n                         as_primitive(path.def).map(|(_, prim, attrs)| {\n                             // Pretend the primitive is local.\n-                            (cx.tcx.hir().local_def_id(id.id), prim, attrs)\n+                            (cx.tcx.hir().local_def_id_from_hir_id(id.id), prim, attrs)\n                         })\n                     }\n                     _ => None\n@@ -320,15 +320,15 @@ impl Clean<ExternalCrate> for CrateNum {\n         };\n         let keywords = if root.is_local() {\n             cx.tcx.hir().krate().module.item_ids.iter().filter_map(|&id| {\n-                let item = cx.tcx.hir().expect_item(id.id);\n+                let item = cx.tcx.hir().expect_item_by_hir_id(id.id);\n                 match item.node {\n                     hir::ItemKind::Mod(_) => {\n-                        as_keyword(Def::Mod(cx.tcx.hir().local_def_id(id.id)))\n+                        as_keyword(Def::Mod(cx.tcx.hir().local_def_id_from_hir_id(id.id)))\n                     }\n                     hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n                         as_keyword(path.def).map(|(_, prim, attrs)| {\n-                            (cx.tcx.hir().local_def_id(id.id), prim, attrs)\n+                            (cx.tcx.hir().local_def_id_from_hir_id(id.id), prim, attrs)\n                         })\n                     }\n                     _ => None\n@@ -2762,7 +2762,7 @@ impl Clean<Type> for hir::Ty {\n             },\n             TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n             TyKind::Def(item_id, _) => {\n-                let item = cx.tcx.hir().expect_item(item_id.id);\n+                let item = cx.tcx.hir().expect_item_by_hir_id(item_id.id);\n                 if let hir::ItemKind::Existential(ref ty) = item.node {\n                     ImplTrait(ty.bounds.clean(cx))\n                 } else {\n@@ -4393,10 +4393,10 @@ pub fn path_to_def_local(tcx: &TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefI\n         let segment = path_it.next()?;\n \n         for item_id in mem::replace(&mut items, HirVec::new()).iter() {\n-            let item = tcx.hir().expect_item(item_id.id);\n+            let item = tcx.hir().expect_item_by_hir_id(item_id.id);\n             if item.ident.name == *segment {\n                 if path_it.peek().is_none() {\n-                    return Some(tcx.hir().local_def_id(item_id.id))\n+                    return Some(tcx.hir().local_def_id_from_hir_id(item_id.id))\n                 }\n \n                 items = match &item.node {"}, {"sha": "4991c53ab4663797254f54d35b8dbfc02b7cb471", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -247,7 +247,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let orig_inside_public_path = self.inside_public_path;\n         self.inside_public_path &= vis.node.is_pub();\n         for i in &m.item_ids {\n-            let item = self.cx.tcx.hir().expect_item(i.id);\n+            let item = self.cx.tcx.hir().expect_item_by_hir_id(i.id);\n             self.visit_item(item, None, &mut om);\n         }\n         self.inside_public_path = orig_inside_public_path;\n@@ -344,7 +344,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Node::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n-                    let i = self.cx.tcx.hir().expect_item(i.id);\n+                    let i = self.cx.tcx.hir().expect_item_by_hir_id(i.id);\n                     self.visit_item(i, None, om);\n                 }\n                 self.inlining = prev;"}, {"sha": "441f6b95d0b6743f0ab8b1dd5c96e192d2c8a167", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -21,6 +21,10 @@ use crate::memchr;\n /// times. It also provides no advantage when reading from a source that is\n /// already in memory, like a `Vec<u8>`.\n ///\n+/// When the `BufReader` is dropped, the contents of its buffer will be\n+/// discarded. Creating multiple instances of a `BufReader` on the same\n+/// stream can cause data loss.\n+///\n /// [`Read`]: ../../std/io/trait.Read.html\n /// [`TcpStream::read`]: ../../std/net/struct.TcpStream.html#method.read\n /// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n@@ -350,7 +354,7 @@ impl<R: Seek> Seek for BufReader<R> {\n ///\n /// It can be excessively inefficient to work directly with something that\n /// implements [`Write`]. For example, every call to\n-/// [`write`][`Tcpstream::write`] on [`TcpStream`] results in a system call. A\n+/// [`write`][`TcpStream::write`] on [`TcpStream`] results in a system call. A\n /// `BufWriter` keeps an in-memory buffer of data and writes it to an underlying\n /// writer in large, infrequent batches.\n ///\n@@ -401,7 +405,7 @@ impl<R: Seek> Seek for BufReader<R> {\n /// the `stream` is dropped.\n ///\n /// [`Write`]: ../../std/io/trait.Write.html\n-/// [`Tcpstream::write`]: ../../std/net/struct.TcpStream.html#method.write\n+/// [`TcpStream::write`]: ../../std/net/struct.TcpStream.html#method.write\n /// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n /// [`flush`]: #method.flush\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "7b0d1549e061ad4ffe45e0005ff23fd9ddc6f8cf", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -286,11 +286,16 @@ mod fn_keyword { }\n //\n /// The `for` keyword.\n ///\n-/// `for` is primarily used in for-in-loops, but it has a few other pieces of syntactic uses such as\n-/// `impl Trait for Type` (see [`impl`] for more info on that). for-in-loops, or to be more\n-/// precise, iterator loops, are a simple syntactic sugar over an exceedingly common practice\n-/// within Rust, which is to loop over an iterator until that iterator returns `None` (or `break`\n-/// is called).\n+/// The `for` keyword is used in many syntactic locations:\n+///\n+/// * `for` is used in for-in-loops (see below).\n+/// * `for` is used when implementing traits as in `impl Trait for Type` (see [`impl`] for more info\n+///   on that).\n+/// * `for` is also used for [higher-ranked trait bounds] as in `for<'a> &'a T: PartialEq<i32>`.\n+///\n+/// for-in-loops, or to be more precise, iterator loops, are a simple syntactic sugar over a common\n+/// practice within Rust, which is to loop over an iterator until that iterator returns `None` (or\n+/// `break` is called).\n ///\n /// ```rust\n /// for i in 0..5 {\n@@ -347,6 +352,8 @@ mod fn_keyword { }\n /// For more information on for-loops, see the [Rust book] or the [Reference].\n ///\n /// [`impl`]: keyword.impl.html\n+/// [higher-ranked trait bounds]:\n+/// https://doc.rust-lang.org/nightly/reference/trait-bounds.html#higher-ranked-trait-bounds\n /// [`IntoIterator`]: iter/trait.IntoIterator.html\n /// [Rust book]:\n /// https://doc.rust-lang.org/book/2018-edition/ch03-05-control-flow.html#looping-through-a-collection-with-for"}, {"sha": "d5afd069d7f29a1e8a2c57eec6e04147b735a3e8", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -4,7 +4,7 @@\n //! library. Each macro is available for use when linking against the standard\n //! library.\n \n-/// The entry point for panic of Rust threads.\n+/// Panics the current thread.\n ///\n /// This allows a program to terminate immediately and provide feedback\n /// to the caller of the program. `panic!` should be used when a program reaches\n@@ -70,7 +70,7 @@ macro_rules! panic {\n     });\n }\n \n-/// Macro for printing to the standard output.\n+/// Prints to the standard output.\n ///\n /// Equivalent to the [`println!`] macro except that a newline is not printed at\n /// the end of the message.\n@@ -116,7 +116,7 @@ macro_rules! print {\n     ($($arg:tt)*) => ($crate::io::_print(format_args!($($arg)*)));\n }\n \n-/// Macro for printing to the standard output, with a newline.\n+/// Prints to the standard output, with a newline.\n ///\n /// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n /// (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n@@ -151,7 +151,7 @@ macro_rules! println {\n     })\n }\n \n-/// Macro for printing to the standard error.\n+/// Prints to the standard error.\n ///\n /// Equivalent to the [`print!`] macro, except that output goes to\n /// [`io::stderr`] instead of `io::stdout`. See [`print!`] for\n@@ -179,7 +179,7 @@ macro_rules! eprint {\n     ($($arg:tt)*) => ($crate::io::_eprint(format_args!($($arg)*)));\n }\n \n-/// Macro for printing to the standard error, with a newline.\n+/// Prints to the standard error, with a newline.\n ///\n /// Equivalent to the [`println!`] macro, except that output goes to\n /// [`io::stderr`] instead of `io::stdout`. See [`println!`] for\n@@ -210,8 +210,10 @@ macro_rules! eprintln {\n     })\n }\n \n-/// A macro for quick and dirty debugging with which you can inspect\n-/// the value of a given expression. An example:\n+/// Prints and returns the value of a given expression for quick and dirty\n+/// debugging.\n+///\n+/// An example:\n ///\n /// ```rust\n /// let a = 2;\n@@ -328,7 +330,7 @@ macro_rules! dbg {\n     }\n }\n \n-/// A macro to await on an async call.\n+/// Awaits the completion of an async call.\n #[macro_export]\n #[unstable(feature = \"await_macro\", issue = \"50547\")]\n #[allow_internal_unstable(gen_future, generators)]\n@@ -351,7 +353,7 @@ macro_rules! r#await {\n     } }\n }\n \n-/// A macro to select an event from a number of receivers.\n+/// Selects the first successful receive event from a number of receivers.\n ///\n /// This macro is used to wait for the first event to occur on a number of\n /// receivers. It places no restrictions on the types of receivers given to\n@@ -423,7 +425,7 @@ macro_rules! assert_approx_eq {\n #[cfg(rustdoc)]\n mod builtin {\n \n-    /// Unconditionally causes compilation to fail with the given error message when encountered.\n+    /// Causes compilation to fail with the given error message when encountered.\n     ///\n     /// This macro should be used when a crate uses a conditional compilation strategy to provide\n     /// better error messages for erroneous conditions. It's the compiler-level form of [`panic!`],\n@@ -465,7 +467,7 @@ mod builtin {\n         ($msg:expr,) => ({ /* compiler built-in */ });\n     }\n \n-    /// The core macro for formatted string creation & output.\n+    /// Constructs parameters for the other string-formatting macros.\n     ///\n     /// This macro functions by taking a formatting string literal containing\n     /// `{}` for each additional argument passed. `format_args!` prepares the\n@@ -517,7 +519,7 @@ mod builtin {\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ });\n     }\n \n-    /// Inspect an environment variable at compile time.\n+    /// Inspects an environment variable at compile time.\n     ///\n     /// This macro will expand to the value of the named environment variable at\n     /// compile time, yielding an expression of type `&'static str`.\n@@ -555,7 +557,7 @@ mod builtin {\n         ($name:expr,) => ({ /* compiler built-in */ });\n     }\n \n-    /// Optionally inspect an environment variable at compile time.\n+    /// Optionally inspects an environment variable at compile time.\n     ///\n     /// If the named environment variable is present at compile time, this will\n     /// expand into an expression of type `Option<&'static str>` whose value is\n@@ -581,7 +583,7 @@ mod builtin {\n         ($name:expr,) => ({ /* compiler built-in */ });\n     }\n \n-    /// Concatenate identifiers into one identifier.\n+    /// Concatenates identifiers into one identifier.\n     ///\n     /// This macro takes any number of comma-separated identifiers, and\n     /// concatenates them all into one, yielding an expression which is a new\n@@ -634,7 +636,7 @@ mod builtin {\n         ($($e:expr,)*) => ({ /* compiler built-in */ });\n     }\n \n-    /// A macro which expands to the line number on which it was invoked.\n+    /// Expands to the line number on which it was invoked.\n     ///\n     /// With [`column!`] and [`file!`], these macros provide debugging information for\n     /// developers about the location within the source.\n@@ -659,7 +661,7 @@ mod builtin {\n     #[rustc_doc_only_macro]\n     macro_rules! line { () => ({ /* compiler built-in */ }) }\n \n-    /// A macro which expands to the column number on which it was invoked.\n+    /// Expands to the column number at which it was invoked.\n     ///\n     /// With [`line!`] and [`file!`], these macros provide debugging information for\n     /// developers about the location within the source.\n@@ -684,7 +686,7 @@ mod builtin {\n     #[rustc_doc_only_macro]\n     macro_rules! column { () => ({ /* compiler built-in */ }) }\n \n-    /// A macro which expands to the file name from which it was invoked.\n+    /// Expands to the file name in which it was invoked.\n     ///\n     /// With [`line!`] and [`column!`], these macros provide debugging information for\n     /// developers about the location within the source.\n@@ -708,7 +710,7 @@ mod builtin {\n     #[rustc_doc_only_macro]\n     macro_rules! file { () => ({ /* compiler built-in */ }) }\n \n-    /// A macro which stringifies its arguments.\n+    /// Stringifies its arguments.\n     ///\n     /// This macro will yield an expression of type `&'static str` which is the\n     /// stringification of all the tokens passed to the macro. No restrictions\n@@ -822,7 +824,7 @@ mod builtin {\n     #[rustc_doc_only_macro]\n     macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n \n-    /// Boolean evaluation of configuration flags, at compile-time.\n+    /// Evaluates boolean combinations of configuration flags at compile-time.\n     ///\n     /// In addition to the `#[cfg]` attribute, this macro is provided to allow\n     /// boolean expression evaluation of configuration flags. This frequently\n@@ -844,7 +846,7 @@ mod builtin {\n     #[rustc_doc_only_macro]\n     macro_rules! cfg { ($($cfg:tt)*) => ({ /* compiler built-in */ }) }\n \n-    /// Parse a file as an expression or an item according to the context.\n+    /// Parses a file as an expression or an item according to the context.\n     ///\n     /// The file is located relative to the current file (similarly to how\n     /// modules are found).\n@@ -890,7 +892,7 @@ mod builtin {\n         ($file:expr,) => ({ /* compiler built-in */ });\n     }\n \n-    /// Ensure that a boolean expression is `true` at runtime.\n+    /// Asserts that a boolean expression is `true` at runtime.\n     ///\n     /// This will invoke the [`panic!`] macro if the provided expression cannot be\n     /// evaluated to `true` at runtime.\n@@ -944,7 +946,7 @@ mod builtin {\n     }\n }\n \n-/// A macro for defining `#[cfg]` if-else statements.\n+/// Defines `#[cfg]` if-else statements.\n ///\n /// This is similar to the `if/elif` C preprocessor macro by allowing definition\n /// of a cascade of `#[cfg]` cases, emitting the implementation which matches"}, {"sha": "c73f7983146d411b4980bce29e1f54cab4328636", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 74, "deletions": 55, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -827,30 +827,54 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n \n+fn open_and_set_permissions(\n+    from: &Path,\n+    to: &Path,\n+) -> io::Result<(crate::fs::File, crate::fs::File, u64, crate::fs::Metadata)> {\n+    use crate::fs::{File, OpenOptions};\n+    use crate::os::unix::fs::{OpenOptionsExt, PermissionsExt};\n+\n+    let reader = File::open(from)?;\n+    let (perm, len) = {\n+        let metadata = reader.metadata()?;\n+        if !metadata.is_file() {\n+            return Err(Error::new(\n+                ErrorKind::InvalidInput,\n+                \"the source path is not an existing regular file\",\n+            ));\n+        }\n+        (metadata.permissions(), metadata.len())\n+    };\n+    let writer = OpenOptions::new()\n+        // create the file with the correct mode right away\n+        .mode(perm.mode())\n+        .write(true)\n+        .create(true)\n+        .truncate(true)\n+        .open(to)?;\n+    let writer_metadata = writer.metadata()?;\n+    if writer_metadata.is_file() {\n+        // Set the correct file permissions, in case the file already existed.\n+        // Don't set the permissions on already existing non-files like\n+        // pipes/FIFOs or device nodes.\n+        writer.set_permissions(perm)?;\n+    }\n+    Ok((reader, writer, len, writer_metadata))\n+}\n+\n #[cfg(not(any(target_os = \"linux\",\n               target_os = \"android\",\n               target_os = \"macos\",\n               target_os = \"ios\")))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n-    use crate::fs::File;\n-    if !from.is_file() {\n-        return Err(Error::new(ErrorKind::InvalidInput,\n-                              \"the source path is not an existing regular file\"))\n-    }\n+    let (mut reader, mut writer, _, _) = open_and_set_permissions(from, to)?;\n \n-    let mut reader = File::open(from)?;\n-    let mut writer = File::create(to)?;\n-    let perm = reader.metadata()?.permissions();\n-\n-    let ret = io::copy(&mut reader, &mut writer)?;\n-    writer.set_permissions(perm)?;\n-    Ok(ret)\n+    io::copy(&mut reader, &mut writer)\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     use crate::cmp;\n-    use crate::fs::File;\n     use crate::sync::atomic::{AtomicBool, Ordering};\n \n     // Kernel prior to 4.5 don't have copy_file_range\n@@ -876,17 +900,7 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         )\n     }\n \n-    if !from.is_file() {\n-        return Err(Error::new(ErrorKind::InvalidInput,\n-                              \"the source path is not an existing regular file\"))\n-    }\n-\n-    let mut reader = File::open(from)?;\n-    let mut writer = File::create(to)?;\n-    let (perm, len) = {\n-        let metadata = reader.metadata()?;\n-        (metadata.permissions(), metadata.size())\n-    };\n+    let (mut reader, mut writer, len, _) = open_and_set_permissions(from, to)?;\n \n     let has_copy_file_range = HAS_COPY_FILE_RANGE.load(Ordering::Relaxed);\n     let mut written = 0u64;\n@@ -896,13 +910,14 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n             let copy_result = unsafe {\n                 // We actually don't have to adjust the offsets,\n                 // because copy_file_range adjusts the file offset automatically\n-                cvt(copy_file_range(reader.as_raw_fd(),\n-                                    ptr::null_mut(),\n-                                    writer.as_raw_fd(),\n-                                    ptr::null_mut(),\n-                                    bytes_to_copy,\n-                                    0)\n-                    )\n+                cvt(copy_file_range(\n+                    reader.as_raw_fd(),\n+                    ptr::null_mut(),\n+                    writer.as_raw_fd(),\n+                    ptr::null_mut(),\n+                    bytes_to_copy,\n+                    0,\n+                ))\n             };\n             if let Err(ref copy_err) = copy_result {\n                 match copy_err.raw_os_error() {\n@@ -920,24 +935,25 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n             Ok(ret) => written += ret as u64,\n             Err(err) => {\n                 match err.raw_os_error() {\n-                    Some(os_err) if os_err == libc::ENOSYS\n-                                 || os_err == libc::EXDEV\n-                                 || os_err == libc::EPERM => {\n-                        // Try fallback io::copy if either:\n-                        // - Kernel version is < 4.5 (ENOSYS)\n-                        // - Files are mounted on different fs (EXDEV)\n-                        // - copy_file_range is disallowed, for example by seccomp (EPERM)\n-                        assert_eq!(written, 0);\n-                        let ret = io::copy(&mut reader, &mut writer)?;\n-                        writer.set_permissions(perm)?;\n-                        return Ok(ret)\n-                    },\n+                    Some(os_err)\n+                    if os_err == libc::ENOSYS\n+                        || os_err == libc::EXDEV\n+                        || os_err == libc::EINVAL\n+                        || os_err == libc::EPERM =>\n+                        {\n+                            // Try fallback io::copy if either:\n+                            // - Kernel version is < 4.5 (ENOSYS)\n+                            // - Files are mounted on different fs (EXDEV)\n+                            // - copy_file_range is disallowed, for example by seccomp (EPERM)\n+                            // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n+                            assert_eq!(written, 0);\n+                            return io::copy(&mut reader, &mut writer);\n+                        }\n                     _ => return Err(err),\n                 }\n             }\n         }\n     }\n-    writer.set_permissions(perm)?;\n     Ok(written)\n }\n \n@@ -960,9 +976,9 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     type copyfile_flags_t = u32;\n \n     extern \"C\" {\n-        fn copyfile(\n-            from: *const libc::c_char,\n-            to: *const libc::c_char,\n+        fn fcopyfile(\n+            from: libc::c_int,\n+            to: libc::c_int,\n             state: copyfile_state_t,\n             flags: copyfile_flags_t,\n         ) -> libc::c_int;\n@@ -988,10 +1004,7 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         }\n     }\n \n-    if !from.is_file() {\n-        return Err(Error::new(ErrorKind::InvalidInput,\n-                              \"the source path is not an existing regular file\"))\n-    }\n+    let (reader, writer, _, writer_metadata) = open_and_set_permissions(from, to)?;\n \n     // We ensure that `FreeOnDrop` never contains a null pointer so it is\n     // always safe to call `copyfile_state_free`\n@@ -1003,12 +1016,18 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         FreeOnDrop(state)\n     };\n \n+    let flags = if writer_metadata.is_file() {\n+        COPYFILE_ALL\n+    } else {\n+        COPYFILE_DATA\n+    };\n+\n     cvt(unsafe {\n-        copyfile(\n-            cstr(from)?.as_ptr(),\n-            cstr(to)?.as_ptr(),\n+        fcopyfile(\n+            reader.as_raw_fd(),\n+            writer.as_raw_fd(),\n             state.0,\n-            COPYFILE_ALL,\n+            flags,\n         )\n     })?;\n "}, {"sha": "79c1f0cb4cc3cf759b8afa5d3d14079a544d5ee6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -4734,7 +4734,7 @@ impl<'a> Parser<'a> {\n                         let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n                             e.emit();\n                             self.recover_stmt();\n-                            (vec![], false)\n+                            (vec![], true)\n                         });\n                         self.bump();\n                         pat = PatKind::Struct(path, fields, etc);"}, {"sha": "dfcef59aa57825851f827159fb833cf12dfdfbb3", "filename": "src/test/run-pass/paths-containing-nul.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftest%2Frun-pass%2Fpaths-containing-nul.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftest%2Frun-pass%2Fpaths-containing-nul.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpaths-containing-nul.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -1,6 +1,7 @@\n #![allow(deprecated)]\n // ignore-cloudabi no files or I/O\n // ignore-wasm32-bare no files or I/O\n+// ignore-emscripten no files\n \n use std::fs;\n use std::io;\n@@ -22,14 +23,18 @@ fn main() {\n     assert_invalid_input(\"remove_file\", fs::remove_file(\"\\0\"));\n     assert_invalid_input(\"metadata\", fs::metadata(\"\\0\"));\n     assert_invalid_input(\"symlink_metadata\", fs::symlink_metadata(\"\\0\"));\n+\n+    // If `dummy_file` does not exist, then we might get another unrelated error\n+    let dummy_file = std::env::current_exe().unwrap();\n+\n     assert_invalid_input(\"rename1\", fs::rename(\"\\0\", \"a\"));\n-    assert_invalid_input(\"rename2\", fs::rename(\"a\", \"\\0\"));\n+    assert_invalid_input(\"rename2\", fs::rename(&dummy_file, \"\\0\"));\n     assert_invalid_input(\"copy1\", fs::copy(\"\\0\", \"a\"));\n-    assert_invalid_input(\"copy2\", fs::copy(\"a\", \"\\0\"));\n+    assert_invalid_input(\"copy2\", fs::copy(&dummy_file, \"\\0\"));\n     assert_invalid_input(\"hard_link1\", fs::hard_link(\"\\0\", \"a\"));\n-    assert_invalid_input(\"hard_link2\", fs::hard_link(\"a\", \"\\0\"));\n+    assert_invalid_input(\"hard_link2\", fs::hard_link(&dummy_file, \"\\0\"));\n     assert_invalid_input(\"soft_link1\", fs::soft_link(\"\\0\", \"a\"));\n-    assert_invalid_input(\"soft_link2\", fs::soft_link(\"a\", \"\\0\"));\n+    assert_invalid_input(\"soft_link2\", fs::soft_link(&dummy_file, \"\\0\"));\n     assert_invalid_input(\"read_link\", fs::read_link(\"\\0\"));\n     assert_invalid_input(\"canonicalize\", fs::canonicalize(\"\\0\"));\n     assert_invalid_input(\"create_dir\", fs::create_dir(\"\\0\"));"}, {"sha": "c4b1937de104f491516280e2ec8e857cbbb58474", "filename": "src/test/ui/parser/bind-struct-early-modifiers.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftest%2Fui%2Fparser%2Fbind-struct-early-modifiers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftest%2Fui%2Fparser%2Fbind-struct-early-modifiers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbind-struct-early-modifiers.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -2,7 +2,6 @@ fn main() {\n     struct Foo { x: isize }\n     match (Foo { x: 10 }) {\n         Foo { ref x: ref x } => {}, //~ ERROR expected `,`\n-                                    //~| ERROR pattern does not mention field `x`\n         _ => {}\n     }\n }"}, {"sha": "03482a41f546597720f4a2f2348739ec7d4446d3", "filename": "src/test/ui/parser/bind-struct-early-modifiers.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftest%2Fui%2Fparser%2Fbind-struct-early-modifiers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftest%2Fui%2Fparser%2Fbind-struct-early-modifiers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbind-struct-early-modifiers.stderr?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -4,12 +4,5 @@ error: expected `,`\n LL |         Foo { ref x: ref x } => {},\n    |                   ^\n \n-error[E0027]: pattern does not mention field `x`\n-  --> $DIR/bind-struct-early-modifiers.rs:4:9\n-   |\n-LL |         Foo { ref x: ref x } => {},\n-   |         ^^^^^^^^^^^^^^^^^^^^ missing field `x`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0027`."}, {"sha": "5b0c2fc2be4076dc38007aaa4fba6cd1406df267", "filename": "src/test/ui/parser/issue-10392.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftest%2Fui%2Fparser%2Fissue-10392.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftest%2Fui%2Fparser%2Fissue-10392.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-10392.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -4,5 +4,4 @@ fn a() -> A { panic!() }\n \n fn main() {\n     let A { , } = a(); //~ ERROR expected ident\n-                       //~| ERROR pattern does not mention field `foo`\n }"}, {"sha": "34991151c1eb63eafaa9a713eb8b4ea7e08df2f0", "filename": "src/test/ui/parser/issue-10392.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftest%2Fui%2Fparser%2Fissue-10392.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftest%2Fui%2Fparser%2Fissue-10392.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-10392.stderr?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -4,12 +4,5 @@ error: expected identifier, found `,`\n LL |     let A { , } = a();\n    |             ^ expected identifier\n \n-error[E0027]: pattern does not mention field `foo`\n-  --> $DIR/issue-10392.rs:6:9\n-   |\n-LL |     let A { , } = a();\n-   |         ^^^^^^^ missing field `foo`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0027`."}, {"sha": "807c54393f29b55f99a7f6ab1ad141be834bcd66", "filename": "src/test/ui/resolve/issue-54379.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftest%2Fui%2Fresolve%2Fissue-54379.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftest%2Fui%2Fresolve%2Fissue-54379.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-54379.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -6,7 +6,7 @@ fn main() {\n     let thing = MyStruct { s1: None };\n \n     match thing {\n-        MyStruct { .., Some(_) } => {}, //~ ERROR pattern does not mention field `s1`\n+        MyStruct { .., Some(_) } => {},\n         //~^ ERROR expected `,`\n         //~| ERROR expected `}`, found `,`\n         _ => {}"}, {"sha": "2a6b54572de03eb955bfd7c81d011c1c27f6f510", "filename": "src/test/ui/resolve/issue-54379.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftest%2Fui%2Fresolve%2Fissue-54379.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftest%2Fui%2Fresolve%2Fissue-54379.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-54379.stderr?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -13,12 +13,5 @@ error: expected `,`\n LL |         MyStruct { .., Some(_) } => {},\n    |                        ^^^^\n \n-error[E0027]: pattern does not mention field `s1`\n-  --> $DIR/issue-54379.rs:9:9\n-   |\n-LL |         MyStruct { .., Some(_) } => {},\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^ missing field `s1`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0027`."}, {"sha": "04986b59ea0f1afeee4df464bf31e649bbab707d", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237bf3244fffef501cf37d4bda00e1fce3fcfb46/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=237bf3244fffef501cf37d4bda00e1fce3fcfb46", "patch": "@@ -27,9 +27,10 @@ enum OutputFormat {\n }\n \n impl OutputFormat {\n-    fn from(format: &str) -> OutputFormat {\n+    fn from(format: &str, resource_suffix: &str) -> OutputFormat {\n         match &*format.to_lowercase() {\n-            \"html\"     => OutputFormat::HTML(HTMLFormatter(RefCell::new(IdMap::new()))),\n+            \"html\"     => OutputFormat::HTML(HTMLFormatter(RefCell::new(IdMap::new()),\n+                                                           resource_suffix.to_owned())),\n             \"markdown\" => OutputFormat::Markdown(MarkdownFormatter),\n             s          => OutputFormat::Unknown(s.to_owned()),\n         }\n@@ -44,7 +45,7 @@ trait Formatter {\n     fn footer(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>>;\n }\n \n-struct HTMLFormatter(RefCell<IdMap>);\n+struct HTMLFormatter(RefCell<IdMap>, String);\n struct MarkdownFormatter;\n \n impl Formatter for HTMLFormatter {\n@@ -55,7 +56,7 @@ impl Formatter for HTMLFormatter {\n <title>Rust Compiler Error Index</title>\n <meta charset=\"utf-8\">\n <!-- Include rust.css after light.css so its rules take priority. -->\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"light.css\"/>\n+<link rel=\"stylesheet\" type=\"text/css\" href=\"light{suffix}.css\"/>\n <link rel=\"stylesheet\" type=\"text/css\" href=\"rust.css\"/>\n <style>\n .error-undescribed {{\n@@ -64,7 +65,7 @@ impl Formatter for HTMLFormatter {\n </style>\n </head>\n <body>\n-\"##)?;\n+\"##, suffix=self.1)?;\n         Ok(())\n     }\n \n@@ -242,9 +243,12 @@ fn main_with_result(format: OutputFormat, dst: &Path) -> Result<(), Box<dyn Erro\n \n fn parse_args() -> (OutputFormat, PathBuf) {\n     let mut args = env::args().skip(1);\n-    let format = args.next().map(|a| OutputFormat::from(&a))\n-                            .unwrap_or(OutputFormat::from(\"html\"));\n-    let dst = args.next().map(PathBuf::from).unwrap_or_else(|| {\n+    let format = args.next();\n+    let dst = args.next();\n+    let resource_suffix = args.next().unwrap_or_else(String::new);\n+    let format = format.map(|a| OutputFormat::from(&a, &resource_suffix))\n+                       .unwrap_or(OutputFormat::from(\"html\", &resource_suffix));\n+    let dst = dst.map(PathBuf::from).unwrap_or_else(|| {\n         match format {\n             OutputFormat::HTML(..) => PathBuf::from(\"doc/error-index.html\"),\n             OutputFormat::Markdown(..) => PathBuf::from(\"doc/error-index.md\"),"}]}