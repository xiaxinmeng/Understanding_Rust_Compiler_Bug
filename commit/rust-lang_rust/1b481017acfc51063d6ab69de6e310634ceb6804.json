{"sha": "1b481017acfc51063d6ab69de6e310634ceb6804", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiNDgxMDE3YWNmYzUxMDYzZDZhYjY5ZGU2ZTMxMDYzNGNlYjY4MDQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-25T22:09:53Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-10T23:42:34Z"}, "message": "Minor cleanups to pipes and serialization", "tree": {"sha": "7138fd9932d29d4e937a33d9215bbfdfcba89790", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7138fd9932d29d4e937a33d9215bbfdfcba89790"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b481017acfc51063d6ab69de6e310634ceb6804", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b481017acfc51063d6ab69de6e310634ceb6804", "html_url": "https://github.com/rust-lang/rust/commit/1b481017acfc51063d6ab69de6e310634ceb6804", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b481017acfc51063d6ab69de6e310634ceb6804/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86f7eb344665cba48089ad63c891cd7834c38499", "url": "https://api.github.com/repos/rust-lang/rust/commits/86f7eb344665cba48089ad63c891cd7834c38499", "html_url": "https://github.com/rust-lang/rust/commit/86f7eb344665cba48089ad63c891cd7834c38499"}], "stats": {"total": 70, "additions": 43, "deletions": 27}, "files": [{"sha": "48b0b8d4d2bde1b7e4fb5e384083a6d5524dc872", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1b481017acfc51063d6ab69de6e310634ceb6804/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b481017acfc51063d6ab69de6e310634ceb6804/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=1b481017acfc51063d6ab69de6e310634ceb6804", "patch": "@@ -527,7 +527,7 @@ pub pure fn peek<T: Send, Tb: Send>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n     }\n }\n \n-impl<T: Send, Tb: Send> RecvPacketBuffered<T, Tb> {\n+impl<T: Send, Tb: Send> RecvPacketBuffered<T, Tb>: Peekable<T> {\n     pure fn peek() -> bool {\n         peek(&self)\n     }\n@@ -928,32 +928,32 @@ proto! streamp (\n )\n \n /// A trait for things that can send multiple messages.\n-pub trait Channel<T: Send> {\n-    // It'd be nice to call this send, but it'd conflict with the\n-    // built in send kind.\n-\n+pub trait GenericChan<T> {\n     /// Sends a message.\n     fn send(x: T);\n+}\n \n+/// Things that can send multiple messages and can detect when the receiver\n+/// is closed\n+pub trait GenericSmartChan<T> {\n     /// Sends a message, or report if the receiver has closed the connection.\n     fn try_send(x: T) -> bool;\n }\n \n /// A trait for things that can receive multiple messages.\n-pub trait Recv<T: Send> {\n+pub trait GenericPort<T> {\n     /// Receives a message, or fails if the connection closes.\n     fn recv() -> T;\n \n-    /** Receives a message if one is available, or returns `none` if\n-    the connection is closed.\n-\n+    /** Receives a message, or returns `none` if\n+    the connection is closed or closes.\n     */\n     fn try_recv() -> Option<T>;\n+}\n \n-    /** Returns true if a message is available or the connection is\n-    closed.\n-\n-    */\n+/// Ports that can `peek`\n+pub trait Peekable<T> {\n+    /// Returns true if a message is available\n     pure fn peek() -> bool;\n }\n \n@@ -984,13 +984,16 @@ pub fn stream<T:Send>() -> (Chan<T>, Port<T>) {\n     (Chan_({ mut endp: Some(move c) }), Port_({ mut endp: Some(move s) }))\n }\n \n-impl<T: Send> Chan<T>: Channel<T> {\n+impl<T: Send> Chan<T>: GenericChan<T> {\n     fn send(x: T) {\n         let mut endp = None;\n         endp <-> self.endp;\n         self.endp = Some(\n             streamp::client::data(unwrap(move endp), move x))\n     }\n+}\n+\n+impl<T: Send> Chan<T>: GenericSmartChan<T> {\n \n     fn try_send(x: T) -> bool {\n         let mut endp = None;\n@@ -1005,7 +1008,7 @@ impl<T: Send> Chan<T>: Channel<T> {\n     }\n }\n \n-impl<T: Send> Port<T>: Recv<T> {\n+impl<T: Send> Port<T>: GenericPort<T> {\n     fn recv() -> T {\n         let mut endp = None;\n         endp <-> self.endp;\n@@ -1025,7 +1028,9 @@ impl<T: Send> Port<T>: Recv<T> {\n           None => None\n         }\n     }\n+}\n \n+impl<T: Send> Port<T>: Peekable<T> {\n     pure fn peek() -> bool unsafe {\n         let mut endp = None;\n         endp <-> self.endp;\n@@ -1071,7 +1076,7 @@ impl<T: Send> PortSet<T> {\n     }\n }\n \n-impl<T: Send> PortSet<T> : Recv<T> {\n+impl<T: Send> PortSet<T> : GenericPort<T> {\n \n     fn try_recv() -> Option<T> {\n         let mut result = None;\n@@ -1099,6 +1104,9 @@ impl<T: Send> PortSet<T> : Recv<T> {\n         option::unwrap_expect(self.try_recv(), \"port_set: endpoints closed\")\n     }\n \n+}\n+\n+impl<T: Send> PortSet<T> : Peekable<T> {\n     pure fn peek() -> bool {\n         // It'd be nice to use self.port.each, but that version isn't\n         // pure.\n@@ -1112,7 +1120,7 @@ impl<T: Send> PortSet<T> : Recv<T> {\n /// A channel that can be shared between many senders.\n pub type SharedChan<T: Send> = private::Exclusive<Chan<T>>;\n \n-impl<T: Send> SharedChan<T>: Channel<T> {\n+impl<T: Send> SharedChan<T>: GenericChan<T> {\n     fn send(x: T) {\n         let mut xx = Some(move x);\n         do self.with_imm |chan| {\n@@ -1121,7 +1129,9 @@ impl<T: Send> SharedChan<T>: Channel<T> {\n             chan.send(option::unwrap(move x))\n         }\n     }\n+}\n \n+impl<T: Send> SharedChan<T>: GenericSmartChan<T> {\n     fn try_send(x: T) -> bool {\n         let mut xx = Some(move x);\n         do self.with_imm |chan| {\n@@ -1145,7 +1155,9 @@ pub trait Select2<T: Send, U: Send> {\n     fn select() -> Either<T, U>;\n }\n \n-impl<T: Send, U: Send, Left: Selectable Recv<T>, Right: Selectable Recv<U>>\n+impl<T: Send, U: Send,\n+     Left: Selectable GenericPort<T>,\n+     Right: Selectable GenericPort<U>>\n     (Left, Right): Select2<T, U> {\n \n     fn select() -> Either<T, U> {"}, {"sha": "d8c5b6e5944eeaf066697fcd8bf0da2073eef69b", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1b481017acfc51063d6ab69de6e310634ceb6804/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b481017acfc51063d6ab69de6e310634ceb6804/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=1b481017acfc51063d6ab69de6e310634ceb6804", "patch": "@@ -17,33 +17,38 @@ Higher level communication abstractions.\n // NB: transitionary, de-mode-ing.\n #[forbid(deprecated_mode)];\n \n-use pipes::{Channel, Recv, Chan, Port, Selectable};\n+use pipes::{GenericChan, GenericSmartChan, GenericPort,\n+            Chan, Port, Selectable, Peekable};\n \n /// An extension of `pipes::stream` that allows both sending and receiving.\n pub struct DuplexStream<T: Send, U: Send> {\n     priv chan: Chan<T>,\n-    priv port: Port <U>,\n+    priv port: Port<U>,\n }\n \n-impl<T: Send, U: Send> DuplexStream<T, U> : Channel<T> {\n+impl<T: Send, U: Send> DuplexStream<T, U> : GenericChan<T> {\n     fn send(x: T) {\n         self.chan.send(move x)\n     }\n+}\n \n+impl<T: Send, U: Send> DuplexStream<T, U> : GenericSmartChan<T> {\n     fn try_send(x: T) -> bool {\n         self.chan.try_send(move x)\n     }\n }\n \n-impl<T: Send, U: Send> DuplexStream<T, U> : Recv<U> {\n+impl<T: Send, U: Send> DuplexStream<T, U> : GenericPort<U> {\n     fn recv() -> U {\n         self.port.recv()\n     }\n \n     fn try_recv() -> Option<U> {\n         self.port.try_recv()\n     }\n+}\n \n+impl<T: Send, U: Send> DuplexStream<T, U> : Peekable<U> {\n     pure fn peek() -> bool {\n         self.port.peek()\n     }"}, {"sha": "1c6384f87d41fb96879986c434dce0e46b399528", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b481017acfc51063d6ab69de6e310634ceb6804/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b481017acfc51063d6ab69de6e310634ceb6804/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=1b481017acfc51063d6ab69de6e310634ceb6804", "patch": "@@ -157,7 +157,6 @@ pub mod reader {\n \n     pub fn doc_data(d: Doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start,\n                                                         d.end) }\n-\n     pub fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n         f(vec::view(*d.data, d.start, d.end))\n     }\n@@ -190,7 +189,7 @@ pub mod reader {\n     pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n \n-    struct Deserializer {\n+    pub struct Deserializer {\n         priv mut parent: Doc,\n         priv mut pos: uint,\n     }\n@@ -388,7 +387,7 @@ pub mod reader {\n pub mod writer {\n \n     // ebml writing\n-    struct Serializer {\n+    pub struct Serializer {\n         writer: io::Writer,\n         priv mut size_positions: ~[uint],\n     }"}, {"sha": "624824dede4f84b8375125df13728b504ca4a985", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b481017acfc51063d6ab69de6e310634ceb6804/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b481017acfc51063d6ab69de6e310634ceb6804/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=1b481017acfc51063d6ab69de6e310634ceb6804", "patch": "@@ -35,7 +35,7 @@ extern mod rustrt {\n  * underlying libuv data structures when it goes out of scope. This is the\n  * data structure that is used for read/write operations over a TCP stream.\n  */\n-struct TcpSocket {\n+pub struct TcpSocket {\n   socket_data: @TcpSocketData,\n }\n \n@@ -59,7 +59,7 @@ pub fn TcpSocket(socket_data: @TcpSocketData) -> TcpSocket {\n  * It is created with a call to `net::tcp::socket_buf()` and has impls that\n  * satisfy both the `io::reader` and `io::writer` traits.\n  */\n-struct TcpSocketBuf {\n+pub struct TcpSocketBuf {\n     data: @TcpBufferedSocketData,\n     mut end_of_stream: bool,\n }"}]}