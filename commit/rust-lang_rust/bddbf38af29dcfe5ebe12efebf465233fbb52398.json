{"sha": "bddbf38af29dcfe5ebe12efebf465233fbb52398", "node_id": "C_kwDOAAsO6NoAKGJkZGJmMzhhZjI5ZGNmZTVlYmUxMmVmZWJmNDY1MjMzZmJiNTIzOTg", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-23T17:34:23Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-17T07:48:19Z"}, "message": "`rustc_expand`: remove `ref` patterns", "tree": {"sha": "5b8bf6c596797e752b0eb0dd00a8eeb1b9cdbb93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b8bf6c596797e752b0eb0dd00a8eeb1b9cdbb93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bddbf38af29dcfe5ebe12efebf465233fbb52398", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bddbf38af29dcfe5ebe12efebf465233fbb52398", "html_url": "https://github.com/rust-lang/rust/commit/bddbf38af29dcfe5ebe12efebf465233fbb52398", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bddbf38af29dcfe5ebe12efebf465233fbb52398/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc6cda860345b734f7c5e39b7801e3fa4cbaaba0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc6cda860345b734f7c5e39b7801e3fa4cbaaba0", "html_url": "https://github.com/rust-lang/rust/commit/fc6cda860345b734f7c5e39b7801e3fa4cbaaba0"}], "stats": {"total": 157, "additions": 75, "deletions": 82}, "files": [{"sha": "951d59246785d08bff71641690fe154308428a34", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=bddbf38af29dcfe5ebe12efebf465233fbb52398", "patch": "@@ -63,21 +63,21 @@ pub enum Annotatable {\n \n impl Annotatable {\n     pub fn span(&self) -> Span {\n-        match *self {\n-            Annotatable::Item(ref item) => item.span,\n-            Annotatable::TraitItem(ref trait_item) => trait_item.span,\n-            Annotatable::ImplItem(ref impl_item) => impl_item.span,\n-            Annotatable::ForeignItem(ref foreign_item) => foreign_item.span,\n-            Annotatable::Stmt(ref stmt) => stmt.span,\n-            Annotatable::Expr(ref expr) => expr.span,\n-            Annotatable::Arm(ref arm) => arm.span,\n-            Annotatable::ExprField(ref field) => field.span,\n-            Annotatable::PatField(ref fp) => fp.pat.span,\n-            Annotatable::GenericParam(ref gp) => gp.ident.span,\n-            Annotatable::Param(ref p) => p.span,\n-            Annotatable::FieldDef(ref sf) => sf.span,\n-            Annotatable::Variant(ref v) => v.span,\n-            Annotatable::Crate(ref c) => c.spans.inner_span,\n+        match self {\n+            Annotatable::Item(item) => item.span,\n+            Annotatable::TraitItem(trait_item) => trait_item.span,\n+            Annotatable::ImplItem(impl_item) => impl_item.span,\n+            Annotatable::ForeignItem(foreign_item) => foreign_item.span,\n+            Annotatable::Stmt(stmt) => stmt.span,\n+            Annotatable::Expr(expr) => expr.span,\n+            Annotatable::Arm(arm) => arm.span,\n+            Annotatable::ExprField(field) => field.span,\n+            Annotatable::PatField(fp) => fp.pat.span,\n+            Annotatable::GenericParam(gp) => gp.ident.span,\n+            Annotatable::Param(p) => p.span,\n+            Annotatable::FieldDef(sf) => sf.span,\n+            Annotatable::Variant(v) => v.span,\n+            Annotatable::Crate(c) => c.spans.inner_span,\n         }\n     }\n "}, {"sha": "1fcbdfd9be5ce14353b7f1c572e2af7d6333f42b", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=bddbf38af29dcfe5ebe12efebf465233fbb52398", "patch": "@@ -298,7 +298,7 @@ impl<'a> StripUnconfigured<'a> {\n                     Some(AttrTokenTree::Delimited(sp, delim, inner))\n                         .into_iter()\n                 }\n-                AttrTokenTree::Token(ref token, _) if let TokenKind::Interpolated(ref nt) = token.kind => {\n+                AttrTokenTree::Token(ref token, _) if let TokenKind::Interpolated(nt) = &token.kind => {\n                     panic!(\n                         \"Nonterminal should have been flattened at {:?}: {:?}\",\n                         token.span, nt"}, {"sha": "79d058d9c97360d0aec61b0128d8ad140e14593d", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=bddbf38af29dcfe5ebe12efebf465233fbb52398", "patch": "@@ -144,12 +144,12 @@ macro_rules! ast_fragments {\n             }\n \n             pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n-                match *self {\n-                    AstFragment::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n+                match self {\n+                    AstFragment::OptExpr(Some(expr)) => visitor.visit_expr(expr),\n                     AstFragment::OptExpr(None) => {}\n-                    AstFragment::MethodReceiverExpr(ref expr) => visitor.visit_method_receiver_expr(expr),\n-                    $($(AstFragment::$Kind(ref ast) => visitor.$visit_ast(ast),)?)*\n-                    $($(AstFragment::$Kind(ref ast) => for ast_elt in &ast[..] {\n+                    AstFragment::MethodReceiverExpr(expr) => visitor.visit_method_receiver_expr(expr),\n+                    $($(AstFragment::$Kind(ast) => visitor.$visit_ast(ast),)?)*\n+                    $($(AstFragment::$Kind(ast) => for ast_elt in &ast[..] {\n                         visitor.$visit_ast_elt(ast_elt, $($args)*);\n                     })?)*\n                 }\n@@ -592,7 +592,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let expn_id = invoc.expansion_data.id;\n                     let parent_def = self.cx.resolver.invocation_parent(expn_id);\n                     let span = match &mut invoc.kind {\n-                        InvocationKind::Bang { ref mut span, .. } => span,\n+                        InvocationKind::Bang { span, .. } => span,\n                         InvocationKind::Attr { attr, .. } => &mut attr.span,\n                         InvocationKind::Derive { path, .. } => &mut path.span,\n                     };\n@@ -945,8 +945,8 @@ pub fn ensure_complete_parse<'a>(\n         let def_site_span = parser.token.span.with_ctxt(SyntaxContext::root());\n \n         let semi_span = parser.sess.source_map().next_point(span);\n-        let add_semicolon = match parser.sess.source_map().span_to_snippet(semi_span) {\n-            Ok(ref snippet) if &snippet[..] != \";\" && kind_name == \"expression\" => {\n+        let add_semicolon = match &parser.sess.source_map().span_to_snippet(semi_span) {\n+            Ok(snippet) if &snippet[..] != \";\" && kind_name == \"expression\" => {\n                 Some(span.shrink_to_hi())\n             }\n             _ => None,"}, {"sha": "5be134f4e664c80c189cefab7d41baa380b41045", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=bddbf38af29dcfe5ebe12efebf465233fbb52398", "patch": "@@ -151,9 +151,9 @@ impl<'a, T> Iterator for &'a Stack<'a, T> {\n \n     // Iterates from top to bottom of the stack.\n     fn next(&mut self) -> Option<&'a T> {\n-        match *self {\n+        match self {\n             Stack::Empty => None,\n-            Stack::Push { ref top, ref prev } => {\n+            Stack::Push { top, prev } => {\n                 *self = prev;\n                 Some(top)\n             }\n@@ -437,8 +437,8 @@ fn check_nested_occurrences(\n                 // We check that the meta-variable is correctly used.\n                 check_occurrences(sess, node_id, tt, macros, binders, ops, valid);\n             }\n-            (NestedMacroState::MacroRulesNotName, &TokenTree::Delimited(_, ref del))\n-            | (NestedMacroState::MacroName, &TokenTree::Delimited(_, ref del))\n+            (NestedMacroState::MacroRulesNotName, TokenTree::Delimited(_, del))\n+            | (NestedMacroState::MacroName, TokenTree::Delimited(_, del))\n                 if del.delim == Delimiter::Brace =>\n             {\n                 let macro_rules = state == NestedMacroState::MacroRulesNotName;\n@@ -497,7 +497,7 @@ fn check_nested_occurrences(\n                     valid,\n                 );\n             }\n-            (_, ref tt) => {\n+            (_, tt) => {\n                 state = NestedMacroState::Empty;\n                 check_occurrences(sess, node_id, tt, macros, binders, ops, valid);\n             }"}, {"sha": "4ebd75f0185604b0038a3ea8d8c70ac489344af7", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=bddbf38af29dcfe5ebe12efebf465233fbb52398", "patch": "@@ -486,11 +486,11 @@ pub fn compile_declarative_macro(\n     let mut valid = true;\n \n     // Extract the arguments:\n-    let lhses = match argument_map[&MacroRulesNormalizedIdent::new(lhs_nm)] {\n-        MatchedSeq(ref s) => s\n+    let lhses = match &argument_map[&MacroRulesNormalizedIdent::new(lhs_nm)] {\n+        MatchedSeq(s) => s\n             .iter()\n             .map(|m| {\n-                if let MatchedTokenTree(ref tt) = *m {\n+                if let MatchedTokenTree(tt) = m {\n                     let tt = mbe::quoted::parse(\n                         TokenStream::new(vec![tt.clone()]),\n                         true,\n@@ -510,11 +510,11 @@ pub fn compile_declarative_macro(\n         _ => sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\"),\n     };\n \n-    let rhses = match argument_map[&MacroRulesNormalizedIdent::new(rhs_nm)] {\n-        MatchedSeq(ref s) => s\n+    let rhses = match &argument_map[&MacroRulesNormalizedIdent::new(rhs_nm)] {\n+        MatchedSeq(s) => s\n             .iter()\n             .map(|m| {\n-                if let MatchedTokenTree(ref tt) = *m {\n+                if let MatchedTokenTree(tt) = m {\n                     return mbe::quoted::parse(\n                         TokenStream::new(vec![tt.clone()]),\n                         false,\n@@ -624,21 +624,21 @@ fn check_lhs_nt_follows(sess: &ParseSess, def: &ast::Item, lhs: &mbe::TokenTree)\n fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n     use mbe::TokenTree;\n     for tt in tts {\n-        match *tt {\n+        match tt {\n             TokenTree::Token(..)\n             | TokenTree::MetaVar(..)\n             | TokenTree::MetaVarDecl(..)\n             | TokenTree::MetaVarExpr(..) => (),\n-            TokenTree::Delimited(_, ref del) => {\n+            TokenTree::Delimited(_, del) => {\n                 if !check_lhs_no_empty_seq(sess, &del.tts) {\n                     return false;\n                 }\n             }\n-            TokenTree::Sequence(span, ref seq) => {\n+            TokenTree::Sequence(span, seq) => {\n                 if seq.separator.is_none()\n-                    && seq.tts.iter().all(|seq_tt| match *seq_tt {\n+                    && seq.tts.iter().all(|seq_tt| match seq_tt {\n                         TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Vis)) => true,\n-                        TokenTree::Sequence(_, ref sub_seq) => {\n+                        TokenTree::Sequence(_, sub_seq) => {\n                             sub_seq.kleene.op == mbe::KleeneOp::ZeroOrMore\n                                 || sub_seq.kleene.op == mbe::KleeneOp::ZeroOrOne\n                         }\n@@ -736,21 +736,21 @@ impl<'tt> FirstSets<'tt> {\n         fn build_recur<'tt>(sets: &mut FirstSets<'tt>, tts: &'tt [TokenTree]) -> TokenSet<'tt> {\n             let mut first = TokenSet::empty();\n             for tt in tts.iter().rev() {\n-                match *tt {\n+                match tt {\n                     TokenTree::Token(..)\n                     | TokenTree::MetaVar(..)\n                     | TokenTree::MetaVarDecl(..)\n                     | TokenTree::MetaVarExpr(..) => {\n                         first.replace_with(TtHandle::TtRef(tt));\n                     }\n-                    TokenTree::Delimited(span, ref delimited) => {\n+                    TokenTree::Delimited(span, delimited) => {\n                         build_recur(sets, &delimited.tts);\n                         first.replace_with(TtHandle::from_token_kind(\n                             token::OpenDelim(delimited.delim),\n                             span.open,\n                         ));\n                     }\n-                    TokenTree::Sequence(sp, ref seq_rep) => {\n+                    TokenTree::Sequence(sp, seq_rep) => {\n                         let subfirst = build_recur(sets, &seq_rep.tts);\n \n                         match sets.first.entry(sp.entire()) {\n@@ -804,22 +804,22 @@ impl<'tt> FirstSets<'tt> {\n         let mut first = TokenSet::empty();\n         for tt in tts.iter() {\n             assert!(first.maybe_empty);\n-            match *tt {\n+            match tt {\n                 TokenTree::Token(..)\n                 | TokenTree::MetaVar(..)\n                 | TokenTree::MetaVarDecl(..)\n                 | TokenTree::MetaVarExpr(..) => {\n                     first.add_one(TtHandle::TtRef(tt));\n                     return first;\n                 }\n-                TokenTree::Delimited(span, ref delimited) => {\n+                TokenTree::Delimited(span, delimited) => {\n                     first.add_one(TtHandle::from_token_kind(\n                         token::OpenDelim(delimited.delim),\n                         span.open,\n                     ));\n                     return first;\n                 }\n-                TokenTree::Sequence(sp, ref seq_rep) => {\n+                TokenTree::Sequence(sp, seq_rep) => {\n                     let subfirst_owned;\n                     let subfirst = match self.first.get(&sp.entire()) {\n                         Some(Some(subfirst)) => subfirst,\n@@ -1041,7 +1041,7 @@ fn check_matcher_core<'tt>(\n \n         // First, update `last` so that it corresponds to the set\n         // of NT tokens that might end the sequence `... token`.\n-        match *token {\n+        match token {\n             TokenTree::Token(..)\n             | TokenTree::MetaVar(..)\n             | TokenTree::MetaVarDecl(..)\n@@ -1057,7 +1057,7 @@ fn check_matcher_core<'tt>(\n                     suffix_first = build_suffix_first();\n                 }\n             }\n-            TokenTree::Delimited(span, ref d) => {\n+            TokenTree::Delimited(span, d) => {\n                 let my_suffix = TokenSet::singleton(TtHandle::from_token_kind(\n                     token::CloseDelim(d.delim),\n                     span.close,\n@@ -1070,7 +1070,7 @@ fn check_matcher_core<'tt>(\n                 // against SUFFIX\n                 continue 'each_token;\n             }\n-            TokenTree::Sequence(_, ref seq_rep) => {\n+            TokenTree::Sequence(_, seq_rep) => {\n                 suffix_first = build_suffix_first();\n                 // The trick here: when we check the interior, we want\n                 // to include the separator (if any) as a potential\n@@ -1372,8 +1372,8 @@ fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n }\n \n fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n-    match *tt {\n-        mbe::TokenTree::Token(ref token) => pprust::token_to_string(&token).into(),\n+    match tt {\n+        mbe::TokenTree::Token(token) => pprust::token_to_string(&token).into(),\n         mbe::TokenTree::MetaVar(_, name) => format!(\"${}\", name),\n         mbe::TokenTree::MetaVarDecl(_, name, Some(kind)) => format!(\"${}:{}\", name, kind),\n         mbe::TokenTree::MetaVarDecl(_, name, None) => format!(\"${}:\", name),"}, {"sha": "b79835be73a7ec1dfd04438ea4257c8cc326bda7", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=bddbf38af29dcfe5ebe12efebf465233fbb52398", "patch": "@@ -47,8 +47,7 @@ impl<'a> Iterator for Frame<'a> {\n \n     fn next(&mut self) -> Option<&'a mbe::TokenTree> {\n         match self {\n-            Frame::Delimited { tts, ref mut idx, .. }\n-            | Frame::Sequence { tts, ref mut idx, .. } => {\n+            Frame::Delimited { tts, idx, .. } | Frame::Sequence { tts, idx, .. } => {\n                 let res = tts.get(*idx);\n                 *idx += 1;\n                 res\n@@ -220,13 +219,13 @@ pub(super) fn transcribe<'a>(\n                 let ident = MacroRulesNormalizedIdent::new(original_ident);\n                 if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n                     match cur_matched {\n-                        MatchedTokenTree(ref tt) => {\n+                        MatchedTokenTree(tt) => {\n                             // `tt`s are emitted into the output stream directly as \"raw tokens\",\n                             // without wrapping them into groups.\n                             let token = tt.clone();\n                             result.push(token);\n                         }\n-                        MatchedNonterminal(ref nt) => {\n+                        MatchedNonterminal(nt) => {\n                             // Other variables are emitted into the output stream as groups with\n                             // `Delimiter::Invisible` to maintain parsing priorities.\n                             // `Interpolated` is currently used for such groups in rustc parser.\n@@ -299,12 +298,11 @@ fn lookup_cur_matched<'a>(\n     interpolations: &'a FxHashMap<MacroRulesNormalizedIdent, NamedMatch>,\n     repeats: &[(usize, usize)],\n ) -> Option<&'a NamedMatch> {\n-    interpolations.get(&ident).map(|matched| {\n-        let mut matched = matched;\n+    interpolations.get(&ident).map(|mut matched| {\n         for &(idx, _) in repeats {\n             match matched {\n                 MatchedTokenTree(_) | MatchedNonterminal(_) => break,\n-                MatchedSeq(ref ads) => matched = ads.get(idx).unwrap(),\n+                MatchedSeq(ads) => matched = ads.get(idx).unwrap(),\n             }\n         }\n \n@@ -339,7 +337,7 @@ impl LockstepIterSize {\n         match self {\n             LockstepIterSize::Unconstrained => other,\n             LockstepIterSize::Contradiction(_) => self,\n-            LockstepIterSize::Constraint(l_len, ref l_id) => match other {\n+            LockstepIterSize::Constraint(l_len, l_id) => match other {\n                 LockstepIterSize::Unconstrained => self,\n                 LockstepIterSize::Contradiction(_) => other,\n                 LockstepIterSize::Constraint(r_len, _) if l_len == r_len => self,\n@@ -378,33 +376,33 @@ fn lockstep_iter_size(\n     repeats: &[(usize, usize)],\n ) -> LockstepIterSize {\n     use mbe::TokenTree;\n-    match *tree {\n-        TokenTree::Delimited(_, ref delimited) => {\n+    match tree {\n+        TokenTree::Delimited(_, delimited) => {\n             delimited.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n                 size.with(lockstep_iter_size(tt, interpolations, repeats))\n             })\n         }\n-        TokenTree::Sequence(_, ref seq) => {\n+        TokenTree::Sequence(_, seq) => {\n             seq.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n                 size.with(lockstep_iter_size(tt, interpolations, repeats))\n             })\n         }\n         TokenTree::MetaVar(_, name) | TokenTree::MetaVarDecl(_, name, _) => {\n-            let name = MacroRulesNormalizedIdent::new(name);\n+            let name = MacroRulesNormalizedIdent::new(*name);\n             match lookup_cur_matched(name, interpolations, repeats) {\n                 Some(matched) => match matched {\n                     MatchedTokenTree(_) | MatchedNonterminal(_) => LockstepIterSize::Unconstrained,\n-                    MatchedSeq(ref ads) => LockstepIterSize::Constraint(ads.len(), name),\n+                    MatchedSeq(ads) => LockstepIterSize::Constraint(ads.len(), name),\n                 },\n                 _ => LockstepIterSize::Unconstrained,\n             }\n         }\n-        TokenTree::MetaVarExpr(_, ref expr) => {\n+        TokenTree::MetaVarExpr(_, expr) => {\n             let default_rslt = LockstepIterSize::Unconstrained;\n             let Some(ident) = expr.ident() else { return default_rslt; };\n             let name = MacroRulesNormalizedIdent::new(ident);\n             match lookup_cur_matched(name, interpolations, repeats) {\n-                Some(MatchedSeq(ref ads)) => {\n+                Some(MatchedSeq(ads)) => {\n                     default_rslt.with(LockstepIterSize::Constraint(ads.len(), name))\n                 }\n                 _ => default_rslt,\n@@ -449,7 +447,7 @@ fn count_repetitions<'a>(\n                     Some(_) => Err(out_of_bounds_err(cx, declared_lhs_depth, sp.entire(), \"count\")),\n                 }\n             }\n-            MatchedSeq(ref named_matches) => {\n+            MatchedSeq(named_matches) => {\n                 let new_declared_lhs_depth = declared_lhs_depth + 1;\n                 match depth_opt {\n                     None => named_matches\n@@ -472,7 +470,7 @@ fn count_repetitions<'a>(\n     // before we start counting. `matched` contains the various levels of the\n     // tree as we descend, and its final value is the subtree we are currently at.\n     for &(idx, _) in repeats {\n-        if let MatchedSeq(ref ads) = matched {\n+        if let MatchedSeq(ads) = matched {\n             matched = &ads[idx];\n         }\n     }"}, {"sha": "0726d922c84a3e494ccbec353c20e6df333ccd73", "filename": "compiler/rustc_expand/src/parse/tests.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs?ref=bddbf38af29dcfe5ebe12efebf465233fbb52398", "patch": "@@ -176,9 +176,9 @@ fn get_spans_of_pat_idents(src: &str) -> Vec<Span> {\n     }\n     impl<'a> visit::Visitor<'a> for PatIdentVisitor {\n         fn visit_pat(&mut self, p: &'a ast::Pat) {\n-            match p.kind {\n-                PatKind::Ident(_, ref ident, _) => {\n-                    self.spans.push(ident.span.clone());\n+            match &p.kind {\n+                PatKind::Ident(_, ident, _) => {\n+                    self.spans.push(ident.span);\n                 }\n                 _ => {\n                     visit::walk_pat(self, p);\n@@ -290,10 +290,8 @@ fn ttdelim_span() {\n         )\n         .unwrap();\n \n-        let tts: Vec<_> = match expr.kind {\n-            ast::ExprKind::MacCall(ref mac) => mac.args.tokens.clone().into_trees().collect(),\n-            _ => panic!(\"not a macro\"),\n-        };\n+        let ast::ExprKind::MacCall(mac) = &expr.kind else { panic!(\"not a macro\") };\n+        let tts: Vec<_> = mac.args.tokens.clone().into_trees().collect();\n \n         let span = tts.iter().rev().next().unwrap().span();\n \n@@ -318,11 +316,8 @@ fn out_of_line_mod() {\n         .unwrap()\n         .unwrap();\n \n-        if let ast::ItemKind::Mod(_, ref mod_kind) = item.kind {\n-            assert!(matches!(mod_kind, ast::ModKind::Loaded(items, ..) if items.len() == 2));\n-        } else {\n-            panic!();\n-        }\n+        let ast::ItemKind::Mod(_, mod_kind) = &item.kind else { panic!() };\n+        assert!(matches!(mod_kind, ast::ModKind::Loaded(items, ..) if items.len() == 2));\n     });\n }\n "}, {"sha": "df59c1132cc1b0057558d81a595e374d2e36ca02", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bddbf38af29dcfe5ebe12efebf465233fbb52398/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=bddbf38af29dcfe5ebe12efebf465233fbb52398", "patch": "@@ -597,8 +597,8 @@ impl server::SourceFile for Rustc<'_, '_> {\n     }\n \n     fn path(&mut self, file: &Self::SourceFile) -> String {\n-        match file.name {\n-            FileName::Real(ref name) => name\n+        match &file.name {\n+            FileName::Real(name) => name\n                 .local_path()\n                 .expect(\"attempting to get a file path in an imported file in `proc_macro::SourceFile::path`\")\n                 .to_str()"}]}