{"sha": "8d239a256d39eb2527ddd40e34d14a2e1801fb61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMjM5YTI1NmQzOWViMjUyN2RkZDQwZTM0ZDE0YTJlMTgwMWZiNjE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-26T14:28:14Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-27T04:48:06Z"}, "message": "libsyntax: change closures to take fn(&Parser)", "tree": {"sha": "7600662ca87a8ec92461190a47efbb1c88a77155", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7600662ca87a8ec92461190a47efbb1c88a77155"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d239a256d39eb2527ddd40e34d14a2e1801fb61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d239a256d39eb2527ddd40e34d14a2e1801fb61", "html_url": "https://github.com/rust-lang/rust/commit/8d239a256d39eb2527ddd40e34d14a2e1801fb61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d239a256d39eb2527ddd40e34d14a2e1801fb61/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "375c2982971662a26afda5e2aac437ccf81a9872", "url": "https://api.github.com/repos/rust-lang/rust/commits/375c2982971662a26afda5e2aac437ccf81a9872", "html_url": "https://github.com/rust-lang/rust/commit/375c2982971662a26afda5e2aac437ccf81a9872"}], "stats": {"total": 66, "additions": 33, "deletions": 33}, "files": [{"sha": "28c5bf721a187b8c1dcd93f900ffa530fba7e6f1", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8d239a256d39eb2527ddd40e34d14a2e1801fb61/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d239a256d39eb2527ddd40e34d14a2e1801fb61/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=8d239a256d39eb2527ddd40e34d14a2e1801fb61", "patch": "@@ -250,7 +250,7 @@ pub impl Parser {\n     // before the '>'.\n     fn parse_seq_to_before_gt<T: Copy>(\n         sep: Option<token::Token>,\n-        f: fn(Parser) -> T\n+        f: fn(&Parser) -> T\n     ) -> ~[T] {\n         let mut first = true;\n         let mut v = ~[];\n@@ -263,15 +263,15 @@ pub impl Parser {\n               }\n               _ => ()\n             }\n-            v.push(f(self));\n+            v.push(f(&self));\n         }\n \n         return v;\n     }\n \n     fn parse_seq_to_gt<T: Copy>(\n         sep: Option<token::Token>,\n-        f: fn(Parser) -> T\n+        f: fn(&Parser) -> T\n     ) -> ~[T] {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n@@ -282,7 +282,7 @@ pub impl Parser {\n     // parse a sequence bracketed by '<' and '>'\n     fn parse_seq_lt_gt<T: Copy>(\n         sep: Option<token::Token>,\n-        f: fn(Parser) -> T\n+        f: fn(&Parser) -> T\n     ) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(&token::LT);\n@@ -298,7 +298,7 @@ pub impl Parser {\n     fn parse_seq_to_end<T: Copy>(\n         ket: &token::Token,\n         sep: SeqSep,\n-        f: fn(Parser) -> T\n+        f: fn(&Parser) -> T\n     ) -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n@@ -311,7 +311,7 @@ pub impl Parser {\n     fn parse_seq_to_before_end<T: Copy>(\n         ket: &token::Token,\n         sep: SeqSep,\n-        f: fn(Parser) -> T\n+        f: fn(&Parser) -> T\n     ) -> ~[T] {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n@@ -324,7 +324,7 @@ pub impl Parser {\n               _ => ()\n             }\n             if sep.trailing_sep_allowed && *self.token == *ket { break; }\n-            v.push(f(self));\n+            v.push(f(&self));\n         }\n         return v;\n     }\n@@ -336,7 +336,7 @@ pub impl Parser {\n         bra: &token::Token,\n         ket: &token::Token,\n         sep: SeqSep,\n-        f: fn(Parser) -> T\n+        f: fn(&Parser) -> T\n     ) -> ~[T] {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n@@ -350,7 +350,7 @@ pub impl Parser {\n         bra: &token::Token,\n         ket: &token::Token,\n         sep: SeqSep,\n-        f: fn(Parser) -> T\n+        f: fn(&Parser) -> T\n     ) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);"}, {"sha": "694e83879588ac3adeee51d4da26158501bd4485", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8d239a256d39eb2527ddd40e34d14a2e1801fb61/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d239a256d39eb2527ddd40e34d14a2e1801fb61/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8d239a256d39eb2527ddd40e34d14a2e1801fb61", "patch": "@@ -768,15 +768,15 @@ pub impl Parser {\n         }\n     }\n \n-    fn parse_capture_item_or(parse_arg_fn: fn(Parser) -> arg_or_capture_item)\n+    fn parse_capture_item_or(parse_arg_fn: fn(&Parser) -> arg_or_capture_item)\n         -> arg_or_capture_item\n     {\n         if self.eat_keyword(&~\"copy\") {\n             // XXX outdated syntax now that moves-based-on-type has gone in\n             self.parse_ident();\n             either::Right(())\n         } else {\n-            parse_arg_fn(self)\n+            parse_arg_fn(&self)\n         }\n     }\n \n@@ -893,8 +893,8 @@ pub impl Parser {\n     }\n \n     fn parse_path_without_tps_(\n-        parse_ident: fn(Parser) -> ident,\n-        parse_last_ident: fn(Parser) -> ident) -> @path {\n+        parse_ident: fn(&Parser) -> ident,\n+        parse_last_ident: fn(&Parser) -> ident) -> @path {\n \n         maybe_whole!(self, nt_path);\n         let lo = self.span.lo;\n@@ -906,10 +906,10 @@ pub impl Parser {\n                 && self.look_ahead(1u) == token::MOD_SEP;\n \n             if is_not_last {\n-                ids.push(parse_ident(self));\n+                ids.push(parse_ident(&self));\n                 self.expect(&token::MOD_SEP);\n             } else {\n-                ids.push(parse_last_ident(self));\n+                ids.push(parse_last_ident(&self));\n                 break;\n             }\n         }\n@@ -1415,7 +1415,7 @@ pub impl Parser {\n     fn parse_token_tree() -> token_tree {\n         maybe_whole!(deref self, nt_tt);\n \n-        fn parse_non_delim_tt_tok(p: Parser) -> token_tree {\n+        fn parse_non_delim_tt_tok(p: &Parser) -> token_tree {\n             maybe_whole!(deref p, nt_tt);\n             match *p.token {\n               token::RPAREN | token::RBRACE | token::RBRACKET\n@@ -1452,7 +1452,7 @@ pub impl Parser {\n         }\n \n         // turn the next token into a tt_tok:\n-        fn parse_any_tt_tok(p: Parser) -> token_tree{\n+        fn parse_any_tt_tok(p: &Parser) -> token_tree{\n             let res = tt_tok(*p.span, *p.token);\n             p.bump();\n             res\n@@ -1468,20 +1468,20 @@ pub impl Parser {\n                 tt_delim(\n                     vec::append(\n                         // the open delimiter:\n-                        ~[parse_any_tt_tok(self)],\n+                        ~[parse_any_tt_tok(&self)],\n                         vec::append(\n                             self.parse_seq_to_before_end(\n                                 &ket,\n                                 seq_sep_none(),\n                                 |p| p.parse_token_tree()\n                             ),\n                             // the close delimiter:\n-                            ~[parse_any_tt_tok(self)]\n+                            ~[parse_any_tt_tok(&self)]\n                         )\n                     )\n                 )\n             }\n-            _ => parse_non_delim_tt_tok(self)\n+            _ => parse_non_delim_tt_tok(&self)\n         }\n     }\n \n@@ -2441,7 +2441,7 @@ pub impl Parser {\n     fn parse_stmt(+first_item_attrs: ~[attribute]) -> @stmt {\n         maybe_whole!(self, nt_stmt);\n \n-        fn check_expected_item(p: Parser, current_attrs: ~[attribute]) {\n+        fn check_expected_item(p: &Parser, current_attrs: ~[attribute]) {\n             // If we have attributes then we should have an item\n             if !current_attrs.is_empty() {\n                 p.fatal(~\"expected item after attrs\");\n@@ -2450,15 +2450,15 @@ pub impl Parser {\n \n         let lo = self.span.lo;\n         if self.is_keyword(&~\"let\") {\n-            check_expected_item(self, first_item_attrs);\n+            check_expected_item(&self, first_item_attrs);\n             self.expect_keyword(&~\"let\");\n             let decl = self.parse_let();\n             return @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n         } else if is_ident(&*self.token)\n             && !self.is_any_keyword(&copy *self.token)\n             && self.look_ahead(1) == token::NOT {\n \n-            check_expected_item(self, first_item_attrs);\n+            check_expected_item(&self, first_item_attrs);\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n@@ -2514,7 +2514,7 @@ pub impl Parser {\n               iovi_none() => { /* fallthrough */ }\n             }\n \n-            check_expected_item(self, item_attrs);\n+            check_expected_item(&self, item_attrs);\n \n             // Remainder are line-expr stmts.\n             let e = self.parse_expr_res(RESTRICT_STMT_EXPR);\n@@ -2538,7 +2538,7 @@ pub impl Parser {\n \n         maybe_whole!(pair_empty self, nt_block);\n \n-        fn maybe_parse_inner_attrs_and_next(p: Parser, parse_attrs: bool) ->\n+        fn maybe_parse_inner_attrs_and_next(p: &Parser, parse_attrs: bool) ->\n             (~[attribute], ~[attribute]) {\n             if parse_attrs {\n                 p.parse_inner_attrs_and_next()\n@@ -2553,7 +2553,7 @@ pub impl Parser {\n         }\n         self.expect(&token::LBRACE);\n         let (inner, next) =\n-            maybe_parse_inner_attrs_and_next(self, parse_attrs);\n+            maybe_parse_inner_attrs_and_next(&self, parse_attrs);\n \n         (inner, self.parse_block_tail_(lo, default_blk, next))\n     }\n@@ -2780,7 +2780,7 @@ pub impl Parser {\n         } else { ~[] }\n     }\n \n-    fn parse_fn_decl(parse_arg_fn: fn(Parser) -> arg_or_capture_item)\n+    fn parse_fn_decl(parse_arg_fn: fn(&Parser) -> arg_or_capture_item)\n         -> fn_decl\n     {\n         let args_or_capture_items: ~[arg_or_capture_item] =\n@@ -2823,11 +2823,11 @@ pub impl Parser {\n \n     fn parse_fn_decl_with_self(\n         parse_arg_fn:\n-        fn(Parser) -> arg_or_capture_item\n+        fn(&Parser) -> arg_or_capture_item\n     ) -> (self_ty, fn_decl) {\n         fn maybe_parse_self_ty(\n             cnstr: fn(+v: mutability) -> ast::self_ty_,\n-            p: Parser\n+            p: &Parser\n         ) -> ast::self_ty_ {\n             // We need to make sure it isn't a mode or a type\n             if p.token_is_keyword(&~\"self\", &p.look_ahead(1)) ||\n@@ -2851,13 +2851,13 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let self_ty = match *self.token {\n           token::BINOP(token::AND) => {\n-            maybe_parse_self_ty(sty_region, self)\n+            maybe_parse_self_ty(sty_region, &self)\n           }\n           token::AT => {\n-            maybe_parse_self_ty(sty_box, self)\n+            maybe_parse_self_ty(sty_box, &self)\n           }\n           token::TILDE => {\n-            maybe_parse_self_ty(sty_uniq, self)\n+            maybe_parse_self_ty(sty_uniq, &self)\n           }\n           token::IDENT(*) if self.is_self_ident() => {\n             self.bump();\n@@ -3028,7 +3028,7 @@ pub impl Parser {\n     //    impl<T> ~[T] : to_str { ... }\n     //    impl<T> to_str for ~[T] { ... }\n     fn parse_item_impl() -> item_info {\n-        fn wrap_path(p: Parser, pt: @path) -> @Ty {\n+        fn wrap_path(p: &Parser, pt: @path) -> @Ty {\n             @Ty {\n                 id: p.get_id(),\n                 node: ty_path(pt, p.get_id()),"}]}