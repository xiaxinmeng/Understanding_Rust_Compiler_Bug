{"sha": "368653081558ab389c6543d6b5027859e26beb3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ODY1MzA4MTU1OGFiMzg5YzY1NDNkNmI1MDI3ODU5ZTI2YmViM2I=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-27T13:48:48Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-27T13:48:48Z"}, "message": "Decouple", "tree": {"sha": "e3531a5793be8b0d48c0246fccfcf81373e286dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3531a5793be8b0d48c0246fccfcf81373e286dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/368653081558ab389c6543d6b5027859e26beb3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/368653081558ab389c6543d6b5027859e26beb3b", "html_url": "https://github.com/rust-lang/rust/commit/368653081558ab389c6543d6b5027859e26beb3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/368653081558ab389c6543d6b5027859e26beb3b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12501fcdd02fec9d43dfd810d65e927ddebb1b56", "url": "https://api.github.com/repos/rust-lang/rust/commits/12501fcdd02fec9d43dfd810d65e927ddebb1b56", "html_url": "https://github.com/rust-lang/rust/commit/12501fcdd02fec9d43dfd810d65e927ddebb1b56"}], "stats": {"total": 35, "additions": 15, "deletions": 20}, "files": [{"sha": "2d447f1ea711193e4b76e411944ff7101dacc2fa", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/368653081558ab389c6543d6b5027859e26beb3b/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368653081558ab389c6543d6b5027859e26beb3b/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=368653081558ab389c6543d6b5027859e26beb3b", "patch": "@@ -31,7 +31,6 @@ use crate::{\n         utils::{all_super_traits, associated_type_by_name_including_super_traits, variant_data},\n     },\n     util::make_mut_slice,\n-    ImplBlock, Trait,\n };\n \n impl Ty {\n@@ -148,13 +147,8 @@ impl Ty {\n     ) -> Ty {\n         let ty = match resolution {\n             TypeNs::TraitId(trait_) => {\n-                let trait_ref = TraitRef::from_resolved_path(\n-                    db,\n-                    resolver,\n-                    trait_.into(),\n-                    resolved_segment,\n-                    None,\n-                );\n+                let trait_ref =\n+                    TraitRef::from_resolved_path(db, resolver, trait_, resolved_segment, None);\n                 return if remaining_segments.len() == 1 {\n                     let segment = &remaining_segments[0];\n                     let associated_ty = associated_type_by_name_including_super_traits(\n@@ -187,7 +181,11 @@ impl Ty {\n                 let name = resolved_segment.name.clone();\n                 Ty::Param { idx, name }\n             }\n-            TypeNs::SelfType(impl_block) => ImplBlock::from(impl_block).target_ty(db),\n+            TypeNs::SelfType(impl_id) => {\n+                let impl_data = db.impl_data(impl_id);\n+                let resolver = impl_id.resolver(db);\n+                Ty::from_hir(db, &resolver, &impl_data.target_type)\n+            }\n             TypeNs::AdtSelfType(adt) => db.ty(adt.into()),\n \n             TypeNs::AdtId(it) => Ty::from_hir_path_inner(db, resolver, resolved_segment, it.into()),\n@@ -250,14 +248,11 @@ impl Ty {\n             GenericPredicate::Implemented(tr) if tr.self_ty() == &self_ty => Some(tr.trait_),\n             _ => None,\n         });\n-        let traits = traits_from_env.flat_map(|t| all_super_traits(db, t)).map(Trait::from);\n+        let traits = traits_from_env.flat_map(|t| all_super_traits(db, t));\n         for t in traits {\n-            if let Some(associated_ty) = db.trait_data(t.id).associated_type_by_name(&segment.name)\n-            {\n-                let substs = Substs::build_for_def(db, t.id)\n-                    .push(self_ty.clone())\n-                    .fill_with_unknown()\n-                    .build();\n+            if let Some(associated_ty) = db.trait_data(t).associated_type_by_name(&segment.name) {\n+                let substs =\n+                    Substs::build_for_def(db, t).push(self_ty.clone()).fill_with_unknown().build();\n                 // FIXME handle type parameters on the segment\n                 return Ty::Projection(ProjectionTy { associated_ty, parameters: substs });\n             }\n@@ -391,15 +386,15 @@ impl TraitRef {\n     pub(super) fn from_resolved_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n-        resolved: Trait,\n+        resolved: TraitId,\n         segment: &PathSegment,\n         explicit_self_ty: Option<Ty>,\n     ) -> Self {\n         let mut substs = TraitRef::substs_from_path(db, resolver, segment, resolved);\n         if let Some(self_ty) = explicit_self_ty {\n             make_mut_slice(&mut substs.0)[0] = self_ty;\n         }\n-        TraitRef { trait_: resolved.id, substs }\n+        TraitRef { trait_: resolved, substs }\n     }\n \n     pub(crate) fn from_hir(\n@@ -419,11 +414,11 @@ impl TraitRef {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         segment: &PathSegment,\n-        resolved: Trait,\n+        resolved: TraitId,\n     ) -> Substs {\n         let has_self_param =\n             segment.args_and_bindings.as_ref().map(|a| a.has_self_type).unwrap_or(false);\n-        substs_from_path_segment(db, resolver, segment, Some(resolved.id.into()), !has_self_param)\n+        substs_from_path_segment(db, resolver, segment, Some(resolved.into()), !has_self_param)\n     }\n \n     pub(crate) fn for_trait(db: &impl HirDatabase, trait_: TraitId) -> TraitRef {"}]}