{"sha": "6504c3c32a9795173fc0c9c94befe7f5d0e7fe9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MDRjM2MzMmE5Nzk1MTczZmMwYzljOTRiZWZlN2Y1ZDBlN2ZlOWU=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-06-21T20:57:54Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-06-22T22:19:54Z"}, "message": "Move subtree collection out of `TokenConvertor`", "tree": {"sha": "4738998b71657a0f39f5be4724b0e34a81ea4138", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4738998b71657a0f39f5be4724b0e34a81ea4138"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6504c3c32a9795173fc0c9c94befe7f5d0e7fe9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6504c3c32a9795173fc0c9c94befe7f5d0e7fe9e", "html_url": "https://github.com/rust-lang/rust/commit/6504c3c32a9795173fc0c9c94befe7f5d0e7fe9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6504c3c32a9795173fc0c9c94befe7f5d0e7fe9e/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38da41ea6e58255223686104b3fbca27392d8162", "url": "https://api.github.com/repos/rust-lang/rust/commits/38da41ea6e58255223686104b3fbca27392d8162", "html_url": "https://github.com/rust-lang/rust/commit/38da41ea6e58255223686104b3fbca27392d8162"}], "stats": {"total": 248, "additions": 124, "deletions": 124}, "files": [{"sha": "adf5a56ec7e427bd023232f9d9908a07336f7b8a", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 124, "deletions": 124, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/6504c3c32a9795173fc0c9c94befe7f5d0e7fe9e/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6504c3c32a9795173fc0c9c94befe7f5d0e7fe9e/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=6504c3c32a9795173fc0c9c94befe7f5d0e7fe9e", "patch": "@@ -24,7 +24,7 @@ pub fn ast_to_token_tree(ast: &impl ast::AstNode) -> (tt::Subtree, TokenMap) {\n pub fn syntax_node_to_token_tree(node: &SyntaxNode) -> (tt::Subtree, TokenMap) {\n     let global_offset = node.text_range().start();\n     let mut c = Convertor::new(node, global_offset);\n-    let subtree = c.go();\n+    let subtree = convert_tokens(&mut c);\n     c.id_alloc.map.shrink_to_fit();\n     (subtree, c.id_alloc.map)\n }\n@@ -80,7 +80,7 @@ pub fn parse_to_token_tree(text: &str) -> Option<(tt::Subtree, TokenMap)> {\n         },\n     };\n \n-    let subtree = conv.go();\n+    let subtree = convert_tokens(&mut conv);\n     Some((subtree, conv.id_alloc.map))\n }\n \n@@ -121,6 +121,128 @@ pub fn parse_exprs_with_sep(tt: &tt::Subtree, sep: char) -> Vec<tt::Subtree> {\n     res\n }\n \n+fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n+    let mut subtree = tt::Subtree { delimiter: None, ..Default::default() };\n+    while conv.peek().is_some() {\n+        collect_leaf(conv, &mut subtree.token_trees);\n+    }\n+    if subtree.token_trees.len() == 1 {\n+        if let tt::TokenTree::Subtree(first) = &subtree.token_trees[0] {\n+            return first.clone();\n+        }\n+    }\n+    return subtree;\n+\n+    fn collect_leaf<C: TokenConvertor>(conv: &mut C, result: &mut Vec<tt::TokenTree>) {\n+        let (token, range) = match conv.bump() {\n+            None => return,\n+            Some(it) => it,\n+        };\n+\n+        let k: SyntaxKind = token.kind();\n+        if k == COMMENT {\n+            if let Some(tokens) = conv.convert_doc_comment(&token) {\n+                result.extend(tokens);\n+            }\n+            return;\n+        }\n+\n+        result.push(if k.is_punct() && k != UNDERSCORE {\n+            assert_eq!(range.len(), TextSize::of('.'));\n+            let delim = match k {\n+                T!['('] => Some((tt::DelimiterKind::Parenthesis, T![')'])),\n+                T!['{'] => Some((tt::DelimiterKind::Brace, T!['}'])),\n+                T!['['] => Some((tt::DelimiterKind::Bracket, T![']'])),\n+                _ => None,\n+            };\n+\n+            if let Some((kind, closed)) = delim {\n+                let mut subtree = tt::Subtree::default();\n+                let (id, idx) = conv.id_alloc().open_delim(range);\n+                subtree.delimiter = Some(tt::Delimiter { id, kind });\n+\n+                while conv.peek().map_or(false, |it| it.kind() != closed) {\n+                    collect_leaf(conv, &mut subtree.token_trees);\n+                }\n+                let last_range = match conv.bump() {\n+                    None => {\n+                        // For error resilience, we insert an char punct for the opening delim here\n+                        conv.id_alloc().close_delim(idx, None);\n+                        let leaf: tt::Leaf = tt::Punct {\n+                            id: conv.id_alloc().alloc(range),\n+                            char: token.to_char().unwrap(),\n+                            spacing: tt::Spacing::Alone,\n+                        }\n+                        .into();\n+                        result.push(leaf.into());\n+                        result.extend(subtree.token_trees);\n+                        return;\n+                    }\n+                    Some(it) => it.1,\n+                };\n+                conv.id_alloc().close_delim(idx, Some(last_range));\n+                subtree.into()\n+            } else {\n+                let spacing = match conv.peek() {\n+                    Some(next)\n+                        if next.kind().is_trivia()\n+                            || next.kind() == T!['[']\n+                            || next.kind() == T!['{']\n+                            || next.kind() == T!['('] =>\n+                    {\n+                        tt::Spacing::Alone\n+                    }\n+                    Some(next) if next.kind().is_punct() && next.kind() != UNDERSCORE => {\n+                        tt::Spacing::Joint\n+                    }\n+                    _ => tt::Spacing::Alone,\n+                };\n+                let char = match token.to_char() {\n+                    Some(c) => c,\n+                    None => {\n+                        panic!(\"Token from lexer must be single char: token = {:#?}\", token);\n+                    }\n+                };\n+                tt::Leaf::from(tt::Punct { char, spacing, id: conv.id_alloc().alloc(range) }).into()\n+            }\n+        } else {\n+            macro_rules! make_leaf {\n+                ($i:ident) => {\n+                    tt::$i { id: conv.id_alloc().alloc(range), text: token.to_text() }.into()\n+                };\n+            }\n+            let leaf: tt::Leaf = match k {\n+                T![true] | T![false] => make_leaf!(Ident),\n+                IDENT => make_leaf!(Ident),\n+                UNDERSCORE => make_leaf!(Ident),\n+                k if k.is_keyword() => make_leaf!(Ident),\n+                k if k.is_literal() => make_leaf!(Literal),\n+                LIFETIME_IDENT => {\n+                    let char_unit = TextSize::of('\\'');\n+                    let r = TextRange::at(range.start(), char_unit);\n+                    let apostrophe = tt::Leaf::from(tt::Punct {\n+                        char: '\\'',\n+                        spacing: tt::Spacing::Joint,\n+                        id: conv.id_alloc().alloc(r),\n+                    });\n+                    result.push(apostrophe.into());\n+\n+                    let r = TextRange::at(range.start() + char_unit, range.len() - char_unit);\n+                    let ident = tt::Leaf::from(tt::Ident {\n+                        text: SmolStr::new(&token.to_text()[1..]),\n+                        id: conv.id_alloc().alloc(r),\n+                    });\n+                    result.push(ident.into());\n+                    return;\n+                }\n+                _ => return,\n+            };\n+\n+            leaf.into()\n+        });\n+    }\n+}\n+\n /// Returns the textual content of a doc comment block as a quoted string\n /// That is, strips leading `///` (or `/**`, etc)\n /// and strips the ending `*/`\n@@ -242,128 +364,6 @@ trait SrcToken: std::fmt::Debug {\n trait TokenConvertor {\n     type Token: SrcToken;\n \n-    fn go(&mut self) -> tt::Subtree {\n-        let mut subtree = tt::Subtree { delimiter: None, ..Default::default() };\n-        while self.peek().is_some() {\n-            self.collect_leaf(&mut subtree.token_trees);\n-        }\n-        if subtree.token_trees.len() == 1 {\n-            if let tt::TokenTree::Subtree(first) = &subtree.token_trees[0] {\n-                return first.clone();\n-            }\n-        }\n-        subtree\n-    }\n-\n-    fn collect_leaf(&mut self, result: &mut Vec<tt::TokenTree>) {\n-        let (token, range) = match self.bump() {\n-            None => return,\n-            Some(it) => it,\n-        };\n-\n-        let k: SyntaxKind = token.kind();\n-        if k == COMMENT {\n-            if let Some(tokens) = self.convert_doc_comment(&token) {\n-                result.extend(tokens);\n-            }\n-            return;\n-        }\n-\n-        result.push(if k.is_punct() && k != UNDERSCORE {\n-            assert_eq!(range.len(), TextSize::of('.'));\n-            let delim = match k {\n-                T!['('] => Some((tt::DelimiterKind::Parenthesis, T![')'])),\n-                T!['{'] => Some((tt::DelimiterKind::Brace, T!['}'])),\n-                T!['['] => Some((tt::DelimiterKind::Bracket, T![']'])),\n-                _ => None,\n-            };\n-\n-            if let Some((kind, closed)) = delim {\n-                let mut subtree = tt::Subtree::default();\n-                let (id, idx) = self.id_alloc().open_delim(range);\n-                subtree.delimiter = Some(tt::Delimiter { id, kind });\n-\n-                while self.peek().map_or(false, |it| it.kind() != closed) {\n-                    self.collect_leaf(&mut subtree.token_trees);\n-                }\n-                let last_range = match self.bump() {\n-                    None => {\n-                        // For error resilience, we insert an char punct for the opening delim here\n-                        self.id_alloc().close_delim(idx, None);\n-                        let leaf: tt::Leaf = tt::Punct {\n-                            id: self.id_alloc().alloc(range),\n-                            char: token.to_char().unwrap(),\n-                            spacing: tt::Spacing::Alone,\n-                        }\n-                        .into();\n-                        result.push(leaf.into());\n-                        result.extend(subtree.token_trees);\n-                        return;\n-                    }\n-                    Some(it) => it.1,\n-                };\n-                self.id_alloc().close_delim(idx, Some(last_range));\n-                subtree.into()\n-            } else {\n-                let spacing = match self.peek() {\n-                    Some(next)\n-                        if next.kind().is_trivia()\n-                            || next.kind() == T!['[']\n-                            || next.kind() == T!['{']\n-                            || next.kind() == T!['('] =>\n-                    {\n-                        tt::Spacing::Alone\n-                    }\n-                    Some(next) if next.kind().is_punct() && next.kind() != UNDERSCORE => {\n-                        tt::Spacing::Joint\n-                    }\n-                    _ => tt::Spacing::Alone,\n-                };\n-                let char = match token.to_char() {\n-                    Some(c) => c,\n-                    None => {\n-                        panic!(\"Token from lexer must be single char: token = {:#?}\", token);\n-                    }\n-                };\n-                tt::Leaf::from(tt::Punct { char, spacing, id: self.id_alloc().alloc(range) }).into()\n-            }\n-        } else {\n-            macro_rules! make_leaf {\n-                ($i:ident) => {\n-                    tt::$i { id: self.id_alloc().alloc(range), text: token.to_text() }.into()\n-                };\n-            }\n-            let leaf: tt::Leaf = match k {\n-                T![true] | T![false] => make_leaf!(Ident),\n-                IDENT => make_leaf!(Ident),\n-                UNDERSCORE => make_leaf!(Ident),\n-                k if k.is_keyword() => make_leaf!(Ident),\n-                k if k.is_literal() => make_leaf!(Literal),\n-                LIFETIME_IDENT => {\n-                    let char_unit = TextSize::of('\\'');\n-                    let r = TextRange::at(range.start(), char_unit);\n-                    let apostrophe = tt::Leaf::from(tt::Punct {\n-                        char: '\\'',\n-                        spacing: tt::Spacing::Joint,\n-                        id: self.id_alloc().alloc(r),\n-                    });\n-                    result.push(apostrophe.into());\n-\n-                    let r = TextRange::at(range.start() + char_unit, range.len() - char_unit);\n-                    let ident = tt::Leaf::from(tt::Ident {\n-                        text: SmolStr::new(&token.to_text()[1..]),\n-                        id: self.id_alloc().alloc(r),\n-                    });\n-                    result.push(ident.into());\n-                    return;\n-                }\n-                _ => return,\n-            };\n-\n-            leaf.into()\n-        });\n-    }\n-\n     fn convert_doc_comment(&self, token: &Self::Token) -> Option<Vec<tt::TokenTree>>;\n \n     fn bump(&mut self) -> Option<(Self::Token, TextRange)>;"}]}