{"sha": "d2164d5c9a17a7c2eefeccf623c278612b2650de", "node_id": "C_kwDOAAsO6NoAKGQyMTY0ZDVjOWExN2E3YzJlZWZlY2NmNjIzYzI3ODYxMmIyNjUwZGU", "commit": {"author": {"name": "Bryan Garza", "email": "1396101+bryangarza@users.noreply.github.com", "date": "2023-05-25T00:47:13Z"}, "committer": {"name": "Bryan Garza", "email": "1396101+bryangarza@users.noreply.github.com", "date": "2023-05-25T00:49:56Z"}, "message": "Safe Transmute: Update definition of Condition type\n\n- Change `Condition` to not contain `Answer`s but instead just contain other\n  `Condition`s directly.\n- Also improve error reporting for `DstHasStricterAlignment`", "tree": {"sha": "b1dd74d0baeb833d0da51390c42cd91a8faf702c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1dd74d0baeb833d0da51390c42cd91a8faf702c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2164d5c9a17a7c2eefeccf623c278612b2650de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2164d5c9a17a7c2eefeccf623c278612b2650de", "html_url": "https://github.com/rust-lang/rust/commit/d2164d5c9a17a7c2eefeccf623c278612b2650de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2164d5c9a17a7c2eefeccf623c278612b2650de/comments", "author": {"login": "bryangarza", "id": 1396101, "node_id": "MDQ6VXNlcjEzOTYxMDE=", "avatar_url": "https://avatars.githubusercontent.com/u/1396101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bryangarza", "html_url": "https://github.com/bryangarza", "followers_url": "https://api.github.com/users/bryangarza/followers", "following_url": "https://api.github.com/users/bryangarza/following{/other_user}", "gists_url": "https://api.github.com/users/bryangarza/gists{/gist_id}", "starred_url": "https://api.github.com/users/bryangarza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bryangarza/subscriptions", "organizations_url": "https://api.github.com/users/bryangarza/orgs", "repos_url": "https://api.github.com/users/bryangarza/repos", "events_url": "https://api.github.com/users/bryangarza/events{/privacy}", "received_events_url": "https://api.github.com/users/bryangarza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bryangarza", "id": 1396101, "node_id": "MDQ6VXNlcjEzOTYxMDE=", "avatar_url": "https://avatars.githubusercontent.com/u/1396101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bryangarza", "html_url": "https://github.com/bryangarza", "followers_url": "https://api.github.com/users/bryangarza/followers", "following_url": "https://api.github.com/users/bryangarza/following{/other_user}", "gists_url": "https://api.github.com/users/bryangarza/gists{/gist_id}", "starred_url": "https://api.github.com/users/bryangarza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bryangarza/subscriptions", "organizations_url": "https://api.github.com/users/bryangarza/orgs", "repos_url": "https://api.github.com/users/bryangarza/repos", "events_url": "https://api.github.com/users/bryangarza/events{/privacy}", "received_events_url": "https://api.github.com/users/bryangarza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62663582375d7dedf42c0a30bfe04c7b53b452d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/62663582375d7dedf42c0a30bfe04c7b53b452d7", "html_url": "https://github.com/rust-lang/rust/commit/62663582375d7dedf42c0a30bfe04c7b53b452d7"}], "stats": {"total": 72, "additions": 39, "deletions": 33}, "files": [{"sha": "23126f2cb52ddc8eafd5b71f00511f3958403bfa", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d2164d5c9a17a7c2eefeccf623c278612b2650de/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2164d5c9a17a7c2eefeccf623c278612b2650de/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d2164d5c9a17a7c2eefeccf623c278612b2650de", "patch": "@@ -2751,8 +2751,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             rustc_transmute::Assume::from_const(self.infcx.tcx, obligation.param_env, trait_ref.substs.const_at(3)) else {\n                 span_bug!(span, \"Unable to construct rustc_transmute::Assume where it was previously possible\");\n             };\n-        // FIXME(bryangarza): Is this enough, or should we resolve all nested\n-        // obligations like we do for `confirm_transmutability_candidate(...)?`\n+\n         match rustc_transmute::TransmuteTypeEnv::new(self.infcx).is_transmutable(\n             obligation.cause,\n             src_and_dst,\n@@ -2784,10 +2783,12 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     rustc_transmute::Reason::DstIsTooBig => {\n                         format!(\"The size of `{src}` is smaller than the size of `{dst}`\")\n                     }\n-                    // FIXME(bryangarza): Say exactly what the minimum alignments of src and dst are\n-                    rustc_transmute::Reason::DstHasStricterAlignment => {\n+                    rustc_transmute::Reason::DstHasStricterAlignment {\n+                        src_min_align,\n+                        dst_min_align,\n+                    } => {\n                         format!(\n-                            \"The minimum alignment of `{src}` should be greater than that of `{dst}`, but it is not\"\n+                            \"The minimum alignment of `{src}` ({src_min_align}) should be greater than that of `{dst}` ({dst_min_align})\"\n                         )\n                     }\n                     rustc_transmute::Reason::DstIsMoreUnique => {"}, {"sha": "3f07ad814ff61e7d5a5e448d42864e3368b15da1", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d2164d5c9a17a7c2eefeccf623c278612b2650de/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2164d5c9a17a7c2eefeccf623c278612b2650de/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=d2164d5c9a17a7c2eefeccf623c278612b2650de", "patch": "@@ -290,25 +290,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             tcx: TyCtxt<'tcx>,\n             obligation: &TraitObligation<'tcx>,\n             predicate: TraitPredicate<'tcx>,\n-            answer: rustc_transmute::Answer<rustc_transmute::layout::rustc::Ref<'tcx>>,\n-        ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+            answer: rustc_transmute::Condition<rustc_transmute::layout::rustc::Ref<'tcx>>,\n+        ) -> Vec<PredicateObligation<'tcx>> {\n             match answer {\n-                Ok(None) => Ok(vec![]),\n-                Err(_) => Err(Unimplemented),\n                 // FIXME(bryangarza): Add separate `IfAny` case, instead of treating as `IfAll`\n                 // Not possible until the trait solver supports disjunctions of obligations\n-                Ok(Some(rustc_transmute::Condition::IfAll(answers)))\n-                | Ok(Some(rustc_transmute::Condition::IfAny(answers))) => {\n+                rustc_transmute::Condition::IfAll(answers)\n+                | rustc_transmute::Condition::IfAny(answers) => {\n                     let mut nested = vec![];\n                     for flattened in answers\n                         .into_iter()\n                         .map(|answer| flatten_answer_tree(tcx, obligation, predicate, answer))\n                     {\n-                        nested.extend(flattened?);\n+                        nested.extend(flattened);\n                     }\n-                    Ok(nested)\n+                    nested\n                 }\n-                Ok(Some(rustc_transmute::Condition::IfTransmutable { src, dst })) => {\n+                rustc_transmute::Condition::IfTransmutable { src, dst } => {\n                     let trait_def_id = obligation.predicate.def_id();\n                     let scope = predicate.trait_ref.substs.type_at(2);\n                     let assume_const = predicate.trait_ref.substs.const_at(3);\n@@ -339,7 +337,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     if dst.mutability == Mutability::Mut {\n                         obligations.push(make_obl(dst.ty, src.ty));\n                     }\n-                    Ok(obligations)\n+                    obligations\n                 }\n             }\n         }\n@@ -371,8 +369,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             assume,\n         );\n \n-        let fully_flattened =\n-            flatten_answer_tree(self.tcx(), obligation, predicate, maybe_transmutable)?;\n+        let fully_flattened = match maybe_transmutable {\n+            Err(_) => Err(Unimplemented)?,\n+            Ok(Some(mt)) => flatten_answer_tree(self.tcx(), obligation, predicate, mt),\n+            Ok(None) => vec![],\n+        };\n+\n         debug!(?fully_flattened);\n         Ok(ImplSourceBuiltinData { nested: fully_flattened })\n     }"}, {"sha": "7a8cbd50d450d1cb01aa07324368de03f8339006", "filename": "compiler/rustc_transmute/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2164d5c9a17a7c2eefeccf623c278612b2650de/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2164d5c9a17a7c2eefeccf623c278612b2650de/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flib.rs?ref=d2164d5c9a17a7c2eefeccf623c278612b2650de", "patch": "@@ -29,10 +29,10 @@ pub enum Condition<R> {\n     IfTransmutable { src: R, dst: R },\n \n     /// `Src` is transmutable into `Dst`, if all of the enclosed requirements are met.\n-    IfAll(Vec<Answer<R>>),\n+    IfAll(Vec<Condition<R>>),\n \n     /// `Src` is transmutable into `Dst` if any of the enclosed requirements are met.\n-    IfAny(Vec<Answer<R>>),\n+    IfAny(Vec<Condition<R>>),\n }\n \n /// Answers: Why wasn't the source type transmutable into the destination type?\n@@ -49,7 +49,7 @@ pub enum Reason {\n     /// `Dst` is larger than `Src`, and the excess bytes were not exclusively uninitialized.\n     DstIsTooBig,\n     /// Src should have a stricter alignment than Dst, but it does not.\n-    DstHasStricterAlignment,\n+    DstHasStricterAlignment { src_min_align: usize, dst_min_align: usize },\n     /// Can't go from shared pointer to unique pointer\n     DstIsMoreUnique,\n }"}, {"sha": "80e3489e99bcd14446daaa87c6f6eee125286514", "filename": "compiler/rustc_transmute/src/maybe_transmutable/mod.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d2164d5c9a17a7c2eefeccf623c278612b2650de/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2164d5c9a17a7c2eefeccf623c278612b2650de/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs?ref=d2164d5c9a17a7c2eefeccf623c278612b2650de", "patch": "@@ -303,7 +303,10 @@ where\n                                         } else if !self.assume.alignment\n                                             && src_ref.min_align() < dst_ref.min_align()\n                                         {\n-                                            Err(Reason::DstHasStricterAlignment)\n+                                            Err(Reason::DstHasStricterAlignment {\n+                                                src_min_align: src_ref.min_align(),\n+                                                dst_min_align: dst_ref.min_align(),\n+                                            })\n                                         } else {\n                                             // ...such that `src` is transmutable into `dst`, if\n                                             // `src_ref` is transmutability into `dst_ref`.\n@@ -360,13 +363,13 @@ where\n             Some(Condition::IfAll(lhs))\n         }\n         // If only one side is an IfAll, add the other Condition to it\n-        (constraint, Some(Condition::IfAll(mut constraints)))\n-        | (Some(Condition::IfAll(mut constraints)), constraint) => {\n-            constraints.push(Ok(constraint));\n-            Some(Condition::IfAll(constraints))\n+        (Some(cond), Some(Condition::IfAll(mut conds)))\n+        | (Some(Condition::IfAll(mut conds)), Some(cond)) => {\n+            conds.push(cond);\n+            Some(Condition::IfAll(conds))\n         }\n         // Otherwise, both lhs and rhs conditions can be combined in a parent IfAll\n-        (lhs, rhs) => Some(Condition::IfAll(vec![Ok(lhs), Ok(rhs)])),\n+        (Some(lhs), Some(rhs)) => Some(Condition::IfAll(vec![lhs, rhs])),\n     })\n }\n \n@@ -394,13 +397,13 @@ where\n             Some(Condition::IfAny(lhs))\n         }\n         // If only one side is an IfAny, add the other Condition to it\n-        (constraint, Some(Condition::IfAny(mut constraints)))\n-        | (Some(Condition::IfAny(mut constraints)), constraint) => {\n-            constraints.push(Ok(constraint));\n-            Some(Condition::IfAny(constraints))\n+        (Some(cond), Some(Condition::IfAny(mut conds)))\n+        | (Some(Condition::IfAny(mut conds)), Some(cond)) => {\n+            conds.push(cond);\n+            Some(Condition::IfAny(conds))\n         }\n         // Otherwise, both lhs and rhs conditions can be combined in a parent IfAny\n-        (lhs, rhs) => Some(Condition::IfAny(vec![Ok(lhs), Ok(rhs)])),\n+        (Some(lhs), Some(rhs)) => Some(Condition::IfAny(vec![lhs, rhs])),\n     })\n }\n "}, {"sha": "59246fb1b0371fe6ea1c49fee219fee026642260", "filename": "tests/ui/transmutability/alignment/align-fail.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2164d5c9a17a7c2eefeccf623c278612b2650de/tests%2Fui%2Ftransmutability%2Falignment%2Falign-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2164d5c9a17a7c2eefeccf623c278612b2650de/tests%2Fui%2Ftransmutability%2Falignment%2Falign-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Falignment%2Falign-fail.stderr?ref=d2164d5c9a17a7c2eefeccf623c278612b2650de", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: `&[u8; 0]` cannot be safely transmuted into `&[u16; 0]` in the defining scope of `assert::Context`\n   --> $DIR/align-fail.rs:22:55\n    |\n-LL | ...c [u8; 0], &'static [u16; 0]>();\n-   |               ^^^^^^^^^^^^^^^^^ The minimum alignment of `&[u8; 0]` should be greater than that of `&[u16; 0]`, but it is not\n+LL | ...tatic [u8; 0], &'static [u16; 0]>();\n+   |                   ^^^^^^^^^^^^^^^^^ The minimum alignment of `&[u8; 0]` (1) should be greater than that of `&[u16; 0]` (2)\n    |\n note: required by a bound in `is_maybe_transmutable`\n   --> $DIR/align-fail.rs:10:14"}]}