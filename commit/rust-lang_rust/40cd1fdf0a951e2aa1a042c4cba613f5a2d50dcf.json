{"sha": "40cd1fdf0a951e2aa1a042c4cba613f5a2d50dcf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwY2QxZmRmMGE5NTFlMmFhMWEwNDJjNGNiYTYxM2Y1YTJkNTBkY2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-14T09:23:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-14T09:23:19Z"}, "message": "Auto merge of #36692 - arthurprs:hashmap-layout, r=alexcrichton\n\nCache conscious hashmap table\n\nRight now the internal HashMap representation is 3 unziped arrays hhhkkkvvv, I propose to change it to hhhkvkvkv (in further iterations kvkvkvhhh may allow inplace grow). A previous attempt is at #21973.\n\nThis layout is generally more cache conscious as it makes the value immediately accessible after a key matches. The separated hash arrays is a _no-brainer_ because of how the RH algorithm works and that's unchanged.\n\n**Lookups**: Upon a successful match in the hash array the code can check the key and immediately have access to the value in the same or next cache line (effectively saving a L[1,2,3] miss compared to the current layout).\n**Inserts/Deletes/Resize**: Moving values in the table (robin hooding it) is faster because it touches consecutive cache lines and uses less instructions.\n\nSome backing benchmarks (besides the ones bellow) for the benefits of this layout can be seen here as well http://www.reedbeta.com/blog/2015/01/12/data-oriented-hash-table/\n\nThe obvious drawbacks is: padding can be wasted between the key and value. Because of that keys(), values() and contains() can consume more cache and be slower.\n\nTotal wasted padding between items (C being the capacity of the table).\n* Old layout: C * (K-K padding) + C * (V-V padding)\n* Proposed: C * (K-V padding) + C * (V-K padding)\n\nIn practice padding between K-K and V-V *can* be smaller than K-V and V-K. The overhead is capped(ish) at sizeof u64 - 1 so we can actually measure the worst case (u8 at the end of key type and value with aliment of 1, _hardly the average case in practice_).\n\nStarting from the worst case the memory overhead is:\n* `HashMap<u64, u8>` 46% memory overhead. (aka *worst case*)\n* `HashMap<u64, u16>` 33% memory overhead.\n* `HashMap<u64, u32>` 20% memory overhead.\n* `HashMap<T, T>` 0% memory overhead\n* Worst case based on sizeof K + sizeof V:\n\n| x              |  16    |  24    |  32    |  64   |  128  |\n|----------------|--------|--------|--------|-------|-------|\n| (8+x+7)/(8+x)  |  1.29  |  1.22  |  1.18  |  1.1  |  1.05 |\n\nI've a test repo here to run benchmarks  https://github.com/arthurprs/hashmap2/tree/layout\n\n```\n \u279c  hashmap2 git:(layout) \u2717 cargo benchcmp hhkkvv:: hhkvkv:: bench.txt\n name                            hhkkvv:: ns/iter  hhkvkv:: ns/iter  diff ns/iter   diff %\n grow_10_000                     922,064           783,933               -138,131  -14.98%\n grow_big_value_10_000           1,901,909         1,171,862             -730,047  -38.38%\n grow_fnv_10_000                 443,544           418,674                -24,870   -5.61%\n insert_100                      2,469             2,342                     -127   -5.14%\n insert_1000                     23,331            21,536                  -1,795   -7.69%\n insert_100_000                  4,748,048         3,764,305             -983,743  -20.72%\n insert_10_000                   321,744           290,126                -31,618   -9.83%\n insert_int_bigvalue_10_000      749,764           407,547               -342,217  -45.64%\n insert_str_10_000               337,425           334,009                 -3,416   -1.01%\n insert_string_10_000            788,667           788,262                   -405   -0.05%\n iter_keys_100_000               394,484           374,161                -20,323   -5.15%\n iter_keys_big_value_100_000     402,071           620,810                218,739   54.40%\n iter_values_100_000             424,794           373,004                -51,790  -12.19%\n iterate_100_000                 424,297           389,950                -34,347   -8.10%\n lookup_100_000                  189,997           186,554                 -3,443   -1.81%\n lookup_100_000_bigvalue         192,509           189,695                 -2,814   -1.46%\n lookup_10_000                   154,251           145,731                 -8,520   -5.52%\n lookup_10_000_bigvalue          162,315           146,527                -15,788   -9.73%\n lookup_10_000_exist             132,769           128,922                 -3,847   -2.90%\n lookup_10_000_noexist           146,880           144,504                 -2,376   -1.62%\n lookup_1_000_000                137,167           132,260                 -4,907   -3.58%\n lookup_1_000_000_bigvalue       141,130           134,371                 -6,759   -4.79%\n lookup_1_000_000_bigvalue_unif  567,235           481,272                -85,963  -15.15%\n lookup_1_000_000_unif           589,391           453,576               -135,815  -23.04%\n merge_shuffle                   1,253,357         1,207,387              -45,970   -3.67%\n merge_simple                    40,264,690        37,996,903          -2,267,787   -5.63%\n new                             6                 5                           -1  -16.67%\n with_capacity_10e5              3,214             3,256                       42    1.31%\n```\n\n```\n\u279c  hashmap2 git:(layout) \u2717 cargo benchcmp hhkkvv:: hhkvkv:: bench.txt\n name                           hhkkvv:: ns/iter  hhkvkv:: ns/iter  diff ns/iter   diff %\n iter_keys_100_000              391,677           382,839                 -8,838   -2.26%\n iter_keys_1_000_000            10,797,360        10,209,898            -587,462   -5.44%\n iter_keys_big_value_100_000    414,736           662,255                247,519   59.68%\n iter_keys_big_value_1_000_000  10,147,837        12,067,938           1,920,101   18.92%\n iter_values_100_000            440,445           377,080                -63,365  -14.39%\n iter_values_1_000_000          10,931,844        9,979,173             -952,671   -8.71%\n iterate_100_000                428,644           388,509                -40,135   -9.36%\n iterate_1_000_000              11,065,419        10,042,427          -1,022,992   -9.24%\n```", "tree": {"sha": "f2e0a291bb1fff48f85aacac08f9d864f713e428", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2e0a291bb1fff48f85aacac08f9d864f713e428"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40cd1fdf0a951e2aa1a042c4cba613f5a2d50dcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40cd1fdf0a951e2aa1a042c4cba613f5a2d50dcf", "html_url": "https://github.com/rust-lang/rust/commit/40cd1fdf0a951e2aa1a042c4cba613f5a2d50dcf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40cd1fdf0a951e2aa1a042c4cba613f5a2d50dcf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17af6b94b2ea39414e4449c17cc4ab066d790e8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/17af6b94b2ea39414e4449c17cc4ab066d790e8f", "html_url": "https://github.com/rust-lang/rust/commit/17af6b94b2ea39414e4449c17cc4ab066d790e8f"}, {"sha": "c435821d164829a0d5f324c1b0366c4b1724849d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c435821d164829a0d5f324c1b0366c4b1724849d", "html_url": "https://github.com/rust-lang/rust/commit/c435821d164829a0d5f324c1b0366c4b1724849d"}], "stats": {"total": 156, "additions": 68, "deletions": 88}, "files": [{"sha": "b357bc3552a5e807b7e483e3665f7816019b420a", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 68, "deletions": 88, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/40cd1fdf0a951e2aa1a042c4cba613f5a2d50dcf/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40cd1fdf0a951e2aa1a042c4cba613f5a2d50dcf/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=40cd1fdf0a951e2aa1a042c4cba613f5a2d50dcf", "patch": "@@ -24,10 +24,10 @@ use self::BucketState::*;\n const EMPTY_BUCKET: u64 = 0;\n \n /// The raw hashtable, providing safe-ish access to the unzipped and highly\n-/// optimized arrays of hashes, keys, and values.\n+/// optimized arrays of hashes, and key-value pairs.\n ///\n-/// This design uses less memory and is a lot faster than the naive\n-/// `Vec<Option<u64, K, V>>`, because we don't pay for the overhead of an\n+/// This design is a lot faster than the naive\n+/// `Vec<Option<(u64, K, V)>>`, because we don't pay for the overhead of an\n /// option on every element, and we get a generally more cache-aware design.\n ///\n /// Essential invariants of this structure:\n@@ -48,17 +48,19 @@ const EMPTY_BUCKET: u64 = 0;\n ///     which will likely map to the same bucket, while not being confused\n ///     with \"empty\".\n ///\n-///   - All three \"arrays represented by pointers\" are the same length:\n+///   - Both \"arrays represented by pointers\" are the same length:\n ///     `capacity`. This is set at creation and never changes. The arrays\n-///     are unzipped to save space (we don't have to pay for the padding\n-///     between odd sized elements, such as in a map from u64 to u8), and\n-///     be more cache aware (scanning through 8 hashes brings in at most\n-///     2 cache lines, since they're all right beside each other).\n+///     are unzipped and are more cache aware (scanning through 8 hashes\n+///     brings in at most 2 cache lines, since they're all right beside each\n+///     other). This layout may waste space in padding such as in a map from\n+///     u64 to u8, but is a more cache conscious layout as the key-value pairs\n+///     are only very shortly probed and the desired value will be in the same\n+///     or next cache line.\n ///\n /// You can kind of think of this module/data structure as a safe wrapper\n /// around just the \"table\" part of the hashtable. It enforces some\n /// invariants at the type level and employs some performance trickery,\n-/// but in general is just a tricked out `Vec<Option<u64, K, V>>`.\n+/// but in general is just a tricked out `Vec<Option<(u64, K, V)>>`.\n pub struct RawTable<K, V> {\n     capacity: usize,\n     size: usize,\n@@ -74,10 +76,8 @@ unsafe impl<K: Sync, V: Sync> Sync for RawTable<K, V> {}\n \n struct RawBucket<K, V> {\n     hash: *mut u64,\n-\n     // We use *const to ensure covariance with respect to K and V\n-    key: *const K,\n-    val: *const V,\n+    pair: *const (K, V),\n     _marker: marker::PhantomData<(K, V)>,\n }\n \n@@ -181,8 +181,7 @@ impl<K, V> RawBucket<K, V> {\n     unsafe fn offset(self, count: isize) -> RawBucket<K, V> {\n         RawBucket {\n             hash: self.hash.offset(count),\n-            key: self.key.offset(count),\n-            val: self.val.offset(count),\n+            pair: self.pair.offset(count),\n             _marker: marker::PhantomData,\n         }\n     }\n@@ -370,8 +369,7 @@ impl<K, V, M> EmptyBucket<K, V, M>\n     pub fn put(mut self, hash: SafeHash, key: K, value: V) -> FullBucket<K, V, M> {\n         unsafe {\n             *self.raw.hash = hash.inspect();\n-            ptr::write(self.raw.key as *mut K, key);\n-            ptr::write(self.raw.val as *mut V, value);\n+            ptr::write(self.raw.pair as *mut (K, V), (key, value));\n \n             self.table.borrow_table_mut().size += 1;\n         }\n@@ -430,7 +428,7 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n \n     /// Gets references to the key and value at a given index.\n     pub fn read(&self) -> (&K, &V) {\n-        unsafe { (&*self.raw.key, &*self.raw.val) }\n+        unsafe { (&(*self.raw.pair).0, &(*self.raw.pair).1) }\n     }\n }\n \n@@ -447,13 +445,14 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n \n         unsafe {\n             *self.raw.hash = EMPTY_BUCKET;\n+            let (k, v) = ptr::read(self.raw.pair);\n             (EmptyBucket {\n                  raw: self.raw,\n                  idx: self.idx,\n                  table: self.table,\n              },\n-             ptr::read(self.raw.key),\n-             ptr::read(self.raw.val))\n+            k,\n+            v)\n         }\n     }\n }\n@@ -466,8 +465,7 @@ impl<K, V, M> FullBucket<K, V, M>\n     pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) {\n         unsafe {\n             let old_hash = ptr::replace(self.raw.hash as *mut SafeHash, h);\n-            let old_key = ptr::replace(self.raw.key as *mut K, k);\n-            let old_val = ptr::replace(self.raw.val as *mut V, v);\n+            let (old_key, old_val) = ptr::replace(self.raw.pair as *mut (K, V), (k, v));\n \n             (old_hash, old_key, old_val)\n         }\n@@ -479,7 +477,8 @@ impl<K, V, M> FullBucket<K, V, M>\n {\n     /// Gets mutable references to the key and value at a given index.\n     pub fn read_mut(&mut self) -> (&mut K, &mut V) {\n-        unsafe { (&mut *(self.raw.key as *mut K), &mut *(self.raw.val as *mut V)) }\n+        let pair_mut = self.raw.pair as *mut (K, V);\n+        unsafe { (&mut (*pair_mut).0, &mut (*pair_mut).1) }\n     }\n }\n \n@@ -492,7 +491,7 @@ impl<'t, K, V, M> FullBucket<K, V, M>\n     /// in exchange for this, the returned references have a longer lifetime\n     /// than the references returned by `read()`.\n     pub fn into_refs(self) -> (&'t K, &'t V) {\n-        unsafe { (&*self.raw.key, &*self.raw.val) }\n+        unsafe { (&(*self.raw.pair).0, &(*self.raw.pair).1) }\n     }\n }\n \n@@ -502,7 +501,8 @@ impl<'t, K, V, M> FullBucket<K, V, M>\n     /// This works similarly to `into_refs`, exchanging a bucket state\n     /// for mutable references into the table.\n     pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) {\n-        unsafe { (&mut *(self.raw.key as *mut K), &mut *(self.raw.val as *mut V)) }\n+        let pair_mut = self.raw.pair as *mut (K, V);\n+        unsafe { (&mut (*pair_mut).0, &mut (*pair_mut).1) }\n     }\n }\n \n@@ -517,8 +517,7 @@ impl<K, V, M> GapThenFull<K, V, M>\n     pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> {\n         unsafe {\n             *self.gap.raw.hash = mem::replace(&mut *self.full.raw.hash, EMPTY_BUCKET);\n-            ptr::copy_nonoverlapping(self.full.raw.key, self.gap.raw.key as *mut K, 1);\n-            ptr::copy_nonoverlapping(self.full.raw.val, self.gap.raw.val as *mut V, 1);\n+            ptr::copy_nonoverlapping(self.full.raw.pair, self.gap.raw.pair as *mut (K, V), 1);\n         }\n \n         let FullBucket { raw: prev_raw, idx: prev_idx, .. } = self.full;\n@@ -560,49 +559,42 @@ fn test_rounding() {\n     assert_eq!(round_up_to_next(5, 4), 8);\n }\n \n-// Returns a tuple of (key_offset, val_offset),\n+// Returns a tuple of (pairs_offset, end_of_pairs_offset),\n // from the start of a mallocated array.\n #[inline]\n fn calculate_offsets(hashes_size: usize,\n-                     keys_size: usize,\n-                     keys_align: usize,\n-                     vals_align: usize)\n+                     pairs_size: usize,\n+                     pairs_align: usize)\n                      -> (usize, usize, bool) {\n-    let keys_offset = round_up_to_next(hashes_size, keys_align);\n-    let (end_of_keys, oflo) = keys_offset.overflowing_add(keys_size);\n-\n-    let vals_offset = round_up_to_next(end_of_keys, vals_align);\n+    let pairs_offset = round_up_to_next(hashes_size, pairs_align);\n+    let (end_of_pairs, oflo) = pairs_offset.overflowing_add(pairs_size);\n \n-    (keys_offset, vals_offset, oflo)\n+    (pairs_offset, end_of_pairs, oflo)\n }\n \n // Returns a tuple of (minimum required malloc alignment, hash_offset,\n // array_size), from the start of a mallocated array.\n fn calculate_allocation(hash_size: usize,\n                         hash_align: usize,\n-                        keys_size: usize,\n-                        keys_align: usize,\n-                        vals_size: usize,\n-                        vals_align: usize)\n+                        pairs_size: usize,\n+                        pairs_align: usize)\n                         -> (usize, usize, usize, bool) {\n     let hash_offset = 0;\n-    let (_, vals_offset, oflo) = calculate_offsets(hash_size, keys_size, keys_align, vals_align);\n-    let (end_of_vals, oflo2) = vals_offset.overflowing_add(vals_size);\n+    let (_, end_of_pairs, oflo) = calculate_offsets(hash_size, pairs_size, pairs_align);\n \n-    let align = cmp::max(hash_align, cmp::max(keys_align, vals_align));\n+    let align = cmp::max(hash_align, pairs_align);\n \n-    (align, hash_offset, end_of_vals, oflo || oflo2)\n+    (align, hash_offset, end_of_pairs, oflo)\n }\n \n #[test]\n fn test_offset_calculation() {\n-    assert_eq!(calculate_allocation(128, 8, 15, 1, 4, 4),\n-               (8, 0, 148, false));\n-    assert_eq!(calculate_allocation(3, 1, 2, 1, 1, 1), (1, 0, 6, false));\n-    assert_eq!(calculate_allocation(6, 2, 12, 4, 24, 8), (8, 0, 48, false));\n-    assert_eq!(calculate_offsets(128, 15, 1, 4), (128, 144, false));\n-    assert_eq!(calculate_offsets(3, 2, 1, 1), (3, 5, false));\n-    assert_eq!(calculate_offsets(6, 12, 4, 8), (8, 24, false));\n+    assert_eq!(calculate_allocation(128, 8, 16, 8), (8, 0, 144, false));\n+    assert_eq!(calculate_allocation(3, 1, 2, 1), (1, 0, 5, false));\n+    assert_eq!(calculate_allocation(6, 2, 12, 4), (4, 0, 20, false));\n+    assert_eq!(calculate_offsets(128, 15, 4), (128, 143, false));\n+    assert_eq!(calculate_offsets(3, 2, 4), (4, 6, false));\n+    assert_eq!(calculate_offsets(6, 12, 4), (8, 20, false));\n }\n \n impl<K, V> RawTable<K, V> {\n@@ -620,39 +612,31 @@ impl<K, V> RawTable<K, V> {\n \n         // No need for `checked_mul` before a more restrictive check performed\n         // later in this method.\n-        let hashes_size = capacity * size_of::<u64>();\n-        let keys_size = capacity * size_of::<K>();\n-        let vals_size = capacity * size_of::<V>();\n+        let hashes_size = capacity.wrapping_mul(size_of::<u64>());\n+        let pairs_size = capacity.wrapping_mul(size_of::<(K, V)>());\n \n-        // Allocating hashmaps is a little tricky. We need to allocate three\n+        // Allocating hashmaps is a little tricky. We need to allocate two\n         // arrays, but since we know their sizes and alignments up front,\n         // we just allocate a single array, and then have the subarrays\n         // point into it.\n         //\n         // This is great in theory, but in practice getting the alignment\n         // right is a little subtle. Therefore, calculating offsets has been\n         // factored out into a different function.\n-        let (malloc_alignment, hash_offset, size, oflo) = calculate_allocation(hashes_size,\n-                                                                               align_of::<u64>(),\n-                                                                               keys_size,\n-                                                                               align_of::<K>(),\n-                                                                               vals_size,\n-                                                                               align_of::<V>());\n-\n+        let (alignment, hash_offset, size, oflo) = calculate_allocation(hashes_size,\n+                                                                        align_of::<u64>(),\n+                                                                        pairs_size,\n+                                                                        align_of::<(K, V)>());\n         assert!(!oflo, \"capacity overflow\");\n \n         // One check for overflow that covers calculation and rounding of size.\n-        let size_of_bucket = size_of::<u64>()\n-            .checked_add(size_of::<K>())\n-            .unwrap()\n-            .checked_add(size_of::<V>())\n-            .unwrap();\n+        let size_of_bucket = size_of::<u64>().checked_add(size_of::<(K, V)>()).unwrap();\n         assert!(size >=\n                 capacity.checked_mul(size_of_bucket)\n                     .expect(\"capacity overflow\"),\n                 \"capacity overflow\");\n \n-        let buffer = allocate(size, malloc_alignment);\n+        let buffer = allocate(size, alignment);\n         if buffer.is_null() {\n             ::alloc::oom()\n         }\n@@ -669,17 +653,16 @@ impl<K, V> RawTable<K, V> {\n \n     fn first_bucket_raw(&self) -> RawBucket<K, V> {\n         let hashes_size = self.capacity * size_of::<u64>();\n-        let keys_size = self.capacity * size_of::<K>();\n+        let pairs_size = self.capacity * size_of::<(K, V)>();\n \n-        let buffer = *self.hashes as *const u8;\n-        let (keys_offset, vals_offset, oflo) =\n-            calculate_offsets(hashes_size, keys_size, align_of::<K>(), align_of::<V>());\n+        let buffer = *self.hashes as *mut u8;\n+        let (pairs_offset, _, oflo) =\n+            calculate_offsets(hashes_size, pairs_size, align_of::<(K, V)>());\n         debug_assert!(!oflo, \"capacity overflow\");\n         unsafe {\n             RawBucket {\n                 hash: *self.hashes,\n-                key: buffer.offset(keys_offset as isize) as *const K,\n-                val: buffer.offset(vals_offset as isize) as *const V,\n+                pair: buffer.offset(pairs_offset as isize) as *const _,\n                 _marker: marker::PhantomData,\n             }\n         }\n@@ -844,7 +827,7 @@ impl<'a, K, V> Iterator for RevMoveBuckets<'a, K, V> {\n \n                 if *self.raw.hash != EMPTY_BUCKET {\n                     self.elems_left -= 1;\n-                    return Some((ptr::read(self.raw.key), ptr::read(self.raw.val)));\n+                    return Some(ptr::read(self.raw.pair));\n                 }\n             }\n         }\n@@ -909,7 +892,7 @@ impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n         self.iter.next().map(|bucket| {\n             self.elems_left -= 1;\n-            unsafe { (&*bucket.key, &*bucket.val) }\n+            unsafe { (&(*bucket.pair).0, &(*bucket.pair).1) }\n         })\n     }\n \n@@ -929,7 +912,8 @@ impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n         self.iter.next().map(|bucket| {\n             self.elems_left -= 1;\n-            unsafe { (&*bucket.key, &mut *(bucket.val as *mut V)) }\n+            let pair_mut = bucket.pair as *mut (K, V);\n+            unsafe { (&(*pair_mut).0, &mut (*pair_mut).1) }\n         })\n     }\n \n@@ -950,7 +934,8 @@ impl<K, V> Iterator for IntoIter<K, V> {\n         self.iter.next().map(|bucket| {\n             self.table.size -= 1;\n             unsafe {\n-                (SafeHash { hash: *bucket.hash }, ptr::read(bucket.key), ptr::read(bucket.val))\n+                let (k, v) = ptr::read(bucket.pair);\n+                (SafeHash { hash: *bucket.hash }, k, v)\n             }\n         })\n     }\n@@ -974,9 +959,8 @@ impl<'a, K, V> Iterator for Drain<'a, K, V> {\n         self.iter.next().map(|bucket| {\n             unsafe {\n                 (**self.table).size -= 1;\n-                (SafeHash { hash: ptr::replace(bucket.hash, EMPTY_BUCKET) },\n-                 ptr::read(bucket.key),\n-                 ptr::read(bucket.val))\n+                let (k, v) = ptr::read(bucket.pair);\n+                (SafeHash { hash: ptr::replace(bucket.hash, EMPTY_BUCKET) }, k, v)\n             }\n         })\n     }\n@@ -1015,8 +999,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n                                 (full.hash(), k.clone(), v.clone())\n                             };\n                             *new_buckets.raw.hash = h.inspect();\n-                            ptr::write(new_buckets.raw.key as *mut K, k);\n-                            ptr::write(new_buckets.raw.val as *mut V, v);\n+                            ptr::write(new_buckets.raw.pair as *mut (K, V), (k, v));\n                         }\n                         Empty(..) => {\n                             *new_buckets.raw.hash = EMPTY_BUCKET;\n@@ -1054,14 +1037,11 @@ impl<K, V> Drop for RawTable<K, V> {\n         }\n \n         let hashes_size = self.capacity * size_of::<u64>();\n-        let keys_size = self.capacity * size_of::<K>();\n-        let vals_size = self.capacity * size_of::<V>();\n+        let pairs_size = self.capacity * size_of::<(K, V)>();\n         let (align, _, size, oflo) = calculate_allocation(hashes_size,\n                                                           align_of::<u64>(),\n-                                                          keys_size,\n-                                                          align_of::<K>(),\n-                                                          vals_size,\n-                                                          align_of::<V>());\n+                                                          pairs_size,\n+                                                          align_of::<(K, V)>());\n \n         debug_assert!(!oflo, \"should be impossible\");\n "}]}