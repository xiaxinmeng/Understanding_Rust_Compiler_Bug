{"sha": "b833fcae90b42a9b55224288d5ec9cfd86835d0d", "node_id": "C_kwDOAAsO6NoAKGI4MzNmY2FlOTBiNDJhOWI1NTIyNDI4OGQ1ZWM5Y2ZkODY4MzVkMGQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-03-30T18:08:09Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-05T19:34:36Z"}, "message": "Manipulate Location instead of SourceInfo.", "tree": {"sha": "ee96521aec198a7c4784be6b00eb1c200fbaa482", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee96521aec198a7c4784be6b00eb1c200fbaa482"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b833fcae90b42a9b55224288d5ec9cfd86835d0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b833fcae90b42a9b55224288d5ec9cfd86835d0d", "html_url": "https://github.com/rust-lang/rust/commit/b833fcae90b42a9b55224288d5ec9cfd86835d0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b833fcae90b42a9b55224288d5ec9cfd86835d0d/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35e622d2185ff094f8fbe528f24e8900b9369efb", "url": "https://api.github.com/repos/rust-lang/rust/commits/35e622d2185ff094f8fbe528f24e8900b9369efb", "html_url": "https://github.com/rust-lang/rust/commit/35e622d2185ff094f8fbe528f24e8900b9369efb"}], "stats": {"total": 86, "additions": 36, "deletions": 50}, "files": [{"sha": "47bcba0f2500704f4ef06a1b18411921a15c202d", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 36, "deletions": 50, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b833fcae90b42a9b55224288d5ec9cfd86835d0d/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b833fcae90b42a9b55224288d5ec9cfd86835d0d/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=b833fcae90b42a9b55224288d5ec9cfd86835d0d", "patch": "@@ -1,7 +1,7 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use either::{Left, Right};\n+use either::Left;\n \n use rustc_const_eval::interpret::Immediate;\n use rustc_const_eval::interpret::{\n@@ -129,9 +129,6 @@ struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n-    // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n-    // the last known `SourceInfo` here and just keep revisiting it.\n-    source_info: Option<SourceInfo>,\n }\n \n impl<'tcx> LayoutOfHelpers<'tcx> for ConstPropagator<'_, 'tcx> {\n@@ -206,7 +203,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         )\n         .expect(\"failed to push initial stack frame\");\n \n-        ConstPropagator { ecx, tcx, param_env, source_info: None }\n+        ConstPropagator { ecx, tcx, param_env }\n     }\n \n     fn body(&self) -> &'mir Body<'tcx> {\n@@ -252,12 +249,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         source_info.scope.lint_root(&self.body().source_scopes)\n     }\n \n-    fn use_ecx<F, T>(&mut self, source_info: SourceInfo, f: F) -> Option<T>\n+    fn use_ecx<F, T>(&mut self, location: Location, f: F) -> Option<T>\n     where\n         F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n     {\n         // Overwrite the PC -- whatever the interpreter does to it does not make any sense anyway.\n-        self.ecx.frame_mut().loc = Right(source_info.span);\n+        self.ecx.frame_mut().loc = Left(location);\n         match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n@@ -276,7 +273,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     /// Returns the value, if any, of evaluating `c`.\n-    fn eval_constant(&mut self, c: &Constant<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+    fn eval_constant(&mut self, c: &Constant<'tcx>, location: Location) -> Option<OpTy<'tcx>> {\n         // FIXME we need to revisit this for #67176\n         if c.needs_subst() {\n             return None;\n@@ -290,45 +287,41 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         // manually normalized.\n         let val = self.tcx.try_normalize_erasing_regions(self.param_env, c.literal).ok()?;\n \n-        self.use_ecx(source_info, |this| this.ecx.eval_mir_constant(&val, Some(c.span), None))\n+        self.use_ecx(location, |this| this.ecx.eval_mir_constant(&val, Some(c.span), None))\n     }\n \n     /// Returns the value, if any, of evaluating `place`.\n-    fn eval_place(&mut self, place: Place<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+    fn eval_place(&mut self, place: Place<'tcx>, location: Location) -> Option<OpTy<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        self.use_ecx(source_info, |this| this.ecx.eval_place_to_op(place, None))\n+        self.use_ecx(location, |this| this.ecx.eval_place_to_op(place, None))\n     }\n \n     /// Returns the value, if any, of evaluating `op`. Calls upon `eval_constant`\n     /// or `eval_place`, depending on the variant of `Operand` used.\n-    fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n+    fn eval_operand(&mut self, op: &Operand<'tcx>, location: Location) -> Option<OpTy<'tcx>> {\n         match *op {\n-            Operand::Constant(ref c) => self.eval_constant(c, source_info),\n-            Operand::Move(place) | Operand::Copy(place) => self.eval_place(place, source_info),\n+            Operand::Constant(ref c) => self.eval_constant(c, location),\n+            Operand::Move(place) | Operand::Copy(place) => self.eval_place(place, location),\n         }\n     }\n \n     fn report_assert_as_lint(\n         &self,\n         lint: &'static lint::Lint,\n-        source_info: SourceInfo,\n+        location: Location,\n         message: &'static str,\n         panic: AssertKind<impl std::fmt::Debug>,\n     ) {\n-        if let Some(lint_root) = self.lint_root(source_info) {\n+        let source_info = self.body().source_info(location);\n+        if let Some(lint_root) = self.lint_root(*source_info) {\n             self.tcx.struct_span_lint_hir(lint, lint_root, source_info.span, message, |lint| {\n                 lint.span_label(source_info.span, format!(\"{:?}\", panic))\n             });\n         }\n     }\n \n-    fn check_unary_op(\n-        &mut self,\n-        op: UnOp,\n-        arg: &Operand<'tcx>,\n-        source_info: SourceInfo,\n-    ) -> Option<()> {\n-        if let (val, true) = self.use_ecx(source_info, |this| {\n+    fn check_unary_op(&mut self, op: UnOp, arg: &Operand<'tcx>, location: Location) -> Option<()> {\n+        if let (val, true) = self.use_ecx(location, |this| {\n             let val = this.ecx.read_immediate(&this.ecx.eval_operand(arg, None)?)?;\n             let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, &val)?;\n             Ok((val, overflow))\n@@ -338,7 +331,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n             self.report_assert_as_lint(\n                 lint::builtin::ARITHMETIC_OVERFLOW,\n-                source_info,\n+                location,\n                 \"this arithmetic operation will overflow\",\n                 AssertKind::OverflowNeg(val.to_const_int()),\n             );\n@@ -353,14 +346,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         op: BinOp,\n         left: &Operand<'tcx>,\n         right: &Operand<'tcx>,\n-        source_info: SourceInfo,\n+        location: Location,\n     ) -> Option<()> {\n-        let r = self.use_ecx(source_info, |this| {\n+        let r = self.use_ecx(location, |this| {\n             this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?)\n         });\n-        let l = self.use_ecx(source_info, |this| {\n-            this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?)\n-        });\n+        let l = self\n+            .use_ecx(location, |this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n         if matches!(op, BinOp::Shr | BinOp::Shl) {\n             let r = r.clone()?;\n@@ -371,10 +363,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let right_size = r.layout.size;\n             let r_bits = r.to_scalar().to_bits(right_size).ok();\n             if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n-                debug!(\"check_binary_op: reporting assert for {:?}\", source_info);\n+                debug!(\"check_binary_op: reporting assert for {:?}\", location);\n                 self.report_assert_as_lint(\n                     lint::builtin::ARITHMETIC_OVERFLOW,\n-                    source_info,\n+                    location,\n                     \"this arithmetic operation will overflow\",\n                     AssertKind::Overflow(\n                         op,\n@@ -396,13 +388,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         if let (Some(l), Some(r)) = (l, r) {\n             // The remaining operators are handled through `overflowing_binary_op`.\n-            if self.use_ecx(source_info, |this| {\n+            if self.use_ecx(location, |this| {\n                 let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, &l, &r)?;\n                 Ok(overflow)\n             })? {\n                 self.report_assert_as_lint(\n                     lint::builtin::ARITHMETIC_OVERFLOW,\n-                    source_info,\n+                    location,\n                     \"this arithmetic operation will overflow\",\n                     AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n                 );\n@@ -412,7 +404,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Some(())\n     }\n \n-    fn check_rvalue(&mut self, rvalue: &Rvalue<'tcx>, source_info: SourceInfo) -> Option<()> {\n+    fn check_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) -> Option<()> {\n         // Perform any special handling for specific Rvalue types.\n         // Generally, checks here fall into one of two categories:\n         //   1. Additional checking to provide useful lints to the user\n@@ -427,11 +419,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // lint.\n             Rvalue::UnaryOp(op, arg) => {\n                 trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n-                self.check_unary_op(*op, arg, source_info)?;\n+                self.check_unary_op(*op, arg, location)?;\n             }\n             Rvalue::BinaryOp(op, box (left, right)) => {\n                 trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n-                self.check_binary_op(*op, left, right, source_info)?;\n+                self.check_binary_op(*op, left, right, location)?;\n             }\n             Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n                 trace!(\n@@ -440,7 +432,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     left,\n                     right\n                 );\n-                self.check_binary_op(*op, left, right, source_info)?;\n+                self.check_binary_op(*op, left, right, location)?;\n             }\n \n             // Do not try creating references (#67862)\n@@ -516,22 +508,21 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         trace!(\"visit_constant: {:?}\", constant);\n         self.super_constant(constant, location);\n-        self.eval_constant(constant, self.source_info.unwrap());\n+        self.eval_constant(constant, location);\n     }\n \n     fn visit_assign(&mut self, place: &Place<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n         self.super_assign(place, rvalue, location);\n \n-        let source_info = self.source_info.unwrap();\n-        let Some(()) = self.check_rvalue(rvalue, source_info) else { return };\n+        let Some(()) = self.check_rvalue(rvalue, location) else { return };\n \n         match self.ecx.machine.can_const_prop[place.local] {\n             // Do nothing if the place is indirect.\n             _ if place.is_indirect() => {}\n             ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n             ConstPropMode::OnlyInsideOwnBlock | ConstPropMode::FullConstProp => {\n                 if self\n-                    .use_ecx(source_info, |this| this.ecx.eval_rvalue_into_place(rvalue, *place))\n+                    .use_ecx(location, |this| this.ecx.eval_rvalue_into_place(rvalue, *place))\n                     .is_none()\n                 {\n                     // Const prop failed, so erase the destination, ensuring that whatever happens\n@@ -557,8 +548,6 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n \n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: {:?}\", statement);\n-        let source_info = statement.source_info;\n-        self.source_info = Some(source_info);\n \n         // We want to evaluate operands before any change to the assigned-to value,\n         // so we recurse first.\n@@ -571,8 +560,7 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                     _ if place.is_indirect() => {}\n                     ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n                     ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n-                        if self.use_ecx(source_info, |this| this.ecx.statement(statement)).is_some()\n-                        {\n+                        if self.use_ecx(location, |this| this.ecx.statement(statement)).is_some() {\n                             trace!(\"propped discriminant into {:?}\", place);\n                         } else {\n                             Self::remove_const(&mut self.ecx, place.local);\n@@ -594,12 +582,10 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     }\n \n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n-        let source_info = terminator.source_info;\n-        self.source_info = Some(source_info);\n         self.super_terminator(terminator, location);\n         match &terminator.kind {\n             TerminatorKind::Assert { expected, ref msg, ref cond, .. } => {\n-                if let Some(ref value) = self.eval_operand(&cond, source_info) {\n+                if let Some(ref value) = self.eval_operand(&cond, location) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n                     let expected = Scalar::from_bool(*expected);\n                     let Ok(value_const) = self.ecx.read_scalar(&value) else {\n@@ -623,7 +609,7 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                         let mut eval_to_int = |op| {\n                             // This can be `None` if the lhs wasn't const propagated and we just\n                             // triggered the assert on the value of the rhs.\n-                            self.eval_operand(op, source_info)\n+                            self.eval_operand(op, location)\n                                 .and_then(|op| self.ecx.read_immediate(&op).ok())\n                                 .map_or(DbgVal::Underscore, |op| DbgVal::Val(op.to_const_int()))\n                         };\n@@ -664,7 +650,7 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                         if let Some(msg) = msg {\n                             self.report_assert_as_lint(\n                                 lint::builtin::UNCONDITIONAL_PANIC,\n-                                source_info,\n+                                location,\n                                 \"this operation will panic at runtime\",\n                                 msg,\n                             );"}]}