{"sha": "c36572c11e0cd179d80b4540890bc046b78a0cb7", "node_id": "C_kwDOAAsO6NoAKGMzNjU3MmMxMWUwY2QxNzlkODBiNDU0MDg5MGJjMDQ2Yjc4YTBjYjc", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-02T14:53:34Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-02T15:41:16Z"}, "message": "add AllocRange Debug impl; remove redundant AllocId Display impl", "tree": {"sha": "012c2a367b48f273cc7e19d8638804c178e296ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/012c2a367b48f273cc7e19d8638804c178e296ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c36572c11e0cd179d80b4540890bc046b78a0cb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c36572c11e0cd179d80b4540890bc046b78a0cb7", "html_url": "https://github.com/rust-lang/rust/commit/c36572c11e0cd179d80b4540890bc046b78a0cb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c36572c11e0cd179d80b4540890bc046b78a0cb7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0075bb4fad68e64b6d1be06bf2db366c30bc75e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0075bb4fad68e64b6d1be06bf2db366c30bc75e1", "html_url": "https://github.com/rust-lang/rust/commit/0075bb4fad68e64b6d1be06bf2db366c30bc75e1"}], "stats": {"total": 86, "additions": 36, "deletions": 50}, "files": [{"sha": "ccf3647f0d90c463e44edfe245c33bb9bea12342", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=c36572c11e0cd179d80b4540890bc046b78a0cb7", "patch": "@@ -276,7 +276,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx> {\n         let (alloc_id, offset, tag) = self.ptr_get_alloc_id(ptr)?;\n-        trace!(\"deallocating: {}\", alloc_id);\n+        trace!(\"deallocating: {alloc_id:?}\");\n \n         if offset.bytes() != 0 {\n             throw_ub_format!(\n@@ -289,10 +289,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Deallocating global memory -- always an error\n             return Err(match self.tcx.get_global_alloc(alloc_id) {\n                 Some(GlobalAlloc::Function(..)) => {\n-                    err_ub_format!(\"deallocating {}, which is a function\", alloc_id)\n+                    err_ub_format!(\"deallocating {alloc_id:?}, which is a function\")\n                 }\n                 Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n-                    err_ub_format!(\"deallocating {}, which is static memory\", alloc_id)\n+                    err_ub_format!(\"deallocating {alloc_id:?}, which is static memory\")\n                 }\n                 None => err_ub!(PointerUseAfterFree(alloc_id)),\n             }\n@@ -302,21 +302,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         debug!(?alloc);\n \n         if alloc.mutability == Mutability::Not {\n-            throw_ub_format!(\"deallocating immutable allocation {}\", alloc_id);\n+            throw_ub_format!(\"deallocating immutable allocation {alloc_id:?}\");\n         }\n         if alloc_kind != kind {\n             throw_ub_format!(\n-                \"deallocating {}, which is {} memory, using {} deallocation operation\",\n-                alloc_id,\n+                \"deallocating {alloc_id:?}, which is {} memory, using {} deallocation operation\",\n                 alloc_kind,\n                 kind\n             );\n         }\n         if let Some((size, align)) = old_size_and_align {\n             if size != alloc.size() || align != alloc.align {\n                 throw_ub_format!(\n-                    \"incorrect layout on deallocation: {} has size {} and alignment {}, but gave size {} and alignment {}\",\n-                    alloc_id,\n+                    \"incorrect layout on deallocation: {alloc_id:?} has size {} and alignment {}, but gave size {} and alignment {}\",\n                     alloc.size().bytes(),\n                     alloc.align.bytes(),\n                     size.bytes(),\n@@ -815,7 +813,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n                 continue;\n             }\n \n-            write!(fmt, \"{}\", id)?;\n+            write!(fmt, \"{id:?}\")?;\n             match self.ecx.memory.alloc_map.get(id) {\n                 Some(&(kind, ref alloc)) => {\n                     // normal alloc\n@@ -865,13 +863,7 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n         val: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx> {\n         let range = self.range.subrange(range);\n-        debug!(\n-            \"write_scalar in {} at {:#x}, size {}: {:?}\",\n-            self.alloc_id,\n-            range.start.bytes(),\n-            range.size.bytes(),\n-            val\n-        );\n+        debug!(\"write_scalar at {:?}{range:?}: {val:?}\", self.alloc_id);\n         Ok(self\n             .alloc\n             .write_scalar(&self.tcx, range, val)\n@@ -906,13 +898,7 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n             .alloc\n             .read_scalar(&self.tcx, range, read_provenance)\n             .map_err(|e| e.to_interp_error(self.alloc_id))?;\n-        debug!(\n-            \"read_scalar in {} at {:#x}, size {}: {:?}\",\n-            self.alloc_id,\n-            range.start.bytes(),\n-            range.size.bytes(),\n-            res\n-        );\n+        debug!(\"read_scalar at {:?}{range:?}: {res:?}\", self.alloc_id);\n         Ok(res)\n     }\n "}, {"sha": "b9143802276f74e3e0c7243d310e309812cc17a0", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=c36572c11e0cd179d80b4540890bc046b78a0cb7", "patch": "@@ -160,12 +160,18 @@ impl AllocError {\n }\n \n /// The information that makes up a memory access: offset and size.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone)]\n pub struct AllocRange {\n     pub start: Size,\n     pub size: Size,\n }\n \n+impl fmt::Debug for AllocRange {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"[{:#x}..{:#x}]\", self.start.bytes(), self.end().bytes())\n+    }\n+}\n+\n /// Free-starting constructor for less syntactic overhead.\n #[inline(always)]\n pub fn alloc_range(start: Size, size: Size) -> AllocRange {"}, {"sha": "dbdbeb0830a41a7e8c51f2a196bb62f1439a6310", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=c36572c11e0cd179d80b4540890bc046b78a0cb7", "patch": "@@ -334,45 +334,39 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n                 p,\n             ),\n             PointerUseAfterFree(a) => {\n-                write!(f, \"pointer to {} was dereferenced after this allocation got freed\", a)\n+                write!(f, \"pointer to {a:?} was dereferenced after this allocation got freed\")\n             }\n             PointerOutOfBounds { alloc_id, alloc_size, ptr_offset, ptr_size: Size::ZERO, msg } => {\n                 write!(\n                     f,\n-                    \"{}{alloc_id} has size {alloc_size}, so pointer at offset {ptr_offset} is out-of-bounds\",\n-                    msg,\n-                    alloc_id = alloc_id,\n+                    \"{msg}{alloc_id:?} has size {alloc_size}, so pointer at offset {ptr_offset} is out-of-bounds\",\n                     alloc_size = alloc_size.bytes(),\n-                    ptr_offset = ptr_offset,\n                 )\n             }\n             PointerOutOfBounds { alloc_id, alloc_size, ptr_offset, ptr_size, msg } => write!(\n                 f,\n-                \"{}{alloc_id} has size {alloc_size}, so pointer to {ptr_size} byte{ptr_size_p} starting at offset {ptr_offset} is out-of-bounds\",\n-                msg,\n-                alloc_id = alloc_id,\n+                \"{msg}{alloc_id:?} has size {alloc_size}, so pointer to {ptr_size} byte{ptr_size_p} starting at offset {ptr_offset} is out-of-bounds\",\n                 alloc_size = alloc_size.bytes(),\n                 ptr_size = ptr_size.bytes(),\n                 ptr_size_p = pluralize!(ptr_size.bytes()),\n-                ptr_offset = ptr_offset,\n             ),\n             DanglingIntPointer(0, CheckInAllocMsg::InboundsTest) => {\n                 write!(f, \"null pointer is not a valid pointer for this operation\")\n             }\n             DanglingIntPointer(0, msg) => {\n-                write!(f, \"{}null pointer is not a valid pointer\", msg)\n+                write!(f, \"{msg}null pointer is not a valid pointer\")\n             }\n             DanglingIntPointer(i, msg) => {\n-                write!(f, \"{}0x{:x} is not a valid pointer\", msg, i)\n+                write!(f, \"{msg}{:#x} is not a valid pointer\", i)\n             }\n             AlignmentCheckFailed { required, has } => write!(\n                 f,\n                 \"accessing memory with alignment {}, but alignment {} is required\",\n                 has.bytes(),\n                 required.bytes()\n             ),\n-            WriteToReadOnly(a) => write!(f, \"writing to {} which is read-only\", a),\n-            DerefFunctionPointer(a) => write!(f, \"accessing {} which contains a function\", a),\n+            WriteToReadOnly(a) => write!(f, \"writing to {a:?} which is read-only\"),\n+            DerefFunctionPointer(a) => write!(f, \"accessing {a:?} which contains a function\"),\n             ValidationFailure { path: None, msg } => {\n                 write!(f, \"constructing invalid value: {}\", msg)\n             }"}, {"sha": "8b75483252776e7e9fcfb0d92f0660353b0d6efe", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=c36572c11e0cd179d80b4540890bc046b78a0cb7", "patch": "@@ -190,11 +190,7 @@ impl fmt::Debug for AllocId {\n     }\n }\n \n-impl fmt::Display for AllocId {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Debug::fmt(self, f)\n-    }\n-}\n+// No \"Display\" since AllocIds are not usually user-visible.\n \n #[derive(TyDecodable, TyEncodable)]\n enum AllocDiscriminant {\n@@ -470,7 +466,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             return alloc_id;\n         }\n         let id = alloc_map.reserve();\n-        debug!(\"creating alloc {:?} with id {}\", alloc, id);\n+        debug!(\"creating alloc {:?} with id {:?}\", alloc, id);\n         alloc_map.alloc_map.insert(id, alloc.clone());\n         alloc_map.dedup.insert(alloc, id);\n         id\n@@ -538,15 +534,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn global_alloc(self, id: AllocId) -> GlobalAlloc<'tcx> {\n         match self.get_global_alloc(id) {\n             Some(alloc) => alloc,\n-            None => bug!(\"could not find allocation for {}\", id),\n+            None => bug!(\"could not find allocation for {id:?}\"),\n         }\n     }\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n     pub fn set_alloc_id_memory(self, id: AllocId, mem: ConstAllocation<'tcx>) {\n         if let Some(old) = self.alloc_map.lock().alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n-            bug!(\"tried to set allocation ID {}, but it was already existing as {:#?}\", id, old);\n+            bug!(\"tried to set allocation ID {id:?}, but it was already existing as {old:#?}\");\n         }\n     }\n "}, {"sha": "81d744107fd569a288423ff27a2fa02039481b21", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=c36572c11e0cd179d80b4540890bc046b78a0cb7", "patch": "@@ -144,7 +144,7 @@ impl Provenance for AllocId {\n         }\n         // Print offset only if it is non-zero.\n         if ptr.offset.bytes() > 0 {\n-            write!(f, \"+0x{:x}\", ptr.offset.bytes())?;\n+            write!(f, \"+{:#x}\", ptr.offset.bytes())?;\n         }\n         Ok(())\n     }\n@@ -181,7 +181,7 @@ impl<Tag: Provenance> fmt::Debug for Pointer<Option<Tag>> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.provenance {\n             Some(tag) => Provenance::fmt(&Pointer::new(tag, self.offset), f),\n-            None => write!(f, \"0x{:x}\", self.offset.bytes()),\n+            None => write!(f, \"{:#x}\", self.offset.bytes()),\n         }\n     }\n }"}, {"sha": "8ecbb5ab0b31f70f068a02d770e3c6be2fae10d3", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=c36572c11e0cd179d80b4540890bc046b78a0cb7", "patch": "@@ -167,7 +167,7 @@ impl<Tag: Provenance> fmt::LowerHex for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(ptr, _size) => write!(f, \"pointer to {:?}\", ptr),\n-            Scalar::Int(int) => write!(f, \"0x{:x}\", int),\n+            Scalar::Int(int) => write!(f, \"{:#x}\", int),\n         }\n     }\n }"}, {"sha": "24c6cd91d0a54cfef880baf7fdb5686409544773", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=c36572c11e0cd179d80b4540890bc046b78a0cb7", "patch": "@@ -716,12 +716,12 @@ pub fn write_allocations<'tcx>(\n                 }\n                 write!(w, \"{}\", display_allocation(tcx, alloc.inner()))\n             };\n-        write!(w, \"\\n{}\", id)?;\n+        write!(w, \"\\n{id:?}\")?;\n         match tcx.get_global_alloc(id) {\n             // This can't really happen unless there are bugs, but it doesn't cost us anything to\n             // gracefully handle it and allow buggy rustc to be debugged via allocation printing.\n             None => write!(w, \" (deallocated)\")?,\n-            Some(GlobalAlloc::Function(inst)) => write!(w, \" (fn: {})\", inst)?,\n+            Some(GlobalAlloc::Function(inst)) => write!(w, \" (fn: {inst})\")?,\n             Some(GlobalAlloc::Static(did)) if !tcx.is_foreign_item(did) => {\n                 match tcx.eval_static_initializer(did) {\n                     Ok(alloc) => {"}, {"sha": "c7c2692281ebb9580ac2871dcfa874403eb9ccaf", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36572c11e0cd179d80b4540890bc046b78a0cb7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=c36572c11e0cd179d80b4540890bc046b78a0cb7", "patch": "@@ -452,6 +452,10 @@ impl fmt::Debug for ScalarInt {\n impl fmt::LowerHex for ScalarInt {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.check_data();\n+        if f.alternate() {\n+            // Like regular ints, alternate flag adds leading `0x`.\n+            write!(f, \"0x\")?;\n+        }\n         // Format as hex number wide enough to fit any value of the given `size`.\n         // So data=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n         // Using a block `{self.data}` here to force a copy instead of using `self.data`"}]}