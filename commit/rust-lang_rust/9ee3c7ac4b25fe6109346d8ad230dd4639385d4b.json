{"sha": "9ee3c7ac4b25fe6109346d8ad230dd4639385d4b", "node_id": "C_kwDOAAsO6NoAKDllZTNjN2FjNGIyNWZlNjEwOTM0NmQ4YWQyMzBkZDQ2MzkzODVkNGI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-14T17:02:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-14T17:02:50Z"}, "message": "Rollup merge of #107739 - spastorino:check-overflow-evaluate_canonical_goal, r=lcnr\n\nCheck for overflow in evaluate_canonical_goal\n\nr? `@lcnr`", "tree": {"sha": "2d8a490bf6378e79eaf94c203a5c1a93c8d6efba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d8a490bf6378e79eaf94c203a5c1a93c8d6efba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ee3c7ac4b25fe6109346d8ad230dd4639385d4b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj6766CRBK7hj4Ov3rIwAAFD4IAKoeNcXqHVrUG9KAkuLojG/Y\nZsbVXg2CBDQz0BI04Gf/++MzUEXm71SrPwVF1b3wY6tkDqfJohJAOWNJ2MBr2mdm\ny97SnR+cmSKk4KlJPxv5dq2hG7qZpJwkyHP5xji75uye9Rz+78I6VkJo/tryR4/Z\nchFyX6jVZDsCmq0l00G9nyQ31+2mXINq8PrmQcmn+vWJGq3k2vZs65MitV4Xn/pB\nt4yuybMIaWii6g1z9slEXnGCBLPDDc9sufYugKaiFIryES9pdP+5LBs1B/6gDTSZ\nrvG2yvcje9m6gHaL8djUUolEaO33HNI3F7ohZENqWK3AWukfKViGPUg+ynxmatE=\n=Ra0f\n-----END PGP SIGNATURE-----\n", "payload": "tree 2d8a490bf6378e79eaf94c203a5c1a93c8d6efba\nparent 202c70666f4fa0a5d823169620487fd685555f75\nparent 26136c6224345743952642600f7bafe78df46449\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1676394170 +0100\ncommitter GitHub <noreply@github.com> 1676394170 +0100\n\nRollup merge of #107739 - spastorino:check-overflow-evaluate_canonical_goal, r=lcnr\n\nCheck for overflow in evaluate_canonical_goal\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ee3c7ac4b25fe6109346d8ad230dd4639385d4b", "html_url": "https://github.com/rust-lang/rust/commit/9ee3c7ac4b25fe6109346d8ad230dd4639385d4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ee3c7ac4b25fe6109346d8ad230dd4639385d4b/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "202c70666f4fa0a5d823169620487fd685555f75", "url": "https://api.github.com/repos/rust-lang/rust/commits/202c70666f4fa0a5d823169620487fd685555f75", "html_url": "https://github.com/rust-lang/rust/commit/202c70666f4fa0a5d823169620487fd685555f75"}, {"sha": "26136c6224345743952642600f7bafe78df46449", "url": "https://api.github.com/repos/rust-lang/rust/commits/26136c6224345743952642600f7bafe78df46449", "html_url": "https://github.com/rust-lang/rust/commit/26136c6224345743952642600f7bafe78df46449"}], "stats": {"total": 227, "additions": 139, "deletions": 88}, "files": [{"sha": "32fcd751b468d4f71f4ff6798a0c37aa3ebb63d2", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/9ee3c7ac4b25fe6109346d8ad230dd4639385d4b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ee3c7ac4b25fe6109346d8ad230dd4639385d4b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=9ee3c7ac4b25fe6109346d8ad230dd4639385d4b", "patch": "@@ -31,6 +31,7 @@ use rustc_middle::ty::{\n };\n use rustc_span::DUMMY_SP;\n \n+use crate::solve::search_graph::OverflowHandler;\n use crate::traits::ObligationCause;\n \n mod assembly;\n@@ -210,27 +211,16 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n         canonical_goal: CanonicalGoal<'tcx>,\n     ) -> QueryResult<'tcx> {\n-        match search_graph.try_push_stack(tcx, canonical_goal) {\n-            Ok(()) => {}\n-            // Our goal is already on the stack, eager return.\n-            Err(response) => return response,\n-        }\n-\n-        // We may have to repeatedly recompute the goal in case of coinductive cycles,\n-        // check out the `cache` module for more information.\n+        // Deal with overflow, caching, and coinduction.\n         //\n-        // FIXME: Similar to `evaluate_all`, this has to check for overflow.\n-        loop {\n+        // The actual solver logic happens in `ecx.compute_goal`.\n+        search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n             let (ref infcx, goal, var_values) =\n                 tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n             let mut ecx =\n                 EvalCtxt { infcx, var_values, search_graph, in_projection_eq_hack: false };\n-            let result = ecx.compute_goal(goal);\n-\n-            if search_graph.try_finalize_goal(tcx, canonical_goal, result) {\n-                return result;\n-            }\n-        }\n+            ecx.compute_goal(goal)\n+        })\n     }\n \n     fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n@@ -485,35 +475,38 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         mut goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> Result<Certainty, NoSolution> {\n         let mut new_goals = Vec::new();\n-        self.repeat_while_none(|this| {\n-            let mut has_changed = Err(Certainty::Yes);\n-            for goal in goals.drain(..) {\n-                let (changed, certainty) = match this.evaluate_goal(goal) {\n-                    Ok(result) => result,\n-                    Err(NoSolution) => return Some(Err(NoSolution)),\n-                };\n-\n-                if changed {\n-                    has_changed = Ok(());\n-                }\n+        self.repeat_while_none(\n+            |_| Ok(Certainty::Maybe(MaybeCause::Overflow)),\n+            |this| {\n+                let mut has_changed = Err(Certainty::Yes);\n+                for goal in goals.drain(..) {\n+                    let (changed, certainty) = match this.evaluate_goal(goal) {\n+                        Ok(result) => result,\n+                        Err(NoSolution) => return Some(Err(NoSolution)),\n+                    };\n+\n+                    if changed {\n+                        has_changed = Ok(());\n+                    }\n \n-                match certainty {\n-                    Certainty::Yes => {}\n-                    Certainty::Maybe(_) => {\n-                        new_goals.push(goal);\n-                        has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                    match certainty {\n+                        Certainty::Yes => {}\n+                        Certainty::Maybe(_) => {\n+                            new_goals.push(goal);\n+                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                        }\n                     }\n                 }\n-            }\n \n-            match has_changed {\n-                Ok(()) => {\n-                    mem::swap(&mut new_goals, &mut goals);\n-                    None\n+                match has_changed {\n+                    Ok(()) => {\n+                        mem::swap(&mut new_goals, &mut goals);\n+                        None\n+                    }\n+                    Err(certainty) => Some(Ok(certainty)),\n                 }\n-                Err(certainty) => Some(Ok(certainty)),\n-            }\n-        })\n+            },\n+        )\n     }\n \n     // Recursively evaluates a list of goals to completion, making a query response."}, {"sha": "e9945cde5df25a13abe8912363a8e153b44fb828", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 70, "deletions": 26, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9ee3c7ac4b25fe6109346d8ad230dd4639385d4b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ee3c7ac4b25fe6109346d8ad230dd4639385d4b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=9ee3c7ac4b25fe6109346d8ad230dd4639385d4b", "patch": "@@ -3,6 +3,7 @@ mod overflow;\n \n use self::cache::ProvisionalEntry;\n use super::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n+pub(super) use crate::solve::search_graph::overflow::OverflowHandler;\n use cache::ProvisionalCache;\n use overflow::OverflowData;\n use rustc_index::vec::IndexVec;\n@@ -46,7 +47,7 @@ impl<'tcx> SearchGraph<'tcx> {\n     ///\n     /// This correctly updates the provisional cache if there is a cycle.\n     #[instrument(level = \"debug\", skip(self, tcx), ret)]\n-    pub(super) fn try_push_stack(\n+    fn try_push_stack(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n         goal: CanonicalGoal<'tcx>,\n@@ -121,19 +122,19 @@ impl<'tcx> SearchGraph<'tcx> {\n     ///\n     /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n     #[instrument(level = \"debug\", skip(self, tcx, actual_goal), ret)]\n-    pub(super) fn try_finalize_goal(\n+    fn try_finalize_goal(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n         actual_goal: CanonicalGoal<'tcx>,\n         response: QueryResult<'tcx>,\n     ) -> bool {\n-        let StackElem { goal, has_been_used } = self.stack.pop().unwrap();\n+        let stack_elem = self.stack.pop().unwrap();\n+        let StackElem { goal, has_been_used } = stack_elem;\n         assert_eq!(goal, actual_goal);\n \n         let cache = &mut self.provisional_cache;\n         let provisional_entry_index = *cache.lookup_table.get(&goal).unwrap();\n         let provisional_entry = &mut cache.entries[provisional_entry_index];\n-        let depth = provisional_entry.depth;\n         // We eagerly update the response in the cache here. If we have to reevaluate\n         // this goal we use the new response when hitting a cycle, and we definitely\n         // want to access the final response whenever we look at the cache.\n@@ -157,29 +158,72 @@ impl<'tcx> SearchGraph<'tcx> {\n             self.stack.push(StackElem { goal, has_been_used: false });\n             false\n         } else {\n-            // If not, we're done with this goal.\n-            //\n-            // Check whether that this goal doesn't depend on a goal deeper on the stack\n-            // and if so, move it and all nested goals to the global cache.\n-            //\n-            // Note that if any nested goal were to depend on something deeper on the stack,\n-            // this would have also updated the depth of the current goal.\n-            if depth == self.stack.next_index() {\n-                for (i, entry) in cache.entries.drain_enumerated(provisional_entry_index.index()..)\n-                {\n-                    let actual_index = cache.lookup_table.remove(&entry.goal);\n-                    debug_assert_eq!(Some(i), actual_index);\n-                    debug_assert!(entry.depth == depth);\n-                    cache::try_move_finished_goal_to_global_cache(\n-                        tcx,\n-                        &mut self.overflow_data,\n-                        &self.stack,\n-                        entry.goal,\n-                        entry.response,\n-                    );\n-                }\n-            }\n+            self.try_move_finished_goal_to_global_cache(tcx, stack_elem);\n             true\n         }\n     }\n+\n+    fn try_move_finished_goal_to_global_cache(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        stack_elem: StackElem<'tcx>,\n+    ) {\n+        let StackElem { goal, .. } = stack_elem;\n+        let cache = &mut self.provisional_cache;\n+        let provisional_entry_index = *cache.lookup_table.get(&goal).unwrap();\n+        let provisional_entry = &mut cache.entries[provisional_entry_index];\n+        let depth = provisional_entry.depth;\n+\n+        // If not, we're done with this goal.\n+        //\n+        // Check whether that this goal doesn't depend on a goal deeper on the stack\n+        // and if so, move it and all nested goals to the global cache.\n+        //\n+        // Note that if any nested goal were to depend on something deeper on the stack,\n+        // this would have also updated the depth of the current goal.\n+        if depth == self.stack.next_index() {\n+            for (i, entry) in cache.entries.drain_enumerated(provisional_entry_index.index()..) {\n+                let actual_index = cache.lookup_table.remove(&entry.goal);\n+                debug_assert_eq!(Some(i), actual_index);\n+                debug_assert!(entry.depth == depth);\n+                cache::try_move_finished_goal_to_global_cache(\n+                    tcx,\n+                    &mut self.overflow_data,\n+                    &self.stack,\n+                    entry.goal,\n+                    entry.response,\n+                );\n+            }\n+        }\n+    }\n+\n+    pub(super) fn with_new_goal(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        canonical_goal: CanonicalGoal<'tcx>,\n+        mut loop_body: impl FnMut(&mut Self) -> QueryResult<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        match self.try_push_stack(tcx, canonical_goal) {\n+            Ok(()) => {}\n+            // Our goal is already on the stack, eager return.\n+            Err(response) => return response,\n+        }\n+\n+        self.repeat_while_none(\n+            |this| {\n+                let result = this.deal_with_overflow(tcx, canonical_goal);\n+                let stack_elem = this.stack.pop().unwrap();\n+                this.try_move_finished_goal_to_global_cache(tcx, stack_elem);\n+                result\n+            },\n+            |this| {\n+                let result = loop_body(this);\n+                if this.try_finalize_goal(tcx, canonical_goal, result) {\n+                    Some(result)\n+                } else {\n+                    None\n+                }\n+            },\n+        )\n+    }\n }"}, {"sha": "56409b0602be9817e1044c5fe0b4fd7cfb055233", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/overflow.rs", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9ee3c7ac4b25fe6109346d8ad230dd4639385d4b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ee3c7ac4b25fe6109346d8ad230dd4639385d4b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs?ref=9ee3c7ac4b25fe6109346d8ad230dd4639385d4b", "patch": "@@ -50,6 +50,42 @@ impl OverflowData {\n     }\n }\n \n+pub(in crate::solve) trait OverflowHandler<'tcx> {\n+    fn search_graph(&mut self) -> &mut SearchGraph<'tcx>;\n+\n+    fn repeat_while_none<T>(\n+        &mut self,\n+        on_overflow: impl FnOnce(&mut Self) -> Result<T, NoSolution>,\n+        mut loop_body: impl FnMut(&mut Self) -> Option<Result<T, NoSolution>>,\n+    ) -> Result<T, NoSolution> {\n+        let start_depth = self.search_graph().overflow_data.additional_depth;\n+        let depth = self.search_graph().stack.len();\n+        while !self.search_graph().overflow_data.has_overflow(depth) {\n+            if let Some(result) = loop_body(self) {\n+                self.search_graph().overflow_data.additional_depth = start_depth;\n+                return result;\n+            }\n+\n+            self.search_graph().overflow_data.additional_depth += 1;\n+        }\n+        self.search_graph().overflow_data.additional_depth = start_depth;\n+        self.search_graph().overflow_data.deal_with_overflow();\n+        on_overflow(self)\n+    }\n+}\n+\n+impl<'tcx> OverflowHandler<'tcx> for EvalCtxt<'_, 'tcx> {\n+    fn search_graph(&mut self) -> &mut SearchGraph<'tcx> {\n+        &mut self.search_graph\n+    }\n+}\n+\n+impl<'tcx> OverflowHandler<'tcx> for SearchGraph<'tcx> {\n+    fn search_graph(&mut self) -> &mut SearchGraph<'tcx> {\n+        self\n+    }\n+}\n+\n impl<'tcx> SearchGraph<'tcx> {\n     pub fn deal_with_overflow(\n         &mut self,\n@@ -60,25 +96,3 @@ impl<'tcx> SearchGraph<'tcx> {\n         response_no_constraints(tcx, goal, Certainty::Maybe(MaybeCause::Overflow))\n     }\n }\n-\n-impl<'tcx> EvalCtxt<'_, 'tcx> {\n-    /// A `while`-loop which tracks overflow.\n-    pub fn repeat_while_none(\n-        &mut self,\n-        mut loop_body: impl FnMut(&mut Self) -> Option<Result<Certainty, NoSolution>>,\n-    ) -> Result<Certainty, NoSolution> {\n-        let start_depth = self.search_graph.overflow_data.additional_depth;\n-        let depth = self.search_graph.stack.len();\n-        while !self.search_graph.overflow_data.has_overflow(depth) {\n-            if let Some(result) = loop_body(self) {\n-                self.search_graph.overflow_data.additional_depth = start_depth;\n-                return result;\n-            }\n-\n-            self.search_graph.overflow_data.additional_depth += 1;\n-        }\n-        self.search_graph.overflow_data.additional_depth = start_depth;\n-        self.search_graph.overflow_data.deal_with_overflow();\n-        Ok(Certainty::Maybe(MaybeCause::Overflow))\n-    }\n-}"}]}