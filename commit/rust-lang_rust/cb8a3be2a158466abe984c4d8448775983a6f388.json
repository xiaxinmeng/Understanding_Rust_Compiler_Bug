{"sha": "cb8a3be2a158466abe984c4d8448775983a6f388", "node_id": "C_kwDOAAsO6NoAKGNiOGEzYmUyYTE1ODQ2NmFiZTk4NGM0ZDg0NDg3NzU5ODNhNmYzODg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-22T12:28:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-22T12:28:27Z"}, "message": "Auto merge of #12835 - fasterthanlime:sysroot-abi, r=fasterthanlime\n\nIntroduce proc-macro-srv/sysroot-abi\n\nStill a WIP.\n\nThis change is tracked by:\n\n  * https://github.com/rust-lang/rust-analyzer/issues/12818", "tree": {"sha": "4391662492ba2f98fa23f2bb6a08c0d24dc3430e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4391662492ba2f98fa23f2bb6a08c0d24dc3430e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb8a3be2a158466abe984c4d8448775983a6f388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb8a3be2a158466abe984c4d8448775983a6f388", "html_url": "https://github.com/rust-lang/rust/commit/cb8a3be2a158466abe984c4d8448775983a6f388", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb8a3be2a158466abe984c4d8448775983a6f388/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84a6fac37ad61ff512993ee64b47deff9a52c560", "url": "https://api.github.com/repos/rust-lang/rust/commits/84a6fac37ad61ff512993ee64b47deff9a52c560", "html_url": "https://github.com/rust-lang/rust/commit/84a6fac37ad61ff512993ee64b47deff9a52c560"}, {"sha": "e591ff32693b77ad3caf3e5b6d0301f55a6aa543", "url": "https://api.github.com/repos/rust-lang/rust/commits/e591ff32693b77ad3caf3e5b6d0301f55a6aa543", "html_url": "https://github.com/rust-lang/rust/commit/e591ff32693b77ad3caf3e5b6d0301f55a6aa543"}], "stats": {"total": 1063, "additions": 1053, "deletions": 10}, "files": [{"sha": "67bfbf01096062b8d7d310b85d06cb9cb5456e31", "filename": "Cargo.lock", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cb8a3be2a158466abe984c4d8448775983a6f388/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cb8a3be2a158466abe984c4d8448775983a6f388/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=cb8a3be2a158466abe984c4d8448775983a6f388", "patch": "@@ -247,6 +247,20 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"crossbeam\"\n+version = \"0.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4ae5588f6b3c3cb05239e90bd110f257254aecd01e4635400391aeae07497845\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crossbeam-channel\",\n+ \"crossbeam-deque\",\n+ \"crossbeam-epoch\",\n+ \"crossbeam-queue\",\n+ \"crossbeam-utils\",\n+]\n+\n [[package]]\n name = \"crossbeam-channel\"\n version = \"0.5.5\"\n@@ -282,6 +296,16 @@ dependencies = [\n  \"scopeguard\",\n ]\n \n+[[package]]\n+name = \"crossbeam-queue\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1f25d8400f4a7a5778f0e4e52384a48cbd9b5c495d110786187fc750075277a2\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crossbeam-utils\",\n+]\n+\n [[package]]\n name = \"crossbeam-utils\"\n version = \"0.8.10\"\n@@ -1022,9 +1046,9 @@ dependencies = [\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.12.0\"\n+version = \"1.13.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7709cef83f0c1f58f666e746a08b21e0085f7440fa6a29cc194d68aac97a4225\"\n+checksum = \"18a6dbe30758c9f83eb00cbea4ac95966305f5a7772f3f42ebfc7fc7eddbd8e1\"\n \n [[package]]\n name = \"oorandom\"\n@@ -1162,6 +1186,7 @@ dependencies = [\n name = \"proc-macro-srv\"\n version = \"0.0.0\"\n dependencies = [\n+ \"crossbeam\",\n  \"expect-test\",\n  \"libloading\",\n  \"mbe\","}, {"sha": "d7010e825aa9fddb7b35ec7c0f34cc677114de4f", "filename": "crates/proc-macro-api/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-api%2Fsrc%2Flib.rs?ref=cb8a3be2a158466abe984c4d8448775983a6f388", "patch": "@@ -26,7 +26,7 @@ use crate::{\n     process::ProcMacroProcessSrv,\n };\n \n-pub use version::{read_dylib_info, RustCInfo};\n+pub use version::{read_dylib_info, read_version, RustCInfo};\n \n #[derive(Copy, Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]\n pub enum ProcMacroKind {"}, {"sha": "030531b80d7bb0d7b511a6e1ba00016561a846c9", "filename": "crates/proc-macro-api/src/version.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-api%2Fsrc%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-api%2Fsrc%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-api%2Fsrc%2Fversion.rs?ref=cb8a3be2a158466abe984c4d8448775983a6f388", "patch": "@@ -16,6 +16,8 @@ pub struct RustCInfo {\n     pub channel: String,\n     pub commit: Option<String>,\n     pub date: Option<String>,\n+    // something like \"rustc 1.58.1 (db9d1b20b 2022-01-20)\"\n+    pub version_string: String,\n }\n \n /// Read rustc dylib information\n@@ -68,7 +70,7 @@ pub fn read_dylib_info(dylib_path: &AbsPath) -> io::Result<RustCInfo> {\n     }\n     let version = (version_numbers[0], version_numbers[1], version_numbers[2]);\n \n-    Ok(RustCInfo { version, channel, commit, date })\n+    Ok(RustCInfo { version, channel, commit, date, version_string: ver_str })\n }\n \n /// This is used inside read_version() to locate the \".rustc\" section\n@@ -102,7 +104,7 @@ fn read_section<'a>(dylib_binary: &'a [u8], section_name: &str) -> io::Result<&'\n /// * [some more bytes that we don't really care but about still there] :-)\n /// Check this issue for more about the bytes layout:\n /// <https://github.com/rust-lang/rust-analyzer/issues/6174>\n-fn read_version(dylib_path: &AbsPath) -> io::Result<String> {\n+pub fn read_version(dylib_path: &AbsPath) -> io::Result<String> {\n     let dylib_file = File::open(dylib_path)?;\n     let dylib_mmaped = unsafe { Mmap::map(&dylib_file) }?;\n "}, {"sha": "5746eac0b3790923886a9d90f020743c9cc44a38", "filename": "crates/proc-macro-srv/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2FCargo.toml?ref=cb8a3be2a158466abe984c4d8448775983a6f388", "patch": "@@ -24,9 +24,13 @@ tt = { path = \"../tt\", version = \"0.0.0\" }\n mbe = { path = \"../mbe\", version = \"0.0.0\" }\n paths = { path = \"../paths\", version = \"0.0.0\" }\n proc-macro-api = { path = \"../proc-macro-api\", version = \"0.0.0\" }\n+crossbeam = \"0.8.1\"\n \n [dev-dependencies]\n expect-test = \"1.4.0\"\n \n # used as proc macro test targets\n proc-macro-test = { path = \"../proc-macro-test\" }\n+\n+[features]\n+sysroot-abi = []"}, {"sha": "a8c732f31541daa12827a51f67d12b61cd248b66", "filename": "crates/proc-macro-srv/build.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fbuild.rs?ref=cb8a3be2a158466abe984c4d8448775983a6f388", "patch": "@@ -0,0 +1,25 @@\n+//! Determine rustc version `proc-macro-srv` (and thus the sysroot ABI) is\n+//! build with and make it accessible at runtime for ABI selection.\n+\n+use std::{env, fs::File, io::Write, path::PathBuf, process::Command};\n+\n+fn main() {\n+    let mut path = PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n+    path.push(\"rustc_version.rs\");\n+    let mut f = File::create(&path).unwrap();\n+\n+    let rustc = env::var(\"RUSTC\").expect(\"proc-macro-srv's build script expects RUSTC to be set\");\n+    let output = Command::new(rustc).arg(\"--version\").output().expect(\"rustc --version must run\");\n+    let version_string = std::str::from_utf8(&output.stdout[..])\n+        .expect(\"rustc --version output must be UTF-8\")\n+        .trim();\n+\n+    write!(\n+        f,\n+        \"\n+    #[allow(dead_code)]\n+    pub(crate) const RUSTC_VERSION_STRING: &str = {version_string:?};\n+    \"\n+    )\n+    .unwrap();\n+}"}, {"sha": "44712f419191b1af43d9ec32f409e046bb7d3024", "filename": "crates/proc-macro-srv/src/abis/abi_sysroot/mod.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fmod.rs?ref=cb8a3be2a158466abe984c4d8448775983a6f388", "patch": "@@ -0,0 +1,102 @@\n+//! Proc macro ABI\n+\n+extern crate proc_macro;\n+\n+#[allow(dead_code)]\n+#[doc(hidden)]\n+mod ra_server;\n+\n+use libloading::Library;\n+use proc_macro_api::ProcMacroKind;\n+\n+use super::PanicMessage;\n+\n+pub(crate) struct Abi {\n+    exported_macros: Vec<proc_macro::bridge::client::ProcMacro>,\n+}\n+\n+impl From<proc_macro::bridge::PanicMessage> for PanicMessage {\n+    fn from(p: proc_macro::bridge::PanicMessage) -> Self {\n+        Self { message: p.as_str().map(|s| s.to_string()) }\n+    }\n+}\n+\n+impl Abi {\n+    pub unsafe fn from_lib(lib: &Library, symbol_name: String) -> Result<Abi, libloading::Error> {\n+        let macros: libloading::Symbol<'_, &&[proc_macro::bridge::client::ProcMacro]> =\n+            lib.get(symbol_name.as_bytes())?;\n+        Ok(Self { exported_macros: macros.to_vec() })\n+    }\n+\n+    pub fn expand(\n+        &self,\n+        macro_name: &str,\n+        macro_body: &tt::Subtree,\n+        attributes: Option<&tt::Subtree>,\n+    ) -> Result<tt::Subtree, PanicMessage> {\n+        let parsed_body = ra_server::TokenStream::with_subtree(macro_body.clone());\n+\n+        let parsed_attributes = attributes.map_or(ra_server::TokenStream::new(), |attr| {\n+            ra_server::TokenStream::with_subtree(attr.clone())\n+        });\n+\n+        for proc_macro in &self.exported_macros {\n+            match proc_macro {\n+                proc_macro::bridge::client::ProcMacro::CustomDerive {\n+                    trait_name, client, ..\n+                } if *trait_name == macro_name => {\n+                    let res = client.run(\n+                        &proc_macro::bridge::server::SameThread,\n+                        ra_server::RustAnalyzer::default(),\n+                        parsed_body,\n+                        true,\n+                    );\n+                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                }\n+                proc_macro::bridge::client::ProcMacro::Bang { name, client }\n+                    if *name == macro_name =>\n+                {\n+                    let res = client.run(\n+                        &proc_macro::bridge::server::SameThread,\n+                        ra_server::RustAnalyzer::default(),\n+                        parsed_body,\n+                        true,\n+                    );\n+                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                }\n+                proc_macro::bridge::client::ProcMacro::Attr { name, client }\n+                    if *name == macro_name =>\n+                {\n+                    let res = client.run(\n+                        &proc_macro::bridge::server::SameThread,\n+                        ra_server::RustAnalyzer::default(),\n+                        parsed_attributes,\n+                        parsed_body,\n+                        true,\n+                    );\n+                    return res.map(|it| it.into_subtree()).map_err(PanicMessage::from);\n+                }\n+                _ => continue,\n+            }\n+        }\n+\n+        Err(proc_macro::bridge::PanicMessage::String(\"Nothing to expand\".to_string()).into())\n+    }\n+\n+    pub fn list_macros(&self) -> Vec<(String, ProcMacroKind)> {\n+        self.exported_macros\n+            .iter()\n+            .map(|proc_macro| match proc_macro {\n+                proc_macro::bridge::client::ProcMacro::CustomDerive { trait_name, .. } => {\n+                    (trait_name.to_string(), ProcMacroKind::CustomDerive)\n+                }\n+                proc_macro::bridge::client::ProcMacro::Bang { name, .. } => {\n+                    (name.to_string(), ProcMacroKind::FuncLike)\n+                }\n+                proc_macro::bridge::client::ProcMacro::Attr { name, .. } => {\n+                    (name.to_string(), ProcMacroKind::Attr)\n+                }\n+            })\n+            .collect()\n+    }\n+}"}, {"sha": "46882845a80798ee5060b95d1ac1d25d713fbcd2", "filename": "crates/proc-macro-srv/src/abis/abi_sysroot/ra_server.rs", "status": "added", "additions": 518, "deletions": 0, "changes": 518, "blob_url": "https://github.com/rust-lang/rust/blob/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server.rs?ref=cb8a3be2a158466abe984c4d8448775983a6f388", "patch": "@@ -0,0 +1,518 @@\n+//! proc-macro server implementation\n+//!\n+//! Based on idea from <https://github.com/fedochet/rust-proc-macro-expander>\n+//! The lib-proc-macro server backend is `TokenStream`-agnostic, such that\n+//! we could provide any TokenStream implementation.\n+//! The original idea from fedochet is using proc-macro2 as backend,\n+//! we use tt instead for better integration with RA.\n+//!\n+//! FIXME: No span and source file information is implemented yet\n+\n+use super::proc_macro::{\n+    self,\n+    bridge::{self, server},\n+};\n+\n+mod token_stream;\n+pub use token_stream::TokenStream;\n+use token_stream::TokenStreamBuilder;\n+\n+mod symbol;\n+pub use symbol::*;\n+\n+use std::{iter::FromIterator, ops::Bound};\n+\n+type Group = tt::Subtree;\n+type TokenTree = tt::TokenTree;\n+type Punct = tt::Punct;\n+type Spacing = tt::Spacing;\n+type Literal = tt::Literal;\n+type Span = tt::TokenId;\n+\n+#[derive(Clone)]\n+pub struct SourceFile {\n+    // FIXME stub\n+}\n+\n+type Level = super::proc_macro::Level;\n+type LineColumn = super::proc_macro::LineColumn;\n+\n+/// A structure representing a diagnostic message and associated children\n+/// messages.\n+#[derive(Clone, Debug)]\n+pub struct Diagnostic {\n+    level: Level,\n+    message: String,\n+    spans: Vec<Span>,\n+    children: Vec<Diagnostic>,\n+}\n+\n+impl Diagnostic {\n+    /// Creates a new diagnostic with the given `level` and `message`.\n+    pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n+        Diagnostic { level, message: message.into(), spans: vec![], children: vec![] }\n+    }\n+}\n+\n+pub struct FreeFunctions;\n+\n+#[derive(Default)]\n+pub struct RustAnalyzer {\n+    // FIXME: store span information here.\n+}\n+\n+impl server::Types for RustAnalyzer {\n+    type FreeFunctions = FreeFunctions;\n+    type TokenStream = TokenStream;\n+    type SourceFile = SourceFile;\n+    type MultiSpan = Vec<Span>;\n+    type Diagnostic = Diagnostic;\n+    type Span = Span;\n+    type Symbol = Symbol;\n+}\n+\n+impl server::FreeFunctions for RustAnalyzer {\n+    fn track_env_var(&mut self, _var: &str, _value: Option<&str>) {\n+        // FIXME: track env var accesses\n+        // https://github.com/rust-lang/rust/pull/71858\n+    }\n+    fn track_path(&mut self, _path: &str) {}\n+\n+    fn literal_from_str(\n+        &mut self,\n+        s: &str,\n+    ) -> Result<bridge::Literal<Self::Span, Self::Symbol>, ()> {\n+        // FIXME: keep track of LitKind and Suffix\n+        Ok(bridge::Literal {\n+            kind: bridge::LitKind::Err,\n+            symbol: Symbol::intern(s),\n+            suffix: None,\n+            span: tt::TokenId::unspecified(),\n+        })\n+    }\n+}\n+\n+impl server::TokenStream for RustAnalyzer {\n+    fn is_empty(&mut self, stream: &Self::TokenStream) -> bool {\n+        stream.is_empty()\n+    }\n+    fn from_str(&mut self, src: &str) -> Self::TokenStream {\n+        use std::str::FromStr;\n+\n+        Self::TokenStream::from_str(src).expect(\"cannot parse string\")\n+    }\n+    fn to_string(&mut self, stream: &Self::TokenStream) -> String {\n+        stream.to_string()\n+    }\n+    fn from_token_tree(\n+        &mut self,\n+        tree: bridge::TokenTree<Self::TokenStream, Self::Span, Self::Symbol>,\n+    ) -> Self::TokenStream {\n+        match tree {\n+            bridge::TokenTree::Group(group) => {\n+                let group = Group {\n+                    delimiter: delim_to_internal(group.delimiter),\n+                    token_trees: match group.stream {\n+                        Some(stream) => stream.into_iter().collect(),\n+                        None => Vec::new(),\n+                    },\n+                };\n+                let tree = TokenTree::from(group);\n+                Self::TokenStream::from_iter(vec![tree])\n+            }\n+\n+            bridge::TokenTree::Ident(ident) => {\n+                // FIXME: handle raw idents\n+                let text = ident.sym.text();\n+                let ident: tt::Ident = tt::Ident { text, id: ident.span };\n+                let leaf = tt::Leaf::from(ident);\n+                let tree = TokenTree::from(leaf);\n+                Self::TokenStream::from_iter(vec![tree])\n+            }\n+\n+            bridge::TokenTree::Literal(literal) => {\n+                let literal = LiteralFormatter(literal);\n+                let text = literal\n+                    .with_stringify_parts(|parts| tt::SmolStr::from_iter(parts.iter().copied()));\n+\n+                let literal = tt::Literal { text, id: literal.0.span };\n+                let leaf = tt::Leaf::from(literal);\n+                let tree = TokenTree::from(leaf);\n+                Self::TokenStream::from_iter(vec![tree])\n+            }\n+\n+            bridge::TokenTree::Punct(p) => {\n+                let punct = tt::Punct {\n+                    char: p.ch as char,\n+                    spacing: if p.joint { Spacing::Joint } else { Spacing::Alone },\n+                    id: p.span,\n+                };\n+                let leaf = tt::Leaf::from(punct);\n+                let tree = TokenTree::from(leaf);\n+                Self::TokenStream::from_iter(vec![tree])\n+            }\n+        }\n+    }\n+\n+    fn expand_expr(&mut self, self_: &Self::TokenStream) -> Result<Self::TokenStream, ()> {\n+        Ok(self_.clone())\n+    }\n+\n+    fn concat_trees(\n+        &mut self,\n+        base: Option<Self::TokenStream>,\n+        trees: Vec<bridge::TokenTree<Self::TokenStream, Self::Span, Self::Symbol>>,\n+    ) -> Self::TokenStream {\n+        let mut builder = TokenStreamBuilder::new();\n+        if let Some(base) = base {\n+            builder.push(base);\n+        }\n+        for tree in trees {\n+            builder.push(self.from_token_tree(tree));\n+        }\n+        builder.build()\n+    }\n+\n+    fn concat_streams(\n+        &mut self,\n+        base: Option<Self::TokenStream>,\n+        streams: Vec<Self::TokenStream>,\n+    ) -> Self::TokenStream {\n+        let mut builder = TokenStreamBuilder::new();\n+        if let Some(base) = base {\n+            builder.push(base);\n+        }\n+        for stream in streams {\n+            builder.push(stream);\n+        }\n+        builder.build()\n+    }\n+\n+    fn into_trees(\n+        &mut self,\n+        stream: Self::TokenStream,\n+    ) -> Vec<bridge::TokenTree<Self::TokenStream, Self::Span, Self::Symbol>> {\n+        stream\n+            .into_iter()\n+            .map(|tree| match tree {\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n+                    bridge::TokenTree::Ident(bridge::Ident {\n+                        sym: Symbol::intern(&ident.text),\n+                        // FIXME: handle raw idents\n+                        is_raw: false,\n+                        span: ident.id,\n+                    })\n+                }\n+                tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) => {\n+                    bridge::TokenTree::Literal(bridge::Literal {\n+                        // FIXME: handle literal kinds\n+                        kind: bridge::LitKind::Err,\n+                        symbol: Symbol::intern(&lit.text),\n+                        // FIXME: handle suffixes\n+                        suffix: None,\n+                        span: lit.id,\n+                    })\n+                }\n+                tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => {\n+                    bridge::TokenTree::Punct(bridge::Punct {\n+                        ch: punct.char as u8,\n+                        joint: punct.spacing == Spacing::Joint,\n+                        span: punct.id,\n+                    })\n+                }\n+                tt::TokenTree::Subtree(subtree) => bridge::TokenTree::Group(bridge::Group {\n+                    delimiter: delim_to_external(subtree.delimiter),\n+                    stream: if subtree.token_trees.is_empty() {\n+                        None\n+                    } else {\n+                        Some(subtree.token_trees.into_iter().collect())\n+                    },\n+                    span: bridge::DelimSpan::from_single(\n+                        subtree.delimiter.map_or(Span::unspecified(), |del| del.id),\n+                    ),\n+                }),\n+            })\n+            .collect()\n+    }\n+}\n+\n+fn delim_to_internal(d: proc_macro::Delimiter) -> Option<tt::Delimiter> {\n+    let kind = match d {\n+        proc_macro::Delimiter::Parenthesis => tt::DelimiterKind::Parenthesis,\n+        proc_macro::Delimiter::Brace => tt::DelimiterKind::Brace,\n+        proc_macro::Delimiter::Bracket => tt::DelimiterKind::Bracket,\n+        proc_macro::Delimiter::None => return None,\n+    };\n+    Some(tt::Delimiter { id: tt::TokenId::unspecified(), kind })\n+}\n+\n+fn delim_to_external(d: Option<tt::Delimiter>) -> proc_macro::Delimiter {\n+    match d.map(|it| it.kind) {\n+        Some(tt::DelimiterKind::Parenthesis) => proc_macro::Delimiter::Parenthesis,\n+        Some(tt::DelimiterKind::Brace) => proc_macro::Delimiter::Brace,\n+        Some(tt::DelimiterKind::Bracket) => proc_macro::Delimiter::Bracket,\n+        None => proc_macro::Delimiter::None,\n+    }\n+}\n+\n+fn spacing_to_internal(spacing: proc_macro::Spacing) -> Spacing {\n+    match spacing {\n+        proc_macro::Spacing::Alone => Spacing::Alone,\n+        proc_macro::Spacing::Joint => Spacing::Joint,\n+    }\n+}\n+\n+fn spacing_to_external(spacing: Spacing) -> proc_macro::Spacing {\n+    match spacing {\n+        Spacing::Alone => proc_macro::Spacing::Alone,\n+        Spacing::Joint => proc_macro::Spacing::Joint,\n+    }\n+}\n+\n+impl server::SourceFile for RustAnalyzer {\n+    // FIXME these are all stubs\n+    fn eq(&mut self, _file1: &Self::SourceFile, _file2: &Self::SourceFile) -> bool {\n+        true\n+    }\n+    fn path(&mut self, _file: &Self::SourceFile) -> String {\n+        String::new()\n+    }\n+    fn is_real(&mut self, _file: &Self::SourceFile) -> bool {\n+        true\n+    }\n+}\n+\n+impl server::Diagnostic for RustAnalyzer {\n+    fn new(&mut self, level: Level, msg: &str, spans: Self::MultiSpan) -> Self::Diagnostic {\n+        let mut diag = Diagnostic::new(level, msg);\n+        diag.spans = spans;\n+        diag\n+    }\n+\n+    fn sub(\n+        &mut self,\n+        _diag: &mut Self::Diagnostic,\n+        _level: Level,\n+        _msg: &str,\n+        _spans: Self::MultiSpan,\n+    ) {\n+        // FIXME handle diagnostic\n+        //\n+    }\n+\n+    fn emit(&mut self, _diag: Self::Diagnostic) {\n+        // FIXME handle diagnostic\n+        // diag.emit()\n+    }\n+}\n+\n+impl server::Span for RustAnalyzer {\n+    fn debug(&mut self, span: Self::Span) -> String {\n+        format!(\"{:?}\", span.0)\n+    }\n+    fn source_file(&mut self, _span: Self::Span) -> Self::SourceFile {\n+        SourceFile {}\n+    }\n+    fn save_span(&mut self, _span: Self::Span) -> usize {\n+        // FIXME stub\n+        0\n+    }\n+    fn recover_proc_macro_span(&mut self, _id: usize) -> Self::Span {\n+        // FIXME stub\n+        tt::TokenId::unspecified()\n+    }\n+    /// Recent feature, not yet in the proc_macro\n+    ///\n+    /// See PR:\n+    /// https://github.com/rust-lang/rust/pull/55780\n+    fn source_text(&mut self, _span: Self::Span) -> Option<String> {\n+        None\n+    }\n+\n+    fn parent(&mut self, _span: Self::Span) -> Option<Self::Span> {\n+        // FIXME handle span\n+        None\n+    }\n+    fn source(&mut self, span: Self::Span) -> Self::Span {\n+        // FIXME handle span\n+        span\n+    }\n+    fn start(&mut self, _span: Self::Span) -> LineColumn {\n+        // FIXME handle span\n+        LineColumn { line: 0, column: 0 }\n+    }\n+    fn end(&mut self, _span: Self::Span) -> LineColumn {\n+        // FIXME handle span\n+        LineColumn { line: 0, column: 0 }\n+    }\n+    fn join(&mut self, first: Self::Span, _second: Self::Span) -> Option<Self::Span> {\n+        // Just return the first span again, because some macros will unwrap the result.\n+        Some(first)\n+    }\n+    fn subspan(\n+        &mut self,\n+        span: Self::Span,\n+        _start: Bound<usize>,\n+        _end: Bound<usize>,\n+    ) -> Option<Self::Span> {\n+        // Just return the span again, because some macros will unwrap the result.\n+        Some(span)\n+    }\n+    fn resolved_at(&mut self, _span: Self::Span, _at: Self::Span) -> Self::Span {\n+        // FIXME handle span\n+        tt::TokenId::unspecified()\n+    }\n+\n+    fn after(&mut self, _self_: Self::Span) -> Self::Span {\n+        tt::TokenId::unspecified()\n+    }\n+\n+    fn before(&mut self, _self_: Self::Span) -> Self::Span {\n+        tt::TokenId::unspecified()\n+    }\n+}\n+\n+impl server::MultiSpan for RustAnalyzer {\n+    fn new(&mut self) -> Self::MultiSpan {\n+        // FIXME handle span\n+        vec![]\n+    }\n+\n+    fn push(&mut self, other: &mut Self::MultiSpan, span: Self::Span) {\n+        //TODP\n+        other.push(span)\n+    }\n+}\n+\n+impl server::Symbol for RustAnalyzer {\n+    fn normalize_and_validate_ident(&mut self, string: &str) -> Result<Self::Symbol, ()> {\n+        // FIXME: nfc-normalize and validate idents\n+        Ok(<Self as server::Server>::intern_symbol(string))\n+    }\n+}\n+\n+impl server::Server for RustAnalyzer {\n+    fn globals(&mut self) -> bridge::ExpnGlobals<Self::Span> {\n+        bridge::ExpnGlobals {\n+            def_site: Span::unspecified(),\n+            call_site: Span::unspecified(),\n+            mixed_site: Span::unspecified(),\n+        }\n+    }\n+\n+    fn intern_symbol(ident: &str) -> Self::Symbol {\n+        Symbol::intern(&tt::SmolStr::from(ident))\n+    }\n+\n+    fn with_symbol_string(symbol: &Self::Symbol, f: impl FnOnce(&str)) {\n+        f(symbol.text().as_str())\n+    }\n+}\n+\n+struct LiteralFormatter(bridge::Literal<tt::TokenId, Symbol>);\n+\n+impl LiteralFormatter {\n+    /// Invokes the callback with a `&[&str]` consisting of each part of the\n+    /// literal's representation. This is done to allow the `ToString` and\n+    /// `Display` implementations to borrow references to symbol values, and\n+    /// both be optimized to reduce overhead.\n+    fn with_stringify_parts<R>(&self, f: impl FnOnce(&[&str]) -> R) -> R {\n+        /// Returns a string containing exactly `num` '#' characters.\n+        /// Uses a 256-character source string literal which is always safe to\n+        /// index with a `u8` index.\n+        fn get_hashes_str(num: u8) -> &'static str {\n+            const HASHES: &str = \"\\\n+                        ################################################################\\\n+                        ################################################################\\\n+                        ################################################################\\\n+                        ################################################################\\\n+                        \";\n+            const _: () = assert!(HASHES.len() == 256);\n+            &HASHES[..num as usize]\n+        }\n+\n+        self.with_symbol_and_suffix(|symbol, suffix| match self.0.kind {\n+            bridge::LitKind::Byte => f(&[\"b'\", symbol, \"'\", suffix]),\n+            bridge::LitKind::Char => f(&[\"'\", symbol, \"'\", suffix]),\n+            bridge::LitKind::Str => f(&[\"\\\"\", symbol, \"\\\"\", suffix]),\n+            bridge::LitKind::StrRaw(n) => {\n+                let hashes = get_hashes_str(n);\n+                f(&[\"r\", hashes, \"\\\"\", symbol, \"\\\"\", hashes, suffix])\n+            }\n+            bridge::LitKind::ByteStr => f(&[\"b\\\"\", symbol, \"\\\"\", suffix]),\n+            bridge::LitKind::ByteStrRaw(n) => {\n+                let hashes = get_hashes_str(n);\n+                f(&[\"br\", hashes, \"\\\"\", symbol, \"\\\"\", hashes, suffix])\n+            }\n+            _ => f(&[symbol, suffix]),\n+        })\n+    }\n+\n+    fn with_symbol_and_suffix<R>(&self, f: impl FnOnce(&str, &str) -> R) -> R {\n+        let symbol = self.0.symbol.text();\n+        let suffix = self.0.suffix.map(|s| s.text()).unwrap_or_default();\n+        f(symbol.as_str(), suffix.as_str())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_ra_server_to_string() {\n+        let s = TokenStream {\n+            token_trees: vec![\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                    text: \"struct\".into(),\n+                    id: tt::TokenId::unspecified(),\n+                })),\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                    text: \"T\".into(),\n+                    id: tt::TokenId::unspecified(),\n+                })),\n+                tt::TokenTree::Subtree(tt::Subtree {\n+                    delimiter: Some(tt::Delimiter {\n+                        id: tt::TokenId::unspecified(),\n+                        kind: tt::DelimiterKind::Brace,\n+                    }),\n+                    token_trees: vec![],\n+                }),\n+            ],\n+        };\n+\n+        assert_eq!(s.to_string(), \"struct T {}\");\n+    }\n+\n+    #[test]\n+    fn test_ra_server_from_str() {\n+        use std::str::FromStr;\n+        let subtree_paren_a = tt::TokenTree::Subtree(tt::Subtree {\n+            delimiter: Some(tt::Delimiter {\n+                id: tt::TokenId::unspecified(),\n+                kind: tt::DelimiterKind::Parenthesis,\n+            }),\n+            token_trees: vec![tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                text: \"a\".into(),\n+                id: tt::TokenId::unspecified(),\n+            }))],\n+        });\n+\n+        let t1 = TokenStream::from_str(\"(a)\").unwrap();\n+        assert_eq!(t1.token_trees.len(), 1);\n+        assert_eq!(t1.token_trees[0], subtree_paren_a);\n+\n+        let t2 = TokenStream::from_str(\"(a);\").unwrap();\n+        assert_eq!(t2.token_trees.len(), 2);\n+        assert_eq!(t2.token_trees[0], subtree_paren_a);\n+\n+        let underscore = TokenStream::from_str(\"_\").unwrap();\n+        assert_eq!(\n+            underscore.token_trees[0],\n+            tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                text: \"_\".into(),\n+                id: tt::TokenId::unspecified(),\n+            }))\n+        );\n+    }\n+}"}, {"sha": "51dfba2ea9fb479bbb8dc7b12807edd4341f1d4b", "filename": "crates/proc-macro-srv/src/abis/abi_sysroot/ra_server/symbol.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Fsymbol.rs?ref=cb8a3be2a158466abe984c4d8448775983a6f388", "patch": "@@ -0,0 +1,46 @@\n+//! Symbol interner for proc-macro-srv\n+\n+use std::{cell::RefCell, collections::HashMap};\n+use tt::SmolStr;\n+\n+thread_local! {\n+    static SYMBOL_INTERNER: RefCell<SymbolInterner> = Default::default();\n+}\n+\n+// ID for an interned symbol.\n+#[derive(Hash, Eq, PartialEq, Copy, Clone)]\n+pub struct Symbol(u32);\n+\n+impl Symbol {\n+    pub fn intern(data: &str) -> Symbol {\n+        SYMBOL_INTERNER.with(|i| i.borrow_mut().intern(data))\n+    }\n+\n+    pub fn text(&self) -> SmolStr {\n+        SYMBOL_INTERNER.with(|i| i.borrow().get(self).clone())\n+    }\n+}\n+\n+#[derive(Default)]\n+struct SymbolInterner {\n+    idents: HashMap<SmolStr, u32>,\n+    ident_data: Vec<SmolStr>,\n+}\n+\n+impl SymbolInterner {\n+    fn intern(&mut self, data: &str) -> Symbol {\n+        if let Some(index) = self.idents.get(data) {\n+            return Symbol(*index);\n+        }\n+\n+        let index = self.idents.len() as u32;\n+        let data = SmolStr::from(data);\n+        self.ident_data.push(data.clone());\n+        self.idents.insert(data, index);\n+        Symbol(index)\n+    }\n+\n+    fn get(&self, sym: &Symbol) -> &SmolStr {\n+        &self.ident_data[sym.0 as usize]\n+    }\n+}"}, {"sha": "113bb52c1af5324fc5573ec2f8c074a1d14437e6", "filename": "crates/proc-macro-srv/src/abis/abi_sysroot/ra_server/token_stream.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Ftoken_stream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Ftoken_stream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fabi_sysroot%2Fra_server%2Ftoken_stream.rs?ref=cb8a3be2a158466abe984c4d8448775983a6f388", "patch": "@@ -0,0 +1,179 @@\n+//! TokenStream implementation used by sysroot ABI\n+\n+use tt::TokenTree;\n+\n+#[derive(Debug, Default, Clone)]\n+pub struct TokenStream {\n+    pub token_trees: Vec<TokenTree>,\n+}\n+\n+impl TokenStream {\n+    pub fn new() -> Self {\n+        TokenStream::default()\n+    }\n+\n+    pub fn with_subtree(subtree: tt::Subtree) -> Self {\n+        if subtree.delimiter.is_some() {\n+            TokenStream { token_trees: vec![TokenTree::Subtree(subtree)] }\n+        } else {\n+            TokenStream { token_trees: subtree.token_trees }\n+        }\n+    }\n+\n+    pub fn into_subtree(self) -> tt::Subtree {\n+        tt::Subtree { delimiter: None, token_trees: self.token_trees }\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.token_trees.is_empty()\n+    }\n+}\n+\n+/// Creates a token stream containing a single token tree.\n+impl From<TokenTree> for TokenStream {\n+    fn from(tree: TokenTree) -> TokenStream {\n+        TokenStream { token_trees: vec![tree] }\n+    }\n+}\n+\n+/// Collects a number of token trees into a single stream.\n+impl FromIterator<TokenTree> for TokenStream {\n+    fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n+        trees.into_iter().map(TokenStream::from).collect()\n+    }\n+}\n+\n+/// A \"flattening\" operation on token streams, collects token trees\n+/// from multiple token streams into a single stream.\n+impl FromIterator<TokenStream> for TokenStream {\n+    fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n+        let mut builder = TokenStreamBuilder::new();\n+        streams.into_iter().for_each(|stream| builder.push(stream));\n+        builder.build()\n+    }\n+}\n+\n+impl Extend<TokenTree> for TokenStream {\n+    fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, trees: I) {\n+        self.extend(trees.into_iter().map(TokenStream::from));\n+    }\n+}\n+\n+impl Extend<TokenStream> for TokenStream {\n+    fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {\n+        for item in streams {\n+            for tkn in item {\n+                match tkn {\n+                    tt::TokenTree::Subtree(subtree) if subtree.delimiter.is_none() => {\n+                        self.token_trees.extend(subtree.token_trees);\n+                    }\n+                    _ => {\n+                        self.token_trees.push(tkn);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub struct TokenStreamBuilder {\n+    acc: TokenStream,\n+}\n+\n+/// Public implementation details for the `TokenStream` type, such as iterators.\n+pub mod token_stream {\n+    use std::str::FromStr;\n+\n+    use super::{TokenStream, TokenTree};\n+\n+    /// An iterator over `TokenStream`'s `TokenTree`s.\n+    /// The iteration is \"shallow\", e.g., the iterator doesn't recurse into delimited groups,\n+    /// and returns whole groups as token trees.\n+    impl IntoIterator for TokenStream {\n+        type Item = TokenTree;\n+        type IntoIter = std::vec::IntoIter<TokenTree>;\n+\n+        fn into_iter(self) -> Self::IntoIter {\n+            self.token_trees.into_iter()\n+        }\n+    }\n+\n+    type LexError = String;\n+\n+    /// Attempts to break the string into tokens and parse those tokens into a token stream.\n+    /// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n+    /// or characters not existing in the language.\n+    /// All tokens in the parsed stream get `Span::call_site()` spans.\n+    ///\n+    /// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n+    /// change these errors into `LexError`s later.\n+    impl FromStr for TokenStream {\n+        type Err = LexError;\n+\n+        fn from_str(src: &str) -> Result<TokenStream, LexError> {\n+            let (subtree, _token_map) =\n+                mbe::parse_to_token_tree(src).ok_or(\"Failed to parse from mbe\")?;\n+\n+            let subtree = subtree_replace_token_ids_with_unspecified(subtree);\n+            Ok(TokenStream::with_subtree(subtree))\n+        }\n+    }\n+\n+    impl ToString for TokenStream {\n+        fn to_string(&self) -> String {\n+            tt::pretty(&self.token_trees)\n+        }\n+    }\n+\n+    fn subtree_replace_token_ids_with_unspecified(subtree: tt::Subtree) -> tt::Subtree {\n+        tt::Subtree {\n+            delimiter: subtree\n+                .delimiter\n+                .map(|d| tt::Delimiter { id: tt::TokenId::unspecified(), ..d }),\n+            token_trees: subtree\n+                .token_trees\n+                .into_iter()\n+                .map(token_tree_replace_token_ids_with_unspecified)\n+                .collect(),\n+        }\n+    }\n+\n+    fn token_tree_replace_token_ids_with_unspecified(tt: tt::TokenTree) -> tt::TokenTree {\n+        match tt {\n+            tt::TokenTree::Leaf(leaf) => {\n+                tt::TokenTree::Leaf(leaf_replace_token_ids_with_unspecified(leaf))\n+            }\n+            tt::TokenTree::Subtree(subtree) => {\n+                tt::TokenTree::Subtree(subtree_replace_token_ids_with_unspecified(subtree))\n+            }\n+        }\n+    }\n+\n+    fn leaf_replace_token_ids_with_unspecified(leaf: tt::Leaf) -> tt::Leaf {\n+        match leaf {\n+            tt::Leaf::Literal(lit) => {\n+                tt::Leaf::Literal(tt::Literal { id: tt::TokenId::unspecified(), ..lit })\n+            }\n+            tt::Leaf::Punct(punct) => {\n+                tt::Leaf::Punct(tt::Punct { id: tt::TokenId::unspecified(), ..punct })\n+            }\n+            tt::Leaf::Ident(ident) => {\n+                tt::Leaf::Ident(tt::Ident { id: tt::TokenId::unspecified(), ..ident })\n+            }\n+        }\n+    }\n+}\n+\n+impl TokenStreamBuilder {\n+    pub(super) fn new() -> TokenStreamBuilder {\n+        TokenStreamBuilder { acc: TokenStream::new() }\n+    }\n+\n+    pub(super) fn push(&mut self, stream: TokenStream) {\n+        self.acc.extend(stream.into_iter())\n+    }\n+\n+    pub(super) fn build(self) -> TokenStream {\n+        self.acc\n+    }\n+}"}, {"sha": "bcf3f1184cf6515dd8844f54833eb25e5ce0dd71", "filename": "crates/proc-macro-srv/src/abis/mod.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs?ref=cb8a3be2a158466abe984c4d8448775983a6f388", "patch": "@@ -26,6 +26,11 @@\n mod abi_1_58;\n mod abi_1_63;\n mod abi_1_64;\n+#[cfg(feature = \"sysroot-abi\")]\n+mod abi_sysroot;\n+\n+// see `build.rs`\n+include!(concat!(env!(\"OUT_DIR\"), \"/rustc_version.rs\"));\n \n // Used by `test/utils.rs`\n #[cfg(test)]\n@@ -35,6 +40,8 @@ use super::dylib::LoadProcMacroDylibError;\n pub(crate) use abi_1_58::Abi as Abi_1_58;\n pub(crate) use abi_1_63::Abi as Abi_1_63;\n pub(crate) use abi_1_64::Abi as Abi_1_64;\n+#[cfg(feature = \"sysroot-abi\")]\n+pub(crate) use abi_sysroot::Abi as Abi_Sysroot;\n use libloading::Library;\n use proc_macro_api::{ProcMacroKind, RustCInfo};\n \n@@ -52,6 +59,8 @@ pub(crate) enum Abi {\n     Abi1_58(Abi_1_58),\n     Abi1_63(Abi_1_63),\n     Abi1_64(Abi_1_64),\n+    #[cfg(feature = \"sysroot-abi\")]\n+    AbiSysroot(Abi_Sysroot),\n }\n \n impl Abi {\n@@ -69,6 +78,37 @@ impl Abi {\n         symbol_name: String,\n         info: RustCInfo,\n     ) -> Result<Abi, LoadProcMacroDylibError> {\n+        // the sysroot ABI relies on `extern proc_macro` with unstable features,\n+        // instead of a snapshot of the proc macro bridge's source code. it's only\n+        // enabled if we have an exact version match.\n+        #[cfg(feature = \"sysroot-abi\")]\n+        {\n+            if info.version_string == RUSTC_VERSION_STRING {\n+                let inner = unsafe { Abi_Sysroot::from_lib(lib, symbol_name) }?;\n+                return Ok(Abi::AbiSysroot(inner));\n+            }\n+\n+            // if we reached this point, versions didn't match. in testing, we\n+            // want that to panic - this could mean that the format of `rustc\n+            // --version` no longer matches the format of the version string\n+            // stored in the `.rustc` section, and we want to catch that in-tree\n+            // with `x.py test`\n+            #[cfg(test)]\n+            {\n+                let allow_mismatch = std::env::var(\"PROC_MACRO_SRV_ALLOW_SYSROOT_MISMATCH\");\n+                if let Ok(\"1\") = allow_mismatch.as_deref() {\n+                    // only used by rust-analyzer developers, when working on the\n+                    // sysroot ABI from the rust-analyzer repository - which should\n+                    // only happen pre-subtree. this can be removed later.\n+                } else {\n+                    panic!(\n+                        \"sysroot ABI mismatch: dylib rustc version (read from .rustc section): {:?} != proc-macro-srv version (read from 'rustc --version'): {:?}\",\n+                        info.version_string, RUSTC_VERSION_STRING\n+                    );\n+                }\n+            }\n+        }\n+\n         // FIXME: this should use exclusive ranges when they're stable\n         // https://github.com/rust-lang/rust/issues/37854\n         match (info.version.0, info.version.1) {\n@@ -98,6 +138,8 @@ impl Abi {\n             Self::Abi1_58(abi) => abi.expand(macro_name, macro_body, attributes),\n             Self::Abi1_63(abi) => abi.expand(macro_name, macro_body, attributes),\n             Self::Abi1_64(abi) => abi.expand(macro_name, macro_body, attributes),\n+            #[cfg(feature = \"sysroot-abi\")]\n+            Self::AbiSysroot(abi) => abi.expand(macro_name, macro_body, attributes),\n         }\n     }\n \n@@ -106,6 +148,8 @@ impl Abi {\n             Self::Abi1_58(abi) => abi.list_macros(),\n             Self::Abi1_63(abi) => abi.list_macros(),\n             Self::Abi1_64(abi) => abi.list_macros(),\n+            #[cfg(feature = \"sysroot-abi\")]\n+            Self::AbiSysroot(abi) => abi.list_macros(),\n         }\n     }\n }"}, {"sha": "4b1858b8ed89e87c87b4e6d481911427936d7e6c", "filename": "crates/proc-macro-srv/src/lib.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Flib.rs?ref=cb8a3be2a158466abe984c4d8448775983a6f388", "patch": "@@ -11,6 +11,10 @@\n //!   rustc rather than `unstable`. (Although in general ABI compatibility is still an issue)\u2026\n \n #![warn(rust_2018_idioms, unused_lifetimes, semicolon_in_expressions_from_macros)]\n+#![cfg_attr(\n+    feature = \"sysroot-abi\",\n+    feature(proc_macro_internals, proc_macro_diagnostic, proc_macro_span)\n+)]\n #![allow(unreachable_pub)]\n \n mod dylib;\n@@ -59,9 +63,26 @@ impl ProcMacroSrv {\n \n         let macro_body = task.macro_body.to_subtree();\n         let attributes = task.attributes.map(|it| it.to_subtree());\n-        let result = expander\n-            .expand(&task.macro_name, &macro_body, attributes.as_ref())\n-            .map(|it| FlatTree::new(&it));\n+        // FIXME: replace this with std's scoped threads once they stabilize\n+        // (then remove dependency on crossbeam)\n+        let result = crossbeam::scope(|s| {\n+            let res = s\n+                .spawn(|_| {\n+                    expander\n+                        .expand(&task.macro_name, &macro_body, attributes.as_ref())\n+                        .map(|it| FlatTree::new(&it))\n+                })\n+                .join();\n+\n+            match res {\n+                Ok(res) => res,\n+                Err(e) => std::panic::resume_unwind(e),\n+            }\n+        });\n+        let result = match result {\n+            Ok(result) => result,\n+            Err(e) => std::panic::resume_unwind(e),\n+        };\n \n         prev_env.rollback();\n "}, {"sha": "07222907f08806b9e48d7d20ec31edebd28912b7", "filename": "crates/proc-macro-srv/src/tests/mod.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-srv%2Fsrc%2Ftests%2Fmod.rs?ref=cb8a3be2a158466abe984c4d8448775983a6f388", "patch": "@@ -56,6 +56,48 @@ fn test_fn_like_macro_clone_ident_subtree() {\n     );\n }\n \n+#[test]\n+fn test_fn_like_macro_clone_raw_ident() {\n+    assert_expand(\n+        \"fn_like_clone_tokens\",\n+        \"r#async\",\n+        expect![[r#\"\n+            SUBTREE $\n+              IDENT   async 4294967295\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_fn_like_mk_literals() {\n+    assert_expand(\n+        \"fn_like_mk_literals\",\n+        r#\"\"#,\n+        expect![[r#\"\n+            SUBTREE $\n+              LITERAL b\"byte_string\" 4294967295\n+              LITERAL 'c' 4294967295\n+              LITERAL \"string\" 4294967295\n+              LITERAL 3.14f64 4294967295\n+              LITERAL 3.14 4294967295\n+              LITERAL 123i64 4294967295\n+              LITERAL 123 4294967295\"#]],\n+    );\n+}\n+\n+#[test]\n+fn test_fn_like_mk_idents() {\n+    // FIXME: this test is wrong: raw should be 'r#raw' but ABIs 1.64 and below\n+    // simply ignore `is_raw` when implementing the `Ident` interface.\n+    assert_expand(\n+        \"fn_like_mk_idents\",\n+        r#\"\"#,\n+        expect![[r#\"\n+            SUBTREE $\n+              IDENT   standard 4294967295\n+              IDENT   raw 4294967295\"#]],\n+    );\n+}\n+\n #[test]\n fn test_fn_like_macro_clone_literals() {\n     assert_expand(\n@@ -105,6 +147,8 @@ fn list_test_macros() {\n         fn_like_panic [FuncLike]\n         fn_like_error [FuncLike]\n         fn_like_clone_tokens [FuncLike]\n+        fn_like_mk_literals [FuncLike]\n+        fn_like_mk_idents [FuncLike]\n         attr_noop [Attr]\n         attr_panic [Attr]\n         attr_error [Attr]"}, {"sha": "feeacdb6407afb85680729e9ca11eca22e76bfa8", "filename": "crates/proc-macro-test/imp/src/lib.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-test%2Fimp%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Fproc-macro-test%2Fimp%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc-macro-test%2Fimp%2Fsrc%2Flib.rs?ref=cb8a3be2a158466abe984c4d8448775983a6f388", "patch": "@@ -2,7 +2,7 @@\n \n #![warn(rust_2018_idioms, unused_lifetimes, semicolon_in_expressions_from_macros)]\n \n-use proc_macro::{Group, Ident, Literal, Punct, TokenStream, TokenTree};\n+use proc_macro::{Group, Ident, Literal, Punct, Span, TokenStream, TokenTree};\n \n #[proc_macro]\n pub fn fn_like_noop(args: TokenStream) -> TokenStream {\n@@ -24,6 +24,31 @@ pub fn fn_like_clone_tokens(args: TokenStream) -> TokenStream {\n     clone_stream(args)\n }\n \n+#[proc_macro]\n+pub fn fn_like_mk_literals(_args: TokenStream) -> TokenStream {\n+    let trees: Vec<TokenTree> = vec![\n+        TokenTree::from(Literal::byte_string(b\"byte_string\")),\n+        TokenTree::from(Literal::character('c')),\n+        TokenTree::from(Literal::string(\"string\")),\n+        // as of 2022-07-21, there's no method on `Literal` to build a raw\n+        // string or a raw byte string\n+        TokenTree::from(Literal::f64_suffixed(3.14)),\n+        TokenTree::from(Literal::f64_unsuffixed(3.14)),\n+        TokenTree::from(Literal::i64_suffixed(123)),\n+        TokenTree::from(Literal::i64_unsuffixed(123)),\n+    ];\n+    TokenStream::from_iter(trees)\n+}\n+\n+#[proc_macro]\n+pub fn fn_like_mk_idents(_args: TokenStream) -> TokenStream {\n+    let trees: Vec<TokenTree> = vec![\n+        TokenTree::from(Ident::new(\"standard\", Span::call_site())),\n+        TokenTree::from(Ident::new_raw(\"raw\", Span::call_site())),\n+    ];\n+    TokenStream::from_iter(trees)\n+}\n+\n #[proc_macro_attribute]\n pub fn attr_noop(_args: TokenStream, item: TokenStream) -> TokenStream {\n     item\n@@ -65,7 +90,14 @@ fn clone_tree(t: TokenTree) -> TokenTree {\n             new.set_span(orig.span());\n             TokenTree::Group(new)\n         }\n-        TokenTree::Ident(orig) => TokenTree::Ident(Ident::new(&orig.to_string(), orig.span())),\n+        TokenTree::Ident(orig) => {\n+            let s = orig.to_string();\n+            if let Some(rest) = s.strip_prefix(\"r#\") {\n+                TokenTree::Ident(Ident::new_raw(rest, orig.span()))\n+            } else {\n+                TokenTree::Ident(Ident::new(&s, orig.span()))\n+            }\n+        }\n         TokenTree::Punct(orig) => {\n             let mut new = Punct::new(orig.as_char(), orig.spacing());\n             new.set_span(orig.span());"}, {"sha": "41205f2584a970e71cd1ecc2facebc1970449ff7", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb8a3be2a158466abe984c4d8448775983a6f388/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=cb8a3be2a158466abe984c4d8448775983a6f388", "patch": "@@ -84,3 +84,4 @@ mbe = { path = \"../mbe\" }\n [features]\n jemalloc = [\"jemallocator\", \"profile/jemalloc\"]\n force-always-assert = [\"always-assert/force\"]\n+in-rust-tree = [\"proc-macro-srv/sysroot-abi\"]"}]}