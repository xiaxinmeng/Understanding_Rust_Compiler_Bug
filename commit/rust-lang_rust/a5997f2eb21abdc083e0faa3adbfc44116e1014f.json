{"sha": "a5997f2eb21abdc083e0faa3adbfc44116e1014f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1OTk3ZjJlYjIxYWJkYzA4M2UwZmFhM2FkYmZjNDQxMTZlMTAxNGY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-10T00:56:26Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-10T00:56:26Z"}, "message": "Actually perform handoff from caller to callee on move-mode args.", "tree": {"sha": "ac8debcedd918dac7f730bc8e6a830f08596ae4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac8debcedd918dac7f730bc8e6a830f08596ae4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5997f2eb21abdc083e0faa3adbfc44116e1014f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5997f2eb21abdc083e0faa3adbfc44116e1014f", "html_url": "https://github.com/rust-lang/rust/commit/a5997f2eb21abdc083e0faa3adbfc44116e1014f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5997f2eb21abdc083e0faa3adbfc44116e1014f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1", "html_url": "https://github.com/rust-lang/rust/commit/5adaa6f9562479fc9e2b85f00eb6ee73c42c80e1"}], "stats": {"total": 62, "additions": 53, "deletions": 9}, "files": [{"sha": "73527d84c245eeb1312c90bcdc0b0878e3483d17", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 41, "deletions": 9, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a5997f2eb21abdc083e0faa3adbfc44116e1014f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5997f2eb21abdc083e0faa3adbfc44116e1014f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a5997f2eb21abdc083e0faa3adbfc44116e1014f", "patch": "@@ -4656,7 +4656,10 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     ret rslt(bcx, pair_v);\n }\n \n-fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n+fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg,\n+                  lldestty0: TypeRef,\n+                  to_zero: &mutable[{v:ValueRef, t: ty::t}],\n+                  to_revoke: &mutable[ValueRef],\n                   e: &@ast::expr) -> result {\n     let ccx = bcx_ccx(cx);\n     let e_ty = ty::expr_ty(ccx.tcx, e);\n@@ -4711,6 +4714,15 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n         // we are now passing it as an arg, so need to load it.\n         val = bcx.build.Load(val);\n     }\n+\n+    // Collect arg for later if it happens to be one we've moving out.\n+    if arg.mode == ty::mo_move {\n+        if lv.is_mem {\n+            to_zero += ~[{v: lv.res.val, t: arg.ty}];\n+        } else {\n+            to_revoke += ~[lv.res.val];\n+        }\n+    }\n     ret rslt(bcx, val);\n }\n \n@@ -4724,10 +4736,18 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n fn trans_args(cx: &@block_ctxt, llenv: ValueRef,\n               gen: &option::t[generic_info], lliterbody: &option::t[ValueRef],\n               es: &[@ast::expr], fn_ty: &ty::t) ->\n-   {bcx: @block_ctxt, args: [ValueRef], retslot: ValueRef} {\n+   {bcx: @block_ctxt,\n+    args: [ValueRef],\n+    retslot: ValueRef,\n+    to_zero: [{v:ValueRef, t: ty::t}],\n+    to_revoke: [ValueRef] } {\n+\n     let args: [ty::arg] = ty::ty_fn_args(bcx_tcx(cx), fn_ty);\n     let llargs: [ValueRef] = ~[];\n     let lltydescs: [ValueRef] = ~[];\n+    let to_zero = ~[];\n+    let to_revoke = ~[];\n+\n     let bcx: @block_ctxt = cx;\n     // Arg 0: Output pointer.\n \n@@ -4736,9 +4756,9 @@ fn trans_args(cx: &@block_ctxt, llenv: ValueRef,\n     if bcx.build.is_terminated() {\n         // This means an earlier arg was divergent.\n         // So this arg can't be evaluated.\n-        ret {bcx: bcx, args: ~[], retslot: C_nil()};\n+        ret {bcx: bcx, args: ~[], retslot: C_nil(),\n+             to_zero: to_zero, to_revoke: to_revoke};\n     }\n-\n     let retty = ty::ty_fn_ret(bcx_tcx(cx), fn_ty);\n     let llretslot_res = alloc_ty(bcx, retty);\n     bcx = llretslot_res.bcx;\n@@ -4787,12 +4807,14 @@ fn trans_args(cx: &@block_ctxt, llenv: ValueRef,\n             // So this arg can't be evaluated.\n             break;\n         }\n-        let r = trans_arg_expr(bcx, args.(i), arg_tys.(i), e);\n+        let r = trans_arg_expr(bcx, args.(i), arg_tys.(i),\n+                               to_zero, to_revoke, e);\n         bcx = r.bcx;\n         llargs += ~[r.val];\n         i += 1u;\n     }\n-    ret {bcx: bcx, args: llargs, retslot: llretslot};\n+    ret {bcx: bcx, args: llargs, retslot: llretslot,\n+         to_zero: to_zero, to_revoke: to_revoke};\n }\n \n fn trans_call(cx: &@block_ctxt, f: &@ast::expr,\n@@ -4875,6 +4897,14 @@ fn trans_call(cx: &@block_ctxt, f: &@ast::expr,\n             // we should ignore llretslot.\n           }\n         }\n+\n+        // Forget about anything we moved out.\n+        for {v,t}: {v: ValueRef, t: ty::t} in args_res.to_zero {\n+            zero_alloca(bcx, v, t)\n+        }\n+        for v: ValueRef in args_res.to_revoke {\n+            revoke_clean(bcx, v)\n+        }\n     }\n     ret rslt(bcx, retval);\n }\n@@ -5493,7 +5523,9 @@ fn trans_put(cx: &@block_ctxt, e: &option::t[@ast::expr]) -> result {\n         let e_ty = ty::expr_ty(bcx_tcx(cx), x);\n         let arg = {mode: ty::mo_alias(false), ty: e_ty};\n         let arg_tys = type_of_explicit_args(bcx_ccx(cx), x.span, ~[arg]);\n-        let r = trans_arg_expr(bcx, arg, arg_tys.(0), x);\n+        let z = ~[];\n+        let k = ~[];\n+        let r = trans_arg_expr(bcx, arg, arg_tys.(0), z, k, x);\n         bcx = r.bcx;\n         llargs += ~[r.val];\n       }\n@@ -6035,13 +6067,13 @@ fn add_cleanups_for_args(bcx: &@block_ctxt, args: &[ast::arg],\n                          arg_tys: &[ty::arg]) {\n     let arg_n: uint = 0u;\n     for aarg: ast::arg  in args {\n-        if aarg.mode == ast::val {\n+        if aarg.mode == ast::val || aarg.mode == ast::move {\n             let argval;\n             alt bcx.fcx.llargs.find(aarg.id) {\n               some(x) { argval = x; }\n               _ {\n                 bcx_ccx(bcx).sess.span_fatal\n-                    (aarg.ty.span, \"unbound arg ID in copy_args_to_allocas\");\n+                    (aarg.ty.span, \"unbound arg ID in add_cleanups_for_args\");\n               }\n             }\n             add_clean(bcx, argval, arg_tys.(arg_n).ty);"}, {"sha": "07f40e403ffc66924becb481d67d2e46773a448e", "filename": "src/test/run-pass/move-arg-2.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5997f2eb21abdc083e0faa3adbfc44116e1014f/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5997f2eb21abdc083e0faa3adbfc44116e1014f/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-arg-2.rs?ref=a5997f2eb21abdc083e0faa3adbfc44116e1014f", "patch": "@@ -0,0 +1,12 @@\n+fn test(foo: -@[int]) {\n+    assert (foo.(0) == 10);\n+}\n+\n+fn main() {\n+    let x = @~[10];\n+    // Test forgetting a local by move-in\n+    test(x);\n+\n+    // Test forgetting a temporary by move-in.\n+    test(@~[10]);\n+}"}]}