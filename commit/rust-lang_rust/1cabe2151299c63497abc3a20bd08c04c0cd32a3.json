{"sha": "1cabe2151299c63497abc3a20bd08c04c0cd32a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjYWJlMjE1MTI5OWM2MzQ5N2FiYzNhMjBiZDA4YzA0YzBjZDMyYTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-22T23:51:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-22T23:51:59Z"}, "message": "Auto merge of #37487 - goffrie:break, r=nikomatsakis\n\nImplement the `loop_break_value` feature.\n\nThis implements RFC 1624, tracking issue #37339.\n- `FnCtxt` (in typeck) gets a stack of `LoopCtxt`s, which store the\n  currently deduced type of that loop, the desired type, and a list of\n  break expressions currently seen. `loop` loops get a fresh type\n  variable as their initial type (this logic is stolen from that for\n  arrays). `while` loops get `()`.\n- `break {expr}` looks up the broken loop, and unifies the type of\n  `expr` with the type of the loop.\n- `break` with no expr unifies the loop's type with `()`.\n- When building MIR, loops no longer construct a `()` value at\n  termination of the loop; rather, the `break` expression assigns the\n  result of the loop.\n- ~~I have also changed the loop scoping in MIR-building so that the test\n  of a while loop is not considered to be part of that loop. This makes\n  the rules consistent with #37360. The new loop scopes in typeck also\n  follow this rule. That means that `loop { while (break) {} }` now\n  terminates instead of looping forever. This is technically a breaking\n  change.~~\n- ~~On that note, expressions like `while break {}` and `if break {}` no\n  longer parse because `{}` is interpreted as an expression argument to\n  `break`. But no code except compiler test cases should do that anyway\n  because it makes no sense.~~\n- The RFC did not make it clear, but I chose to make `break ()` inside\n  of a `while` loop illegal, just in case we wanted to do anything with\n  that design space in the future.\n\nThis is my first time dealing with this part of rustc so I'm sure\nthere's plenty of problems to pick on here ^_^", "tree": {"sha": "d5117e6a154299f1ca35561e42e53fc59bb81d52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5117e6a154299f1ca35561e42e53fc59bb81d52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cabe2151299c63497abc3a20bd08c04c0cd32a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cabe2151299c63497abc3a20bd08c04c0cd32a3", "html_url": "https://github.com/rust-lang/rust/commit/1cabe2151299c63497abc3a20bd08c04c0cd32a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cabe2151299c63497abc3a20bd08c04c0cd32a3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bf2be9ceea90b650105cd1f78ad5a098a0d158d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bf2be9ceea90b650105cd1f78ad5a098a0d158d", "html_url": "https://github.com/rust-lang/rust/commit/3bf2be9ceea90b650105cd1f78ad5a098a0d158d"}, {"sha": "9d42549df40464899dda11fc9509f511046fb4c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d42549df40464899dda11fc9509f511046fb4c6", "html_url": "https://github.com/rust-lang/rust/commit/9d42549df40464899dda11fc9509f511046fb4c6"}], "stats": {"total": 857, "additions": 641, "deletions": 216}, "files": [{"sha": "c399623462b5d732368fe2fab0ac64b762521ee2", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -223,7 +223,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 expr_exit\n             }\n \n-            hir::ExprLoop(ref body, _) => {\n+            hir::ExprLoop(ref body, _, _) => {\n                 //\n                 //     [pred]\n                 //       |\n@@ -282,9 +282,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_unreachable_node()\n             }\n \n-            hir::ExprBreak(label) => {\n+            hir::ExprBreak(label, ref opt_expr) => {\n+                let v = self.opt_expr(opt_expr, pred);\n                 let loop_scope = self.find_scope(expr, label.map(|l| l.node));\n-                let b = self.add_ast_node(expr.id, &[pred]);\n+                let b = self.add_ast_node(expr.id, &[v]);\n                 self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n                 self.add_unreachable_node()"}, {"sha": "7dd88e36dd1f55ca7fe93d2092f2f893e801fe8c", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -882,7 +882,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_block(block);\n             walk_opt_sp_name(visitor, opt_sp_name);\n         }\n-        ExprLoop(ref block, ref opt_sp_name) => {\n+        ExprLoop(ref block, ref opt_sp_name, _) => {\n             visitor.visit_block(block);\n             walk_opt_sp_name(visitor, opt_sp_name);\n         }\n@@ -923,7 +923,11 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprBreak(ref opt_sp_name) | ExprAgain(ref opt_sp_name) => {\n+        ExprBreak(ref opt_sp_name, ref opt_expr) => {\n+            walk_opt_sp_name(visitor, opt_sp_name);\n+            walk_list!(visitor, visit_expr, opt_expr);\n+        }\n+        ExprAgain(ref opt_sp_name) => {\n             walk_opt_sp_name(visitor, opt_sp_name);\n         }\n         ExprRet(ref optional_expression) => {"}, {"sha": "5af7c18e1a1078f4c9cc14849f59b0691d8b01ba", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -1136,7 +1136,9 @@ impl<'a> LoweringContext<'a> {\n                                    self.lower_opt_sp_ident(opt_ident))\n                 }\n                 ExprKind::Loop(ref body, opt_ident) => {\n-                    hir::ExprLoop(self.lower_block(body), self.lower_opt_sp_ident(opt_ident))\n+                    hir::ExprLoop(self.lower_block(body),\n+                                  self.lower_opt_sp_ident(opt_ident),\n+                                  hir::LoopSource::Loop)\n                 }\n                 ExprKind::Match(ref expr, ref arms) => {\n                     hir::ExprMatch(P(self.lower_expr(expr)),\n@@ -1242,7 +1244,10 @@ impl<'a> LoweringContext<'a> {\n                     });\n                     hir::ExprPath(hir_qself, self.lower_path(path))\n                 }\n-                ExprKind::Break(opt_ident) => hir::ExprBreak(self.lower_opt_sp_ident(opt_ident)),\n+                ExprKind::Break(opt_ident, ref opt_expr) => {\n+                    hir::ExprBreak(self.lower_opt_sp_ident(opt_ident),\n+                                   opt_expr.as_ref().map(|x| P(self.lower_expr(x))))\n+                }\n                 ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_opt_sp_ident(opt_ident)),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n                 ExprKind::InlineAsm(ref asm) => {\n@@ -1410,7 +1415,8 @@ impl<'a> LoweringContext<'a> {\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = P(self.block_expr(P(match_expr)));\n-                    let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident));\n+                    let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident),\n+                                                  hir::LoopSource::WhileLet);\n                     // add attributes to the outer returned expr node\n                     let attrs = e.attrs.clone();\n                     return hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: attrs };\n@@ -1485,7 +1491,8 @@ impl<'a> LoweringContext<'a> {\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = P(self.block_expr(match_expr));\n-                    let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident));\n+                    let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident),\n+                                                  hir::LoopSource::ForLoop);\n                     let loop_expr = P(hir::Expr {\n                         id: e.id,\n                         node: loop_expr,\n@@ -1723,7 +1730,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_break(&mut self, span: Span, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        P(self.expr(span, hir::ExprBreak(None), attrs))\n+        P(self.expr(span, hir::ExprBreak(None, None), attrs))\n     }\n \n     fn expr_call(&mut self, span: Span, e: P<hir::Expr>, args: hir::HirVec<hir::Expr>)"}, {"sha": "31648765224254796ca75be5e292b5035ac9470b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -908,7 +908,7 @@ pub enum Expr_ {\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    ExprLoop(P<Block>, Option<Spanned<Name>>),\n+    ExprLoop(P<Block>, Option<Spanned<Name>>, LoopSource),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n     ExprMatch(P<Expr>, HirVec<Arm>, MatchSource),\n@@ -944,7 +944,7 @@ pub enum Expr_ {\n     /// A referencing operation (`&a` or `&mut a`)\n     ExprAddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Option<Spanned<Name>>),\n+    ExprBreak(Option<Spanned<Name>>, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n     ExprAgain(Option<Spanned<Name>>),\n     /// A `return`, with an optional value to be returned\n@@ -1002,6 +1002,18 @@ pub enum MatchSource {\n     TryDesugar,\n }\n \n+/// The loop type that yielded an ExprLoop\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum LoopSource {\n+    /// A `loop { .. }` loop\n+    Loop,\n+    /// A `while let _ = _ { .. }` loop\n+    WhileLet,\n+    /// A `for _ in _ { .. }` loop\n+    ForLoop,\n+}\n+\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum CaptureClause {\n     CaptureByValue,"}, {"sha": "c109e84bf6186a65ee7b224d962e5d3b982b6a31", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -1393,7 +1393,7 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n                 self.print_block(&blk)?;\n             }\n-            hir::ExprLoop(ref blk, opt_sp_name) => {\n+            hir::ExprLoop(ref blk, opt_sp_name, _) => {\n                 if let Some(sp_name) = opt_sp_name {\n                     self.print_name(sp_name.node)?;\n                     self.word_space(\":\")?;\n@@ -1471,13 +1471,17 @@ impl<'a> State<'a> {\n             hir::ExprPath(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, true)?\n             }\n-            hir::ExprBreak(opt_name) => {\n+            hir::ExprBreak(opt_name, ref opt_expr) => {\n                 word(&mut self.s, \"break\")?;\n                 space(&mut self.s)?;\n                 if let Some(name) = opt_name {\n                     self.print_name(name.node)?;\n                     space(&mut self.s)?;\n                 }\n+                if let Some(ref expr) = *opt_expr {\n+                    self.print_expr(expr)?;\n+                    space(&mut self.s)?;\n+                }\n             }\n             hir::ExprAgain(opt_name) => {\n                 word(&mut self.s, \"continue\")?;"}, {"sha": "594ed408d8cd48efed2a73c9c87873d96f384e4c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -472,11 +472,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_exprs(inputs);\n             }\n \n-            hir::ExprBreak(..) |\n             hir::ExprAgain(..) |\n             hir::ExprLit(..) => {}\n \n-            hir::ExprLoop(ref blk, _) => {\n+            hir::ExprLoop(ref blk, _, _) => {\n                 self.walk_block(&blk);\n             }\n \n@@ -514,7 +513,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.walk_block(&blk);\n             }\n \n-            hir::ExprRet(ref opt_expr) => {\n+            hir::ExprBreak(_, ref opt_expr) | hir::ExprRet(ref opt_expr) => {\n                 if let Some(ref expr) = *opt_expr {\n                     self.consume_expr(&expr);\n                 }"}, {"sha": "4b1787ba593cbcae173ec7b63239e4293e3c2983", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -490,7 +490,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       hir::ExprIndex(..) | hir::ExprField(..) | hir::ExprTupField(..) |\n       hir::ExprArray(..) | hir::ExprCall(..) | hir::ExprMethodCall(..) |\n       hir::ExprTup(..) | hir::ExprBinary(..) | hir::ExprAddrOf(..) |\n-      hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprBreak(_) |\n+      hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprBreak(..) |\n       hir::ExprAgain(_) | hir::ExprLit(_) | hir::ExprRet(..) |\n       hir::ExprBlock(..) | hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n@@ -990,7 +990,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n-          hir::ExprLoop(ref blk, _) => {\n+          hir::ExprLoop(ref blk, _, _) => {\n             self.propagate_through_loop(expr, LoopLoop, &blk, succ)\n           }\n \n@@ -1035,15 +1035,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n           }\n \n-          hir::ExprBreak(opt_label) => {\n+          hir::ExprBreak(opt_label, ref opt_expr) => {\n               // Find which label this break jumps to\n               let sc = self.find_loop_scope(opt_label.map(|l| l.node), expr.id, expr.span);\n \n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n \n               match self.break_ln.get(&sc) {\n-                  Some(&b) => b,\n+                  Some(&b) => self.propagate_through_opt_expr(opt_expr.as_ref().map(|e| &**e), b),\n                   None => span_bug!(expr.span, \"break to unknown label\")\n               }\n           }\n@@ -1057,7 +1057,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n               match self.cont_ln.get(&sc) {\n                   Some(&b) => b,\n-                  None => span_bug!(expr.span, \"loop to unknown label\")\n+                  None => span_bug!(expr.span, \"continue to unknown label\")\n               }\n           }\n "}, {"sha": "0dbde2d21caf5607bd145920a88874abe85407f3", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -805,7 +805,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &hir::Expr) {\n                 terminating(then.id);\n             }\n \n-            hir::ExprLoop(ref body, _) => {\n+            hir::ExprLoop(ref body, _, _) => {\n                 terminating(body.id);\n             }\n "}, {"sha": "41da5562e23fa4f488bda5112ba63367fa810284", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -462,7 +462,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Expr) {\n     fn expression_label(ex: &hir::Expr) -> Option<(ast::Name, Span)> {\n         match ex.node {\n             hir::ExprWhile(.., Some(label)) |\n-            hir::ExprLoop(_, Some(label)) => Some((label.node, label.span)),\n+            hir::ExprLoop(_, Some(label), _) => Some((label.node, label.span)),\n             _ => None,\n         }\n     }"}, {"sha": "e01856b2a476265b161671e78b5760d249e545ae", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -19,10 +19,6 @@ use std::iter::repeat;\n use std::path::Path;\n use std::time::{Duration, Instant};\n \n-use hir;\n-use hir::intravisit;\n-use hir::intravisit::Visitor;\n-\n // The name of the associated type for `Fn` return types\n pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n@@ -186,57 +182,6 @@ pub fn indenter() -> Indenter {\n     Indenter { _cannot_construct_outside_of_this_module: () }\n }\n \n-struct LoopQueryVisitor<P> where P: FnMut(&hir::Expr_) -> bool {\n-    p: P,\n-    flag: bool,\n-}\n-\n-impl<'v, P> Visitor<'v> for LoopQueryVisitor<P> where P: FnMut(&hir::Expr_) -> bool {\n-    fn visit_expr(&mut self, e: &hir::Expr) {\n-        self.flag |= (self.p)(&e.node);\n-        match e.node {\n-          // Skip inner loops, since a break in the inner loop isn't a\n-          // break inside the outer loop\n-          hir::ExprLoop(..) | hir::ExprWhile(..) => {}\n-          _ => intravisit::walk_expr(self, e)\n-        }\n-    }\n-}\n-\n-// Takes a predicate p, returns true iff p is true for any subexpressions\n-// of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query<P>(b: &hir::Block, p: P) -> bool where P: FnMut(&hir::Expr_) -> bool {\n-    let mut v = LoopQueryVisitor {\n-        p: p,\n-        flag: false,\n-    };\n-    intravisit::walk_block(&mut v, b);\n-    return v.flag;\n-}\n-\n-struct BlockQueryVisitor<P> where P: FnMut(&hir::Expr) -> bool {\n-    p: P,\n-    flag: bool,\n-}\n-\n-impl<'v, P> Visitor<'v> for BlockQueryVisitor<P> where P: FnMut(&hir::Expr) -> bool {\n-    fn visit_expr(&mut self, e: &hir::Expr) {\n-        self.flag |= (self.p)(e);\n-        intravisit::walk_expr(self, e)\n-    }\n-}\n-\n-// Takes a predicate p, returns true iff p is true for any subexpressions\n-// of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query<P>(b: &hir::Block, p: P) -> bool where P: FnMut(&hir::Expr) -> bool {\n-    let mut v = BlockQueryVisitor {\n-        p: p,\n-        flag: false,\n-    };\n-    intravisit::walk_block(&mut v, &b);\n-    return v.flag;\n-}\n-\n pub trait MemoizationMap {\n     type Key: Clone;\n     type Value: Clone;"}, {"sha": "756b0457b788c5529148a09571ba5921d84c9e0e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -855,7 +855,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     time(time_passes,\n          \"loop checking\",\n-         || loops::check_crate(sess, &hir_map));\n+         || loops::check_crate(sess, &resolutions.def_map, &hir_map));\n \n     time(time_passes,\n               \"static item recursion checking\","}, {"sha": "fd0856393fc1b3b9c8b39bbe0d9a5e5cd73f3568", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -322,7 +322,7 @@ fn saw_expr<'a>(node: &'a Expr_,\n         ExprType(..)             => (SawExprType, false),\n         ExprIf(..)               => (SawExprIf, false),\n         ExprWhile(..)            => (SawExprWhile, false),\n-        ExprLoop(_, id)          => (SawExprLoop(id.map(|id| id.node.as_str())), false),\n+        ExprLoop(_, id, _)       => (SawExprLoop(id.map(|id| id.node.as_str())), false),\n         ExprMatch(..)            => (SawExprMatch, false),\n         ExprClosure(cc, _, _, _) => (SawExprClosure(cc), false),\n         ExprBlock(..)            => (SawExprBlock, false),\n@@ -335,7 +335,7 @@ fn saw_expr<'a>(node: &'a Expr_,\n         ExprIndex(..)            => (SawExprIndex, true),\n         ExprPath(ref qself, _)   => (SawExprPath(qself.as_ref().map(|q| q.position)), false),\n         ExprAddrOf(m, _)         => (SawExprAddrOf(m), false),\n-        ExprBreak(id)            => (SawExprBreak(id.map(|id| id.node.as_str())), false),\n+        ExprBreak(id, _)         => (SawExprBreak(id.map(|id| id.node.as_str())), false),\n         ExprAgain(id)            => (SawExprAgain(id.map(|id| id.node.as_str())), false),\n         ExprRet(..)              => (SawExprRet, false),\n         ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(a), false),"}, {"sha": "5a77de08070281763ba800cc6796895a5cd353fb", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -169,41 +169,39 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 this.cfg.terminate(block, source_info,\n                                    TerminatorKind::Goto { target: loop_block });\n \n-                let might_break = this.in_loop_scope(loop_block, exit_block, move |this| {\n-                    // conduct the test, if necessary\n-                    let body_block;\n-                    if let Some(cond_expr) = opt_cond_expr {\n-                        // This loop has a condition, ergo its exit_block is reachable.\n-                        this.find_loop_scope(expr_span, None).might_break = true;\n+                this.in_loop_scope(\n+                    loop_block, exit_block, destination.clone(),\n+                    move |this| {\n+                        // conduct the test, if necessary\n+                        let body_block;\n+                        if let Some(cond_expr) = opt_cond_expr {\n+                            let loop_block_end;\n+                            let cond = unpack!(\n+                                loop_block_end = this.as_operand(loop_block, cond_expr));\n+                            body_block = this.cfg.start_new_block();\n+                            this.cfg.terminate(loop_block_end, source_info,\n+                                               TerminatorKind::If {\n+                                                   cond: cond,\n+                                                   targets: (body_block, exit_block)\n+                                               });\n \n-                        let loop_block_end;\n-                        let cond = unpack!(loop_block_end = this.as_operand(loop_block, cond_expr));\n-                        body_block = this.cfg.start_new_block();\n-                        this.cfg.terminate(loop_block_end, source_info,\n-                                           TerminatorKind::If {\n-                                               cond: cond,\n-                                               targets: (body_block, exit_block)\n-                                           });\n-                    } else {\n-                        body_block = loop_block;\n-                    }\n+                            // if the test is false, there's no `break` to assign `destination`, so\n+                            // we have to do it; this overwrites any `break`-assigned value but it's\n+                            // always `()` anyway\n+                            this.cfg.push_assign_unit(exit_block, source_info, destination);\n+                        } else {\n+                            body_block = loop_block;\n+                        }\n \n-                    // The \u201creturn\u201d value of the loop body must always be an unit, but we cannot\n-                    // reuse that as a \u201creturn\u201d value of the whole loop expressions, because some\n-                    // loops are diverging (e.g. `loop {}`). Thus, we introduce a unit temporary as\n-                    // the destination for the loop body and assign the loop\u2019s own \u201creturn\u201d value\n-                    // immediately after the iteration is finished.\n-                    let tmp = this.get_unit_temp();\n-                    // Execute the body, branching back to the test.\n-                    let body_block_end = unpack!(this.into(&tmp, body_block, body));\n-                    this.cfg.terminate(body_block_end, source_info,\n-                                       TerminatorKind::Goto { target: loop_block });\n-                });\n-                // If the loop may reach its exit_block, we assign an empty tuple to the\n-                // destination to keep the MIR well-formed.\n-                if might_break {\n-                    this.cfg.push_assign_unit(exit_block, source_info, destination);\n-                }\n+                        // The \u201creturn\u201d value of the loop body must always be an unit. We therefore\n+                        // introduce a unit temporary as the destination for the loop body.\n+                        let tmp = this.get_unit_temp();\n+                        // Execute the body, branching back to the test.\n+                        let body_block_end = unpack!(this.into(&tmp, body_block, body));\n+                        this.cfg.terminate(body_block_end, source_info,\n+                                           TerminatorKind::Goto { target: loop_block });\n+                    }\n+                );\n                 exit_block.unit()\n             }\n             ExprKind::Call { ty, fun, args } => {"}, {"sha": "f04d630379a35c99ed6dfdb27b3515190fe9daf1", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -11,9 +11,7 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::scope::LoopScope;\n use hair::*;\n-use rustc::middle::region::CodeExtent;\n use rustc::mir::*;\n-use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n@@ -79,14 +77,28 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.unit()\n             }\n             ExprKind::Continue { label } => {\n-                this.break_or_continue(expr_span, label, block,\n-                                       |loop_scope| loop_scope.continue_block)\n+                let LoopScope { continue_block, extent, .. } =\n+                    *this.find_loop_scope(expr_span, label);\n+                this.exit_scope(expr_span, extent, block, continue_block);\n+                this.cfg.start_new_block().unit()\n             }\n-            ExprKind::Break { label } => {\n-                this.break_or_continue(expr_span, label, block, |loop_scope| {\n-                    loop_scope.might_break = true;\n-                    loop_scope.break_block\n-                })\n+            ExprKind::Break { label, value } => {\n+                let (break_block, extent, destination) = {\n+                    let LoopScope {\n+                        break_block,\n+                        extent,\n+                        ref break_destination,\n+                        ..\n+                    } = *this.find_loop_scope(expr_span, label);\n+                    (break_block, extent, break_destination.clone())\n+                };\n+                if let Some(value) = value {\n+                    unpack!(block = this.into(&destination, block, value))\n+                } else {\n+                    this.cfg.push_assign_unit(block, source_info, &destination)\n+                }\n+                this.exit_scope(expr_span, extent, block, break_block);\n+                this.cfg.start_new_block().unit()\n             }\n             ExprKind::Return { value } => {\n                 block = match value {\n@@ -115,20 +127,4 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn break_or_continue<F>(&mut self,\n-                            span: Span,\n-                            label: Option<CodeExtent>,\n-                            block: BasicBlock,\n-                            exit_selector: F)\n-                            -> BlockAnd<()>\n-        where F: FnOnce(&mut LoopScope) -> BasicBlock\n-    {\n-        let (exit_block, extent) = {\n-            let loop_scope = self.find_loop_scope(span, label);\n-            (exit_selector(loop_scope), loop_scope.extent)\n-        };\n-        self.exit_scope(span, extent, block, exit_block);\n-        self.cfg.start_new_block().unit()\n-    }\n-\n }"}, {"sha": "5713ee45b9d8f4c5927285d84ea993567b1f7053", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -38,7 +38,7 @@ pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     /// the current set of loops; see the `scope` module for more\n     /// details\n-    loop_scopes: Vec<scope::LoopScope>,\n+    loop_scopes: Vec<scope::LoopScope<'tcx>>,\n \n     /// the vector of all scopes that we have created thus far;\n     /// we track this for debuginfo later"}, {"sha": "e5fac94a8a494eb2f344a6fb5ae6964b01cae69a", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -177,16 +177,17 @@ struct FreeData<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub struct LoopScope {\n+pub struct LoopScope<'tcx> {\n     /// Extent of the loop\n     pub extent: CodeExtent,\n     /// Where the body of the loop begins\n     pub continue_block: BasicBlock,\n     /// Block to branch into when the loop terminates (either by being `break`-en out from, or by\n     /// having its condition to become false)\n     pub break_block: BasicBlock,\n-    /// Indicates the reachability of the break_block for this loop\n-    pub might_break: bool\n+    /// The destination of the loop expression itself (i.e. where to put the result of a `break`\n+    /// expression)\n+    pub break_destination: Lvalue<'tcx>,\n }\n \n impl<'tcx> Scope<'tcx> {\n@@ -246,24 +247,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     ///\n     /// Returns the might_break attribute of the LoopScope used.\n     pub fn in_loop_scope<F>(&mut self,\n-                               loop_block: BasicBlock,\n-                               break_block: BasicBlock,\n-                               f: F)\n-                               -> bool\n+                            loop_block: BasicBlock,\n+                            break_block: BasicBlock,\n+                            break_destination: Lvalue<'tcx>,\n+                            f: F)\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>)\n     {\n         let extent = self.extent_of_innermost_scope();\n         let loop_scope = LoopScope {\n             extent: extent.clone(),\n             continue_block: loop_block,\n             break_block: break_block,\n-            might_break: false\n+            break_destination: break_destination,\n         };\n         self.loop_scopes.push(loop_scope);\n         f(self);\n         let loop_scope = self.loop_scopes.pop().unwrap();\n         assert!(loop_scope.extent == extent);\n-        loop_scope.might_break\n     }\n \n     /// Convenience wrapper that pushes a scope and then executes `f`\n@@ -386,7 +386,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn find_loop_scope(&mut self,\n                            span: Span,\n                            label: Option<CodeExtent>)\n-                           -> &mut LoopScope {\n+                           -> &mut LoopScope<'tcx> {\n         let loop_scopes = &mut self.loop_scopes;\n         match label {\n             None => {"}, {"sha": "6fa2672593587b2f0885fa08f4e1cc73e67ff58b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -558,8 +558,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         },\n         hir::ExprRet(ref v) =>\n             ExprKind::Return { value: v.to_ref() },\n-        hir::ExprBreak(label) =>\n-            ExprKind::Break { label: label.map(|_| loop_label(cx, expr)) },\n+        hir::ExprBreak(label, ref value) =>\n+            ExprKind::Break { label: label.map(|_| loop_label(cx, expr)),\n+                              value: value.to_ref() },\n         hir::ExprAgain(label) =>\n             ExprKind::Continue { label: label.map(|_| loop_label(cx, expr)) },\n         hir::ExprMatch(ref discr, ref arms, _) =>\n@@ -572,7 +573,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprWhile(ref cond, ref body, _) =>\n             ExprKind::Loop { condition: Some(cond.to_ref()),\n                              body: block::to_expr_ref(cx, body) },\n-        hir::ExprLoop(ref body, _) =>\n+        hir::ExprLoop(ref body, _, _) =>\n             ExprKind::Loop { condition: None,\n                              body: block::to_expr_ref(cx, body) },\n         hir::ExprField(ref source, name) => {"}, {"sha": "50eee7723964e0cc18b346b9ba12e6420eb518dd", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -202,6 +202,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Break {\n         label: Option<CodeExtent>,\n+        value: Option<ExprRef<'tcx>>,\n     },\n     Continue {\n         label: Option<CodeExtent>,"}, {"sha": "a3916e7eca35104b8bbd246630ec45db25e85c06", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -106,7 +106,7 @@ impl<'a> Visitor for AstValidator<'a> {\n             ExprKind::Loop(_, Some(ident)) |\n             ExprKind::WhileLet(.., Some(ident)) |\n             ExprKind::ForLoop(.., Some(ident)) |\n-            ExprKind::Break(Some(ident)) |\n+            ExprKind::Break(Some(ident), _) |\n             ExprKind::Continue(Some(ident)) => {\n                 self.check_label(ident.node, ident.span, expr.id);\n             }"}, {"sha": "4d8520ed0440a1259fc0124ad9160bf27c2da03b", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -610,7 +610,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         hir::ExprLoop(..) |\n \n         // More control flow (also not very meaningful).\n-        hir::ExprBreak(_) |\n+        hir::ExprBreak(..) |\n         hir::ExprAgain(_) |\n         hir::ExprRet(_) |\n "}, {"sha": "b2ef1abd2a4e78eca2c7f6ad44737a4538bfefff", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -228,4 +228,5 @@ pub impl Foo for Bar {\n register_diagnostics! {\n     E0472, // asm! is unsupported on this target\n     E0561, // patterns aren't allowed in function pointer types\n+    E0571, // `break` with a value in a non-`loop`-loop\n }"}, {"sha": "c909e75afc1f579c5328a528266d3dbd035005e3", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 71, "deletions": 12, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -12,34 +12,56 @@ use self::Context::*;\n use rustc::session::Session;\n \n use rustc::dep_graph::DepNode;\n+use rustc::hir::def::{Def, DefMap};\n use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir;\n use syntax_pos::Span;\n \n+#[derive(Clone, Copy, PartialEq)]\n+enum LoopKind {\n+    Loop(hir::LoopSource),\n+    WhileLoop,\n+}\n+\n+impl LoopKind {\n+    fn name(self) -> &'static str {\n+        match self {\n+            LoopKind::Loop(hir::LoopSource::Loop) => \"loop\",\n+            LoopKind::Loop(hir::LoopSource::WhileLet) => \"while let\",\n+            LoopKind::Loop(hir::LoopSource::ForLoop) => \"for\",\n+            LoopKind::WhileLoop => \"while\",\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq)]\n enum Context {\n     Normal,\n-    Loop,\n+    Loop(LoopKind),\n     Closure,\n }\n \n #[derive(Copy, Clone)]\n-struct CheckLoopVisitor<'a> {\n+struct CheckLoopVisitor<'a, 'ast: 'a> {\n     sess: &'a Session,\n+    def_map: &'a DefMap,\n+    hir_map: &'a Map<'ast>,\n     cx: Context,\n }\n \n-pub fn check_crate(sess: &Session, map: &Map) {\n+pub fn check_crate(sess: &Session, def_map: &DefMap, map: &Map) {\n     let _task = map.dep_graph.in_task(DepNode::CheckLoops);\n     let krate = map.krate();\n     krate.visit_all_item_likes(&mut CheckLoopVisitor {\n         sess: sess,\n+        def_map: def_map,\n+        hir_map: map,\n         cx: Normal,\n     }.as_deep_visitor());\n }\n \n-impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n+impl<'a, 'ast, 'v> Visitor<'v> for CheckLoopVisitor<'a, 'ast> {\n     fn visit_item(&mut self, i: &hir::Item) {\n         self.with_context(Normal, |v| intravisit::walk_item(v, i));\n     }\n@@ -51,25 +73,62 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n     fn visit_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n             hir::ExprWhile(ref e, ref b, _) => {\n-                self.visit_expr(&e);\n-                self.with_context(Loop, |v| v.visit_block(&b));\n+                self.with_context(Loop(LoopKind::WhileLoop), |v| {\n+                    v.visit_expr(&e);\n+                    v.visit_block(&b);\n+                });\n             }\n-            hir::ExprLoop(ref b, _) => {\n-                self.with_context(Loop, |v| v.visit_block(&b));\n+            hir::ExprLoop(ref b, _, source) => {\n+                self.with_context(Loop(LoopKind::Loop(source)), |v| v.visit_block(&b));\n             }\n             hir::ExprClosure(.., ref b, _) => {\n                 self.with_context(Closure, |v| v.visit_expr(&b));\n             }\n-            hir::ExprBreak(_) => self.require_loop(\"break\", e.span),\n+            hir::ExprBreak(ref opt_label, ref opt_expr) => {\n+                if opt_expr.is_some() {\n+                    let loop_kind = if opt_label.is_some() {\n+                        let loop_def = self.def_map.get(&e.id).unwrap().full_def();\n+                        if loop_def == Def::Err {\n+                            None\n+                        } else if let Def::Label(loop_id) = loop_def {\n+                            Some(match self.hir_map.expect_expr(loop_id).node {\n+                                hir::ExprWhile(..) => LoopKind::WhileLoop,\n+                                hir::ExprLoop(_, _, source) => LoopKind::Loop(source),\n+                                ref r => span_bug!(e.span,\n+                                                   \"break label resolved to a non-loop: {:?}\", r),\n+                            })\n+                        } else {\n+                            span_bug!(e.span, \"break resolved to a non-label\")\n+                        }\n+                    } else if let Loop(kind) = self.cx {\n+                        Some(kind)\n+                    } else {\n+                        // `break` outside a loop - caught below\n+                        None\n+                    };\n+                    match loop_kind {\n+                        None | Some(LoopKind::Loop(hir::LoopSource::Loop)) => (),\n+                        Some(kind) => {\n+                            struct_span_err!(self.sess, e.span, E0571,\n+                                             \"`break` with value from a `{}` loop\",\n+                                             kind.name())\n+                                .span_label(e.span,\n+                                            &format!(\"can only break with a value inside `loop`\"))\n+                                .emit();\n+                        }\n+                    }\n+                }\n+                self.require_loop(\"break\", e.span);\n+            }\n             hir::ExprAgain(_) => self.require_loop(\"continue\", e.span),\n             _ => intravisit::walk_expr(self, e),\n         }\n     }\n }\n \n-impl<'a> CheckLoopVisitor<'a> {\n+impl<'a, 'ast> CheckLoopVisitor<'a, 'ast> {\n     fn with_context<F>(&mut self, cx: Context, f: F)\n-        where F: FnOnce(&mut CheckLoopVisitor<'a>)\n+        where F: FnOnce(&mut CheckLoopVisitor<'a, 'ast>)\n     {\n         let old_cx = self.cx;\n         self.cx = cx;\n@@ -79,7 +138,7 @@ impl<'a> CheckLoopVisitor<'a> {\n \n     fn require_loop(&self, name: &str, span: Span) {\n         match self.cx {\n-            Loop => {}\n+            Loop(_) => {}\n             Closure => {\n                 struct_span_err!(self.sess, span, E0267, \"`{}` inside of a closure\", name)\n                 .span_label(span, &format!(\"cannot break inside of a closure\"))"}, {"sha": "ab3d361a940f9ed9dba097742ff07302db613b76", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -3074,22 +3074,25 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprKind::Break(Some(label)) | ExprKind::Continue(Some(label)) => {\n+            ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n                 match self.search_label(label.node) {\n                     None => {\n                         self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,\n                                       label.span,\n-                                      ResolutionError::UndeclaredLabel(&label.node.name.as_str()))\n+                                      ResolutionError::UndeclaredLabel(&label.node.name.as_str()));\n                     }\n                     Some(def @ Def::Label(_)) => {\n                         // Since this def is a label, it is never read.\n-                        self.record_def(expr.id, PathResolution::new(def))\n+                        self.record_def(expr.id, PathResolution::new(def));\n                     }\n                     Some(_) => {\n-                        span_bug!(expr.span, \"label wasn't mapped to a label def!\")\n+                        span_bug!(expr.span, \"label wasn't mapped to a label def!\");\n                     }\n                 }\n+\n+                // visit `break` argument if any\n+                visit::walk_expr(self, expr);\n             }\n \n             ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {"}, {"sha": "eeb7bb287002f7ffb32a93718ff8b2943a667a37", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 148, "deletions": 29, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -103,7 +103,7 @@ use session::{Session, CompileResult};\n use CrateCtxt;\n use TypeAndSubsts;\n use lint;\n-use util::common::{block_query, ErrorReported, indenter, loop_query};\n+use util::common::{ErrorReported, indenter};\n use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n@@ -407,6 +407,34 @@ impl Diverges {\n     }\n }\n \n+#[derive(Clone)]\n+pub struct LoopCtxt<'gcx, 'tcx> {\n+    unified: Ty<'tcx>,\n+    coerce_to: Ty<'tcx>,\n+    break_exprs: Vec<&'gcx hir::Expr>,\n+    may_break: bool,\n+}\n+\n+#[derive(Clone)]\n+pub struct EnclosingLoops<'gcx, 'tcx> {\n+    stack: Vec<LoopCtxt<'gcx, 'tcx>>,\n+    by_id: NodeMap<usize>,\n+}\n+\n+impl<'gcx, 'tcx> EnclosingLoops<'gcx, 'tcx> {\n+    fn find_loop(&mut self, id: Option<ast::NodeId>) -> Option<&mut LoopCtxt<'gcx, 'tcx>> {\n+        if let Some(id) = id {\n+            if let Some(ix) = self.by_id.get(&id).cloned() {\n+                Some(&mut self.stack[ix])\n+            } else {\n+                None\n+            }\n+        } else {\n+            self.stack.last_mut()\n+        }\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n@@ -433,6 +461,8 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// Whether any child nodes have any type errors.\n     has_errors: Cell<bool>,\n \n+    enclosing_loops: RefCell<EnclosingLoops<'gcx, 'tcx>>,\n+\n     inh: &'a Inherited<'a, 'gcx, 'tcx>,\n }\n \n@@ -1503,6 +1533,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                      ast::CRATE_NODE_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n             has_errors: Cell::new(false),\n+            enclosing_loops: RefCell::new(EnclosingLoops {\n+                stack: Vec::new(),\n+                by_id: NodeMap(),\n+            }),\n             inh: inh,\n         }\n     }\n@@ -3584,7 +3618,74 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               }\n               tcx.mk_nil()\n           }\n-          hir::ExprBreak(_) => { tcx.types.never }\n+          hir::ExprBreak(ref label_opt, ref expr_opt) => {\n+            let loop_id = if label_opt.is_some() {\n+                let loop_def = tcx.expect_def(expr.id);\n+                if let Def::Label(loop_id) = loop_def {\n+                    Some(Some(loop_id))\n+                } else if loop_def == Def::Err {\n+                    // an error was already printed, so just ignore it\n+                    None\n+                } else {\n+                    span_bug!(expr.span, \"break label resolved to a non-label\");\n+                }\n+            } else {\n+                Some(None)\n+            };\n+            if let Some(loop_id) = loop_id {\n+                let coerce_to = {\n+                    let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n+                    enclosing_loops.find_loop(loop_id).map(|ctxt| ctxt.coerce_to)\n+                };\n+                if let Some(coerce_to) = coerce_to {\n+                    let e_ty;\n+                    let cause;\n+                    if let Some(ref e) = *expr_opt {\n+                        // Recurse without `enclosing_loops` borrowed.\n+                        e_ty = self.check_expr_with_hint(e, coerce_to);\n+                        cause = self.misc(e.span);\n+                        // Notably, the recursive call may alter coerce_to - must not keep using it!\n+                    } else {\n+                        // `break` without argument acts like `break ()`.\n+                        e_ty = tcx.mk_nil();\n+                        cause = self.misc(expr.span);\n+                    }\n+                    let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n+                    let ctxt = enclosing_loops.find_loop(loop_id).unwrap();\n+\n+                    let result = if let Some(ref e) = *expr_opt {\n+                        // Special-case the first element, as it has no \"previous expressions\".\n+                        let result = if !ctxt.may_break {\n+                            self.try_coerce(e, e_ty, ctxt.coerce_to)\n+                        } else {\n+                            self.try_find_coercion_lub(&cause, || ctxt.break_exprs.iter().cloned(),\n+                                                       ctxt.unified, e, e_ty)\n+                        };\n+\n+                        ctxt.break_exprs.push(e);\n+                        result\n+                    } else {\n+                        self.eq_types(true, &cause, e_ty, ctxt.unified)\n+                            .map(|InferOk { obligations, .. }| {\n+                                // FIXME(#32730) propagate obligations\n+                                assert!(obligations.is_empty());\n+                                e_ty\n+                            })\n+                    };\n+                    match result {\n+                        Ok(ty) => ctxt.unified = ty,\n+                        Err(err) => {\n+                            self.report_mismatched_types(&cause, ctxt.unified, e_ty, err);\n+                        }\n+                    }\n+\n+                    ctxt.may_break = true;\n+                }\n+                // Otherwise, we failed to find the enclosing loop; this can only happen if the\n+                // `break` was not inside a loop at all, which is caught by the loop-checking pass.\n+            }\n+            tcx.types.never\n+          }\n           hir::ExprAgain(_) => { tcx.types.never }\n           hir::ExprRet(ref expr_opt) => {\n             if let Some(ref e) = *expr_opt {\n@@ -3635,27 +3736,48 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  expr.span, expected)\n           }\n           hir::ExprWhile(ref cond, ref body, _) => {\n-            self.check_expr_has_type(&cond, tcx.types.bool);\n-            let cond_diverging = self.diverges.get();\n-            self.check_block_no_value(&body);\n+            let unified = self.tcx.mk_nil();\n+            let coerce_to = unified;\n+            let ctxt = LoopCtxt {\n+                unified: unified,\n+                coerce_to: coerce_to,\n+                break_exprs: vec![],\n+                may_break: true,\n+            };\n+            self.with_loop_ctxt(expr.id, ctxt, || {\n+                self.check_expr_has_type(&cond, tcx.types.bool);\n+                let cond_diverging = self.diverges.get();\n+                self.check_block_no_value(&body);\n \n-            // We may never reach the body so it diverging means nothing.\n-            self.diverges.set(cond_diverging);\n+                // We may never reach the body so it diverging means nothing.\n+                self.diverges.set(cond_diverging);\n+            });\n \n             if self.has_errors.get() {\n                 tcx.types.err\n             } else {\n                 tcx.mk_nil()\n             }\n           }\n-          hir::ExprLoop(ref body, _) => {\n-            self.check_block_no_value(&body);\n-            if may_break(tcx, expr.id, &body) {\n+          hir::ExprLoop(ref body, _, _) => {\n+            let unified = self.next_ty_var();\n+            let coerce_to = expected.only_has_type(self).unwrap_or(unified);\n+            let ctxt = LoopCtxt {\n+                unified: unified,\n+                coerce_to: coerce_to,\n+                break_exprs: vec![],\n+                may_break: false,\n+            };\n+\n+            let ctxt = self.with_loop_ctxt(expr.id, ctxt, || {\n+                self.check_block_no_value(&body);\n+            });\n+            if ctxt.may_break {\n                 // No way to know whether it's diverging because\n                 // of a `break` or an outer `break` or `return.\n                 self.diverges.set(Diverges::Maybe);\n \n-                tcx.mk_nil()\n+                ctxt.unified\n             } else {\n                 tcx.types.never\n             }\n@@ -4531,27 +4653,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.tcx.types.err\n         })\n     }\n-}\n \n-// Returns true if b contains a break that can exit from b\n-pub fn may_break(tcx: TyCtxt, id: ast::NodeId, b: &hir::Block) -> bool {\n-    // First: is there an unlabeled break immediately\n-    // inside the loop?\n-    (loop_query(&b, |e| {\n-        match *e {\n-            hir::ExprBreak(None) => true,\n-            _ => false\n+    fn with_loop_ctxt<F: FnOnce()>(&self, id: ast::NodeId, ctxt: LoopCtxt<'gcx, 'tcx>, f: F)\n+                                   -> LoopCtxt<'gcx, 'tcx> {\n+        let index;\n+        {\n+            let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n+            index = enclosing_loops.stack.len();\n+            enclosing_loops.by_id.insert(id, index);\n+            enclosing_loops.stack.push(ctxt);\n         }\n-    })) ||\n-    // Second: is there a labeled break with label\n-    // <id> nested anywhere inside the loop?\n-    (block_query(b, |e| {\n-        if let hir::ExprBreak(Some(_)) = e.node {\n-            tcx.expect_def(e.id) == Def::Label(id)\n-        } else {\n-            false\n+        f();\n+        {\n+            let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n+            debug_assert!(enclosing_loops.stack.len() == index + 1);\n+            enclosing_loops.by_id.remove(&id).expect(\"missing loop context\");\n+            (enclosing_loops.stack.pop().expect(\"missing loop context\"))\n         }\n-    }))\n+    }\n }\n \n pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,"}, {"sha": "c613b62bf2d82b4a3589f01d6f909986588d58b8", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -742,7 +742,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 self.check_expr_fn_block(expr, &body);\n             }\n \n-            hir::ExprLoop(ref body, _) => {\n+            hir::ExprLoop(ref body, _, _) => {\n                 let repeating_scope = self.set_repeating_scope(body.id);\n                 intravisit::walk_expr(self, expr);\n                 self.set_repeating_scope(repeating_scope);"}, {"sha": "2a911aceb9d94e01a8be3187953b019271d6103d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -999,8 +999,8 @@ pub enum ExprKind {\n \n     /// A referencing operation (`&a` or `&mut a`)\n     AddrOf(Mutability, P<Expr>),\n-    /// A `break`, with an optional label to break\n-    Break(Option<SpannedIdent>),\n+    /// A `break`, with an optional label to break, and an optional expression\n+    Break(Option<SpannedIdent>, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n     Continue(Option<SpannedIdent>),\n     /// A `return`, with an optional value to be returned"}, {"sha": "a208b934d79e1da09b7ca1b31ba069b7aca824dd", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -777,7 +777,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n \n     fn expr_break(&self, sp: Span) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::Break(None))\n+        self.expr(sp, ast::ExprKind::Break(None, None))\n     }\n \n "}, {"sha": "aa6a29b78b075d2263a5eb2ed194161f371db08e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -313,6 +313,9 @@ declare_features! (\n     (active, link_cfg, \"1.14.0\", Some(37406)),\n \n     (active, use_extern_macros, \"1.15.0\", Some(35896)),\n+\n+    // Allows `break {expr}` with a value inside `loop`s.\n+    (active, loop_break_value, \"1.14.0\", Some(37339)),\n );\n \n declare_features! (\n@@ -1189,6 +1192,10 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n                     }\n                 }\n             }\n+            ast::ExprKind::Break(_, Some(_)) => {\n+                gate_feature_post!(&self, loop_break_value, e.span,\n+                                   \"`break` with a value is experimental\");\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "6af8efb2a195c6c3408a568b2fa0b8a8f7c04568", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -1238,10 +1238,11 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 });\n                 ExprKind::Path(qself, folder.fold_path(path))\n             }\n-            ExprKind::Break(opt_ident) => ExprKind::Break(opt_ident.map(|label|\n-                respan(folder.new_span(label.span),\n-                       folder.fold_ident(label.node)))\n-            ),\n+            ExprKind::Break(opt_ident, opt_expr) => {\n+                ExprKind::Break(opt_ident.map(|label| respan(folder.new_span(label.span),\n+                                                             folder.fold_ident(label.node))),\n+                                opt_expr.map(|e| folder.fold_expr(e)))\n+            }\n             ExprKind::Continue(opt_ident) => ExprKind::Continue(opt_ident.map(|label|\n                 respan(folder.new_span(label.span),\n                        folder.fold_ident(label.node)))"}, {"sha": "49226be4147d7c4b9b01a062f4b44c4997fcc45f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -2256,15 +2256,25 @@ impl<'a> Parser<'a> {\n                         ex = ExprKind::Ret(None);\n                     }\n                 } else if self.eat_keyword(keywords::Break) {\n-                    if self.token.is_lifetime() {\n-                        ex = ExprKind::Break(Some(Spanned {\n+                    let lt = if self.token.is_lifetime() {\n+                        let spanned_lt = Spanned {\n                             node: self.get_lifetime(),\n                             span: self.span\n-                        }));\n+                        };\n                         self.bump();\n+                        Some(spanned_lt)\n                     } else {\n-                        ex = ExprKind::Break(None);\n-                    }\n+                        None\n+                    };\n+                    let e = if self.token.can_begin_expr()\n+                               && !(self.token == token::OpenDelim(token::Brace)\n+                                    && self.restrictions.contains(\n+                                           Restrictions::RESTRICTION_NO_STRUCT_LITERAL)) {\n+                        Some(self.parse_expr()?)\n+                    } else {\n+                        None\n+                    };\n+                    ex = ExprKind::Break(lt, e);\n                     hi = self.prev_span.hi;\n                 } else if self.token.is_keyword(keywords::Let) {\n                     // Catch this syntax error here, instead of in `check_strict_keywords`, so"}, {"sha": "c28b9d00501b70fd6a989f27af86ad170873d3df", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -2191,13 +2191,17 @@ impl<'a> State<'a> {\n             ast::ExprKind::Path(Some(ref qself), ref path) => {\n                 try!(self.print_qpath(path, qself, true))\n             }\n-            ast::ExprKind::Break(opt_ident) => {\n+            ast::ExprKind::Break(opt_ident, ref opt_expr) => {\n                 try!(word(&mut self.s, \"break\"));\n                 try!(space(&mut self.s));\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident.node));\n                     try!(space(&mut self.s));\n                 }\n+                if let Some(ref expr) = *opt_expr {\n+                    try!(self.print_expr(expr));\n+                    try!(space(&mut self.s));\n+                }\n             }\n             ast::ExprKind::Continue(opt_ident) => {\n                 try!(word(&mut self.s, \"continue\"));"}, {"sha": "da36225fb329cdd17d51846e2b953a07abb82f6a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -746,7 +746,11 @@ pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n             }\n             visitor.visit_path(path, expression.id)\n         }\n-        ExprKind::Break(ref opt_sp_ident) | ExprKind::Continue(ref opt_sp_ident) => {\n+        ExprKind::Break(ref opt_sp_ident, ref opt_expr) => {\n+            walk_opt_sp_ident(visitor, opt_sp_ident);\n+            walk_list!(visitor, visit_expr, opt_expr);\n+        }\n+        ExprKind::Continue(ref opt_sp_ident) => {\n             walk_opt_sp_ident(visitor, opt_sp_ident);\n         }\n         ExprKind::Ret(ref optional_expression) => {"}, {"sha": "1632c40d59fdf0fbc67c599d045ff1ee5d40d7ab", "filename": "src/test/compile-fail/feature-gate-loop-break-value.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Ftest%2Fcompile-fail%2Ffeature-gate-loop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Ftest%2Fcompile-fail%2Ffeature-gate-loop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-loop-break-value.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    loop {\n+        break 123; //~ ERROR `break` with a value is experimental\n+    }\n+}"}, {"sha": "d4f29597486983038dee9b9f870e1be8fbb53df5", "filename": "src/test/compile-fail/loop-break-value.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Ftest%2Fcompile-fail%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Ftest%2Fcompile-fail%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Floop-break-value.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -0,0 +1,101 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(loop_break_value)]\n+#![feature(never_type)]\n+\n+fn main() {\n+    let val: ! = loop { break break; };\n+    //~^ ERROR mismatched types\n+\n+    loop {\n+        if true {\n+            break \"asdf\";\n+        } else {\n+            break 123; //~ ERROR mismatched types\n+        }\n+    };\n+\n+    let _: i32 = loop {\n+        break \"asdf\"; //~ ERROR mismatched types\n+    };\n+\n+    let _: i32 = 'outer_loop: loop {\n+        loop {\n+            break 'outer_loop \"nope\"; //~ ERROR mismatched types\n+            break \"ok\";\n+        };\n+    };\n+\n+    'while_loop: while true {\n+        break;\n+        break (); //~ ERROR `break` with value from a `while` loop\n+        loop {\n+            break 'while_loop 123;\n+            //~^ ERROR `break` with value from a `while` loop\n+            //~| ERROR mismatched types\n+            break 456;\n+            break 789;\n+        };\n+    }\n+\n+    'while_let_loop: while let Some(_) = Some(()) {\n+        if break () { //~ ERROR `break` with value from a `while let` loop\n+            break;\n+            break None;\n+            //~^ ERROR `break` with value from a `while let` loop\n+            //~| ERROR mismatched types\n+        }\n+        loop {\n+            break 'while_let_loop \"nope\";\n+            //~^ ERROR `break` with value from a `while let` loop\n+            //~| ERROR mismatched types\n+            break 33;\n+        };\n+    }\n+\n+    'for_loop: for _ in &[1,2,3] {\n+        break (); //~ ERROR `break` with value from a `for` loop\n+        break [()];\n+        //~^ ERROR `break` with value from a `for` loop\n+        //~| ERROR mismatched types\n+        loop {\n+            break Some(3);\n+            break 'for_loop Some(17);\n+            //~^ ERROR `break` with value from a `for` loop\n+            //~| ERROR mismatched types\n+        };\n+    }\n+\n+    let _: i32 = 'a: loop {\n+        let _: () = 'b: loop {\n+            break ('c: loop {\n+                break;\n+                break 'c 123; //~ ERROR mismatched types\n+            });\n+            break 'a 123;\n+        };\n+    };\n+\n+    loop {\n+        break (break, break); //~ ERROR mismatched types\n+    };\n+\n+    loop {\n+        break;\n+        break 2; //~ ERROR mismatched types\n+    };\n+\n+    loop {\n+        break 2;\n+        break; //~ ERROR mismatched types\n+        break 4;\n+    };\n+}"}, {"sha": "6a5e051c0c7322d72c18a136b0bca887e537b871", "filename": "src/test/run-pass/loop-break-value.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Ftest%2Frun-pass%2Floop-break-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src%2Ftest%2Frun-pass%2Floop-break-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-break-value.rs?ref=1cabe2151299c63497abc3a20bd08c04c0cd32a3", "patch": "@@ -0,0 +1,133 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(loop_break_value)]\n+#![feature(never_type)]\n+\n+#[allow(unused)]\n+fn never_returns() {\n+    loop {\n+        break loop {};\n+    }\n+}\n+\n+pub fn main() {\n+    let value = 'outer: loop {\n+        if 1 == 1 {\n+            break 13;\n+        } else {\n+            let _never: ! = loop {\n+                break loop {\n+                    break 'outer panic!();\n+                }\n+            };\n+        }\n+    };\n+    assert_eq!(value, 13);\n+\n+    let x = [1, 3u32, 5];\n+    let y = [17];\n+    let z = [];\n+    let coerced: &[_] = loop {\n+        match 2 {\n+            1 => break &x,\n+            2 => break &y,\n+            3 => break &z,\n+            _ => (),\n+        }\n+    };\n+    assert_eq!(coerced, &[17u32]);\n+\n+    let trait_unified = loop {\n+        break if true {\n+            break Default::default()\n+        } else {\n+            break [13, 14]\n+        };\n+    };\n+    assert_eq!(trait_unified, [0, 0]);\n+\n+    let trait_unified_2 = loop {\n+        if false {\n+            break [String::from(\"Hello\")]\n+        } else {\n+            break Default::default()\n+        };\n+    };\n+    assert_eq!(trait_unified_2, [\"\"]);\n+\n+    let trait_unified_3 = loop {\n+        break if false {\n+            break [String::from(\"Hello\")]\n+        } else {\n+            [\"Yes\".into()]\n+        };\n+    };\n+    assert_eq!(trait_unified_3, [\"Yes\"]);\n+\n+    let regular_break = loop {\n+        if true {\n+            break;\n+        } else {\n+            break break Default::default();\n+        }\n+    };\n+    assert_eq!(regular_break, ());\n+\n+    let regular_break_2 = loop {\n+        if true {\n+            break Default::default();\n+        } else {\n+            break;\n+        }\n+    };\n+    assert_eq!(regular_break_2, ());\n+\n+    let regular_break_3 = loop {\n+        break if true {\n+            Default::default()\n+        } else {\n+            break;\n+        }\n+    };\n+    assert_eq!(regular_break_3, ());\n+\n+    let regular_break_4 = loop {\n+        break ();\n+        break;\n+    };\n+    assert_eq!(regular_break_4, ());\n+\n+    let regular_break_5 = loop {\n+        break;\n+        break ();\n+    };\n+    assert_eq!(regular_break_5, ());\n+\n+    let nested_break_value = 'outer2: loop {\n+        let _a: u32 = 'inner: loop {\n+            if true {\n+                break 'outer2 \"hello\";\n+            } else {\n+                break 'inner 17;\n+            }\n+        };\n+        panic!();\n+    };\n+    assert_eq!(nested_break_value, \"hello\");\n+\n+    let break_from_while_cond = loop {\n+        while break {\n+            panic!();\n+        }\n+        break 123;\n+    };\n+    assert_eq!(break_from_while_cond, 123);\n+}"}]}