{"sha": "4a3505682e97c8e667338056ae216e4b84b22dd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMzUwNTY4MmU5N2M4ZTY2NzMzODA1NmFlMjE2ZTRiODRiMjJkZDc=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-08-28T04:33:26Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-12-07T05:56:50Z"}, "message": "Add x86_64-fortanix-unknown-sgx target to libstd and dependencies\n\nThe files src/libstd/sys/sgx/*.rs are mostly copied/adapted from\nthe wasm target.\n\nThis also updates the dlmalloc submodule to the very latest version.", "tree": {"sha": "64f04641da2097afb5c6a386f8e26a36a2687e6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64f04641da2097afb5c6a386f8e26a36a2687e6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a3505682e97c8e667338056ae216e4b84b22dd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a3505682e97c8e667338056ae216e4b84b22dd7", "html_url": "https://github.com/rust-lang/rust/commit/4a3505682e97c8e667338056ae216e4b84b22dd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a3505682e97c8e667338056ae216e4b84b22dd7/comments", "author": null, "committer": null, "parents": [{"sha": "c559216ad0d2f0737f8dbb51a7d42b1727b77b3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c559216ad0d2f0737f8dbb51a7d42b1727b77b3c", "html_url": "https://github.com/rust-lang/rust/commit/c559216ad0d2f0737f8dbb51a7d42b1727b77b3c"}], "stats": {"total": 2888, "additions": 2873, "deletions": 15}, "files": [{"sha": "3fc6e45db3e397449b71cd5c134cb2bfac2ff142", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -61,10 +61,12 @@\n \tpath = src/tools/clang\n \turl = https://github.com/rust-lang-nursery/clang.git\n \tbranch = rust-release-80-v2\n-\n [submodule \"src/doc/rustc-guide\"]\n \tpath = src/doc/rustc-guide\n \turl = https://github.com/rust-lang/rustc-guide.git\n [submodule \"src/doc/edition-guide\"]\n \tpath = src/doc/edition-guide\n \turl = https://github.com/rust-lang-nursery/edition-guide\n+[submodule \"src/rust-sgx\"]\n+\tpath = src/rust-sgx\n+\turl = https://github.com/fortanix/rust-sgx"}, {"sha": "316724ca6515884f871a0fa376ddae87412abdd0", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -797,6 +797,14 @@ name = \"foreign-types-shared\"\n version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"fortanix-sgx-abi\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"compiler_builtins 0.0.0\",\n+ \"core 0.0.0\",\n+]\n+\n [[package]]\n name = \"fs2\"\n version = \"0.4.3\"\n@@ -2773,6 +2781,7 @@ dependencies = [\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n  \"dlmalloc 0.0.0\",\n+ \"fortanix-sgx-abi 0.0.0\",\n  \"libc 0.0.0\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\","}, {"sha": "6108692e43c667ddaac1443e20c0a7c9f4458561", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -874,6 +874,7 @@ impl Step for Src {\n             \"src/rustc/compiler_builtins_shim\",\n             \"src/rustc/libc_shim\",\n             \"src/rustc/dlmalloc_shim\",\n+            \"src/rustc/fortanix-sgx-abi_shim\",\n             \"src/libtest\",\n             \"src/libterm\",\n             \"src/libprofiler_builtins\","}, {"sha": "de99f4b0c886f5916cd1a146464276d65bef61b8", "filename": "src/dlmalloc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdlmalloc?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -1 +1 @@\n-Subproject commit c99638dc2ecfc750cc1656f6edb2bd062c1e0981\n+Subproject commit de99f4b0c886f5916cd1a146464276d65bef61b8"}, {"sha": "5b403753da9ec8ff501adf34cb6d63b319b4a3ae", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -1 +1 @@\n-Subproject commit c75ca6465a139704e00295be355b1f067af2f535\n+Subproject commit 5b403753da9ec8ff501adf34cb6d63b319b4a3ae"}, {"sha": "95c3514185e2f87cce797e4f5a70e47643e12a8a", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -66,6 +66,12 @@ pub unsafe extern fn __rust_start_panic(_payload: usize) -> u32 {\n     unsafe fn abort() -> ! {\n         core::intrinsics::abort();\n     }\n+\n+    #[cfg(target_env=\"sgx\")]\n+    unsafe fn abort() -> ! {\n+        extern \"C\" { pub fn panic_exit() -> !; }\n+        panic_exit();\n+    }\n }\n \n // This... is a bit of an oddity. The tl;dr; is that this is required to link"}, {"sha": "49f8a429126b70e5a31ed128d216ad366572e79f", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -62,7 +62,7 @@ cfg_if! {\n     if #[cfg(target_os = \"emscripten\")] {\n         #[path = \"emcc.rs\"]\n         mod imp;\n-    } else if #[cfg(target_arch = \"wasm32\")] {\n+    } else if #[cfg(any(target_arch = \"wasm32\", target_env = \"sgx\"))] {\n         #[path = \"dummy.rs\"]\n         mod imp;\n     } else if #[cfg(all(target_env = \"msvc\", target_arch = \"aarch64\"))] {"}, {"sha": "274d5bec6622fbdcf78ae08fa43eb62b32ba4693", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -35,9 +35,12 @@ rustc_lsan = { path = \"../librustc_lsan\" }\n rustc_msan = { path = \"../librustc_msan\" }\n rustc_tsan = { path = \"../librustc_tsan\" }\n \n-[target.'cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))'.dependencies]\n+[target.'cfg(any(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")), target_env = \"sgx\"))'.dependencies]\n dlmalloc = { path = '../rustc/dlmalloc_shim' }\n \n+[target.x86_64-fortanix-unknown-sgx.dependencies]\n+fortanix-sgx-abi = { path = \"../rustc/fortanix-sgx-abi_shim\" }\n+\n [build-dependencies]\n cc = \"1.0\"\n build_helper = { path = \"../build_helper\" }"}, {"sha": "32e29962760bf7d4b9f4344f180acd25b07014e2", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -184,7 +184,7 @@ pub enum ErrorKind {\n }\n \n impl ErrorKind {\n-    fn as_str(&self) -> &'static str {\n+    pub(crate) fn as_str(&self) -> &'static str {\n         match *self {\n             ErrorKind::NotFound => \"entity not found\",\n             ErrorKind::PermissionDenied => \"permission denied\","}, {"sha": "bf1e64efd37c4f3c13b4636e141e6192a629683b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -312,6 +312,7 @@\n #![feature(non_exhaustive)]\n #![feature(alloc_layout_extra)]\n #![feature(maybe_uninit)]\n+#![cfg_attr(target_env = \"sgx\", feature(global_asm, range_contains))]\n \n #![default_lib_allocator]\n \n@@ -354,6 +355,12 @@ extern crate unwind;\n // testing gives test-std access to real-std lang items and globals. See #2912\n #[cfg(test)] extern crate std as realstd;\n \n+#[cfg(target_env = \"sgx\")]\n+#[macro_use]\n+#[allow(unused_imports)] // FIXME: without `#[macro_use]`, get error: \u201ccannot\n+                         // determine resolution for the macro `usercalls_asm`\u201d\n+extern crate fortanix_sgx_abi;\n+\n // The standard macros that are not built-in to the compiler.\n #[macro_use]\n mod macros;"}, {"sha": "04c47aeb8276b80e0e10e67a95e58f5e0cc47368", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -48,6 +48,9 @@ cfg_if! {\n     } else if #[cfg(target_arch = \"wasm32\")] {\n         mod wasm;\n         pub use self::wasm::*;\n+    } else if #[cfg(target_env = \"sgx\")] {\n+        mod sgx;\n+        pub use self::sgx::*;\n     } else {\n         compile_error!(\"libstd doesn't compile for this platform yet\");\n     }"}, {"sha": "4d5cc02e11e2ccdb93e0ee91961ee5d3312e2719", "filename": "src/libstd/sys/sgx/abi/entry.S", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,327 @@\n+/* Copyright 2018 The Rust Project Developers. See the COPYRIGHT     */\n+/* file at the top-level directory of this distribution and at       */\n+/* http://rust-lang.org/COPYRIGHT.                                   */\n+/*                                                                   */\n+/* Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or */\n+/* http://www.apache.org/licenses/LICENSE-2.0> or the MIT license    */\n+/* <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your      */\n+/* option. This file may not be copied, modified, or distributed     */\n+/* except according to those terms.                                  */\n+\n+/*  This symbol is used at runtime to figure out the virtual address that the */\n+/*  enclave is loaded at. */\n+.section absolute\n+.global IMAGE_BASE\n+IMAGE_BASE:\n+\n+.section .rodata\n+/*  The XSAVE area needs to be a large chunk of readable memory, but since we are */\n+/*  going to restore everything to its initial state (XSTATE_BV=0), only certain */\n+/*  parts need to have a defined value. In particular: */\n+/*  */\n+/*    * MXCSR in the legacy area. This register is always restored if RFBM[1] or */\n+/*      RFBM[2] is set, regardless of the value of XSTATE_BV */\n+/*    * XSAVE header */\n+.align 64\n+.Lxsave_clear:\n+.org .+24\n+.Lxsave_mxcsr:\n+    .int 0\n+\n+/*  We can store a bunch of data in the gap between MXCSR and the XSAVE header */\n+\n+/*  The following symbols point at read-only data that will be filled in by the */\n+/*  post-linker. */\n+\n+/*  When using this macro, don't forget to adjust the linker version script! */\n+.macro globvar name:req size:req\n+    .global \\name\n+    .protected \\name\n+    .align \\size\n+    .size \\name , \\size\n+    \\name :\n+        .org .+\\size\n+.endm\n+    /*  The base address (relative to enclave start) of the heap area */\n+    globvar HEAP_BASE 8\n+    /*  The heap size in bytes */\n+    globvar HEAP_SIZE 8\n+    /*  Value of the RELA entry in the dynamic table */\n+    globvar RELA 8\n+    /*  Value of the RELACOUNT entry in the dynamic table */\n+    globvar RELACOUNT 8\n+    /*  The enclave size in bytes */\n+    globvar ENCLAVE_SIZE 8\n+    /*  The base address (relative to enclave start) of the enclave configuration area */\n+    globvar CFGDATA_BASE 8\n+    /*  Non-zero if debugging is enabled, zero otherwise */\n+    globvar DEBUG 1\n+\n+.Lreentry_panic_msg:\n+    .asciz \"Re-entered panicked enclave!\"\n+.Lreentry_panic_msg_end:\n+\n+.Lusercall_panic_msg:\n+    .asciz \"Invalid usercall#!\"\n+.Lusercall_panic_msg_end:\n+\n+.org .Lxsave_clear+512\n+.Lxsave_header:\n+    .int 0, 0 /*  XSTATE_BV */\n+    .int 0, 0 /*  XCOMP_BV */\n+    .org .+48 /*  reserved bits */\n+\n+.data\n+.Lpanicked:\n+    .byte 0\n+\n+/*  TCS local storage section */\n+.equ tcsls_tos,                 0x00 /*  initialized by loader to *offset* from image base to TOS */\n+.equ tcsls_flags,               0x08 /*  initialized by loader */\n+.equ tcsls_flag_secondary,      0    /*  initialized by loader; 0 = standard TCS, 1 = secondary TCS */\n+.equ tcsls_flag_init_once,      1    /*  initialized by loader to 0 */\n+/*  14 unused bits */\n+.equ tcsls_user_fcw,            0x0a\n+.equ tcsls_user_mxcsr,          0x0c\n+.equ tcsls_last_rsp,            0x10 /*  initialized by loader to 0 */\n+.equ tcsls_panic_last_rsp,      0x18 /*  initialized by loader to 0 */\n+.equ tcsls_debug_panic_buf_ptr, 0x20 /*  initialized by loader to 0 */\n+.equ tcsls_user_rsp,            0x28\n+.equ tcsls_user_retip,          0x30\n+.equ tcsls_user_rbp,            0x38\n+.equ tcsls_user_r12,            0x40\n+.equ tcsls_user_r13,            0x48\n+.equ tcsls_user_r14,            0x50\n+.equ tcsls_user_r15,            0x58\n+.equ tcsls_tls_ptr,             0x60\n+.equ tcsls_tcs_addr,            0x68\n+\n+.macro load_tcsls_flag_secondary_bool reg:req comments:vararg\n+    .ifne tcsls_flag_secondary /* to convert to a bool, must be the first bit */\n+    .abort\n+    .endif\n+        mov $(1<<tcsls_flag_secondary),%e\\reg\n+        and %gs:tcsls_flags,%\\reg\n+.endm\n+\n+.text\n+.global sgx_entry\n+.type sgx_entry,function\n+sgx_entry:\n+/*  save user registers */\n+    mov %rcx,%gs:tcsls_user_retip\n+    mov %rsp,%gs:tcsls_user_rsp\n+    mov %rbp,%gs:tcsls_user_rbp\n+    mov %r12,%gs:tcsls_user_r12\n+    mov %r13,%gs:tcsls_user_r13\n+    mov %r14,%gs:tcsls_user_r14\n+    mov %r15,%gs:tcsls_user_r15\n+    mov %rbx,%gs:tcsls_tcs_addr\n+    stmxcsr %gs:tcsls_user_mxcsr\n+    fnstcw %gs:tcsls_user_fcw\n+/*  reset user state */\n+    cld /* x86-64 ABI requires DF to be unset at function entry/exit */\n+/*  check for debug buffer pointer */\n+    testb  $0xff,DEBUG(%rip)\n+    jz .Lskip_debug_init\n+    mov %r10,%gs:tcsls_debug_panic_buf_ptr\n+.Lskip_debug_init:\n+/*  check if returning from usercall */\n+    mov %gs:tcsls_last_rsp,%r11\n+    test %r11,%r11\n+    jnz .Lusercall_ret\n+/*  setup stack */\n+    mov %gs:tcsls_tos,%rsp /*  initially, RSP is not set to the correct value */\n+                           /*  here. This is fixed below under \"adjust stack\". */\n+/*  check for thread init */\n+    bts $tcsls_flag_init_once,%gs:tcsls_flags\n+    jc .Lskip_init\n+/*  adjust stack */\n+    lea IMAGE_BASE(%rip),%rax\n+    add %rax,%rsp\n+    mov %rsp,%gs:tcsls_tos\n+/*  call tcs_init */\n+/*  store caller-saved registers in callee-saved registers */\n+    mov %rdi,%rbx\n+    mov %rsi,%r12\n+    mov %rdx,%r13\n+    mov %r8,%r14\n+    mov %r9,%r15\n+    load_tcsls_flag_secondary_bool di /* RDI = tcs_init() argument: secondary: bool */\n+    call tcs_init\n+/*  reload caller-saved registers */\n+    mov %rbx,%rdi\n+    mov %r12,%rsi\n+    mov %r13,%rdx\n+    mov %r14,%r8\n+    mov %r15,%r9\n+.Lskip_init:\n+/*  check for panic */\n+    bt $0,.Lpanicked(%rip)\n+    jc .Lreentry_panic\n+/*  call into main entry point */\n+    load_tcsls_flag_secondary_bool cx /* RCX = entry() argument: secondary: bool */\n+    call entry /* RDI, RSI, RDX, R8, R9 passed in from userspace */\n+    mov %rax,%rsi  /* RSI = return value */\n+    /* NOP: mov %rdx,%rdx */ /*  RDX = return value */\n+    xor %rdi,%rdi  /* RDI = normal exit */\n+.Lexit:\n+/*  clear general purpose register state */\n+    /*  RAX overwritten by ENCLU */\n+    /*  RBX set later */\n+    /*  RCX overwritten by ENCLU */\n+    /*  RDX contains return value */\n+    /*  RSP set later */\n+    /*  RBP set later */\n+    /*  RDI contains exit mode */\n+    /*  RSI contains return value */\n+    xor %r8,%r8\n+    xor %r9,%r9\n+    xor %r10,%r10\n+    xor %r11,%r11\n+    /*  R12 ~ R15 set by sgx_exit */\n+.Lsgx_exit:\n+/*  clear extended register state */\n+    mov %rdx, %rcx /*  save RDX */\n+    mov $-1, %rax\n+    mov %rax, %rdx\n+    xrstor .Lxsave_clear(%rip)\n+    mov %rcx, %rdx /*  restore RDX */\n+/*  clear flags */\n+    pushq $0\n+    popfq\n+/*  restore user registers */\n+    mov %gs:tcsls_user_r12,%r12\n+    mov %gs:tcsls_user_r13,%r13\n+    mov %gs:tcsls_user_r14,%r14\n+    mov %gs:tcsls_user_r15,%r15\n+    mov %gs:tcsls_user_retip,%rbx\n+    mov %gs:tcsls_user_rsp,%rsp\n+    mov %gs:tcsls_user_rbp,%rbp\n+    fldcw %gs:tcsls_user_fcw\n+    ldmxcsr %gs:tcsls_user_mxcsr\n+/*  exit enclave */\n+    mov $0x4,%eax /*  EEXIT */\n+    enclu\n+/*  end sgx_entry */\n+\n+.Lreentry_panic:\n+    lea .Lreentry_panic_msg(%rip),%rdi\n+    mov $.Lreentry_panic_msg_end-.Lreentry_panic_msg,%esi\n+    orq $8,%rsp\n+    jmp panic_msg\n+\n+.Lusercall_panic:\n+    lea .Lusercall_panic_msg(%rip),%rdi\n+    mov $.Lusercall_panic_msg_end-.Lusercall_panic_msg,%esi\n+    orq $8,%rsp\n+    jmp panic_msg\n+\n+.macro push_callee_saved_registers\n+    push %r15\n+    push %r14\n+    push %r13\n+    push %r12\n+    push %rbp\n+    push %rbx\n+    sub $8, %rsp\n+    fstcw 4(%rsp)\n+    stmxcsr (%rsp)\n+.endm\n+\n+.global panic_exit\n+panic_exit:\n+/* save registers in DEBUG mode, so that debugger can reconstruct the stack */\n+    testb $0xff,DEBUG(%rip)\n+    jz .Lskip_save_registers\n+    push_callee_saved_registers\n+    movq %rsp,%gs:tcsls_panic_last_rsp\n+.Lskip_save_registers:\n+/* set panicked bit */\n+    movb $1,.Lpanicked(%rip)\n+/* call usercall exit(true) */\n+    mov $1,%esi   /*  RSI = usercall() argument: panic = true */\n+    xor %rdx,%rdx /*  RDX cleared */\n+    movq $usercall_nr_exit,%rdi /*  RDI = usercall exit */\n+    jmp .Lexit\n+\n+/*  This *MUST* be called with 6 parameters, otherwise register information */\n+/*  might leak! */\n+.global usercall\n+usercall:\n+    test %rdi,%rdi\n+    jle .Lusercall_panic\n+/*  save callee-saved state */\n+    push_callee_saved_registers\n+    movq %rsp,%gs:tcsls_last_rsp\n+/*  clear general purpose register state */\n+    /*  RAX overwritten by ENCLU */\n+    /*  RBX set by sgx_exit */\n+    /*  RCX overwritten by ENCLU */\n+    /*  RDX contains parameter */\n+    /*  RSP set by sgx_exit */\n+    /*  RBP set by sgx_exit */\n+    /*  RDI contains parameter */\n+    /*  RSI contains parameter */\n+    /*  R8 contains parameter */\n+    /*  R9 contains parameter */\n+    xor %r10,%r10\n+    xor %r11,%r11\n+    /*  R12 ~ R15 set by sgx_exit */\n+/*  extended registers/flags cleared by sgx_exit */\n+/*  exit */\n+    jmp .Lsgx_exit\n+.Lusercall_ret:\n+    movq $0,%gs:tcsls_last_rsp\n+/*  restore callee-saved state, cf. push_callee_saved_registers */\n+    mov %r11,%rsp\n+    ldmxcsr (%rsp)\n+    fldcw 4(%rsp)\n+    add $8, %rsp\n+    pop %rbx\n+    pop %rbp\n+    pop %r12\n+    pop %r13\n+    pop %r14\n+    pop %r15\n+/*  return */\n+    mov %rsi,%rax /*  RAX = return value */\n+    /* NOP: mov %rdx,%rdx */ /*  RDX = return value */\n+    ret\n+\n+/*\n+The following functions need to be defined externally:\n+```\n+// Called by entry code when it needs to panic\n+extern \"C\" fn panic_msg(msg: &'static str) -> ! {\n+    panic!(msg)\n+}\n+\n+// Called once when a TCS is first entered\n+extern \"C\" fn tcs_init(secondary: bool);\n+\n+// Standard TCS entrypoint\n+extern \"C\" fn entry(p1: u64, p2: u64, p3: u64, secondary: bool, p4: u64, p5: u64) -> (u64, u64);\n+```\n+*/\n+\n+.global get_tcs_addr\n+get_tcs_addr:\n+    mov %gs:tcsls_tcs_addr,%rax\n+    ret\n+\n+.global get_tls_ptr\n+get_tls_ptr:\n+    mov %gs:tcsls_tls_ptr,%rax\n+    ret\n+\n+.global set_tls_ptr\n+set_tls_ptr:\n+    mov %rdi,%gs:tcsls_tls_ptr\n+    ret\n+\n+.global take_debug_panic_buf_ptr\n+take_debug_panic_buf_ptr:\n+    xor %rax,%rax\n+    xchg %gs:tcsls_debug_panic_buf_ptr,%rax\n+    ret"}, {"sha": "aedf6ec7acb08f4b7d0a0ce6b2a969fa01586f35", "filename": "src/libstd/sys/sgx/abi/mem.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Do not remove inline: will result in relocation failure\n+#[inline(always)]\n+pub unsafe fn rel_ptr<T>(offset: u64) -> *const T {\n+    (image_base()+offset) as *const T\n+}\n+\n+// Do not remove inline: will result in relocation failure\n+#[inline(always)]\n+pub unsafe fn rel_ptr_mut<T>(offset: u64) -> *mut T {\n+    (image_base()+offset) as *mut T\n+}\n+\n+// Do not remove inline: will result in relocation failure\n+// For the same reason we use inline ASM here instead of an extern static to\n+// locate the base\n+#[inline(always)]\n+fn image_base() -> u64 {\n+    let base;\n+    unsafe{asm!(\"lea IMAGE_BASE(%rip),$0\":\"=r\"(base))};\n+    base\n+}"}, {"sha": "cade96e3f52b7e8e57d43fde83b7bc87d0ed452b", "filename": "src/libstd/sys/sgx/abi/mod.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::sync::atomic::{AtomicUsize, Ordering};\n+use io::Write;\n+\n+// runtime features\n+mod reloc;\n+mod mem;\n+pub(super) mod panic;\n+\n+// library features\n+#[macro_use]\n+mod usercalls;\n+\n+global_asm!(concat!(usercalls_asm!(), include_str!(\"entry.S\")));\n+\n+#[no_mangle]\n+unsafe extern \"C\" fn tcs_init(secondary: bool) {\n+    // Be very careful when changing this code: it runs before the binary has been\n+    // relocated. Any indirect accesses to symbols will likely fail.\n+    const UNINIT: usize = 0;\n+    const BUSY: usize = 1;\n+    const DONE: usize = 2;\n+    // Three-state spin-lock\n+    static RELOC_STATE: AtomicUsize = AtomicUsize::new(UNINIT);\n+\n+    if secondary && RELOC_STATE.load(Ordering::Relaxed) != DONE {\n+        panic::panic_msg(\"Entered secondary TCS before main TCS!\")\n+    }\n+\n+    // Try to atomically swap UNINIT with BUSY. The returned state can be:\n+    match RELOC_STATE.compare_and_swap(UNINIT, BUSY, Ordering::Acquire) {\n+        // This thread just obtained the lock and other threads will observe BUSY\n+        UNINIT => {\n+            reloc::relocate_elf_rela();\n+            RELOC_STATE.store(DONE, Ordering::Release);\n+        },\n+        // We need to wait until the initialization is done.\n+        BUSY => while RELOC_STATE.load(Ordering::Acquire) == BUSY  {\n+            ::core::arch::x86_64::_mm_pause()\n+        },\n+        // Initialization is done.\n+        DONE => {},\n+        _ => unreachable!()\n+    }\n+}\n+\n+// FIXME: this item should only exist if this is linked into an executable\n+// (main function exists). If this is a library, the crate author should be\n+// able to specify this\n+#[no_mangle]\n+#[allow(unreachable_code)]\n+extern \"C\" fn entry(p1: u64, p2: u64, p3: u64, secondary: bool, p4: u64, p5: u64) -> (u64, u64) {\n+    if secondary {\n+        unimplemented!(\"thread entrypoint\");\n+\n+        (0, 0)\n+    } else {\n+        extern \"C\" {\n+            fn main(argc: isize, argv: *const *const u8) -> isize;\n+        }\n+\n+        // check entry is being called according to ABI\n+        assert_eq!(p3, 0);\n+        assert_eq!(p4, 0);\n+        assert_eq!(p5, 0);\n+\n+        unsafe {\n+            // The actual types of these arguments are `p1: *const Arg, p2:\n+            // usize`. We can't currently customize the argument list of Rust's\n+            // main function, so we pass these in as the standard pointer-sized\n+            // values in `argc` and `argv`.\n+            let ret = main(p2 as _, p1 as _);\n+            exit_with_code(ret)\n+        }\n+    }\n+}\n+\n+pub(super) fn exit_with_code(code: isize) -> ! {\n+    if code != 0 {\n+        if let Some(mut out) = panic::SgxPanicOutput::new() {\n+            let _ = write!(out, \"Exited with status code {}\", code);\n+        }\n+    }\n+    unsafe { usercalls::raw::exit(code != 0) };\n+}"}, {"sha": "dd9159b9fe23fc87057da63d55fb9a9ea1d42628", "filename": "src/libstd/sys/sgx/abi/panic.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fpanic.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io::{self, Write};\n+use slice::from_raw_parts_mut;\n+\n+extern \"C\" {\n+    fn take_debug_panic_buf_ptr() -> *mut u8;\n+    static DEBUG: u8;\n+}\n+\n+pub(crate) struct SgxPanicOutput(Option<&'static mut [u8]>);\n+\n+impl SgxPanicOutput {\n+    pub(crate) fn new() -> Option<Self> {\n+        if unsafe { DEBUG == 0 } {\n+            None\n+        } else {\n+            Some(SgxPanicOutput(None))\n+        }\n+    }\n+\n+    fn init(&mut self) -> &mut &'static mut [u8] {\n+        self.0.get_or_insert_with(|| unsafe {\n+            let ptr = take_debug_panic_buf_ptr();\n+            if ptr.is_null() {\n+                &mut []\n+            } else {\n+                from_raw_parts_mut(ptr, 1024)\n+            }\n+        })\n+    }\n+}\n+\n+impl Write for SgxPanicOutput {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.init().write(buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.init().flush()\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn panic_msg(msg: &str) -> ! {\n+    let _ = SgxPanicOutput::new().map(|mut out| out.write(msg.as_bytes()));\n+    unsafe { panic_exit(); }\n+}\n+\n+extern \"C\" { pub fn panic_exit() -> !; }"}, {"sha": "2d5e14d6ad1fc475884a3a89fc986467bcdd74ce", "filename": "src/libstd/sys/sgx/abi/reloc.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Freloc.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use slice::from_raw_parts;\n+use super::mem;\n+\n+const R_X86_64_RELATIVE: u32 = 8;\n+\n+#[repr(packed)]\n+struct Rela<T> {\n+    offset: T,\n+    info: T,\n+    addend: T,\n+}\n+\n+pub fn relocate_elf_rela() {\n+    extern {\n+        static RELA: u64;\n+        static RELACOUNT: usize;\n+    }\n+\n+    if unsafe { RELACOUNT } == 0 { return }  // unsafe ok: link-time constant\n+\n+    let relas = unsafe {\n+        from_raw_parts::<Rela<u64>>(mem::rel_ptr(RELA), RELACOUNT)  // unsafe ok: link-time constant\n+    };\n+    for rela in relas {\n+        if rela.info != (/*0 << 32 |*/ R_X86_64_RELATIVE as u64) {\n+            panic!(\"Invalid relocation\");\n+        }\n+        unsafe { *mem::rel_ptr_mut::<*const ()>(rela.offset) = mem::rel_ptr(rela.addend) };\n+    }\n+}"}, {"sha": "370e058badf5988a8aa72fe702b223f2ab6e187d", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+pub mod raw;"}, {"sha": "a28d41c1b7458e83d6a3ce48813af91101eaf974", "filename": "src/libstd/sys/sgx/abi/usercalls/raw.rs", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,231 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+\n+use fortanix_sgx_abi::*;\n+\n+use ptr::NonNull;\n+\n+#[repr(C)]\n+struct UsercallReturn(u64, u64);\n+\n+extern \"C\" {\n+    fn usercall(nr: u64, p1: u64, p2: u64, _ignore: u64, p3: u64, p4: u64) -> UsercallReturn;\n+}\n+\n+unsafe fn do_usercall(nr: u64, p1: u64, p2: u64, p3: u64, p4: u64) -> (u64, u64) {\n+    if nr==0 { panic!(\"Invalid usercall number {}\",nr) }\n+    let UsercallReturn(a, b) = usercall(nr,p1,p2,0,p3,p4);\n+    (a, b)\n+}\n+\n+type Register = u64;\n+\n+trait RegisterArgument {\n+    fn from_register(Register) -> Self;\n+    fn into_register(self) -> Register;\n+}\n+\n+trait ReturnValue {\n+    fn from_registers(call: &'static str, regs: (Register, Register)) -> Self;\n+}\n+\n+macro_rules! define_usercalls {\n+    // Using `$r:tt` because `$r:ty` doesn't match ! in `clobber_diverging`\n+    ($(fn $f:ident($($n:ident: $t:ty),*) $(-> $r:tt)*; )*) => {\n+        #[repr(C)]\n+        #[allow(non_camel_case_types)]\n+        enum Usercalls {\n+            __enclave_usercalls_invalid,\n+            $($f,)*\n+        }\n+\n+        $(enclave_usercalls_internal_define_usercalls!(def fn $f($($n: $t),*) $(-> $r)*);)*\n+    };\n+}\n+\n+macro_rules! define_usercalls_asm {\n+    ($(fn $f:ident($($n:ident: $t:ty),*) $(-> $r:ty)*; )*) => {\n+        macro_rules! usercalls_asm {\n+            () => {\n+                concat!(\n+                    \".equ usercall_nr_LAST, 0\\n\",\n+                    $(\n+                    \".equ usercall_nr_\", stringify!($f), \", usercall_nr_LAST+1\\n\",\n+                    \".equ usercall_nr_LAST, usercall_nr_\", stringify!($f), \"\\n\"\n+                    ),*\n+                )\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! define_ra {\n+    (< $i:ident > $t:ty) => {\n+        impl<$i> RegisterArgument for $t {\n+            fn from_register(a: Register) -> Self {\n+                a as _\n+            }\n+            fn into_register(self) -> Register {\n+                self as _\n+            }\n+        }\n+    };\n+    ($i:ty as $t:ty) => {\n+        impl RegisterArgument for $t {\n+            fn from_register(a: Register) -> Self {\n+                a as $i as _\n+            }\n+            fn into_register(self) -> Register {\n+                self as $i as _\n+            }\n+        }\n+    };\n+    ($t:ty) => {\n+        impl RegisterArgument for $t {\n+            fn from_register(a: Register) -> Self {\n+                a as _\n+            }\n+            fn into_register(self) -> Register {\n+                self as _\n+            }\n+        }\n+    };\n+}\n+\n+define_ra!(Register);\n+define_ra!(i64);\n+define_ra!(u32);\n+define_ra!(u32 as i32);\n+define_ra!(u16);\n+define_ra!(u16 as i16);\n+define_ra!(u8);\n+define_ra!(u8 as i8);\n+define_ra!(usize);\n+define_ra!(usize as isize);\n+define_ra!(<T> *const T);\n+define_ra!(<T> *mut T);\n+\n+impl RegisterArgument for bool {\n+    fn from_register(a: Register) -> bool {\n+        if a != 0 {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+    fn into_register(self) -> Register {\n+        self as _\n+    }\n+}\n+\n+impl<T: RegisterArgument> RegisterArgument for Option<NonNull<T>> {\n+    fn from_register(a: Register) -> Option<NonNull<T>> {\n+        NonNull::new(a as _)\n+    }\n+    fn into_register(self) -> Register {\n+        self.map_or(0 as _, NonNull::as_ptr) as _\n+    }\n+}\n+\n+impl ReturnValue for ! {\n+    fn from_registers(call: &'static str, _regs: (Register, Register)) -> Self {\n+        panic!(\"Usercall {}: did not expect to be re-entered\", call);\n+    }\n+}\n+\n+impl ReturnValue for () {\n+    fn from_registers(call: &'static str, regs: (Register, Register)) -> Self {\n+        assert_eq!(regs.0, 0, \"Usercall {}: expected {} return value to be 0\", call, \"1st\");\n+        assert_eq!(regs.1, 0, \"Usercall {}: expected {} return value to be 0\", call, \"2nd\");\n+        ()\n+    }\n+}\n+\n+impl<T: RegisterArgument> ReturnValue for T {\n+    fn from_registers(call: &'static str, regs: (Register, Register)) -> Self {\n+        assert_eq!(regs.1, 0, \"Usercall {}: expected {} return value to be 0\", call, \"2nd\");\n+        T::from_register(regs.0)\n+    }\n+}\n+\n+impl<T: RegisterArgument, U: RegisterArgument> ReturnValue for (T, U) {\n+    fn from_registers(_call: &'static str, regs: (Register, Register)) -> Self {\n+        (\n+            T::from_register(regs.0),\n+            U::from_register(regs.1)\n+        )\n+    }\n+}\n+\n+macro_rules! enclave_usercalls_internal_define_usercalls {\n+    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty,\n+                     $n3:ident: $t3:ty, $n4:ident: $t4:ty) -> $r:ty) => (\n+        #[inline(always)]\n+        pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3, $n4: $t4) -> $r {\n+            ReturnValue::from_registers(stringify!($f), do_usercall(\n+                Usercalls::$f as Register,\n+                RegisterArgument::into_register($n1),\n+                RegisterArgument::into_register($n2),\n+                RegisterArgument::into_register($n3),\n+                RegisterArgument::into_register($n4),\n+            ))\n+        }\n+    );\n+    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty, $n3:ident: $t3:ty) -> $r:ty) => (\n+        #[inline(always)]\n+        pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3) -> $r {\n+            ReturnValue::from_registers(stringify!($f), do_usercall(\n+                Usercalls::$f as Register,\n+                RegisterArgument::into_register($n1),\n+                RegisterArgument::into_register($n2),\n+                RegisterArgument::into_register($n3),\n+                0\n+            ))\n+        }\n+    );\n+    (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty) -> $r:ty) => (\n+        #[inline(always)]\n+        pub unsafe fn $f($n1: $t1, $n2: $t2) -> $r {\n+            ReturnValue::from_registers(stringify!($f), do_usercall(\n+                Usercalls::$f as Register,\n+                RegisterArgument::into_register($n1),\n+                RegisterArgument::into_register($n2),\n+                0,0\n+            ))\n+        }\n+    );\n+    (def fn $f:ident($n1:ident: $t1:ty) -> $r:ty) => (\n+        #[inline(always)]\n+        pub unsafe fn $f($n1: $t1) -> $r {\n+            ReturnValue::from_registers(stringify!($f), do_usercall(\n+                Usercalls::$f as Register,\n+                RegisterArgument::into_register($n1),\n+                0,0,0\n+            ))\n+        }\n+    );\n+    (def fn $f:ident() -> $r:ty) => (\n+        #[inline(always)]\n+        pub unsafe fn $f() -> $r {\n+            ReturnValue::from_registers(stringify!($f), do_usercall(\n+                Usercalls::$f as Register,\n+                0,0,0,0\n+            ))\n+        }\n+    );\n+    (def fn $f:ident($($n:ident: $t:ty),*)) => (\n+        enclave_usercalls_internal_define_usercalls!(def fn $f($($n: $t),*) -> ());\n+    );\n+}\n+\n+invoke_with_usercalls!(define_usercalls);\n+invoke_with_usercalls!(define_usercalls_asm);"}, {"sha": "a31f93ae493738df8d9d3c7f5751e073ed8f3071", "filename": "src/libstd/sys/sgx/alloc.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Falloc.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate dlmalloc;\n+\n+use alloc::{GlobalAlloc, Layout, System};\n+\n+// FIXME: protect this value for concurrent access\n+static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n+\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+unsafe impl GlobalAlloc for System {\n+    #[inline]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        DLMALLOC.malloc(layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        DLMALLOC.calloc(layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        DLMALLOC.free(ptr, layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n+    }\n+}"}, {"sha": "64cb83b462a44d357787d794a160d3ca080d1064", "filename": "src/libstd/sys/sgx/args.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsString;\n+use fortanix_sgx_abi::ByteBuffer;\n+\n+pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+    // See ABI\n+    let _len: usize = argc as _;\n+    let _args: *const ByteBuffer = argv as _;\n+\n+    // TODO\n+}\n+\n+pub unsafe fn cleanup() {\n+}\n+\n+pub fn args() -> Args {\n+    Args\n+}\n+\n+pub struct Args;\n+\n+impl Args {\n+    pub fn inner_debug(&self) -> &[OsString] {\n+        &[]\n+    }\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> {\n+        None\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(0))\n+    }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize {\n+        0\n+    }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> {\n+        None\n+    }\n+}"}, {"sha": "ca4a7c9561cf79d1962f031544f6bc6c88909bb4", "filename": "src/libstd/sys/sgx/backtrace.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fbacktrace.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::unsupported;\n+use sys_common::backtrace::Frame;\n+\n+pub struct BacktraceContext;\n+\n+pub fn unwind_backtrace(_frames: &mut [Frame])\n+    -> io::Result<(usize, BacktraceContext)>\n+{\n+    unsupported()\n+}\n+\n+pub fn resolve_symname<F>(_frame: Frame,\n+                          _callback: F,\n+                          _: &BacktraceContext) -> io::Result<()>\n+    where F: FnOnce(Option<&str>) -> io::Result<()>\n+{\n+    unsupported()\n+}\n+\n+pub fn foreach_symbol_fileline<F>(_: Frame,\n+                                  _: F,\n+                                  _: &BacktraceContext) -> io::Result<bool>\n+    where F: FnMut(&[u8], u32) -> io::Result<()>\n+{\n+    unsupported()\n+}"}, {"sha": "0c1300f61f86ca4384e5ce18c876181ad73f3a1e", "filename": "src/libstd/sys/sgx/cmath.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcmath.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg(not(test))]\n+\n+// These symbols are all defined in `compiler-builtins`\n+extern {\n+    pub fn acos(n: f64) -> f64;\n+    pub fn acosf(n: f32) -> f32;\n+    pub fn asin(n: f64) -> f64;\n+    pub fn asinf(n: f32) -> f32;\n+    pub fn atan(n: f64) -> f64;\n+    pub fn atan2(a: f64, b: f64) -> f64;\n+    pub fn atan2f(a: f32, b: f32) -> f32;\n+    pub fn atanf(n: f32) -> f32;\n+    pub fn cbrt(n: f64) -> f64;\n+    pub fn cbrtf(n: f32) -> f32;\n+    pub fn cosh(n: f64) -> f64;\n+    pub fn coshf(n: f32) -> f32;\n+    pub fn expm1(n: f64) -> f64;\n+    pub fn expm1f(n: f32) -> f32;\n+    pub fn fdim(a: f64, b: f64) -> f64;\n+    pub fn fdimf(a: f32, b: f32) -> f32;\n+    pub fn hypot(x: f64, y: f64) -> f64;\n+    pub fn hypotf(x: f32, y: f32) -> f32;\n+    pub fn log1p(n: f64) -> f64;\n+    pub fn log1pf(n: f32) -> f32;\n+    pub fn sinh(n: f64) -> f64;\n+    pub fn sinhf(n: f32) -> f32;\n+    pub fn tan(n: f64) -> f64;\n+    pub fn tanf(n: f32) -> f32;\n+    pub fn tanh(n: f64) -> f64;\n+    pub fn tanhf(n: f32) -> f32;\n+}"}, {"sha": "2097280a064f0fdea59ca93a2cfeb92e698f8d7f", "filename": "src/libstd/sys/sgx/condvar.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use sys::mutex::Mutex;\n+use time::Duration;\n+\n+pub struct Condvar { }\n+\n+impl Condvar {\n+    pub const fn new() -> Condvar {\n+        Condvar { }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {}\n+\n+    #[inline]\n+    pub unsafe fn notify_one(&self) {\n+    }\n+\n+    #[inline]\n+    pub unsafe fn notify_all(&self) {\n+    }\n+\n+    pub unsafe fn wait(&self, _mutex: &Mutex) {\n+        panic!(\"can't block with web assembly\")\n+    }\n+\n+    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n+        panic!(\"can't block with web assembly\");\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+    }\n+}"}, {"sha": "146ce02754b10af1263b3236c55fc0dcf662a418", "filename": "src/libstd/sys/sgx/env.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fenv.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod os {\n+    pub const FAMILY: &'static str = \"\";\n+    pub const OS: &'static str = \"\";\n+    pub const DLL_PREFIX: &'static str = \"\";\n+    pub const DLL_SUFFIX: &'static str = \".sgxs\";\n+    pub const DLL_EXTENSION: &'static str = \"sgxs\";\n+    pub const EXE_SUFFIX: &'static str = \".sgxs\";\n+    pub const EXE_EXTENSION: &'static str = \"sgxs\";\n+}"}, {"sha": "1dcea3e8eac97972020dc6d97f1cbce80fb9bf15", "filename": "src/libstd/sys/sgx/fs.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ffs.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,304 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsString;\n+use fmt;\n+use hash::{Hash, Hasher};\n+use io::{self, SeekFrom};\n+use path::{Path, PathBuf};\n+use sys::time::SystemTime;\n+use sys::{unsupported, Void};\n+\n+pub struct File(Void);\n+\n+pub struct FileAttr(Void);\n+\n+pub struct ReadDir(Void);\n+\n+pub struct DirEntry(Void);\n+\n+#[derive(Clone, Debug)]\n+pub struct OpenOptions { }\n+\n+pub struct FilePermissions(Void);\n+\n+pub struct FileType(Void);\n+\n+#[derive(Debug)]\n+pub struct DirBuilder { }\n+\n+impl FileAttr {\n+    pub fn size(&self) -> u64 {\n+        match self.0 {}\n+    }\n+\n+    pub fn perm(&self) -> FilePermissions {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_type(&self) -> FileType {\n+        match self.0 {}\n+    }\n+\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+\n+    pub fn created(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FileAttr {\n+    fn clone(&self) -> FileAttr {\n+        match self.0 {}\n+    }\n+}\n+\n+impl FilePermissions {\n+    pub fn readonly(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_readonly(&mut self, _readonly: bool) {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FilePermissions {\n+    fn clone(&self) -> FilePermissions {\n+        match self.0 {}\n+    }\n+}\n+\n+impl PartialEq for FilePermissions {\n+    fn eq(&self, _other: &FilePermissions) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for FilePermissions {\n+}\n+\n+impl fmt::Debug for FilePermissions {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl FileType {\n+    pub fn is_dir(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn is_file(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn is_symlink(&self) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FileType {\n+    fn clone(&self) -> FileType {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Copy for FileType {}\n+\n+impl PartialEq for FileType {\n+    fn eq(&self, _other: &FileType) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for FileType {\n+}\n+\n+impl Hash for FileType {\n+    fn hash<H: Hasher>(&self, _h: &mut H) {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for FileType {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for ReadDir {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Iterator for ReadDir {\n+    type Item = io::Result<DirEntry>;\n+\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl DirEntry {\n+    pub fn path(&self) -> PathBuf {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_name(&self) -> OsString {\n+        match self.0 {}\n+    }\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl OpenOptions {\n+    pub fn new() -> OpenOptions {\n+        OpenOptions { }\n+    }\n+\n+    pub fn read(&mut self, _read: bool) { }\n+    pub fn write(&mut self, _write: bool) { }\n+    pub fn append(&mut self, _append: bool) { }\n+    pub fn truncate(&mut self, _truncate: bool) { }\n+    pub fn create(&mut self, _create: bool) { }\n+    pub fn create_new(&mut self, _create_new: bool) { }\n+}\n+\n+impl File {\n+    pub fn open(_path: &Path, _opts: &OpenOptions) -> io::Result<File> {\n+        unsupported()\n+    }\n+\n+    pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn fsync(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn datasync(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn truncate(&self, _size: u64) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<File> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        match self.0 {}\n+    }\n+}\n+\n+impl DirBuilder {\n+    pub fn new() -> DirBuilder {\n+        DirBuilder { }\n+    }\n+\n+    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {\n+        unsupported()\n+    }\n+}\n+\n+impl fmt::Debug for File {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n+    unsupported()\n+}\n+\n+pub fn unlink(_p: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {\n+    match perm.0 {}\n+}\n+\n+pub fn rmdir(_p: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn remove_dir_all(_path: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn stat(_p: &Path) -> io::Result<FileAttr> {\n+    unsupported()\n+}\n+\n+pub fn lstat(_p: &Path) -> io::Result<FileAttr> {\n+    unsupported()\n+}\n+\n+pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> {\n+    unsupported()\n+}"}, {"sha": "0998bc5db4c3f97b85052116a641e5a273cefbd1", "filename": "src/libstd/sys/sgx/memchr.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmemchr.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use core::slice::memchr::{memchr, memrchr};"}, {"sha": "f38c69e90c7c46f73c92828aa40f46f9aac86978", "filename": "src/libstd/sys/sgx/mod.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,151 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! System bindings for the Fortanix SGX platform\n+//!\n+//! This module contains the facade (aka platform-specific) implementations of\n+//! OS level functionality for Fortanix SGX.\n+\n+use io;\n+use os::raw::c_char;\n+use sync::atomic::{AtomicBool, Ordering};\n+\n+pub mod abi;\n+\n+pub mod alloc;\n+pub mod args;\n+#[cfg(feature = \"backtrace\")]\n+pub mod backtrace;\n+pub mod cmath;\n+pub mod condvar;\n+pub mod env;\n+pub mod fs;\n+pub mod memchr;\n+pub mod mutex;\n+pub mod net;\n+pub mod os;\n+pub mod os_str;\n+pub mod path;\n+pub mod pipe;\n+pub mod process;\n+pub mod rwlock;\n+pub mod stack_overflow;\n+pub mod thread;\n+pub mod thread_local;\n+pub mod time;\n+pub mod stdio;\n+\n+#[cfg(not(test))]\n+pub fn init() {\n+}\n+\n+/// This function is used to implement functionality that simply doesn't exist.\n+/// Programs relying on this functionality will need to deal with the error.\n+pub fn unsupported<T>() -> io::Result<T> {\n+    Err(unsupported_err())\n+}\n+\n+pub fn unsupported_err() -> io::Error {\n+    io::Error::new(io::ErrorKind::Other,\n+                   \"operation not supported on SGX yet\")\n+}\n+\n+/// This function is used to implement various functions that doesn't exist,\n+/// but the lack of which might not be reason for error. If no error is\n+/// returned, the program might very well be able to function normally. This is\n+/// what happens when `SGX_INEFFECTIVE_ERROR` is set to `true`. If it is\n+/// `false`, the behavior is the same as `unsupported`.\n+pub fn sgx_ineffective<T>(v: T) -> io::Result<T> {\n+    static SGX_INEFFECTIVE_ERROR: AtomicBool = AtomicBool::new(false);\n+    if SGX_INEFFECTIVE_ERROR.load(Ordering::Relaxed) {\n+        Err(io::Error::new(io::ErrorKind::Other,\n+                       \"operation can't be trusted to have any effect on SGX\"))\n+    } else {\n+        Ok(v)\n+    }\n+}\n+\n+pub fn decode_error_kind(code: i32) -> io::ErrorKind {\n+    use fortanix_sgx_abi::Error;\n+\n+    // FIXME: not sure how to make sure all variants of Error are covered\n+    if code == Error::NotFound as _ {\n+        io::ErrorKind::NotFound\n+    } else if code == Error::PermissionDenied as _ {\n+        io::ErrorKind::PermissionDenied\n+    } else if code == Error::ConnectionRefused as _ {\n+        io::ErrorKind::ConnectionRefused\n+    } else if code == Error::ConnectionReset as _ {\n+        io::ErrorKind::ConnectionReset\n+    } else if code == Error::ConnectionAborted as _ {\n+        io::ErrorKind::ConnectionAborted\n+    } else if code == Error::NotConnected as _ {\n+        io::ErrorKind::NotConnected\n+    } else if code == Error::AddrInUse as _ {\n+        io::ErrorKind::AddrInUse\n+    } else if code == Error::AddrNotAvailable as _ {\n+        io::ErrorKind::AddrNotAvailable\n+    } else if code == Error::BrokenPipe as _ {\n+        io::ErrorKind::BrokenPipe\n+    } else if code == Error::AlreadyExists as _ {\n+        io::ErrorKind::AlreadyExists\n+    } else if code == Error::WouldBlock as _ {\n+        io::ErrorKind::WouldBlock\n+    } else if code == Error::InvalidInput as _ {\n+        io::ErrorKind::InvalidInput\n+    } else if code == Error::InvalidData as _ {\n+        io::ErrorKind::InvalidData\n+    } else if code == Error::TimedOut as _ {\n+        io::ErrorKind::TimedOut\n+    } else if code == Error::WriteZero as _ {\n+        io::ErrorKind::WriteZero\n+    } else if code == Error::Interrupted as _ {\n+        io::ErrorKind::Interrupted\n+    } else if code == Error::Other as _ {\n+        io::ErrorKind::Other\n+    } else if code == Error::UnexpectedEof as _ {\n+        io::ErrorKind::UnexpectedEof\n+    } else {\n+        io::ErrorKind::Other\n+    }\n+}\n+\n+// This enum is used as the storage for a bunch of types which can't actually\n+// exist.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub enum Void {}\n+\n+pub unsafe fn strlen(mut s: *const c_char) -> usize {\n+    let mut n = 0;\n+    while *s != 0 {\n+        n += 1;\n+        s = s.offset(1);\n+    }\n+    return n\n+}\n+\n+pub unsafe fn abort_internal() -> ! {\n+    abi::panic::panic_exit()\n+}\n+\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    fn rdrand64() -> u64 {\n+        unsafe {\n+            let mut ret: u64 = ::mem::uninitialized();\n+            for _ in 0..10 {\n+                if ::arch::x86_64::_rdrand64_step(&mut ret) == 1 {\n+                    return ret;\n+                }\n+            }\n+            panic!(\"Failed to obtain random data\");\n+        }\n+    }\n+    (rdrand64(), rdrand64())\n+}"}, {"sha": "ffaa4014e1468152a870c5568298a1d6ea44ee89", "filename": "src/libstd/sys/sgx/mutex.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+\n+pub struct Mutex {\n+    locked: UnsafeCell<bool>,\n+}\n+\n+unsafe impl Send for Mutex {}\n+unsafe impl Sync for Mutex {} // FIXME\n+\n+impl Mutex {\n+    pub const fn new() -> Mutex {\n+        Mutex { locked: UnsafeCell::new(false) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {\n+    }\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let locked = self.locked.get();\n+        assert!(!*locked, \"cannot recursively acquire mutex\");\n+        *locked = true;\n+    }\n+\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        *self.locked.get() = false;\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let locked = self.locked.get();\n+        if *locked {\n+            false\n+        } else {\n+            *locked = true;\n+            true\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+    }\n+}\n+\n+// FIXME\n+pub struct ReentrantMutex {\n+}\n+\n+impl ReentrantMutex {\n+    pub unsafe fn uninitialized() -> ReentrantMutex {\n+        ReentrantMutex { }\n+    }\n+\n+    pub unsafe fn init(&mut self) {}\n+\n+    pub unsafe fn lock(&self) {}\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        true\n+    }\n+\n+    pub unsafe fn unlock(&self) {}\n+\n+    pub unsafe fn destroy(&self) {}\n+}"}, {"sha": "094683e28b80d6ee91a6c10c6e642bdf83dc38f8", "filename": "src/libstd/sys/sgx/net.rs", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,356 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fmt;\n+use io;\n+use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n+use time::Duration;\n+use sys::{unsupported, Void};\n+use convert::TryFrom;\n+\n+pub struct TcpStream(Void);\n+\n+impl TcpStream {\n+    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n+        unsupported()\n+    }\n+\n+    pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n+        unsupported()\n+    }\n+\n+    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpStream> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for TcpStream {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct TcpListener(Void);\n+\n+impl TcpListener {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n+        unsupported()\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpListener> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for TcpListener {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct UdpSocket(Void);\n+\n+impl UdpSocket {\n+    pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n+        unsupported()\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn broadcast(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n+                         -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n+                         -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n+                          -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n+                          -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for UdpSocket {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct LookupHost(Void);\n+\n+impl LookupHost {\n+    pub fn port(&self) -> u16 {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Iterator for LookupHost {\n+    type Item = SocketAddr;\n+    fn next(&mut self) -> Option<SocketAddr> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl<'a> TryFrom<&'a str> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(_v: &'a str) -> io::Result<LookupHost> {\n+        unsupported()\n+    }\n+}\n+\n+impl<'a> TryFrom<(&'a str, u16)> for LookupHost {\n+    type Error = io::Error;\n+\n+    fn try_from(_v: (&'a str, u16)) -> io::Result<LookupHost> {\n+        unsupported()\n+    }\n+}\n+\n+#[allow(bad_style)]\n+pub mod netc {\n+    pub const AF_INET: u8 = 0;\n+    pub const AF_INET6: u8 = 1;\n+    pub type sa_family_t = u8;\n+\n+    #[derive(Copy, Clone)]\n+    pub struct in_addr {\n+        pub s_addr: u32,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr_in {\n+        pub sin_family: sa_family_t,\n+        pub sin_port: u16,\n+        pub sin_addr: in_addr,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct in6_addr {\n+        pub s6_addr: [u8; 16],\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr_in6 {\n+        pub sin6_family: sa_family_t,\n+        pub sin6_port: u16,\n+        pub sin6_addr: in6_addr,\n+        pub sin6_flowinfo: u32,\n+        pub sin6_scope_id: u32,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr {\n+    }\n+\n+    pub type socklen_t = usize;\n+}"}, {"sha": "38d82efaf17bde4bcb24a676f2c0f68c32d26ea5", "filename": "src/libstd/sys/sgx/os.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fos.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,120 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fortanix_sgx_abi::{Error, RESULT_SUCCESS};\n+\n+use error::Error as StdError;\n+use ffi::{OsString, OsStr};\n+use fmt;\n+use io;\n+use path::{self, PathBuf};\n+use str;\n+use sys::{unsupported, Void, sgx_ineffective, decode_error_kind};\n+\n+pub fn errno() -> i32 {\n+    RESULT_SUCCESS\n+}\n+\n+pub fn error_string(errno: i32) -> String {\n+    if errno == RESULT_SUCCESS {\n+        \"operation succesful\".into()\n+    } else if ((Error::UserRangeStart as _)..=(Error::UserRangeEnd as _)).contains(&errno) {\n+        format!(\"user-specified error {:08x}\", errno)\n+    } else {\n+        decode_error_kind(errno).as_str().into()\n+    }\n+}\n+\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn chdir(_: &path::Path) -> io::Result<()> {\n+    sgx_ineffective(())\n+}\n+\n+pub struct SplitPaths<'a>(&'a Void);\n+\n+pub fn split_paths(_unparsed: &OsStr) -> SplitPaths {\n+    panic!(\"unsupported\")\n+}\n+\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> {\n+        match *self.0 {}\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n+    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+{\n+    Err(JoinPathsError)\n+}\n+\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"not supported in SGX yet\".fmt(f)\n+    }\n+}\n+\n+impl StdError for JoinPathsError {\n+    fn description(&self) -> &str {\n+        \"not supported in SGX yet\"\n+    }\n+}\n+\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub struct Env;\n+\n+impl Iterator for Env {\n+    type Item = (OsString, OsString);\n+    fn next(&mut self) -> Option<(OsString, OsString)> {\n+        None\n+    }\n+}\n+\n+pub fn env() -> Env {\n+    Env\n+}\n+\n+pub fn getenv(_k: &OsStr) -> io::Result<Option<OsString>> {\n+    unsupported()\n+}\n+\n+pub fn setenv(_k: &OsStr, _v: &OsStr) -> io::Result<()> {\n+    sgx_ineffective(()) // FIXME: this could trigger a panic higher up the stack\n+}\n+\n+pub fn unsetenv(_k: &OsStr) -> io::Result<()> {\n+    sgx_ineffective(()) // FIXME: this could trigger a panic higher up the stack\n+}\n+\n+pub fn temp_dir() -> PathBuf {\n+    panic!(\"no filesystem in SGX\")\n+}\n+\n+pub fn home_dir() -> Option<PathBuf> {\n+    None\n+}\n+\n+pub fn exit(code: i32) -> ! {\n+    super::abi::exit_with_code(code as _)\n+}\n+\n+pub fn getpid() -> u32 {\n+    panic!(\"no pids in SGX\")\n+}"}, {"sha": "9bfb84db209456248adaff64844c3aeb6ea09639", "filename": "src/libstd/sys/sgx/os_str.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fos_str.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,189 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The underlying OsString/OsStr implementation on Unix systems: just\n+/// a `Vec<u8>`/`[u8]`.\n+\n+use borrow::Cow;\n+use fmt;\n+use str;\n+use mem;\n+use rc::Rc;\n+use sync::Arc;\n+use sys_common::{AsInner, IntoInner};\n+use sys_common::bytestring::debug_fmt_bytestring;\n+use core::str::lossy::Utf8Lossy;\n+\n+#[derive(Clone, Hash)]\n+pub struct Buf {\n+    pub inner: Vec<u8>\n+}\n+\n+pub struct Slice {\n+    pub inner: [u8]\n+}\n+\n+impl fmt::Debug for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        debug_fmt_bytestring(&self.inner, formatter)\n+    }\n+}\n+\n+impl fmt::Display for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&Utf8Lossy::from_bytes(&self.inner), formatter)\n+    }\n+}\n+\n+impl fmt::Debug for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(self.as_slice(), formatter)\n+    }\n+}\n+\n+impl fmt::Display for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self.as_slice(), formatter)\n+    }\n+}\n+\n+impl IntoInner<Vec<u8>> for Buf {\n+    fn into_inner(self) -> Vec<u8> {\n+        self.inner\n+    }\n+}\n+\n+impl AsInner<[u8]> for Buf {\n+    fn as_inner(&self) -> &[u8] {\n+        &self.inner\n+    }\n+}\n+\n+\n+impl Buf {\n+    pub fn from_string(s: String) -> Buf {\n+        Buf { inner: s.into_bytes() }\n+    }\n+\n+    #[inline]\n+    pub fn with_capacity(capacity: usize) -> Buf {\n+        Buf {\n+            inner: Vec::with_capacity(capacity)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.inner.clear()\n+    }\n+\n+    #[inline]\n+    pub fn capacity(&self) -> usize {\n+        self.inner.capacity()\n+    }\n+\n+    #[inline]\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.inner.reserve(additional)\n+    }\n+\n+    #[inline]\n+    pub fn reserve_exact(&mut self, additional: usize) {\n+        self.inner.reserve_exact(additional)\n+    }\n+\n+    #[inline]\n+    pub fn shrink_to_fit(&mut self) {\n+        self.inner.shrink_to_fit()\n+    }\n+\n+    #[inline]\n+    pub fn shrink_to(&mut self, min_capacity: usize) {\n+        self.inner.shrink_to(min_capacity)\n+    }\n+\n+    pub fn as_slice(&self) -> &Slice {\n+        unsafe { mem::transmute(&*self.inner) }\n+    }\n+\n+    pub fn into_string(self) -> Result<String, Buf> {\n+        String::from_utf8(self.inner).map_err(|p| Buf { inner: p.into_bytes() } )\n+    }\n+\n+    pub fn push_slice(&mut self, s: &Slice) {\n+        self.inner.extend_from_slice(&s.inner)\n+    }\n+\n+    #[inline]\n+    pub fn into_box(self) -> Box<Slice> {\n+        unsafe { mem::transmute(self.inner.into_boxed_slice()) }\n+    }\n+\n+    #[inline]\n+    pub fn from_box(boxed: Box<Slice>) -> Buf {\n+        let inner: Box<[u8]> = unsafe { mem::transmute(boxed) };\n+        Buf { inner: inner.into_vec() }\n+    }\n+\n+    #[inline]\n+    pub fn into_arc(&self) -> Arc<Slice> {\n+        self.as_slice().into_arc()\n+    }\n+\n+    #[inline]\n+    pub fn into_rc(&self) -> Rc<Slice> {\n+        self.as_slice().into_rc()\n+    }\n+}\n+\n+impl Slice {\n+    fn from_u8_slice(s: &[u8]) -> &Slice {\n+        unsafe { mem::transmute(s) }\n+    }\n+\n+    pub fn from_str(s: &str) -> &Slice {\n+        Slice::from_u8_slice(s.as_bytes())\n+    }\n+\n+    pub fn to_str(&self) -> Option<&str> {\n+        str::from_utf8(&self.inner).ok()\n+    }\n+\n+    pub fn to_string_lossy(&self) -> Cow<str> {\n+        String::from_utf8_lossy(&self.inner)\n+    }\n+\n+    pub fn to_owned(&self) -> Buf {\n+        Buf { inner: self.inner.to_vec() }\n+    }\n+\n+    #[inline]\n+    pub fn into_box(&self) -> Box<Slice> {\n+        let boxed: Box<[u8]> = self.inner.into();\n+        unsafe { mem::transmute(boxed) }\n+    }\n+\n+    pub fn empty_box() -> Box<Slice> {\n+        let boxed: Box<[u8]> = Default::default();\n+        unsafe { mem::transmute(boxed) }\n+    }\n+\n+    #[inline]\n+    pub fn into_arc(&self) -> Arc<Slice> {\n+        let arc: Arc<[u8]> = Arc::from(&self.inner);\n+        unsafe { Arc::from_raw(Arc::into_raw(arc) as *const Slice) }\n+    }\n+\n+    #[inline]\n+    pub fn into_rc(&self) -> Rc<Slice> {\n+        let rc: Rc<[u8]> = Rc::from(&self.inner);\n+        unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Slice) }\n+    }\n+}"}, {"sha": "afe0c490426f950150e3e96cfa7295f23e157979", "filename": "src/libstd/sys/sgx/path.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fpath.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use path::Prefix;\n+use ffi::OsStr;\n+\n+#[inline]\n+pub fn is_sep_byte(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+#[inline]\n+pub fn is_verbatim_sep(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+pub fn parse_prefix(_: &OsStr) -> Option<Prefix> {\n+    None\n+}\n+\n+pub const MAIN_SEP_STR: &'static str = \"/\";\n+pub const MAIN_SEP: char = '/';"}, {"sha": "6c6cbc14a8ab2d7b3cb7306d488bf2dc61e12777", "filename": "src/libstd/sys/sgx/pipe.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fpipe.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::Void;\n+\n+pub struct AnonPipe(Void);\n+\n+impl AnonPipe {\n+    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn read2(p1: AnonPipe,\n+             _v1: &mut Vec<u8>,\n+             _p2: AnonPipe,\n+             _v2: &mut Vec<u8>) -> io::Result<()> {\n+    match p1.0 {}\n+}"}, {"sha": "01a12fba043ca913bf7cae188912c446ba9d91fb", "filename": "src/libstd/sys/sgx/process.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,162 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsStr;\n+use fmt;\n+use io;\n+use sys::fs::File;\n+use sys::pipe::AnonPipe;\n+use sys::{unsupported, Void};\n+use sys_common::process::{CommandEnv, DefaultEnvKey};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Command {\n+    env: CommandEnv<DefaultEnvKey>\n+}\n+\n+// passed back to std::process with the pipes connected to the child, if any\n+// were requested\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+}\n+\n+impl Command {\n+    pub fn new(_program: &OsStr) -> Command {\n+        Command {\n+            env: Default::default()\n+        }\n+    }\n+\n+    pub fn arg(&mut self, _arg: &OsStr) {\n+    }\n+\n+    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n+        &mut self.env\n+    }\n+\n+    pub fn cwd(&mut self, _dir: &OsStr) {\n+    }\n+\n+    pub fn stdin(&mut self, _stdin: Stdio) {\n+    }\n+\n+    pub fn stdout(&mut self, _stdout: Stdio) {\n+    }\n+\n+    pub fn stderr(&mut self, _stderr: Stdio) {\n+    }\n+\n+    pub fn spawn(&mut self, _default: Stdio, _needs_stdin: bool)\n+        -> io::Result<(Process, StdioPipes)> {\n+        unsupported()\n+    }\n+}\n+\n+impl From<AnonPipe> for Stdio {\n+    fn from(pipe: AnonPipe) -> Stdio {\n+        pipe.diverge()\n+    }\n+}\n+\n+impl From<File> for Stdio {\n+    fn from(file: File) -> Stdio {\n+        file.diverge()\n+    }\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        Ok(())\n+    }\n+}\n+\n+pub struct ExitStatus(Void);\n+\n+impl ExitStatus {\n+    pub fn success(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for ExitStatus {\n+    fn clone(&self) -> ExitStatus {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Copy for ExitStatus {}\n+\n+impl PartialEq for ExitStatus {\n+    fn eq(&self, _other: &ExitStatus) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for ExitStatus {\n+}\n+\n+impl fmt::Debug for ExitStatus {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitCode(bool);\n+\n+impl ExitCode {\n+    pub const SUCCESS: ExitCode = ExitCode(false);\n+    pub const FAILURE: ExitCode = ExitCode(true);\n+\n+    pub fn as_i32(&self) -> i32 {\n+        self.0 as i32\n+    }\n+}\n+\n+pub struct Process(Void);\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        match self.0 {}\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        match self.0 {}\n+    }\n+\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n+        match self.0 {}\n+    }\n+}"}, {"sha": "2c0b1a45206c3345ee6fb2d8623d4290ade5fc69", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+\n+pub struct RWLock {\n+    mode: UnsafeCell<isize>,\n+}\n+\n+unsafe impl Send for RWLock {}\n+unsafe impl Sync for RWLock {} // FIXME\n+\n+impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock {\n+            mode: UnsafeCell::new(0),\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        let mode = self.mode.get();\n+        if *mode >= 0 {\n+            *mode += 1;\n+        } else {\n+            rtabort!(\"rwlock locked for writing\");\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        let mode = self.mode.get();\n+        if *mode >= 0 {\n+            *mode += 1;\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        let mode = self.mode.get();\n+        if *mode == 0 {\n+            *mode = -1;\n+        } else {\n+            rtabort!(\"rwlock locked for reading\")\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        let mode = self.mode.get();\n+        if *mode == 0 {\n+            *mode = -1;\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        *self.mode.get() -= 1;\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        *self.mode.get() += 1;\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+    }\n+}"}, {"sha": "0176b748a87c6f6192d65648755202a8408e24d7", "filename": "src/libstd/sys/sgx/stack_overflow.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Handler;\n+\n+impl Handler {\n+    pub unsafe fn new() -> Handler {\n+        Handler\n+    }\n+}\n+\n+pub unsafe fn init() {\n+}\n+\n+pub unsafe fn cleanup() {\n+}"}, {"sha": "540599a35964cb2e33ddf48339f7e8f309f2ae8a", "filename": "src/libstd/sys/sgx/stdio.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fstdio.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::unsupported;\n+\n+pub struct Stdin;\n+pub struct Stdout;\n+pub struct Stderr;\n+\n+impl Stdin {\n+    pub fn new() -> io::Result<Stdin> {\n+        Ok(Stdin)\n+    }\n+\n+    pub fn read(&self, _data: &mut [u8]) -> io::Result<usize> {\n+        unsupported()\n+    }\n+}\n+\n+impl Stdout {\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout)\n+    }\n+\n+    pub fn write(&self, _data: &[u8]) -> io::Result<usize> {\n+        unsupported()\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl Stderr {\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr)\n+    }\n+\n+    pub fn write(&self, _data: &[u8]) -> io::Result<usize> {\n+        unsupported()\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl io::Write for Stderr {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        (&*self).write(data)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        (&*self).flush()\n+    }\n+}\n+\n+pub const STDIN_BUF_SIZE: usize = 0;\n+\n+pub fn is_ebadf(_err: &io::Error) -> bool {\n+    true\n+}\n+\n+pub fn panic_output() -> Option<impl io::Write> {\n+    super::abi::panic::SgxPanicOutput::new()\n+}"}, {"sha": "ff8df12302c309c9aa7b688a223e11b3ac038568", "filename": "src/libstd/sys/sgx/thread.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use boxed::FnBox;\n+use ffi::CStr;\n+use io;\n+use sys::{unsupported, Void};\n+use time::Duration;\n+\n+pub struct Thread(Void);\n+\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n+\n+impl Thread {\n+    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n+    pub unsafe fn new(_stack: usize, _p: Box<dyn FnBox()>)\n+        -> io::Result<Thread>\n+    {\n+        unsupported()\n+    }\n+\n+    pub fn yield_now() {\n+        // do nothing\n+    }\n+\n+    pub fn set_name(_name: &CStr) {\n+        // nope\n+    }\n+\n+    pub fn sleep(_dur: Duration) {\n+        panic!(\"can't sleep\");\n+    }\n+\n+    pub fn join(self) {\n+        match self.0 {}\n+    }\n+}\n+\n+pub mod guard {\n+    pub type Guard = !;\n+    pub unsafe fn current() -> Option<Guard> { None }\n+    pub unsafe fn init() -> Option<Guard> { None }\n+    pub unsafe fn deinit() {}\n+}"}, {"sha": "2126e0a853eb01618922a2605b1a2e5c16c18a57", "filename": "src/libstd/sys/sgx/thread_local.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread_local.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use boxed::Box;\n+use ptr;\n+\n+pub type Key = usize;\n+\n+struct Allocated {\n+    value: *mut u8,\n+    dtor: Option<unsafe extern fn(*mut u8)>,\n+}\n+\n+#[inline]\n+pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    Box::into_raw(Box::new(Allocated {\n+        value: ptr::null_mut(),\n+        dtor,\n+    })) as usize\n+}\n+\n+#[inline]\n+pub unsafe fn set(key: Key, value: *mut u8) {\n+    (*(key as *mut Allocated)).value = value;\n+}\n+\n+#[inline]\n+pub unsafe fn get(key: Key) -> *mut u8 {\n+    (*(key as *mut Allocated)).value\n+}\n+\n+#[inline]\n+pub unsafe fn destroy(key: Key) {\n+    let key = Box::from_raw(key as *mut Allocated);\n+    if let Some(f) = key.dtor {\n+        f(key.value);\n+    }\n+}\n+\n+#[inline]\n+pub fn requires_synchronized_create() -> bool {\n+    false\n+}"}, {"sha": "894680b0b65dd403c96d755043364c6906ed3aa8", "filename": "src/libstd/sys/sgx/time.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use time::Duration;\n+use sys::unsupported_err;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub struct Instant(Duration);\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub struct SystemTime(Duration);\n+\n+pub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));\n+\n+impl Instant {\n+    pub fn now() -> Instant {\n+        panic!(\"{}\", unsupported_err());\n+    }\n+\n+    pub fn sub_instant(&self, other: &Instant) -> Duration {\n+        self.0 - other.0\n+    }\n+\n+    pub fn add_duration(&self, other: &Duration) -> Instant {\n+        Instant(self.0 + *other)\n+    }\n+\n+    pub fn sub_duration(&self, other: &Duration) -> Instant {\n+        Instant(self.0 - *other)\n+    }\n+}\n+\n+impl SystemTime {\n+    pub fn now() -> SystemTime {\n+        panic!(\"{}\", unsupported_err());\n+    }\n+\n+    pub fn sub_time(&self, other: &SystemTime)\n+                    -> Result<Duration, Duration> {\n+        self.0.checked_sub(other.0).ok_or_else(|| other.0 - self.0)\n+    }\n+\n+    pub fn add_duration(&self, other: &Duration) -> SystemTime {\n+        SystemTime(self.0 + *other)\n+    }\n+\n+    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n+        self.0.checked_add(*other).map(|d| SystemTime(d))\n+    }\n+\n+    pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n+        SystemTime(self.0 - *other)\n+    }\n+}"}, {"sha": "881794d9f16da4b7ada8f45bddab490fda957f4e", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -57,9 +57,11 @@ pub mod bytestring;\n pub mod process;\n \n cfg_if! {\n-    if #[cfg(any(target_os = \"cloudabi\", target_os = \"l4re\", target_os = \"redox\"))] {\n-        pub use sys::net;\n-    } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {\n+    if #[cfg(any(target_os = \"cloudabi\",\n+                 target_os = \"l4re\",\n+                 target_os = \"redox\",\n+                 all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+                 target_env = \"sgx\"))] {\n         pub use sys::net;\n     } else {\n         pub mod net;"}, {"sha": "b8711a691477bccd63467fadca5f3c237a118efd", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -1018,10 +1018,12 @@ fn use_color(opts: &TestOpts) -> bool {\n     }\n }\n \n-#[cfg(any(target_os = \"cloudabi\", target_os = \"redox\",\n-          all(target_arch = \"wasm32\", not(target_os = \"emscripten\"))))]\n+#[cfg(any(target_os = \"cloudabi\",\n+          target_os = \"redox\",\n+          all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+          target_env = \"sgx\"))]\n fn stdout_isatty() -> bool {\n-    // FIXME: Implement isatty on Redox\n+    // FIXME: Implement isatty on Redox and SGX\n     false\n }\n #[cfg(unix)]\n@@ -1246,7 +1248,7 @@ fn get_concurrency() -> usize {\n         1\n     }\n \n-    #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n+    #[cfg(any(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")), target_env = \"sgx\"))]\n     fn num_cpus() -> usize {\n         1\n     }"}, {"sha": "eb53332ab3302f7c394d52e86b7d9ddfc3f037d6", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -26,7 +26,10 @@ mod macros;\n cfg_if! {\n     if #[cfg(target_env = \"msvc\")] {\n         // no extra unwinder support needed\n-    } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {\n+    } else if #[cfg(any(\n+        all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+        target_env = \"sgx\"\n+    ))] {\n         // no unwinder on the system!\n     } else {\n         extern crate libc;"}, {"sha": "9656260888095f44830641ca7bb3da609a793451", "filename": "src/rust-sgx", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frust-sgx?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1 @@\n+Subproject commit 9656260888095f44830641ca7bb3da609a793451"}, {"sha": "fd81d3db3a79b0a84730e9c0d327de9aa4ed6acf", "filename": "src/rustc/fortanix-sgx-abi_shim/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Frustc%2Ffortanix-sgx-abi_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Frustc%2Ffortanix-sgx-abi_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffortanix-sgx-abi_shim%2FCargo.toml?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"fortanix-sgx-abi\"\n+version = \"0.0.0\"\n+authors = [\"The Rust Project Developers\"]\n+\n+[lib]\n+path = \"../../rust-sgx/fortanix-sgx-abi/src/lib.rs\"\n+test = false\n+bench = false\n+doc = false\n+\n+[dependencies]\n+core = { path = \"../../libcore\" }\n+compiler_builtins = { path = \"../../rustc/compiler_builtins_shim\" }"}, {"sha": "5e628c5120c619a22799187371f057ec41e06f87", "filename": "src/stdsimd", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstdsimd?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -1 +1 @@\n-Subproject commit 0309be1ade6bf61066f2c69f77ac3567b7dc31b5\n+Subproject commit 5e628c5120c619a22799187371f057ec41e06f87"}, {"sha": "53db589beaf46cd24f9a9181914130aa3159fa4b", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3505682e97c8e667338056ae216e4b84b22dd7/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=4a3505682e97c8e667338056ae216e4b84b22dd7", "patch": "@@ -76,6 +76,7 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/tools/lldb\",\n         \"src/target\",\n         \"src/stdsimd\",\n+        \"src/rust-sgx\",\n         \"target\",\n         \"vendor\",\n     ];"}]}