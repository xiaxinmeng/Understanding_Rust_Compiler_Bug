{"sha": "9a716dafbe3deb97091c5e511c2d893e1f325b07", "node_id": "C_kwDOAAsO6NoAKDlhNzE2ZGFmYmUzZGViOTcwOTFjNWU1MTFjMmQ4OTNlMWYzMjViMDc", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-02-17T13:44:35Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-27T15:46:21Z"}, "message": "Add a `ConstParamTy` trait", "tree": {"sha": "54b22f959cd04e39669f17027ea2505e9ae128e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54b22f959cd04e39669f17027ea2505e9ae128e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a716dafbe3deb97091c5e511c2d893e1f325b07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a716dafbe3deb97091c5e511c2d893e1f325b07", "html_url": "https://github.com/rust-lang/rust/commit/9a716dafbe3deb97091c5e511c2d893e1f325b07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a716dafbe3deb97091c5e511c2d893e1f325b07/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "518d348f873ac5df4ca43b36145e5556138adad3", "url": "https://api.github.com/repos/rust-lang/rust/commits/518d348f873ac5df4ca43b36145e5556138adad3", "html_url": "https://github.com/rust-lang/rust/commit/518d348f873ac5df4ca43b36145e5556138adad3"}], "stats": {"total": 422, "additions": 300, "deletions": 122}, "files": [{"sha": "e1c030d3e198aff55f85cac0344993abcd81abca", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a716dafbe3deb97091c5e511c2d893e1f325b07/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a716dafbe3deb97091c5e511c2d893e1f325b07/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=9a716dafbe3deb97091c5e511c2d893e1f325b07", "patch": "@@ -293,6 +293,8 @@ language_item_table! {\n \n     PointerLike,             sym::pointer_like,        pointer_like,               Target::Trait,          GenericRequirement::Exact(0);\n \n+    ConstParamTy,            sym::const_param_ty,      const_param_ty_trait,       Target::Trait,          GenericRequirement::Exact(0);\n+\n     Poll,                    sym::Poll,                poll,                       Target::Enum,           GenericRequirement::None;\n     PollReady,               sym::Ready,               poll_ready_variant,         Target::Variant,        GenericRequirement::None;\n     PollPending,             sym::Pending,             poll_pending_variant,       Target::Variant,        GenericRequirement::None;"}, {"sha": "bda9879b5db1af0f312f8ddc76ac82e865f65554", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a716dafbe3deb97091c5e511c2d893e1f325b07/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9a716dafbe3deb97091c5e511c2d893e1f325b07/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=9a716dafbe3deb97091c5e511c2d893e1f325b07", "patch": "@@ -35,6 +35,10 @@ hir_analysis_field_already_declared =\n \n hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n \n+hir_analysis_const_param_ty_impl_on_non_adt =\n+    the trait `ConstParamTy` may not be implemented for this type\n+    .label = type is not a structure or enumeration\n+\n hir_analysis_ambiguous_lifetime_bound =\n     ambiguous lifetime bound, explicit lifetime bound required\n "}, {"sha": "0f450ae67b7a636579818d77ba6ba5f7f7f8c9ff", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 148, "deletions": 107, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/9a716dafbe3deb97091c5e511c2d893e1f325b07/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a716dafbe3deb97091c5e511c2d893e1f325b07/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=9a716dafbe3deb97091c5e511c2d893e1f325b07", "patch": "@@ -1,9 +1,11 @@\n //! Check properties that are required by built-in traits and set\n //! up data structures required by type-checking/codegen.\n \n-use crate::errors::{CopyImplOnNonAdt, CopyImplOnTypeWithDtor, DropImplOnWrongItem};\n+use crate::errors::{\n+    ConstParamTyImplOnNonAdt, CopyImplOnNonAdt, CopyImplOnTypeWithDtor, DropImplOnWrongItem,\n+};\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{struct_span_err, MultiSpan};\n+use rustc_errors::{struct_span_err, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n@@ -14,9 +16,11 @@ use rustc_infer::infer::{DefineOpaqueTypes, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n use rustc_middle::ty::adjustment::CoerceUnsizedInfo;\n use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::misc::{\n-    type_allowed_to_implement_copy, CopyImplementationError, InfringingFieldsReason,\n+    type_allowed_to_implement_const_param_ty, type_allowed_to_implement_copy,\n+    ConstParamTyImplementationError, CopyImplementationError, InfringingFieldsReason,\n };\n use rustc_trait_selection::traits::ObligationCtxt;\n use rustc_trait_selection::traits::{self, ObligationCause};\n@@ -27,6 +31,7 @@ pub fn check_trait(tcx: TyCtxt<'_>, trait_def_id: DefId) {\n     Checker { tcx, trait_def_id }\n         .check(lang_items.drop_trait(), visit_implementation_of_drop)\n         .check(lang_items.copy_trait(), visit_implementation_of_copy)\n+        .check(lang_items.const_param_ty_trait(), visit_implementation_of_const_param_ty)\n         .check(lang_items.coerce_unsized_trait(), visit_implementation_of_coerce_unsized)\n         .check(lang_items.dispatch_from_dyn_trait(), visit_implementation_of_dispatch_from_dyn);\n }\n@@ -83,110 +88,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     match type_allowed_to_implement_copy(tcx, param_env, self_type, cause) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfringingFields(fields)) => {\n-            let mut err = struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0204,\n-                \"the trait `Copy` cannot be implemented for this type\"\n-            );\n-\n-            // We'll try to suggest constraining type parameters to fulfill the requirements of\n-            // their `Copy` implementation.\n-            let mut errors: BTreeMap<_, Vec<_>> = Default::default();\n-            let mut bounds = vec![];\n-\n-            let mut seen_tys = FxHashSet::default();\n-\n-            for (field, ty, reason) in fields {\n-                // Only report an error once per type.\n-                if !seen_tys.insert(ty) {\n-                    continue;\n-                }\n-\n-                let field_span = tcx.def_span(field.did);\n-                err.span_label(field_span, \"this field does not implement `Copy`\");\n-\n-                match reason {\n-                    InfringingFieldsReason::Fulfill(fulfillment_errors) => {\n-                        for error in fulfillment_errors {\n-                            let error_predicate = error.obligation.predicate;\n-                            // Only note if it's not the root obligation, otherwise it's trivial and\n-                            // should be self-explanatory (i.e. a field literally doesn't implement Copy).\n-\n-                            // FIXME: This error could be more descriptive, especially if the error_predicate\n-                            // contains a foreign type or if it's a deeply nested type...\n-                            if error_predicate != error.root_obligation.predicate {\n-                                errors\n-                                    .entry((ty.to_string(), error_predicate.to_string()))\n-                                    .or_default()\n-                                    .push(error.obligation.cause.span);\n-                            }\n-                            if let ty::PredicateKind::Clause(ty::Clause::Trait(\n-                                ty::TraitPredicate {\n-                                    trait_ref,\n-                                    polarity: ty::ImplPolarity::Positive,\n-                                    ..\n-                                },\n-                            )) = error_predicate.kind().skip_binder()\n-                            {\n-                                let ty = trait_ref.self_ty();\n-                                if let ty::Param(_) = ty.kind() {\n-                                    bounds.push((\n-                                        format!(\"{ty}\"),\n-                                        trait_ref.print_only_trait_path().to_string(),\n-                                        Some(trait_ref.def_id),\n-                                    ));\n-                                }\n-                            }\n-                        }\n-                    }\n-                    InfringingFieldsReason::Regions(region_errors) => {\n-                        for error in region_errors {\n-                            let ty = ty.to_string();\n-                            match error {\n-                                RegionResolutionError::ConcreteFailure(origin, a, b) => {\n-                                    let predicate = format!(\"{b}: {a}\");\n-                                    errors\n-                                        .entry((ty.clone(), predicate.clone()))\n-                                        .or_default()\n-                                        .push(origin.span());\n-                                    if let ty::RegionKind::ReEarlyBound(ebr) = *b && ebr.has_name() {\n-                                        bounds.push((b.to_string(), a.to_string(), None));\n-                                    }\n-                                }\n-                                RegionResolutionError::GenericBoundFailure(origin, a, b) => {\n-                                    let predicate = format!(\"{a}: {b}\");\n-                                    errors\n-                                        .entry((ty.clone(), predicate.clone()))\n-                                        .or_default()\n-                                        .push(origin.span());\n-                                    if let infer::region_constraints::GenericKind::Param(_) = a {\n-                                        bounds.push((a.to_string(), b.to_string(), None));\n-                                    }\n-                                }\n-                                _ => continue,\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            for ((ty, error_predicate), spans) in errors {\n-                let span: MultiSpan = spans.into();\n-                err.span_note(\n-                    span,\n-                    &format!(\"the `Copy` impl for `{}` requires that `{}`\", ty, error_predicate),\n-                );\n-            }\n-            suggest_constraining_type_params(\n-                tcx,\n-                tcx.hir().get_generics(impl_did).expect(\"impls always have generics\"),\n-                &mut err,\n-                bounds.iter().map(|(param, constraint, def_id)| {\n-                    (param.as_str(), constraint.as_str(), *def_id)\n-                }),\n-                None,\n-            );\n-            err.emit();\n+            infringing_fields_error(tcx, fields, LangItem::Copy, impl_did, span);\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n             tcx.sess.emit_err(CopyImplOnNonAdt { span });\n@@ -197,6 +99,29 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     }\n }\n \n+fn visit_implementation_of_const_param_ty(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n+    let self_type = tcx.type_of(impl_did).subst_identity();\n+    assert!(!self_type.has_escaping_bound_vars());\n+\n+    let param_env = tcx.param_env(impl_did);\n+\n+    let span = match tcx.hir().expect_item(impl_did).expect_impl() {\n+        hir::Impl { polarity: hir::ImplPolarity::Negative(_), .. } => return,\n+        impl_ => impl_.self_ty.span,\n+    };\n+\n+    let cause = traits::ObligationCause::misc(span, impl_did);\n+    match type_allowed_to_implement_const_param_ty(tcx, param_env, self_type, cause) {\n+        Ok(()) => {}\n+        Err(ConstParamTyImplementationError::InfrigingFields(fields)) => {\n+            infringing_fields_error(tcx, fields, LangItem::ConstParamTy, impl_did, span);\n+        }\n+        Err(ConstParamTyImplementationError::NotAnAdtOrBuiltinAllowed) => {\n+            tcx.sess.emit_err(ConstParamTyImplOnNonAdt { span });\n+        }\n+    }\n+}\n+\n fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_coerce_unsized: impl_did={:?}\", impl_did);\n \n@@ -593,3 +518,119 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: LocalDefId) -> Coe\n \n     CoerceUnsizedInfo { custom_kind: kind }\n }\n+\n+fn infringing_fields_error(\n+    tcx: TyCtxt<'_>,\n+    fields: Vec<(&ty::FieldDef, Ty<'_>, InfringingFieldsReason<'_>)>,\n+    lang_item: LangItem,\n+    impl_did: LocalDefId,\n+    impl_span: Span,\n+) -> ErrorGuaranteed {\n+    let trait_did = tcx.require_lang_item(lang_item, Some(impl_span));\n+\n+    let trait_name = tcx.def_path_str(trait_did);\n+\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        impl_span,\n+        E0204,\n+        \"the trait `{trait_name}` cannot be implemented for this type\"\n+    );\n+\n+    // We'll try to suggest constraining type parameters to fulfill the requirements of\n+    // their `Copy` implementation.\n+    let mut errors: BTreeMap<_, Vec<_>> = Default::default();\n+    let mut bounds = vec![];\n+\n+    let mut seen_tys = FxHashSet::default();\n+\n+    for (field, ty, reason) in fields {\n+        // Only report an error once per type.\n+        if !seen_tys.insert(ty) {\n+            continue;\n+        }\n+\n+        let field_span = tcx.def_span(field.did);\n+        err.span_label(field_span, format!(\"this field does not implement `{trait_name}`\"));\n+\n+        match reason {\n+            InfringingFieldsReason::Fulfill(fulfillment_errors) => {\n+                for error in fulfillment_errors {\n+                    let error_predicate = error.obligation.predicate;\n+                    // Only note if it's not the root obligation, otherwise it's trivial and\n+                    // should be self-explanatory (i.e. a field literally doesn't implement Copy).\n+\n+                    // FIXME: This error could be more descriptive, especially if the error_predicate\n+                    // contains a foreign type or if it's a deeply nested type...\n+                    if error_predicate != error.root_obligation.predicate {\n+                        errors\n+                            .entry((ty.to_string(), error_predicate.to_string()))\n+                            .or_default()\n+                            .push(error.obligation.cause.span);\n+                    }\n+                    if let ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n+                        trait_ref,\n+                        polarity: ty::ImplPolarity::Positive,\n+                        ..\n+                    })) = error_predicate.kind().skip_binder()\n+                    {\n+                        let ty = trait_ref.self_ty();\n+                        if let ty::Param(_) = ty.kind() {\n+                            bounds.push((\n+                                format!(\"{ty}\"),\n+                                trait_ref.print_only_trait_path().to_string(),\n+                                Some(trait_ref.def_id),\n+                            ));\n+                        }\n+                    }\n+                }\n+            }\n+            InfringingFieldsReason::Regions(region_errors) => {\n+                for error in region_errors {\n+                    let ty = ty.to_string();\n+                    match error {\n+                        RegionResolutionError::ConcreteFailure(origin, a, b) => {\n+                            let predicate = format!(\"{b}: {a}\");\n+                            errors\n+                                .entry((ty.clone(), predicate.clone()))\n+                                .or_default()\n+                                .push(origin.span());\n+                            if let ty::RegionKind::ReEarlyBound(ebr) = *b && ebr.has_name() {\n+                                        bounds.push((b.to_string(), a.to_string(), None));\n+                                    }\n+                        }\n+                        RegionResolutionError::GenericBoundFailure(origin, a, b) => {\n+                            let predicate = format!(\"{a}: {b}\");\n+                            errors\n+                                .entry((ty.clone(), predicate.clone()))\n+                                .or_default()\n+                                .push(origin.span());\n+                            if let infer::region_constraints::GenericKind::Param(_) = a {\n+                                bounds.push((a.to_string(), b.to_string(), None));\n+                            }\n+                        }\n+                        _ => continue,\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    for ((ty, error_predicate), spans) in errors {\n+        let span: MultiSpan = spans.into();\n+        err.span_note(\n+            span,\n+            format!(\"the `{trait_name}` impl for `{ty}` requires that `{error_predicate}`\"),\n+        );\n+    }\n+    suggest_constraining_type_params(\n+        tcx,\n+        tcx.hir().get_generics(impl_did).expect(\"impls always have generics\"),\n+        &mut err,\n+        bounds\n+            .iter()\n+            .map(|(param, constraint, def_id)| (param.as_str(), constraint.as_str(), *def_id)),\n+        None,\n+    );\n+\n+    err.emit()\n+}"}, {"sha": "8dcf3b1670dc9eb0565bab927cefa87fdcc81a32", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a716dafbe3deb97091c5e511c2d893e1f325b07/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a716dafbe3deb97091c5e511c2d893e1f325b07/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=9a716dafbe3deb97091c5e511c2d893e1f325b07", "patch": "@@ -107,6 +107,14 @@ pub struct CopyImplOnNonAdt {\n     pub span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_const_param_ty_impl_on_non_adt)]\n+pub struct ConstParamTyImplOnNonAdt {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(hir_analysis_trait_object_declared_with_no_traits, code = \"E0224\")]\n pub struct TraitObjectDeclaredWithNoTraits {"}, {"sha": "d2e23f845144f5eec0482d148836ec7f5b20ceff", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a716dafbe3deb97091c5e511c2d893e1f325b07/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a716dafbe3deb97091c5e511c2d893e1f325b07/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9a716dafbe3deb97091c5e511c2d893e1f325b07", "patch": "@@ -531,6 +531,7 @@ symbols! {\n         const_mut_refs,\n         const_panic,\n         const_panic_fmt,\n+        const_param_ty,\n         const_precise_live_drops,\n         const_raw_ptr_deref,\n         const_raw_ptr_to_usize_cast,"}, {"sha": "3c43758e50daad1c9e75ee61ac27025c5ac62dc8", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 79, "deletions": 15, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9a716dafbe3deb97091c5e511c2d893e1f325b07/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a716dafbe3deb97091c5e511c2d893e1f325b07/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=9a716dafbe3deb97091c5e511c2d893e1f325b07", "patch": "@@ -2,13 +2,14 @@\n \n use crate::traits::{self, ObligationCause, ObligationCtxt};\n \n+use hir::LangItem;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::infer::{RegionResolutionError, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::{infer::outlives::env::OutlivesEnvironment, traits::FulfillmentError};\n-use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_middle::ty::{self, AdtDef, GenericArg, List, ParamEnv, Ty, TyCtxt, TypeVisitableExt};\n use rustc_span::DUMMY_SP;\n \n use super::outlives_bounds::InferCtxtExt;\n@@ -19,6 +20,11 @@ pub enum CopyImplementationError<'tcx> {\n     HasDestructor,\n }\n \n+pub enum ConstParamTyImplementationError<'tcx> {\n+    InfrigingFields(Vec<(&'tcx ty::FieldDef, Ty<'tcx>, InfringingFieldsReason<'tcx>)>),\n+    NotAnAdtOrBuiltinAllowed,\n+}\n+\n pub enum InfringingFieldsReason<'tcx> {\n     Fulfill(Vec<FulfillmentError<'tcx>>),\n     Regions(Vec<RegionResolutionError<'tcx>>),\n@@ -27,7 +33,10 @@ pub enum InfringingFieldsReason<'tcx> {\n /// Checks that the fields of the type (an ADT) all implement copy.\n ///\n /// If fields don't implement copy, return an error containing a list of\n-/// those violating fields. If it's not an ADT, returns `Err(NotAnAdt)`.\n+/// those violating fields.\n+///\n+/// If it's not an ADT, int ty, `bool`, float ty, `char`, raw pointer, `!`,\n+/// a reference or an array returns `Err(NotAnAdt)`.\n pub fn type_allowed_to_implement_copy<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -47,12 +56,75 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n         | ty::Ref(_, _, hir::Mutability::Not)\n         | ty::Array(..) => return Ok(()),\n \n-        ty::Adt(adt, substs) => (adt, substs),\n+        &ty::Adt(adt, substs) => (adt, substs),\n \n         _ => return Err(CopyImplementationError::NotAnAdt),\n     };\n \n-    let copy_def_id = tcx.require_lang_item(hir::LangItem::Copy, Some(parent_cause.span));\n+    all_fields_implement_trait(\n+        tcx,\n+        param_env,\n+        self_type,\n+        adt,\n+        substs,\n+        parent_cause,\n+        hir::LangItem::Copy,\n+    )\n+    .map_err(CopyImplementationError::InfringingFields)?;\n+\n+    if adt.has_dtor(tcx) {\n+        return Err(CopyImplementationError::HasDestructor);\n+    }\n+\n+    Ok(())\n+}\n+\n+/// Checks that the fields of the type (an ADT) all implement `ConstParamTy`.\n+///\n+/// If fields don't implement `ConstParamTy`, return an error containing a list of\n+/// those violating fields.\n+///\n+/// If it's not an ADT, int ty, `bool` or `char`, returns `Err(NotAnAdtOrBuiltinAllowed)`.\n+pub fn type_allowed_to_implement_const_param_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    self_type: Ty<'tcx>,\n+    parent_cause: ObligationCause<'tcx>,\n+) -> Result<(), ConstParamTyImplementationError<'tcx>> {\n+    let (adt, substs) = match self_type.kind() {\n+        // `core` provides these impls.\n+        ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Char => return Ok(()),\n+\n+        &ty::Adt(adt, substs) => (adt, substs),\n+\n+        _ => return Err(ConstParamTyImplementationError::NotAnAdtOrBuiltinAllowed),\n+    };\n+\n+    all_fields_implement_trait(\n+        tcx,\n+        param_env,\n+        self_type,\n+        adt,\n+        substs,\n+        parent_cause,\n+        hir::LangItem::Copy,\n+    )\n+    .map_err(ConstParamTyImplementationError::InfrigingFields)?;\n+\n+    Ok(())\n+}\n+\n+/// Check that all fields of a given `adt` implement `lang_item` trait.\n+pub fn all_fields_implement_trait<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    self_type: Ty<'tcx>,\n+    adt: AdtDef<'tcx>,\n+    substs: &'tcx List<GenericArg<'tcx>>,\n+    parent_cause: ObligationCause<'tcx>,\n+    lang_item: LangItem,\n+) -> Result<(), Vec<(&'tcx ty::FieldDef, Ty<'tcx>, InfringingFieldsReason<'tcx>)>> {\n+    let trait_def_id = tcx.require_lang_item(lang_item, Some(parent_cause.span));\n \n     let mut infringing = Vec::new();\n     for variant in adt.variants() {\n@@ -93,15 +165,15 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n             // between expected and found const-generic types. Don't report an\n             // additional copy error here, since it's not typically useful.\n             if !normalization_errors.is_empty() || ty.references_error() {\n-                tcx.sess.delay_span_bug(field_span, format!(\"couldn't normalize struct field `{unnormalized_ty}` when checking Copy implementation\"));\n+                tcx.sess.delay_span_bug(field_span, format!(\"couldn't normalize struct field `{unnormalized_ty}` when checking {tr} implementation\", tr = tcx.def_path_str(trait_def_id)));\n                 continue;\n             }\n \n             ocx.register_bound(\n                 ObligationCause::dummy_with_span(field_ty_span),\n                 param_env,\n                 ty,\n-                copy_def_id,\n+                trait_def_id,\n             );\n             let errors = ocx.select_all_or_error();\n             if !errors.is_empty() {\n@@ -124,15 +196,7 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n         }\n     }\n \n-    if !infringing.is_empty() {\n-        return Err(CopyImplementationError::InfringingFields(infringing));\n-    }\n-\n-    if adt.has_dtor(tcx) {\n-        return Err(CopyImplementationError::HasDestructor);\n-    }\n-\n-    Ok(())\n+    if infringing.is_empty() { Ok(()) } else { Err(infringing) }\n }\n \n pub fn check_tys_might_be_eq<'tcx>("}, {"sha": "ff8653c08204a9ce829e8491b1b876c66d8d8c59", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9a716dafbe3deb97091c5e511c2d893e1f325b07/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a716dafbe3deb97091c5e511c2d893e1f325b07/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=9a716dafbe3deb97091c5e511c2d893e1f325b07", "patch": "@@ -912,6 +912,40 @@ pub trait Tuple {}\n )]\n pub trait PointerLike {}\n \n+/// A marker for types which can be used as types of `const` generic parameters.\n+#[cfg_attr(not(bootstrap), lang = \"const_param_ty\")]\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+#[rustc_on_unimplemented(message = \"`{Self}` can't be used as a const parameter type\")]\n+pub trait ConstParamTy: StructuralEq {}\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+impl ConstParamTy for usize {}\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+impl ConstParamTy for u8 {}\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+impl ConstParamTy for u16 {}\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+impl ConstParamTy for u32 {}\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+impl ConstParamTy for u64 {}\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+impl ConstParamTy for u128 {}\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+impl ConstParamTy for isize {}\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+impl ConstParamTy for i8 {}\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+impl ConstParamTy for i16 {}\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+impl ConstParamTy for i32 {}\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+impl ConstParamTy for i64 {}\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+impl ConstParamTy for i128 {}\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+impl ConstParamTy for bool {}\n+#[unstable(feature = \"const_param_ty_trait\", issue = \"none\")]\n+impl ConstParamTy for char {}\n+\n /// Implementations of `Copy` for primitive types.\n ///\n /// Implementations that cannot be described in Rust"}, {"sha": "37cfa1aa7f5371e970e7f4c4b5a1dbc6fd90731f", "filename": "tests/ui/const-generics/const_patam_ty_impl_bad_field.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a716dafbe3deb97091c5e511c2d893e1f325b07/tests%2Fui%2Fconst-generics%2Fconst_patam_ty_impl_bad_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a716dafbe3deb97091c5e511c2d893e1f325b07/tests%2Fui%2Fconst-generics%2Fconst_patam_ty_impl_bad_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fconst_patam_ty_impl_bad_field.rs?ref=9a716dafbe3deb97091c5e511c2d893e1f325b07", "patch": "@@ -0,0 +1,12 @@\n+#![feature(const_param_ty_trait)]\n+\n+#[derive(PartialEq)]\n+struct NotParam;\n+\n+#[derive(PartialEq)]\n+struct CantParam(NotParam);\n+\n+impl std::marker::ConstParamTy for CantParam {}\n+//~^ error: the trait `ConstParamTy` may not be implemented for this type\n+\n+fn main() {}"}, {"sha": "dd150deffc2de5e2c2a0242c091fe03e8762642f", "filename": "tests/ui/const-generics/const_patam_ty_impl_bad_field.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a716dafbe3deb97091c5e511c2d893e1f325b07/tests%2Fui%2Fconst-generics%2Fconst_patam_ty_impl_bad_field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a716dafbe3deb97091c5e511c2d893e1f325b07/tests%2Fui%2Fconst-generics%2Fconst_patam_ty_impl_bad_field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fconst_patam_ty_impl_bad_field.stderr?ref=9a716dafbe3deb97091c5e511c2d893e1f325b07", "patch": "@@ -0,0 +1,12 @@\n+error[E0204]: the trait `ConstParamTy` may not be implemented for this type\n+  --> $DIR/const_patam_ty_impl_bad_field.rs:9:36\n+   |\n+LL | struct CantParam(NotParam);\n+   |                  -------- this field does not implement `ConstParamTy`\n+LL |\n+LL | impl std::marker::ConstParamTy for CantParam {}\n+   |                                    ^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0204`."}]}