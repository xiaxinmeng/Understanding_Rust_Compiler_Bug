{"sha": "d6223253b628b279f9ddae8f83f7173d01f6b32c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MjIzMjUzYjYyOGIyNzlmOWRkYWU4ZjgzZjcxNzNkMDFmNmIzMmM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-14T18:16:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-14T18:16:48Z"}, "message": "Merge #2561\n\n2561: Split generic and non-generic paths r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "12f2ccc5c52c1c0b67932d3a35fe18668b8e5d62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12f2ccc5c52c1c0b67932d3a35fe18668b8e5d62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6223253b628b279f9ddae8f83f7173d01f6b32c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd9ScQCRBK7hj4Ov3rIwAAdHIIAIm48AdD0Q4rXXqstQQVyZfl\nDtxY2M0MKHWYuoqf2CMLRwOVmJS/3yxfxSWG5X8lGjSb8L7CwMbEzbUACBteGOmb\nbbW00AEvKCUR1HWJjOIi86b2P6+lj/MTmBSKBr1NezaK4+a0sLZ2Ace4/thGqdPu\nsuwbBFtdpHw8jjKr2MJE8KEEu9qXfMGnpxycXzoC4U/vDfM8JwdXqRE+FKHGtdQ4\nKxCAMUPtJDqlWdFuu+R5MXYa4cKM7HhK8NXqRZsZ2DINSJGfUynVYYbtGbS7jwHN\nEp6eoOY+MzO/vwCi1T5YwhPmc0/eqcy2d2U+V67Ocy4gHJUFrQzizgdDF3ykx88=\n=UNc9\n-----END PGP SIGNATURE-----\n", "payload": "tree 12f2ccc5c52c1c0b67932d3a35fe18668b8e5d62\nparent 202ad1e2d9376565cb273cf085be600ed10e5a93\nparent 2619950b3b405324ab1c1745876165c834b3b4b9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1576347408 +0000\ncommitter GitHub <noreply@github.com> 1576347408 +0000\n\nMerge #2561\n\n2561: Split generic and non-generic paths r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6223253b628b279f9ddae8f83f7173d01f6b32c", "html_url": "https://github.com/rust-lang/rust/commit/d6223253b628b279f9ddae8f83f7173d01f6b32c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6223253b628b279f9ddae8f83f7173d01f6b32c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "202ad1e2d9376565cb273cf085be600ed10e5a93", "url": "https://api.github.com/repos/rust-lang/rust/commits/202ad1e2d9376565cb273cf085be600ed10e5a93", "html_url": "https://github.com/rust-lang/rust/commit/202ad1e2d9376565cb273cf085be600ed10e5a93"}, {"sha": "2619950b3b405324ab1c1745876165c834b3b4b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2619950b3b405324ab1c1745876165c834b3b4b9", "html_url": "https://github.com/rust-lang/rust/commit/2619950b3b405324ab1c1745876165c834b3b4b9"}], "stats": {"total": 833, "additions": 478, "deletions": 355}, "files": [{"sha": "f81b4184a06b426f89f4abc8301fee6d84b0e7dc", "filename": "crates/ra_assists/src/assists/add_import.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_import.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -578,17 +578,15 @@ fn apply_auto_import(\n \n fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n     let mut ps = Vec::<SmolStr>::with_capacity(10);\n-    match path.kind {\n+    match path.kind() {\n         hir::PathKind::Abs => ps.push(\"\".into()),\n         hir::PathKind::Crate => ps.push(\"crate\".into()),\n         hir::PathKind::Plain => {}\n         hir::PathKind::Self_ => ps.push(\"self\".into()),\n         hir::PathKind::Super => ps.push(\"super\".into()),\n         hir::PathKind::Type(_) | hir::PathKind::DollarCrate(_) => return None,\n     }\n-    for s in path.segments.iter() {\n-        ps.push(s.name.to_string().into());\n-    }\n+    ps.extend(path.segments().iter().map(|it| it.name.to_string().into()));\n     Some(ps)\n }\n "}, {"sha": "451b227a6ee458ea0b343524405a5185c1ee4d80", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -54,7 +54,7 @@ pub use hir_def::{\n     builtin_type::BuiltinType,\n     docs::Documentation,\n     nameres::ModuleSource,\n-    path::{Path, PathKind},\n+    path::{ModPath, Path, PathKind},\n     type_ref::Mutability,\n };\n pub use hir_expand::{"}, {"sha": "d326169b33557bfb588e08460c765e2d3d13e922", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -258,48 +258,50 @@ impl SourceAnalyzer {\n     ) -> Option<MacroDef> {\n         let hygiene = Hygiene::new(db, macro_call.file_id);\n         let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &hygiene))?;\n-        self.resolver.resolve_path_as_macro(db, &path).map(|it| it.into())\n+        self.resolver.resolve_path_as_macro(db, path.mod_path()).map(|it| it.into())\n     }\n \n     pub fn resolve_hir_path(\n         &self,\n         db: &impl HirDatabase,\n         path: &crate::Path,\n     ) -> Option<PathResolution> {\n-        let types = self.resolver.resolve_path_in_type_ns_fully(db, &path).map(|ty| match ty {\n-            TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n-            TypeNs::GenericParam(id) => PathResolution::TypeParam(TypeParam { id }),\n-            TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => {\n-                PathResolution::Def(Adt::from(it).into())\n-            }\n-            TypeNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n-            TypeNs::TypeAliasId(it) => PathResolution::Def(TypeAlias::from(it).into()),\n-            TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n-            TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n-        });\n-        let values = self.resolver.resolve_path_in_value_ns_fully(db, &path).and_then(|val| {\n-            let res = match val {\n-                ValueNs::LocalBinding(pat_id) => {\n-                    let var = Local { parent: self.body_owner?, pat_id };\n-                    PathResolution::Local(var)\n+        let types =\n+            self.resolver.resolve_path_in_type_ns_fully(db, path.mod_path()).map(|ty| match ty {\n+                TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n+                TypeNs::GenericParam(id) => PathResolution::TypeParam(TypeParam { id }),\n+                TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => {\n+                    PathResolution::Def(Adt::from(it).into())\n                 }\n-                ValueNs::FunctionId(it) => PathResolution::Def(Function::from(it).into()),\n-                ValueNs::ConstId(it) => PathResolution::Def(Const::from(it).into()),\n-                ValueNs::StaticId(it) => PathResolution::Def(Static::from(it).into()),\n-                ValueNs::StructId(it) => PathResolution::Def(Struct::from(it).into()),\n-                ValueNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n-            };\n-            Some(res)\n-        });\n+                TypeNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n+                TypeNs::TypeAliasId(it) => PathResolution::Def(TypeAlias::from(it).into()),\n+                TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n+                TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n+            });\n+        let values =\n+            self.resolver.resolve_path_in_value_ns_fully(db, path.mod_path()).and_then(|val| {\n+                let res = match val {\n+                    ValueNs::LocalBinding(pat_id) => {\n+                        let var = Local { parent: self.body_owner?, pat_id };\n+                        PathResolution::Local(var)\n+                    }\n+                    ValueNs::FunctionId(it) => PathResolution::Def(Function::from(it).into()),\n+                    ValueNs::ConstId(it) => PathResolution::Def(Const::from(it).into()),\n+                    ValueNs::StaticId(it) => PathResolution::Def(Static::from(it).into()),\n+                    ValueNs::StructId(it) => PathResolution::Def(Struct::from(it).into()),\n+                    ValueNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n+                };\n+                Some(res)\n+            });\n \n         let items = self\n             .resolver\n-            .resolve_module_path_in_items(db, &path)\n+            .resolve_module_path_in_items(db, path.mod_path())\n             .take_types()\n             .map(|it| PathResolution::Def(it.into()));\n         types.or(values).or(items).or_else(|| {\n             self.resolver\n-                .resolve_path_as_macro(db, &path)\n+                .resolve_path_as_macro(db, path.mod_path())\n                 .map(|def| PathResolution::Macro(def.into()))\n         })\n     }"}, {"sha": "9efa4970c11c66984f2bed149fa026ba129532b0", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -12,7 +12,7 @@ use ra_syntax::{\n use tt::Subtree;\n \n use crate::{\n-    db::DefDatabase, path::Path, src::HasChildSource, src::HasSource, AdtId, AttrDefId, Lookup,\n+    db::DefDatabase, path::ModPath, src::HasChildSource, src::HasSource, AdtId, AttrDefId, Lookup,\n };\n \n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n@@ -94,7 +94,7 @@ impl Attrs {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Attr {\n-    pub(crate) path: Path,\n+    pub(crate) path: ModPath,\n     pub(crate) input: Option<AttrInput>,\n }\n \n@@ -106,7 +106,7 @@ pub enum AttrInput {\n \n impl Attr {\n     fn from_src(ast: ast::Attr, hygiene: &Hygiene) -> Option<Attr> {\n-        let path = Path::from_src(ast.path()?, hygiene)?;\n+        let path = ModPath::from_src(ast.path()?, hygiene)?;\n         let input = match ast.input() {\n             None => None,\n             Some(ast::AttrInput::Literal(lit)) => {"}, {"sha": "7787cb87ffe17f159a3f9ed01919b647fc23563c", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -83,7 +83,7 @@ impl Expander {\n \n     fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &Path) -> Option<MacroDefId> {\n         self.crate_def_map\n-            .resolve_path(db, self.module.local_id, path, BuiltinShadowMode::Other)\n+            .resolve_path(db, self.module.local_id, path.mod_path(), BuiltinShadowMode::Other)\n             .0\n             .take_macros()\n     }"}, {"sha": "9aae7e48e2299fdb8637c489593d3e49cfc9479e", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -74,7 +74,7 @@ use crate::{\n     builtin_type::BuiltinType,\n     db::DefDatabase,\n     nameres::{diagnostics::DefDiagnostic, path_resolution::ResolveMode},\n-    path::Path,\n+    path::ModPath,\n     per_ns::PerNs,\n     AstId, FunctionId, ImplId, LocalImportId, LocalModuleId, ModuleDefId, ModuleId, TraitId,\n };\n@@ -329,7 +329,7 @@ impl CrateDefMap {\n         &self,\n         db: &impl DefDatabase,\n         original_module: LocalModuleId,\n-        path: &Path,\n+        path: &ModPath,\n         shadow: BuiltinShadowMode,\n     ) -> (PerNs, Option<usize>) {\n         let res ="}, {"sha": "912a073eac2dcff19b950037318981c7f4fdc582", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -22,7 +22,7 @@ use crate::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n         raw, BuiltinShadowMode, CrateDefMap, ModuleData, ModuleOrigin, Resolution, ResolveMode,\n     },\n-    path::{Path, PathKind},\n+    path::{ModPath, PathKind},\n     per_ns::PerNs,\n     AdtId, AstId, ConstLoc, ContainerId, EnumLoc, EnumVariantId, FunctionLoc, ImplLoc, Intern,\n     LocalImportId, LocalModuleId, ModuleDefId, ModuleId, StaticLoc, StructLoc, TraitLoc,\n@@ -101,7 +101,7 @@ struct ImportDirective {\n struct MacroDirective {\n     module_id: LocalModuleId,\n     ast_id: AstId<ast::MacroCall>,\n-    path: Path,\n+    path: ModPath,\n     legacy: Option<MacroCallId>,\n }\n \n@@ -113,7 +113,7 @@ struct DefCollector<'a, DB> {\n     unresolved_imports: Vec<ImportDirective>,\n     resolved_imports: Vec<ImportDirective>,\n     unexpanded_macros: Vec<MacroDirective>,\n-    unexpanded_attribute_macros: Vec<(LocalModuleId, AstId<ast::ModuleItem>, Path)>,\n+    unexpanded_attribute_macros: Vec<(LocalModuleId, AstId<ast::ModuleItem>, ModPath)>,\n     mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n     cfg_options: &'a CfgOptions,\n }\n@@ -428,7 +428,7 @@ where\n         } else {\n             match import.path.segments.last() {\n                 Some(last_segment) => {\n-                    let name = import.alias.clone().unwrap_or_else(|| last_segment.name.clone());\n+                    let name = import.alias.clone().unwrap_or_else(|| last_segment.clone());\n                     log::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n \n                     // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n@@ -565,7 +565,7 @@ where\n         res\n     }\n \n-    fn resolve_attribute_macro(&self, path: &Path) -> Option<MacroDefId> {\n+    fn resolve_attribute_macro(&self, path: &ModPath) -> Option<MacroDefId> {\n         // FIXME this is currently super hacky, just enough to support the\n         // built-in derives\n         if let Some(name) = path.as_ident() {\n@@ -829,7 +829,7 @@ where\n                     tt::TokenTree::Leaf(tt::Leaf::Punct(_)) => continue, // , is ok\n                     _ => continue, // anything else would be an error (which we currently ignore)\n                 };\n-                let path = Path::from_tt_ident(ident);\n+                let path = ModPath::from_tt_ident(ident);\n \n                 let ast_id = AstId::new(self.file_id, def.kind.ast_id());\n                 self.def_collector.unexpanded_attribute_macros.push((self.module_id, ast_id, path));\n@@ -917,7 +917,7 @@ where\n     }\n }\n \n-fn is_macro_rules(path: &Path) -> bool {\n+fn is_macro_rules(path: &ModPath) -> bool {\n     path.as_ident() == Some(&name![macro_rules])\n }\n "}, {"sha": "4a249e7e727866d634e289a741a2a3338b11e049", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -17,7 +17,7 @@ use test_utils::tested_by;\n use crate::{\n     db::DefDatabase,\n     nameres::{BuiltinShadowMode, CrateDefMap},\n-    path::{Path, PathKind},\n+    path::{ModPath, PathKind},\n     per_ns::PerNs,\n     AdtId, CrateId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n };\n@@ -69,7 +69,7 @@ impl CrateDefMap {\n         db: &impl DefDatabase,\n         mode: ResolveMode,\n         original_module: LocalModuleId,\n-        path: &Path,\n+        path: &ModPath,\n         shadow: BuiltinShadowMode,\n     ) -> ResolvePathResult {\n         // if it is not the last segment, we prefer the module to the builtin\n@@ -113,15 +113,15 @@ impl CrateDefMap {\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n-                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name, prefer_module(idx))\n+                self.resolve_name_in_crate_root_or_extern_prelude(&segment, prefer_module(idx))\n             }\n             PathKind::Plain => {\n                 let (idx, segment) = match segments.next() {\n                     Some((idx, segment)) => (idx, segment),\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 log::debug!(\"resolving {:?} in module\", segment);\n-                self.resolve_name_in_module(db, original_module, &segment.name, prefer_module(idx))\n+                self.resolve_name_in_module(db, original_module, &segment, prefer_module(idx))\n             }\n             PathKind::Super => {\n                 if let Some(p) = self.modules[original_module].parent {\n@@ -137,7 +137,7 @@ impl CrateDefMap {\n                     Some((_, segment)) => segment,\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n-                if let Some(def) = self.extern_prelude.get(&segment.name) {\n+                if let Some(def) = self.extern_prelude.get(&segment) {\n                     log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n                     PerNs::types(*def)\n                 } else {\n@@ -168,8 +168,10 @@ impl CrateDefMap {\n             curr_per_ns = match curr {\n                 ModuleDefId::ModuleId(module) => {\n                     if module.krate != self.krate {\n-                        let path =\n-                            Path { segments: path.segments[i..].to_vec(), kind: PathKind::Self_ };\n+                        let path = ModPath {\n+                            segments: path.segments[i..].to_vec(),\n+                            kind: PathKind::Self_,\n+                        };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n                         let defp_map = db.crate_def_map(module.krate);\n                         let (def, s) = defp_map.resolve_path(db, module.local_id, &path, shadow);\n@@ -182,10 +184,10 @@ impl CrateDefMap {\n                     }\n \n                     // Since it is a qualified path here, it should not contains legacy macros\n-                    match self[module.local_id].scope.get(&segment.name, prefer_module(i)) {\n+                    match self[module.local_id].scope.get(&segment, prefer_module(i)) {\n                         Some(res) => res.def,\n                         _ => {\n-                            log::debug!(\"path segment {:?} not found\", segment.name);\n+                            log::debug!(\"path segment {:?} not found\", segment);\n                             return ResolvePathResult::empty(ReachedFixedPoint::No);\n                         }\n                     }\n@@ -194,7 +196,7 @@ impl CrateDefMap {\n                     // enum variant\n                     tested_by!(can_import_enum_variant);\n                     let enum_data = db.enum_data(e);\n-                    match enum_data.variant(&segment.name) {\n+                    match enum_data.variant(&segment) {\n                         Some(local_id) => {\n                             let variant = EnumVariantId { parent: e, local_id };\n                             PerNs::both(variant.into(), variant.into())\n@@ -214,7 +216,7 @@ impl CrateDefMap {\n                     // (`Struct::method`), or some other kind of associated item\n                     log::debug!(\n                         \"path segment {:?} resolved to non-module {:?}, but is not last\",\n-                        segment.name,\n+                        segment,\n                         curr,\n                     );\n "}, {"sha": "ecb4d7c03d65a3cddf803959a2273157c73cb563", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -22,7 +22,7 @@ use ra_syntax::{\n use test_utils::tested_by;\n \n use crate::{\n-    attr::Attrs, db::DefDatabase, path::Path, trace::Trace, FileAstId, HirFileId, InFile,\n+    attr::Attrs, db::DefDatabase, path::ModPath, trace::Trace, FileAstId, HirFileId, InFile,\n     LocalImportId,\n };\n \n@@ -154,7 +154,7 @@ pub(super) enum ModuleData {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImportData {\n-    pub(super) path: Path,\n+    pub(super) path: ModPath,\n     pub(super) alias: Option<Name>,\n     pub(super) is_glob: bool,\n     pub(super) is_prelude: bool,\n@@ -206,7 +206,7 @@ impl_arena_id!(Macro);\n #[derive(Debug, PartialEq, Eq)]\n pub(super) struct MacroData {\n     pub(super) ast_id: FileAstId<ast::MacroCall>,\n-    pub(super) path: Path,\n+    pub(super) path: ModPath,\n     pub(super) name: Option<Name>,\n     pub(super) export: bool,\n     pub(super) builtin: bool,\n@@ -327,7 +327,7 @@ impl RawItemsCollector {\n         let attrs = self.parse_attrs(&use_item);\n \n         let mut buf = Vec::new();\n-        Path::expand_use_item(\n+        ModPath::expand_use_item(\n             InFile { value: use_item, file_id: self.file_id },\n             &self.hygiene,\n             |path, use_tree, is_glob, alias| {\n@@ -353,7 +353,7 @@ impl RawItemsCollector {\n         extern_crate: ast::ExternCrateItem,\n     ) {\n         if let Some(name_ref) = extern_crate.name_ref() {\n-            let path = Path::from_name_ref(&name_ref);\n+            let path = ModPath::from_name_ref(&name_ref);\n             let alias = extern_crate.alias().and_then(|a| a.name()).map(|it| it.as_name());\n             let attrs = self.parse_attrs(&extern_crate);\n             // FIXME: cfg_attr\n@@ -377,7 +377,7 @@ impl RawItemsCollector {\n \n     fn add_macro(&mut self, current_module: Option<Module>, m: ast::MacroCall) {\n         let attrs = self.parse_attrs(&m);\n-        let path = match m.path().and_then(|path| Path::from_src(path, &self.hygiene)) {\n+        let path = match m.path().and_then(|path| ModPath::from_src(path, &self.hygiene)) {\n             Some(it) => it,\n             _ => return,\n         };"}, {"sha": "20d6d98ea036512720449a9321aed140dd50e9f6", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 145, "deletions": 200, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -1,31 +1,78 @@\n //! A desugared representation of paths like `crate::foo` or `<Type as Trait>::bar`.\n-mod lower_use;\n+mod lower;\n \n use std::{iter, sync::Arc};\n \n-use either::Either;\n use hir_expand::{\n     hygiene::Hygiene,\n-    name::{name, AsName, Name},\n+    name::{AsName, Name},\n };\n use ra_db::CrateId;\n-use ra_syntax::{\n-    ast::{self, TypeAscriptionOwner},\n-    AstNode,\n-};\n+use ra_syntax::ast;\n \n use crate::{type_ref::TypeRef, InFile};\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Path {\n+pub struct ModPath {\n     pub kind: PathKind,\n-    pub segments: Vec<PathSegment>,\n+    pub segments: Vec<Name>,\n+}\n+\n+impl ModPath {\n+    pub fn from_src(path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n+        lower::lower_path(path, hygiene).map(|it| it.mod_path)\n+    }\n+\n+    pub fn from_simple_segments(\n+        kind: PathKind,\n+        segments: impl IntoIterator<Item = Name>,\n+    ) -> ModPath {\n+        let segments = segments.into_iter().collect::<Vec<_>>();\n+        ModPath { kind, segments }\n+    }\n+\n+    pub(crate) fn from_name_ref(name_ref: &ast::NameRef) -> ModPath {\n+        name_ref.as_name().into()\n+    }\n+\n+    /// Converts an `tt::Ident` into a single-identifier `Path`.\n+    pub(crate) fn from_tt_ident(ident: &tt::Ident) -> ModPath {\n+        ident.as_name().into()\n+    }\n+\n+    /// Calls `cb` with all paths, represented by this use item.\n+    pub(crate) fn expand_use_item(\n+        item_src: InFile<ast::UseItem>,\n+        hygiene: &Hygiene,\n+        mut cb: impl FnMut(ModPath, &ast::UseTree, /* is_glob */ bool, Option<Name>),\n+    ) {\n+        if let Some(tree) = item_src.value.use_tree() {\n+            lower::lower_use_tree(None, tree, hygiene, &mut cb);\n+        }\n+    }\n+\n+    pub fn is_ident(&self) -> bool {\n+        self.kind == PathKind::Plain && self.segments.len() == 1\n+    }\n+\n+    pub fn is_self(&self) -> bool {\n+        self.kind == PathKind::Self_ && self.segments.is_empty()\n+    }\n+\n+    /// If this path is a single identifier, like `foo`, return its name.\n+    pub fn as_ident(&self) -> Option<&Name> {\n+        if self.kind != PathKind::Plain || self.segments.len() > 1 {\n+            return None;\n+        }\n+        self.segments.first()\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct PathSegment {\n-    pub name: Name,\n-    pub args_and_bindings: Option<Arc<GenericArgs>>,\n+pub struct Path {\n+    mod_path: ModPath,\n+    /// Invariant: the same len as self.path.segments\n+    generic_args: Vec<Option<Arc<GenericArgs>>>,\n }\n \n /// Generic arguments to a path segment (e.g. the `i32` in `Option<i32>`). This\n@@ -65,221 +112,110 @@ pub enum PathKind {\n }\n \n impl Path {\n-    /// Calls `cb` with all paths, represented by this use item.\n-    pub(crate) fn expand_use_item(\n-        item_src: InFile<ast::UseItem>,\n-        hygiene: &Hygiene,\n-        mut cb: impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n-    ) {\n-        if let Some(tree) = item_src.value.use_tree() {\n-            lower_use::lower_use_tree(None, tree, hygiene, &mut cb);\n-        }\n-    }\n-\n-    pub fn from_simple_segments(kind: PathKind, segments: impl IntoIterator<Item = Name>) -> Path {\n-        Path {\n-            kind,\n-            segments: segments\n-                .into_iter()\n-                .map(|name| PathSegment { name, args_and_bindings: None })\n-                .collect(),\n-        }\n-    }\n-\n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// DEPRECATED: It does not handle `$crate` from macro call.\n     pub fn from_ast(path: ast::Path) -> Option<Path> {\n-        Path::from_src(path, &Hygiene::new_unhygienic())\n+        lower::lower_path(path, &Hygiene::new_unhygienic())\n     }\n \n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// It correctly handles `$crate` based path from macro call.\n-    pub fn from_src(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n-        let mut kind = PathKind::Plain;\n-        let mut segments = Vec::new();\n-        loop {\n-            let segment = path.segment()?;\n-\n-            if segment.has_colon_colon() {\n-                kind = PathKind::Abs;\n-            }\n-\n-            match segment.kind()? {\n-                ast::PathSegmentKind::Name(name_ref) => {\n-                    // FIXME: this should just return name\n-                    match hygiene.name_ref_to_name(name_ref) {\n-                        Either::Left(name) => {\n-                            let args = segment\n-                                .type_arg_list()\n-                                .and_then(GenericArgs::from_ast)\n-                                .or_else(|| {\n-                                    GenericArgs::from_fn_like_path_ast(\n-                                        segment.param_list(),\n-                                        segment.ret_type(),\n-                                    )\n-                                })\n-                                .map(Arc::new);\n-                            let segment = PathSegment { name, args_and_bindings: args };\n-                            segments.push(segment);\n-                        }\n-                        Either::Right(crate_id) => {\n-                            kind = PathKind::DollarCrate(crate_id);\n-                            break;\n-                        }\n-                    }\n-                }\n-                ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n-                    assert!(path.qualifier().is_none()); // this can only occur at the first segment\n-\n-                    let self_type = TypeRef::from_ast(type_ref?);\n-\n-                    match trait_ref {\n-                        // <T>::foo\n-                        None => {\n-                            kind = PathKind::Type(Box::new(self_type));\n-                        }\n-                        // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n-                        Some(trait_ref) => {\n-                            let path = Path::from_src(trait_ref.path()?, hygiene)?;\n-                            kind = path.kind;\n-                            let mut prefix_segments = path.segments;\n-                            prefix_segments.reverse();\n-                            segments.extend(prefix_segments);\n-                            // Insert the type reference (T in the above example) as Self parameter for the trait\n-                            let mut last_segment = segments.last_mut()?;\n-                            if last_segment.args_and_bindings.is_none() {\n-                                last_segment.args_and_bindings =\n-                                    Some(Arc::new(GenericArgs::empty()));\n-                            };\n-                            let args = last_segment.args_and_bindings.as_mut().unwrap();\n-                            let mut args_inner = Arc::make_mut(args);\n-                            args_inner.has_self_type = true;\n-                            args_inner.args.insert(0, GenericArg::Type(self_type));\n-                        }\n-                    }\n-                }\n-                ast::PathSegmentKind::CrateKw => {\n-                    kind = PathKind::Crate;\n-                    break;\n-                }\n-                ast::PathSegmentKind::SelfKw => {\n-                    kind = PathKind::Self_;\n-                    break;\n-                }\n-                ast::PathSegmentKind::SuperKw => {\n-                    kind = PathKind::Super;\n-                    break;\n-                }\n-            }\n-            path = match qualifier(&path) {\n-                Some(it) => it,\n-                None => break,\n-            };\n-        }\n-        segments.reverse();\n-        return Some(Path { kind, segments });\n-\n-        fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n-            if let Some(q) = path.qualifier() {\n-                return Some(q);\n-            }\n-            // FIXME: this bottom up traversal is not too precise.\n-            // Should we handle do a top-down analysis, recording results?\n-            let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n-            let use_tree = use_tree_list.parent_use_tree();\n-            use_tree.path()\n-        }\n+    pub fn from_src(path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n+        lower::lower_path(path, hygiene)\n     }\n \n     /// Converts an `ast::NameRef` into a single-identifier `Path`.\n     pub(crate) fn from_name_ref(name_ref: &ast::NameRef) -> Path {\n-        name_ref.as_name().into()\n+        Path { mod_path: name_ref.as_name().into(), generic_args: vec![None] }\n     }\n \n-    /// Converts an `tt::Ident` into a single-identifier `Path`.\n-    pub(crate) fn from_tt_ident(ident: &tt::Ident) -> Path {\n-        ident.as_name().into()\n+    /// `true` if this path is just a standalone `self`\n+    pub fn is_self(&self) -> bool {\n+        self.mod_path.is_self()\n     }\n \n-    /// `true` is this path is a single identifier, like `foo`\n-    pub fn is_ident(&self) -> bool {\n-        self.kind == PathKind::Plain && self.segments.len() == 1\n+    pub fn kind(&self) -> &PathKind {\n+        &self.mod_path.kind\n     }\n \n-    /// `true` if this path is just a standalone `self`\n-    pub fn is_self(&self) -> bool {\n-        self.kind == PathKind::Self_ && self.segments.is_empty()\n+    pub fn segments(&self) -> PathSegments<'_> {\n+        PathSegments {\n+            segments: self.mod_path.segments.as_slice(),\n+            generic_args: self.generic_args.as_slice(),\n+        }\n     }\n \n-    /// If this path is a single identifier, like `foo`, return its name.\n-    pub fn as_ident(&self) -> Option<&Name> {\n-        if self.kind != PathKind::Plain || self.segments.len() > 1 {\n+    pub fn mod_path(&self) -> &ModPath {\n+        &self.mod_path\n+    }\n+\n+    pub fn qualifier(&self) -> Option<Path> {\n+        if self.mod_path.is_ident() {\n             return None;\n         }\n-        self.segments.first().map(|s| &s.name)\n+        let res = Path {\n+            mod_path: ModPath {\n+                kind: self.mod_path.kind.clone(),\n+                segments: self.mod_path.segments[..self.mod_path.segments.len() - 1].to_vec(),\n+            },\n+            generic_args: self.generic_args[..self.generic_args.len() - 1].to_vec(),\n+        };\n+        Some(res)\n     }\n+}\n \n-    pub fn expand_macro_expr(&self) -> Option<Name> {\n-        self.as_ident().and_then(|name| Some(name.clone()))\n-    }\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct PathSegment<'a> {\n+    pub name: &'a Name,\n+    pub args_and_bindings: Option<&'a GenericArgs>,\n+}\n \n-    pub fn is_type_relative(&self) -> bool {\n-        match self.kind {\n-            PathKind::Type(_) => true,\n-            _ => false,\n-        }\n+pub struct PathSegments<'a> {\n+    segments: &'a [Name],\n+    generic_args: &'a [Option<Arc<GenericArgs>>],\n+}\n+\n+impl<'a> PathSegments<'a> {\n+    pub const EMPTY: PathSegments<'static> = PathSegments { segments: &[], generic_args: &[] };\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+    pub fn len(&self) -> usize {\n+        self.segments.len()\n+    }\n+    pub fn first(&self) -> Option<PathSegment<'a>> {\n+        self.get(0)\n+    }\n+    pub fn last(&self) -> Option<PathSegment<'a>> {\n+        self.get(self.len().checked_sub(1)?)\n+    }\n+    pub fn get(&self, idx: usize) -> Option<PathSegment<'a>> {\n+        assert_eq!(self.segments.len(), self.generic_args.len());\n+        let res = PathSegment {\n+            name: self.segments.get(idx)?,\n+            args_and_bindings: self.generic_args.get(idx).unwrap().as_ref().map(|it| &**it),\n+        };\n+        Some(res)\n+    }\n+    pub fn skip(&self, len: usize) -> PathSegments<'a> {\n+        assert_eq!(self.segments.len(), self.generic_args.len());\n+        PathSegments { segments: &self.segments[len..], generic_args: &self.generic_args[len..] }\n+    }\n+    pub fn take(&self, len: usize) -> PathSegments<'a> {\n+        assert_eq!(self.segments.len(), self.generic_args.len());\n+        PathSegments { segments: &self.segments[..len], generic_args: &self.generic_args[..len] }\n+    }\n+    pub fn iter(&self) -> impl Iterator<Item = PathSegment<'a>> {\n+        self.segments.iter().zip(self.generic_args.iter()).map(|(name, args)| PathSegment {\n+            name,\n+            args_and_bindings: args.as_ref().map(|it| &**it),\n+        })\n     }\n }\n \n impl GenericArgs {\n     pub(crate) fn from_ast(node: ast::TypeArgList) -> Option<GenericArgs> {\n-        let mut args = Vec::new();\n-        for type_arg in node.type_args() {\n-            let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n-            args.push(GenericArg::Type(type_ref));\n-        }\n-        // lifetimes ignored for now\n-        let mut bindings = Vec::new();\n-        for assoc_type_arg in node.assoc_type_args() {\n-            if let Some(name_ref) = assoc_type_arg.name_ref() {\n-                let name = name_ref.as_name();\n-                let type_ref = TypeRef::from_ast_opt(assoc_type_arg.type_ref());\n-                bindings.push((name, type_ref));\n-            }\n-        }\n-        if args.is_empty() && bindings.is_empty() {\n-            None\n-        } else {\n-            Some(GenericArgs { args, has_self_type: false, bindings })\n-        }\n-    }\n-\n-    /// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)\n-    /// -> Z` (which desugars to `Fn<(X, Y), Output=Z>`).\n-    pub(crate) fn from_fn_like_path_ast(\n-        params: Option<ast::ParamList>,\n-        ret_type: Option<ast::RetType>,\n-    ) -> Option<GenericArgs> {\n-        let mut args = Vec::new();\n-        let mut bindings = Vec::new();\n-        if let Some(params) = params {\n-            let mut param_types = Vec::new();\n-            for param in params.params() {\n-                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n-                param_types.push(type_ref);\n-            }\n-            let arg = GenericArg::Type(TypeRef::Tuple(param_types));\n-            args.push(arg);\n-        }\n-        if let Some(ret_type) = ret_type {\n-            let type_ref = TypeRef::from_ast_opt(ret_type.type_ref());\n-            bindings.push((name![Output], type_ref))\n-        }\n-        if args.is_empty() && bindings.is_empty() {\n-            None\n-        } else {\n-            Some(GenericArgs { args, has_self_type: false, bindings })\n-        }\n+        lower::lower_generic_args(node)\n     }\n \n     pub(crate) fn empty() -> GenericArgs {\n@@ -289,7 +225,16 @@ impl GenericArgs {\n \n impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n-        Path::from_simple_segments(PathKind::Plain, iter::once(name))\n+        Path {\n+            mod_path: ModPath::from_simple_segments(PathKind::Plain, iter::once(name)),\n+            generic_args: vec![None],\n+        }\n+    }\n+}\n+\n+impl From<Name> for ModPath {\n+    fn from(name: Name) -> ModPath {\n+        ModPath::from_simple_segments(PathKind::Plain, iter::once(name))\n     }\n }\n \n@@ -319,7 +264,7 @@ macro_rules! __known_path {\n macro_rules! __path {\n     ($start:ident $(:: $seg:ident)*) => ({\n         $crate::__known_path!($start $(:: $seg)*);\n-        $crate::path::Path::from_simple_segments($crate::path::PathKind::Abs, vec![\n+        $crate::path::ModPath::from_simple_segments($crate::path::PathKind::Abs, vec![\n             $crate::path::__name![$start], $($crate::path::__name![$seg],)*\n         ])\n     });"}, {"sha": "a2e99519802cf646d8363c336340902989dbd25b", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -0,0 +1,176 @@\n+//! Transforms syntax into `Path` objects, ideally with accounting for hygiene\n+\n+mod lower_use;\n+\n+use std::sync::Arc;\n+\n+use either::Either;\n+use hir_expand::{\n+    hygiene::Hygiene,\n+    name::{name, AsName},\n+};\n+use ra_syntax::ast::{self, AstNode, TypeAscriptionOwner};\n+\n+use crate::{\n+    path::{GenericArg, GenericArgs, ModPath, Path, PathKind},\n+    type_ref::TypeRef,\n+};\n+\n+pub(super) use lower_use::lower_use_tree;\n+\n+/// Converts an `ast::Path` to `Path`. Works with use trees.\n+/// It correctly handles `$crate` based path from macro call.\n+pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n+    let mut kind = PathKind::Plain;\n+    let mut segments = Vec::new();\n+    let mut generic_args = Vec::new();\n+    loop {\n+        let segment = path.segment()?;\n+\n+        if segment.has_colon_colon() {\n+            kind = PathKind::Abs;\n+        }\n+\n+        match segment.kind()? {\n+            ast::PathSegmentKind::Name(name_ref) => {\n+                // FIXME: this should just return name\n+                match hygiene.name_ref_to_name(name_ref) {\n+                    Either::Left(name) => {\n+                        let args = segment\n+                            .type_arg_list()\n+                            .and_then(lower_generic_args)\n+                            .or_else(|| {\n+                                lower_generic_args_from_fn_path(\n+                                    segment.param_list(),\n+                                    segment.ret_type(),\n+                                )\n+                            })\n+                            .map(Arc::new);\n+                        segments.push(name);\n+                        generic_args.push(args)\n+                    }\n+                    Either::Right(crate_id) => {\n+                        kind = PathKind::DollarCrate(crate_id);\n+                        break;\n+                    }\n+                }\n+            }\n+            ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n+                assert!(path.qualifier().is_none()); // this can only occur at the first segment\n+\n+                let self_type = TypeRef::from_ast(type_ref?);\n+\n+                match trait_ref {\n+                    // <T>::foo\n+                    None => {\n+                        kind = PathKind::Type(Box::new(self_type));\n+                    }\n+                    // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n+                    Some(trait_ref) => {\n+                        let path = Path::from_src(trait_ref.path()?, hygiene)?;\n+                        kind = path.mod_path.kind;\n+\n+                        let mut prefix_segments = path.mod_path.segments;\n+                        prefix_segments.reverse();\n+                        segments.extend(prefix_segments);\n+\n+                        let mut prefix_args = path.generic_args;\n+                        prefix_args.reverse();\n+                        generic_args.extend(prefix_args);\n+\n+                        // Insert the type reference (T in the above example) as Self parameter for the trait\n+                        let last_segment = generic_args.last_mut()?;\n+                        if last_segment.is_none() {\n+                            *last_segment = Some(Arc::new(GenericArgs::empty()));\n+                        };\n+                        let args = last_segment.as_mut().unwrap();\n+                        let mut args_inner = Arc::make_mut(args);\n+                        args_inner.has_self_type = true;\n+                        args_inner.args.insert(0, GenericArg::Type(self_type));\n+                    }\n+                }\n+            }\n+            ast::PathSegmentKind::CrateKw => {\n+                kind = PathKind::Crate;\n+                break;\n+            }\n+            ast::PathSegmentKind::SelfKw => {\n+                kind = PathKind::Self_;\n+                break;\n+            }\n+            ast::PathSegmentKind::SuperKw => {\n+                kind = PathKind::Super;\n+                break;\n+            }\n+        }\n+        path = match qualifier(&path) {\n+            Some(it) => it,\n+            None => break,\n+        };\n+    }\n+    segments.reverse();\n+    generic_args.reverse();\n+    let mod_path = ModPath { kind, segments };\n+    return Some(Path { mod_path, generic_args });\n+\n+    fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n+        if let Some(q) = path.qualifier() {\n+            return Some(q);\n+        }\n+        // FIXME: this bottom up traversal is not too precise.\n+        // Should we handle do a top-down analysis, recording results?\n+        let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n+        let use_tree = use_tree_list.parent_use_tree();\n+        use_tree.path()\n+    }\n+}\n+\n+pub(super) fn lower_generic_args(node: ast::TypeArgList) -> Option<GenericArgs> {\n+    let mut args = Vec::new();\n+    for type_arg in node.type_args() {\n+        let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n+        args.push(GenericArg::Type(type_ref));\n+    }\n+    // lifetimes ignored for now\n+    let mut bindings = Vec::new();\n+    for assoc_type_arg in node.assoc_type_args() {\n+        if let Some(name_ref) = assoc_type_arg.name_ref() {\n+            let name = name_ref.as_name();\n+            let type_ref = TypeRef::from_ast_opt(assoc_type_arg.type_ref());\n+            bindings.push((name, type_ref));\n+        }\n+    }\n+    if args.is_empty() && bindings.is_empty() {\n+        None\n+    } else {\n+        Some(GenericArgs { args, has_self_type: false, bindings })\n+    }\n+}\n+\n+/// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)\n+/// -> Z` (which desugars to `Fn<(X, Y), Output=Z>`).\n+fn lower_generic_args_from_fn_path(\n+    params: Option<ast::ParamList>,\n+    ret_type: Option<ast::RetType>,\n+) -> Option<GenericArgs> {\n+    let mut args = Vec::new();\n+    let mut bindings = Vec::new();\n+    if let Some(params) = params {\n+        let mut param_types = Vec::new();\n+        for param in params.params() {\n+            let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n+            param_types.push(type_ref);\n+        }\n+        let arg = GenericArg::Type(TypeRef::Tuple(param_types));\n+        args.push(arg);\n+    }\n+    if let Some(ret_type) = ret_type {\n+        let type_ref = TypeRef::from_ast_opt(ret_type.type_ref());\n+        bindings.push((name![Output], type_ref))\n+    }\n+    if args.is_empty() && bindings.is_empty() {\n+        None\n+    } else {\n+        Some(GenericArgs { args, has_self_type: false, bindings })\n+    }\n+}"}, {"sha": "ea3fdb56cc2f3e6166e6ecdeadd091efbbffa8bc", "filename": "crates/ra_hir_def/src/path/lower/lower_use.rs", "status": "renamed", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -10,13 +10,13 @@ use hir_expand::{\n };\n use ra_syntax::ast::{self, NameOwner};\n \n-use crate::path::{Path, PathKind, PathSegment};\n+use crate::path::{ModPath, PathKind};\n \n pub(crate) fn lower_use_tree(\n-    prefix: Option<Path>,\n+    prefix: Option<ModPath>,\n     tree: ast::UseTree,\n     hygiene: &Hygiene,\n-    cb: &mut dyn FnMut(Path, &ast::UseTree, bool, Option<Name>),\n+    cb: &mut dyn FnMut(ModPath, &ast::UseTree, bool, Option<Name>),\n ) {\n     if let Some(use_tree_list) = tree.use_tree_list() {\n         let prefix = match tree.path() {\n@@ -57,7 +57,7 @@ pub(crate) fn lower_use_tree(\n     }\n }\n \n-fn convert_path(prefix: Option<Path>, path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n+fn convert_path(prefix: Option<ModPath>, path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n     let prefix = if let Some(qual) = path.qualifier() {\n         Some(convert_path(prefix, qual, hygiene)?)\n     } else {\n@@ -70,18 +70,15 @@ fn convert_path(prefix: Option<Path>, path: ast::Path, hygiene: &Hygiene) -> Opt\n             match hygiene.name_ref_to_name(name_ref) {\n                 Either::Left(name) => {\n                     // no type args in use\n-                    let mut res = prefix.unwrap_or_else(|| Path {\n+                    let mut res = prefix.unwrap_or_else(|| ModPath {\n                         kind: PathKind::Plain,\n                         segments: Vec::with_capacity(1),\n                     });\n-                    res.segments.push(PathSegment {\n-                        name,\n-                        args_and_bindings: None, // no type args in use\n-                    });\n+                    res.segments.push(name);\n                     res\n                 }\n                 Either::Right(crate_id) => {\n-                    return Some(Path::from_simple_segments(\n+                    return Some(ModPath::from_simple_segments(\n                         PathKind::DollarCrate(crate_id),\n                         iter::empty(),\n                     ))\n@@ -92,19 +89,19 @@ fn convert_path(prefix: Option<Path>, path: ast::Path, hygiene: &Hygiene) -> Opt\n             if prefix.is_some() {\n                 return None;\n             }\n-            Path::from_simple_segments(PathKind::Crate, iter::empty())\n+            ModPath::from_simple_segments(PathKind::Crate, iter::empty())\n         }\n         ast::PathSegmentKind::SelfKw => {\n             if prefix.is_some() {\n                 return None;\n             }\n-            Path::from_simple_segments(PathKind::Self_, iter::empty())\n+            ModPath::from_simple_segments(PathKind::Self_, iter::empty())\n         }\n         ast::PathSegmentKind::SuperKw => {\n             if prefix.is_some() {\n                 return None;\n             }\n-            Path::from_simple_segments(PathKind::Super, iter::empty())\n+            ModPath::from_simple_segments(PathKind::Super, iter::empty())\n         }\n         ast::PathSegmentKind::Type { .. } => {\n             // not allowed in imports", "previous_filename": "crates/ra_hir_def/src/path/lower_use.rs"}, {"sha": "2694c0438b86bf9acb4c96ad8165591f2009d3c1", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     expr::{ExprId, PatId},\n     generics::GenericParams,\n     nameres::{BuiltinShadowMode, CrateDefMap},\n-    path::{Path, PathKind},\n+    path::{ModPath, PathKind},\n     per_ns::PerNs,\n     AdtId, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, GenericDefId,\n     HasModule, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId, StaticId, StructId, TraitId,\n@@ -91,7 +91,7 @@ pub enum ValueNs {\n \n impl Resolver {\n     /// Resolve known trait from std, like `std::futures::Future`\n-    pub fn resolve_known_trait(&self, db: &impl DefDatabase, path: &Path) -> Option<TraitId> {\n+    pub fn resolve_known_trait(&self, db: &impl DefDatabase, path: &ModPath) -> Option<TraitId> {\n         let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;\n         match res {\n             ModuleDefId::TraitId(it) => Some(it),\n@@ -100,7 +100,7 @@ impl Resolver {\n     }\n \n     /// Resolve known struct from std, like `std::boxed::Box`\n-    pub fn resolve_known_struct(&self, db: &impl DefDatabase, path: &Path) -> Option<StructId> {\n+    pub fn resolve_known_struct(&self, db: &impl DefDatabase, path: &ModPath) -> Option<StructId> {\n         let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;\n         match res {\n             ModuleDefId::AdtId(AdtId::StructId(it)) => Some(it),\n@@ -109,7 +109,7 @@ impl Resolver {\n     }\n \n     /// Resolve known enum from std, like `std::result::Result`\n-    pub fn resolve_known_enum(&self, db: &impl DefDatabase, path: &Path) -> Option<EnumId> {\n+    pub fn resolve_known_enum(&self, db: &impl DefDatabase, path: &ModPath) -> Option<EnumId> {\n         let res = self.resolve_module_path(db, path, BuiltinShadowMode::Other).take_types()?;\n         match res {\n             ModuleDefId::AdtId(AdtId::EnumId(it)) => Some(it),\n@@ -120,33 +120,30 @@ impl Resolver {\n     fn resolve_module_path(\n         &self,\n         db: &impl DefDatabase,\n-        path: &Path,\n+        path: &ModPath,\n         shadow: BuiltinShadowMode,\n     ) -> PerNs {\n         let (item_map, module) = match self.module() {\n             Some(it) => it,\n             None => return PerNs::none(),\n         };\n-        let (module_res, segment_index) = item_map.resolve_path(db, module, path, shadow);\n+        let (module_res, segment_index) = item_map.resolve_path(db, module, &path, shadow);\n         if segment_index.is_some() {\n             return PerNs::none();\n         }\n         module_res\n     }\n \n-    pub fn resolve_module_path_in_items(&self, db: &impl DefDatabase, path: &Path) -> PerNs {\n+    pub fn resolve_module_path_in_items(&self, db: &impl DefDatabase, path: &ModPath) -> PerNs {\n         self.resolve_module_path(db, path, BuiltinShadowMode::Module)\n     }\n \n     pub fn resolve_path_in_type_ns(\n         &self,\n         db: &impl DefDatabase,\n-        path: &Path,\n+        path: &ModPath,\n     ) -> Option<(TypeNs, Option<usize>)> {\n-        if path.is_type_relative() {\n-            return None;\n-        }\n-        let first_name = &path.segments.first()?.name;\n+        let first_name = path.segments.first()?;\n         let skip_to_mod = path.kind != PathKind::Plain;\n         for scope in self.scopes.iter().rev() {\n             match scope {\n@@ -178,7 +175,7 @@ impl Resolver {\n                     let (module_def, idx) = m.crate_def_map.resolve_path(\n                         db,\n                         m.module_id,\n-                        path,\n+                        &path,\n                         BuiltinShadowMode::Other,\n                     );\n                     let res = match module_def.take_types()? {\n@@ -205,7 +202,7 @@ impl Resolver {\n     pub fn resolve_path_in_type_ns_fully(\n         &self,\n         db: &impl DefDatabase,\n-        path: &Path,\n+        path: &ModPath,\n     ) -> Option<TypeNs> {\n         let (res, unresolved) = self.resolve_path_in_type_ns(db, path)?;\n         if unresolved.is_some() {\n@@ -214,17 +211,14 @@ impl Resolver {\n         Some(res)\n     }\n \n-    pub fn resolve_path_in_value_ns<'p>(\n+    pub fn resolve_path_in_value_ns(\n         &self,\n         db: &impl DefDatabase,\n-        path: &'p Path,\n+        path: &ModPath,\n     ) -> Option<ResolveValueResult> {\n-        if path.is_type_relative() {\n-            return None;\n-        }\n         let n_segments = path.segments.len();\n         let tmp = name![self];\n-        let first_name = if path.is_self() { &tmp } else { &path.segments.first()?.name };\n+        let first_name = if path.is_self() { &tmp } else { &path.segments.first()? };\n         let skip_to_mod = path.kind != PathKind::Plain && !path.is_self();\n         for scope in self.scopes.iter().rev() {\n             match scope {\n@@ -276,7 +270,7 @@ impl Resolver {\n                     let (module_def, idx) = m.crate_def_map.resolve_path(\n                         db,\n                         m.module_id,\n-                        path,\n+                        &path,\n                         BuiltinShadowMode::Other,\n                     );\n                     return match idx {\n@@ -322,17 +316,21 @@ impl Resolver {\n     pub fn resolve_path_in_value_ns_fully(\n         &self,\n         db: &impl DefDatabase,\n-        path: &Path,\n+        path: &ModPath,\n     ) -> Option<ValueNs> {\n         match self.resolve_path_in_value_ns(db, path)? {\n             ResolveValueResult::ValueNs(it) => Some(it),\n             ResolveValueResult::Partial(..) => None,\n         }\n     }\n \n-    pub fn resolve_path_as_macro(&self, db: &impl DefDatabase, path: &Path) -> Option<MacroDefId> {\n+    pub fn resolve_path_as_macro(\n+        &self,\n+        db: &impl DefDatabase,\n+        path: &ModPath,\n+    ) -> Option<MacroDefId> {\n         let (item_map, module) = self.module()?;\n-        item_map.resolve_path(db, module, path, BuiltinShadowMode::Other).0.take_macros()\n+        item_map.resolve_path(db, module, &path, BuiltinShadowMode::Other).0.take_macros()\n     }\n \n     pub fn process_all_names(&self, db: &impl DefDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {"}, {"sha": "af42854cce9fa8f152470b3201bd4b34eb127f9c", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -386,7 +386,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let resolver = &self.resolver;\n         // FIXME: this should resolve assoc items as well, see this example:\n         // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n-        match resolver.resolve_path_in_type_ns_fully(self.db, &path) {\n+        match resolver.resolve_path_in_type_ns_fully(self.db, path.mod_path()) {\n             Some(TypeNs::AdtId(AdtId::StructId(strukt))) => {\n                 let substs = Ty::substs_from_path(self.db, resolver, path, strukt.into());\n                 let ty = self.db.ty(strukt.into());"}, {"sha": "3bae0ca6c291738f60e3a05729814fd2ceb51736", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -32,21 +32,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         path: &Path,\n         id: ExprOrPatId,\n     ) -> Option<Ty> {\n-        let (value, self_subst) = if let PathKind::Type(type_ref) = &path.kind {\n-            if path.segments.is_empty() {\n+        let (value, self_subst) = if let PathKind::Type(type_ref) = path.kind() {\n+            if path.segments().is_empty() {\n                 // This can't actually happen syntax-wise\n                 return None;\n             }\n             let ty = self.make_ty(type_ref);\n-            let remaining_segments_for_ty = &path.segments[..path.segments.len() - 1];\n+            let remaining_segments_for_ty = path.segments().take(path.segments().len() - 1);\n             let ty = Ty::from_type_relative_path(self.db, resolver, ty, remaining_segments_for_ty);\n             self.resolve_ty_assoc_item(\n                 ty,\n-                &path.segments.last().expect(\"path had at least one segment\").name,\n+                &path.segments().last().expect(\"path had at least one segment\").name,\n                 id,\n             )?\n         } else {\n-            let value_or_partial = resolver.resolve_path_in_value_ns(self.db, &path)?;\n+            let value_or_partial = resolver.resolve_path_in_value_ns(self.db, path.mod_path())?;\n \n             match value_or_partial {\n                 ResolveValueResult::ValueNs(it) => (it, None),\n@@ -85,13 +85,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         remaining_index: usize,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n-        assert!(remaining_index < path.segments.len());\n+        assert!(remaining_index < path.segments().len());\n         // there may be more intermediate segments between the resolved one and\n         // the end. Only the last segment needs to be resolved to a value; from\n         // the segments before that, we need to get either a type or a trait ref.\n \n-        let resolved_segment = &path.segments[remaining_index - 1];\n-        let remaining_segments = &path.segments[remaining_index..];\n+        let resolved_segment = path.segments().get(remaining_index - 1).unwrap();\n+        let remaining_segments = path.segments().skip(remaining_index);\n         let is_before_last = remaining_segments.len() == 1;\n \n         match (def, is_before_last) {\n@@ -112,7 +112,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // trait but it's not the last segment, so the next segment\n                 // should resolve to an associated type of that trait (e.g. `<T\n                 // as Iterator>::Item::default`)\n-                let remaining_segments_for_ty = &remaining_segments[..remaining_segments.len() - 1];\n+                let remaining_segments_for_ty =\n+                    remaining_segments.take(remaining_segments.len() - 1);\n                 let ty = Ty::from_partly_resolved_hir_path(\n                     self.db,\n                     &self.resolver,\n@@ -138,7 +139,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_trait_assoc_item(\n         &mut self,\n         trait_ref: TraitRef,\n-        segment: &PathSegment,\n+        segment: PathSegment<'_>,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n         let trait_ = trait_ref.trait_;\n@@ -150,15 +151,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             .map(|(_name, id)| (*id).into())\n             .find_map(|item| match item {\n                 AssocItemId::FunctionId(func) => {\n-                    if segment.name == self.db.function_data(func).name {\n+                    if segment.name == &self.db.function_data(func).name {\n                         Some(AssocItemId::FunctionId(func))\n                     } else {\n                         None\n                     }\n                 }\n \n                 AssocItemId::ConstId(konst) => {\n-                    if self.db.const_data(konst).name.as_ref().map_or(false, |n| n == &segment.name)\n+                    if self.db.const_data(konst).name.as_ref().map_or(false, |n| n == segment.name)\n                     {\n                         Some(AssocItemId::ConstId(konst))\n                     } else {"}, {"sha": "a4ddfc8efb6572550983da55307a2df7421ba864", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -11,7 +11,7 @@ use std::sync::Arc;\n use hir_def::{\n     builtin_type::BuiltinType,\n     generics::WherePredicate,\n-    path::{GenericArg, Path, PathKind, PathSegment},\n+    path::{GenericArg, Path, PathKind, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n     AdtId, ConstId, EnumId, EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId,\n@@ -101,13 +101,13 @@ impl Ty {\n             TypeRef::Path(path) => path,\n             _ => return None,\n         };\n-        if let PathKind::Type(_) = &path.kind {\n+        if let PathKind::Type(_) = path.kind() {\n             return None;\n         }\n-        if path.segments.len() > 1 {\n+        if path.segments().len() > 1 {\n             return None;\n         }\n-        let resolution = match resolver.resolve_path_in_type_ns(db, path) {\n+        let resolution = match resolver.resolve_path_in_type_ns(db, path.mod_path()) {\n             Some((it, None)) => it,\n             _ => return None,\n         };\n@@ -124,11 +124,11 @@ impl Ty {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         ty: Ty,\n-        remaining_segments: &[PathSegment],\n+        remaining_segments: PathSegments<'_>,\n     ) -> Ty {\n         if remaining_segments.len() == 1 {\n             // resolve unselected assoc types\n-            let segment = &remaining_segments[0];\n+            let segment = remaining_segments.first().unwrap();\n             Ty::select_associated_type(db, resolver, ty, segment)\n         } else if remaining_segments.len() > 1 {\n             // FIXME report error (ambiguous associated type)\n@@ -142,15 +142,15 @@ impl Ty {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         resolution: TypeNs,\n-        resolved_segment: &PathSegment,\n-        remaining_segments: &[PathSegment],\n+        resolved_segment: PathSegment<'_>,\n+        remaining_segments: PathSegments<'_>,\n     ) -> Ty {\n         let ty = match resolution {\n             TypeNs::TraitId(trait_) => {\n                 let trait_ref =\n                     TraitRef::from_resolved_path(db, resolver, trait_, resolved_segment, None);\n                 return if remaining_segments.len() == 1 {\n-                    let segment = &remaining_segments[0];\n+                    let segment = remaining_segments.first().unwrap();\n                     let associated_ty = associated_type_by_name_including_super_traits(\n                         db,\n                         trait_ref.trait_,\n@@ -202,21 +202,21 @@ impl Ty {\n \n     pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n         // Resolve the path (in type namespace)\n-        if let PathKind::Type(type_ref) = &path.kind {\n+        if let PathKind::Type(type_ref) = path.kind() {\n             let ty = Ty::from_hir(db, resolver, &type_ref);\n-            let remaining_segments = &path.segments[..];\n-            return Ty::from_type_relative_path(db, resolver, ty, remaining_segments);\n+            return Ty::from_type_relative_path(db, resolver, ty, path.segments());\n         }\n-        let (resolution, remaining_index) = match resolver.resolve_path_in_type_ns(db, path) {\n-            Some(it) => it,\n-            None => return Ty::Unknown,\n-        };\n+        let (resolution, remaining_index) =\n+            match resolver.resolve_path_in_type_ns(db, path.mod_path()) {\n+                Some(it) => it,\n+                None => return Ty::Unknown,\n+            };\n         let (resolved_segment, remaining_segments) = match remaining_index {\n             None => (\n-                path.segments.last().expect(\"resolved path has at least one element\"),\n-                &[] as &[PathSegment],\n+                path.segments().last().expect(\"resolved path has at least one element\"),\n+                PathSegments::EMPTY,\n             ),\n-            Some(i) => (&path.segments[i - 1], &path.segments[i..]),\n+            Some(i) => (path.segments().get(i - 1).unwrap(), path.segments().skip(i)),\n         };\n         Ty::from_partly_resolved_hir_path(\n             db,\n@@ -231,7 +231,7 @@ impl Ty {\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         self_ty: Ty,\n-        segment: &PathSegment,\n+        segment: PathSegment<'_>,\n     ) -> Ty {\n         let param_idx = match self_ty {\n             Ty::Param { idx, .. } => idx,\n@@ -261,7 +261,7 @@ impl Ty {\n     fn from_hir_path_inner(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n-        segment: &PathSegment,\n+        segment: PathSegment<'_>,\n         typable: TyDefId,\n     ) -> Ty {\n         let generic_def = match typable {\n@@ -284,7 +284,7 @@ impl Ty {\n         // special-case enum variants\n         resolved: ValueTyDefId,\n     ) -> Substs {\n-        let last = path.segments.last().expect(\"path should have at least one segment\");\n+        let last = path.segments().last().expect(\"path should have at least one segment\");\n         let (segment, generic_def) = match resolved {\n             ValueTyDefId::FunctionId(it) => (last, Some(it.into())),\n             ValueTyDefId::StructId(it) => (last, Some(it.into())),\n@@ -296,13 +296,11 @@ impl Ty {\n                 // referring to the variant. So `Option::<T>::None` and\n                 // `Option::None::<T>` are both allowed (though the former is\n                 // preferred). See also `def_ids_for_path_segments` in rustc.\n-                let len = path.segments.len();\n-                let segment = if len >= 2 && path.segments[len - 2].args_and_bindings.is_some() {\n-                    // Option::<T>::None\n-                    &path.segments[len - 2]\n-                } else {\n-                    // Option::None::<T>\n-                    last\n+                let len = path.segments().len();\n+                let penultimate = if len >= 2 { path.segments().get(len - 2) } else { None };\n+                let segment = match penultimate {\n+                    Some(segment) if segment.args_and_bindings.is_some() => segment,\n+                    _ => last,\n                 };\n                 (segment, Some(var.parent.into()))\n             }\n@@ -314,7 +312,7 @@ impl Ty {\n pub(super) fn substs_from_path_segment(\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n-    segment: &PathSegment,\n+    segment: PathSegment<'_>,\n     def_generic: Option<GenericDefId>,\n     add_self_param: bool,\n ) -> Substs {\n@@ -372,19 +370,19 @@ impl TraitRef {\n         path: &Path,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n-        let resolved = match resolver.resolve_path_in_type_ns_fully(db, &path)? {\n+        let resolved = match resolver.resolve_path_in_type_ns_fully(db, path.mod_path())? {\n             TypeNs::TraitId(tr) => tr,\n             _ => return None,\n         };\n-        let segment = path.segments.last().expect(\"path should have at least one segment\");\n+        let segment = path.segments().last().expect(\"path should have at least one segment\");\n         Some(TraitRef::from_resolved_path(db, resolver, resolved.into(), segment, explicit_self_ty))\n     }\n \n     pub(crate) fn from_resolved_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         resolved: TraitId,\n-        segment: &PathSegment,\n+        segment: PathSegment<'_>,\n         explicit_self_ty: Option<Ty>,\n     ) -> Self {\n         let mut substs = TraitRef::substs_from_path(db, resolver, segment, resolved);\n@@ -410,7 +408,7 @@ impl TraitRef {\n     fn substs_from_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n-        segment: &PathSegment,\n+        segment: PathSegment<'_>,\n         resolved: TraitId,\n     ) -> Substs {\n         let has_self_param =\n@@ -464,12 +462,12 @@ fn assoc_type_bindings_from_type_bound<'a>(\n     trait_ref: TraitRef,\n ) -> impl Iterator<Item = GenericPredicate> + 'a {\n     let last_segment = match bound {\n-        TypeBound::Path(path) => path.segments.last(),\n+        TypeBound::Path(path) => path.segments().last(),\n         TypeBound::Error => None,\n     };\n     last_segment\n         .into_iter()\n-        .flat_map(|segment| segment.args_and_bindings.iter())\n+        .flat_map(|segment| segment.args_and_bindings.into_iter())\n         .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n         .map(move |(name, type_ref)| {\n             let associated_ty ="}, {"sha": "29799a8cbdb8e09d88128fb389e207d23a7de68a", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -6,6 +6,7 @@ use hir_def::{\n     adt::VariantData,\n     db::DefDatabase,\n     generics::{GenericParams, TypeParamData},\n+    path::Path,\n     resolver::{HasResolver, TypeNs},\n     type_ref::TypeRef,\n     ContainerId, GenericDefId, Lookup, TraitId, TypeAliasId, TypeParamId, VariantId,\n@@ -22,10 +23,10 @@ fn direct_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n         .where_predicates\n         .iter()\n         .filter_map(|pred| match &pred.type_ref {\n-            TypeRef::Path(p) if p.as_ident() == Some(&name![Self]) => pred.bound.as_path(),\n+            TypeRef::Path(p) if p == &Path::from(name![Self]) => pred.bound.as_path(),\n             _ => None,\n         })\n-        .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path) {\n+        .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path.mod_path()) {\n             Some(TypeNs::TraitId(t)) => Some(t),\n             _ => None,\n         })"}, {"sha": "981da2b79487f4ad4a691413f9992245590c7dc3", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -188,10 +188,9 @@ impl<'a> CompletionContext<'a> {\n             self.is_path_type = path.syntax().parent().and_then(ast::PathType::cast).is_some();\n             self.has_type_args = segment.type_arg_list().is_some();\n \n-            if let Some(mut path) = hir::Path::from_ast(path.clone()) {\n-                if !path.is_ident() {\n-                    path.segments.pop().unwrap();\n-                    self.path_prefix = Some(path);\n+            if let Some(path) = hir::Path::from_ast(path.clone()) {\n+                if let Some(path_prefix) = path.qualifier() {\n+                    self.path_prefix = Some(path_prefix);\n                     return;\n                 }\n             }"}, {"sha": "c862d3912c3529d0715805ae0cb91d15e47f9c22", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6223253b628b279f9ddae8f83f7173d01f6b32c/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=d6223253b628b279f9ddae8f83f7173d01f6b32c", "patch": "@@ -24,7 +24,7 @@ pub struct CargoWorkspace {\n     pub(crate) workspace_root: PathBuf,\n }\n \n-#[derive(Deserialize, Clone, Debug, PartialEq, Eq, Default)]\n+#[derive(Deserialize, Clone, Debug, PartialEq, Eq)]\n #[serde(rename_all = \"camelCase\", default)]\n pub struct CargoFeatures {\n     /// Do not activate the `default` feature.\n@@ -38,6 +38,12 @@ pub struct CargoFeatures {\n     pub features: Vec<String>,\n }\n \n+impl Default for CargoFeatures {\n+    fn default() -> Self {\n+        CargoFeatures { no_default_features: false, all_features: true, features: Vec::new() }\n+    }\n+}\n+\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct Package(RawId);\n impl_arena_id!(Package);"}]}