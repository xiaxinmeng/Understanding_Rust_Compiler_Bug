{"sha": "87fa38910eb78c116cd34b2524edd9c1cfe97228", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ZmEzODkxMGViNzhjMTE2Y2QzNGIyNTI0ZWRkOWMxY2ZlOTcyMjg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-15T12:53:34Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-15T13:17:14Z"}, "message": "Make storing returned references in a by-reference local work\n\n    fn f(a: {x: str}) -> &str {\n        ret a.x;\n    }\n\n    fn main() {\n        let x = {x: \"hi\"};\n        let &y = f(x); // Look ma, no copy!\n        log_err y;\n    }\n\nIssue #918.", "tree": {"sha": "3c8903899875037a14975ef46ec207a2a24476f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c8903899875037a14975ef46ec207a2a24476f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87fa38910eb78c116cd34b2524edd9c1cfe97228", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87fa38910eb78c116cd34b2524edd9c1cfe97228", "html_url": "https://github.com/rust-lang/rust/commit/87fa38910eb78c116cd34b2524edd9c1cfe97228", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87fa38910eb78c116cd34b2524edd9c1cfe97228/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25787bd2b887edcd7749268b6d0d1376312714d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/25787bd2b887edcd7749268b6d0d1376312714d1", "html_url": "https://github.com/rust-lang/rust/commit/25787bd2b887edcd7749268b6d0d1376312714d1"}], "stats": {"total": 86, "additions": 47, "deletions": 39}, "files": [{"sha": "fe3f153fcd5d726d6e62e437376d44566546a35c", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/87fa38910eb78c116cd34b2524edd9c1cfe97228/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87fa38910eb78c116cd34b2524edd9c1cfe97228/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=87fa38910eb78c116cd34b2524edd9c1cfe97228", "patch": "@@ -182,13 +182,35 @@ fn add_bindings_for_let(cx: ctx, &bs: [binding], loc: @ast::local) {\n                 (loc.span, \"can not move into a by-reference binding\");\n         }\n         let root = expr_root(cx.tcx, init.expr, false);\n+        let outer_ds = *root.ds;\n         let root_var = path_def_id(cx, root.ex);\n-        // FIXME also allow by-ref function calls\n-        if is_none(root_var) {\n+        let is_temp = is_none(root_var);\n+        if is_temp {\n+            alt root.ex.node {\n+              ast::expr_call(f, args) {\n+                let fty = ty::type_autoderef(cx.tcx, ty::expr_ty(cx.tcx, f));\n+                let ret_style = ty::ty_fn_ret_style(cx.tcx, fty);\n+                if ast_util::ret_by_ref(ret_style) {\n+                    // FIXME pick right arg\n+                    let arg_root = expr_root(cx.tcx, args[0], false);\n+                    root_var = path_def_id(cx, arg_root.ex);\n+                    if !is_none(root_var) {\n+                        is_temp = false;\n+                        if ret_style == ast::return_ref(true) {\n+                            outer_ds = [@{mut: true with *arg_root.ds[0]}];\n+                        }\n+                        outer_ds = *arg_root.ds + outer_ds;\n+                    }\n+                }\n+              }\n+              _ {}\n+            }\n+        }\n+        if is_temp {\n             cx.tcx.sess.span_err(loc.span, \"a reference binding can't be \\\n                                             rooted in a temporary\");\n         }\n-        for proot in *pattern_roots(cx.tcx, *root.ds, loc.node.pat) {\n+        for proot in *pattern_roots(cx.tcx, outer_ds, loc.node.pat) {\n             let bnd = mk_binding(cx, proot.id, proot.span, root_var,\n                                  inner_mut(proot.ds));\n             // Don't implicitly copy explicit references"}, {"sha": "dafb91c25d73b3a964280834ea114e8c2a3721fd", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/87fa38910eb78c116cd34b2524edd9c1cfe97228/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87fa38910eb78c116cd34b2524edd9c1cfe97228/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=87fa38910eb78c116cd34b2524edd9c1cfe97228", "patch": "@@ -2731,7 +2731,7 @@ fn trans_for_each(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n       ast::expr_call(f, args) {\n         let pair =\n             create_real_fn_pair(cx, iter_body_llty, lliterbody, llenv.ptr);\n-        r = trans_call(cx, f, some(pair), args, seq.id);\n+        r = trans_call(cx, f, some(pair), args, seq.id).res;\n         ret rslt(r.bcx, C_nil());\n       }\n     }\n@@ -3089,6 +3089,12 @@ fn trans_lval_gen(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n           }\n         }\n       }\n+      ast::expr_call(f, args) {\n+        let {res: {bcx, val}, by_ref} =\n+            trans_call(cx, f, none, args, e.id);\n+        if by_ref { ret lval_mem(bcx, val); }\n+        else { ret lval_val(bcx, val); }\n+      }\n       _ {\n         ret {res: trans_expr(cx, e),\n              is_mem: false,\n@@ -3623,7 +3629,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n \n fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n               lliterbody: option::t<ValueRef>, args: [@ast::expr],\n-              id: ast::node_id) -> result {\n+              id: ast::node_id) -> {res: result, by_ref: bool} {\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n     // with trans_call.\n@@ -3690,8 +3696,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n           none. {\n             if !ty::type_is_nil(bcx_tcx(cx), ret_ty) {\n                 if by_ref {\n-                    let retptr = Load(bcx, llretslot);\n-                    retval = load_if_immediate(bcx, retptr, ret_ty);\n+                    retval = Load(bcx, llretslot);\n                 } else {\n                     retval = load_if_immediate(bcx, llretslot, ret_ty);\n                     // Retval doesn't correspond to anything really tangible\n@@ -3720,7 +3725,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n         Br(bcx, next_cx.llbb);\n         bcx = next_cx;\n     }\n-    ret rslt(bcx, retval);\n+    ret {res: rslt(bcx, retval), by_ref: by_ref};\n }\n \n fn invoke(bcx: @block_ctxt, llfn: ValueRef,\n@@ -3887,9 +3892,6 @@ fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n     // Fixme Fill in cx.sp\n     alt e.node {\n       ast::expr_lit(lit) { ret trans_lit(cx, *lit); }\n-      ast::expr_unary(op, x) {\n-        if op != ast::deref { ret trans_unary(cx, op, x, e.id); }\n-      }\n       ast::expr_binary(op, x, y) { ret trans_binary(cx, op, x, y); }\n       ast::expr_if(cond, thn, els) {\n         ret with_out_method(bind trans_if(cx, cond, thn, els, _), cx, e.id,\n@@ -4044,9 +4046,6 @@ fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n         ret rslt(bcx, C_nil());\n       }\n       ast::expr_bind(f, args) { ret trans_bind(cx, f, args, e.id); }\n-      ast::expr_call(f, args) {\n-        ret trans_call(cx, f, none::<ValueRef>, args, e.id);\n-      }\n       ast::expr_cast(val, _) { ret trans_cast(cx, val, e.id); }\n       ast::expr_vec(args, _) { ret tvec::trans_vec(cx, args, e.id); }\n       ast::expr_rec(args, base) { ret trans_rec(cx, args, base, e.id); }\n@@ -4092,21 +4091,18 @@ fn trans_expr_out(cx: @block_ctxt, e: @ast::expr, output: out_method) ->\n       ast::expr_anon_obj(anon_obj) {\n         ret trans_anon_obj(cx, e.span, anon_obj, e.id);\n       }\n-      _ {\n-        // The expression is an lvalue. Fall through.\n-        assert (ty::is_lval(e));\n-        // make sure it really is and that we\n-        // didn't forget to add a case for a new expr!\n+      ast::expr_call(_, _) | ast::expr_field(_, _) | ast::expr_index(_, _) |\n+      ast::expr_path(_) | ast::expr_unary(ast::deref., _) {\n+        let t = ty::expr_ty(bcx_tcx(cx), e);\n+        let sub = trans_lval(cx, e);\n+        let v = sub.res.val;\n+        if sub.is_mem { v = load_if_immediate(sub.res.bcx, v, t); }\n+        ret rslt(sub.res.bcx, v);\n+      }\n+      ast::expr_unary(op, x) {\n+        ret trans_unary(cx, op, x, e.id);\n       }\n     }\n-    // lval cases fall through to trans_lval and then\n-    // possibly load the result (if it's non-structural).\n-\n-    let t = ty::expr_ty(bcx_tcx(cx), e);\n-    let sub = trans_lval(cx, e);\n-    let v = sub.res.val;\n-    if sub.is_mem { v = load_if_immediate(sub.res.bcx, v, t); }\n-    ret rslt(sub.res.bcx, v);\n }\n \n fn with_out_method(work: fn(out_method) -> result, cx: @block_ctxt,\n@@ -4517,7 +4513,8 @@ fn init_ref_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     let init_expr = option::get(local.node.init).expr;\n     let val = trans_lval(bcx, init_expr);\n     assert val.is_mem;\n-    ret trans_alt::bind_irrefutable_pat(bcx, local.node.pat, val.res.val,\n+    ret trans_alt::bind_irrefutable_pat(val.res.bcx, local.node.pat,\n+                                        val.res.val,\n                                         bcx.fcx.lllocals, false);\n }\n "}, {"sha": "6fbe21e60de08f9a3569a3ad0a8b448e53948364", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/87fa38910eb78c116cd34b2524edd9c1cfe97228/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87fa38910eb78c116cd34b2524edd9c1cfe97228/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=87fa38910eb78c116cd34b2524edd9c1cfe97228", "patch": "@@ -50,7 +50,6 @@ export fm_general;\n export get_element_type;\n export hash_ty;\n export idx_nil;\n-export is_lval;\n export is_binopable;\n export is_pred_ty;\n export lookup_item_type;\n@@ -1713,16 +1712,6 @@ fn sort_methods(meths: [method]) -> [method] {\n     ret std::sort::merge_sort::<method>(bind method_lteq(_, _), meths);\n }\n \n-fn is_lval(expr: @ast::expr) -> bool {\n-    alt expr.node {\n-      ast::expr_field(_, _) { ret true; }\n-      ast::expr_index(_, _) { ret true; }\n-      ast::expr_path(_) { ret true; }\n-      ast::expr_unary(ast::deref., _) { ret true; }\n-      _ { ret false; }\n-    }\n-}\n-\n fn occurs_check_fails(tcx: ctxt, sp: option::t<span>, vid: int, rt: t) ->\n    bool {\n     if !type_contains_vars(tcx, rt) {"}]}