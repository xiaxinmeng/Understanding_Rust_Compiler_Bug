{"sha": "606f50c46dd9a3852d36456d2015e1ccf832642e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNmY1MGM0NmRkOWEzODUyZDM2NDU2ZDIwMTVlMWNjZjgzMjY0MmU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-03-30T13:27:13Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-03-31T01:16:42Z"}, "message": "Lex binary and octal literals more eagerly.\n\nPreviously 0b12 was considered two tokens, 0b1 and 2, as 2 isn't a valid\nbase 2 digit. This patch changes that to collapse them into one (and\nmakes `0b12` etc. an error: 2 isn't a valid base 2 digit).\n\nThis may break some macro invocations of macros with `tt` (or syntax\nextensions) that rely on adjacent digits being separate tokens and hence\nis a\n\n[breaking-change]\n\nThe fix is to separate the tokens, e.g. `0b12` -> `0b1 2`.\n\ncc https://github.com/rust-lang/rfcs/pull/879", "tree": {"sha": "1c992543bb91d02c72328b9021202a9fdcdba01a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c992543bb91d02c72328b9021202a9fdcdba01a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/606f50c46dd9a3852d36456d2015e1ccf832642e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/606f50c46dd9a3852d36456d2015e1ccf832642e", "html_url": "https://github.com/rust-lang/rust/commit/606f50c46dd9a3852d36456d2015e1ccf832642e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/606f50c46dd9a3852d36456d2015e1ccf832642e/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f00264074fb8f7e3b603eb3469822813632a6d30", "url": "https://api.github.com/repos/rust-lang/rust/commits/f00264074fb8f7e3b603eb3469822813632a6d30", "html_url": "https://github.com/rust-lang/rust/commit/f00264074fb8f7e3b603eb3469822813632a6d30"}], "stats": {"total": 90, "additions": 75, "deletions": 15}, "files": [{"sha": "ae5c99123a574163745c43bb13ad30ea30c820ad", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/606f50c46dd9a3852d36456d2015e1ccf832642e/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606f50c46dd9a3852d36456d2015e1ccf832642e/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=606f50c46dd9a3852d36456d2015e1ccf832642e", "patch": "@@ -621,7 +621,7 @@ impl<'a> StringReader<'a> {\n         let base = 10;\n \n         // find the integer representing the name\n-        self.scan_digits(base);\n+        self.scan_digits(base, base);\n         let encoded_name : u32 = self.with_str_from(start_bpos, |s| {\n             num::from_str_radix(s, 10).unwrap_or_else(|_| {\n                 panic!(\"expected digits representing a name, got {:?}, {}, range [{:?},{:?}]\",\n@@ -639,7 +639,7 @@ impl<'a> StringReader<'a> {\n \n         // find the integer representing the ctxt\n         let start_bpos = self.last_pos;\n-        self.scan_digits(base);\n+        self.scan_digits(base, base);\n         let encoded_ctxt : ast::SyntaxContext = self.with_str_from(start_bpos, |s| {\n             num::from_str_radix(s, 10).unwrap_or_else(|_| {\n                 panic!(\"expected digits representing a ctxt, got {:?}, {}\", s, whence);\n@@ -653,16 +653,28 @@ impl<'a> StringReader<'a> {\n                      ctxt: encoded_ctxt, }\n     }\n \n-    /// Scan through any digits (base `radix`) or underscores, and return how\n-    /// many digits there were.\n-    fn scan_digits(&mut self, radix: u32) -> usize {\n+    /// Scan through any digits (base `scan_radix`) or underscores,\n+    /// and return how many digits there were.\n+    ///\n+    /// `real_radix` represents the true radix of the number we're\n+    /// interested in, and errors will be emitted for any digits\n+    /// between `real_radix` and `scan_radix`.\n+    fn scan_digits(&mut self, real_radix: u32, scan_radix: u32) -> usize {\n+        assert!(real_radix <= scan_radix);\n         let mut len = 0;\n         loop {\n             let c = self.curr;\n             if c == Some('_') { debug!(\"skipping a _\"); self.bump(); continue; }\n-            match c.and_then(|cc| cc.to_digit(radix)) {\n+            match c.and_then(|cc| cc.to_digit(scan_radix)) {\n                 Some(_) => {\n                     debug!(\"{:?} in scan_digits\", c);\n+                    // check that the hypothetical digit is actually\n+                    // in range for the true radix\n+                    if c.unwrap().to_digit(real_radix).is_none() {\n+                        self.err_span_(self.last_pos, self.pos,\n+                                       &format!(\"invalid digit for a base {} literal\",\n+                                                real_radix));\n+                    }\n                     len += 1;\n                     self.bump();\n                 }\n@@ -681,19 +693,19 @@ impl<'a> StringReader<'a> {\n \n         if c == '0' {\n             match self.curr.unwrap_or('\\0') {\n-                'b' => { self.bump(); base = 2; num_digits = self.scan_digits(2); }\n-                'o' => { self.bump(); base = 8; num_digits = self.scan_digits(8); }\n-                'x' => { self.bump(); base = 16; num_digits = self.scan_digits(16); }\n+                'b' => { self.bump(); base = 2; num_digits = self.scan_digits(2, 10); }\n+                'o' => { self.bump(); base = 8; num_digits = self.scan_digits(8, 10); }\n+                'x' => { self.bump(); base = 16; num_digits = self.scan_digits(16, 16); }\n                 '0'...'9' | '_' | '.' => {\n-                    num_digits = self.scan_digits(10) + 1;\n+                    num_digits = self.scan_digits(10, 10) + 1;\n                 }\n                 _ => {\n                     // just a 0\n                     return token::Integer(self.name_from(start_bpos));\n                 }\n             }\n         } else if c.is_digit(10) {\n-            num_digits = self.scan_digits(10) + 1;\n+            num_digits = self.scan_digits(10, 10) + 1;\n         } else {\n             num_digits = 0;\n         }\n@@ -712,7 +724,7 @@ impl<'a> StringReader<'a> {\n             // with a number\n             self.bump();\n             if self.curr.unwrap_or('\\0').is_digit(10) {\n-                self.scan_digits(10);\n+                self.scan_digits(10, 10);\n                 self.scan_float_exponent();\n             }\n             let last_pos = self.last_pos;\n@@ -935,7 +947,7 @@ impl<'a> StringReader<'a> {\n             if self.curr_is('-') || self.curr_is('+') {\n                 self.bump();\n             }\n-            if self.scan_digits(10) == 0 {\n+            if self.scan_digits(10, 10) == 0 {\n                 self.err_span_(self.last_pos, self.pos, \"expected at least one digit in exponent\")\n             }\n         }"}, {"sha": "f8820999c9d8174a6dfc57cd5290cb379bd8e724", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/606f50c46dd9a3852d36456d2015e1ccf832642e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606f50c46dd9a3852d36456d2015e1ccf832642e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=606f50c46dd9a3852d36456d2015e1ccf832642e", "patch": "@@ -735,7 +735,20 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n \n     let res: u64 = match ::std::num::from_str_radix(s, base).ok() {\n         Some(r) => r,\n-        None => { sd.span_err(sp, \"int literal is too large\"); 0 }\n+        None => {\n+            // small bases are lexed as if they were base 10, e.g, the string\n+            // might be `0b10201`. This will cause the conversion above to fail,\n+            // but these cases have errors in the lexer: we don't want to emit\n+            // two errors, and we especially don't want to emit this error since\n+            // it isn't necessarily true.\n+            let already_errored = base < 10 &&\n+                s.chars().any(|c| c.to_digit(10).map_or(false, |d| d >= base));\n+\n+            if !already_errored {\n+                sd.span_err(sp, \"int literal is too large\");\n+            }\n+            0\n+        }\n     };\n \n     // adjust the sign"}, {"sha": "00fb2808faa95124227431a325a22660525b0f8b", "filename": "src/test/parse-fail/issue-1802-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/606f50c46dd9a3852d36456d2015e1ccf832642e/src%2Ftest%2Fparse-fail%2Fissue-1802-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606f50c46dd9a3852d36456d2015e1ccf832642e/src%2Ftest%2Fparse-fail%2Fissue-1802-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-1802-1.rs?ref=606f50c46dd9a3852d36456d2015e1ccf832642e", "patch": "@@ -10,5 +10,5 @@\n \n // error-pattern:no valid digits found for number\n fn main() {\n-    log(error, 0b42);\n+    log(error, 0b);\n }"}, {"sha": "e92000c54ba343633cf645b8612be55883a0ffc4", "filename": "src/test/parse-fail/lex-bad-binary-literal.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/606f50c46dd9a3852d36456d2015e1ccf832642e/src%2Ftest%2Fparse-fail%2Flex-bad-binary-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606f50c46dd9a3852d36456d2015e1ccf832642e/src%2Ftest%2Fparse-fail%2Flex-bad-binary-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Flex-bad-binary-literal.rs?ref=606f50c46dd9a3852d36456d2015e1ccf832642e", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    0b121; //~ ERROR invalid digit for a base 2 literal\n+    0b10_10301; //~ ERROR invalid digit for a base 2 literal\n+    0b30; //~ ERROR invalid digit for a base 2 literal\n+    0b41; //~ ERROR invalid digit for a base 2 literal\n+    0b5; //~ ERROR invalid digit for a base 2 literal\n+    0b6; //~ ERROR invalid digit for a base 2 literal\n+    0b7; //~ ERROR invalid digit for a base 2 literal\n+    0b8; //~ ERROR invalid digit for a base 2 literal\n+    0b9; //~ ERROR invalid digit for a base 2 literal\n+}"}, {"sha": "bf9880cb6cfbfb174997b6cde6a912ba1533a253", "filename": "src/test/parse-fail/lex-bad-octal-literal.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/606f50c46dd9a3852d36456d2015e1ccf832642e/src%2Ftest%2Fparse-fail%2Flex-bad-octal-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/606f50c46dd9a3852d36456d2015e1ccf832642e/src%2Ftest%2Fparse-fail%2Flex-bad-octal-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Flex-bad-octal-literal.rs?ref=606f50c46dd9a3852d36456d2015e1ccf832642e", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    0o18; //~ ERROR invalid digit for a base 8 literal\n+    0o1234_9_5670;  //~ ERROR invalid digit for a base 8 literal\n+}"}]}