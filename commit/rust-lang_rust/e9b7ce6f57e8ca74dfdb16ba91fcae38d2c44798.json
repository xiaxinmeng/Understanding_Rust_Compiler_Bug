{"sha": "e9b7ce6f57e8ca74dfdb16ba91fcae38d2c44798", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5YjdjZTZmNTdlOGNhNzRkZmRiMTZiYTkxZmNhZTM4ZDJjNDQ3OTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-28T18:59:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-28T19:00:42Z"}, "message": "refactor send_map impl to be based on structs", "tree": {"sha": "e9e23b39166a41b2abbef382c2a433530935c200", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9e23b39166a41b2abbef382c2a433530935c200"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9b7ce6f57e8ca74dfdb16ba91fcae38d2c44798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9b7ce6f57e8ca74dfdb16ba91fcae38d2c44798", "html_url": "https://github.com/rust-lang/rust/commit/e9b7ce6f57e8ca74dfdb16ba91fcae38d2c44798", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9b7ce6f57e8ca74dfdb16ba91fcae38d2c44798/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0031617f30f159df2cef301c9d574cd219e16b16", "url": "https://api.github.com/repos/rust-lang/rust/commits/0031617f30f159df2cef301c9d574cd219e16b16", "html_url": "https://github.com/rust-lang/rust/commit/0031617f30f159df2cef301c9d574cd219e16b16"}], "stats": {"total": 66, "additions": 47, "deletions": 19}, "files": [{"sha": "12d3583aef151e0626f0b781738f0e25e1cf24bb", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 47, "deletions": 19, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e9b7ce6f57e8ca74dfdb16ba91fcae38d2c44798/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b7ce6f57e8ca74dfdb16ba91fcae38d2c44798/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=e9b7ce6f57e8ca74dfdb16ba91fcae38d2c44798", "patch": "@@ -13,19 +13,38 @@ Sendable hash maps.  Very much a work in progress.\n type HashFn<K> = pure fn~(K) -> uint;\n type EqFn<K> = pure fn~(K, K) -> bool;\n \n+trait send_map<K, V: copy> {\n+    // FIXME(#3148)  ^^^^ once find_ref() works, we can drop V:copy\n+\n+    fn insert(&mut self, +k: K, +v: V) -> bool;\n+    fn remove(&mut self, k: &K) -> bool;\n+    fn clear(&mut self);\n+    pure fn len(&const self) -> uint;\n+    pure fn is_empty(&const self) -> bool;\n+    fn contains_key(&const self, k: &K) -> bool;\n+    fn each_ref(&self, blk: fn(k: &K, v: &V) -> bool);\n+    fn each_key_ref(&self, blk: fn(k: &K) -> bool);\n+    fn each_value_ref(&self, blk: fn(v: &V) -> bool);\n+    fn find(&const self, k: &K) -> Option<V>;\n+    fn get(&const self, k: &K) -> V;\n+}\n+\n /// Open addressing with linear probing.\n mod linear {\n     export LinearMap, linear_map, linear_map_with_capacity, public_methods;\n \n     const initial_capacity: uint = 32u; // 2^5\n-    type Bucket<K,V> = {hash: uint, key: K, value: V};\n-    enum LinearMap<K,V> {\n-        LinearMap_({\n-            hashfn: pure fn~(x: &K) -> uint,\n-            eqfn: pure fn~(x: &K, y: &K) -> bool,\n-            resize_at: uint,\n-            size: uint,\n-            buckets: ~[Option<Bucket<K,V>>]})\n+    struct Bucket<K,V> {\n+        hash: uint;\n+        key: K;\n+        value: V;\n+    }\n+    struct LinearMap<K,V> {\n+        hashfn: pure fn~(x: &K) -> uint;\n+        eqfn: pure fn~(x: &K, y: &K) -> bool;\n+        resize_at: uint;\n+        size: uint;\n+        buckets: ~[Option<Bucket<K,V>>];\n     }\n \n     // FIXME(#3148) -- we could rewrite found_entry\n@@ -51,12 +70,13 @@ mod linear {\n         +eqfn: pure fn~(x: &K, y: &K) -> bool,\n         initial_capacity: uint) -> LinearMap<K,V> {\n \n-        LinearMap_({\n+        LinearMap {\n             hashfn: hashfn,\n             eqfn: eqfn,\n             resize_at: resize_at(initial_capacity),\n             size: 0,\n-            buckets: vec::from_fn(initial_capacity, |_i| None)})\n+            buckets: vec::from_fn(initial_capacity, |_i| None)\n+        }\n     }\n \n     priv impl<K, V> LinearMap<K,V> {\n@@ -136,15 +156,19 @@ mod linear {\n             for uint::range(0, old_capacity) |i| {\n                 let mut bucket = None;\n                 bucket <-> old_buckets[i];\n-                if bucket.is_some() {\n-                    self.insert_bucket(bucket);\n-                }\n+                self.insert_opt_bucket(bucket);\n             }\n         }\n \n-        fn insert_bucket(&mut self, +bucket: Option<Bucket<K,V>>) {\n-            let {hash, key, value} <- option::unwrap(bucket);\n-            let _ = self.insert_internal(hash, key, value);\n+        fn insert_opt_bucket(&mut self, +bucket: Option<Bucket<K,V>>) {\n+            match move bucket {\n+              Some(Bucket {hash: move hash,\n+                           key: move key,\n+                           value: move value}) => {\n+                self.insert_internal(hash, key, value);\n+              }\n+              None => {}\n+            }\n         }\n \n         /// Inserts the key value pair into the buckets.\n@@ -156,14 +180,18 @@ mod linear {\n               FoundHole(idx) => {\n                 debug!(\"insert fresh (%?->%?) at idx %?, hash %?\",\n                        k, v, idx, hash);\n-                self.buckets[idx] = Some({hash: hash, key: k, value: v});\n+                self.buckets[idx] = Some(Bucket {hash: hash,\n+                                                 key: k,\n+                                                 value: v});\n                 self.size += 1;\n                 return true;\n               }\n               FoundEntry(idx) => {\n                 debug!(\"insert overwrite (%?->%?) at idx %?, hash %?\",\n                        k, v, idx, hash);\n-                self.buckets[idx] = Some({hash: hash, key: k, value: v});\n+                self.buckets[idx] = Some(Bucket {hash: hash,\n+                                                 key: k,\n+                                                 value: v});\n                 return false;\n               }\n             }\n@@ -223,7 +251,7 @@ mod linear {\n             while self.buckets[idx].is_some() {\n                 let mut bucket = None;\n                 bucket <-> self.buckets[idx];\n-                self.insert_bucket(bucket);\n+                self.insert_opt_bucket(bucket);\n                 idx = self.next_bucket(idx, len_buckets);\n             }\n             self.size -= 1;"}]}