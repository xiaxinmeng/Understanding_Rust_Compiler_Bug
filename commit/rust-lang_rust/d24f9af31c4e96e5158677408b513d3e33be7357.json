{"sha": "d24f9af31c4e96e5158677408b513d3e33be7357", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNGY5YWYzMWM0ZTk2ZTUxNTg2Nzc0MDhiNTEzZDNlMzNiZTczNTc=", "commit": {"author": {"name": "Gilad Naaman", "email": "gilad.naaman@gmail.com", "date": "2017-11-08T04:06:16Z"}, "committer": {"name": "Gilad Naaman", "email": "gilad.naaman@gmail.com", "date": "2018-01-26T17:46:04Z"}, "message": "Refactoring needed in order to have test json output.", "tree": {"sha": "c3ff05111217cd576a8e8e19026fead2e7a54f14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3ff05111217cd576a8e8e19026fead2e7a54f14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d24f9af31c4e96e5158677408b513d3e33be7357", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d24f9af31c4e96e5158677408b513d3e33be7357", "html_url": "https://github.com/rust-lang/rust/commit/d24f9af31c4e96e5158677408b513d3e33be7357", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d24f9af31c4e96e5158677408b513d3e33be7357/comments", "author": null, "committer": null, "parents": [{"sha": "a97cd17f5d71fb4ec362f4fbd79373a6e7ed7b82", "url": "https://api.github.com/repos/rust-lang/rust/commits/a97cd17f5d71fb4ec362f4fbd79373a6e7ed7b82", "html_url": "https://github.com/rust-lang/rust/commit/a97cd17f5d71fb4ec362f4fbd79373a6e7ed7b82"}], "stats": {"total": 540, "additions": 308, "deletions": 232}, "files": [{"sha": "4454e7ed115c23d09c85422209730ee36f1d30bb", "filename": "src/libtest/formatters.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/d24f9af31c4e96e5158677408b513d3e33be7357/src%2Flibtest%2Fformatters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d24f9af31c4e96e5158677408b513d3e33be7357/src%2Flibtest%2Fformatters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters.rs?ref=d24f9af31c4e96e5158677408b513d3e33be7357", "patch": "@@ -0,0 +1,246 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+pub(crate) trait OutputFormatter {\n+    fn write_run_start(&mut self, len: usize) -> io::Result<()>;\n+    fn write_test_start(&mut self,\n+        test: &TestDesc,\n+        align: NamePadding,\n+        max_name_len: usize) -> io::Result<()>;\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()>;\n+    fn write_result(&mut self, result: &TestResult) -> io::Result<()>;\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool>;\n+}\n+\n+pub(crate) struct HumanFormatter<T> {\n+    out: OutputLocation<T>,\n+    terse: bool,\n+    use_color: bool,\n+    test_count: usize,\n+}\n+\n+impl<T: Write> HumanFormatter<T> {\n+    pub fn new(out: OutputLocation<T>, use_color: bool, terse: bool) -> Self {\n+        HumanFormatter {\n+            out,\n+            terse,\n+            use_color,\n+            test_count: 0,\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    pub fn output_location(&self) -> &OutputLocation<T> {\n+        &self.out\n+    }\n+\n+    pub fn write_ok(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"ok\", \".\", term::color::GREEN)\n+    }\n+\n+    pub fn write_failed(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"FAILED\", \"F\", term::color::RED)\n+    }\n+\n+    pub fn write_ignored(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"ignored\", \"i\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"FAILED (allowed)\", \"a\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_bench(&mut self) -> io::Result<()> {\n+        self.write_pretty(\"bench\", term::color::CYAN)\n+    }\n+\n+    pub fn write_short_result(&mut self, verbose: &str, quiet: &str, color: term::color::Color)\n+                              -> io::Result<()> {\n+        if self.terse {\n+            self.write_pretty(quiet, color)?;\n+            if self.test_count % QUIET_MODE_MAX_COLUMN == QUIET_MODE_MAX_COLUMN - 1 {\n+                // we insert a new line every 100 dots in order to flush the\n+                // screen when dealing with line-buffered output (e.g. piping to\n+                // `stamp` in the rust CI).\n+                self.write_plain(\"\\n\")?;\n+            }\n+            \n+            self.test_count += 1;\n+            Ok(())\n+        } else {\n+            self.write_pretty(verbose, color)?;\n+            self.write_plain(\"\\n\")\n+        }\n+    }\n+\n+    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n+        match self.out {\n+            Pretty(ref mut term) => {\n+                if self.use_color {\n+                    term.fg(color)?;\n+                }\n+                term.write_all(word.as_bytes())?;\n+                if self.use_color {\n+                    term.reset()?;\n+                }\n+                term.flush()\n+            }\n+            Raw(ref mut stdout) => {\n+                stdout.write_all(word.as_bytes())?;\n+                stdout.flush()\n+            }\n+        }\n+    }\n+\n+    pub fn write_plain<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n+        let s = s.as_ref();\n+        self.out.write_all(s.as_bytes())?;\n+        self.out.flush()\n+    }\n+\n+    pub fn write_outputs(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        let mut successes = Vec::new();\n+        let mut stdouts = String::new();\n+        for &(ref f, ref stdout) in &state.not_failures {\n+            successes.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                stdouts.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                stdouts.push_str(&output);\n+                stdouts.push_str(\"\\n\");\n+            }\n+        }\n+        if !stdouts.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&stdouts)?;\n+        }\n+\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        successes.sort();\n+        for name in &successes {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn write_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_plain(\"\\nfailures:\\n\")?;\n+        let mut failures = Vec::new();\n+        let mut fail_out = String::new();\n+        for &(ref f, ref stdout) in &state.failures {\n+            failures.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                fail_out.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                fail_out.push_str(&output);\n+                fail_out.push_str(\"\\n\");\n+            }\n+        }\n+        if !fail_out.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&fail_out)?;\n+        }\n+\n+        self.write_plain(\"\\nfailures:\\n\")?;\n+        failures.sort();\n+        for name in &failures {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<T: Write> OutputFormatter for HumanFormatter<T> {\n+    fn write_run_start(&mut self, len: usize) -> io::Result<()> {\n+        let noun = if len != 1 {\n+            \"tests\"\n+        } else {\n+            \"test\"\n+        };\n+        self.write_plain(&format!(\"\\nrunning {} {}\\n\", len, noun))\n+    }\n+\n+    fn write_test_start(&mut self,\n+                        test: &TestDesc,\n+                        align: NamePadding,\n+                        max_name_len: usize) -> io::Result<()> {\n+        if self.terse && align != PadOnRight {\n+            Ok(())\n+        }\n+        else {\n+            let name = test.padded_name(max_name_len, align);\n+            self.write_plain(&format!(\"test {} ... \", name))\n+        }\n+    }\n+\n+    fn write_result(&mut self, result: &TestResult) -> io::Result<()> {\n+        match *result {\n+            TrOk => self.write_ok(),\n+            TrFailed | TrFailedMsg(_) => self.write_failed(),\n+            TrIgnored => self.write_ignored(),\n+            TrAllowedFail => self.write_allowed_fail(),\n+            TrBench(ref bs) => {\n+                self.write_bench()?;\n+                self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n+            }\n+        }\n+    }\n+\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        self.write_plain(&format!(\"test {} has been running for over {} seconds\\n\",\n+                                  desc.name,\n+                                  TEST_WARN_TIMEOUT_S))\n+    }\n+\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n+        if state.options.display_output {\n+            self.write_outputs(state)?;\n+        }\n+        let success = state.failed == 0;\n+        if !success {\n+            self.write_failures(state)?;\n+        }\n+\n+        self.write_plain(\"\\ntest result: \")?;\n+\n+        if success {\n+            // There's no parallelism at this point so it's safe to use color\n+            self.write_pretty(\"ok\", term::color::GREEN)?;\n+        } else {\n+            self.write_pretty(\"FAILED\", term::color::RED)?;\n+        }\n+\n+        let s = if state.allowed_fail > 0 {\n+            format!(\n+                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\\n\\n\",\n+                state.passed,\n+                state.failed + state.allowed_fail,\n+                state.allowed_fail,\n+                state.ignored,\n+                state.measured,\n+                state.filtered_out)\n+        } else {\n+            format!(\n+                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n+                state.passed,\n+                state.failed,\n+                state.ignored,\n+                state.measured,\n+                state.filtered_out)\n+        };\n+\n+        self.write_plain(&s)?;\n+\n+        Ok(success)\n+    }\n+}"}, {"sha": "2fb62c832f8024618be6606b40a82faeb5fe0ebd", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 62, "deletions": 232, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/d24f9af31c4e96e5158677408b513d3e33be7357/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d24f9af31c4e96e5158677408b513d3e33be7357/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=d24f9af31c4e96e5158677408b513d3e33be7357", "patch": "@@ -84,6 +84,9 @@ pub mod test {\n }\n \n pub mod stats;\n+mod formatters;\n+\n+use formatters::*;\n \n // The name of a test. By convention this follows the rules for rust\n // paths; i.e. it should be a series of identifiers separated by double\n@@ -359,7 +362,8 @@ fn optgroups() -> getopts::Options {\n                                      in parallel\", \"n_threads\")\n         .optmulti(\"\", \"skip\", \"Skip tests whose names contain FILTER (this flag can \\\n                                be used multiple times)\",\"FILTER\")\n-        .optflag(\"q\", \"quiet\", \"Display one character per test instead of one line\")\n+        .optflag(\"q\", \"quiet\", \"Display one character per test instead of one line.\\\n+                                Equivalent to --format=terse\")\n         .optflag(\"\", \"exact\", \"Exactly match filters rather than by substring\")\n         .optopt(\"\", \"color\", \"Configure coloring of output:\n             auto   = colorize if stdout is a tty and tests are run on serially (default);\n@@ -507,11 +511,24 @@ enum OutputLocation<T> {\n     Raw(T),\n }\n \n-struct ConsoleTestState<T> {\n+impl<T: Write> Write for OutputLocation<T> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        match *self {\n+            Pretty(ref mut term) => term.write(buf),\n+            Raw(ref mut stdout) => stdout.write(buf)\n+        }\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        match *self {\n+            Pretty(ref mut term) => term.flush(),\n+            Raw(ref mut stdout) => stdout.flush()\n+        }\n+    }\n+}\n+\n+struct ConsoleTestState {\n     log_out: Option<File>,\n-    out: OutputLocation<T>,\n-    use_color: bool,\n-    quiet: bool,\n     total: usize,\n     passed: usize,\n     failed: usize,\n@@ -526,22 +543,15 @@ struct ConsoleTestState<T> {\n     options: Options,\n }\n \n-impl<T: Write> ConsoleTestState<T> {\n-    pub fn new(opts: &TestOpts, _: Option<T>) -> io::Result<ConsoleTestState<io::Stdout>> {\n+impl ConsoleTestState {\n+    pub fn new(opts: &TestOpts) -> io::Result<ConsoleTestState> {\n         let log_out = match opts.logfile {\n             Some(ref path) => Some(File::create(path)?),\n             None => None,\n         };\n-        let out = match term::stdout() {\n-            None => Raw(io::stdout()),\n-            Some(t) => Pretty(t),\n-        };\n \n         Ok(ConsoleTestState {\n-            out,\n             log_out,\n-            use_color: use_color(opts),\n-            quiet: opts.quiet,\n             total: 0,\n             passed: 0,\n             failed: 0,\n@@ -557,114 +567,6 @@ impl<T: Write> ConsoleTestState<T> {\n         })\n     }\n \n-    pub fn write_ok(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"ok\", \".\", term::color::GREEN)\n-    }\n-\n-    pub fn write_failed(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"FAILED\", \"F\", term::color::RED)\n-    }\n-\n-    pub fn write_ignored(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"ignored\", \"i\", term::color::YELLOW)\n-    }\n-\n-    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"FAILED (allowed)\", \"a\", term::color::YELLOW)\n-    }\n-\n-    pub fn write_bench(&mut self) -> io::Result<()> {\n-        self.write_pretty(\"bench\", term::color::CYAN)\n-    }\n-\n-    pub fn write_short_result(&mut self, verbose: &str, quiet: &str, color: term::color::Color)\n-                              -> io::Result<()> {\n-        if self.quiet {\n-            self.write_pretty(quiet, color)?;\n-            if self.current_test_count() % QUIET_MODE_MAX_COLUMN == QUIET_MODE_MAX_COLUMN - 1 {\n-                // we insert a new line every 100 dots in order to flush the\n-                // screen when dealing with line-buffered output (e.g. piping to\n-                // `stamp` in the rust CI).\n-                self.write_plain(\"\\n\")?;\n-            }\n-            Ok(())\n-        } else {\n-            self.write_pretty(verbose, color)?;\n-            self.write_plain(\"\\n\")\n-        }\n-    }\n-\n-    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n-        match self.out {\n-            Pretty(ref mut term) => {\n-                if self.use_color {\n-                    term.fg(color)?;\n-                }\n-                term.write_all(word.as_bytes())?;\n-                if self.use_color {\n-                    term.reset()?;\n-                }\n-                term.flush()\n-            }\n-            Raw(ref mut stdout) => {\n-                stdout.write_all(word.as_bytes())?;\n-                stdout.flush()\n-            }\n-        }\n-    }\n-\n-    pub fn write_plain<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n-        let s = s.as_ref();\n-        match self.out {\n-            Pretty(ref mut term) => {\n-                term.write_all(s.as_bytes())?;\n-                term.flush()\n-            }\n-            Raw(ref mut stdout) => {\n-                stdout.write_all(s.as_bytes())?;\n-                stdout.flush()\n-            }\n-        }\n-    }\n-\n-    pub fn write_run_start(&mut self, len: usize) -> io::Result<()> {\n-        self.total = len;\n-        let noun = if len != 1 {\n-            \"tests\"\n-        } else {\n-            \"test\"\n-        };\n-        self.write_plain(&format!(\"\\nrunning {} {}\\n\", len, noun))\n-    }\n-\n-    pub fn write_test_start(&mut self, test: &TestDesc, align: NamePadding) -> io::Result<()> {\n-        if self.quiet && align != PadOnRight {\n-            Ok(())\n-        } else {\n-            let name = test.padded_name(self.max_name_len, align);\n-            self.write_plain(&format!(\"test {} ... \", name))\n-        }\n-    }\n-\n-    pub fn write_result(&mut self, result: &TestResult) -> io::Result<()> {\n-        match *result {\n-            TrOk => self.write_ok(),\n-            TrFailed | TrFailedMsg(_) => self.write_failed(),\n-            TrIgnored => self.write_ignored(),\n-            TrAllowedFail => self.write_allowed_fail(),\n-            TrBench(ref bs) => {\n-                self.write_bench()?;\n-                self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n-            }\n-        }\n-    }\n-\n-    pub fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.write_plain(&format!(\"test {} has been running for over {} seconds\\n\",\n-                                  desc.name,\n-                                  TEST_WARN_TIMEOUT_S))\n-    }\n-\n     pub fn write_log<S: AsRef<str>>(&mut self, msg: S) -> io::Result<()> {\n         let msg = msg.as_ref();\n         match self.log_out {\n@@ -687,101 +589,9 @@ impl<T: Write> ConsoleTestState<T> {\n                     test.name))\n     }\n \n-    pub fn write_failures(&mut self) -> io::Result<()> {\n-        self.write_plain(\"\\nfailures:\\n\")?;\n-        let mut failures = Vec::new();\n-        let mut fail_out = String::new();\n-        for &(ref f, ref stdout) in &self.failures {\n-            failures.push(f.name.to_string());\n-            if !stdout.is_empty() {\n-                fail_out.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n-                let output = String::from_utf8_lossy(stdout);\n-                fail_out.push_str(&output);\n-                fail_out.push_str(\"\\n\");\n-            }\n-        }\n-        if !fail_out.is_empty() {\n-            self.write_plain(\"\\n\")?;\n-            self.write_plain(&fail_out)?;\n-        }\n-\n-        self.write_plain(\"\\nfailures:\\n\")?;\n-        failures.sort();\n-        for name in &failures {\n-            self.write_plain(&format!(\"    {}\\n\", name))?;\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn write_outputs(&mut self) -> io::Result<()> {\n-        self.write_plain(\"\\nsuccesses:\\n\")?;\n-        let mut successes = Vec::new();\n-        let mut stdouts = String::new();\n-        for &(ref f, ref stdout) in &self.not_failures {\n-            successes.push(f.name.to_string());\n-            if !stdout.is_empty() {\n-                stdouts.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n-                let output = String::from_utf8_lossy(stdout);\n-                stdouts.push_str(&output);\n-                stdouts.push_str(\"\\n\");\n-            }\n-        }\n-        if !stdouts.is_empty() {\n-            self.write_plain(\"\\n\")?;\n-            self.write_plain(&stdouts)?;\n-        }\n-\n-        self.write_plain(\"\\nsuccesses:\\n\")?;\n-        successes.sort();\n-        for name in &successes {\n-            self.write_plain(&format!(\"    {}\\n\", name))?;\n-        }\n-        Ok(())\n-    }\n-\n     fn current_test_count(&self) -> usize {\n         self.passed + self.failed + self.ignored + self.measured + self.allowed_fail\n     }\n-\n-    pub fn write_run_finish(&mut self) -> io::Result<bool> {\n-        assert!(self.current_test_count() == self.total);\n-\n-        if self.options.display_output {\n-            self.write_outputs()?;\n-        }\n-        let success = self.failed == 0;\n-        if !success {\n-            self.write_failures()?;\n-        }\n-\n-        self.write_plain(\"\\ntest result: \")?;\n-        if success {\n-            // There's no parallelism at this point so it's safe to use color\n-            self.write_pretty(\"ok\", term::color::GREEN)?;\n-        } else {\n-            self.write_pretty(\"FAILED\", term::color::RED)?;\n-        }\n-        let s = if self.allowed_fail > 0 {\n-            format!(\n-                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\\n\\n\",\n-                self.passed,\n-                self.failed + self.allowed_fail,\n-                self.allowed_fail,\n-                self.ignored,\n-                self.measured,\n-                self.filtered_out)\n-        } else {\n-            format!(\n-                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n-                self.passed,\n-                self.failed,\n-                self.ignored,\n-                self.measured,\n-                self.filtered_out)\n-        };\n-        self.write_plain(&s)?;\n-        return Ok(success);\n-    }\n }\n \n // Format a number with thousands separators\n@@ -827,7 +637,12 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n \n // List the tests to console, and optionally to logfile. Filters are honored.\n pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<()> {\n-    let mut st = ConsoleTestState::new(opts, None::<io::Stdout>)?;\n+    let output = match term::stdout() {\n+        None => Raw(io::stdout()),\n+        Some(t) => Pretty(t),\n+    };\n+    let mut out = HumanFormatter::new(output, use_color(opts), opts.quiet);\n+    let mut st = ConsoleTestState::new(opts)?;\n \n     let mut ntest = 0;\n     let mut nbench = 0;\n@@ -842,7 +657,7 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n             StaticBenchFn(..) | DynBenchFn(..) => { nbench += 1; \"benchmark\" },\n         };\n \n-        st.write_plain(format!(\"{}: {}\\n\", name, fntype))?;\n+        out.write_plain(format!(\"{}: {}\\n\", name, fntype))?;\n         st.write_log(format!(\"{} {}\\n\", fntype, name))?;\n     }\n \n@@ -868,15 +683,21 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n \n-    fn callback<T: Write>(event: &TestEvent, st: &mut ConsoleTestState<T>) -> io::Result<()> {\n+    fn callback(event: &TestEvent,\n+                st: &mut ConsoleTestState,\n+                out: &mut OutputFormatter) -> io::Result<()> {\n+\n         match (*event).clone() {\n-            TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n+            TeFiltered(ref filtered_tests) => {\n+                st.total = filtered_tests.len();\n+                out.write_run_start(filtered_tests.len())\n+            },\n             TeFilteredOut(filtered_out) => Ok(st.filtered_out = filtered_out),\n-            TeWait(ref test, padding) => st.write_test_start(test, padding),\n-            TeTimeout(ref test) => st.write_timeout(test),\n+            TeWait(ref test, padding) => out.write_test_start(test, padding, st.max_name_len),\n+            TeTimeout(ref test) => out.write_timeout(test),\n             TeResult(test, result, stdout) => {\n                 st.write_log_result(&test, &result)?;\n-                st.write_result(&result)?;\n+                out.write_result(&result)?;\n                 match result {\n                     TrOk => {\n                         st.passed += 1;\n@@ -908,7 +729,14 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         }\n     }\n \n-    let mut st = ConsoleTestState::new(opts, None::<io::Stdout>)?;\n+    let output = match term::stdout() {\n+        None => Raw(io::stdout()),\n+        Some(t) => Pretty(t),\n+    };\n+\n+    let mut out = HumanFormatter::new(output, use_color(opts), opts.quiet);\n+\n+    let mut st = ConsoleTestState::new(opts)?;\n     fn len_if_padded(t: &TestDescAndFn) -> usize {\n         match t.testfn.padding() {\n             PadNone => 0,\n@@ -919,8 +747,11 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         let n = t.desc.name.as_slice();\n         st.max_name_len = n.len();\n     }\n-    run_tests(opts, tests, |x| callback(&x, &mut st))?;\n-    return st.write_run_finish();\n+    run_tests(opts, tests, |x| callback(&x, &mut st, &mut out))?;\n+\n+    assert!(st.current_test_count() == st.total);\n+\n+    return out.write_run_finish(&st);\n }\n \n #[test]\n@@ -939,11 +770,10 @@ fn should_sort_failures_before_printing_them() {\n         allow_fail: false,\n     };\n \n-    let mut st = ConsoleTestState {\n+    let mut out = HumanFormatter::new(Raw(Vec::new()), false, false);\n+\n+    let st = ConsoleTestState {\n         log_out: None,\n-        out: Raw(Vec::new()),\n-        use_color: false,\n-        quiet: false,\n         total: 0,\n         passed: 0,\n         failed: 0,\n@@ -958,10 +788,10 @@ fn should_sort_failures_before_printing_them() {\n         not_failures: Vec::new(),\n     };\n \n-    st.write_failures().unwrap();\n-    let s = match st.out {\n-        Raw(ref m) => String::from_utf8_lossy(&m[..]),\n-        Pretty(_) => unreachable!(),\n+    out.write_failures(&st).unwrap();\n+    let s = match out.output_location() {\n+        &Raw(ref m) => String::from_utf8_lossy(&m[..]),\n+        &Pretty(_) => unreachable!(),\n     };\n \n     let apos = s.find(\"a\").unwrap();"}]}