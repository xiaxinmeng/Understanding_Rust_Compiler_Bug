{"sha": "f7e86a5a490427bfc0b29fa5ebaaaac9ff1375f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ZTg2YTVhNDkwNDI3YmZjMGIyOWZhNWViYWFhYWM5ZmYxMzc1ZjM=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-05-05T10:16:56Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-03T13:55:29Z"}, "message": "Improve cannot move errors\n\n* Show the place and type being moved\n* Give a special error for variables in match guard\n* Simplify search for overloaded deref\n* Search for overloaded index", "tree": {"sha": "6981107f502936adad3c51eeacb3d9b956a786ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6981107f502936adad3c51eeacb3d9b956a786ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7e86a5a490427bfc0b29fa5ebaaaac9ff1375f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7e86a5a490427bfc0b29fa5ebaaaac9ff1375f3", "html_url": "https://github.com/rust-lang/rust/commit/f7e86a5a490427bfc0b29fa5ebaaaac9ff1375f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7e86a5a490427bfc0b29fa5ebaaaac9ff1375f3/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f309f917c21f371a1cff8f917518aa29e2f6b850", "url": "https://api.github.com/repos/rust-lang/rust/commits/f309f917c21f371a1cff8f917518aa29e2f6b850", "html_url": "https://github.com/rust-lang/rust/commit/f309f917c21f371a1cff8f917518aa29e2f6b850"}], "stats": {"total": 529, "additions": 320, "deletions": 209}, "files": [{"sha": "27486df196753bb21a93ba4c3a5cff9191c83cb4", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 317, "deletions": 200, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/f7e86a5a490427bfc0b29fa5ebaaaac9ff1375f3/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7e86a5a490427bfc0b29fa5ebaaaac9ff1375f3/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=f7e86a5a490427bfc0b29fa5ebaaaac9ff1375f3", "patch": "@@ -1,8 +1,7 @@\n use core::unicode::property::Pattern_White_Space;\n-use std::fmt::{self, Display};\n \n use rustc::mir::*;\n-use rustc::ty;\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc_errors::{DiagnosticBuilder,Applicability};\n use syntax_pos::Span;\n \n@@ -55,20 +54,66 @@ enum GroupedMoveError<'tcx> {\n     },\n }\n \n-enum BorrowedContentSource {\n-    Arc,\n-    Rc,\n+enum BorrowedContentSource<'tcx> {\n     DerefRawPointer,\n-    Other,\n+    DerefMutableRef,\n+    DerefSharedRef,\n+    OverloadedDeref(Ty<'tcx>),\n+    OverloadedIndex(Ty<'tcx>),\n }\n \n-impl Display for BorrowedContentSource {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+impl BorrowedContentSource<'tcx> {\n+    fn describe_for_unnamed_place(&self) -> String {\n         match *self {\n-            BorrowedContentSource::Arc => write!(f, \"an `Arc`\"),\n-            BorrowedContentSource::Rc => write!(f, \"an `Rc`\"),\n-            BorrowedContentSource::DerefRawPointer => write!(f, \"dereference of raw pointer\"),\n-            BorrowedContentSource::Other => write!(f, \"borrowed content\"),\n+            BorrowedContentSource::DerefRawPointer => format!(\"a raw pointer\"),\n+            BorrowedContentSource::DerefSharedRef => format!(\"a shared reference\"),\n+            BorrowedContentSource::DerefMutableRef => {\n+                format!(\"a mutable reference\")\n+            }\n+            BorrowedContentSource::OverloadedDeref(ty) => {\n+                if ty.is_rc() {\n+                   format!(\"an `Rc`\")\n+                } else if ty.is_arc() {\n+                    format!(\"an `Arc`\")\n+                } else {\n+                    format!(\"dereference of `{}`\", ty)\n+                }\n+            }\n+            BorrowedContentSource::OverloadedIndex(ty) => format!(\"index of `{}`\", ty),\n+        }\n+    }\n+\n+    fn describe_for_named_place(&self) -> Option<&'static str> {\n+        match *self {\n+            BorrowedContentSource::DerefRawPointer => Some(\"raw pointer\"),\n+            BorrowedContentSource::DerefSharedRef => Some(\"shared reference\"),\n+            BorrowedContentSource::DerefMutableRef => Some(\"mutable reference\"),\n+            // Overloaded deref and index operators should be evaluated into a\n+            // temporary. So we don't need a description here.\n+            BorrowedContentSource::OverloadedDeref(_)\n+            | BorrowedContentSource::OverloadedIndex(_) => None\n+        }\n+    }\n+\n+    fn from_call(func: Ty<'tcx>, tcx: TyCtxt<'_, '_, 'tcx>) -> Option<Self> {\n+        match func.sty {\n+            ty::FnDef(def_id, substs) => {\n+                let trait_id = tcx.trait_of_item(def_id)?;\n+\n+                let lang_items = tcx.lang_items();\n+                if Some(trait_id) == lang_items.deref_trait()\n+                    || Some(trait_id) == lang_items.deref_mut_trait()\n+                {\n+                    Some(BorrowedContentSource::OverloadedDeref(substs.type_at(0)))\n+                } else if Some(trait_id) == lang_items.index_trait()\n+                    || Some(trait_id) == lang_items.index_mut_trait()\n+                {\n+                    Some(BorrowedContentSource::OverloadedIndex(substs.type_at(0)))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n         }\n     }\n }\n@@ -248,109 +293,194 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         (span, original_path, kind)\n                     },\n                 };\n-            let origin = Origin::Mir;\n             debug!(\"report: original_path={:?} span={:?}, kind={:?} \\\n                    original_path.is_upvar_field_projection={:?}\", original_path, span, kind,\n                    self.is_upvar_field_projection(original_path));\n-            let err = match kind {\n-                IllegalMoveOriginKind::Static => {\n-                    self.infcx.tcx.cannot_move_out_of(span, \"static item\", origin)\n-                }\n-                IllegalMoveOriginKind::BorrowedContent { target_place: place } => {\n-                    // Inspect the type of the content behind the\n-                    // borrow to provide feedback about why this\n-                    // was a move rather than a copy.\n-                    let ty = place.ty(self.mir, self.infcx.tcx).ty;\n-                    let is_upvar_field_projection =\n-                        self.prefixes(&original_path, PrefixSet::All)\n-                        .any(|p| self.is_upvar_field_projection(p).is_some());\n-                    debug!(\"report: ty={:?}\", ty);\n-                    let mut err = match ty.sty {\n-                        ty::Array(..) | ty::Slice(..) =>\n-                            self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n-                                span, ty, None, origin\n-                            ),\n-                        ty::Closure(def_id, closure_substs)\n-                            if def_id == self.mir_def_id && is_upvar_field_projection\n-                        => {\n-                            let closure_kind_ty =\n-                                closure_substs.closure_kind_ty(def_id, self.infcx.tcx);\n-                            let closure_kind = closure_kind_ty.to_opt_closure_kind();\n-                            let place_description = match closure_kind {\n-                                Some(ty::ClosureKind::Fn) => {\n-                                    \"captured variable in an `Fn` closure\"\n-                                }\n-                                Some(ty::ClosureKind::FnMut) => {\n-                                    \"captured variable in an `FnMut` closure\"\n-                                }\n-                                Some(ty::ClosureKind::FnOnce) => {\n-                                    bug!(\"closure kind does not match first argument type\")\n-                                }\n-                                None => bug!(\"closure kind not inferred by borrowck\"),\n-                            };\n-                            debug!(\"report: closure_kind_ty={:?} closure_kind={:?} \\\n-                                    place_description={:?}\", closure_kind_ty, closure_kind,\n-                                    place_description);\n-\n-                            let mut diag = self.infcx.tcx.cannot_move_out_of(\n-                                span, place_description, origin);\n-\n-                            for prefix in self.prefixes(&original_path, PrefixSet::All) {\n-                                if let Some(field) = self.is_upvar_field_projection(prefix) {\n-                                    let upvar_hir_id = self.upvars[field.index()].var_hir_id;\n-                                    let upvar_span = self.infcx.tcx.hir().span_by_hir_id(\n-                                        upvar_hir_id);\n-                                    diag.span_label(upvar_span, \"captured outer variable\");\n-                                    break;\n-                                }\n-                            }\n-\n-                            diag\n-                        }\n-                        _ => {\n-                            let source = self.borrowed_content_source(place);\n-                            self.infcx.tcx.cannot_move_out_of(\n-                                span, &source.to_string(), origin\n-                            )\n-                        },\n-                    };\n-                    let orig_path_ty = format!(\n-                        \"{:?}\",\n-                        original_path.ty(self.mir, self.infcx.tcx).ty,\n-                    );\n-                    let snippet = self.infcx.tcx.sess.source_map().span_to_snippet(span).unwrap();\n-                    let is_option = orig_path_ty.starts_with(\"std::option::Option\");\n-                    let is_result = orig_path_ty.starts_with(\"std::result::Result\");\n-                    if  is_option || is_result {\n-                        err.span_suggestion(\n+            (\n+                match kind {\n+                    IllegalMoveOriginKind::Static => {\n+                        self.report_cannot_move_from_static(original_path, span)\n+                    }\n+                    IllegalMoveOriginKind::BorrowedContent { target_place } => {\n+                        self.report_cannot_move_from_borrowed_content(\n+                            original_path,\n+                            target_place,\n                             span,\n-                            &format!(\"consider borrowing the `{}`'s content\", if is_option {\n-                                \"Option\"\n-                            } else {\n-                                \"Result\"\n-                            }),\n-                            format!(\"{}.as_ref()\", snippet),\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                        )\n                     }\n-                    err\n-                }\n-                IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n-                    self.infcx.tcx\n-                        .cannot_move_out_of_interior_of_drop(span, ty, origin)\n-                }\n-                IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } =>\n-                    self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n-                        span, ty, Some(*is_index), origin\n-                    ),\n-            };\n-            (err, span)\n+                    IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n+                        self.infcx.tcx\n+                            .cannot_move_out_of_interior_of_drop(span, ty, Origin::Mir)\n+                    }\n+                    IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } =>\n+                        self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n+                            span, ty, Some(*is_index), Origin::Mir\n+                        ),\n+                },\n+                span,\n+            )\n         };\n \n         self.add_move_hints(error, &mut err, err_span);\n         err.buffer(&mut self.errors_buffer);\n     }\n \n+    fn report_cannot_move_from_static(\n+        &mut self,\n+        place: &Place<'tcx>,\n+        span: Span\n+    ) -> DiagnosticBuilder<'a> {\n+        let mut base_static = place;\n+        loop {\n+            match base_static {\n+                Place::Base(_) => break,\n+                Place::Projection(box Projection { base, .. }) => base_static = base,\n+            }\n+        }\n+\n+        let description = if let Place::Base(_) = place {\n+            format!(\"static item `{}`\", self.describe_place(place).unwrap())\n+        } else {\n+            format!(\n+                \"`{:?}` as `{:?}` is a static item\",\n+                self.describe_place(place).unwrap(),\n+                self.describe_place(base_static).unwrap(),\n+            )\n+        };\n+\n+        self.infcx.tcx.cannot_move_out_of(span, &description, Origin::Mir)\n+    }\n+\n+    fn report_cannot_move_from_borrowed_content(\n+        &mut self,\n+        move_place: &Place<'tcx>,\n+        deref_target_place: &Place<'tcx>,\n+        span: Span,\n+    ) -> DiagnosticBuilder<'a> {\n+        let origin = Origin::Mir;\n+\n+        // Inspect the type of the content behind the\n+        // borrow to provide feedback about why this\n+        // was a move rather than a copy.\n+        let ty = deref_target_place.ty(self.mir, self.infcx.tcx).ty;\n+        let upvar_field = self.prefixes(&move_place, PrefixSet::All)\n+            .find_map(|p| self.is_upvar_field_projection(p));\n+\n+        let deref_base = match deref_target_place {\n+            Place::Projection(box Projection { base, elem: ProjectionElem::Deref }) => base,\n+            _ => bug!(\"deref_target_place is not a deref projection\"),\n+        };\n+\n+        if let Place::Base(PlaceBase::Local(local)) = *deref_base {\n+            let decl = &self.mir.local_decls[local];\n+            if decl.is_ref_for_guard() {\n+                let mut err = self.infcx.tcx.cannot_move_out_of(\n+                    span,\n+                    &format!(\"`{}` in pattern guard\", decl.name.unwrap()),\n+                    origin,\n+                );\n+                err.note(\n+                    \"variables bound in patterns cannot be moved from \\\n+                     until after the end of the pattern guard\");\n+                return err;\n+            }\n+        }\n+\n+        debug!(\"report: ty={:?}\", ty);\n+        let mut err = match ty.sty {\n+            ty::Array(..) | ty::Slice(..) =>\n+                self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n+                    span, ty, None, origin\n+                ),\n+            ty::Closure(def_id, closure_substs)\n+                if def_id == self.mir_def_id && upvar_field.is_some()\n+            => {\n+                let closure_kind_ty = closure_substs.closure_kind_ty(def_id, self.infcx.tcx);\n+                let closure_kind = closure_kind_ty.to_opt_closure_kind();\n+                let capture_description = match closure_kind {\n+                    Some(ty::ClosureKind::Fn) => {\n+                        \"captured variable in an `Fn` closure\"\n+                    }\n+                    Some(ty::ClosureKind::FnMut) => {\n+                        \"captured variable in an `FnMut` closure\"\n+                    }\n+                    Some(ty::ClosureKind::FnOnce) => {\n+                        bug!(\"closure kind does not match first argument type\")\n+                    }\n+                    None => bug!(\"closure kind not inferred by borrowck\"),\n+                };\n+\n+                let upvar = &self.upvars[upvar_field.unwrap().index()];\n+                let upvar_hir_id = upvar.var_hir_id;\n+                let upvar_name = upvar.name;\n+                let upvar_span = self.infcx.tcx.hir().span_by_hir_id(upvar_hir_id);\n+\n+                let place_name = self.describe_place(move_place).unwrap();\n+\n+                let place_description = if self.is_upvar_field_projection(move_place).is_some() {\n+                    format!(\"`{}`, a {}\", place_name, capture_description)\n+                } else {\n+                    format!(\n+                        \"`{}`, as `{}` is a {}\",\n+                        place_name,\n+                        upvar_name,\n+                        capture_description,\n+                    )\n+                };\n+\n+                debug!(\n+                    \"report: closure_kind_ty={:?} closure_kind={:?} place_description={:?}\",\n+                    closure_kind_ty, closure_kind, place_description,\n+                );\n+\n+                let mut diag = self.infcx.tcx.cannot_move_out_of(span, &place_description, origin);\n+\n+                diag.span_label(upvar_span, \"captured outer variable\");\n+\n+                diag\n+            }\n+            _ => {\n+                let source = self.borrowed_content_source(deref_base);\n+                match (self.describe_place(move_place), source.describe_for_named_place()) {\n+                    (Some(place_desc), Some(source_desc)) => {\n+                        self.infcx.tcx.cannot_move_out_of(\n+                            span,\n+                            &format!(\"`{}` which is behind a {}\", place_desc, source_desc),\n+                            origin,\n+                        )\n+                    }\n+                    (_, _) => {\n+                        self.infcx.tcx.cannot_move_out_of(\n+                            span,\n+                            &source.describe_for_unnamed_place(),\n+                            origin,\n+                        )\n+                    }\n+                }\n+            },\n+        };\n+        let move_ty = format!(\n+            \"{:?}\",\n+            move_place.ty(self.mir, self.infcx.tcx).ty,\n+        );\n+        let snippet = self.infcx.tcx.sess.source_map().span_to_snippet(span).unwrap();\n+        let is_option = move_ty.starts_with(\"std::option::Option\");\n+        let is_result = move_ty.starts_with(\"std::result::Result\");\n+        if  is_option || is_result {\n+            err.span_suggestion(\n+                span,\n+                &format!(\"consider borrowing the `{}`'s content\", if is_option {\n+                    \"Option\"\n+                } else {\n+                    \"Result\"\n+                }),\n+                format!(\"{}.as_ref()\", snippet),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+        err\n+    }\n+\n     fn add_move_hints(\n         &self,\n         error: GroupedMoveError<'tcx>,\n@@ -391,9 +521,25 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     );\n                 }\n \n-                binds_to.sort();\n-                binds_to.dedup();\n-                self.add_move_error_details(err, &binds_to);\n+                if binds_to.is_empty() {\n+                    let place_ty = move_from.ty(self.mir, self.infcx.tcx).ty;\n+                    let place_desc = match self.describe_place(&move_from) {\n+                        Some(desc) => format!(\"`{}`\", desc),\n+                        None => format!(\"value\"),\n+                    };\n+\n+                    self.note_type_does_not_implement_copy(\n+                        err,\n+                        &place_desc,\n+                        place_ty,\n+                        Some(span)\n+                    );\n+                } else {\n+                    binds_to.sort();\n+                    binds_to.dedup();\n+\n+                    self.add_move_error_details(err, &binds_to);\n+                }\n             }\n             GroupedMoveError::MovesFromValue { mut binds_to, .. } => {\n                 binds_to.sort();\n@@ -402,7 +548,19 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 self.add_move_error_details(err, &binds_to);\n             }\n             // No binding. Nothing to suggest.\n-            GroupedMoveError::OtherIllegalMove { .. } => (),\n+            GroupedMoveError::OtherIllegalMove { ref original_path, span, .. } => {\n+                let place_ty = original_path.ty(self.mir, self.infcx.tcx).ty;\n+                let place_desc = match self.describe_place(original_path) {\n+                    Some(desc) => format!(\"`{}`\", desc),\n+                    None => format!(\"value\"),\n+                };\n+                self.note_type_does_not_implement_copy(\n+                    err,\n+                    &place_desc,\n+                    place_ty,\n+                    Some(span),\n+                );\n+            },\n         }\n     }\n \n@@ -493,105 +651,64 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn borrowed_content_source(&self, place: &Place<'tcx>) -> BorrowedContentSource {\n-        // Look up the provided place and work out the move path index for it,\n-        // we'll use this to work back through where this value came from and check whether it\n-        // was originally part of an `Rc` or `Arc`.\n-        let initial_mpi = match self.move_data.rev_lookup.find(place) {\n-            LookupResult::Exact(mpi) | LookupResult::Parent(Some(mpi)) => mpi,\n-            _ => return BorrowedContentSource::Other,\n-        };\n-\n-        let mut queue = vec![initial_mpi];\n-        let mut visited = Vec::new();\n-        debug!(\"borrowed_content_source: queue={:?}\", queue);\n-        while let Some(mpi) = queue.pop() {\n-            debug!(\n-                \"borrowed_content_source: mpi={:?} queue={:?} visited={:?}\",\n-                mpi, queue, visited\n-            );\n+    fn borrowed_content_source(&self, deref_base: &Place<'tcx>) -> BorrowedContentSource<'tcx> {\n+        let tcx = self.infcx.tcx;\n \n-            // Don't visit the same path twice.\n-            if visited.contains(&mpi) {\n-                continue;\n-            }\n-            visited.push(mpi);\n-\n-            for i in &self.move_data.init_path_map[mpi] {\n-                let init = &self.move_data.inits[*i];\n-                debug!(\"borrowed_content_source: init={:?}\", init);\n-                // We're only interested in statements that initialized a value, not the\n-                // initializations from arguments.\n-                let loc = match init.location {\n-                    InitLocation::Statement(stmt) => stmt,\n-                    _ => continue,\n-                };\n+        // Look up the provided place and work out the move path index for it,\n+        // we'll use this to check whether it was originally from an overloaded\n+        // operator.\n+        match self.move_data.rev_lookup.find(deref_base) {\n+            LookupResult::Exact(mpi) | LookupResult::Parent(Some(mpi)) => {\n+                debug!(\"borrowed_content_source: mpi={:?}\", mpi);\n+\n+                for i in &self.move_data.init_path_map[mpi] {\n+                    let init = &self.move_data.inits[*i];\n+                    debug!(\"borrowed_content_source: init={:?}\", init);\n+                    // We're only interested in statements that initialized a value, not the\n+                    // initializations from arguments.\n+                    let loc = match init.location {\n+                        InitLocation::Statement(stmt) => stmt,\n+                        _ => continue,\n+                    };\n \n-                let bbd = &self.mir[loc.block];\n-                let is_terminator = bbd.statements.len() == loc.statement_index;\n-                debug!(\"borrowed_content_source: loc={:?} is_terminator={:?}\", loc, is_terminator);\n-                if !is_terminator {\n-                    let stmt = &bbd.statements[loc.statement_index];\n-                    debug!(\"borrowed_content_source: stmt={:?}\", stmt);\n-                    // We're only interested in assignments (in particular, where the\n-                    // assignment came from - was it an `Rc` or `Arc`?).\n-                    if let StatementKind::Assign(_, box Rvalue::Ref(_, _, source)) = &stmt.kind {\n-                        let ty = source.ty(self.mir, self.infcx.tcx).ty;\n-                        let ty = match ty.sty {\n-                            ty::Ref(_, ty, _) => ty,\n-                            _ => ty,\n-                        };\n-                        debug!(\"borrowed_content_source: ty={:?}\", ty);\n-\n-                        if ty.is_arc() {\n-                            return BorrowedContentSource::Arc;\n-                        } else if ty.is_rc() {\n-                            return BorrowedContentSource::Rc;\n-                        } else {\n-                            queue.push(init.path);\n-                        }\n-                    }\n-                } else if let Some(Terminator {\n-                    kind: TerminatorKind::Call { args, .. },\n-                    ..\n-                }) = &bbd.terminator {\n-                    for arg in args {\n-                        let source = match arg {\n-                            Operand::Copy(place) | Operand::Move(place) => place,\n-                            _ => continue,\n-                        };\n-\n-                        let ty = source.ty(self.mir, self.infcx.tcx).ty;\n-                        let ty = match ty.sty {\n-                            ty::Ref(_, ty, _) => ty,\n-                            _ => ty,\n-                        };\n-                        debug!(\"borrowed_content_source: ty={:?}\", ty);\n-\n-                        if ty.is_arc() {\n-                            return BorrowedContentSource::Arc;\n-                        } else if ty.is_rc() {\n-                            return BorrowedContentSource::Rc;\n-                        } else {\n-                            queue.push(init.path);\n+                    let bbd = &self.mir[loc.block];\n+                    let is_terminator = bbd.statements.len() == loc.statement_index;\n+                    debug!(\n+                        \"borrowed_content_source: loc={:?} is_terminator={:?}\",\n+                        loc,\n+                        is_terminator,\n+                    );\n+                    if !is_terminator {\n+                        continue;\n+                    } else if let Some(Terminator {\n+                        kind: TerminatorKind::Call {\n+                            ref func,\n+                            from_hir_call: false,\n+                            ..\n+                        },\n+                        ..\n+                    }) = bbd.terminator {\n+                        if let Some(source)\n+                            = BorrowedContentSource::from_call(func.ty(self.mir, tcx), tcx)\n+                        {\n+                            return source;\n                         }\n                     }\n                 }\n             }\n-        }\n+            // Base is a `static` so won't be from an overloaded operator\n+            _ => (),\n+        };\n \n-        // If we didn't find an `Arc` or an `Rc`, then check specifically for\n-        // a dereference of a place that has the type of a raw pointer.\n-        // We can't use `place.ty(..).to_ty(..)` here as that strips away the raw pointer.\n-        if let Place::Projection(box Projection {\n-            base,\n-            elem: ProjectionElem::Deref,\n-        }) = place {\n-            if base.ty(self.mir, self.infcx.tcx).ty.is_unsafe_ptr() {\n-                return BorrowedContentSource::DerefRawPointer;\n-            }\n+        // If we didn't find an overloaded deref or index, then assume it's a\n+        // built in deref and check the type of the base.\n+        let base_ty = deref_base.ty(self.mir, tcx).ty;\n+        if base_ty.is_unsafe_ptr() {\n+            BorrowedContentSource::DerefRawPointer\n+        } else if base_ty.is_mutable_pointer() {\n+            BorrowedContentSource::DerefMutableRef\n+        } else {\n+            BorrowedContentSource::DerefSharedRef\n         }\n-\n-        BorrowedContentSource::Other\n     }\n }"}, {"sha": "37df368f3b72560cbf2db8d66552c13bbd5d75bc", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7e86a5a490427bfc0b29fa5ebaaaac9ff1375f3/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7e86a5a490427bfc0b29fa5ebaaaac9ff1375f3/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=f7e86a5a490427bfc0b29fa5ebaaaac9ff1375f3", "patch": "@@ -399,18 +399,14 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         move_from_desc: &str,\n         o: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n-        let mut err = struct_span_err!(\n+        let err = struct_span_err!(\n             self,\n             move_from_span,\n             E0507,\n             \"cannot move out of {}{OGN}\",\n             move_from_desc,\n             OGN = o\n         );\n-        err.span_label(\n-            move_from_span,\n-            format!(\"cannot move out of {}\", move_from_desc),\n-        );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n@@ -434,8 +430,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n             self,\n             move_from_span,\n             E0508,\n-            \"cannot move out of type `{}`, \\\n-             a non-copy {}{OGN}\",\n+            \"cannot move out of type `{}`, a non-copy {}{OGN}\",\n             ty,\n             type_name,\n             OGN = o\n@@ -455,8 +450,7 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n             self,\n             move_from_span,\n             E0509,\n-            \"cannot move out of type `{}`, \\\n-             which implements the `Drop` trait{OGN}\",\n+            \"cannot move out of type `{}`, which implements the `Drop` trait{OGN}\",\n             container_ty,\n             OGN = o\n         );"}]}