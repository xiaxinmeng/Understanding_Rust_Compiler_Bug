{"sha": "5b995397dba72b9afeb621eef17479b8538f235a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViOTk1Mzk3ZGJhNzJiOWFmZWI2MjFlZWYxNzQ3OWI4NTM4ZjIzNWE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-06T07:36:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-06T07:36:36Z"}, "message": "Rollup merge of #63676 - newpavlov:wasi, r=alexcrichton\n\nUse wasi crate for Core API\n\nBlocked by: CraneStation/rust-wasi#5\n\nBlocks: rust-lang/libc#1461\n\ncc @sunfishcode @alexcrichton", "tree": {"sha": "f7f136ae6e28ff944d6c3bc94b4a834bb63d0e09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7f136ae6e28ff944d6c3bc94b4a834bb63d0e09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b995397dba72b9afeb621eef17479b8538f235a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdcgyECRBK7hj4Ov3rIwAAdHIIABNAZ5h6WUn5ZMX+I3z5lEj5\nchwHgQV8Pww9MYpL8wMlmRzzn7HlE6PWHyvF+hrNVv6tVkpOCKLI+PFRv7bTJdWA\nq/UgebR9t486wZsOFCV4phMoVi99uxPQsr2F8Cae/Ha5f88Q3hmh3LgEbvqSPS5r\n2uKOAWy0XyK/alOUeYuibwYXwGyPLeyrrhUsjjnFljMiBddjyKgnRU4BPiSdE3cs\nRW2Fil40gMvuLO4e7rpmcqoTmAfDEzuBxT3gw1vhswrXabuU6z2rSxaKFRfBNvBV\nNs67emvdticgaM6IY0wDbLv2bbdDghxxhNmRaMJTSVJQuRZqAvVWCwC1QTGMlJM=\n=fy4u\n-----END PGP SIGNATURE-----\n", "payload": "tree f7f136ae6e28ff944d6c3bc94b4a834bb63d0e09\nparent 6b5f9b2e973e438fc1726a2d164d046acd80b170\nparent 0662fcf4f950ec2800f0b1e02254ef2389b55079\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1567755396 +0200\ncommitter GitHub <noreply@github.com> 1567755396 +0200\n\nRollup merge of #63676 - newpavlov:wasi, r=alexcrichton\n\nUse wasi crate for Core API\n\nBlocked by: CraneStation/rust-wasi#5\n\nBlocks: rust-lang/libc#1461\n\ncc @sunfishcode @alexcrichton\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b995397dba72b9afeb621eef17479b8538f235a", "html_url": "https://github.com/rust-lang/rust/commit/5b995397dba72b9afeb621eef17479b8538f235a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b995397dba72b9afeb621eef17479b8538f235a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b5f9b2e973e438fc1726a2d164d046acd80b170", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b5f9b2e973e438fc1726a2d164d046acd80b170", "html_url": "https://github.com/rust-lang/rust/commit/6b5f9b2e973e438fc1726a2d164d046acd80b170"}, {"sha": "0662fcf4f950ec2800f0b1e02254ef2389b55079", "url": "https://api.github.com/repos/rust-lang/rust/commits/0662fcf4f950ec2800f0b1e02254ef2389b55079", "html_url": "https://github.com/rust-lang/rust/commit/0662fcf4f950ec2800f0b1e02254ef2389b55079"}], "stats": {"total": 774, "additions": 340, "deletions": 434}, "files": [{"sha": "313fef1c086a871d7542c7c49823bf19fbfb5f68", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b995397dba72b9afeb621eef17479b8538f235a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5b995397dba72b9afeb621eef17479b8538f235a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5b995397dba72b9afeb621eef17479b8538f235a", "patch": "@@ -3870,6 +3870,7 @@ dependencies = [\n  \"rustc_msan\",\n  \"rustc_tsan\",\n  \"unwind\",\n+ \"wasi\",\n ]\n \n [[package]]\n@@ -4686,6 +4687,17 @@ dependencies = [\n  \"try-lock\",\n ]\n \n+[[package]]\n+name = \"wasi\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b89c3ce4ce14bdc6fb6beaf9ec7928ca331de5df7e5ea278375642a2f478570d\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"winapi\"\n version = \"0.2.8\""}, {"sha": "18a46cf0b5257e5a2692b98f0450197148830ac6", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=5b995397dba72b9afeb621eef17479b8538f235a", "patch": "@@ -56,6 +56,9 @@ dlmalloc = { version = \"0.1\", features = ['rustc-dep-of-std'] }\n [target.x86_64-fortanix-unknown-sgx.dependencies]\n fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n \n+[target.wasm32-wasi.dependencies]\n+wasi = { version = \"0.7.0\", features = ['rustc-dep-of-std', 'alloc'] }\n+\n [build-dependencies]\n cc = \"1.0\"\n "}, {"sha": "3280c4990dc66cf0444332095bf4a7574cb4526e", "filename": "src/libstd/sys/wasi/args.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs?ref=5b995397dba72b9afeb621eef17479b8538f235a", "patch": "@@ -1,11 +1,10 @@\n-use crate::ffi::CStr;\n-use crate::io;\n-use crate::sys::cvt_wasi;\n use crate::ffi::OsString;\n use crate::marker::PhantomData;\n use crate::os::wasi::ffi::OsStringExt;\n use crate::vec;\n \n+use ::wasi::wasi_unstable as wasi;\n+\n pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n }\n \n@@ -19,31 +18,17 @@ pub struct Args {\n \n /// Returns the command line arguments\n pub fn args() -> Args {\n-    maybe_args().unwrap_or_else(|_| {\n-        Args {\n-            iter: Vec::new().into_iter(),\n-            _dont_send_or_sync_me: PhantomData\n-        }\n-    })\n-}\n-\n-fn maybe_args() -> io::Result<Args> {\n-    unsafe {\n-        let (mut argc, mut argv_buf_size) = (0, 0);\n-        cvt_wasi(libc::__wasi_args_sizes_get(&mut argc, &mut argv_buf_size))?;\n-\n-        let mut argc = vec![core::ptr::null_mut::<libc::c_char>(); argc];\n-        let mut argv_buf = vec![0; argv_buf_size];\n-        cvt_wasi(libc::__wasi_args_get(argc.as_mut_ptr(), argv_buf.as_mut_ptr()))?;\n-\n-        let args = argc.into_iter()\n-            .map(|ptr| CStr::from_ptr(ptr).to_bytes().to_vec())\n-            .map(|bytes| OsString::from_vec(bytes))\n-            .collect::<Vec<_>>();\n-        Ok(Args {\n-            iter: args.into_iter(),\n-            _dont_send_or_sync_me: PhantomData,\n-        })\n+    let buf = wasi::args_sizes_get().and_then(|args_sizes| {\n+        let mut buf = Vec::with_capacity(args_sizes.get_count());\n+        wasi::args_get(args_sizes, |arg| {\n+            let arg = OsString::from_vec(arg.to_vec());\n+            buf.push(arg);\n+        })?;\n+        Ok(buf)\n+    }).unwrap_or(vec![]);\n+    Args {\n+        iter: buf.into_iter(),\n+        _dont_send_or_sync_me: PhantomData\n     }\n }\n "}, {"sha": "9fa4abfd171b5e61ac97c50283f49988bf3b76ef", "filename": "src/libstd/sys/wasi/ext/fs.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs?ref=5b995397dba72b9afeb621eef17479b8538f235a", "patch": "@@ -8,6 +8,8 @@ use crate::os::wasi::ffi::OsStrExt;\n use crate::path::{Path, PathBuf};\n use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n \n+use ::wasi::wasi_unstable as wasi;\n+\n /// WASI-specific extensions to [`File`].\n ///\n /// [`File`]: ../../../../std/fs/struct.File.html\n@@ -336,16 +338,16 @@ pub trait FileTypeExt {\n \n impl FileTypeExt for fs::FileType {\n     fn is_block_device(&self) -> bool {\n-        self.as_inner().bits() == libc::__WASI_FILETYPE_BLOCK_DEVICE\n+        self.as_inner().bits() == wasi::FILETYPE_BLOCK_DEVICE\n     }\n     fn is_character_device(&self) -> bool {\n-        self.as_inner().bits() == libc::__WASI_FILETYPE_CHARACTER_DEVICE\n+        self.as_inner().bits() == wasi::FILETYPE_CHARACTER_DEVICE\n     }\n     fn is_socket_dgram(&self) -> bool {\n-        self.as_inner().bits() == libc::__WASI_FILETYPE_SOCKET_DGRAM\n+        self.as_inner().bits() == wasi::FILETYPE_SOCKET_DGRAM\n     }\n     fn is_socket_stream(&self) -> bool {\n-        self.as_inner().bits() == libc::__WASI_FILETYPE_SOCKET_STREAM\n+        self.as_inner().bits() == wasi::FILETYPE_SOCKET_STREAM\n     }\n }\n "}, {"sha": "f1839df380112d5403e7c7ddd46a424b91c84fb0", "filename": "src/libstd/sys/wasi/ext/io.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs?ref=5b995397dba72b9afeb621eef17479b8538f235a", "patch": "@@ -8,6 +8,8 @@ use crate::sys;\n use crate::net;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n+use ::wasi::wasi_unstable as wasi;\n+\n /// Raw file descriptors.\n pub type RawFd = u32;\n \n@@ -125,18 +127,18 @@ impl IntoRawFd for fs::File {\n \n impl AsRawFd for io::Stdin {\n     fn as_raw_fd(&self) -> RawFd {\n-        libc::STDIN_FILENO as u32\n+        wasi::STDIN_FD\n     }\n }\n \n impl AsRawFd for io::Stdout {\n     fn as_raw_fd(&self) -> RawFd {\n-        libc::STDOUT_FILENO as u32\n+        wasi::STDOUT_FD\n     }\n }\n \n impl AsRawFd for io::Stderr {\n     fn as_raw_fd(&self) -> RawFd {\n-        libc::STDERR_FILENO as u32\n+        wasi::STDERR_FD\n     }\n }"}, {"sha": "5b7a8678b66eab724465219e46c4dd1f830acd10", "filename": "src/libstd/sys/wasi/fd.rs", "status": "modified", "additions": 90, "deletions": 190, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs?ref=5b995397dba72b9afeb621eef17479b8538f235a", "patch": "@@ -3,348 +3,248 @@\n use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::net::Shutdown;\n-use crate::sys::cvt_wasi;\n-use libc::{self, c_char, c_void};\n+use super::err2io;\n+use ::wasi::wasi_unstable as wasi;\n \n #[derive(Debug)]\n pub struct WasiFd {\n-    fd: libc::__wasi_fd_t,\n+    fd: wasi::Fd,\n }\n \n-// FIXME: these should probably all be fancier structs, builders, enums, etc\n-pub type LookupFlags = u32;\n-pub type FdFlags = u16;\n-pub type Advice = u8;\n-pub type Rights = u64;\n-pub type Oflags = u16;\n-pub type DirCookie = u64;\n-pub type Timestamp = u64;\n-pub type FstFlags = u16;\n-pub type RiFlags = u16;\n-pub type RoFlags = u16;\n-pub type SiFlags = u16;\n-\n-fn iovec(a: &mut [IoSliceMut<'_>]) -> (*const libc::__wasi_iovec_t, usize) {\n+fn iovec<'a>(a: &'a mut [IoSliceMut<'_>]) -> &'a [wasi::IoVec] {\n     assert_eq!(\n         mem::size_of::<IoSliceMut<'_>>(),\n-        mem::size_of::<libc::__wasi_iovec_t>()\n+        mem::size_of::<wasi::IoVec>()\n     );\n     assert_eq!(\n         mem::align_of::<IoSliceMut<'_>>(),\n-        mem::align_of::<libc::__wasi_iovec_t>()\n+        mem::align_of::<wasi::IoVec>()\n     );\n-    (a.as_ptr() as *const libc::__wasi_iovec_t, a.len())\n+    /// SAFETY: `IoSliceMut` and `IoVec` have exactly the same memory layout\n+    unsafe { mem::transmute(a) }\n }\n \n-fn ciovec(a: &[IoSlice<'_>]) -> (*const libc::__wasi_ciovec_t, usize) {\n+fn ciovec<'a>(a: &'a [IoSlice<'_>]) -> &'a [wasi::CIoVec] {\n     assert_eq!(\n         mem::size_of::<IoSlice<'_>>(),\n-        mem::size_of::<libc::__wasi_ciovec_t>()\n+        mem::size_of::<wasi::CIoVec>()\n     );\n     assert_eq!(\n         mem::align_of::<IoSlice<'_>>(),\n-        mem::align_of::<libc::__wasi_ciovec_t>()\n+        mem::align_of::<wasi::CIoVec>()\n     );\n-    (a.as_ptr() as *const libc::__wasi_ciovec_t, a.len())\n+    /// SAFETY: `IoSlice` and `CIoVec` have exactly the same memory layout\n+    unsafe { mem::transmute(a) }\n }\n \n impl WasiFd {\n-    pub unsafe fn from_raw(fd: libc::__wasi_fd_t) -> WasiFd {\n+    pub unsafe fn from_raw(fd: wasi::Fd) -> WasiFd {\n         WasiFd { fd }\n     }\n \n-    pub fn into_raw(self) -> libc::__wasi_fd_t {\n+    pub fn into_raw(self) -> wasi::Fd {\n         let ret = self.fd;\n         mem::forget(self);\n         ret\n     }\n \n-    pub fn as_raw(&self) -> libc::__wasi_fd_t {\n+    pub fn as_raw(&self) -> wasi::Fd {\n         self.fd\n     }\n \n     pub fn datasync(&self) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_datasync(self.fd) })\n+        unsafe { wasi::fd_datasync(self.fd).map_err(err2io) }\n     }\n \n     pub fn pread(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n-        let mut read = 0;\n-        let (ptr, len) = iovec(bufs);\n-        cvt_wasi(unsafe { libc::__wasi_fd_pread(self.fd, ptr, len, offset, &mut read) })?;\n-        Ok(read)\n+        unsafe { wasi::fd_pread(self.fd, iovec(bufs), offset).map_err(err2io) }\n     }\n \n     pub fn pwrite(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n-        let mut read = 0;\n-        let (ptr, len) = ciovec(bufs);\n-        cvt_wasi(unsafe { libc::__wasi_fd_pwrite(self.fd, ptr, len, offset, &mut read) })?;\n-        Ok(read)\n+        unsafe { wasi::fd_pwrite(self.fd, ciovec(bufs), offset).map_err(err2io) }\n     }\n \n     pub fn read(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        let mut read = 0;\n-        let (ptr, len) = iovec(bufs);\n-        cvt_wasi(unsafe { libc::__wasi_fd_read(self.fd, ptr, len, &mut read) })?;\n-        Ok(read)\n+        unsafe { wasi::fd_read(self.fd, iovec(bufs)).map_err(err2io) }\n     }\n \n     pub fn write(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        let mut read = 0;\n-        let (ptr, len) = ciovec(bufs);\n-        cvt_wasi(unsafe { libc::__wasi_fd_write(self.fd, ptr, len, &mut read) })?;\n-        Ok(read)\n+        unsafe { wasi::fd_write(self.fd, ciovec(bufs)).map_err(err2io) }\n     }\n \n     pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n         let (whence, offset) = match pos {\n-            SeekFrom::Start(pos) => (libc::__WASI_WHENCE_SET, pos as i64),\n-            SeekFrom::End(pos) => (libc::__WASI_WHENCE_END, pos),\n-            SeekFrom::Current(pos) => (libc::__WASI_WHENCE_CUR, pos),\n+            SeekFrom::Start(pos) => (wasi::WHENCE_SET, pos as i64),\n+            SeekFrom::End(pos) => (wasi::WHENCE_END, pos),\n+            SeekFrom::Current(pos) => (wasi::WHENCE_CUR, pos),\n         };\n-        let mut pos = 0;\n-        cvt_wasi(unsafe { libc::__wasi_fd_seek(self.fd, offset, whence, &mut pos) })?;\n-        Ok(pos)\n+        unsafe { wasi::fd_seek(self.fd, offset, whence).map_err(err2io) }\n     }\n \n     pub fn tell(&self) -> io::Result<u64> {\n-        let mut pos = 0;\n-        cvt_wasi(unsafe { libc::__wasi_fd_tell(self.fd, &mut pos) })?;\n-        Ok(pos)\n+        unsafe { wasi::fd_tell(self.fd).map_err(err2io) }\n     }\n \n     // FIXME: __wasi_fd_fdstat_get\n \n-    pub fn set_flags(&self, flags: FdFlags) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_fdstat_set_flags(self.fd, flags) })\n+    pub fn set_flags(&self, flags: wasi::FdFlags) -> io::Result<()> {\n+        unsafe { wasi::fd_fdstat_set_flags(self.fd, flags).map_err(err2io) }\n     }\n \n-    pub fn set_rights(&self, base: Rights, inheriting: Rights) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_fdstat_set_rights(self.fd, base, inheriting) })\n+    pub fn set_rights(&self, base: wasi::Rights, inheriting: wasi::Rights) -> io::Result<()> {\n+        unsafe { wasi::fd_fdstat_set_rights(self.fd, base, inheriting).map_err(err2io) }\n     }\n \n     pub fn sync(&self) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_sync(self.fd) })\n+        unsafe { wasi::fd_sync(self.fd).map_err(err2io) }\n     }\n \n-    pub fn advise(&self, offset: u64, len: u64, advice: Advice) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_advise(self.fd, offset, len, advice as u8) })\n+    pub fn advise(&self, offset: u64, len: u64, advice: wasi::Advice) -> io::Result<()> {\n+        unsafe { wasi::fd_advise(self.fd, offset, len, advice).map_err(err2io) }\n     }\n \n     pub fn allocate(&self, offset: u64, len: u64) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_allocate(self.fd, offset, len) })\n+        unsafe { wasi::fd_allocate(self.fd, offset, len).map_err(err2io) }\n     }\n \n     pub fn create_directory(&self, path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_create_directory(self.fd, path.as_ptr() as *const c_char, path.len())\n-        })\n+        unsafe { wasi::path_create_directory(self.fd, path).map_err(err2io) }\n     }\n \n     pub fn link(\n         &self,\n-        old_flags: LookupFlags,\n+        old_flags: wasi::LookupFlags,\n         old_path: &[u8],\n         new_fd: &WasiFd,\n         new_path: &[u8],\n     ) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_link(\n-                self.fd,\n-                old_flags,\n-                old_path.as_ptr() as *const c_char,\n-                old_path.len(),\n-                new_fd.fd,\n-                new_path.as_ptr() as *const c_char,\n-                new_path.len(),\n-            )\n-        })\n+        unsafe {\n+            wasi::path_link(self.fd, old_flags, old_path, new_fd.fd, new_path)\n+                .map_err(err2io)\n+        }\n     }\n \n     pub fn open(\n         &self,\n-        dirflags: LookupFlags,\n+        dirflags: wasi::LookupFlags,\n         path: &[u8],\n-        oflags: Oflags,\n-        fs_rights_base: Rights,\n-        fs_rights_inheriting: Rights,\n-        fs_flags: FdFlags,\n+        oflags: wasi::OFlags,\n+        fs_rights_base: wasi::Rights,\n+        fs_rights_inheriting: wasi::Rights,\n+        fs_flags: wasi::FdFlags,\n     ) -> io::Result<WasiFd> {\n         unsafe {\n-            let mut fd = 0;\n-            cvt_wasi(libc::__wasi_path_open(\n+            wasi::path_open(\n                 self.fd,\n                 dirflags,\n-                path.as_ptr() as *const c_char,\n-                path.len(),\n+                path,\n                 oflags,\n                 fs_rights_base,\n                 fs_rights_inheriting,\n                 fs_flags,\n-                &mut fd,\n-            ))?;\n-            Ok(WasiFd::from_raw(fd))\n+            ).map(|fd| WasiFd::from_raw(fd)).map_err(err2io)\n         }\n     }\n \n-    pub fn readdir(&self, buf: &mut [u8], cookie: DirCookie) -> io::Result<usize> {\n-        let mut used = 0;\n-        cvt_wasi(unsafe {\n-            libc::__wasi_fd_readdir(\n-                self.fd,\n-                buf.as_mut_ptr() as *mut c_void,\n-                buf.len(),\n-                cookie,\n-                &mut used,\n-            )\n-        })?;\n-        Ok(used)\n+    pub fn readdir(&self, buf: &mut [u8], cookie: wasi::DirCookie) -> io::Result<usize> {\n+        unsafe { wasi::fd_readdir(self.fd, buf, cookie).map_err(err2io) }\n     }\n \n     pub fn readlink(&self, path: &[u8], buf: &mut [u8]) -> io::Result<usize> {\n-        let mut used = 0;\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_readlink(\n-                self.fd,\n-                path.as_ptr() as *const c_char,\n-                path.len(),\n-                buf.as_mut_ptr() as *mut c_char,\n-                buf.len(),\n-                &mut used,\n-            )\n-        })?;\n-        Ok(used)\n+        unsafe { wasi::path_readlink(self.fd, path, buf).map_err(err2io) }\n     }\n \n     pub fn rename(&self, old_path: &[u8], new_fd: &WasiFd, new_path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_rename(\n-                self.fd,\n-                old_path.as_ptr() as *const c_char,\n-                old_path.len(),\n-                new_fd.fd,\n-                new_path.as_ptr() as *const c_char,\n-                new_path.len(),\n-            )\n-        })\n+        unsafe {\n+            wasi::path_rename(self.fd, old_path, new_fd.fd, new_path).map_err(err2io)\n+        }\n     }\n \n-    pub fn filestat_get(&self, buf: *mut libc::__wasi_filestat_t) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_filestat_get(self.fd, buf) })\n+    pub fn filestat_get(&self) -> io::Result<wasi::FileStat> {\n+        unsafe { wasi::fd_filestat_get(self.fd).map_err(err2io) }\n     }\n \n     pub fn filestat_set_times(\n         &self,\n-        atim: Timestamp,\n-        mtim: Timestamp,\n-        fstflags: FstFlags,\n+        atim: wasi::Timestamp,\n+        mtim: wasi::Timestamp,\n+        fstflags: wasi::FstFlags,\n     ) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_filestat_set_times(self.fd, atim, mtim, fstflags) })\n+        unsafe {\n+            wasi::fd_filestat_set_times(self.fd, atim, mtim, fstflags).map_err(err2io)\n+        }\n     }\n \n     pub fn filestat_set_size(&self, size: u64) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_filestat_set_size(self.fd, size) })\n+        unsafe { wasi::fd_filestat_set_size(self.fd, size).map_err(err2io) }\n     }\n \n     pub fn path_filestat_get(\n         &self,\n-        flags: LookupFlags,\n+        flags: wasi::LookupFlags,\n         path: &[u8],\n-        buf: *mut libc::__wasi_filestat_t,\n-    ) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_filestat_get(\n-                self.fd,\n-                flags,\n-                path.as_ptr() as *const c_char,\n-                path.len(),\n-                buf,\n-            )\n-        })\n+    ) -> io::Result<wasi::FileStat> {\n+        unsafe { wasi::path_filestat_get(self.fd, flags, path).map_err(err2io) }\n     }\n \n     pub fn path_filestat_set_times(\n         &self,\n-        flags: LookupFlags,\n+        flags: wasi::LookupFlags,\n         path: &[u8],\n-        atim: Timestamp,\n-        mtim: Timestamp,\n-        fstflags: FstFlags,\n+        atim: wasi::Timestamp,\n+        mtim: wasi::Timestamp,\n+        fstflags: wasi::FstFlags,\n     ) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_filestat_set_times(\n+        unsafe {\n+            wasi::path_filestat_set_times(\n                 self.fd,\n                 flags,\n-                path.as_ptr() as *const c_char,\n-                path.len(),\n+                path,\n                 atim,\n                 mtim,\n                 fstflags,\n-            )\n-        })\n+            ).map_err(err2io)\n+        }\n     }\n \n     pub fn symlink(&self, old_path: &[u8], new_path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_symlink(\n-                old_path.as_ptr() as *const c_char,\n-                old_path.len(),\n-                self.fd,\n-                new_path.as_ptr() as *const c_char,\n-                new_path.len(),\n-            )\n-        })\n+        unsafe { wasi::path_symlink(old_path, self.fd, new_path).map_err(err2io) }\n     }\n \n     pub fn unlink_file(&self, path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_unlink_file(self.fd, path.as_ptr() as *const c_char, path.len())\n-        })\n+        unsafe { wasi::path_unlink_file(self.fd, path).map_err(err2io) }\n     }\n \n     pub fn remove_directory(&self, path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_remove_directory(self.fd, path.as_ptr() as *const c_char, path.len())\n-        })\n+        unsafe { wasi::path_remove_directory(self.fd, path).map_err(err2io) }\n     }\n \n     pub fn sock_recv(\n         &self,\n         ri_data: &mut [IoSliceMut<'_>],\n-        ri_flags: RiFlags,\n-    ) -> io::Result<(usize, RoFlags)> {\n-        let mut ro_datalen = 0;\n-        let mut ro_flags = 0;\n-        let (ptr, len) = iovec(ri_data);\n-        cvt_wasi(unsafe {\n-            libc::__wasi_sock_recv(self.fd, ptr, len, ri_flags, &mut ro_datalen, &mut ro_flags)\n-        })?;\n-        Ok((ro_datalen, ro_flags))\n+        ri_flags: wasi::RiFlags,\n+    ) -> io::Result<(usize, wasi::RoFlags)> {\n+        unsafe { wasi::sock_recv(self.fd, iovec(ri_data), ri_flags).map_err(err2io) }\n     }\n \n-    pub fn sock_send(&self, si_data: &[IoSlice<'_>], si_flags: SiFlags) -> io::Result<usize> {\n-        let mut so_datalen = 0;\n-        let (ptr, len) = ciovec(si_data);\n-        cvt_wasi(unsafe { libc::__wasi_sock_send(self.fd, ptr, len, si_flags, &mut so_datalen) })?;\n-        Ok(so_datalen)\n+    pub fn sock_send(&self, si_data: &[IoSlice<'_>], si_flags: wasi::SiFlags) -> io::Result<usize> {\n+        unsafe { wasi::sock_send(self.fd, ciovec(si_data), si_flags).map_err(err2io) }\n     }\n \n     pub fn sock_shutdown(&self, how: Shutdown) -> io::Result<()> {\n         let how = match how {\n-            Shutdown::Read => libc::__WASI_SHUT_RD,\n-            Shutdown::Write => libc::__WASI_SHUT_WR,\n-            Shutdown::Both => libc::__WASI_SHUT_WR | libc::__WASI_SHUT_RD,\n+            Shutdown::Read => wasi::SHUT_RD,\n+            Shutdown::Write => wasi::SHUT_WR,\n+            Shutdown::Both => wasi::SHUT_WR | wasi::SHUT_RD,\n         };\n-        cvt_wasi(unsafe { libc::__wasi_sock_shutdown(self.fd, how) })?;\n-        Ok(())\n+        unsafe { wasi::sock_shutdown(self.fd, how).map_err(err2io) }\n     }\n }\n \n impl Drop for WasiFd {\n     fn drop(&mut self) {\n-        unsafe {\n-            // FIXME: can we handle the return code here even though we can't on\n-            // unix?\n-            libc::__wasi_fd_close(self.fd);\n-        }\n+        // FIXME: can we handle the return code here even though we can't on\n+        // unix?\n+        let _ = unsafe { wasi::fd_close(self.fd) };\n     }\n }"}, {"sha": "4113f6a2e09c0e21e7080102df326095182957af", "filename": "src/libstd/sys/wasi/fs.rs", "status": "modified", "additions": 84, "deletions": 102, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs?ref=5b995397dba72b9afeb621eef17479b8538f235a", "patch": "@@ -7,26 +7,28 @@ use crate::os::wasi::ffi::{OsStrExt, OsStringExt};\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n use crate::sync::Arc;\n-use crate::sys::fd::{DirCookie, WasiFd};\n+use crate::sys::fd::WasiFd;\n use crate::sys::time::SystemTime;\n use crate::sys::unsupported;\n use crate::sys_common::FromInner;\n \n pub use crate::sys_common::fs::copy;\n pub use crate::sys_common::fs::remove_dir_all;\n \n+use ::wasi::wasi_unstable as wasi;\n+\n pub struct File {\n     fd: WasiFd,\n }\n \n #[derive(Clone)]\n pub struct FileAttr {\n-    meta: libc::__wasi_filestat_t,\n+    meta: wasi::FileStat,\n }\n \n pub struct ReadDir {\n     inner: Arc<ReadDirInner>,\n-    cookie: Option<DirCookie>,\n+    cookie: Option<wasi::DirCookie>,\n     buf: Vec<u8>,\n     offset: usize,\n     cap: usize,\n@@ -38,7 +40,7 @@ struct ReadDirInner {\n }\n \n pub struct DirEntry {\n-    meta: libc::__wasi_dirent_t,\n+    meta: wasi::Dirent,\n     name: Vec<u8>,\n     inner: Arc<ReadDirInner>,\n }\n@@ -47,11 +49,11 @@ pub struct DirEntry {\n pub struct OpenOptions {\n     read: bool,\n     write: bool,\n-    dirflags: libc::__wasi_lookupflags_t,\n-    fdflags: libc::__wasi_fdflags_t,\n-    oflags: libc::__wasi_oflags_t,\n-    rights_base: Option<libc::__wasi_rights_t>,\n-    rights_inheriting: Option<libc::__wasi_rights_t>,\n+    dirflags: wasi::LookupFlags,\n+    fdflags: wasi::FdFlags,\n+    oflags: wasi::OFlags,\n+    rights_base: Option<wasi::Rights>,\n+    rights_inheriting: Option<wasi::Rights>,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -61,19 +63,13 @@ pub struct FilePermissions {\n \n #[derive(PartialEq, Eq, Hash, Debug, Copy, Clone)]\n pub struct FileType {\n-    bits: libc::__wasi_filetype_t,\n+    bits: wasi::FileType,\n }\n \n #[derive(Debug)]\n pub struct DirBuilder {}\n \n impl FileAttr {\n-    fn zero() -> FileAttr {\n-        FileAttr {\n-            meta: unsafe { mem::zeroed() },\n-        }\n-    }\n-\n     pub fn size(&self) -> u64 {\n         self.meta.st_size\n     }\n@@ -101,7 +97,7 @@ impl FileAttr {\n         Ok(SystemTime::from_wasi_timestamp(self.meta.st_ctim))\n     }\n \n-    pub fn as_wasi(&self) -> &libc::__wasi_filestat_t {\n+    pub fn as_wasi(&self) -> &wasi::FileStat {\n         &self.meta\n     }\n }\n@@ -118,18 +114,18 @@ impl FilePermissions {\n \n impl FileType {\n     pub fn is_dir(&self) -> bool {\n-        self.bits == libc::__WASI_FILETYPE_DIRECTORY\n+        self.bits == wasi::FILETYPE_DIRECTORY\n     }\n \n     pub fn is_file(&self) -> bool {\n-        self.bits == libc::__WASI_FILETYPE_REGULAR_FILE\n+        self.bits == wasi::FILETYPE_REGULAR_FILE\n     }\n \n     pub fn is_symlink(&self) -> bool {\n-        self.bits == libc::__WASI_FILETYPE_SYMBOLIC_LINK\n+        self.bits == wasi::FILETYPE_SYMBOLIC_LINK\n     }\n \n-    pub fn bits(&self) -> libc::__wasi_filetype_t {\n+    pub fn bits(&self) -> wasi::FileType {\n         self.bits\n     }\n }\n@@ -173,7 +169,7 @@ impl Iterator for ReadDir {\n             // must have been truncated at the end of the buffer, so reset our\n             // offset so we can go back and reread into the buffer, picking up\n             // where we last left off.\n-            let dirent_size = mem::size_of::<libc::__wasi_dirent_t>();\n+            let dirent_size = mem::size_of::<wasi::Dirent>();\n             if data.len() < dirent_size {\n                 assert!(self.cookie.is_some());\n                 assert!(self.buf.len() >= dirent_size);\n@@ -182,7 +178,7 @@ impl Iterator for ReadDir {\n             }\n             let (dirent, data) = data.split_at(dirent_size);\n             let dirent =\n-                unsafe { ptr::read_unaligned(dirent.as_ptr() as *const libc::__wasi_dirent_t) };\n+                unsafe { ptr::read_unaligned(dirent.as_ptr() as *const wasi::Dirent) };\n \n             // If the file name was truncated, then we need to reinvoke\n             // `readdir` so we truncate our buffer to start over and reread this\n@@ -241,15 +237,15 @@ impl DirEntry {\n         })\n     }\n \n-    pub fn ino(&self) -> libc::__wasi_inode_t {\n+    pub fn ino(&self) -> wasi::Inode {\n         self.meta.d_ino\n     }\n }\n \n impl OpenOptions {\n     pub fn new() -> OpenOptions {\n         let mut base = OpenOptions::default();\n-        base.dirflags = libc::__WASI_LOOKUP_SYMLINK_FOLLOW;\n+        base.dirflags = wasi::LOOKUP_SYMLINK_FOLLOW;\n         return base;\n     }\n \n@@ -262,23 +258,23 @@ impl OpenOptions {\n     }\n \n     pub fn truncate(&mut self, truncate: bool) {\n-        self.oflag(libc::__WASI_O_TRUNC, truncate);\n+        self.oflag(wasi::O_TRUNC, truncate);\n     }\n \n     pub fn create(&mut self, create: bool) {\n-        self.oflag(libc::__WASI_O_CREAT, create);\n+        self.oflag(wasi::O_CREAT, create);\n     }\n \n     pub fn create_new(&mut self, create_new: bool) {\n-        self.oflag(libc::__WASI_O_EXCL, create_new);\n-        self.oflag(libc::__WASI_O_CREAT, create_new);\n+        self.oflag(wasi::O_EXCL, create_new);\n+        self.oflag(wasi::O_CREAT, create_new);\n     }\n \n     pub fn directory(&mut self, directory: bool) {\n-        self.oflag(libc::__WASI_O_DIRECTORY, directory);\n+        self.oflag(wasi::O_DIRECTORY, directory);\n     }\n \n-    fn oflag(&mut self, bit: libc::__wasi_oflags_t, set: bool) {\n+    fn oflag(&mut self, bit: wasi::OFlags, set: bool) {\n         if set {\n             self.oflags |= bit;\n         } else {\n@@ -287,42 +283,42 @@ impl OpenOptions {\n     }\n \n     pub fn append(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_APPEND, set);\n+        self.fdflag(wasi::FDFLAG_APPEND, set);\n     }\n \n     pub fn dsync(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_DSYNC, set);\n+        self.fdflag(wasi::FDFLAG_DSYNC, set);\n     }\n \n     pub fn nonblock(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_NONBLOCK, set);\n+        self.fdflag(wasi::FDFLAG_NONBLOCK, set);\n     }\n \n     pub fn rsync(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_RSYNC, set);\n+        self.fdflag(wasi::FDFLAG_RSYNC, set);\n     }\n \n     pub fn sync(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_SYNC, set);\n+        self.fdflag(wasi::FDFLAG_SYNC, set);\n     }\n \n-    fn fdflag(&mut self, bit: libc::__wasi_fdflags_t, set: bool) {\n+    fn fdflag(&mut self, bit: wasi::FdFlags, set: bool) {\n         if set {\n             self.fdflags |= bit;\n         } else {\n             self.fdflags &= !bit;\n         }\n     }\n \n-    pub fn fs_rights_base(&mut self, rights: libc::__wasi_rights_t) {\n+    pub fn fs_rights_base(&mut self, rights: wasi::Rights) {\n         self.rights_base = Some(rights);\n     }\n \n-    pub fn fs_rights_inheriting(&mut self, rights: libc::__wasi_rights_t) {\n+    pub fn fs_rights_inheriting(&mut self, rights: wasi::Rights) {\n         self.rights_inheriting = Some(rights);\n     }\n \n-    fn rights_base(&self) -> libc::__wasi_rights_t {\n+    fn rights_base(&self) -> wasi::Rights {\n         if let Some(rights) = self.rights_base {\n             return rights;\n         }\n@@ -334,52 +330,52 @@ impl OpenOptions {\n         // based on that.\n         let mut base = 0;\n         if self.read {\n-            base |= libc::__WASI_RIGHT_FD_READ;\n-            base |= libc::__WASI_RIGHT_FD_READDIR;\n+            base |= wasi::RIGHT_FD_READ;\n+            base |= wasi::RIGHT_FD_READDIR;\n         }\n         if self.write {\n-            base |= libc::__WASI_RIGHT_FD_WRITE;\n-            base |= libc::__WASI_RIGHT_FD_DATASYNC;\n-            base |= libc::__WASI_RIGHT_FD_ALLOCATE;\n-            base |= libc::__WASI_RIGHT_FD_FILESTAT_SET_SIZE;\n+            base |= wasi::RIGHT_FD_WRITE;\n+            base |= wasi::RIGHT_FD_DATASYNC;\n+            base |= wasi::RIGHT_FD_ALLOCATE;\n+            base |= wasi::RIGHT_FD_FILESTAT_SET_SIZE;\n         }\n \n         // FIXME: some of these should probably be read-only or write-only...\n-        base |= libc::__WASI_RIGHT_FD_ADVISE;\n-        base |= libc::__WASI_RIGHT_FD_FDSTAT_SET_FLAGS;\n-        base |= libc::__WASI_RIGHT_FD_FILESTAT_SET_TIMES;\n-        base |= libc::__WASI_RIGHT_FD_SEEK;\n-        base |= libc::__WASI_RIGHT_FD_SYNC;\n-        base |= libc::__WASI_RIGHT_FD_TELL;\n-        base |= libc::__WASI_RIGHT_PATH_CREATE_DIRECTORY;\n-        base |= libc::__WASI_RIGHT_PATH_CREATE_FILE;\n-        base |= libc::__WASI_RIGHT_PATH_FILESTAT_GET;\n-        base |= libc::__WASI_RIGHT_PATH_LINK_SOURCE;\n-        base |= libc::__WASI_RIGHT_PATH_LINK_TARGET;\n-        base |= libc::__WASI_RIGHT_PATH_OPEN;\n-        base |= libc::__WASI_RIGHT_PATH_READLINK;\n-        base |= libc::__WASI_RIGHT_PATH_REMOVE_DIRECTORY;\n-        base |= libc::__WASI_RIGHT_PATH_RENAME_SOURCE;\n-        base |= libc::__WASI_RIGHT_PATH_RENAME_TARGET;\n-        base |= libc::__WASI_RIGHT_PATH_SYMLINK;\n-        base |= libc::__WASI_RIGHT_PATH_UNLINK_FILE;\n-        base |= libc::__WASI_RIGHT_POLL_FD_READWRITE;\n+        base |= wasi::RIGHT_FD_ADVISE;\n+        base |= wasi::RIGHT_FD_FDSTAT_SET_FLAGS;\n+        base |= wasi::RIGHT_FD_FILESTAT_SET_TIMES;\n+        base |= wasi::RIGHT_FD_SEEK;\n+        base |= wasi::RIGHT_FD_SYNC;\n+        base |= wasi::RIGHT_FD_TELL;\n+        base |= wasi::RIGHT_PATH_CREATE_DIRECTORY;\n+        base |= wasi::RIGHT_PATH_CREATE_FILE;\n+        base |= wasi::RIGHT_PATH_FILESTAT_GET;\n+        base |= wasi::RIGHT_PATH_LINK_SOURCE;\n+        base |= wasi::RIGHT_PATH_LINK_TARGET;\n+        base |= wasi::RIGHT_PATH_OPEN;\n+        base |= wasi::RIGHT_PATH_READLINK;\n+        base |= wasi::RIGHT_PATH_REMOVE_DIRECTORY;\n+        base |= wasi::RIGHT_PATH_RENAME_SOURCE;\n+        base |= wasi::RIGHT_PATH_RENAME_TARGET;\n+        base |= wasi::RIGHT_PATH_SYMLINK;\n+        base |= wasi::RIGHT_PATH_UNLINK_FILE;\n+        base |= wasi::RIGHT_POLL_FD_READWRITE;\n \n         return base;\n     }\n \n-    fn rights_inheriting(&self) -> libc::__wasi_rights_t {\n+    fn rights_inheriting(&self) -> wasi::Rights {\n         self.rights_inheriting.unwrap_or_else(|| self.rights_base())\n     }\n \n-    pub fn lookup_flags(&mut self, flags: libc::__wasi_lookupflags_t) {\n+    pub fn lookup_flags(&mut self, flags: wasi::LookupFlags) {\n         self.dirflags = flags;\n     }\n }\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let (dir, file) = open_parent(path, libc::__WASI_RIGHT_PATH_OPEN)?;\n+        let (dir, file) = open_parent(path, wasi::RIGHT_PATH_OPEN)?;\n         open_at(&dir, &file, opts)\n     }\n \n@@ -388,14 +384,12 @@ impl File {\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n-        let mut ret = FileAttr::zero();\n-        self.fd.filestat_get(&mut ret.meta)?;\n-        Ok(ret)\n+        self.fd.filestat_get().map(|meta| FileAttr { meta })\n     }\n \n     pub fn metadata_at(\n         &self,\n-        flags: libc::__wasi_lookupflags_t,\n+        flags: wasi::LookupFlags,\n         path: &Path,\n     ) -> io::Result<FileAttr> {\n         metadata_at(&self.fd, flags, path)\n@@ -477,7 +471,7 @@ impl DirBuilder {\n     }\n \n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_CREATE_DIRECTORY)?;\n+        let (dir, file) = open_parent(p, wasi::RIGHT_PATH_CREATE_DIRECTORY)?;\n         dir.create_directory(file.as_os_str().as_bytes())\n     }\n }\n@@ -508,13 +502,13 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_UNLINK_FILE)?;\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_UNLINK_FILE)?;\n     dir.unlink_file(file.as_os_str().as_bytes())\n }\n \n pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let (old, old_file) = open_parent(old, libc::__WASI_RIGHT_PATH_RENAME_SOURCE)?;\n-    let (new, new_file) = open_parent(new, libc::__WASI_RIGHT_PATH_RENAME_TARGET)?;\n+    let (old, old_file) = open_parent(old, wasi::RIGHT_PATH_RENAME_SOURCE)?;\n+    let (new, new_file) = open_parent(new, wasi::RIGHT_PATH_RENAME_TARGET)?;\n     old.rename(\n         old_file.as_os_str().as_bytes(),\n         &new,\n@@ -529,12 +523,12 @@ pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> {\n }\n \n pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_REMOVE_DIRECTORY)?;\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_REMOVE_DIRECTORY)?;\n     dir.remove_directory(file.as_os_str().as_bytes())\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_READLINK)?;\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_READLINK)?;\n     read_link(&dir, &file)\n }\n \n@@ -570,39 +564,38 @@ fn read_link(fd: &WasiFd, file: &Path) -> io::Result<PathBuf> {\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n-    let (dst, dst_file) = open_parent(dst, libc::__WASI_RIGHT_PATH_SYMLINK)?;\n+    let (dst, dst_file) = open_parent(dst, wasi::RIGHT_PATH_SYMLINK)?;\n     dst.symlink(src.as_os_str().as_bytes(), dst_file.as_os_str().as_bytes())\n }\n \n pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n-    let (src, src_file) = open_parent(src, libc::__WASI_RIGHT_PATH_LINK_SOURCE)?;\n-    let (dst, dst_file) = open_parent(dst, libc::__WASI_RIGHT_PATH_LINK_TARGET)?;\n+    let (src, src_file) = open_parent(src, wasi::RIGHT_PATH_LINK_SOURCE)?;\n+    let (dst, dst_file) = open_parent(dst, wasi::RIGHT_PATH_LINK_TARGET)?;\n     src.link(\n-        libc::__WASI_LOOKUP_SYMLINK_FOLLOW,\n+        wasi::LOOKUP_SYMLINK_FOLLOW,\n         src_file.as_os_str().as_bytes(),\n         &dst,\n         dst_file.as_os_str().as_bytes(),\n     )\n }\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_FILESTAT_GET)?;\n-    metadata_at(&dir, libc::__WASI_LOOKUP_SYMLINK_FOLLOW, &file)\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_FILESTAT_GET)?;\n+    metadata_at(&dir, wasi::LOOKUP_SYMLINK_FOLLOW, &file)\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_FILESTAT_GET)?;\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_FILESTAT_GET)?;\n     metadata_at(&dir, 0, &file)\n }\n \n fn metadata_at(\n     fd: &WasiFd,\n-    flags: libc::__wasi_lookupflags_t,\n+    flags: wasi::LookupFlags,\n     path: &Path,\n ) -> io::Result<FileAttr> {\n-    let mut ret = FileAttr::zero();\n-    fd.path_filestat_get(flags, path.as_os_str().as_bytes(), &mut ret.meta)?;\n-    Ok(ret)\n+    fd.path_filestat_get(flags, path.as_os_str().as_bytes())\n+        .map(|meta| FileAttr { meta })\n }\n \n pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n@@ -652,12 +645,12 @@ fn open_at(fd: &WasiFd, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n /// to any preopened file descriptor.\n fn open_parent(\n     p: &Path,\n-    rights: libc::__wasi_rights_t,\n+    rights: wasi::Rights,\n ) -> io::Result<(ManuallyDrop<WasiFd>, PathBuf)> {\n     let p = CString::new(p.as_os_str().as_bytes())?;\n     unsafe {\n         let mut ret = ptr::null();\n-        let fd = __wasilibc_find_relpath(p.as_ptr(), rights, 0, &mut ret);\n+        let fd = libc::__wasilibc_find_relpath(p.as_ptr(), rights, 0, &mut ret);\n         if fd == -1 {\n             let msg = format!(\n                 \"failed to find a preopened file descriptor \\\n@@ -677,15 +670,4 @@ fn open_parent(\n \n         return Ok((ManuallyDrop::new(WasiFd::from_raw(fd as u32)), path));\n     }\n-\n-    // FIXME(rust-lang/libc#1314) use the `libc` crate for this when the API\n-    // there is published\n-    extern \"C\" {\n-        pub fn __wasilibc_find_relpath(\n-            path: *const libc::c_char,\n-            rights_base: libc::__wasi_rights_t,\n-            rights_inheriting: libc::__wasi_rights_t,\n-            relative_path: *mut *const libc::c_char,\n-        ) -> libc::c_int;\n-    }\n }"}, {"sha": "4be92faed308fe91632a5e2588234202d1a338d9", "filename": "src/libstd/sys/wasi/io.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs?ref=5b995397dba72b9afeb621eef17479b8538f235a", "patch": "@@ -1,19 +1,20 @@\n use crate::marker::PhantomData;\n use crate::slice;\n \n-use libc::{__wasi_ciovec_t, __wasi_iovec_t, c_void};\n+use ::wasi::wasi_unstable as wasi;\n+use core::ffi::c_void;\n \n #[repr(transparent)]\n pub struct IoSlice<'a> {\n-    vec: __wasi_ciovec_t,\n+    vec: wasi::CIoVec,\n     _p: PhantomData<&'a [u8]>,\n }\n \n impl<'a> IoSlice<'a> {\n     #[inline]\n     pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n         IoSlice {\n-            vec: __wasi_ciovec_t {\n+            vec: wasi::CIoVec {\n                 buf: buf.as_ptr() as *const c_void,\n                 buf_len: buf.len(),\n             },\n@@ -43,15 +44,15 @@ impl<'a> IoSlice<'a> {\n \n #[repr(transparent)]\n pub struct IoSliceMut<'a> {\n-    vec: __wasi_iovec_t,\n+    vec: wasi::IoVec,\n     _p: PhantomData<&'a mut [u8]>,\n }\n \n impl<'a> IoSliceMut<'a> {\n     #[inline]\n     pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n         IoSliceMut {\n-            vec: __wasi_iovec_t {\n+            vec: wasi::IoVec {\n                 buf: buf.as_mut_ptr() as *mut c_void,\n                 buf_len: buf.len()\n             },"}, {"sha": "517e3be9cb58c14273f3eb2c0e8526e29f70dbd4", "filename": "src/libstd/sys/wasi/mod.rs", "status": "modified", "additions": 40, "deletions": 53, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs?ref=5b995397dba72b9afeb621eef17479b8538f235a", "patch": "@@ -14,10 +14,10 @@\n //! compiling for wasm. That way it's a compile time error for something that's\n //! guaranteed to be a runtime error!\n \n-use libc;\n-use crate::io::{Error, ErrorKind};\n+use crate::io as std_io;\n use crate::mem;\n use crate::os::raw::c_char;\n+use ::wasi::wasi_unstable as wasi;\n \n pub mod alloc;\n pub mod args;\n@@ -56,31 +56,42 @@ pub mod ext;\n pub fn init() {\n }\n \n-pub fn unsupported<T>() -> crate::io::Result<T> {\n+pub fn unsupported<T>() -> std_io::Result<T> {\n     Err(unsupported_err())\n }\n \n-pub fn unsupported_err() -> Error {\n-    Error::new(ErrorKind::Other, \"operation not supported on wasm yet\")\n+pub fn unsupported_err() -> std_io::Error {\n+    std_io::Error::new(\n+        std_io::ErrorKind::Other,\n+        \"operation not supported on wasm yet\",\n+    )\n }\n \n-pub fn decode_error_kind(errno: i32) -> ErrorKind {\n-    match errno as libc::c_int {\n-        libc::ECONNREFUSED => ErrorKind::ConnectionRefused,\n-        libc::ECONNRESET => ErrorKind::ConnectionReset,\n-        libc::EPERM | libc::EACCES => ErrorKind::PermissionDenied,\n-        libc::EPIPE => ErrorKind::BrokenPipe,\n-        libc::ENOTCONN => ErrorKind::NotConnected,\n-        libc::ECONNABORTED => ErrorKind::ConnectionAborted,\n-        libc::EADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n-        libc::EADDRINUSE => ErrorKind::AddrInUse,\n-        libc::ENOENT => ErrorKind::NotFound,\n-        libc::EINTR => ErrorKind::Interrupted,\n-        libc::EINVAL => ErrorKind::InvalidInput,\n-        libc::ETIMEDOUT => ErrorKind::TimedOut,\n-        libc::EEXIST => ErrorKind::AlreadyExists,\n-        libc::EAGAIN => ErrorKind::WouldBlock,\n-        _ => ErrorKind::Other,\n+pub fn decode_error_kind(errno: i32) -> std_io::ErrorKind {\n+    use std_io::ErrorKind::*;\n+    if errno > u16::max_value() as i32 || errno < 0 {\n+        return Other;\n+    }\n+    let code = match wasi::Error::new(errno as u16) {\n+        Some(code) => code,\n+        None => return Other,\n+    };\n+    match code {\n+        wasi::ECONNREFUSED => ConnectionRefused,\n+        wasi::ECONNRESET => ConnectionReset,\n+        wasi::EPERM | wasi::EACCES => PermissionDenied,\n+        wasi::EPIPE => BrokenPipe,\n+        wasi::ENOTCONN => NotConnected,\n+        wasi::ECONNABORTED => ConnectionAborted,\n+        wasi::EADDRNOTAVAIL => AddrNotAvailable,\n+        wasi::EADDRINUSE => AddrInUse,\n+        wasi::ENOENT => NotFound,\n+        wasi::EINTR => Interrupted,\n+        wasi::EINVAL => InvalidInput,\n+        wasi::ETIMEDOUT => TimedOut,\n+        wasi::EEXIST => AlreadyExists,\n+        wasi::EAGAIN => WouldBlock,\n+        _ => Other,\n     }\n }\n \n@@ -105,40 +116,16 @@ pub unsafe fn abort_internal() -> ! {\n pub fn hashmap_random_keys() -> (u64, u64) {\n     let mut ret = (0u64, 0u64);\n     unsafe {\n-        let base = &mut ret as *mut (u64, u64) as *mut libc::c_void;\n+        let base = &mut ret as *mut (u64, u64) as *mut core::ffi::c_void;\n         let len = mem::size_of_val(&ret);\n-        cvt_wasi(libc::__wasi_random_get(base, len)).unwrap();\n-    }\n-    return ret\n-}\n-\n-#[doc(hidden)]\n-pub trait IsMinusOne {\n-    fn is_minus_one(&self) -> bool;\n-}\n-\n-macro_rules! impl_is_minus_one {\n-    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n-        fn is_minus_one(&self) -> bool {\n-            *self == -1\n+        let ret = wasi::raw::__wasi_random_get(base, len);\n+        if ret != 0 {\n+            panic!(\"__wasi_random_get failure\")\n         }\n-    })*)\n-}\n-\n-impl_is_minus_one! { i8 i16 i32 i64 isize }\n-\n-pub fn cvt<T: IsMinusOne>(t: T) -> crate::io::Result<T> {\n-    if t.is_minus_one() {\n-        Err(Error::last_os_error())\n-    } else {\n-        Ok(t)\n     }\n+    return ret\n }\n \n-pub fn cvt_wasi(r: u16) -> crate::io::Result<()> {\n-    if r != libc::__WASI_ESUCCESS {\n-        Err(Error::from_raw_os_error(r as i32))\n-    } else {\n-        Ok(())\n-    }\n+fn err2io(err: wasi::Error) -> std_io::Error {\n+    std_io::Error::from_raw_os_error(err.get() as i32)\n }"}, {"sha": "feee840782550cd81dff8d1050124b7d7e9d6dab", "filename": "src/libstd/sys/wasi/os.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs?ref=5b995397dba72b9afeb621eef17479b8538f235a", "patch": "@@ -9,7 +9,7 @@ use crate::path::{self, PathBuf};\n use crate::ptr;\n use crate::str;\n use crate::sys::memchr;\n-use crate::sys::{cvt, unsupported, Void};\n+use crate::sys::{unsupported, Void};\n use crate::vec;\n \n #[cfg(not(target_feature = \"atomics\"))]\n@@ -28,16 +28,11 @@ pub fn errno() -> i32 {\n }\n \n pub fn error_string(errno: i32) -> String {\n-    extern {\n-        fn strerror_r(errnum: libc::c_int, buf: *mut libc::c_char,\n-                      buflen: libc::size_t) -> libc::c_int;\n-    }\n-\n     let mut buf = [0 as libc::c_char; 1024];\n \n     let p = buf.as_mut_ptr();\n     unsafe {\n-        if strerror_r(errno as libc::c_int, p, buf.len()) < 0 {\n+        if libc::strerror_r(errno as libc::c_int, p, buf.len()) < 0 {\n             panic!(\"strerror_r failure\");\n         }\n         str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_owned()\n@@ -89,7 +84,6 @@ impl StdError for JoinPathsError {\n pub fn current_exe() -> io::Result<PathBuf> {\n     unsupported()\n }\n-\n pub struct Env {\n     iter: vec::IntoIter<(OsString, OsString)>,\n     _dont_send_or_sync_me: PhantomData<*mut ()>,\n@@ -182,3 +176,26 @@ pub fn exit(code: i32) -> ! {\n pub fn getpid() -> u32 {\n     panic!(\"unsupported\");\n }\n+\n+#[doc(hidden)]\n+pub trait IsMinusOne {\n+    fn is_minus_one(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_minus_one {\n+    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n+        fn is_minus_one(&self) -> bool {\n+            *self == -1\n+        }\n+    })*)\n+}\n+\n+impl_is_minus_one! { i8 i16 i32 i64 isize }\n+\n+fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n+    if t.is_minus_one() {\n+        Err(io::Error::last_os_error())\n+    } else {\n+        Ok(t)\n+    }\n+}"}, {"sha": "1d57b9922e5993770c828484e6d28916515164d4", "filename": "src/libstd/sys/wasi/stdio.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs?ref=5b995397dba72b9afeb621eef17479b8538f235a", "patch": "@@ -1,8 +1,9 @@\n use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::libc;\n use crate::mem::ManuallyDrop;\n use crate::sys::fd::WasiFd;\n \n+use ::wasi::wasi_unstable as wasi;\n+\n pub struct Stdin;\n pub struct Stdout;\n pub struct Stderr;\n@@ -17,7 +18,7 @@ impl Stdin {\n     }\n \n     pub fn read_vectored(&self, data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDIN_FILENO as u32) })\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(wasi::STDIN_FD) })\n             .read(data)\n     }\n }\n@@ -32,7 +33,7 @@ impl Stdout {\n     }\n \n     pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDOUT_FILENO as u32) })\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(wasi::STDOUT_FD) })\n             .write(data)\n     }\n \n@@ -51,7 +52,7 @@ impl Stderr {\n     }\n \n     pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDERR_FILENO as u32) })\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(wasi::STDERR_FD) })\n             .write(data)\n     }\n \n@@ -73,7 +74,7 @@ impl io::Write for Stderr {\n pub const STDIN_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n \n pub fn is_ebadf(err: &io::Error) -> bool {\n-    err.raw_os_error() == Some(libc::__WASI_EBADF as i32)\n+    err.raw_os_error() == Some(wasi::EBADF.get() as i32)\n }\n \n pub fn panic_output() -> Option<impl io::Write> {"}, {"sha": "28a504f19797496e8d30b9d43d700b2d19a5b724", "filename": "src/libstd/sys/wasi/thread.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs?ref=5b995397dba72b9afeb621eef17479b8538f235a", "patch": "@@ -1,10 +1,10 @@\n-use crate::cmp;\n use crate::ffi::CStr;\n use crate::io;\n-use crate::sys::cvt;\n+use crate::mem;\n use crate::sys::{unsupported, Void};\n use crate::time::Duration;\n-use libc;\n+\n+use ::wasi::wasi_unstable as wasi;\n \n pub struct Thread(Void);\n \n@@ -19,28 +19,46 @@ impl Thread {\n     }\n \n     pub fn yield_now() {\n-        let ret = unsafe { libc::__wasi_sched_yield() };\n-        debug_assert_eq!(ret, 0);\n+        let ret = wasi::sched_yield();\n+        debug_assert_eq!(ret, Ok(()));\n     }\n \n     pub fn set_name(_name: &CStr) {\n         // nope\n     }\n \n     pub fn sleep(dur: Duration) {\n-        let mut secs = dur.as_secs();\n-        let mut nsecs = dur.subsec_nanos() as i32;\n-\n-        unsafe {\n-            while secs > 0 || nsecs > 0 {\n-                let mut ts = libc::timespec {\n-                    tv_sec: cmp::min(libc::time_t::max_value() as u64, secs) as libc::time_t,\n-                    tv_nsec: nsecs,\n-                };\n-                secs -= ts.tv_sec as u64;\n-                cvt(libc::nanosleep(&ts, &mut ts)).unwrap();\n-                nsecs = 0;\n-            }\n+        let nanos = dur.as_nanos();\n+        assert!(nanos <= u64::max_value() as u128);\n+\n+        const CLOCK_ID: wasi::Userdata = 0x0123_45678;\n+\n+        let clock = wasi::raw::__wasi_subscription_u_clock_t {\n+            identifier: CLOCK_ID,\n+            clock_id: wasi::CLOCK_MONOTONIC,\n+            timeout: nanos as u64,\n+            precision: 0,\n+            flags: 0,\n+        };\n+\n+        let in_ = [wasi::Subscription {\n+            userdata: 0,\n+            type_: wasi::EVENTTYPE_CLOCK,\n+            u: wasi::raw::__wasi_subscription_u { clock: clock },\n+        }];\n+        let (res, event) = unsafe {\n+            let mut out: [wasi::Event; 1] = mem::zeroed();\n+            let res = wasi::poll_oneoff(&in_, &mut out);\n+            (res, out[0])\n+        };\n+        match (res, event) {\n+            (Ok(1), wasi::Event {\n+                userdata: CLOCK_ID,\n+                error: 0,\n+                type_: wasi::EVENTTYPE_CLOCK,\n+                ..\n+            }) => {}\n+            _ => panic!(\"thread::sleep(): unexpected result of poll_oneoff\"),\n         }\n     }\n "}, {"sha": "4394a22f9c233253cbcb8f8a323ecaeacf8b6f91", "filename": "src/libstd/sys/wasi/time.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b995397dba72b9afeb621eef17479b8538f235a/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs?ref=5b995397dba72b9afeb621eef17479b8538f235a", "patch": "@@ -1,7 +1,5 @@\n use crate::time::Duration;\n-use crate::mem;\n-use crate::sys::cvt_wasi;\n-use libc;\n+use ::wasi::wasi_unstable as wasi;\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n pub struct Instant(Duration);\n@@ -12,23 +10,19 @@ pub struct SystemTime(Duration);\n pub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));\n \n fn current_time(clock: u32) -> Duration {\n-    unsafe {\n-        let mut ts = mem::zeroed();\n-        cvt_wasi(libc::__wasi_clock_time_get(\n-            clock,\n-            1, // precision... seems ignored though?\n-            &mut ts,\n-        )).unwrap();\n-        Duration::new(\n-            (ts / 1_000_000_000) as u64,\n-            (ts % 1_000_000_000) as u32,\n-        )\n-    }\n+    let ts = wasi::clock_time_get(\n+        clock,\n+        1, // precision... seems ignored though?\n+    ).unwrap();\n+    Duration::new(\n+        (ts / 1_000_000_000) as u64,\n+        (ts % 1_000_000_000) as u32,\n+    )\n }\n \n impl Instant {\n     pub fn now() -> Instant {\n-        Instant(current_time(libc::__WASI_CLOCK_MONOTONIC))\n+        Instant(current_time(wasi::CLOCK_MONOTONIC))\n     }\n \n     pub const fn zero() -> Instant {\n@@ -54,10 +48,10 @@ impl Instant {\n \n impl SystemTime {\n     pub fn now() -> SystemTime {\n-        SystemTime(current_time(libc::__WASI_CLOCK_REALTIME))\n+        SystemTime(current_time(wasi::CLOCK_REALTIME))\n     }\n \n-    pub fn from_wasi_timestamp(ts: libc::__wasi_timestamp_t) -> SystemTime {\n+    pub fn from_wasi_timestamp(ts: wasi::Timestamp) -> SystemTime {\n         SystemTime(Duration::from_nanos(ts))\n     }\n "}, {"sha": "1ed39f45d3e701ab7f97a72444dbb62557428532", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b995397dba72b9afeb621eef17479b8538f235a/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b995397dba72b9afeb621eef17479b8538f235a/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=5b995397dba72b9afeb621eef17479b8538f235a", "patch": "@@ -15,6 +15,7 @@ const LICENSES: &[&str] = &[\n     \"Apache-2.0 / MIT\",\n     \"MIT OR Apache-2.0\",\n     \"Apache-2.0 OR MIT\",\n+    \"Apache-2.0 WITH LLVM-exception OR Apache-2.0 OR MIT\", // wasi license\n     \"MIT\",\n     \"Unlicense/MIT\",\n     \"Unlicense OR MIT\",\n@@ -172,6 +173,7 @@ const WHITELIST: &[Crate<'_>] = &[\n     Crate(\"vcpkg\"),\n     Crate(\"version_check\"),\n     Crate(\"void\"),\n+    Crate(\"wasi\"),\n     Crate(\"winapi\"),\n     Crate(\"winapi-build\"),\n     Crate(\"winapi-i686-pc-windows-gnu\"),"}]}