{"sha": "fc98b19cf72ea45851ebb7b28af160be92b19128", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjOThiMTljZjcyZWE0NTg1MWViYjdiMjhhZjE2MGJlOTJiMTkxMjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-03T04:29:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-03T04:29:52Z"}, "message": "Auto merge of #23832 - petrochenkov:usize, r=aturon\n\nThese constants are small and can fit even in `u8`, but semantically they have type `usize` because they denote sizes and are almost always used in `usize` context. The change of their type to `u32` during the integer audit led only to the large amount of `as usize` noise (see the second commit, which removes this noise).\r\n\r\nThis is a minor [breaking-change] to an unstable interface.\r\n\r\nr? @aturon", "tree": {"sha": "8a19d8c1f6e9a71eb5e0286954519b4b7ec3fbf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a19d8c1f6e9a71eb5e0286954519b4b7ec3fbf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc98b19cf72ea45851ebb7b28af160be92b19128", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc98b19cf72ea45851ebb7b28af160be92b19128", "html_url": "https://github.com/rust-lang/rust/commit/fc98b19cf72ea45851ebb7b28af160be92b19128", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc98b19cf72ea45851ebb7b28af160be92b19128/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e30f05a05326018357c6fffdfb872e8a8d2367c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e30f05a05326018357c6fffdfb872e8a8d2367c", "html_url": "https://github.com/rust-lang/rust/commit/5e30f05a05326018357c6fffdfb872e8a8d2367c"}, {"sha": "883adc6763c3dd06b282368698b28a07cdd65fd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/883adc6763c3dd06b282368698b28a07cdd65fd6", "html_url": "https://github.com/rust-lang/rust/commit/883adc6763c3dd06b282368698b28a07cdd65fd6"}], "stats": {"total": 172, "additions": 86, "deletions": 86}, "files": [{"sha": "d9255241af0e644415bb6fc04d25dc79f80d8756", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=fc98b19cf72ea45851ebb7b28af160be92b19128", "patch": "@@ -190,17 +190,17 @@ fn blocks_for_bits(bits: usize) -> usize {\n     //\n     // Note that we can technically avoid this branch with the expression\n     // `(nbits + u32::BITS - 1) / 32::BITS`, but if nbits is almost usize::MAX this will overflow.\n-    if bits % u32::BITS as usize == 0 {\n-        bits / u32::BITS as usize\n+    if bits % u32::BITS == 0 {\n+        bits / u32::BITS\n     } else {\n-        bits / u32::BITS as usize + 1\n+        bits / u32::BITS + 1\n     }\n }\n \n /// Computes the bitmask for the final word of the vector\n fn mask_for_bits(bits: usize) -> u32 {\n     // Note especially that a perfect multiple of u32::BITS should mask all 1s.\n-    !0 >> (u32::BITS as usize - bits % u32::BITS as usize) % u32::BITS as usize\n+    !0 >> (u32::BITS - bits % u32::BITS) % u32::BITS\n }\n \n impl BitVec {\n@@ -238,7 +238,7 @@ impl BitVec {\n     /// An operation might screw up the unused bits in the last block of the\n     /// `BitVec`. As per (3), it's assumed to be all 0s. This method fixes it up.\n     fn fix_last_block(&mut self) {\n-        let extra_bits = self.len() % u32::BITS as usize;\n+        let extra_bits = self.len() % u32::BITS;\n         if extra_bits > 0 {\n             let mask = (1 << extra_bits) - 1;\n             let storage_len = self.storage.len();\n@@ -317,7 +317,7 @@ impl BitVec {\n     ///                     false, false, true, false]));\n     /// ```\n     pub fn from_bytes(bytes: &[u8]) -> BitVec {\n-        let len = bytes.len().checked_mul(u8::BITS as usize).expect(\"capacity overflow\");\n+        let len = bytes.len().checked_mul(u8::BITS).expect(\"capacity overflow\");\n         let mut bit_vec = BitVec::with_capacity(len);\n         let complete_words = bytes.len() / 4;\n         let extra_bytes = bytes.len() % 4;\n@@ -386,8 +386,8 @@ impl BitVec {\n         if i >= self.nbits {\n             return None;\n         }\n-        let w = i / u32::BITS as usize;\n-        let b = i % u32::BITS as usize;\n+        let w = i / u32::BITS;\n+        let b = i % u32::BITS;\n         self.storage.get(w).map(|&block|\n             (block & (1 << b)) != 0\n         )\n@@ -414,8 +414,8 @@ impl BitVec {\n                reason = \"panic semantics are likely to change in the future\")]\n     pub fn set(&mut self, i: usize, x: bool) {\n         assert!(i < self.nbits);\n-        let w = i / u32::BITS as usize;\n-        let b = i % u32::BITS as usize;\n+        let w = i / u32::BITS;\n+        let b = i % u32::BITS;\n         let flag = 1 << b;\n         let val = if x { self.storage[w] | flag }\n                   else { self.storage[w] & !flag };\n@@ -811,7 +811,7 @@ impl BitVec {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.storage.capacity().checked_mul(u32::BITS as usize).unwrap_or(usize::MAX)\n+        self.storage.capacity().checked_mul(u32::BITS).unwrap_or(usize::MAX)\n     }\n \n     /// Grows the `BitVec` in-place, adding `n` copies of `value` to the `BitVec`.\n@@ -842,7 +842,7 @@ impl BitVec {\n \n         // Correct the old tail word, setting or clearing formerly unused bits\n         let num_cur_blocks = blocks_for_bits(self.nbits);\n-        if self.nbits % u32::BITS as usize > 0 {\n+        if self.nbits % u32::BITS > 0 {\n             let mask = mask_for_bits(self.nbits);\n             if value {\n                 self.storage[num_cur_blocks - 1] |= !mask;\n@@ -892,7 +892,7 @@ impl BitVec {\n             // (3)\n             self.set(i, false);\n             self.nbits = i;\n-            if self.nbits % u32::BITS as usize == 0 {\n+            if self.nbits % u32::BITS == 0 {\n                 // (2)\n                 self.storage.pop();\n             }\n@@ -915,7 +915,7 @@ impl BitVec {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, elem: bool) {\n-        if self.nbits % u32::BITS as usize == 0 {\n+        if self.nbits % u32::BITS == 0 {\n             self.storage.push(0);\n         }\n         let insert_pos = self.nbits;\n@@ -1433,7 +1433,7 @@ impl BitSet {\n         // Truncate\n         let trunc_len = cmp::max(old_len - n, 1);\n         bit_vec.storage.truncate(trunc_len);\n-        bit_vec.nbits = trunc_len * u32::BITS as usize;\n+        bit_vec.nbits = trunc_len * u32::BITS;\n     }\n \n     /// Iterator over each u32 stored in the `BitSet`.\n@@ -1871,13 +1871,13 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n     fn next(&mut self) -> Option<usize> {\n         while self.next_idx < self.set.bit_vec.len() ||\n               self.next_idx < self.other.bit_vec.len() {\n-            let bit_idx = self.next_idx % u32::BITS as usize;\n+            let bit_idx = self.next_idx % u32::BITS;\n             if bit_idx == 0 {\n                 let s_bit_vec = &self.set.bit_vec;\n                 let o_bit_vec = &self.other.bit_vec;\n                 // Merging the two words is a bit of an awkward dance since\n                 // one BitVec might be longer than the other\n-                let word_idx = self.next_idx / u32::BITS as usize;\n+                let word_idx = self.next_idx / u32::BITS;\n                 let w1 = if word_idx < s_bit_vec.storage.len() {\n                              s_bit_vec.storage[word_idx]\n                          } else { 0 };"}, {"sha": "a3a266669b1bbb6787c97ebd505bcf8fe8a566a5", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=fc98b19cf72ea45851ebb7b28af160be92b19128", "patch": "@@ -86,7 +86,7 @@ pub trait CLike {\n fn bit<E:CLike>(e: &E) -> usize {\n     use core::usize;\n     let value = e.to_usize();\n-    assert!(value < usize::BITS as usize,\n+    assert!(value < usize::BITS,\n             \"EnumSet only supports up to {} variants.\", usize::BITS - 1);\n     1 << value\n }"}, {"sha": "10c688c3b66338ceedcc2b76b27d1bee05967575", "filename": "src/libcollectionstest/bit/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcollectionstest%2Fbit%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcollectionstest%2Fbit%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fset.rs?ref=fc98b19cf72ea45851ebb7b28af160be92b19128", "patch": "@@ -407,7 +407,7 @@ mod bench {\n         let mut bit_vec = BitSet::new();\n         b.iter(|| {\n             for _ in 0..100 {\n-                bit_vec.insert((r.next_u32() as usize) % u32::BITS as usize);\n+                bit_vec.insert((r.next_u32() as usize) % u32::BITS);\n             }\n             black_box(&bit_vec);\n         });"}, {"sha": "de3c0586ab728f3ccd8e8215e06633f78683c663", "filename": "src/libcollectionstest/bit/vec.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fvec.rs?ref=fc98b19cf72ea45851ebb7b28af160be92b19128", "patch": "@@ -541,70 +541,70 @@ fn test_big_bit_vec_tests() {\n \n #[test]\n fn test_bit_vec_push_pop() {\n-    let mut s = BitVec::from_elem(5 * u32::BITS as usize - 2, false);\n-    assert_eq!(s.len(), 5 * u32::BITS as usize - 2);\n-    assert_eq!(s[5 * u32::BITS as usize - 3], false);\n+    let mut s = BitVec::from_elem(5 * u32::BITS - 2, false);\n+    assert_eq!(s.len(), 5 * u32::BITS - 2);\n+    assert_eq!(s[5 * u32::BITS - 3], false);\n     s.push(true);\n     s.push(true);\n-    assert_eq!(s[5 * u32::BITS as usize - 2], true);\n-    assert_eq!(s[5 * u32::BITS as usize - 1], true);\n+    assert_eq!(s[5 * u32::BITS - 2], true);\n+    assert_eq!(s[5 * u32::BITS - 1], true);\n     // Here the internal vector will need to be extended\n     s.push(false);\n-    assert_eq!(s[5 * u32::BITS as usize], false);\n+    assert_eq!(s[5 * u32::BITS], false);\n     s.push(false);\n-    assert_eq!(s[5 * u32::BITS as usize + 1], false);\n-    assert_eq!(s.len(), 5 * u32::BITS as usize + 2);\n+    assert_eq!(s[5 * u32::BITS + 1], false);\n+    assert_eq!(s.len(), 5 * u32::BITS + 2);\n     // Pop it all off\n     assert_eq!(s.pop(), Some(false));\n     assert_eq!(s.pop(), Some(false));\n     assert_eq!(s.pop(), Some(true));\n     assert_eq!(s.pop(), Some(true));\n-    assert_eq!(s.len(), 5 * u32::BITS as usize - 2);\n+    assert_eq!(s.len(), 5 * u32::BITS - 2);\n }\n \n #[test]\n fn test_bit_vec_truncate() {\n-    let mut s = BitVec::from_elem(5 * u32::BITS as usize, true);\n+    let mut s = BitVec::from_elem(5 * u32::BITS, true);\n \n-    assert_eq!(s, BitVec::from_elem(5 * u32::BITS as usize, true));\n-    assert_eq!(s.len(), 5 * u32::BITS as usize);\n-    s.truncate(4 * u32::BITS as usize);\n-    assert_eq!(s, BitVec::from_elem(4 * u32::BITS as usize, true));\n-    assert_eq!(s.len(), 4 * u32::BITS as usize);\n+    assert_eq!(s, BitVec::from_elem(5 * u32::BITS, true));\n+    assert_eq!(s.len(), 5 * u32::BITS);\n+    s.truncate(4 * u32::BITS);\n+    assert_eq!(s, BitVec::from_elem(4 * u32::BITS, true));\n+    assert_eq!(s.len(), 4 * u32::BITS);\n     // Truncating to a size > s.len() should be a noop\n-    s.truncate(5 * u32::BITS as usize);\n-    assert_eq!(s, BitVec::from_elem(4 * u32::BITS as usize, true));\n-    assert_eq!(s.len(), 4 * u32::BITS as usize);\n-    s.truncate(3 * u32::BITS as usize - 10);\n-    assert_eq!(s, BitVec::from_elem(3 * u32::BITS as usize - 10, true));\n-    assert_eq!(s.len(), 3 * u32::BITS as usize - 10);\n+    s.truncate(5 * u32::BITS);\n+    assert_eq!(s, BitVec::from_elem(4 * u32::BITS, true));\n+    assert_eq!(s.len(), 4 * u32::BITS);\n+    s.truncate(3 * u32::BITS - 10);\n+    assert_eq!(s, BitVec::from_elem(3 * u32::BITS - 10, true));\n+    assert_eq!(s.len(), 3 * u32::BITS - 10);\n     s.truncate(0);\n     assert_eq!(s, BitVec::from_elem(0, true));\n     assert_eq!(s.len(), 0);\n }\n \n #[test]\n fn test_bit_vec_reserve() {\n-    let mut s = BitVec::from_elem(5 * u32::BITS as usize, true);\n+    let mut s = BitVec::from_elem(5 * u32::BITS, true);\n     // Check capacity\n-    assert!(s.capacity() >= 5 * u32::BITS as usize);\n-    s.reserve(2 * u32::BITS as usize);\n-    assert!(s.capacity() >= 7 * u32::BITS as usize);\n-    s.reserve(7 * u32::BITS as usize);\n-    assert!(s.capacity() >= 12 * u32::BITS as usize);\n-    s.reserve_exact(7 * u32::BITS as usize);\n-    assert!(s.capacity() >= 12 * u32::BITS as usize);\n-    s.reserve(7 * u32::BITS as usize + 1);\n-    assert!(s.capacity() >= 12 * u32::BITS as usize + 1);\n+    assert!(s.capacity() >= 5 * u32::BITS);\n+    s.reserve(2 * u32::BITS);\n+    assert!(s.capacity() >= 7 * u32::BITS);\n+    s.reserve(7 * u32::BITS);\n+    assert!(s.capacity() >= 12 * u32::BITS);\n+    s.reserve_exact(7 * u32::BITS);\n+    assert!(s.capacity() >= 12 * u32::BITS);\n+    s.reserve(7 * u32::BITS + 1);\n+    assert!(s.capacity() >= 12 * u32::BITS + 1);\n     // Check that length hasn't changed\n-    assert_eq!(s.len(), 5 * u32::BITS as usize);\n+    assert_eq!(s.len(), 5 * u32::BITS);\n     s.push(true);\n     s.push(false);\n     s.push(true);\n-    assert_eq!(s[5 * u32::BITS as usize - 1], true);\n-    assert_eq!(s[5 * u32::BITS as usize - 0], true);\n-    assert_eq!(s[5 * u32::BITS as usize + 1], false);\n-    assert_eq!(s[5 * u32::BITS as usize + 2], true);\n+    assert_eq!(s[5 * u32::BITS - 1], true);\n+    assert_eq!(s[5 * u32::BITS - 0], true);\n+    assert_eq!(s[5 * u32::BITS + 1], false);\n+    assert_eq!(s[5 * u32::BITS + 2], true);\n }\n \n #[test]\n@@ -650,7 +650,7 @@ mod bench {\n         let mut bit_vec = 0 as usize;\n         b.iter(|| {\n             for _ in 0..100 {\n-                bit_vec |= 1 << ((r.next_u32() as usize) % u32::BITS as usize);\n+                bit_vec |= 1 << ((r.next_u32() as usize) % u32::BITS);\n             }\n             black_box(&bit_vec);\n         });\n@@ -683,10 +683,10 @@ mod bench {\n     #[bench]\n     fn bench_bit_set_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bit_vec = BitVec::from_elem(u32::BITS as usize, false);\n+        let mut bit_vec = BitVec::from_elem(u32::BITS, false);\n         b.iter(|| {\n             for _ in 0..100 {\n-                bit_vec.set((r.next_u32() as usize) % u32::BITS as usize, true);\n+                bit_vec.set((r.next_u32() as usize) % u32::BITS, true);\n             }\n             black_box(&bit_vec);\n         });\n@@ -703,7 +703,7 @@ mod bench {\n \n     #[bench]\n     fn bench_bit_vec_small_iter(b: &mut Bencher) {\n-        let bit_vec = BitVec::from_elem(u32::BITS as usize, false);\n+        let bit_vec = BitVec::from_elem(u32::BITS, false);\n         b.iter(|| {\n             let mut sum = 0;\n             for _ in 0..10 {"}, {"sha": "553e0c0dfe6e45c3cf792d70cd0768a80c0a8990", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=fc98b19cf72ea45851ebb7b28af160be92b19128", "patch": "@@ -194,7 +194,7 @@ mod impls {\n                 fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n                     // FIXME(#23542) Replace with type ascription.\n                     #![allow(trivial_casts)]\n-                    let newlen = data.len() * ::$ty::BYTES as usize;\n+                    let newlen = data.len() * ::$ty::BYTES;\n                     let ptr = data.as_ptr() as *const u8;\n                     state.write(unsafe { slice::from_raw_parts(ptr, newlen) })\n                 }"}, {"sha": "3113521e0afff825ed7352ba894b73928686f8a3", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=fc98b19cf72ea45851ebb7b28af160be92b19128", "patch": "@@ -15,11 +15,11 @@ macro_rules! int_module { ($T:ty, $bits:expr) => (\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n #[unstable(feature = \"core\")]\n-pub const BITS : u32 = $bits;\n+pub const BITS : usize = $bits;\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n #[unstable(feature = \"core\")]\n-pub const BYTES : u32 = ($bits / 8);\n+pub const BYTES : usize = ($bits / 8);\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::min_value` function."}, {"sha": "867829507455035e7eabbf74fd394efca5102cb4", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=fc98b19cf72ea45851ebb7b28af160be92b19128", "patch": "@@ -13,9 +13,9 @@\n macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => (\n \n #[unstable(feature = \"core\")]\n-pub const BITS : u32 = $bits;\n+pub const BITS : usize = $bits;\n #[unstable(feature = \"core\")]\n-pub const BYTES : u32 = ($bits / 8);\n+pub const BYTES : usize = ($bits / 8);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN: $T = 0 as $T;"}, {"sha": "cb2359873e9dc59ef8e19f09726c6647c1d6fc1e", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=fc98b19cf72ea45851ebb7b28af160be92b19128", "patch": "@@ -86,9 +86,9 @@ mod tests {\n \n     #[test]\n     fn test_count_zeros() {\n-        assert!(A.count_zeros() == BITS - 3);\n-        assert!(B.count_zeros() == BITS - 2);\n-        assert!(C.count_zeros() == BITS - 5);\n+        assert!(A.count_zeros() == BITS as u32 - 3);\n+        assert!(B.count_zeros() == BITS as u32 - 2);\n+        assert!(C.count_zeros() == BITS as u32 - 5);\n     }\n \n     #[test]"}, {"sha": "5e00692766d90aa052029f70b013e444f12426df", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=fc98b19cf72ea45851ebb7b28af160be92b19128", "patch": "@@ -54,9 +54,9 @@ mod tests {\n \n     #[test]\n     fn test_count_zeros() {\n-        assert!(A.count_zeros() == BITS - 3);\n-        assert!(B.count_zeros() == BITS - 2);\n-        assert!(C.count_zeros() == BITS - 5);\n+        assert!(A.count_zeros() == BITS as u32 - 3);\n+        assert!(B.count_zeros() == BITS as u32 - 2);\n+        assert!(C.count_zeros() == BITS as u32 - 5);\n     }\n \n     #[test]"}, {"sha": "b20e4c3f563ca8a7d20f6b8e5464b430a2d98426", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=fc98b19cf72ea45851ebb7b28af160be92b19128", "patch": "@@ -195,7 +195,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                oper: O,\n                id_range: IdRange,\n                bits_per_id: usize) -> DataFlowContext<'a, 'tcx, O> {\n-        let words_per_id = (bits_per_id + usize::BITS as usize - 1) / usize::BITS as usize;\n+        let words_per_id = (bits_per_id + usize::BITS - 1) / usize::BITS;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n         debug!(\"DataFlowContext::new(analysis_name: {}, id_range={:?}, \\\n@@ -367,7 +367,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         for (word_index, &word) in words.iter().enumerate() {\n             if word != 0 {\n-                let base_index = word_index * usize::BITS as usize;\n+                let base_index = word_index * usize::BITS;\n                 for offset in 0..usize::BITS {\n                     let bit = 1 << offset;\n                     if (word & bit) != 0 {\n@@ -601,8 +601,8 @@ fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n fn set_bit(words: &mut [usize], bit: usize) -> bool {\n     debug!(\"set_bit: words={} bit={}\",\n            mut_bits_to_string(words), bit_str(bit));\n-    let word = bit / usize::BITS as usize;\n-    let bit_in_word = bit % usize::BITS as usize;\n+    let word = bit / usize::BITS;\n+    let bit_in_word = bit % usize::BITS;\n     let bit_mask = 1 << bit_in_word;\n     debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, word);\n     let oldv = words[word];"}, {"sha": "5e93757668cbd45e3c4dc78bce1b4cdf826d8a1f", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=fc98b19cf72ea45851ebb7b28af160be92b19128", "patch": "@@ -726,28 +726,28 @@ pub trait Reader {\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_le_uint(&mut self) -> IoResult<usize> {\n-        self.read_le_uint_n(usize::BYTES as usize).map(|i| i as usize)\n+        self.read_le_uint_n(usize::BYTES).map(|i| i as usize)\n     }\n \n     /// Reads a little-endian integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_le_int(&mut self) -> IoResult<isize> {\n-        self.read_le_int_n(isize::BYTES as usize).map(|i| i as isize)\n+        self.read_le_int_n(isize::BYTES).map(|i| i as isize)\n     }\n \n     /// Reads a big-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_be_uint(&mut self) -> IoResult<usize> {\n-        self.read_be_uint_n(usize::BYTES as usize).map(|i| i as usize)\n+        self.read_be_uint_n(usize::BYTES).map(|i| i as usize)\n     }\n \n     /// Reads a big-endian integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_be_int(&mut self) -> IoResult<isize> {\n-        self.read_be_int_n(isize::BYTES as usize).map(|i| i as isize)\n+        self.read_be_int_n(isize::BYTES).map(|i| i as isize)\n     }\n \n     /// Reads a big-endian `u64`.\n@@ -1110,25 +1110,25 @@ pub trait Writer {\n     /// Write a little-endian usize (number of bytes depends on system).\n     #[inline]\n     fn write_le_uint(&mut self, n: usize) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, usize::BYTES as usize, |v| self.write_all(v))\n+        extensions::u64_to_le_bytes(n as u64, usize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian isize (number of bytes depends on system).\n     #[inline]\n     fn write_le_int(&mut self, n: isize) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, isize::BYTES as usize, |v| self.write_all(v))\n+        extensions::u64_to_le_bytes(n as u64, isize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian usize (number of bytes depends on system).\n     #[inline]\n     fn write_be_uint(&mut self, n: usize) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, usize::BYTES as usize, |v| self.write_all(v))\n+        extensions::u64_to_be_bytes(n as u64, usize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian isize (number of bytes depends on system).\n     #[inline]\n     fn write_be_int(&mut self, n: isize) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, isize::BYTES as usize, |v| self.write_all(v))\n+        extensions::u64_to_be_bytes(n as u64, isize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian u64 (8 bytes)."}, {"sha": "5ae508e46106a7f35fcbc431d90db5aba18a1e4b", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=fc98b19cf72ea45851ebb7b28af160be92b19128", "patch": "@@ -194,12 +194,12 @@ mod select {\n     #[repr(C)]\n     pub struct fd_set {\n         // FIXME: shouldn't this be a c_ulong?\n-        fds_bits: [libc::uintptr_t; (FD_SETSIZE / usize::BITS as usize)]\n+        fds_bits: [libc::uintptr_t; (FD_SETSIZE / usize::BITS)]\n     }\n \n     pub fn fd_set(set: &mut fd_set, fd: i32) {\n         let fd = fd as usize;\n-        set.fds_bits[fd / usize::BITS as usize] |= 1 << (fd % usize::BITS as usize);\n+        set.fds_bits[fd / usize::BITS] |= 1 << (fd % usize::BITS);\n     }\n }\n "}, {"sha": "e11270c94ca546dc980578b8c2eff4e987d92bc9", "filename": "src/test/run-pass/issue-13763.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Ftest%2Frun-pass%2Fissue-13763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Ftest%2Frun-pass%2Fissue-13763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13763.rs?ref=fc98b19cf72ea45851ebb7b28af160be92b19128", "patch": "@@ -14,7 +14,7 @@\n \n use std::u8;\n \n-const NUM: usize = u8::BITS as usize;\n+const NUM: usize = u8::BITS;\n \n struct MyStruct { nums: [usize; 8] }\n "}, {"sha": "eca7e62d67cbf4937f01045d56f6c05a097fb5af", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc98b19cf72ea45851ebb7b28af160be92b19128/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=fc98b19cf72ea45851ebb7b28af160be92b19128", "patch": "@@ -57,7 +57,7 @@ impl Drop for DropCounter {\n }\n \n pub fn main() {\n-    assert!(MAX_LEN <= std::usize::BITS as usize);\n+    assert!(MAX_LEN <= std::usize::BITS);\n     // len can't go above 64.\n     for len in 2..MAX_LEN {\n         for _ in 0..REPEATS {"}]}