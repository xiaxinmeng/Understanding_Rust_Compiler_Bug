{"sha": "6267339d6869a27b95f13c578a235204a1562697", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNjczMzlkNjg2OWEyN2I5NWYxM2M1NzhhMjM1MjA0YTE1NjI2OTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-05T22:49:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-06T16:02:19Z"}, "message": "Fix bug in coherence that causes all cross-crate impls to be regarded as\ninherent impls, not just those of the `impl Type` variety.", "tree": {"sha": "1e2f756ecad93469bb325adc1ed6dde83513d4da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e2f756ecad93469bb325adc1ed6dde83513d4da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6267339d6869a27b95f13c578a235204a1562697", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6267339d6869a27b95f13c578a235204a1562697", "html_url": "https://github.com/rust-lang/rust/commit/6267339d6869a27b95f13c578a235204a1562697", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6267339d6869a27b95f13c578a235204a1562697/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "959e483fb705e99097a85ce42371bd57b78bd180", "url": "https://api.github.com/repos/rust-lang/rust/commits/959e483fb705e99097a85ce42371bd57b78bd180", "html_url": "https://github.com/rust-lang/rust/commit/959e483fb705e99097a85ce42371bd57b78bd180"}], "stats": {"total": 386, "additions": 292, "deletions": 94}, "files": [{"sha": "18e049789445a181bebea5dc5e81ac3fb1efcdc9", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 150, "deletions": 88, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/6267339d6869a27b95f13c578a235204a1562697/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6267339d6869a27b95f13c578a235204a1562697/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=6267339d6869a27b95f13c578a235204a1562697", "patch": "@@ -104,64 +104,98 @@ pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n     (Port_(Port_ { endp: Some(s) }), Chan_(Chan_{ endp: Some(c) }))\n }\n \n+// Add an inherent method so that imports of GenericChan are not\n+// required.\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<T: Owned> Chan<T> {\n+    fn send(&self, x: T) { chan_send(self, x) }\n+    fn try_send(&self, x: T) -> bool { chan_try_send(self, x) }\n+}\n+\n impl<T: Owned> GenericChan<T> for Chan<T> {\n-    fn send(&self, x: T) {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        self.endp = Some(\n-            streamp::client::data(unwrap(endp), x))\n-    }\n+    fn send(&self, x: T) { chan_send(self, x) }\n }\n \n-impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n+#[inline(always)]\n+fn chan_send<T:Owned>(self: &Chan<T>, x: T) {\n+    let mut endp = None;\n+    endp <-> self.endp;\n+    self.endp = Some(\n+        streamp::client::data(unwrap(endp), x))\n+}\n \n+impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n     fn try_send(&self, x: T) -> bool {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        match streamp::client::try_data(unwrap(endp), x) {\n-            Some(next) => {\n-                self.endp = Some(next);\n-                true\n-            }\n-            None => false\n-        }\n+        chan_try_send(self, x)\n     }\n }\n \n-impl<T: Owned> GenericPort<T> for Port<T> {\n-    fn recv(&self) -> T {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        let streamp::data(x, endp) = recv(unwrap(endp));\n-        self.endp = Some(endp);\n-        x\n+#[inline(always)]\n+fn chan_try_send<T:Owned>(self: &Chan<T>, x: T) -> bool {\n+    let mut endp = None;\n+    endp <-> self.endp;\n+    match streamp::client::try_data(unwrap(endp), x) {\n+        Some(next) => {\n+            self.endp = Some(next);\n+            true\n+        }\n+        None => false\n     }\n+}\n \n-    fn try_recv(&self) -> Option<T> {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        match try_recv(unwrap(endp)) {\n-          Some(streamp::data(x, endp)) => {\n+// Use an inherent impl so that imports are not required:\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<T: Owned> Port<T> {\n+    fn recv(&self) -> T { port_recv(self) }\n+    fn try_recv(&self) -> Option<T> { port_try_recv(self) }\n+    pure fn peek(&self) -> bool { port_peek(self) }\n+}\n+\n+impl<T: Owned> GenericPort<T> for Port<T> {\n+    // These two calls will prefer the inherent versions above:\n+    fn recv(&self) -> T { port_recv(self) }\n+    fn try_recv(&self) -> Option<T> { port_try_recv(self) }\n+}\n+\n+#[inline(always)]\n+fn port_recv<T:Owned>(self: &Port<T>) -> T {\n+    let mut endp = None;\n+    endp <-> self.endp;\n+    let streamp::data(x, endp) = recv(unwrap(endp));\n+    self.endp = Some(endp);\n+    x\n+}\n+\n+#[inline(always)]\n+fn port_try_recv<T:Owned>(self: &Port<T>) -> Option<T> {\n+    let mut endp = None;\n+    endp <-> self.endp;\n+    match try_recv(unwrap(endp)) {\n+        Some(streamp::data(x, endp)) => {\n             self.endp = Some(endp);\n             Some(x)\n-          }\n-          None => None\n         }\n+        None => None\n     }\n }\n \n impl<T: Owned> Peekable<T> for Port<T> {\n-    pure fn peek(&self) -> bool {\n-        unsafe {\n-            let mut endp = None;\n-            endp <-> self.endp;\n-            let peek = match &endp {\n-              &Some(ref endp) => peek(endp),\n-              &None => fail!(~\"peeking empty stream\")\n-            };\n-            self.endp <-> endp;\n-            peek\n-        }\n+    pure fn peek(&self) -> bool { port_peek(self) }\n+}\n+\n+#[inline(always)]\n+pure fn port_peek<T:Owned>(self: &Port<T>) -> bool {\n+    unsafe {\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        let peek = match &endp {\n+            &Some(ref endp) => peek(endp),\n+            &None => fail!(~\"peeking empty stream\")\n+        };\n+        self.endp <-> endp;\n+        peek\n     }\n }\n \n@@ -187,8 +221,16 @@ pub fn PortSet<T: Owned>() -> PortSet<T>{\n     }\n }\n \n-pub impl<T: Owned> PortSet<T> {\n+// Use an inherent impl so that imports are not required:\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<T:Owned> PortSet<T> {\n+    fn recv(&self) -> T { port_set_recv(self) }\n+    fn try_recv(&self) -> Option<T> { port_set_try_recv(self) }\n+    pure fn peek(&self) -> bool { port_set_peek(self) }\n+}\n \n+pub impl<T: Owned> PortSet<T> {\n     fn add(&self, port: Port<T>) {\n         self.ports.push(port)\n     }\n@@ -200,69 +242,89 @@ pub impl<T: Owned> PortSet<T> {\n     }\n }\n \n-impl<T: Owned> GenericPort<T> for PortSet<T> {\n-\n-    fn try_recv(&self) -> Option<T> {\n-        let mut result = None;\n-        // we have to swap the ports array so we aren't borrowing\n-        // aliasable mutable memory.\n-        let mut ports = ~[];\n-        ports <-> self.ports;\n-        while result.is_none() && ports.len() > 0 {\n-            let i = wait_many(ports);\n-            match ports[i].try_recv() {\n-                Some(m) => {\n-                  result = Some(m);\n-                }\n-                None => {\n-                    // Remove this port.\n-                    let _ = ports.swap_remove(i);\n-                }\n+impl<T:Owned> GenericPort<T> for PortSet<T> {\n+    fn try_recv(&self) -> Option<T> { port_set_try_recv(self) }\n+    fn recv(&self) -> T { port_set_recv(self) }\n+}\n+\n+#[inline(always)]\n+fn port_set_recv<T:Owned>(self: &PortSet<T>) -> T {\n+    port_set_try_recv(self).expect(\"port_set: endpoints closed\")\n+}\n+\n+#[inline(always)]\n+fn port_set_try_recv<T:Owned>(self: &PortSet<T>) -> Option<T> {\n+    let mut result = None;\n+    // we have to swap the ports array so we aren't borrowing\n+    // aliasable mutable memory.\n+    let mut ports = ~[];\n+    ports <-> self.ports;\n+    while result.is_none() && ports.len() > 0 {\n+        let i = wait_many(ports);\n+        match ports[i].try_recv() {\n+            Some(m) => {\n+                result = Some(m);\n+            }\n+            None => {\n+                // Remove this port.\n+                let _ = ports.swap_remove(i);\n             }\n         }\n-        ports <-> self.ports;\n-        result\n     }\n-\n-    fn recv(&self) -> T {\n-        self.try_recv().expect(\"port_set: endpoints closed\")\n-    }\n-\n+    ports <-> self.ports;\n+    result\n }\n \n impl<T: Owned> Peekable<T> for PortSet<T> {\n-    pure fn peek(&self) -> bool {\n-        // It'd be nice to use self.port.each, but that version isn't\n-        // pure.\n-        for vec::each(self.ports) |p| {\n-            if p.peek() { return true }\n-        }\n-        false\n+    pure fn peek(&self) -> bool { port_set_peek(self) }\n+}\n+\n+#[inline(always)]\n+pure fn port_set_peek<T:Owned>(self: &PortSet<T>) -> bool {\n+    // It'd be nice to use self.port.each, but that version isn't\n+    // pure.\n+    for vec::each(self.ports) |p| {\n+        if p.peek() { return true }\n     }\n+    false\n }\n \n+\n /// A channel that can be shared between many senders.\n pub type SharedChan<T> = unstable::Exclusive<Chan<T>>;\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<T: Owned> SharedChan<T> {\n+    fn send(&self, x: T) { shared_chan_send(self, x) }\n+    fn try_send(&self, x: T) -> bool { shared_chan_try_send(self, x) }\n+}\n+\n impl<T: Owned> GenericChan<T> for SharedChan<T> {\n-    fn send(&self, x: T) {\n-        let mut xx = Some(x);\n-        do self.with_imm |chan| {\n-            let mut x = None;\n-            x <-> xx;\n-            chan.send(option::unwrap(x))\n-        }\n+    fn send(&self, x: T) { shared_chan_send(self, x) }\n+}\n+\n+#[inline(always)]\n+fn shared_chan_send<T:Owned>(self: &SharedChan<T>, x: T) {\n+    let mut xx = Some(x);\n+    do self.with_imm |chan| {\n+        let mut x = None;\n+        x <-> xx;\n+        chan.send(option::unwrap(x))\n     }\n }\n \n impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n-    fn try_send(&self, x: T) -> bool {\n-        let mut xx = Some(x);\n-        do self.with_imm |chan| {\n-            let mut x = None;\n-            x <-> xx;\n-            chan.try_send(option::unwrap(x))\n-        }\n+    fn try_send(&self, x: T) -> bool { shared_chan_try_send(self, x) }\n+}\n+\n+#[inline(always)]\n+fn shared_chan_try_send<T:Owned>(self: &SharedChan<T>, x: T) -> bool {\n+    let mut xx = Some(x);\n+    do self.with_imm |chan| {\n+        let mut x = None;\n+        x <-> xx;\n+        chan.try_send(option::unwrap(x))\n     }\n }\n "}, {"sha": "8e74ec1dc4cb3904f039fefa8006007c05d22994", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6267339d6869a27b95f13c578a235204a1562697/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6267339d6869a27b95f13c578a235204a1562697/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=6267339d6869a27b95f13c578a235204a1562697", "patch": "@@ -23,6 +23,7 @@ use middle::ty;\n use util::ppaux;\n \n use core::char;\n+use core::hash::Streaming;\n use core::hash;\n use core::io::{Writer, WriterUtil};\n use core::libc::{c_int, c_uint, c_char};"}, {"sha": "2c9a824471cee1c3bf56837d9d71853c727c28b3", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6267339d6869a27b95f13c578a235204a1562697/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6267339d6869a27b95f13c578a235204a1562697/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=6267339d6869a27b95f13c578a235204a1562697", "patch": "@@ -26,7 +26,7 @@ use core::dvec;\n use core::flate;\n use core::hash::{Hash, HashUtil};\n use core::int;\n-use core::io::WriterUtil;\n+use core::io::{Writer, WriterUtil};\n use core::io;\n use core::str;\n use core::to_bytes::IterBytes;"}, {"sha": "0fb587dfc9a6263788df63405774d1a39ea4aa30", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6267339d6869a27b95f13c578a235204a1562697/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6267339d6869a27b95f13c578a235204a1562697/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=6267339d6869a27b95f13c578a235204a1562697", "patch": "@@ -29,10 +29,11 @@ use core::{dvec, io, option, vec};\n use std::ebml::reader;\n use std::ebml;\n use std::serialize;\n-use std::serialize::{Encodable, EncoderHelpers, DecoderHelpers};\n-use std::serialize::Decodable;\n+use std::serialize::{Encoder, Encodable, EncoderHelpers, DecoderHelpers};\n+use std::serialize::{Decoder, Decodable};\n use syntax::ast;\n use syntax::ast_map;\n+use syntax::ast_util::inlined_item_utils;\n use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::codemap;"}, {"sha": "2d1fab5f6a9c9198bca12b08d248b0b37941ab64", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6267339d6869a27b95f13c578a235204a1562697/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6267339d6869a27b95f13c578a235204a1562697/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=6267339d6869a27b95f13c578a235204a1562697", "patch": "@@ -902,8 +902,12 @@ pub impl CoherenceChecker {\n                     // Nothing to do.\n                 }\n                 Some(base_type_def_id) => {\n-                    self.add_inherent_method(base_type_def_id,\n-                                             *implementation);\n+                    // inherent methods apply to `impl Type` but not\n+                    // `impl Trait for Type`:\n+                    if associated_traits.len() == 0 {\n+                        self.add_inherent_method(base_type_def_id,\n+                                                 *implementation);\n+                    }\n \n                     self.base_type_def_ids.insert(implementation.did,\n                                                   base_type_def_id);"}, {"sha": "0f8463b0b3c93879a6f7ae05f344f8195556556c", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6267339d6869a27b95f13c578a235204a1562697/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6267339d6869a27b95f13c578a235204a1562697/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=6267339d6869a27b95f13c578a235204a1562697", "patch": "@@ -35,6 +35,7 @@ use std::net::url;\n use std::{json, semver, getopts};\n use syntax::codemap::spanned;\n use syntax::{ast, attr, codemap, diagnostic, parse, visit};\n+use core::container::Map;\n \n mod usage;\n mod util;"}, {"sha": "7238a934c9956e3139d6d0e79cf57b1c0070784d", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6267339d6869a27b95f13c578a235204a1562697/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6267339d6869a27b95f13c578a235204a1562697/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=6267339d6869a27b95f13c578a235204a1562697", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use core::*;\n+use core::hash::{Hash, HashUtil, Streaming};\n use core::hashmap::linear::LinearMap;\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;"}, {"sha": "e3437fc57aaed8515de5d24ec65dbfcc7586acba", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6267339d6869a27b95f13c578a235204a1562697/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6267339d6869a27b95f13c578a235204a1562697/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=6267339d6869a27b95f13c578a235204a1562697", "patch": "@@ -25,6 +25,27 @@ pub struct DuplexStream<T, U> {\n     priv port: Port<U>,\n }\n \n+// Allow these methods to be used without import:\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<T:Owned,U:Owned> DuplexStream<T, U> {\n+    fn send(x: T) {\n+        self.chan.send(x)\n+    }\n+    fn try_send(x: T) -> bool {\n+        self.chan.try_send(x)\n+    }\n+    fn recv() -> U {\n+        self.port.recv()\n+    }\n+    fn try_recv() -> Option<U> {\n+        self.port.try_recv()\n+    }\n+    pure fn peek() -> bool {\n+        self.port.peek()\n+    }\n+}\n+\n impl<T:Owned,U:Owned> GenericChan<T> for DuplexStream<T, U> {\n     fn send(&self, x: T) {\n         self.chan.send(x)"}, {"sha": "0458636a401ef5be00402a224e8dd09c6673ae5d", "filename": "src/test/auxiliary/coherence_inherent_cc_lib.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6267339d6869a27b95f13c578a235204a1562697/src%2Ftest%2Fauxiliary%2Fcoherence_inherent_cc_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6267339d6869a27b95f13c578a235204a1562697/src%2Ftest%2Fauxiliary%2Fcoherence_inherent_cc_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcoherence_inherent_cc_lib.rs?ref=6267339d6869a27b95f13c578a235204a1562697", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// See coherence_inherent_cc.rs\n+\n+pub trait TheTrait {\n+    fn the_fn(&self);\n+}\n+\n+pub struct TheStruct;\n+\n+impl TheTrait for TheStruct {\n+    fn the_fn(&self) {}\n+}"}, {"sha": "590c12826e4fe834698c3604de827859d88754f5", "filename": "src/test/compile-fail/coherence_inherent.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6267339d6869a27b95f13c578a235204a1562697/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6267339d6869a27b95f13c578a235204a1562697/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs?ref=6267339d6869a27b95f13c578a235204a1562697", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that methods that implement a trait cannot be invoked\n+// unless the trait is imported.\n+\n+mod Lib {\n+    pub trait TheTrait {\n+        fn the_fn(&self);\n+    }\n+\n+    pub struct TheStruct;\n+\n+    impl TheTrait for TheStruct {\n+        fn the_fn(&self) {}\n+    }\n+}\n+\n+mod Import {\n+    // Trait is in scope here:\n+    use Lib::TheStruct;\n+    use Lib::TheTrait;\n+\n+    fn call_the_fn(s: &TheStruct) {\n+        s.the_fn();\n+    }\n+}\n+\n+mod NoImport {\n+    // Trait is not in scope here:\n+    use Lib::TheStruct;\n+\n+    fn call_the_fn(s: &TheStruct) {\n+        s.the_fn(); //~ ERROR does not implement any method in scope named `the_fn`\n+    }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "72c6df57c4ff580946ed9eb099c65565a6be6360", "filename": "src/test/compile-fail/coherence_inherent_cc.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6267339d6869a27b95f13c578a235204a1562697/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6267339d6869a27b95f13c578a235204a1562697/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs?ref=6267339d6869a27b95f13c578a235204a1562697", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast\n+// aux-build:coherence_inherent_cc_lib.rs\n+\n+// Tests that methods that implement a trait cannot be invoked\n+// unless the trait is imported.\n+\n+extern mod coherence_inherent_cc_lib;\n+\n+mod Import {\n+    // Trait is in scope here:\n+    use coherence_inherent_cc_lib::TheStruct;\n+    use coherence_inherent_cc_lib::TheTrait;\n+\n+    fn call_the_fn(s: &TheStruct) {\n+        s.the_fn();\n+    }\n+}\n+\n+mod NoImport {\n+    // Trait is not in scope here:\n+    use coherence_inherent_cc_lib::TheStruct;\n+\n+    fn call_the_fn(s: &TheStruct) {\n+        s.the_fn(); //~ ERROR does not implement any method in scope named `the_fn`\n+    }\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "01f68929b90a709366304f3cf8d83b11c711a0d7", "filename": "src/test/run-pass/pipe-presentation-examples.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6267339d6869a27b95f13c578a235204a1562697/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6267339d6869a27b95f13c578a235204a1562697/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-presentation-examples.rs?ref=6267339d6869a27b95f13c578a235204a1562697", "patch": "@@ -17,6 +17,7 @@\n \n use double_buffer::client::*;\n use double_buffer::give_buffer;\n+use core::comm::Selectable;\n \n macro_rules! select_if (\n     {"}, {"sha": "f344837a22d73f955efa28de18e7e79e74a34f5c", "filename": "src/test/run-pass/trait-inheritance-cross-trait-call-xc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6267339d6869a27b95f13c578a235204a1562697/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6267339d6869a27b95f13c578a235204a1562697/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-cross-trait-call-xc.rs?ref=6267339d6869a27b95f13c578a235204a1562697", "patch": "@@ -13,7 +13,9 @@\n \n extern mod aux(name = \"trait_inheritance_cross_trait_call_xc_aux\");\n \n-trait Bar : aux::Foo {\n+use aux::Foo;\n+\n+trait Bar : Foo {\n     fn g() -> int;\n }\n "}]}