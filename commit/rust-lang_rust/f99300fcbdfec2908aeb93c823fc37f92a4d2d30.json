{"sha": "f99300fcbdfec2908aeb93c823fc37f92a4d2d30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5OTMwMGZjYmRmZWMyOTA4YWViOTNjODIzZmMzN2Y5MmE0ZDJkMzA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-17T18:55:42Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-19T13:32:30Z"}, "message": "pull `relate_type_and_user_type` code into `type_check` module\n\nIt's really layered atop the core \"relate-types\" code", "tree": {"sha": "d20774e43c5a4465a27a1e62a396a0fb535edfb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d20774e43c5a4465a27a1e62a396a0fb535edfb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f99300fcbdfec2908aeb93c823fc37f92a4d2d30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f99300fcbdfec2908aeb93c823fc37f92a4d2d30", "html_url": "https://github.com/rust-lang/rust/commit/f99300fcbdfec2908aeb93c823fc37f92a4d2d30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f99300fcbdfec2908aeb93c823fc37f92a4d2d30/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7ab33e7a61ff046f1736f1b027c16d9494e20b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7ab33e7a61ff046f1736f1b027c16d9494e20b8", "html_url": "https://github.com/rust-lang/rust/commit/e7ab33e7a61ff046f1736f1b027c16d9494e20b8"}], "stats": {"total": 231, "additions": 99, "deletions": 132}, "files": [{"sha": "823a249760f5b70ac79df4009c167e2236181c43", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 85, "deletions": 26, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/f99300fcbdfec2908aeb93c823fc37f92a4d2d30/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f99300fcbdfec2908aeb93c823fc37f92a4d2d30/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=f99300fcbdfec2908aeb93c823fc37f92a4d2d30", "patch": "@@ -42,7 +42,7 @@ use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n+use rustc::ty::subst::{Subst, Substs, UnpackedKind, UserSubsts, UserSelfTy};\n use rustc::ty::{self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n use std::rc::Rc;\n use std::{fmt, iter};\n@@ -901,23 +901,37 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn sub_types(\n+    /// Convenient wrapper around `relate_tys::relate_types` -- see\n+    /// that fn for docs.\n+    fn relate_types(\n         &mut self,\n-        sub: Ty<'tcx>,\n-        sup: Ty<'tcx>,\n+        a: Ty<'tcx>,\n+        v: ty::Variance,\n+        b: Ty<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n-        relate_tys::sub_types(\n+        relate_tys::relate_types(\n             self.infcx,\n-            sub,\n-            sup,\n+            a,\n+            v,\n+            b,\n             locations,\n             category,\n             self.borrowck_context.as_mut().map(|x| &mut **x),\n         )\n     }\n \n+    fn sub_types(\n+        &mut self,\n+        sub: Ty<'tcx>,\n+        sup: Ty<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Fallible<()> {\n+        self.relate_types(sub, ty::Variance::Covariant, sup, locations, category)\n+    }\n+\n     /// Try to relate `sub <: sup`; if this fails, instantiate opaque\n     /// variables in `sub` with their inferred definitions and try\n     /// again. This is used for opaque types in places (e.g., `let x:\n@@ -950,34 +964,79 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n-        relate_tys::eq_types(\n-            self.infcx,\n-            a,\n-            b,\n-            locations,\n-            category,\n-            self.borrowck_context.as_mut().map(|x| &mut **x),\n-        )\n+        self.relate_types(a, ty::Variance::Invariant, b, locations, category)\n     }\n \n     fn relate_type_and_user_type(\n         &mut self,\n         a: Ty<'tcx>,\n         v: ty::Variance,\n-        b: UserTypeAnnotation<'tcx>,\n+        user_ty: UserTypeAnnotation<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n-        let ty = relate_tys::relate_type_and_user_type(\n-            self.infcx,\n-            a,\n-            v,\n-            b,\n-            locations,\n-            category,\n-            self.borrowck_context.as_mut().map(|x| &mut **x),\n-        )?;\n-        self.prove_predicate(ty::Predicate::WellFormed(ty), locations, category);\n+        let tcx = self.tcx();\n+\n+        debug!(\n+            \"relate_type_and_user_type(a={:?}, v={:?}, b={:?}, locations={:?})\",\n+            a, v, user_ty, locations\n+        );\n+\n+        // The `TypeRelating` code assumes that \"unresolved inference\n+        // variables\" appear in the \"a\" side, so flip `Contravariant`\n+        // ambient variance to get the right relationship.\n+        let v1 = ty::Contravariant.xform(v);\n+\n+        match user_ty {\n+            UserTypeAnnotation::Ty(canonical_ty) => {\n+                let (ty, _) = self.infcx\n+                    .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_ty);\n+\n+                self.relate_types(ty, v1, a, locations, category)?;\n+\n+                self.prove_predicate(ty::Predicate::WellFormed(ty), locations, category);\n+            }\n+            UserTypeAnnotation::TypeOf(def_id, canonical_substs) => {\n+                let (\n+                    UserSubsts {\n+                        substs,\n+                        user_self_ty,\n+                    },\n+                    _,\n+                ) = self.infcx\n+                    .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_substs);\n+\n+                let ty = self.tcx().type_of(def_id);\n+                let ty = ty.subst(tcx, substs);\n+\n+                self.relate_types(ty, v1, a, locations, category)?;\n+\n+                if let Some(UserSelfTy {\n+                    impl_def_id,\n+                    self_ty,\n+                }) = user_self_ty\n+                {\n+                    let impl_self_ty = tcx.type_of(impl_def_id);\n+                    let impl_self_ty = impl_self_ty.subst(tcx, &substs);\n+\n+                    // There may be type variables in `substs` and hence\n+                    // in `impl_self_ty`, but they should all have been\n+                    // resolved to some fixed value during the first call\n+                    // to `relate`, above. Therefore, if we use\n+                    // `resolve_type_vars_if_possible` we should get to\n+                    // something without type variables. This is important\n+                    // because the `b` type in `relate_with_variance`\n+                    // below is not permitted to have inference variables.\n+                    let impl_self_ty = self.infcx.resolve_type_vars_if_possible(&impl_self_ty);\n+                    assert!(!impl_self_ty.has_infer_types());\n+\n+                    self.eq_types(self_ty, impl_self_ty, locations, category)?;\n+                }\n+\n+                self.prove_predicate(ty::Predicate::WellFormed(ty), locations, category);\n+            }\n+        }\n+\n         Ok(())\n     }\n "}, {"sha": "13ebf46bdb14904fa56eb17bf9182e52668d376f", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 14, "deletions": 106, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f99300fcbdfec2908aeb93c823fc37f92a4d2d30/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f99300fcbdfec2908aeb93c823fc37f92a4d2d30/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=f99300fcbdfec2908aeb93c823fc37f92a4d2d30", "patch": "@@ -12,35 +12,23 @@ use borrow_check::nll::constraints::OutlivesConstraint;\n use borrow_check::nll::type_check::{BorrowCheckContext, Locations};\n use rustc::infer::nll_relate::{TypeRelating, TypeRelatingDelegate};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n-use rustc::mir::{ConstraintCategory, UserTypeAnnotation};\n+use rustc::mir::ConstraintCategory;\n use rustc::traits::query::Fallible;\n use rustc::ty::relate::TypeRelation;\n-use rustc::ty::subst::{Subst, UserSelfTy, UserSubsts};\n-use rustc::ty::{self, Ty, TypeFoldable};\n-use syntax_pos::DUMMY_SP;\n-\n-/// Adds sufficient constraints to ensure that `a <: b`.\n-pub(super) fn sub_types<'tcx>(\n-    infcx: &InferCtxt<'_, '_, 'tcx>,\n-    a: Ty<'tcx>,\n-    b: Ty<'tcx>,\n-    locations: Locations,\n-    category: ConstraintCategory,\n-    borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n-) -> Fallible<()> {\n-    debug!(\"sub_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n-    TypeRelating::new(\n-        infcx,\n-        NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n-        ty::Variance::Covariant,\n-    ).relate(&a, &b)?;\n-    Ok(())\n-}\n-\n-/// Adds sufficient constraints to ensure that `a == b`.\n-pub(super) fn eq_types<'tcx>(\n+use rustc::ty::{self, Ty};\n+\n+/// Adds sufficient constraints to ensure that `a R b` where `R` depends on `v`:\n+///\n+/// - \"Covariant\" `a <: b`\n+/// - \"Invariant\" `a == b`\n+/// - \"Contravariant\" `a :> b`\n+///\n+/// NB. The type `a` is permitted to have unresolved inference\n+/// variables, but not the type `b`.\n+pub(super) fn relate_types<'tcx>(\n     infcx: &InferCtxt<'_, '_, 'tcx>,\n     a: Ty<'tcx>,\n+    v: ty::Variance,\n     b: Ty<'tcx>,\n     locations: Locations,\n     category: ConstraintCategory,\n@@ -50,91 +38,11 @@ pub(super) fn eq_types<'tcx>(\n     TypeRelating::new(\n         infcx,\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n-        ty::Variance::Invariant,\n+        v,\n     ).relate(&a, &b)?;\n     Ok(())\n }\n \n-/// Adds sufficient constraints to ensure that `a <: b`, where `b` is\n-/// a user-given type (which means it may have canonical variables\n-/// encoding things like `_`).\n-pub(super) fn relate_type_and_user_type<'tcx>(\n-    infcx: &InferCtxt<'_, '_, 'tcx>,\n-    a: Ty<'tcx>,\n-    v: ty::Variance,\n-    user_ty: UserTypeAnnotation<'tcx>,\n-    locations: Locations,\n-    category: ConstraintCategory,\n-    borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n-) -> Fallible<Ty<'tcx>> {\n-    debug!(\n-        \"relate_type_and_user_type(a={:?}, v={:?}, b={:?}, locations={:?})\",\n-        a, v, user_ty, locations\n-    );\n-\n-    // The `TypeRelating` code assumes that the \"canonical variables\"\n-    // appear in the \"a\" side, so flip `Contravariant` ambient\n-    // variance to get the right relationship.\n-    let v1 = ty::Contravariant.xform(v);\n-\n-    let mut type_relating = TypeRelating::new(\n-        infcx,\n-        NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n-        v1,\n-    );\n-\n-    match user_ty {\n-        UserTypeAnnotation::Ty(canonical_ty) => {\n-            let (ty, _) =\n-                infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_ty);\n-            type_relating.relate(&ty, &a)?;\n-            Ok(ty)\n-        }\n-        UserTypeAnnotation::TypeOf(def_id, canonical_substs) => {\n-            let (\n-                UserSubsts {\n-                    substs,\n-                    user_self_ty,\n-                },\n-                _,\n-            ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_substs);\n-\n-            let ty = infcx.tcx.type_of(def_id);\n-            let ty = ty.subst(infcx.tcx, substs);\n-\n-            type_relating.relate(&ty, &a)?;\n-\n-            if let Some(UserSelfTy {\n-                impl_def_id,\n-                self_ty,\n-            }) = user_self_ty\n-            {\n-                let impl_self_ty = infcx.tcx.type_of(impl_def_id);\n-                let impl_self_ty = impl_self_ty.subst(infcx.tcx, &substs);\n-\n-                // There may be type variables in `substs` and hence\n-                // in `impl_self_ty`, but they should all have been\n-                // resolved to some fixed value during the first call\n-                // to `relate`, above. Therefore, if we use\n-                // `resolve_type_vars_if_possible` we should get to\n-                // something without type variables. This is important\n-                // because the `b` type in `relate_with_variance`\n-                // below is not permitted to have inference variables.\n-                let impl_self_ty = infcx.resolve_type_vars_if_possible(&impl_self_ty);\n-                assert!(!impl_self_ty.has_infer_types());\n-\n-                type_relating.relate_with_variance(\n-                    ty::Variance::Invariant,\n-                    &self_ty,\n-                    &impl_self_ty,\n-                )?;\n-            }\n-\n-            Ok(ty)\n-        }\n-    }\n-}\n-\n struct NllTypeRelatingDelegate<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n     infcx: &'me InferCtxt<'me, 'gcx, 'tcx>,\n     borrowck_context: Option<&'me mut BorrowCheckContext<'bccx, 'tcx>>,"}]}