{"sha": "57b371ab145698bce32425dc8566bcf80ac98f63", "node_id": "C_kwDOAAsO6NoAKDU3YjM3MWFiMTQ1Njk4YmNlMzI0MjVkYzg1NjZiY2Y4MGFjOThmNjM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-13T18:16:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-13T18:16:43Z"}, "message": "Rollup merge of #106641 - chenyukang:yukang/fix-105761-segguest-this, r=estebank\n\nProvide help on closures capturing self causing borrow checker errors\n\nFixes #105761\n\nr? ````@estebank````", "tree": {"sha": "20b2d61339a6b7863cb04201e842ce5071e2152a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20b2d61339a6b7863cb04201e842ce5071e2152a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57b371ab145698bce32425dc8566bcf80ac98f63", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjwaALCRBK7hj4Ov3rIwAAgn0IAAEpzlbOzYRe8Abjs8rAWgdR\ntW8fjmNYRymodnrjOX7LFYfywj6yfTO9J47aYEd1L4CCoM4yf3dlwtYM9RClYvSV\naWe0/fjJTkZt4dJbgInPQxjXMNJmOy/dlzmSxsT0qqtOcPu5XTZ8DdfvzCTJ1cbq\nkTmQalaHRAgZ6s7g2fsy4iY026wRAq084dEntQctcf/aovbUv5aukVlVaIzrtzaj\n+j038GGymOrH7l7YfDUrddfNYk6iMLntsyuj283ejU6mel+3aPnopUBHzjqgpoyE\nkJ9wj7F59Vx2DEpwoACBuseT1Urz8koL0E1kFHh6GMAKP85oUXyi7aoo4fevGkA=\n=fpX8\n-----END PGP SIGNATURE-----\n", "payload": "tree 20b2d61339a6b7863cb04201e842ce5071e2152a\nparent c6e3a47843649a2d7658272f7aee5c2e529b5ce4\nparent eafbca916632ef8a92570fe3bf2c88ac6fbb3665\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1673633803 +0100\ncommitter GitHub <noreply@github.com> 1673633803 +0100\n\nRollup merge of #106641 - chenyukang:yukang/fix-105761-segguest-this, r=estebank\n\nProvide help on closures capturing self causing borrow checker errors\n\nFixes #105761\n\nr? ````@estebank````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57b371ab145698bce32425dc8566bcf80ac98f63", "html_url": "https://github.com/rust-lang/rust/commit/57b371ab145698bce32425dc8566bcf80ac98f63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57b371ab145698bce32425dc8566bcf80ac98f63/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6e3a47843649a2d7658272f7aee5c2e529b5ce4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6e3a47843649a2d7658272f7aee5c2e529b5ce4", "html_url": "https://github.com/rust-lang/rust/commit/c6e3a47843649a2d7658272f7aee5c2e529b5ce4"}, {"sha": "eafbca916632ef8a92570fe3bf2c88ac6fbb3665", "url": "https://api.github.com/repos/rust-lang/rust/commits/eafbca916632ef8a92570fe3bf2c88ac6fbb3665", "html_url": "https://github.com/rust-lang/rust/commit/eafbca916632ef8a92570fe3bf2c88ac6fbb3665"}], "stats": {"total": 255, "additions": 250, "deletions": 5}, "files": [{"sha": "968c1f49b95c00ccec072fc253421936dc258f90", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 144, "deletions": 4, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/57b371ab145698bce32425dc8566bcf80ac98f63/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57b371ab145698bce32425dc8566bcf80ac98f63/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=57b371ab145698bce32425dc8566bcf80ac98f63", "patch": "@@ -6,6 +6,7 @@ use rustc_errors::{\n     struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n+use rustc_hir::def::Res;\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, LangItem};\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -20,7 +21,7 @@ use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n \n@@ -29,6 +30,7 @@ use crate::borrowck_errors;\n \n use crate::diagnostics::conflict_errors::StorageDeadOrDrop::LocalStorageDead;\n use crate::diagnostics::find_all_local_uses;\n+use crate::diagnostics::mutability_errors::mut_borrow_of_mutable_ref;\n use crate::{\n     borrow_set::BorrowData, diagnostics::Instance, prefixes::IsPrefixOf,\n     InitializationRequiringAction, MirBorrowckCtxt, PrefixSet, WriteKind,\n@@ -356,7 +358,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let Some(hir::Node::Item(hir::Item {\n             kind: hir::ItemKind::Fn(_, _, body_id),\n             ..\n-        })) = hir.find(hir.local_def_id_to_hir_id(self.mir_def_id()))\n+        })) = hir.find(self.mir_hir_id())\n             && let Some(hir::Node::Expr(expr)) = hir.find(body_id.hir_id)\n         {\n             let place = &self.move_data.move_paths[mpi].place;\n@@ -948,7 +950,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n             (BorrowKind::Mut { .. }, BorrowKind::Shared) => {\n                 first_borrow_desc = \"immutable \";\n-                self.cannot_reborrow_already_borrowed(\n+                let mut err = self.cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     &msg_place,\n@@ -958,7 +960,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     \"immutable\",\n                     &msg_borrow,\n                     None,\n-                )\n+                );\n+                self.suggest_binding_for_closure_capture_self(\n+                    &mut err,\n+                    issued_borrow.borrowed_place,\n+                    &issued_spans,\n+                );\n+                err\n             }\n \n             (BorrowKind::Mut { .. }, BorrowKind::Mut { .. }) => {\n@@ -1240,6 +1248,138 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    fn suggest_binding_for_closure_capture_self(\n+        &self,\n+        err: &mut Diagnostic,\n+        borrowed_place: Place<'tcx>,\n+        issued_spans: &UseSpans<'tcx>,\n+    ) {\n+        let UseSpans::ClosureUse { capture_kind_span, .. } = issued_spans else { return };\n+        let hir = self.infcx.tcx.hir();\n+\n+        // check whether the borrowed place is capturing `self` by mut reference\n+        let local = borrowed_place.local;\n+        let Some(_) = self\n+            .body\n+            .local_decls\n+            .get(local)\n+            .map(|l| mut_borrow_of_mutable_ref(l, self.local_names[local])) else { return };\n+\n+        struct ExpressionFinder<'hir> {\n+            capture_span: Span,\n+            closure_change_spans: Vec<Span>,\n+            closure_arg_span: Option<Span>,\n+            in_closure: bool,\n+            suggest_arg: String,\n+            hir: rustc_middle::hir::map::Map<'hir>,\n+            closure_local_id: Option<hir::HirId>,\n+            closure_call_changes: Vec<(Span, String)>,\n+        }\n+        impl<'hir> Visitor<'hir> for ExpressionFinder<'hir> {\n+            fn visit_expr(&mut self, e: &'hir hir::Expr<'hir>) {\n+                if e.span.contains(self.capture_span) {\n+                    if let hir::ExprKind::Closure(&hir::Closure {\n+                            movability: None,\n+                            body,\n+                            fn_arg_span,\n+                            fn_decl: hir::FnDecl{ inputs, .. },\n+                            ..\n+                        }) = e.kind &&\n+                        let Some(hir::Node::Expr(body )) = self.hir.find(body.hir_id) {\n+                            self.suggest_arg = \"this: &Self\".to_string();\n+                            if inputs.len() > 0 {\n+                                self.suggest_arg.push_str(\", \");\n+                            }\n+                            self.in_closure = true;\n+                            self.closure_arg_span = fn_arg_span;\n+                            self.visit_expr(body);\n+                            self.in_closure = false;\n+                    }\n+                }\n+                if let hir::Expr { kind: hir::ExprKind::Path(path), .. } = e {\n+                    if let hir::QPath::Resolved(_, hir::Path { segments: [seg], ..}) = path &&\n+                        seg.ident.name == kw::SelfLower && self.in_closure {\n+                            self.closure_change_spans.push(e.span);\n+                    }\n+                }\n+                hir::intravisit::walk_expr(self, e);\n+            }\n+\n+            fn visit_local(&mut self, local: &'hir hir::Local<'hir>) {\n+                if let hir::Pat { kind: hir::PatKind::Binding(_, hir_id, _ident, _), .. } = local.pat &&\n+                    let Some(init) = local.init\n+                {\n+                    if let hir::Expr { kind: hir::ExprKind::Closure(&hir::Closure {\n+                            movability: None,\n+                            ..\n+                        }), .. } = init &&\n+                        init.span.contains(self.capture_span) {\n+                            self.closure_local_id = Some(*hir_id);\n+                    }\n+                }\n+                hir::intravisit::walk_local(self, local);\n+            }\n+\n+            fn visit_stmt(&mut self, s: &'hir hir::Stmt<'hir>) {\n+                if let hir::StmtKind::Semi(e) = s.kind &&\n+                    let hir::ExprKind::Call(hir::Expr { kind: hir::ExprKind::Path(path), ..}, args) = e.kind &&\n+                    let hir::QPath::Resolved(_, hir::Path { segments: [seg], ..}) = path &&\n+                    let Res::Local(hir_id) = seg.res &&\n+                        Some(hir_id) == self.closure_local_id {\n+                        let (span, arg_str) = if args.len() > 0 {\n+                            (args[0].span.shrink_to_lo(), \"self, \".to_string())\n+                        } else {\n+                            let span = e.span.trim_start(seg.ident.span).unwrap_or(e.span);\n+                            (span, \"(self)\".to_string())\n+                        };\n+                        self.closure_call_changes.push((span, arg_str));\n+                }\n+                hir::intravisit::walk_stmt(self, s);\n+            }\n+        }\n+\n+        if let Some(hir::Node::ImplItem(\n+                    hir::ImplItem { kind: hir::ImplItemKind::Fn(_fn_sig, body_id), .. }\n+                )) = hir.find(self.mir_hir_id()) &&\n+            let Some(hir::Node::Expr(expr)) = hir.find(body_id.hir_id) {\n+            let mut finder = ExpressionFinder {\n+                capture_span: *capture_kind_span,\n+                closure_change_spans: vec![],\n+                closure_arg_span: None,\n+                in_closure: false,\n+                suggest_arg: String::new(),\n+                closure_local_id: None,\n+                closure_call_changes: vec![],\n+                hir,\n+            };\n+            finder.visit_expr(expr);\n+\n+            if finder.closure_change_spans.is_empty() || finder.closure_call_changes.is_empty() {\n+                return;\n+            }\n+\n+            let mut sugg = vec![];\n+            let sm = self.infcx.tcx.sess.source_map();\n+\n+            if let Some(span) = finder.closure_arg_span {\n+                sugg.push((sm.next_point(span.shrink_to_lo()).shrink_to_hi(), finder.suggest_arg));\n+            }\n+            for span in finder.closure_change_spans {\n+                sugg.push((span, \"this\".to_string()));\n+            }\n+\n+            for (span, suggest) in finder.closure_call_changes {\n+                sugg.push((span, suggest));\n+            }\n+\n+            err.multipart_suggestion_verbose(\n+                \"try explicitly pass `&Self` into the Closure as an argument\",\n+                sugg,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n     /// Returns the description of the root place for a conflicting borrow and the full\n     /// descriptions of the places that caused the conflict.\n     ///"}, {"sha": "45b15c2c5bd7062451a9b947584ecacb2f504d0f", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57b371ab145698bce32425dc8566bcf80ac98f63/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57b371ab145698bce32425dc8566bcf80ac98f63/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=57b371ab145698bce32425dc8566bcf80ac98f63", "patch": "@@ -1094,7 +1094,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n+pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n     debug!(\"local_info: {:?}, ty.kind(): {:?}\", local_decl.local_info, local_decl.ty.kind());\n \n     match local_decl.local_info.as_deref() {"}, {"sha": "78e48364bba001ec5bf7f1a4ba78dd9a444fa424", "filename": "tests/ui/suggestions/issue-105761-suggest-self-for-closure.fixed", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/57b371ab145698bce32425dc8566bcf80ac98f63/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/57b371ab145698bce32425dc8566bcf80ac98f63/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.fixed?ref=57b371ab145698bce32425dc8566bcf80ac98f63", "patch": "@@ -0,0 +1,28 @@\n+//run-rustfix\n+#![allow(unused)]\n+\n+struct S;\n+impl S {\n+    fn foo(&mut self) {\n+        let x = |this: &Self, v: i32| {\n+            this.bar();\n+            this.hel();\n+        };\n+        self.qux(); //~ ERROR cannot borrow `*self` as mutable because it is also borrowed as immutable\n+        x(self, 1);\n+        x(self, 3);\n+    }\n+    fn bar(&self) {}\n+    fn hel(&self) {}\n+    fn qux(&mut self) {}\n+\n+    fn hello(&mut self) {\n+        let y = |this: &Self| {\n+            this.bar();\n+        };\n+        self.qux(); //~ ERROR cannot borrow `*self` as mutable because it is also borrowed as immutable\n+        y(self);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6d8a9ffc12d3938e7a04772f9a8df1897137b5bb", "filename": "tests/ui/suggestions/issue-105761-suggest-self-for-closure.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/57b371ab145698bce32425dc8566bcf80ac98f63/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57b371ab145698bce32425dc8566bcf80ac98f63/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.rs?ref=57b371ab145698bce32425dc8566bcf80ac98f63", "patch": "@@ -0,0 +1,28 @@\n+//run-rustfix\n+#![allow(unused)]\n+\n+struct S;\n+impl S {\n+    fn foo(&mut self) {\n+        let x = |v: i32| {\n+            self.bar();\n+            self.hel();\n+        };\n+        self.qux(); //~ ERROR cannot borrow `*self` as mutable because it is also borrowed as immutable\n+        x(1);\n+        x(3);\n+    }\n+    fn bar(&self) {}\n+    fn hel(&self) {}\n+    fn qux(&mut self) {}\n+\n+    fn hello(&mut self) {\n+        let y = || {\n+            self.bar();\n+        };\n+        self.qux(); //~ ERROR cannot borrow `*self` as mutable because it is also borrowed as immutable\n+        y();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "bc97d32ebb6e52e8a76347bc15a4cef75b17749a", "filename": "tests/ui/suggestions/issue-105761-suggest-self-for-closure.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/57b371ab145698bce32425dc8566bcf80ac98f63/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/57b371ab145698bce32425dc8566bcf80ac98f63/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-105761-suggest-self-for-closure.stderr?ref=57b371ab145698bce32425dc8566bcf80ac98f63", "patch": "@@ -0,0 +1,49 @@\n+error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable\n+  --> $DIR/issue-105761-suggest-self-for-closure.rs:11:9\n+   |\n+LL |         let x = |v: i32| {\n+   |                 -------- immutable borrow occurs here\n+LL |             self.bar();\n+   |             ---- first borrow occurs due to use of `self` in closure\n+...\n+LL |         self.qux();\n+   |         ^^^^^^^^^^ mutable borrow occurs here\n+LL |         x(1);\n+   |         - immutable borrow later used here\n+   |\n+help: try explicitly pass `&Self` into the Closure as an argument\n+   |\n+LL ~         let x = |this: &Self, v: i32| {\n+LL ~             this.bar();\n+LL ~             this.hel();\n+LL |         };\n+LL |         self.qux();\n+LL ~         x(self, 1);\n+LL ~         x(self, 3);\n+   |\n+\n+error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable\n+  --> $DIR/issue-105761-suggest-self-for-closure.rs:23:9\n+   |\n+LL |         let y = || {\n+   |                 -- immutable borrow occurs here\n+LL |             self.bar();\n+   |             ---- first borrow occurs due to use of `self` in closure\n+LL |         };\n+LL |         self.qux();\n+   |         ^^^^^^^^^^ mutable borrow occurs here\n+LL |         y();\n+   |         - immutable borrow later used here\n+   |\n+help: try explicitly pass `&Self` into the Closure as an argument\n+   |\n+LL ~         let y = |this: &Self| {\n+LL ~             this.bar();\n+LL |         };\n+LL |         self.qux();\n+LL ~         y(self);\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0502`."}]}