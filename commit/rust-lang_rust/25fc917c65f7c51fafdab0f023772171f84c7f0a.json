{"sha": "25fc917c65f7c51fafdab0f023772171f84c7f0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZmM5MTdjNjVmN2M1MWZhZmRhYjBmMDIzNzcyMTcxZjg0YzdmMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-29T07:07:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-29T07:07:07Z"}, "message": "Auto merge of #25747 - SimonSapin:map_ref, r=alexcrichton\n\nFor slightly complex data structures like `rustc_serialize::json::Json`, it is often convenient to have helper methods like `Json::as_string(&self) -> Option<&str>`  that return a borrow of some component of `&self`.\r\n\r\nHowever, when `RefCell`s are involved, keeping a `Ref` around is required to hold a borrow to the insides of a `RefCell`. But `Ref` so far only references the entirety of the contents of a `RefCell`, not a component. But there is no reason it couldn\u2019t: `Ref` internally contains just a data reference and a borrow count reference. The two can be dissociated.\r\n\r\nThis adds a `map_ref` function that creates a new `Ref` for some other data, but borrowing the same `RefCell` as an existing `Ref`.\r\n\r\nExample:\r\n\r\n```rust\r\nstruct RefCellJson(RefCell<Json>);\r\n\r\nimpl RefCellJson {\r\n    fn as_string(&self) -> Option<Ref<str>> {\r\n        map_ref(self.borrow(), |j| j.as_string())\r\n    }\r\n}\r\n```\r\n\r\nr? @alexcrichton", "tree": {"sha": "c30bec8b690dc6cee25c5e43deb79e2ddd9f2581", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c30bec8b690dc6cee25c5e43deb79e2ddd9f2581"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25fc917c65f7c51fafdab0f023772171f84c7f0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25fc917c65f7c51fafdab0f023772171f84c7f0a", "html_url": "https://github.com/rust-lang/rust/commit/25fc917c65f7c51fafdab0f023772171f84c7f0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25fc917c65f7c51fafdab0f023772171f84c7f0a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42a59aef710c66e17627e00cc4d00cf29a7b46ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/42a59aef710c66e17627e00cc4d00cf29a7b46ed", "html_url": "https://github.com/rust-lang/rust/commit/42a59aef710c66e17627e00cc4d00cf29a7b46ed"}, {"sha": "d0afa6ede3ce5fd6b35c8f1fd5fc89336ec2dc96", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0afa6ede3ce5fd6b35c8f1fd5fc89336ec2dc96", "html_url": "https://github.com/rust-lang/rust/commit/d0afa6ede3ce5fd6b35c8f1fd5fc89336ec2dc96"}], "stats": {"total": 237, "additions": 231, "deletions": 6}, "files": [{"sha": "c5d08c3dd20ad564267ea2c6eb8263efdb338e64", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 152, "deletions": 4, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/25fc917c65f7c51fafdab0f023772171f84c7f0a/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fc917c65f7c51fafdab0f023772171f84c7f0a/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=25fc917c65f7c51fafdab0f023772171f84c7f0a", "patch": "@@ -146,7 +146,7 @@ use clone::Clone;\n use cmp::{PartialEq, Eq};\n use default::Default;\n use marker::{Copy, Send, Sync, Sized};\n-use ops::{Deref, DerefMut, Drop};\n+use ops::{Deref, DerefMut, Drop, FnOnce};\n use option::Option;\n use option::Option::{None, Some};\n \n@@ -551,13 +551,161 @@ impl<'b, T: ?Sized> Deref for Ref<'b, T> {\n ///\n /// A `Clone` implementation would interfere with the widespread\n /// use of `r.borrow().clone()` to clone the contents of a `RefCell`.\n+#[deprecated(since = \"1.2.0\", reason = \"moved to a `Ref::clone` associated function\")]\n #[unstable(feature = \"core\",\n            reason = \"likely to be moved to a method, pending language changes\")]\n #[inline]\n pub fn clone_ref<'b, T:Clone>(orig: &Ref<'b, T>) -> Ref<'b, T> {\n-    Ref {\n-        _value: orig._value,\n-        _borrow: orig._borrow.clone(),\n+    Ref::clone(orig)\n+}\n+\n+impl<'b, T: ?Sized> Ref<'b, T> {\n+    /// Copies a `Ref`.\n+    ///\n+    /// The `RefCell` is already immutably borrowed, so this cannot fail.\n+    ///\n+    /// This is an associated function that needs to be used as `Ref::clone(...)`.\n+    /// A `Clone` implementation or a method would interfere with the widespread\n+    /// use of `r.borrow().clone()` to clone the contents of a `RefCell`.\n+    #[unstable(feature = \"cell_extras\",\n+               reason = \"likely to be moved to a method, pending language changes\")]\n+    #[inline]\n+    pub fn clone(orig: &Ref<'b, T>) -> Ref<'b, T> {\n+        Ref {\n+            _value: orig._value,\n+            _borrow: orig._borrow.clone(),\n+        }\n+    }\n+\n+    /// Make a new `Ref` for a component of the borrowed data.\n+    ///\n+    /// The `RefCell` is already immutably borrowed, so this cannot fail.\n+    ///\n+    /// This is an associated function that needs to be used as `Ref::map(...)`.\n+    /// A method would interfere with methods of the same name on the contents of a `RefCell`\n+    /// used through `Deref`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # #![feature(cell_extras)]\n+    /// use std::cell::{RefCell, Ref};\n+    ///\n+    /// let c = RefCell::new((5, 'b'));\n+    /// let b1: Ref<(u32, char)> = c.borrow();\n+    /// let b2: Ref<u32> = Ref::map(b1, |t| &t.0);\n+    /// assert_eq!(*b2, 5)\n+    /// ```\n+    #[unstable(feature = \"cell_extras\", reason = \"recently added\")]\n+    #[inline]\n+    pub fn map<U: ?Sized, F>(orig: Ref<'b, T>, f: F) -> Ref<'b, U>\n+        where F: FnOnce(&T) -> &U\n+    {\n+        Ref {\n+            _value: f(orig._value),\n+            _borrow: orig._borrow,\n+        }\n+    }\n+\n+    /// Make a new `Ref` for a optional component of the borrowed data, e.g. an enum variant.\n+    ///\n+    /// The `RefCell` is already immutably borrowed, so this cannot fail.\n+    ///\n+    /// This is an associated function that needs to be used as `Ref::filter_map(...)`.\n+    /// A method would interfere with methods of the same name on the contents of a `RefCell`\n+    /// used through `Deref`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # #![feature(cell_extras)]\n+    /// use std::cell::{RefCell, Ref};\n+    ///\n+    /// let c = RefCell::new(Ok(5));\n+    /// let b1: Ref<Result<u32, ()>> = c.borrow();\n+    /// let b2: Ref<u32> = Ref::filter_map(b1, |o| o.as_ref().ok()).unwrap();\n+    /// assert_eq!(*b2, 5)\n+    /// ```\n+    #[unstable(feature = \"cell_extras\", reason = \"recently added\")]\n+    #[inline]\n+    pub fn filter_map<U: ?Sized, F>(orig: Ref<'b, T>, f: F) -> Option<Ref<'b, U>>\n+        where F: FnOnce(&T) -> Option<&U>\n+    {\n+        f(orig._value).map(move |new| Ref {\n+            _value: new,\n+            _borrow: orig._borrow,\n+        })\n+    }\n+}\n+\n+impl<'b, T: ?Sized> RefMut<'b, T> {\n+    /// Make a new `RefMut` for a component of the borrowed data, e.g. an enum variant.\n+    ///\n+    /// The `RefCell` is already mutably borrowed, so this cannot fail.\n+    ///\n+    /// This is an associated function that needs to be used as `RefMut::map(...)`.\n+    /// A method would interfere with methods of the same name on the contents of a `RefCell`\n+    /// used through `Deref`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # #![feature(cell_extras)]\n+    /// use std::cell::{RefCell, RefMut};\n+    ///\n+    /// let c = RefCell::new((5, 'b'));\n+    /// {\n+    ///     let b1: RefMut<(u32, char)> = c.borrow_mut();\n+    ///     let mut b2: RefMut<u32> = RefMut::map(b1, |t| &mut t.0);\n+    ///     assert_eq!(*b2, 5);\n+    ///     *b2 = 42;\n+    /// }\n+    /// assert_eq!(*c.borrow(), (42, 'b'));\n+    /// ```\n+    #[unstable(feature = \"cell_extras\", reason = \"recently added\")]\n+    #[inline]\n+    pub fn map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> RefMut<'b, U>\n+        where F: FnOnce(&mut T) -> &mut U\n+    {\n+        RefMut {\n+            _value: f(orig._value),\n+            _borrow: orig._borrow,\n+        }\n+    }\n+\n+    /// Make a new `RefMut` for a optional component of the borrowed data, e.g. an enum variant.\n+    ///\n+    /// The `RefCell` is already mutably borrowed, so this cannot fail.\n+    ///\n+    /// This is an associated function that needs to be used as `RefMut::filter_map(...)`.\n+    /// A method would interfere with methods of the same name on the contents of a `RefCell`\n+    /// used through `Deref`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # #![feature(cell_extras)]\n+    /// use std::cell::{RefCell, RefMut};\n+    ///\n+    /// let c = RefCell::new(Ok(5));\n+    /// {\n+    ///     let b1: RefMut<Result<u32, ()>> = c.borrow_mut();\n+    ///     let mut b2: RefMut<u32> = RefMut::filter_map(b1, |o| o.as_mut().ok()).unwrap();\n+    ///     assert_eq!(*b2, 5);\n+    ///     *b2 = 42;\n+    /// }\n+    /// assert_eq!(*c.borrow(), Ok(42));\n+    /// ```\n+    #[unstable(feature = \"cell_extras\", reason = \"recently added\")]\n+    #[inline]\n+    pub fn filter_map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> Option<RefMut<'b, U>>\n+        where F: FnOnce(&mut T) -> Option<&mut U>\n+    {\n+        let RefMut { _value, _borrow } = orig;\n+        f(_value).map(move |new| RefMut {\n+            _value: new,\n+            _borrow: _borrow,\n+        })\n     }\n }\n "}, {"sha": "20740a5e2cebc91dc3649cbf6a2c60536c4efe2e", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 78, "deletions": 2, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/25fc917c65f7c51fafdab0f023772171f84c7f0a/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fc917c65f7c51fafdab0f023772171f84c7f0a/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=25fc917c65f7c51fafdab0f023772171f84c7f0a", "patch": "@@ -115,20 +115,96 @@ fn discard_doesnt_unborrow() {\n }\n \n #[test]\n-fn clone_ref_updates_flag() {\n+fn ref_clone_updates_flag() {\n     let x = RefCell::new(0);\n     {\n         let b1 = x.borrow();\n         assert_eq!(x.borrow_state(), BorrowState::Reading);\n         {\n-            let _b2 = clone_ref(&b1);\n+            let _b2 = Ref::clone(&b1);\n             assert_eq!(x.borrow_state(), BorrowState::Reading);\n         }\n         assert_eq!(x.borrow_state(), BorrowState::Reading);\n     }\n     assert_eq!(x.borrow_state(), BorrowState::Unused);\n }\n \n+#[test]\n+fn ref_map_does_not_update_flag() {\n+    let x = RefCell::new(Some(5));\n+    {\n+        let b1: Ref<Option<u32>> = x.borrow();\n+        assert_eq!(x.borrow_state(), BorrowState::Reading);\n+        {\n+            let b2: Ref<u32> = Ref::map(b1, |o| o.as_ref().unwrap());\n+            assert_eq!(*b2, 5);\n+            assert_eq!(x.borrow_state(), BorrowState::Reading);\n+        }\n+        assert_eq!(x.borrow_state(), BorrowState::Unused);\n+    }\n+    assert_eq!(x.borrow_state(), BorrowState::Unused);\n+}\n+\n+#[test]\n+fn ref_map_accessor() {\n+    struct X(RefCell<(u32, char)>);\n+    impl X {\n+        fn accessor(&self) -> Ref<u32> {\n+            Ref::map(self.0.borrow(), |tuple| &tuple.0)\n+        }\n+    }\n+    let x = X(RefCell::new((7, 'z')));\n+    let d: Ref<u32> = x.accessor();\n+    assert_eq!(*d, 7);\n+}\n+\n+#[test]\n+fn ref_filter_map_accessor() {\n+    struct X(RefCell<Result<u32, ()>>);\n+    impl X {\n+        fn accessor(&self) -> Option<Ref<u32>> {\n+            Ref::filter_map(self.0.borrow(), |r| r.as_ref().ok())\n+        }\n+    }\n+    let x = X(RefCell::new(Ok(7)));\n+    let d: Ref<u32> = x.accessor().unwrap();\n+    assert_eq!(*d, 7);\n+}\n+\n+#[test]\n+fn ref_mut_map_accessor() {\n+    struct X(RefCell<(u32, char)>);\n+    impl X {\n+        fn accessor(&self) -> RefMut<u32> {\n+            RefMut::map(self.0.borrow_mut(), |tuple| &mut tuple.0)\n+        }\n+    }\n+    let x = X(RefCell::new((7, 'z')));\n+    {\n+        let mut d: RefMut<u32> = x.accessor();\n+        assert_eq!(*d, 7);\n+        *d += 1;\n+    }\n+    assert_eq!(*x.0.borrow(), (8, 'z'));\n+}\n+\n+#[test]\n+fn ref_mut_filter_map_accessor() {\n+    struct X(RefCell<Result<u32, ()>>);\n+    impl X {\n+        fn accessor(&self) -> Option<RefMut<u32>> {\n+            RefMut::filter_map(self.0.borrow_mut(), |r| r.as_mut().ok())\n+        }\n+    }\n+    let x = X(RefCell::new(Ok(7)));\n+    {\n+        let mut d: RefMut<u32> = x.accessor().unwrap();\n+        assert_eq!(*d, 7);\n+        *d += 1;\n+    }\n+    assert_eq!(*x.0.borrow(), Ok(8));\n+}\n+\n #[test]\n fn as_unsafe_cell() {\n     let c1: Cell<usize> = Cell::new(0);"}, {"sha": "3d14b3f3c810631ed0cf49d1807e5e3b2a20784a", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25fc917c65f7c51fafdab0f023772171f84c7f0a/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fc917c65f7c51fafdab0f023772171f84c7f0a/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=25fc917c65f7c51fafdab0f023772171f84c7f0a", "patch": "@@ -24,6 +24,7 @@\n #![feature(step_by)]\n #![feature(slice_patterns)]\n #![feature(float_from_str_radix)]\n+#![feature(cell_extras)]\n \n extern crate core;\n extern crate test;"}]}