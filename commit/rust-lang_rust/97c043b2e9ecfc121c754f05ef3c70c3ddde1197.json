{"sha": "97c043b2e9ecfc121c754f05ef3c70c3ddde1197", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3YzA0M2IyZTllY2ZjMTIxYzc1NGYwNWVmM2M3MGMzZGRkZTExOTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-21T19:06:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-21T19:06:52Z"}, "message": "auto merge of #19114 : frewsxcv/rust/master, r=bstrie\n\nFixes #19010", "tree": {"sha": "af276407824df5eb8eca16633e59b31de6d079eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af276407824df5eb8eca16633e59b31de6d079eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97c043b2e9ecfc121c754f05ef3c70c3ddde1197", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97c043b2e9ecfc121c754f05ef3c70c3ddde1197", "html_url": "https://github.com/rust-lang/rust/commit/97c043b2e9ecfc121c754f05ef3c70c3ddde1197", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97c043b2e9ecfc121c754f05ef3c70c3ddde1197/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f530aa08dfcdaeb249341bdd1a9797780b4294c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f530aa08dfcdaeb249341bdd1a9797780b4294c2", "html_url": "https://github.com/rust-lang/rust/commit/f530aa08dfcdaeb249341bdd1a9797780b4294c2"}, {"sha": "ef5acff0db6ad7660e46e42f3acac4034df51723", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef5acff0db6ad7660e46e42f3acac4034df51723", "html_url": "https://github.com/rust-lang/rust/commit/ef5acff0db6ad7660e46e42f3acac4034df51723"}], "stats": {"total": 259, "additions": 130, "deletions": 129}, "files": [{"sha": "83f9bbff8aa6eafea09aaa58b2b2806afe967333", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97c043b2e9ecfc121c754f05ef3c70c3ddde1197/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/97c043b2e9ecfc121c754f05ef3c70c3ddde1197/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=97c043b2e9ecfc121c754f05ef3c70c3ddde1197", "patch": "@@ -121,6 +121,7 @@ Cole Mickens <cole.mickens@gmail.com>\n Colin Davidson <colrdavidson@gmail.com>\n Colin Sherratt <colin.sherratt@gmail.com>\n Conrad Kleinespel <conradk@conradk.com>\n+Corey Farwell <coreyf+rust@rwell.org>\n Corey Ford <corey@coreyford.name>\n Corey Richardson <corey@octayn.net>\n DJUrsus <colinvh@divitu.com>"}, {"sha": "68a80edc5d07f14aa24788df7b385aec7f65150b", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97c043b2e9ecfc121c754f05ef3c70c3ddde1197/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c043b2e9ecfc121c754f05ef3c70c3ddde1197/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=97c043b2e9ecfc121c754f05ef3c70c3ddde1197", "patch": "@@ -250,7 +250,7 @@ impl Target {\n             } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name[]).map(|o| o.as_list()\n+                obj.find(name[]).map(|o| o.as_array()\n                     .map(|v| base.options.$key_name = v.iter()\n                         .map(|a| a.as_string().unwrap().to_string()).collect()\n                         )"}, {"sha": "d59edafb2b42cfe0674df9301468d58f68f4cdc6", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 127, "deletions": 127, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/97c043b2e9ecfc121c754f05ef3c70c3ddde1197/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c043b2e9ecfc121c754f05ef3c70c3ddde1197/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=97c043b2e9ecfc121c754f05ef3c70c3ddde1197", "patch": "@@ -28,7 +28,7 @@ Data types that can be encoded are JavaScript types (see the `Json` enum for mor\n * `Boolean`: equivalent to rust's `bool`\n * `Number`: equivalent to rust's `f64`\n * `String`: equivalent to rust's `String`\n-* `List`: equivalent to rust's `Vec<T>`, but also allowing objects of different types in the same\n+* `Array`: equivalent to rust's `Vec<T>`, but also allowing objects of different types in the same\n array\n * `Object`: equivalent to rust's `Treemap<String, json::Json>`\n * `Null`\n@@ -223,12 +223,12 @@ pub enum Json {\n     F64(f64),\n     String(string::String),\n     Boolean(bool),\n-    List(JsonList),\n+    Array(JsonArray),\n     Object(JsonObject),\n     Null,\n }\n \n-pub type JsonList = Vec<Json>;\n+pub type JsonArray = Vec<Json>;\n pub type JsonObject = TreeMap<string::String, Json>;\n \n /// The errors that can arise while parsing a JSON stream.\n@@ -237,7 +237,7 @@ pub enum ErrorCode {\n     InvalidSyntax,\n     InvalidNumber,\n     EOFWhileParsingObject,\n-    EOFWhileParsingList,\n+    EOFWhileParsingArray,\n     EOFWhileParsingValue,\n     EOFWhileParsingString,\n     KeyMustBeAString,\n@@ -278,7 +278,7 @@ pub fn error_str(error: ErrorCode) -> &'static str {\n         InvalidSyntax => \"invalid syntax\",\n         InvalidNumber => \"invalid number\",\n         EOFWhileParsingObject => \"EOF While parsing object\",\n-        EOFWhileParsingList => \"EOF While parsing list\",\n+        EOFWhileParsingArray => \"EOF While parsing array\",\n         EOFWhileParsingValue => \"EOF While parsing value\",\n         EOFWhileParsingString => \"EOF While parsing string\",\n         KeyMustBeAString => \"key must be a string\",\n@@ -868,7 +868,7 @@ impl<E: ::Encoder<S>, S> Encodable<E, S> for Json {\n             F64(v) => v.encode(e),\n             String(ref v) => v.encode(e),\n             Boolean(v) => v.encode(e),\n-            List(ref v) => v.encode(e),\n+            Array(ref v) => v.encode(e),\n             Object(ref v) => v.encode(e),\n             Null => e.emit_nil(),\n         }\n@@ -956,16 +956,16 @@ impl Json {\n         }\n     }\n \n-    /// Returns true if the Json value is a List. Returns false otherwise.\n-    pub fn is_list<'a>(&'a self) -> bool {\n-        self.as_list().is_some()\n+    /// Returns true if the Json value is an Array. Returns false otherwise.\n+    pub fn is_array<'a>(&'a self) -> bool {\n+        self.as_array().is_some()\n     }\n \n-    /// If the Json value is a List, returns the associated vector.\n+    /// If the Json value is an Array, returns the associated vector.\n     /// Returns None otherwise.\n-    pub fn as_list<'a>(&'a self) -> Option<&'a JsonList> {\n+    pub fn as_array<'a>(&'a self) -> Option<&'a JsonArray> {\n         match self {\n-            &List(ref list) => Some(&*list),\n+            &Array(ref array) => Some(&*array),\n             _ => None\n         }\n     }\n@@ -1085,8 +1085,8 @@ impl<'a> ops::Index<&'a str, Json>  for Json {\n impl ops::Index<uint, Json> for Json {\n     fn index<'a>(&'a self, idx: &uint) -> &'a Json {\n         match self {\n-            &List(ref v) => v.index(idx),\n-            _ => panic!(\"can only index Json with uint if it is a list\")\n+            &Array(ref v) => v.index(idx),\n+            _ => panic!(\"can only index Json with uint if it is an array\")\n         }\n     }\n }\n@@ -1096,8 +1096,8 @@ impl ops::Index<uint, Json> for Json {\n pub enum JsonEvent {\n     ObjectStart,\n     ObjectEnd,\n-    ListStart,\n-    ListEnd,\n+    ArrayStart,\n+    ArrayEnd,\n     BooleanValue(bool),\n     I64Value(i64),\n     U64Value(u64),\n@@ -1109,10 +1109,10 @@ pub enum JsonEvent {\n \n #[deriving(PartialEq, Show)]\n enum ParserState {\n-    // Parse a value in a list, true means first element.\n+    // Parse a value in an array, true means first element.\n     ParseArray(bool),\n-    // Parse ',' or ']' after an element in a list.\n-    ParseListComma,\n+    // Parse ',' or ']' after an element in an array.\n+    ParseArrayComma,\n     // Parse a key:value in an object, true means first element.\n     ParseObject(bool),\n     // Parse ',' or ']' after an element in an object.\n@@ -1601,7 +1601,7 @@ impl<T: Iterator<char>> Parser<T> {\n     fn parse(&mut self) -> JsonEvent {\n         loop {\n             // The only paths where the loop can spin a new iteration\n-            // are in the cases ParseListComma and ParseObjectComma if ','\n+            // are in the cases ParseArrayComma and ParseObjectComma if ','\n             // is parsed. In these cases the state is set to (respectively)\n             // ParseArray(false) and ParseObject(false), which always return,\n             // so there is no risk of getting stuck in an infinite loop.\n@@ -1613,10 +1613,10 @@ impl<T: Iterator<char>> Parser<T> {\n                     return self.parse_start();\n                 }\n                 ParseArray(first) => {\n-                    return self.parse_list(first);\n+                    return self.parse_array(first);\n                 }\n-                ParseListComma => {\n-                    match self.parse_list_comma_or_end() {\n+                ParseArrayComma => {\n+                    match self.parse_array_comma_or_end() {\n                         Some(evt) => { return evt; }\n                         None => {}\n                     }\n@@ -1644,14 +1644,14 @@ impl<T: Iterator<char>> Parser<T> {\n         let val = self.parse_value();\n         self.state = match val {\n             Error(_) => { ParseFinished }\n-            ListStart => { ParseArray(true) }\n+            ArrayStart => { ParseArray(true) }\n             ObjectStart => { ParseObject(true) }\n             _ => { ParseBeforeFinish }\n         };\n         return val;\n     }\n \n-    fn parse_list(&mut self, first: bool) -> JsonEvent {\n+    fn parse_array(&mut self, first: bool) -> JsonEvent {\n         if self.ch_is(']') {\n             if !first {\n                 return self.error_event(InvalidSyntax);\n@@ -1660,13 +1660,13 @@ impl<T: Iterator<char>> Parser<T> {\n                 self.state = ParseBeforeFinish;\n             } else {\n                 self.state = if self.stack.last_is_index() {\n-                    ParseListComma\n+                    ParseArrayComma\n                 } else {\n                     ParseObjectComma\n                 }\n             }\n             self.bump();\n-            return ListEnd;\n+            return ArrayEnd;\n         }\n         if first {\n             self.stack.push_index(0);\n@@ -1676,14 +1676,14 @@ impl<T: Iterator<char>> Parser<T> {\n \n         self.state = match val {\n             Error(_) => { ParseFinished }\n-            ListStart => { ParseArray(true) }\n+            ArrayStart => { ParseArray(true) }\n             ObjectStart => { ParseObject(true) }\n-            _ => { ParseListComma }\n+            _ => { ParseArrayComma }\n         };\n         return val;\n     }\n \n-    fn parse_list_comma_or_end(&mut self) -> Option<JsonEvent> {\n+    fn parse_array_comma_or_end(&mut self) -> Option<JsonEvent> {\n         if self.ch_is(',') {\n             self.stack.bump_index();\n             self.state = ParseArray(false);\n@@ -1695,15 +1695,15 @@ impl<T: Iterator<char>> Parser<T> {\n                 self.state = ParseBeforeFinish;\n             } else {\n                 self.state = if self.stack.last_is_index() {\n-                    ParseListComma\n+                    ParseArrayComma\n                 } else {\n                     ParseObjectComma\n                 }\n             }\n             self.bump();\n-            return Some(ListEnd);\n+            return Some(ArrayEnd);\n         } else if self.eof() {\n-            return Some(self.error_event(EOFWhileParsingList));\n+            return Some(self.error_event(EOFWhileParsingArray));\n         } else {\n             return Some(self.error_event(InvalidSyntax));\n         }\n@@ -1722,7 +1722,7 @@ impl<T: Iterator<char>> Parser<T> {\n                 self.state = ParseBeforeFinish;\n             } else {\n                 self.state = if self.stack.last_is_index() {\n-                    ParseListComma\n+                    ParseArrayComma\n                 } else {\n                     ParseObjectComma\n                 }\n@@ -1757,7 +1757,7 @@ impl<T: Iterator<char>> Parser<T> {\n \n         self.state = match val {\n             Error(_) => { ParseFinished }\n-            ListStart => { ParseArray(true) }\n+            ArrayStart => { ParseArray(true) }\n             ObjectStart => { ParseObject(true) }\n             _ => { ParseObjectComma }\n         };\n@@ -1770,7 +1770,7 @@ impl<T: Iterator<char>> Parser<T> {\n                 self.state = ParseBeforeFinish;\n             } else {\n                 self.state = if self.stack.last_is_index() {\n-                    ParseListComma\n+                    ParseArrayComma\n                 } else {\n                     ParseObjectComma\n                 }\n@@ -1797,7 +1797,7 @@ impl<T: Iterator<char>> Parser<T> {\n             },\n             '[' => {\n                 self.bump();\n-                ListStart\n+                ArrayStart\n             }\n             '{' => {\n                 self.bump();\n@@ -1864,21 +1864,21 @@ impl<T: Iterator<char>> Builder<T> {\n                 Ok(String(temp))\n             }\n             Some(Error(e)) => { Err(e) }\n-            Some(ListStart) => { self.build_list() }\n+            Some(ArrayStart) => { self.build_array() }\n             Some(ObjectStart) => { self.build_object() }\n             Some(ObjectEnd) => { self.parser.error(InvalidSyntax) }\n-            Some(ListEnd) => { self.parser.error(InvalidSyntax) }\n+            Some(ArrayEnd) => { self.parser.error(InvalidSyntax) }\n             None => { self.parser.error(EOFWhileParsingValue) }\n         }\n     }\n \n-    fn build_list(&mut self) -> Result<Json, BuilderError> {\n+    fn build_array(&mut self) -> Result<Json, BuilderError> {\n         self.bump();\n         let mut values = Vec::new();\n \n         loop {\n-            if self.token == Some(ListEnd) {\n-                return Ok(List(values.into_iter().collect()));\n+            if self.token == Some(ArrayEnd) {\n+                return Ok(Array(values.into_iter().collect()));\n             }\n             match self.build_value() {\n                 Ok(v) => values.push(v),\n@@ -2093,13 +2093,13 @@ impl ::Decoder<DecoderError> for Decoder {\n                     }\n                 };\n                 match o.remove(&\"fields\".to_string()) {\n-                    Some(List(l)) => {\n+                    Some(Array(l)) => {\n                         for field in l.into_iter().rev() {\n                             self.stack.push(field);\n                         }\n                     },\n                     Some(val) => {\n-                        return Err(ExpectedError(\"List\".to_string(), format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"Array\".to_string(), format!(\"{}\", val)))\n                     }\n                     None => {\n                         return Err(MissingFieldError(\"fields\".to_string()))\n@@ -2229,9 +2229,9 @@ impl ::Decoder<DecoderError> for Decoder {\n \n     fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n         debug!(\"read_seq()\");\n-        let list = try!(expect!(self.pop(), List));\n-        let len = list.len();\n-        for v in list.into_iter().rev() {\n+        let array = try!(expect!(self.pop(), Array));\n+        let len = array.len();\n+        for v in array.into_iter().rev() {\n             self.stack.push(v);\n         }\n         f(self, len)\n@@ -2343,7 +2343,7 @@ macro_rules! tuple_impl {\n             #[allow(non_snake_case)]\n             fn to_json(&self) -> Json {\n                 match *self {\n-                    ($(ref $tyvar),*,) => List(vec![$($tyvar.to_json()),*])\n+                    ($(ref $tyvar),*,) => Array(vec![$($tyvar.to_json()),*])\n                 }\n             }\n         }\n@@ -2364,11 +2364,11 @@ tuple_impl!{A, B, C, D, E, F, G, H, I, J, K}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J, K, L}\n \n impl<A: ToJson> ToJson for [A] {\n-    fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n+    fn to_json(&self) -> Json { Array(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n impl<A: ToJson> ToJson for Vec<A> {\n-    fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n+    fn to_json(&self) -> Json { Array(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n impl<A: ToJson> ToJson for TreeMap<string::String, A> {\n@@ -2420,13 +2420,13 @@ mod tests {\n     use self::DecodeEnum::*;\n     use self::test::Bencher;\n     use {Encodable, Decodable};\n-    use super::{List, Encoder, Decoder, Error, Boolean, I64, U64, F64, String, Null,\n+    use super::{Array, Encoder, Decoder, Error, Boolean, I64, U64, F64, String, Null,\n                 PrettyEncoder, Object, Json, from_str, ParseError, ExpectedError,\n                 MissingFieldError, UnknownVariantError, DecodeResult, DecoderError,\n                 JsonEvent, Parser, StackElement,\n-                ObjectStart, ObjectEnd, ListStart, ListEnd, BooleanValue, U64Value,\n+                ObjectStart, ObjectEnd, ArrayStart, ArrayEnd, BooleanValue, U64Value,\n                 F64Value, StringValue, NullValue, SyntaxError, Key, Index, Stack,\n-                InvalidSyntax, InvalidNumber, EOFWhileParsingObject, EOFWhileParsingList,\n+                InvalidSyntax, InvalidNumber, EOFWhileParsingObject, EOFWhileParsingArray,\n                 EOFWhileParsingValue, EOFWhileParsingString, KeyMustBeAString, ExpectedColon,\n                 TrailingCharacters, TrailingComma};\n     use std::{i64, u64, f32, f64, io};\n@@ -2558,28 +2558,28 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_write_list() {\n-        assert_eq!(List(vec![]).to_string().into_string(), \"[]\".to_string());\n-        assert_eq!(List(vec![]).to_pretty_str().into_string(), \"[]\".to_string());\n+    fn test_write_array() {\n+        assert_eq!(Array(vec![]).to_string().into_string(), \"[]\".to_string());\n+        assert_eq!(Array(vec![]).to_pretty_str().into_string(), \"[]\".to_string());\n \n-        assert_eq!(List(vec![Boolean(true)]).to_string().into_string(), \"[true]\".to_string());\n+        assert_eq!(Array(vec![Boolean(true)]).to_string().into_string(), \"[true]\".to_string());\n         assert_eq!(\n-            List(vec![Boolean(true)]).to_pretty_str().into_string(),\n+            Array(vec![Boolean(true)]).to_pretty_str().into_string(),\n             \"\\\n             [\\n  \\\n                 true\\n\\\n             ]\".to_string()\n         );\n \n-        let long_test_list = List(vec![\n+        let long_test_array = Array(vec![\n             Boolean(false),\n             Null,\n-            List(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n+            Array(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n \n-        assert_eq!(long_test_list.to_string().into_string(),\n+        assert_eq!(long_test_array.to_string().into_string(),\n             \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_string());\n         assert_eq!(\n-            long_test_list.to_pretty_str().into_string(),\n+            long_test_array.to_pretty_str().into_string(),\n             \"\\\n             [\\n  \\\n                 false,\\n  \\\n@@ -2612,7 +2612,7 @@ mod tests {\n         );\n \n         let complex_obj = mk_object(&[\n-                (\"b\".to_string(), List(vec![\n+                (\"b\".to_string(), Array(vec![\n                     mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n                     mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n                 ]))\n@@ -2644,7 +2644,7 @@ mod tests {\n \n         let a = mk_object(&[\n             (\"a\".to_string(), Boolean(true)),\n-            (\"b\".to_string(), List(vec![\n+            (\"b\".to_string(), Array(vec![\n                 mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n                 mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n             ]))\n@@ -2878,28 +2878,28 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_read_list() {\n+    fn test_read_array() {\n         assert_eq!(from_str(\"[\"),     Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n-        assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingList,  1, 3)));\n+        assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n         assert_eq!(from_str(\"[1,\"),   Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n         assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n         assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n \n-        assert_eq!(from_str(\"[]\"), Ok(List(vec![])));\n-        assert_eq!(from_str(\"[ ]\"), Ok(List(vec![])));\n-        assert_eq!(from_str(\"[true]\"), Ok(List(vec![Boolean(true)])));\n-        assert_eq!(from_str(\"[ false ]\"), Ok(List(vec![Boolean(false)])));\n-        assert_eq!(from_str(\"[null]\"), Ok(List(vec![Null])));\n+        assert_eq!(from_str(\"[]\"), Ok(Array(vec![])));\n+        assert_eq!(from_str(\"[ ]\"), Ok(Array(vec![])));\n+        assert_eq!(from_str(\"[true]\"), Ok(Array(vec![Boolean(true)])));\n+        assert_eq!(from_str(\"[ false ]\"), Ok(Array(vec![Boolean(false)])));\n+        assert_eq!(from_str(\"[null]\"), Ok(Array(vec![Null])));\n         assert_eq!(from_str(\"[3, 1]\"),\n-                     Ok(List(vec![U64(3), U64(1)])));\n+                     Ok(Array(vec![U64(3), U64(1)])));\n         assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n-                     Ok(List(vec![U64(3), U64(2)])));\n+                     Ok(Array(vec![U64(3), U64(2)])));\n         assert_eq!(from_str(\"[2, [4, 1]]\"),\n-               Ok(List(vec![U64(2), List(vec![U64(4), U64(1)])])));\n+               Ok(Array(vec![U64(2), Array(vec![U64(4), U64(1)])])));\n     }\n \n     #[test]\n-    fn test_decode_list() {\n+    fn test_decode_array() {\n         let v: Vec<()> = super::decode(\"[]\").unwrap();\n         assert_eq!(v, vec![]);\n \n@@ -2967,7 +2967,7 @@ mod tests {\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object(&[\n                       (\"a\".to_string(), F64(1.0)),\n-                      (\"b\".to_string(), List(vec![Boolean(true)]))\n+                      (\"b\".to_string(), Array(vec![Boolean(true)]))\n                   ]));\n         assert_eq!(from_str(\n                       \"{\\\n@@ -2980,7 +2980,7 @@ mod tests {\n                       }\").unwrap(),\n                   mk_object(&[\n                       (\"a\".to_string(), F64(1.0)),\n-                      (\"b\".to_string(), List(vec![\n+                      (\"b\".to_string(), Array(vec![\n                           Boolean(true),\n                           String(\"foo\\nbar\".to_string()),\n                           mk_object(&[\n@@ -3097,7 +3097,7 @@ mod tests {\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n                                   ExpectedError(\"String\".to_string(), \"{}\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n-                                  ExpectedError(\"List\".to_string(), \"null\".to_string()));\n+                                  ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n                                   MissingFieldError(\"w\".to_string()));\n     }\n@@ -3110,7 +3110,7 @@ mod tests {\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n                                 MissingFieldError(\"fields\".to_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n-                                ExpectedError(\"List\".to_string(), \"null\".to_string()));\n+                                ExpectedError(\"Array\".to_string(), \"null\".to_string()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n                                 UnknownVariantError(\"C\".to_string()));\n     }\n@@ -3139,10 +3139,10 @@ mod tests {\n     #[test]\n     fn test_index(){\n         let json_value = from_str(\"{\\\"animals\\\":[\\\"dog\\\",\\\"cat\\\",\\\"mouse\\\"]}\").unwrap();\n-        let ref list = json_value[\"animals\"];\n-        assert_eq!(list[0].as_string().unwrap(), \"dog\");\n-        assert_eq!(list[1].as_string().unwrap(), \"cat\");\n-        assert_eq!(list[2].as_string().unwrap(), \"mouse\");\n+        let ref array = json_value[\"animals\"];\n+        assert_eq!(array[0].as_string().unwrap(), \"dog\");\n+        assert_eq!(array[1].as_string().unwrap(), \"cat\");\n+        assert_eq!(array[2].as_string().unwrap(), \"mouse\");\n     }\n \n     #[test]\n@@ -3159,17 +3159,17 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_is_list(){\n+    fn test_is_array(){\n         let json_value = from_str(\"[1, 2, 3]\").unwrap();\n-        assert!(json_value.is_list());\n+        assert!(json_value.is_array());\n     }\n \n     #[test]\n-    fn test_as_list(){\n+    fn test_as_array(){\n         let json_value = from_str(\"[1, 2, 3]\").unwrap();\n-        let json_list = json_value.as_list();\n+        let json_array = json_value.as_array();\n         let expected_length = 3;\n-        assert!(json_list.is_some() && json_list.unwrap().len() == expected_length);\n+        assert!(json_array.is_some() && json_array.unwrap().len() == expected_length);\n     }\n \n     #[test]\n@@ -3328,15 +3328,15 @@ mod tests {\n         tree.insert(\"hello\".into_string(), String(\"guten tag\".into_string()));\n         tree.insert(\"goodbye\".into_string(), String(\"sayonara\".into_string()));\n \n-        let json = List(\n+        let json = Array(\n             // The following layout below should look a lot like\n             // the pretty-printed JSON (indent * x)\n             vec!\n             ( // 0x\n                 String(\"greetings\".into_string()), // 1x\n                 Object(tree), // 1x + 2x + 2x + 1x\n             ) // 0x\n-            // End JSON list (7 lines)\n+            // End JSON array (7 lines)\n         );\n \n         // Helper function for counting indents\n@@ -3425,19 +3425,19 @@ mod tests {\n             vec![\n                 (ObjectStart,             vec![]),\n                   (StringValue(\"bar\".to_string()),   vec![Key(\"foo\")]),\n-                  (ListStart,             vec![Key(\"array\")]),\n+                  (ArrayStart,            vec![Key(\"array\")]),\n                     (U64Value(0),         vec![Key(\"array\"), Index(0)]),\n                     (U64Value(1),         vec![Key(\"array\"), Index(1)]),\n                     (U64Value(2),         vec![Key(\"array\"), Index(2)]),\n                     (U64Value(3),         vec![Key(\"array\"), Index(3)]),\n                     (U64Value(4),         vec![Key(\"array\"), Index(4)]),\n                     (U64Value(5),         vec![Key(\"array\"), Index(5)]),\n-                  (ListEnd,               vec![Key(\"array\")]),\n-                  (ListStart,             vec![Key(\"idents\")]),\n+                  (ArrayEnd,              vec![Key(\"array\")]),\n+                  (ArrayStart,            vec![Key(\"idents\")]),\n                     (NullValue,           vec![Key(\"idents\"), Index(0)]),\n                     (BooleanValue(true),  vec![Key(\"idents\"), Index(1)]),\n                     (BooleanValue(false), vec![Key(\"idents\"), Index(2)]),\n-                  (ListEnd,               vec![Key(\"idents\")]),\n+                  (ArrayEnd,              vec![Key(\"idents\")]),\n                 (ObjectEnd,               vec![]),\n             ]\n         );\n@@ -3495,9 +3495,9 @@ mod tests {\n             vec![\n                 (ObjectStart,           vec![]),\n                   (F64Value(1.0),       vec![Key(\"a\")]),\n-                  (ListStart,           vec![Key(\"b\")]),\n+                  (ArrayStart,          vec![Key(\"b\")]),\n                     (BooleanValue(true),vec![Key(\"b\"), Index(0)]),\n-                  (ListEnd,             vec![Key(\"b\")]),\n+                  (ArrayEnd,            vec![Key(\"b\")]),\n                 (ObjectEnd,             vec![]),\n             ]\n         );\n@@ -3513,95 +3513,95 @@ mod tests {\n             vec![\n                 (ObjectStart,                   vec![]),\n                   (F64Value(1.0),               vec![Key(\"a\")]),\n-                  (ListStart,                   vec![Key(\"b\")]),\n+                  (ArrayStart,                  vec![Key(\"b\")]),\n                     (BooleanValue(true),        vec![Key(\"b\"), Index(0)]),\n                     (StringValue(\"foo\\nbar\".to_string()),  vec![Key(\"b\"), Index(1)]),\n                     (ObjectStart,               vec![Key(\"b\"), Index(2)]),\n                       (ObjectStart,             vec![Key(\"b\"), Index(2), Key(\"c\")]),\n                         (NullValue,             vec![Key(\"b\"), Index(2), Key(\"c\"), Key(\"d\")]),\n                       (ObjectEnd,               vec![Key(\"b\"), Index(2), Key(\"c\")]),\n                     (ObjectEnd,                 vec![Key(\"b\"), Index(2)]),\n-                  (ListEnd,                     vec![Key(\"b\")]),\n+                  (ArrayEnd,                    vec![Key(\"b\")]),\n                 (ObjectEnd,                     vec![]),\n             ]\n         );\n     }\n     #[test]\n     #[cfg_attr(target_word_size = \"32\", ignore)] // FIXME(#14064)\n-    fn test_read_list_streaming() {\n+    fn test_read_array_streaming() {\n         assert_stream_equal(\n             \"[]\",\n             vec![\n-                (ListStart, vec![]),\n-                (ListEnd,   vec![]),\n+                (ArrayStart, vec![]),\n+                (ArrayEnd,   vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[ ]\",\n             vec![\n-                (ListStart, vec![]),\n-                (ListEnd,   vec![]),\n+                (ArrayStart, vec![]),\n+                (ArrayEnd,   vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[true]\",\n             vec![\n-                (ListStart,              vec![]),\n+                (ArrayStart,             vec![]),\n                     (BooleanValue(true), vec![Index(0)]),\n-                (ListEnd,                vec![]),\n+                (ArrayEnd,               vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[ false ]\",\n             vec![\n-                (ListStart,               vec![]),\n+                (ArrayStart,              vec![]),\n                     (BooleanValue(false), vec![Index(0)]),\n-                (ListEnd,                 vec![]),\n+                (ArrayEnd,                vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[null]\",\n             vec![\n-                (ListStart,     vec![]),\n+                (ArrayStart,    vec![]),\n                     (NullValue, vec![Index(0)]),\n-                (ListEnd,       vec![]),\n+                (ArrayEnd,      vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[3, 1]\",\n             vec![\n-                (ListStart,     vec![]),\n+                (ArrayStart,      vec![]),\n                     (U64Value(3), vec![Index(0)]),\n                     (U64Value(1), vec![Index(1)]),\n-                (ListEnd,       vec![]),\n+                (ArrayEnd,        vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"\\n[3, 2]\\n\",\n             vec![\n-                (ListStart,     vec![]),\n+                (ArrayStart,      vec![]),\n                     (U64Value(3), vec![Index(0)]),\n                     (U64Value(2), vec![Index(1)]),\n-                (ListEnd,       vec![]),\n+                (ArrayEnd,        vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[2, [4, 1]]\",\n             vec![\n-                (ListStart,            vec![]),\n+                (ArrayStart,           vec![]),\n                     (U64Value(2),      vec![Index(0)]),\n-                    (ListStart,        vec![Index(1)]),\n+                    (ArrayStart,       vec![Index(1)]),\n                         (U64Value(4),  vec![Index(1), Index(0)]),\n                         (U64Value(1),  vec![Index(1), Index(1)]),\n-                    (ListEnd,          vec![Index(1)]),\n-                (ListEnd,              vec![]),\n+                    (ArrayEnd,         vec![Index(1)]),\n+                (ArrayEnd,             vec![]),\n             ]\n         );\n \n         assert_eq!(last_event(\"[\"), Error(SyntaxError(EOFWhileParsingValue, 1,  2)));\n \n         assert_eq!(from_str(\"[\"),     Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n-        assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingList,  1, 3)));\n+        assert_eq!(from_str(\"[1\"),    Err(SyntaxError(EOFWhileParsingArray, 1, 3)));\n         assert_eq!(from_str(\"[1,\"),   Err(SyntaxError(EOFWhileParsingValue, 1, 4)));\n         assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n         assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n@@ -3693,16 +3693,16 @@ mod tests {\n         use std::collections::{HashMap,TreeMap};\n         use super::ToJson;\n \n-        let list2 = List(vec!(U64(1), U64(2)));\n-        let list3 = List(vec!(U64(1), U64(2), U64(3)));\n+        let array2 = Array(vec!(U64(1), U64(2)));\n+        let array3 = Array(vec!(U64(1), U64(2), U64(3)));\n         let object = {\n             let mut tree_map = TreeMap::new();\n             tree_map.insert(\"a\".to_string(), U64(1));\n             tree_map.insert(\"b\".to_string(), U64(2));\n             Object(tree_map)\n         };\n \n-        assert_eq!(list2.to_json(), list2);\n+        assert_eq!(array2.to_json(), array2);\n         assert_eq!(object.to_json(), object);\n         assert_eq!(3_i.to_json(), I64(3));\n         assert_eq!(4_i8.to_json(), I64(4));\n@@ -3723,12 +3723,12 @@ mod tests {\n         assert_eq!(false.to_json(), Boolean(false));\n         assert_eq!(\"abc\".to_json(), String(\"abc\".into_string()));\n         assert_eq!(\"abc\".into_string().to_json(), String(\"abc\".into_string()));\n-        assert_eq!((1u, 2u).to_json(), list2);\n-        assert_eq!((1u, 2u, 3u).to_json(), list3);\n-        assert_eq!([1u, 2].to_json(), list2);\n-        assert_eq!((&[1u, 2, 3]).to_json(), list3);\n-        assert_eq!((vec![1u, 2]).to_json(), list2);\n-        assert_eq!(vec!(1u, 2, 3).to_json(), list3);\n+        assert_eq!((1u, 2u).to_json(), array2);\n+        assert_eq!((1u, 2u, 3u).to_json(), array3);\n+        assert_eq!([1u, 2].to_json(), array2);\n+        assert_eq!((&[1u, 2, 3]).to_json(), array3);\n+        assert_eq!((vec![1u, 2]).to_json(), array2);\n+        assert_eq!(vec!(1u, 2, 3).to_json(), array3);\n         let mut tree_map = TreeMap::new();\n         tree_map.insert(\"a\".to_string(), 1u);\n         tree_map.insert(\"b\".to_string(), 2);"}, {"sha": "4f66139789b1e88a00d30af91bb700d90d50d01d", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97c043b2e9ecfc121c754f05ef3c70c3ddde1197/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97c043b2e9ecfc121c754f05ef3c70c3ddde1197/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=97c043b2e9ecfc121c754f05ef3c70c3ddde1197", "patch": "@@ -59,7 +59,7 @@ fn add_interfaces(store: int, managed_ip: String, device: HashMap<String, json::\n -> Vec<(String, object)> {\n     match device[\"interfaces\".to_string()]\n     {\n-        json::List(ref interfaces) =>\n+        json::Array(ref interfaces) =>\n         {\n           interfaces.iter().map(|interface| {\n                 add_interface(store, managed_ip.clone(), (*interface).clone())"}]}