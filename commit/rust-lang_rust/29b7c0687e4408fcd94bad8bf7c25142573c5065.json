{"sha": "29b7c0687e4408fcd94bad8bf7c25142573c5065", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YjdjMDY4N2U0NDA4ZmNkOTRiYWQ4YmY3YzI1MTQyNTczYzUwNjU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-05-28T22:21:27Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-05-28T22:43:57Z"}, "message": "rustc_codegen_llvm: remove LLVM instruction count stats.", "tree": {"sha": "63072518e3e564f8e4b1c8c809517538e4c48ddd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63072518e3e564f8e4b1c8c809517538e4c48ddd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29b7c0687e4408fcd94bad8bf7c25142573c5065", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29b7c0687e4408fcd94bad8bf7c25142573c5065", "html_url": "https://github.com/rust-lang/rust/commit/29b7c0687e4408fcd94bad8bf7c25142573c5065", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29b7c0687e4408fcd94bad8bf7c25142573c5065/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03d32905e7312b0179103e8cc338876c81098da4", "url": "https://api.github.com/repos/rust-lang/rust/commits/03d32905e7312b0179103e8cc338876c81098da4", "html_url": "https://github.com/rust-lang/rust/commit/03d32905e7312b0179103e8cc338876c81098da4"}], "stats": {"total": 271, "additions": 20, "deletions": 251}, "files": [{"sha": "ca79bc15358c500fb6f3216af3933ddf43af2e87", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=29b7c0687e4408fcd94bad8bf7c25142573c5065", "patch": "@@ -188,31 +188,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n     }\n }\n \n-#[derive(Clone, Default)]\n-pub struct Stats {\n-    pub n_llvm_insns: usize,\n-    pub llvm_insns: FxHashMap<String, usize>,\n-    // (ident, llvm-instructions)\n-    pub fn_stats: Vec<(String, usize)>,\n-}\n-\n-impl_stable_hash_for!(struct self::Stats {\n-    n_llvm_insns,\n-    llvm_insns,\n-    fn_stats\n-});\n-\n-impl Stats {\n-    pub fn extend(&mut self, stats: Stats) {\n-        self.n_llvm_insns += stats.n_llvm_insns;\n-\n-        for (k, v) in stats.llvm_insns {\n-            *self.llvm_insns.entry(k).or_insert(0) += v;\n-        }\n-        self.fn_stats.extend(stats.fn_stats);\n-    }\n-}\n-\n pub struct CodegenUnitNameBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     cache: FxHashMap<CrateNum, String>,"}, {"sha": "300d0cbfba55bd3e3f10a1f02bdfa06c2b5b2030", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=29b7c0687e4408fcd94bad8bf7c25142573c5065", "patch": "@@ -1216,21 +1216,12 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"measure time of each rustc pass\"),\n     time: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of rustc processes\"),\n-    count_llvm_insns: bool = (false, parse_bool,\n-        [UNTRACKED_WITH_WARNING(true,\n-        \"The output generated by `-Z count_llvm_insns` might not be reliable \\\n-         when used with incremental compilation\")],\n-        \"count where LLVM instrs originate\"),\n     time_llvm_passes: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n         \"The output of `-Z time-llvm-passes` will only reflect timings of \\\n          re-codegened modules when used with incremental compilation\" )],\n         \"measure time of each LLVM pass\"),\n     input_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather statistics about the input\"),\n-    codegen_stats: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n-        \"The output of `-Z codegen-stats` might not be accurate when incremental \\\n-         compilation is enabled\")],\n-        \"gather codegen statistics\"),\n     asm_comments: bool = (false, parse_bool, [TRACKED],\n         \"generate comments into the assembly (may change behavior)\"),\n     verify_llvm_ir: bool = (false, parse_bool, [TRACKED],\n@@ -3259,14 +3250,10 @@ mod tests {\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.time_passes = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.count_llvm_insns = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.time_llvm_passes = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.input_stats = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.codegen_stats = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.borrowck_stats = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.meta_stats = true;"}, {"sha": "2726a4770c8602b0a8f02e6764bf4fe7ba5955c7", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=29b7c0687e4408fcd94bad8bf7c25142573c5065", "patch": "@@ -519,15 +519,9 @@ impl Session {\n     pub fn instrument_mcount(&self) -> bool {\n         self.opts.debugging_opts.instrument_mcount\n     }\n-    pub fn count_llvm_insns(&self) -> bool {\n-        self.opts.debugging_opts.count_llvm_insns\n-    }\n     pub fn time_llvm_passes(&self) -> bool {\n         self.opts.debugging_opts.time_llvm_passes\n     }\n-    pub fn codegen_stats(&self) -> bool {\n-        self.opts.debugging_opts.codegen_stats\n-    }\n     pub fn meta_stats(&self) -> bool {\n         self.opts.debugging_opts.meta_stats\n     }"}, {"sha": "f8c6087373f1eb9218bd24c475e22bb6a8d417b6", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=29b7c0687e4408fcd94bad8bf7c25142573c5065", "patch": "@@ -24,7 +24,7 @@ use crate::common;\n use crate::context::CodegenCx;\n use crate::monomorphize::partitioning::CodegenUnitExt;\n use rustc::dep_graph;\n-use rustc::mir::mono::{Linkage, Visibility, Stats};\n+use rustc::mir::mono::{Linkage, Visibility};\n use rustc::middle::cstore::{EncodedMetadata};\n use rustc::ty::TyCtxt;\n use rustc::middle::exported_symbols;\n@@ -104,17 +104,17 @@ pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n     }\n }\n \n-pub fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  cgu_name: InternedString)\n-                                  -> Stats {\n+pub fn compile_codegen_unit(tcx: TyCtxt<'a, 'tcx, 'tcx>, cgu_name: InternedString) {\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n-    let ((stats, module), _) = tcx.dep_graph.with_task(dep_node,\n-                                                       tcx,\n-                                                       cgu_name,\n-                                                       module_codegen,\n-                                                       dep_graph::hash_result);\n+    let (module, _) = tcx.dep_graph.with_task(\n+        dep_node,\n+        tcx,\n+        cgu_name,\n+        module_codegen,\n+        dep_graph::hash_result,\n+    );\n     let time_to_codegen = start_time.elapsed();\n \n     // We assume that the cost to run LLVM on a CGU is proportional to\n@@ -123,17 +123,15 @@ pub fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                time_to_codegen.subsec_nanos() as u64;\n \n     submit_codegened_module_to_llvm(&LlvmCodegenBackend(()), tcx, module, cost);\n-    return stats;\n \n     fn module_codegen<'ll, 'tcx>(\n         tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n-        cgu_name: InternedString)\n-        -> (Stats, ModuleCodegen<ModuleLlvm>)\n-    {\n+        cgu_name: InternedString,\n+    ) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);\n         // Instantiate monomorphizations without filling out definitions yet...\n         let llvm_module = ModuleLlvm::new(tcx, &cgu_name.as_str());\n-        let stats = {\n+        {\n             let cx = CodegenCx::new(tcx, cgu, &llvm_module);\n             let mono_items = cx.codegen_unit\n                                .items_in_deterministic_order(cx.tcx);\n@@ -169,15 +167,13 @@ pub fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if cx.sess().opts.debuginfo != DebugInfo::None {\n                 cx.debuginfo_finalize();\n             }\n+        }\n \n-            cx.consume_stats().into_inner()\n-        };\n-\n-        (stats, ModuleCodegen {\n+        ModuleCodegen {\n             name: cgu_name.to_string(),\n             module_llvm: llvm_module,\n             kind: ModuleKind::Regular,\n-        })\n+        }\n     }\n }\n "}, {"sha": "79c58fbf6e4651fd3bebde8b203621a207031edb", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=29b7c0687e4408fcd94bad8bf7c25142573c5065", "patch": "@@ -147,21 +147,18 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn ret_void(&mut self) {\n-        self.count_insn(\"retvoid\");\n         unsafe {\n             llvm::LLVMBuildRetVoid(self.llbuilder);\n         }\n     }\n \n     fn ret(&mut self, v: &'ll Value) {\n-        self.count_insn(\"ret\");\n         unsafe {\n             llvm::LLVMBuildRet(self.llbuilder, v);\n         }\n     }\n \n     fn br(&mut self, dest: &'ll BasicBlock) {\n-        self.count_insn(\"br\");\n         unsafe {\n             llvm::LLVMBuildBr(self.llbuilder, dest);\n         }\n@@ -173,7 +170,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         then_llbb: &'ll BasicBlock,\n         else_llbb: &'ll BasicBlock,\n     ) {\n-        self.count_insn(\"condbr\");\n         unsafe {\n             llvm::LLVMBuildCondBr(self.llbuilder, cond, then_llbb, else_llbb);\n         }\n@@ -204,7 +200,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         catch: &'ll BasicBlock,\n         funclet: Option<&Funclet<'ll>>,\n     ) -> &'ll Value {\n-        self.count_insn(\"invoke\");\n \n         debug!(\"Invoke {:?} with args ({:?})\",\n                llfn,\n@@ -227,29 +222,25 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn unreachable(&mut self) {\n-        self.count_insn(\"unreachable\");\n         unsafe {\n             llvm::LLVMBuildUnreachable(self.llbuilder);\n         }\n     }\n \n     /* Arithmetic */\n     fn add(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"add\");\n         unsafe {\n             llvm::LLVMBuildAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fadd(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fadd\");\n         unsafe {\n             llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fadd_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fadd\");\n         unsafe {\n             let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -258,21 +249,18 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn sub(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"sub\");\n         unsafe {\n             llvm::LLVMBuildSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fsub(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fsub\");\n         unsafe {\n             llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fsub_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fsub\");\n         unsafe {\n             let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -281,21 +269,18 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn mul(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"mul\");\n         unsafe {\n             llvm::LLVMBuildMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fmul(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fmul\");\n         unsafe {\n             llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fmul_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fmul\");\n         unsafe {\n             let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -305,42 +290,36 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n \n     fn udiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"udiv\");\n         unsafe {\n             llvm::LLVMBuildUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn exactudiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"exactudiv\");\n         unsafe {\n             llvm::LLVMBuildExactUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn sdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"sdiv\");\n         unsafe {\n             llvm::LLVMBuildSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn exactsdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"exactsdiv\");\n         unsafe {\n             llvm::LLVMBuildExactSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fdiv\");\n         unsafe {\n             llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fdiv_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fdiv\");\n         unsafe {\n             let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -349,28 +328,24 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn urem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"urem\");\n         unsafe {\n             llvm::LLVMBuildURem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn srem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"srem\");\n         unsafe {\n             llvm::LLVMBuildSRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn frem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"frem\");\n         unsafe {\n             llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn frem_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"frem\");\n         unsafe {\n             let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -379,63 +354,54 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn shl(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"shl\");\n         unsafe {\n             llvm::LLVMBuildShl(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn lshr(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"lshr\");\n         unsafe {\n             llvm::LLVMBuildLShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn ashr(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"ashr\");\n         unsafe {\n             llvm::LLVMBuildAShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn and(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"and\");\n         unsafe {\n             llvm::LLVMBuildAnd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn or(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"or\");\n         unsafe {\n             llvm::LLVMBuildOr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn xor(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"xor\");\n         unsafe {\n             llvm::LLVMBuildXor(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn neg(&mut self, v: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"neg\");\n         unsafe {\n             llvm::LLVMBuildNeg(self.llbuilder, v, noname())\n         }\n     }\n \n     fn fneg(&mut self, v: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fneg\");\n         unsafe {\n             llvm::LLVMBuildFNeg(self.llbuilder, v, noname())\n         }\n     }\n \n     fn not(&mut self, v: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"not\");\n         unsafe {\n             llvm::LLVMBuildNot(self.llbuilder, v, noname())\n         }\n@@ -524,7 +490,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn dynamic_alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n-        self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty, noname())\n@@ -543,7 +508,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                         len: &'ll Value,\n                         name: &str,\n                         align: Align) -> &'ll Value {\n-        self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n                 llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, noname())\n@@ -558,7 +522,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn load(&mut self, ptr: &'ll Value, align: Align) -> &'ll Value {\n-        self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n             llvm::LLVMSetAlignment(load, align.bytes() as c_uint);\n@@ -567,7 +530,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn volatile_load(&mut self, ptr: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"load.volatile\");\n         unsafe {\n             let insn = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n             llvm::LLVMSetVolatile(insn, llvm::True);\n@@ -581,7 +543,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         order: rustc_codegen_ssa::common::AtomicOrdering,\n         size: Size,\n     ) -> &'ll Value {\n-        self.count_insn(\"load.atomic\");\n         unsafe {\n             let load = llvm::LLVMRustBuildAtomicLoad(\n                 self.llbuilder,\n@@ -745,7 +706,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         flags: MemFlags,\n     ) -> &'ll Value {\n         debug!(\"Store {:?} -> {:?} ({:?})\", val, ptr, flags);\n-        self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n             let store = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n@@ -774,7 +734,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n    fn atomic_store(&mut self, val: &'ll Value, ptr: &'ll Value,\n                    order: rustc_codegen_ssa::common::AtomicOrdering, size: Size) {\n         debug!(\"Store {:?} -> {:?}\", val, ptr);\n-        self.count_insn(\"store.atomic\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n             let store = llvm::LLVMRustBuildAtomicStore(\n@@ -789,23 +748,20 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn gep(&mut self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n-        self.count_insn(\"gep\");\n         unsafe {\n             llvm::LLVMBuildGEP(self.llbuilder, ptr, indices.as_ptr(),\n                                indices.len() as c_uint, noname())\n         }\n     }\n \n     fn inbounds_gep(&mut self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n-        self.count_insn(\"inboundsgep\");\n         unsafe {\n             llvm::LLVMBuildInBoundsGEP(\n                 self.llbuilder, ptr, indices.as_ptr(), indices.len() as c_uint, noname())\n         }\n     }\n \n     fn struct_gep(&mut self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n-        self.count_insn(\"structgep\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n@@ -814,108 +770,93 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     /* Casts */\n     fn trunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"trunc\");\n         unsafe {\n             llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn sext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"sext\");\n         unsafe {\n             llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"fptoui\");\n         unsafe {\n             llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn fptosi(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"fptosi\");\n         unsafe {\n             llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,noname())\n         }\n     }\n \n     fn uitofp(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"uitofp\");\n         unsafe {\n             llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn sitofp(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"sitofp\");\n         unsafe {\n             llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn fptrunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"fptrunc\");\n         unsafe {\n             llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn fpext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"fpext\");\n         unsafe {\n             llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn ptrtoint(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"ptrtoint\");\n         unsafe {\n             llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn inttoptr(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"inttoptr\");\n         unsafe {\n             llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn bitcast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"bitcast\");\n         unsafe {\n             llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n \n     fn intcast(&mut self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"intcast\");\n         unsafe {\n             llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed)\n         }\n     }\n \n     fn pointercast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"pointercast\");\n         unsafe {\n             llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     /* Comparisons */\n     fn icmp(&mut self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"icmp\");\n         let op = llvm::IntPredicate::from_generic(op);\n         unsafe {\n             llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n     fn fcmp(&mut self, op: RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fcmp\");\n         unsafe {\n             llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n@@ -984,22 +925,19 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         then_val: &'ll Value,\n         else_val: &'ll Value,\n     ) -> &'ll Value {\n-        self.count_insn(\"select\");\n         unsafe {\n             llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, noname())\n         }\n     }\n \n     #[allow(dead_code)]\n     fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"vaarg\");\n         unsafe {\n             llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n         }\n     }\n \n     fn extract_element(&mut self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"extractelement\");\n         unsafe {\n             llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, noname())\n         }\n@@ -1016,7 +954,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn extract_value(&mut self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n-        self.count_insn(\"extractvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n@@ -1025,7 +962,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn insert_value(&mut self, agg_val: &'ll Value, elt: &'ll Value,\n                        idx: u64) -> &'ll Value {\n-        self.count_insn(\"insertvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildInsertValue(self.llbuilder, agg_val, elt, idx as c_uint,\n@@ -1035,22 +971,19 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn landing_pad(&mut self, ty: &'ll Type, pers_fn: &'ll Value,\n                        num_clauses: usize) -> &'ll Value {\n-        self.count_insn(\"landingpad\");\n         unsafe {\n             llvm::LLVMBuildLandingPad(self.llbuilder, ty, pers_fn,\n                                       num_clauses as c_uint, noname())\n         }\n     }\n \n     fn set_cleanup(&mut self, landing_pad: &'ll Value) {\n-        self.count_insn(\"setcleanup\");\n         unsafe {\n             llvm::LLVMSetCleanup(landing_pad, llvm::True);\n         }\n     }\n \n     fn resume(&mut self, exn: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"resume\");\n         unsafe {\n             llvm::LLVMBuildResume(self.llbuilder, exn)\n         }\n@@ -1059,7 +992,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn cleanup_pad(&mut self,\n                        parent: Option<&'ll Value>,\n                        args: &[&'ll Value]) -> Funclet<'ll> {\n-        self.count_insn(\"cleanuppad\");\n         let name = const_cstr!(\"cleanuppad\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupPad(self.llbuilder,\n@@ -1075,7 +1007,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         &mut self, funclet: &Funclet<'ll>,\n         unwind: Option<&'ll BasicBlock>,\n     ) -> &'ll Value {\n-        self.count_insn(\"cleanupret\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupRet(self.llbuilder, funclet.cleanuppad(), unwind)\n         };\n@@ -1085,7 +1016,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn catch_pad(&mut self,\n                      parent: &'ll Value,\n                      args: &[&'ll Value]) -> Funclet<'ll> {\n-        self.count_insn(\"catchpad\");\n         let name = const_cstr!(\"catchpad\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchPad(self.llbuilder, parent,\n@@ -1101,7 +1031,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unwind: Option<&'ll BasicBlock>,\n         num_handlers: usize,\n     ) -> &'ll Value {\n-        self.count_insn(\"catchswitch\");\n         let name = const_cstr!(\"catchswitch\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchSwitch(self.llbuilder, parent, unwind,\n@@ -1199,7 +1128,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         args: &[&'ll Value],\n         funclet: Option<&Funclet<'ll>>,\n     ) -> &'ll Value {\n-        self.count_insn(\"call\");\n \n         debug!(\"Call {:?} with args ({:?})\",\n                llfn,\n@@ -1221,7 +1149,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn zext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"zext\");\n         unsafe {\n             llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n         }\n@@ -1285,32 +1212,17 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn count_insn(&self, category: &str) {\n-        if self.sess().codegen_stats() {\n-            self.stats.borrow_mut().n_llvm_insns += 1;\n-        }\n-        if self.sess().count_llvm_insns() {\n-            *self.stats\n-                      .borrow_mut()\n-                      .llvm_insns\n-                      .entry(category.to_string())\n-                      .or_insert(0) += 1;\n-        }\n-    }\n-\n     fn position_at_start(&mut self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n         }\n     }\n \n     pub fn minnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"minnum\");\n         unsafe { llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs) }\n     }\n \n     pub fn maxnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"maxnum\");\n         unsafe { llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs) }\n     }\n \n@@ -1319,7 +1231,6 @@ impl Builder<'a, 'll, 'tcx> {\n         elt: &'ll Value,\n         idx: &'ll Value,\n     ) -> &'ll Value {\n-        self.count_insn(\"insertelement\");\n         unsafe {\n             llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n         }\n@@ -1331,14 +1242,12 @@ impl Builder<'a, 'll, 'tcx> {\n         v2: &'ll Value,\n         mask: &'ll Value,\n     ) -> &'ll Value {\n-        self.count_insn(\"shufflevector\");\n         unsafe {\n             llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n         }\n     }\n \n     pub fn vector_reduce_fadd_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fadd_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n             // https://bugs.llvm.org/show_bug.cgi?id=36732\n@@ -1349,7 +1258,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n     pub fn vector_reduce_fmul_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmul_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n             // https://bugs.llvm.org/show_bug.cgi?id=36732\n@@ -1360,55 +1268,44 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n     pub fn vector_reduce_add(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.add\");\n         unsafe { llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_mul(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.mul\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_and(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.and\");\n         unsafe { llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_or(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.or\");\n         unsafe { llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_xor(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.xor\");\n         unsafe { llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_fmin(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmin\");\n         unsafe { llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n     pub fn vector_reduce_fmax(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmax\");\n         unsafe { llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n     pub fn vector_reduce_fmin_fast(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmin_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n     pub fn vector_reduce_fmax_fast(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmax_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n     pub fn vector_reduce_min(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.min\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed) }\n     }\n     pub fn vector_reduce_max(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.max\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed) }\n     }\n \n@@ -1419,7 +1316,6 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     pub fn catch_ret(&mut self, funclet: &Funclet<'ll>, unwind: &'ll BasicBlock) -> &'ll Value {\n-        self.count_insn(\"catchret\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchRet(self.llbuilder, funclet.cleanuppad(), unwind)\n         };\n@@ -1488,7 +1384,6 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     pub fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"vaarg\");\n         unsafe {\n             llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n         }\n@@ -1511,7 +1406,6 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     fn phi(&mut self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n-        self.count_insn(\"addincoming\");\n         assert_eq!(vals.len(), bbs.len());\n         let phi = unsafe {\n             llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n@@ -1525,7 +1419,6 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     fn add_incoming_to_phi(&mut self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock) {\n-        self.count_insn(\"addincoming\");\n         unsafe {\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n         }"}, {"sha": "b6b47d047c8b1023e8c7ef843167ff0b3d502257", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=29b7c0687e4408fcd94bad8bf7c25142573c5065", "patch": "@@ -12,7 +12,6 @@ use rustc_codegen_ssa::traits::*;\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::small_c_str::SmallCStr;\n-use rustc::mir::mono::Stats;\n use rustc::session::config::{self, DebugInfo};\n use rustc::session::Session;\n use rustc::ty::layout::{\n@@ -44,7 +43,6 @@ pub struct CodegenCx<'ll, 'tcx: 'll> {\n \n     pub llmod: &'ll llvm::Module,\n     pub llcx: &'ll llvm::Context,\n-    pub stats: RefCell<Stats>,\n     pub codegen_unit: Arc<CodegenUnit<'tcx>>,\n \n     /// Cache instances of monomorphic and polymorphic items\n@@ -284,7 +282,6 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n             tls_model,\n             llmod,\n             llcx,\n-            stats: RefCell::new(Stats::default()),\n             codegen_unit,\n             instances: Default::default(),\n             vtables: Default::default(),\n@@ -408,14 +405,6 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         self.check_overflow\n     }\n \n-    fn stats(&self) -> &RefCell<Stats> {\n-        &self.stats\n-    }\n-\n-    fn consume_stats(self) -> RefCell<Stats> {\n-        self.stats\n-    }\n-\n     fn codegen_unit(&self) -> &Arc<CodegenUnit<'tcx>> {\n         &self.codegen_unit\n     }"}, {"sha": "57cffa48163e1d6506a857c38776cb9b4d87d21a", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=29b7c0687e4408fcd94bad8bf7c25142573c5065", "patch": "@@ -52,7 +52,6 @@ use rustc_codegen_ssa::CompiledModule;\n use errors::{FatalError, Handler};\n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::InternedString;\n-use rustc::mir::mono::Stats;\n pub use llvm_util::target_features;\n use std::any::Any;\n use std::sync::{mpsc, Arc};\n@@ -130,8 +129,8 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         cgu_name: InternedString,\n-    ) -> Stats {\n-        base::compile_codegen_unit(tcx, cgu_name)\n+    ) {\n+        base::compile_codegen_unit(tcx, cgu_name);\n     }\n     fn target_machine_factory(\n         &self,"}, {"sha": "172b5b39987d43247f137f5039361318c3ebe749", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 62, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=29b7c0687e4408fcd94bad8bf7c25142573c5065", "patch": "@@ -20,15 +20,14 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::weak_lang_items;\n-use rustc::mir::mono::{Stats, CodegenUnitNameBuilder};\n+use rustc::mir::mono::CodegenUnitNameBuilder;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::ty::query::Providers;\n use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, EntryFnType, Lto};\n use rustc::session::Session;\n-use rustc_mir::monomorphize::item::DefPathBasedNames;\n use rustc_mir::monomorphize::Instance;\n use rustc_mir::monomorphize::partitioning::{CodegenUnit, CodegenUnitExt};\n use rustc::util::nodemap::FxHashMap;\n@@ -58,39 +57,6 @@ use rustc::hir;\n \n use crate::mir::operand::OperandValue;\n \n-use std::marker::PhantomData;\n-\n-pub struct StatRecorder<'a, 'tcx, Cx: 'a + CodegenMethods<'tcx>> {\n-    cx: &'a Cx,\n-    name: Option<String>,\n-    istart: usize,\n-    _marker: PhantomData<&'tcx ()>,\n-}\n-\n-impl<'a, 'tcx, Cx: CodegenMethods<'tcx>> StatRecorder<'a, 'tcx, Cx> {\n-    pub fn new(cx: &'a Cx, name: String) -> Self {\n-        let istart = cx.stats().borrow().n_llvm_insns;\n-        StatRecorder {\n-            cx,\n-            name: Some(name),\n-            istart,\n-            _marker: PhantomData,\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, Cx: CodegenMethods<'tcx>> Drop for StatRecorder<'a, 'tcx, Cx> {\n-    fn drop(&mut self) {\n-        if self.cx.sess().codegen_stats() {\n-            let mut stats = self.cx.stats().borrow_mut();\n-            let iend = stats.n_llvm_insns;\n-            stats.fn_stats.push((self.name.take().unwrap(), iend - self.istart));\n-            // Reset LLVM insn count to avoid compound costs.\n-            stats.n_llvm_insns = self.istart;\n-        }\n-    }\n-}\n-\n pub fn bin_op_to_icmp_predicate(op: hir::BinOpKind,\n                                 signed: bool)\n                                 -> IntPredicate {\n@@ -407,15 +373,6 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n     instance: Instance<'tcx>,\n ) {\n-    let _s = if cx.sess().codegen_stats() {\n-        let mut instance_name = String::new();\n-        DefPathBasedNames::new(cx.tcx(), true, true)\n-            .push_def_path(instance.def_id(), &mut instance_name);\n-        Some(StatRecorder::new(cx, instance_name))\n-    } else {\n-        None\n-    };\n-\n     // this is an info! to allow collecting monomorphization statistics\n     // and to allow finding the last function before LLVM aborts from\n     // release builds.\n@@ -650,7 +607,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     };\n \n     let mut total_codegen_time = Duration::new(0, 0);\n-    let mut all_stats = Stats::default();\n \n     for cgu in codegen_units.into_iter() {\n         ongoing_codegen.wait_for_signal_to_codegen_item();\n@@ -663,8 +619,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             CguReuse::No => {\n                 tcx.sess.profiler(|p| p.start_activity(format!(\"codegen {}\", cgu.name())));\n                 let start_time = Instant::now();\n-                let stats = backend.compile_codegen_unit(tcx, *cgu.name());\n-                all_stats.extend(stats);\n+                backend.compile_codegen_unit(tcx, *cgu.name());\n                 total_codegen_time += start_time.elapsed();\n                 tcx.sess.profiler(|p| p.end_activity(format!(\"codegen {}\", cgu.name())));\n                 false\n@@ -698,21 +653,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     symbol_names_test::report_symbol_names(tcx);\n \n-    if tcx.sess.codegen_stats() {\n-        println!(\"--- codegen stats ---\");\n-        println!(\"fn stats:\");\n-        all_stats.fn_stats.sort_by_key(|&(_, insns)| insns);\n-        for &(ref name, insns) in all_stats.fn_stats.iter() {\n-            println!(\"{} insns, {}\", insns, *name);\n-        }\n-    }\n-\n-    if tcx.sess.count_llvm_insns() {\n-        for (k, v) in all_stats.llvm_insns.iter() {\n-            println!(\"{:7} {}\", *v, *k);\n-        }\n-    }\n-\n     ongoing_codegen.check_for_errors(tcx.sess);\n \n     assert_and_save_dep_graph(tcx);"}, {"sha": "0466b47cf148f8c680d49563ca8948ce58921207", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=29b7c0687e4408fcd94bad8bf7c25142573c5065", "patch": "@@ -5,7 +5,6 @@ use super::write::WriteBackendMethods;\n use super::CodegenObject;\n use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::EncodedMetadata;\n-use rustc::mir::mono::Stats;\n use rustc::session::{Session, config};\n use rustc::ty::TyCtxt;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -49,7 +48,7 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         cgu_name: InternedString,\n-    ) -> Stats;\n+    );\n     // If find_features is true this won't access `sess.crate_types` by assuming\n     // that `is_pie_binary` is false. When we discover LLVM target features\n     // `sess.crate_types` is uninitialized so we cannot access it."}, {"sha": "5ea86df6e9459cc76fcb3e0c5dfb007b65003b84", "filename": "src/librustc_codegen_ssa/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29b7c0687e4408fcd94bad8bf7c25142573c5065/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs?ref=29b7c0687e4408fcd94bad8bf7c25142573c5065", "patch": "@@ -1,5 +1,4 @@\n use super::BackendTypes;\n-use rustc::mir::mono::Stats;\n use rustc::session::Session;\n use rustc::ty::{self, Instance, Ty};\n use rustc::util::nodemap::FxHashMap;\n@@ -17,8 +16,6 @@ pub trait MiscMethods<'tcx>: BackendTypes {\n     fn eh_personality(&self) -> Self::Value;\n     fn eh_unwind_resume(&self) -> Self::Value;\n     fn sess(&self) -> &Session;\n-    fn stats(&self) -> &RefCell<Stats>;\n-    fn consume_stats(self) -> RefCell<Stats>;\n     fn codegen_unit(&self) -> &Arc<CodegenUnit<'tcx>>;\n     fn used_statics(&self) -> &RefCell<Vec<Self::Value>>;\n     fn set_frame_pointer_elimination(&self, llfn: Self::Value);"}]}