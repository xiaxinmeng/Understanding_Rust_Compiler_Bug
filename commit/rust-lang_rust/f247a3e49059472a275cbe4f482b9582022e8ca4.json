{"sha": "f247a3e49059472a275cbe4f482b9582022e8ca4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyNDdhM2U0OTA1OTQ3MmEyNzVjYmU0ZjQ4MmI5NTgyMDIyZThjYTQ=", "commit": {"author": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2018-07-04T06:45:01Z"}, "committer": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2018-07-05T10:34:10Z"}, "message": "fix for issue #8636", "tree": {"sha": "ab69dfd6e800a89f663b2a12e4d5fb9dd84fb34e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab69dfd6e800a89f663b2a12e4d5fb9dd84fb34e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f247a3e49059472a275cbe4f482b9582022e8ca4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f247a3e49059472a275cbe4f482b9582022e8ca4", "html_url": "https://github.com/rust-lang/rust/commit/f247a3e49059472a275cbe4f482b9582022e8ca4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f247a3e49059472a275cbe4f482b9582022e8ca4/comments", "author": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fc21e55766bbcdb0279e6f8a63bdc9859b6e0fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fc21e55766bbcdb0279e6f8a63bdc9859b6e0fc", "html_url": "https://github.com/rust-lang/rust/commit/6fc21e55766bbcdb0279e6f8a63bdc9859b6e0fc"}], "stats": {"total": 372, "additions": 356, "deletions": 16}, "files": [{"sha": "9fbad46a2384535e3eb7c2a5c81b7b932d8e5c0f", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 67, "deletions": 16, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f247a3e49059472a275cbe4f482b9582022e8ca4/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f247a3e49059472a275cbe4f482b9582022e8ca4/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=f247a3e49059472a275cbe4f482b9582022e8ca4", "patch": "@@ -15,6 +15,7 @@ use rustc::hir;\n use rustc::mir::{Mir, Place};\n use rustc::mir::{Projection, ProjectionElem};\n use rustc::ty::{self, TyCtxt};\n+use std::cmp::max;\n \n pub(super) fn places_conflict<'gcx, 'tcx>(\n     tcx: TyCtxt<'_, 'gcx, 'tcx>,\n@@ -394,27 +395,77 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n                 | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n                 | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n-                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::ConstantIndex { .. })\n-                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. })\n-                | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..))\n-                | (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. })\n-                | (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+                | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..)) => {\n                     // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n                     // (if the indexes differ) or equal (if they are the same), so this\n                     // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n-                    //\n-                    // Note that by construction, MIR at borrowck can't subdivide\n-                    // `Subslice` accesses (e.g. `a[2..3][i]` will never be present) - they\n-                    // are only present in slice patterns, and we \"merge together\" nested\n-                    // slice patterns. That means we don't have to think about these. It's\n-                    // probably a good idea to assert this somewhere, but I'm too lazy.\n-                    //\n-                    // FIXME(#8636) we might want to return Disjoint if\n-                    // both projections are constant and disjoint.\n-                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY\");\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-INDEX\");\n                     Overlap::EqualOrDisjoint\n                 }\n-\n+                (ProjectionElem::ConstantIndex { offset: o1, min_length: _, from_end: false },\n+                    ProjectionElem::ConstantIndex { offset: o2, min_length: _, from_end: false })\n+                | (ProjectionElem::ConstantIndex { offset: o1, min_length: _, from_end: true },\n+                    ProjectionElem::ConstantIndex {\n+                        offset: o2, min_length: _, from_end: true }) => {\n+                    if o1 == o2 {\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX\");\n+                        Overlap::Disjoint\n+                    }\n+                }\n+                (ProjectionElem::ConstantIndex {\n+                    offset: offset_from_begin, min_length: min_length1, from_end: false },\n+                    ProjectionElem::ConstantIndex {\n+                        offset: offset_from_end, min_length: min_length2, from_end: true })\n+                | (ProjectionElem::ConstantIndex {\n+                    offset: offset_from_end, min_length: min_length1, from_end: true },\n+                   ProjectionElem::ConstantIndex {\n+                       offset: offset_from_begin, min_length: min_length2, from_end: false }) => {\n+                    // both patterns matched so it must be at least the greater of the two\n+                    let min_length = max(min_length1, min_length2);\n+                    // offset_from_end can be in range [1..min_length], -1 for last and min_length\n+                    // for first, min_length - offset_from_end gives minimal possible offset from\n+                    // the beginning\n+                    if *offset_from_begin >= min_length - offset_from_end {\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-FE\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-FE\");\n+                        Overlap::Disjoint\n+                    }\n+                }\n+                (ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false },\n+                 ProjectionElem::Subslice {from, .. })\n+                | (ProjectionElem::Subslice {from, .. },\n+                    ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false }) => {\n+                    if offset >= from {\n+                        debug!(\n+                            \"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n+                        Overlap::Disjoint\n+                    }\n+                }\n+                (ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true },\n+                 ProjectionElem::Subslice {from: _, to })\n+                | (ProjectionElem::Subslice {from: _, to },\n+                    ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true }) => {\n+                    if offset > to {\n+                        debug!(\"place_element_conflict: \\\n+                               DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-SUBSLICE-FE\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-SUBSLICE-FE\");\n+                        Overlap::Disjoint\n+                    }\n+                }\n+                (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-SUBSLICES\");\n+                     Overlap::EqualOrDisjoint\n+                }\n                 (ProjectionElem::Deref, _)\n                 | (ProjectionElem::Field(..), _)\n                 | (ProjectionElem::Index(..), _)"}, {"sha": "48d16102ff3c2366085a754e4eb4544bc5622e9f", "filename": "src/test/run-pass/borrowck/borrowck-slice-pattern-element-loan.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f247a3e49059472a275cbe4f482b9582022e8ca4/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f247a3e49059472a275cbe4f482b9582022e8ca4/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs?ref=f247a3e49059472a275cbe4f482b9582022e8ca4", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-flags: -Z borrowck=mir\n+\n+#![feature(slice_patterns)]\n+\n+fn mut_head_tail<'a, A>(v: &'a mut [A]) -> Option<(&'a mut A, &'a mut [A])> {\n+    match *v {\n+        [ref mut head, ref mut tail..] => {\n+            Some((head, tail))\n+        }\n+        [] => None\n+    }\n+}\n+\n+fn main() {\n+    let mut v = [1,2,3,4];\n+    match mut_head_tail(&mut v) {\n+        None => {},\n+        Some((h,t)) => {\n+            *h = 1000;\n+            t.reverse();\n+        }\n+    }\n+}"}, {"sha": "da36f494eb6868297431f21ea17e59464e2210a1", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/f247a3e49059472a275cbe4f482b9582022e8ca4/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f247a3e49059472a275cbe4f482b9582022e8ca4/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs?ref=f247a3e49059472a275cbe4f482b9582022e8ca4", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-flags: -Z borrowck=mir\n+\n+#![feature(slice_patterns)]\n+\n+fn nop(_s: &[& i32]) {}\n+fn nop_subslice(_s: &[i32]) {}\n+\n+fn const_index_ok(s: &mut [i32]) {\n+    if let [ref first, ref second, _, ref fourth, ..] = *s {\n+        if let [_, _, ref mut third, ..] = *s {\n+            nop(&[first, second, third, fourth]);\n+        }\n+    }\n+}\n+\n+fn const_index_err(s: &mut [i32]) {\n+    if let [ref first, ref second, ..] = *s {\n+        if let [_, ref mut  second2, ref mut third, ..] = *s { //~ERROR\n+            nop(&[first, second, second2, third]);\n+        }\n+    }\n+}\n+\n+fn const_index_from_end_ok(s: &mut [i32]) {\n+    if let [.., ref fourth, ref third, _, ref first] = *s {\n+        if let [.., ref mut second, _] = *s {\n+            nop(&[first, second, third, fourth]);\n+        }\n+    }\n+}\n+\n+fn const_index_from_end_err(s: &mut [i32]) {\n+    if let [.., ref fourth, ref third, _, ref first] = *s {\n+        if let [.., ref mut third2, _, _] = *s { //~ERROR\n+            nop(&[first, third, third2, fourth]);\n+        }\n+    }\n+}\n+\n+fn const_index_mixed(s: &mut [i32]) {\n+    if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n+        if let [ref mut from_begin0, ..] = *s {\n+            nop(&[from_begin0, from_end1, from_end3, from_end4]);\n+        }\n+        if let [_, ref mut from_begin1, ..] = *s { //~ERROR\n+            nop(&[from_begin1, from_end1, from_end3, from_end4]);\n+        }\n+        if let [_, _, ref mut from_begin2, ..] = *s { //~ERROR\n+            nop(&[from_begin2, from_end1, from_end3, from_end4]);\n+        }\n+        if let [_, _, _, ref mut from_begin3, ..] = *s { //~ERROR\n+            nop(&[from_begin3, from_end1, from_end3, from_end4]);\n+        }\n+    }\n+    if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n+        if let [.., ref mut from_end1] = *s {\n+            nop(&[from_begin0, from_begin1, from_begin3, from_end1]);\n+        }\n+        if let [.., ref mut from_end2, _] = *s { //~ERROR\n+            nop(&[from_begin0, from_begin1, from_begin3, from_end2]);\n+        }\n+        if let [.., ref mut from_end3, _,  _] = *s { //~ERROR\n+            nop(&[from_begin0, from_begin1, from_begin3, from_end3]);\n+        }\n+        if let [.., ref mut from_end4, _, _, _] = *s { //~ERROR\n+            nop(&[from_begin0, from_begin1, from_begin3, from_end4]);\n+        }\n+    }\n+}\n+\n+fn const_index_and_subslice_ok(s: &mut [i32]) {\n+    if let [ref first, ref second, ..] = *s {\n+        if let [_, _, ref mut tail..] = *s {\n+            nop(&[first, second]);\n+            nop_subslice(tail);\n+        }\n+    }\n+}\n+\n+fn const_index_and_subslice_err(s: &mut [i32]) {\n+    if let [ref first, ref second, ..] = *s {\n+        if let [_, ref mut tail..] = *s { //~ERROR\n+            nop(&[first, second]);\n+            nop_subslice(tail);\n+        }\n+    }\n+}\n+\n+fn const_index_and_subslice_from_end_ok(s: &mut [i32]) {\n+    if let [.., ref second, ref first] = *s {\n+        if let [ref mut tail.., _, _] = *s {\n+            nop(&[first, second]);\n+            nop_subslice(tail);\n+        }\n+    }\n+}\n+\n+fn const_index_and_subslice_from_end_err(s: &mut [i32]) {\n+    if let [.., ref second, ref first] = *s {\n+        if let [ref mut tail.., _] = *s { //~ERROR\n+            nop(&[first, second]);\n+            nop_subslice(tail);\n+        }\n+    }\n+}\n+\n+fn subslices(s: &mut [i32]) {\n+    if let [_, _, _, ref s1..] = *s {\n+        if let [ref mut s2.., _, _, _] = *s { //~ERROR\n+            nop_subslice(s1);\n+            nop_subslice(s2);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut v = [1,2,3,4];\n+    const_index_ok(&mut v);\n+    const_index_err(&mut v);\n+    const_index_from_end_ok(&mut v);\n+    const_index_from_end_err(&mut v);\n+    const_index_and_subslice_ok(&mut v);\n+    const_index_and_subslice_err(&mut v);\n+    const_index_and_subslice_from_end_ok(&mut v);\n+    const_index_and_subslice_from_end_err(&mut v);\n+    subslices(&mut v);\n+}"}, {"sha": "16d401ec7f9bf5403815999165689231735ba545", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan.stderr", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/f247a3e49059472a275cbe4f482b9582022e8ca4/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f247a3e49059472a275cbe4f482b9582022e8ca4/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.stderr?ref=f247a3e49059472a275cbe4f482b9582022e8ca4", "patch": "@@ -0,0 +1,119 @@\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:28:20\n+   |\n+LL |     if let [ref first, ref second, ..] = *s {\n+   |                        ---------- immutable borrow occurs here\n+LL |         if let [_, ref mut  second2, ref mut third, ..] = *s { //~ERROR\n+   |                    ^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[first, second, second2, third]);\n+   |                          ------ borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:44:21\n+   |\n+LL |     if let [.., ref fourth, ref third, _, ref first] = *s {\n+   |                             --------- immutable borrow occurs here\n+LL |         if let [.., ref mut third2, _, _] = *s { //~ERROR\n+   |                     ^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[first, third, third2, fourth]);\n+   |                          ----- borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:55:20\n+   |\n+LL |     if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n+   |                    ------------- immutable borrow occurs here\n+...\n+LL |         if let [_, ref mut from_begin1, ..] = *s { //~ERROR\n+   |                    ^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[from_begin1, from_end1, from_end3, from_end4]);\n+   |                                                      --------- borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:58:23\n+   |\n+LL |     if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n+   |                                   ------------- immutable borrow occurs here\n+...\n+LL |         if let [_, _, ref mut from_begin2, ..] = *s { //~ERROR\n+   |                       ^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[from_begin2, from_end1, from_end3, from_end4]);\n+   |                                           --------- borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:61:26\n+   |\n+LL |     if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n+   |                                   ------------- immutable borrow occurs here\n+...\n+LL |         if let [_, _, _, ref mut from_begin3, ..] = *s { //~ERROR\n+   |                          ^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[from_begin3, from_end1, from_end3, from_end4]);\n+   |                                           --------- borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:69:21\n+   |\n+LL |     if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n+   |                                                  --------------- immutable borrow occurs here\n+...\n+LL |         if let [.., ref mut from_end2, _] = *s { //~ERROR\n+   |                     ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[from_begin0, from_begin1, from_begin3, from_end2]);\n+   |                                             ----------- borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:72:21\n+   |\n+LL |     if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n+   |                                                  --------------- immutable borrow occurs here\n+...\n+LL |         if let [.., ref mut from_end3, _,  _] = *s { //~ERROR\n+   |                     ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[from_begin0, from_begin1, from_begin3, from_end3]);\n+   |                                             ----------- borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:75:21\n+   |\n+LL |     if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n+   |                              --------------- immutable borrow occurs here\n+...\n+LL |         if let [.., ref mut from_end4, _, _, _] = *s { //~ERROR\n+   |                     ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[from_begin0, from_begin1, from_begin3, from_end4]);\n+   |                                ----------- borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:92:20\n+   |\n+LL |     if let [ref first, ref second, ..] = *s {\n+   |                        ---------- immutable borrow occurs here\n+LL |         if let [_, ref mut tail..] = *s { //~ERROR\n+   |                    ^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[first, second]);\n+   |                          ------ borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:110:17\n+   |\n+LL |     if let [.., ref second, ref first] = *s {\n+   |                 ---------- immutable borrow occurs here\n+LL |         if let [ref mut tail.., _] = *s { //~ERROR\n+   |                 ^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[first, second]);\n+   |                          ------ borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:119:17\n+   |\n+LL |     if let [_, _, _, ref s1..] = *s {\n+   |                      ------ immutable borrow occurs here\n+LL |         if let [ref mut s2.., _, _, _] = *s { //~ERROR\n+   |                 ^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop_subslice(s1);\n+   |                          -- borrow later used here\n+\n+error: aborting due to 11 previous errors\n+\n+For more information about this error, try `rustc --explain E0502`."}]}