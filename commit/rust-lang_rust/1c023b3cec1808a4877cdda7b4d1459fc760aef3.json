{"sha": "1c023b3cec1808a4877cdda7b4d1459fc760aef3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMDIzYjNjZWMxODA4YTQ4NzdjZGRhN2I0ZDE0NTlmYzc2MGFlZjM=", "commit": {"author": {"name": "Sunjay Varma", "email": "varma.sunjay@gmail.com", "date": "2017-11-22T18:15:05Z"}, "committer": {"name": "Sunjay Varma", "email": "varma.sunjay@gmail.com", "date": "2017-12-01T06:26:29Z"}, "message": "Renaming MethodRibKind to TraitOrImplItemRibKind and removing its field which was never used. Lifting the HasTypeParameters rib to all trait item kinds and all impl item kinds", "tree": {"sha": "0907479622aeaab1949ba37a31c4a08895e9a1ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0907479622aeaab1949ba37a31c4a08895e9a1ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c023b3cec1808a4877cdda7b4d1459fc760aef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c023b3cec1808a4877cdda7b4d1459fc760aef3", "html_url": "https://github.com/rust-lang/rust/commit/1c023b3cec1808a4877cdda7b4d1459fc760aef3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c023b3cec1808a4877cdda7b4d1459fc760aef3/comments", "author": {"login": "sunjay", "id": 530939, "node_id": "MDQ6VXNlcjUzMDkzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/530939?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunjay", "html_url": "https://github.com/sunjay", "followers_url": "https://api.github.com/users/sunjay/followers", "following_url": "https://api.github.com/users/sunjay/following{/other_user}", "gists_url": "https://api.github.com/users/sunjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunjay/subscriptions", "organizations_url": "https://api.github.com/users/sunjay/orgs", "repos_url": "https://api.github.com/users/sunjay/repos", "events_url": "https://api.github.com/users/sunjay/events{/privacy}", "received_events_url": "https://api.github.com/users/sunjay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sunjay", "id": 530939, "node_id": "MDQ6VXNlcjUzMDkzOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/530939?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunjay", "html_url": "https://github.com/sunjay", "followers_url": "https://api.github.com/users/sunjay/followers", "following_url": "https://api.github.com/users/sunjay/following{/other_user}", "gists_url": "https://api.github.com/users/sunjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunjay/subscriptions", "organizations_url": "https://api.github.com/users/sunjay/orgs", "repos_url": "https://api.github.com/users/sunjay/repos", "events_url": "https://api.github.com/users/sunjay/events{/privacy}", "received_events_url": "https://api.github.com/users/sunjay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0621a178613d04bcd3855dd74bf0a3affb105df", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0621a178613d04bcd3855dd74bf0a3affb105df", "html_url": "https://github.com/rust-lang/rust/commit/e0621a178613d04bcd3855dd74bf0a3affb105df"}], "stats": {"total": 149, "additions": 69, "deletions": 80}, "files": [{"sha": "2143296c13cb5ba73c348ccbfda2b2be63413c34", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 69, "deletions": 80, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/1c023b3cec1808a4877cdda7b4d1459fc760aef3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c023b3cec1808a4877cdda7b4d1459fc760aef3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1c023b3cec1808a4877cdda7b4d1459fc760aef3", "patch": "@@ -734,8 +734,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             FnKind::ItemFn(..) => {\n                 ItemRibKind\n             }\n-            FnKind::Method(_, sig, _, _) => {\n-                MethodRibKind(!sig.decl.has_self())\n+            FnKind::Method(_, _, _, _) => {\n+                TraitOrImplItemRibKind\n             }\n             FnKind::Closure(_) => ClosureRibKind(node_id),\n         };\n@@ -823,12 +823,10 @@ enum RibKind<'a> {\n     ClosureRibKind(NodeId /* func id */),\n \n     // We passed through an impl or trait and are now in one of its\n-    // methods. Allow references to ty params that impl or trait\n+    // methods or associated types. Allow references to ty params that impl or trait\n     // binds. Disallow any other upvars (including other ty params that are\n     // upvars).\n-    //\n-    // The boolean value represents the fact that this method is static or not.\n-    MethodRibKind(bool),\n+    TraitOrImplItemRibKind,\n \n     // We passed through an item scope. Disallow upvars.\n     ItemRibKind,\n@@ -1888,36 +1886,33 @@ impl<'a> Resolver<'a> {\n                         for trait_item in trait_items {\n                             this.check_proc_macro_attrs(&trait_item.attrs);\n \n-                            match trait_item.node {\n-                                TraitItemKind::Const(ref ty, ref default) => {\n-                                    this.visit_ty(ty);\n-\n-                                    // Only impose the restrictions of\n-                                    // ConstRibKind for an actual constant\n-                                    // expression in a provided default.\n-                                    if let Some(ref expr) = *default{\n-                                        this.with_constant_rib(|this| {\n-                                            this.visit_expr(expr);\n-                                        });\n+                            let type_parameters = HasTypeParameters(&trait_item.generics,\n+                                                                    TraitOrImplItemRibKind);\n+                            this.with_type_parameter_rib(type_parameters, |this| {\n+                                match trait_item.node {\n+                                    TraitItemKind::Const(ref ty, ref default) => {\n+                                        this.visit_ty(ty);\n+\n+                                        // Only impose the restrictions of\n+                                        // ConstRibKind for an actual constant\n+                                        // expression in a provided default.\n+                                        if let Some(ref expr) = *default{\n+                                            this.with_constant_rib(|this| {\n+                                                this.visit_expr(expr);\n+                                            });\n+                                        }\n                                     }\n-                                }\n-                                TraitItemKind::Method(ref sig, _) => {\n-                                    let type_parameters =\n-                                        HasTypeParameters(&trait_item.generics,\n-                                                          MethodRibKind(!sig.decl.has_self()));\n-                                    this.with_type_parameter_rib(type_parameters, |this| {\n+                                    TraitItemKind::Method(_, _) => {\n                                         visit::walk_trait_item(this, trait_item)\n-                                    });\n-                                }\n-                                TraitItemKind::Type(..) => {\n-                                    let type_parameters = HasTypeParameters(&trait_item.generics,\n-                                                                            ItemRibKind);\n-                                    this.with_type_parameter_rib(type_parameters, |this| {\n+                                    }\n+                                    TraitItemKind::Type(..) => {\n                                         visit::walk_trait_item(this, trait_item)\n-                                    });\n-                                }\n-                                TraitItemKind::Macro(_) => panic!(\"unexpanded macro in resolve!\"),\n-                            };\n+                                    }\n+                                    TraitItemKind::Macro(_) => {\n+                                        panic!(\"unexpanded macro in resolve!\")\n+                                    }\n+                                };\n+                            });\n                         }\n                     });\n                 });\n@@ -2125,54 +2120,48 @@ impl<'a> Resolver<'a> {\n                             for impl_item in impl_items {\n                                 this.check_proc_macro_attrs(&impl_item.attrs);\n                                 this.resolve_visibility(&impl_item.vis);\n-                                match impl_item.node {\n-                                    ImplItemKind::Const(..) => {\n-                                        // If this is a trait impl, ensure the const\n-                                        // exists in trait\n-                                        this.check_trait_item(impl_item.ident,\n-                                                            ValueNS,\n-                                                            impl_item.span,\n-                                            |n, s| ResolutionError::ConstNotMemberOfTrait(n, s));\n-                                        this.with_constant_rib(|this|\n-                                            visit::walk_impl_item(this, impl_item)\n-                                        );\n-                                    }\n-                                    ImplItemKind::Method(ref sig, _) => {\n-                                        // If this is a trait impl, ensure the method\n-                                        // exists in trait\n-                                        this.check_trait_item(impl_item.ident,\n-                                                            ValueNS,\n-                                                            impl_item.span,\n-                                            |n, s| ResolutionError::MethodNotMemberOfTrait(n, s));\n-\n-                                        // We also need a new scope for the method-\n-                                        // specific type parameters.\n-                                        let type_parameters =\n-                                            HasTypeParameters(&impl_item.generics,\n-                                                            MethodRibKind(!sig.decl.has_self()));\n-                                        this.with_type_parameter_rib(type_parameters, |this| {\n+\n+                                // We also need a new scope for the impl item type parameters.\n+                                let type_parameters = HasTypeParameters(&impl_item.generics,\n+                                                                        TraitOrImplItemRibKind);\n+                                this.with_type_parameter_rib(type_parameters, |this| {\n+                                    use self::ResolutionError::*;\n+                                    match impl_item.node {\n+                                        ImplItemKind::Const(..) => {\n+                                            // If this is a trait impl, ensure the const\n+                                            // exists in trait\n+                                            this.check_trait_item(impl_item.ident,\n+                                                                ValueNS,\n+                                                                impl_item.span,\n+                                                |n, s| ConstNotMemberOfTrait(n, s));\n+                                            this.with_constant_rib(|this|\n+                                                visit::walk_impl_item(this, impl_item)\n+                                            );\n+                                        }\n+                                        ImplItemKind::Method(_, _) => {\n+                                            // If this is a trait impl, ensure the method\n+                                            // exists in trait\n+                                            this.check_trait_item(impl_item.ident,\n+                                                                ValueNS,\n+                                                                impl_item.span,\n+                                                |n, s| MethodNotMemberOfTrait(n, s));\n+\n                                             visit::walk_impl_item(this, impl_item);\n-                                        });\n-                                    }\n-                                    ImplItemKind::Type(ref ty) => {\n-                                        // If this is a trait impl, ensure the type\n-                                        // exists in trait\n-                                        this.check_trait_item(impl_item.ident,\n-                                                            TypeNS,\n-                                                            impl_item.span,\n-                                            |n, s| ResolutionError::TypeNotMemberOfTrait(n, s));\n-\n-                                        // We also need a new scope for the associated type\n-                                        // specific type parameters.\n-                                        let type_parameters =\n-                                            HasTypeParameters(&impl_item.generics, ItemRibKind);\n-                                        this.with_type_parameter_rib(type_parameters, |this| {\n+                                        }\n+                                        ImplItemKind::Type(ref ty) => {\n+                                            // If this is a trait impl, ensure the type\n+                                            // exists in trait\n+                                            this.check_trait_item(impl_item.ident,\n+                                                                TypeNS,\n+                                                                impl_item.span,\n+                                                |n, s| TypeNotMemberOfTrait(n, s));\n+\n                                             this.visit_ty(ty);\n-                                        });\n+                                        }\n+                                        ImplItemKind::Macro(_) =>\n+                                            panic!(\"unexpanded macro in resolve!\"),\n                                     }\n-                                    ImplItemKind::Macro(_) =>\n-                                        panic!(\"unexpanded macro in resolve!\"),\n-                                }\n+                                });\n                             }\n                         });\n                     });\n@@ -3108,7 +3097,7 @@ impl<'a> Resolver<'a> {\n                                 seen.insert(node_id, depth);\n                             }\n                         }\n-                        ItemRibKind | MethodRibKind(_) => {\n+                        ItemRibKind | TraitOrImplItemRibKind => {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n@@ -3132,7 +3121,7 @@ impl<'a> Resolver<'a> {\n             Def::TyParam(..) | Def::SelfTy(..) => {\n                 for rib in ribs {\n                     match rib.kind {\n-                        NormalRibKind | MethodRibKind(_) | ClosureRibKind(..) |\n+                        NormalRibKind | TraitOrImplItemRibKind | ClosureRibKind(..) |\n                         ModuleRibKind(..) | MacroDefinition(..) | ForwardTyParamBanRibKind |\n                         ConstantItemRibKind => {\n                             // Nothing to do. Continue."}]}