{"sha": "0eb858b4c913b531ae5ac915abbbe579b49b9df4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYjg1OGI0YzkxM2I1MzFhZTVhYzkxNWFiYmJlNTc5YjQ5YjlkZjQ=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-06-06T08:56:03Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-06-09T14:36:56Z"}, "message": "Cleanup bigint", "tree": {"sha": "669e52b0aa8be7178d7ed4391f97cc463cb3f066", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/669e52b0aa8be7178d7ed4391f97cc463cb3f066"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0eb858b4c913b531ae5ac915abbbe579b49b9df4", "comment_count": 13, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0eb858b4c913b531ae5ac915abbbe579b49b9df4", "html_url": "https://github.com/rust-lang/rust/commit/0eb858b4c913b531ae5ac915abbbe579b49b9df4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0eb858b4c913b531ae5ac915abbbe579b49b9df4/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ca00ec0db8875e97fbe88990722dd9378f51b11", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ca00ec0db8875e97fbe88990722dd9378f51b11", "html_url": "https://github.com/rust-lang/rust/commit/3ca00ec0db8875e97fbe88990722dd9378f51b11"}], "stats": {"total": 63, "additions": 27, "deletions": 36}, "files": [{"sha": "0933301970d1969a3901a1c9f6b196107653e7b4", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0eb858b4c913b531ae5ac915abbbe579b49b9df4/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb858b4c913b531ae5ac915abbbe579b49b9df4/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=0eb858b4c913b531ae5ac915abbbe579b49b9df4", "patch": "@@ -17,18 +17,16 @@ A `BigInt` is a combination of `BigUint` and `Sign`.\n */\n \n use Integer;\n+use rand::Rng;\n \n-use std::cmp;\n+use std::{cmp, fmt};\n use std::default::Default;\n-use std::fmt;\n use std::from_str::FromStr;\n use std::num::CheckedDiv;\n use std::num::{Bitwise, ToPrimitive, FromPrimitive};\n use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n-use rand::Rng;\n use std::string::String;\n-use std::uint;\n-use std::{i64, u64};\n+use std::{uint, i64, u64};\n \n /**\n A `BigDigit` is a `BigUint`'s composing element.\n@@ -94,7 +92,7 @@ impl Eq for BigUint {}\n impl PartialOrd for BigUint {\n     #[inline]\n     fn lt(&self, other: &BigUint) -> bool {\n-        match self.cmp(other) { Less => true, _ => false}\n+        self.cmp(other) == Less\n     }\n }\n \n@@ -115,7 +113,7 @@ impl Ord for BigUint {\n \n impl Default for BigUint {\n     #[inline]\n-    fn default() -> BigUint { BigUint::new(Vec::new()) }\n+    fn default() -> BigUint { Zero::zero() }\n }\n \n impl fmt::Show for BigUint {\n@@ -605,7 +603,7 @@ impl_to_biguint!(u64,  FromPrimitive::from_u64)\n \n impl ToStrRadix for BigUint {\n     fn to_str_radix(&self, radix: uint) -> String {\n-        assert!(1 < radix && radix <= 16);\n+        assert!(1 < radix && radix <= 16, \"The radix must be within (1, 16]\");\n         let (base, max_len) = get_radix_base(radix);\n         if base == BigDigit::base {\n             return fill_concat(self.data.as_slice(), radix, max_len)\n@@ -645,8 +643,7 @@ impl ToStrRadix for BigUint {\n impl FromStrRadix for BigUint {\n     /// Creates and initializes a `BigUint`.\n     #[inline]\n-    fn from_str_radix(s: &str, radix: uint)\n-        -> Option<BigUint> {\n+    fn from_str_radix(s: &str, radix: uint) -> Option<BigUint> {\n         BigUint::parse_bytes(s.as_bytes(), radix)\n     }\n }\n@@ -656,22 +653,19 @@ impl BigUint {\n     ///\n     /// The digits are be in base 2^32.\n     #[inline]\n-    pub fn new(v: Vec<BigDigit>) -> BigUint {\n+    pub fn new(mut digits: Vec<BigDigit>) -> BigUint {\n         // omit trailing zeros\n-        let new_len = v.iter().rposition(|n| *n != 0).map_or(0, |p| p + 1);\n-\n-        if new_len == v.len() { return BigUint { data: v }; }\n-        let mut v = v;\n-        v.truncate(new_len);\n-        return BigUint { data: v };\n+        let new_len = digits.iter().rposition(|n| *n != 0).map_or(0, |p| p + 1);\n+        digits.truncate(new_len);\n+        BigUint { data: digits }\n     }\n \n     /// Creates and initializes a `BigUint`.\n     ///\n     /// The digits are be in base 2^32.\n     #[inline]\n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n-        return BigUint::new(Vec::from_slice(slice));\n+        BigUint::new(Vec::from_slice(slice))\n     }\n \n     /// Creates and initializes a `BigUint`.\n@@ -768,7 +762,6 @@ impl BigUint {\n // `DoubleBigDigit` size dependent\n #[inline]\n fn get_radix_base(radix: uint) -> (DoubleBigDigit, uint) {\n-    assert!(1 < radix && radix <= 16);\n     match radix {\n         2  => (4294967296, 32),\n         3  => (3486784401, 20),\n@@ -785,7 +778,7 @@ fn get_radix_base(radix: uint) -> (DoubleBigDigit, uint) {\n         14 => (1475789056, 8),\n         15 => (2562890625, 8),\n         16 => (4294967296, 8),\n-        _  => fail!()\n+        _  => fail!(\"The radix must be within (1, 16]\")\n     }\n }\n \n@@ -815,7 +808,7 @@ pub struct BigInt {\n impl PartialEq for BigInt {\n     #[inline]\n     fn eq(&self, other: &BigInt) -> bool {\n-        match self.cmp(other) { Equal => true, _ => false }\n+        self.cmp(other) == Equal\n     }\n }\n \n@@ -824,7 +817,7 @@ impl Eq for BigInt {}\n impl PartialOrd for BigInt {\n     #[inline]\n     fn lt(&self, other: &BigInt) -> bool {\n-        match self.cmp(other) { Less => true, _ => false}\n+        self.cmp(other) == Less\n     }\n }\n \n@@ -844,7 +837,7 @@ impl Ord for BigInt {\n \n impl Default for BigInt {\n     #[inline]\n-    fn default() -> BigInt { BigInt::new(Zero, Vec::new()) }\n+    fn default() -> BigInt { Zero::zero() }\n }\n \n impl fmt::Show for BigInt {\n@@ -929,8 +922,7 @@ impl Add<BigInt, BigInt> for BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)      => other.clone(),\n             (_,    Zero)   => self.clone(),\n-            (Plus, Plus)   => BigInt::from_biguint(Plus,\n-                                                   self.data + other.data),\n+            (Plus, Plus)   => BigInt::from_biguint(Plus, self.data + other.data),\n             (Plus, Minus)  => self - (-*other),\n             (Minus, Plus)  => other - (-*self),\n             (Minus, Minus) => -((-self) + (-*other))\n@@ -975,15 +967,15 @@ impl Div<BigInt, BigInt> for BigInt {\n     #[inline]\n     fn div(&self, other: &BigInt) -> BigInt {\n         let (q, _) = self.div_rem(other);\n-        return q;\n+        q\n     }\n }\n \n impl Rem<BigInt, BigInt> for BigInt {\n     #[inline]\n     fn rem(&self, other: &BigInt) -> BigInt {\n         let (_, r) = self.div_rem(other);\n-        return r;\n+        r\n     }\n }\n \n@@ -1045,13 +1037,13 @@ impl Integer for BigInt {\n     #[inline]\n     fn div_floor(&self, other: &BigInt) -> BigInt {\n         let (d, _) = self.div_mod_floor(other);\n-        return d;\n+        d\n     }\n \n     #[inline]\n     fn mod_floor(&self, other: &BigInt) -> BigInt {\n         let (_, m) = self.div_mod_floor(other);\n-        return m;\n+        m\n     }\n \n     fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {\n@@ -1265,7 +1257,7 @@ impl<R: Rng> RandBigInt for R {\n             let final_digit: BigDigit = self.gen();\n             data.push(final_digit >> (BigDigit::bits - rem));\n         }\n-        return BigUint::new(data);\n+        BigUint::new(data)\n     }\n \n     fn gen_bigint(&mut self, bit_size: uint) -> BigInt {\n@@ -1287,7 +1279,7 @@ impl<R: Rng> RandBigInt for R {\n         } else {\n             Minus\n         };\n-        return BigInt::from_biguint(sign, biguint);\n+        BigInt::from_biguint(sign, biguint)\n     }\n \n     fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint {\n@@ -1322,8 +1314,8 @@ impl BigInt {\n     ///\n     /// The digits are be in base 2^32.\n     #[inline]\n-    pub fn new(sign: Sign, v: Vec<BigDigit>) -> BigInt {\n-        BigInt::from_biguint(sign, BigUint::new(v))\n+    pub fn new(sign: Sign, digits: Vec<BigDigit>) -> BigInt {\n+        BigInt::from_biguint(sign, BigUint::new(digits))\n     }\n \n     /// Creates and initializes a `BigInt`.\n@@ -1334,7 +1326,7 @@ impl BigInt {\n         if sign == Zero || data.is_zero() {\n             return BigInt { sign: Zero, data: Zero::zero() };\n         }\n-        return BigInt { sign: sign, data: data };\n+        BigInt { sign: sign, data: data }\n     }\n \n     /// Creates and initializes a `BigInt`.\n@@ -1344,8 +1336,7 @@ impl BigInt {\n     }\n \n     /// Creates and initializes a `BigInt`.\n-    pub fn parse_bytes(buf: &[u8], radix: uint)\n-        -> Option<BigInt> {\n+    pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<BigInt> {\n         if buf.is_empty() { return None; }\n         let mut sign  = Plus;\n         let mut start = 0;"}]}