{"sha": "ff223ff29799eaf99635ad0a07547f572a7136d7", "node_id": "C_kwDOAAsO6NoAKGZmMjIzZmYyOTc5OWVhZjk5NjM1YWQwYTA3NTQ3ZjU3MmE3MTM2ZDc", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-06-28T10:00:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-28T10:00:05Z"}, "message": "Rollup merge of #98430 - camsteffen:flatten-refactor, r=joshtriplett\n\nRefactor iter adapters with less macros\n\nJust some code cleanup. Introduced a util `and_then_or_clear` for each of chain, flatten and fuse iter adapter impls. This reduces code nicely for flatten, but admittedly the other modules are more of a lateral move replacing macros with a function. But I think consistency across the modules and avoiding macros when possible is good.", "tree": {"sha": "5d02e2f68c5b127f4e752a07e5ad23a211727939", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d02e2f68c5b127f4e752a07e5ad23a211727939"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff223ff29799eaf99635ad0a07547f572a7136d7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiutElCRBK7hj4Ov3rIwAAEdwIABjy3DwV2zY4oYH3fSM5zGuk\nL80QcrcHadJ08nGkej8z4h8PO2qCzIvJOk+L4UfIoc6YlKAbiJG/w9mYI9BcVP3z\n96lnpuYDwIWJnjs78rYcrApJE+zxSNBVnFjqltpwjbDzBOgeavxLO7TxcC9lmIW3\nT35/RQsiTLDvcPUUoV0jx3IlW3KqCGY2HY7Rvo8R3zs36KdJ4XiM89U/p6j74KRp\n+d1ZQt9QQctOLU+25vE9OQXd4LbazJvlLE5QoLi4all1ARf2PH0HavPMMPzWaGGa\n4jQCwe26Qy2iT27+TOAGhpJRgw8qUrVXHWZKzB+4KfCIjHKvVXwFrNSV5TNwwxY=\n=BtX+\n-----END PGP SIGNATURE-----\n", "payload": "tree 5d02e2f68c5b127f4e752a07e5ad23a211727939\nparent 400f435c2ddb2139ab967b375bc1fd0a06f1aa46\nparent 6587dda39e9b49b322394592e45a477da68c7f1a\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1656410405 +0530\ncommitter GitHub <noreply@github.com> 1656410405 +0530\n\nRollup merge of #98430 - camsteffen:flatten-refactor, r=joshtriplett\n\nRefactor iter adapters with less macros\n\nJust some code cleanup. Introduced a util `and_then_or_clear` for each of chain, flatten and fuse iter adapter impls. This reduces code nicely for flatten, but admittedly the other modules are more of a lateral move replacing macros with a function. But I think consistency across the modules and avoiding macros when possible is good.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff223ff29799eaf99635ad0a07547f572a7136d7", "html_url": "https://github.com/rust-lang/rust/commit/ff223ff29799eaf99635ad0a07547f572a7136d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff223ff29799eaf99635ad0a07547f572a7136d7/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "400f435c2ddb2139ab967b375bc1fd0a06f1aa46", "url": "https://api.github.com/repos/rust-lang/rust/commits/400f435c2ddb2139ab967b375bc1fd0a06f1aa46", "html_url": "https://github.com/rust-lang/rust/commit/400f435c2ddb2139ab967b375bc1fd0a06f1aa46"}, {"sha": "6587dda39e9b49b322394592e45a477da68c7f1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6587dda39e9b49b322394592e45a477da68c7f1a", "html_url": "https://github.com/rust-lang/rust/commit/6587dda39e9b49b322394592e45a477da68c7f1a"}], "stats": {"total": 173, "additions": 56, "deletions": 117}, "files": [{"sha": "60eb3a6da3a4bf93147a7a5cd103ed380eef6954", "filename": "library/core/src/iter/adapters/chain.rs", "status": "modified", "additions": 19, "deletions": 53, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ff223ff29799eaf99635ad0a07547f572a7136d7/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff223ff29799eaf99635ad0a07547f572a7136d7/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs?ref=ff223ff29799eaf99635ad0a07547f572a7136d7", "patch": "@@ -37,33 +37,6 @@ impl<A, B> Chain<A, B> {\n     }\n }\n \n-/// Fuse the iterator if the expression is `None`.\n-macro_rules! fuse {\n-    ($self:ident . $iter:ident . $($call:tt)+) => {\n-        match $self.$iter {\n-            Some(ref mut iter) => match iter.$($call)+ {\n-                None => {\n-                    $self.$iter = None;\n-                    None\n-                }\n-                item => item,\n-            },\n-            None => None,\n-        }\n-    };\n-}\n-\n-/// Try an iterator method without fusing,\n-/// like an inline `.as_mut().and_then(...)`\n-macro_rules! maybe {\n-    ($self:ident . $iter:ident . $($call:tt)+) => {\n-        match $self.$iter {\n-            Some(ref mut iter) => iter.$($call)+,\n-            None => None,\n-        }\n-    };\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> Iterator for Chain<A, B>\n where\n@@ -74,10 +47,7 @@ where\n \n     #[inline]\n     fn next(&mut self) -> Option<A::Item> {\n-        match fuse!(self.a.next()) {\n-            None => maybe!(self.b.next()),\n-            item => item,\n-        }\n+        and_then_or_clear(&mut self.a, Iterator::next).or_else(|| self.b.as_mut()?.next())\n     }\n \n     #[inline]\n@@ -161,31 +131,23 @@ where\n             self.a = None;\n         }\n \n-        maybe!(self.b.nth(n))\n+        self.b.as_mut()?.nth(n)\n     }\n \n     #[inline]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        match fuse!(self.a.find(&mut predicate)) {\n-            None => maybe!(self.b.find(predicate)),\n-            item => item,\n-        }\n+        and_then_or_clear(&mut self.a, |a| a.find(&mut predicate))\n+            .or_else(|| self.b.as_mut()?.find(predicate))\n     }\n \n     #[inline]\n     fn last(self) -> Option<A::Item> {\n         // Must exhaust a before b.\n-        let a_last = match self.a {\n-            Some(a) => a.last(),\n-            None => None,\n-        };\n-        let b_last = match self.b {\n-            Some(b) => b.last(),\n-            None => None,\n-        };\n+        let a_last = self.a.and_then(Iterator::last);\n+        let b_last = self.b.and_then(Iterator::last);\n         b_last.or(a_last)\n     }\n \n@@ -220,10 +182,7 @@ where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<A::Item> {\n-        match fuse!(self.b.next_back()) {\n-            None => maybe!(self.a.next_back()),\n-            item => item,\n-        }\n+        and_then_or_clear(&mut self.b, |b| b.next_back()).or_else(|| self.a.as_mut()?.next_back())\n     }\n \n     #[inline]\n@@ -263,18 +222,16 @@ where\n             self.b = None;\n         }\n \n-        maybe!(self.a.nth_back(n))\n+        self.a.as_mut()?.nth_back(n)\n     }\n \n     #[inline]\n     fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        match fuse!(self.b.rfind(&mut predicate)) {\n-            None => maybe!(self.a.rfind(predicate)),\n-            item => item,\n-        }\n+        and_then_or_clear(&mut self.b, |b| b.rfind(&mut predicate))\n+            .or_else(|| self.a.as_mut()?.rfind(predicate))\n     }\n \n     fn try_rfold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n@@ -324,3 +281,12 @@ where\n     B: TrustedLen<Item = A::Item>,\n {\n }\n+\n+#[inline]\n+fn and_then_or_clear<T, U>(opt: &mut Option<T>, f: impl FnOnce(&mut T) -> Option<U>) -> Option<U> {\n+    let x = f(opt.as_mut()?);\n+    if x.is_none() {\n+        *opt = None;\n+    }\n+    x\n+}"}, {"sha": "15a120e35a2fa16c75562b84eaed6e60ed79045e", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ff223ff29799eaf99635ad0a07547f572a7136d7/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff223ff29799eaf99635ad0a07547f572a7136d7/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=ff223ff29799eaf99635ad0a07547f572a7136d7", "patch": "@@ -290,20 +290,11 @@ where\n     #[inline]\n     fn next(&mut self) -> Option<U::Item> {\n         loop {\n-            if let Some(ref mut inner) = self.frontiter {\n-                match inner.next() {\n-                    None => self.frontiter = None,\n-                    elt @ Some(_) => return elt,\n-                }\n+            if let elt @ Some(_) = and_then_or_clear(&mut self.frontiter, Iterator::next) {\n+                return elt;\n             }\n             match self.iter.next() {\n-                None => match self.backiter.as_mut()?.next() {\n-                    None => {\n-                        self.backiter = None;\n-                        return None;\n-                    }\n-                    elt @ Some(_) => return elt,\n-                },\n+                None => return and_then_or_clear(&mut self.backiter, Iterator::next),\n                 Some(inner) => self.frontiter = Some(inner.into_iter()),\n             }\n         }\n@@ -436,21 +427,12 @@ where\n     #[inline]\n     fn next_back(&mut self) -> Option<U::Item> {\n         loop {\n-            if let Some(ref mut inner) = self.backiter {\n-                match inner.next_back() {\n-                    None => self.backiter = None,\n-                    elt @ Some(_) => return elt,\n-                }\n+            if let elt @ Some(_) = and_then_or_clear(&mut self.backiter, |b| b.next_back()) {\n+                return elt;\n             }\n             match self.iter.next_back() {\n-                None => match self.frontiter.as_mut()?.next_back() {\n-                    None => {\n-                        self.frontiter = None;\n-                        return None;\n-                    }\n-                    elt @ Some(_) => return elt,\n-                },\n-                next => self.backiter = next.map(IntoIterator::into_iter),\n+                None => return and_then_or_clear(&mut self.frontiter, |f| f.next_back()),\n+                Some(inner) => self.backiter = Some(inner.into_iter()),\n             }\n         }\n     }\n@@ -606,3 +588,12 @@ unsafe impl<T, const N: usize> TrustedConstSize for [T; N] {}\n unsafe impl<T, const N: usize> TrustedConstSize for &'_ [T; N] {}\n #[unstable(feature = \"std_internals\", issue = \"none\")]\n unsafe impl<T, const N: usize> TrustedConstSize for &'_ mut [T; N] {}\n+\n+#[inline]\n+fn and_then_or_clear<T, U>(opt: &mut Option<T>, f: impl FnOnce(&mut T) -> Option<U>) -> Option<U> {\n+    let x = f(opt.as_mut()?);\n+    if x.is_none() {\n+        *opt = None;\n+    }\n+    x\n+}"}, {"sha": "c931445420342bf16c9585ab145d1ca73ab0c910", "filename": "library/core/src/iter/adapters/fuse.rs", "status": "modified", "additions": 21, "deletions": 39, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ff223ff29799eaf99635ad0a07547f572a7136d7/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff223ff29799eaf99635ad0a07547f572a7136d7/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs?ref=ff223ff29799eaf99635ad0a07547f572a7136d7", "patch": "@@ -29,33 +29,6 @@ impl<I> Fuse<I> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Fuse<I> where I: Iterator {}\n \n-/// Fuse the iterator if the expression is `None`.\n-macro_rules! fuse {\n-    ($self:ident . iter . $($call:tt)+) => {\n-        match $self.iter {\n-            Some(ref mut iter) => match iter.$($call)+ {\n-                None => {\n-                    $self.iter = None;\n-                    None\n-                }\n-                item => item,\n-            },\n-            None => None,\n-        }\n-    };\n-}\n-\n-/// Specialized macro that doesn't check if the expression is `None`.\n-/// (We trust that a `FusedIterator` will fuse itself.)\n-macro_rules! spec {\n-    ($self:ident . iter . $($call:tt)+) => {\n-        match $self.iter {\n-            Some(ref mut iter) => iter.$($call)+,\n-            None => None,\n-        }\n-    };\n-}\n-\n // Any specialized implementation here is made internal\n // to avoid exposing default fns outside this trait.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -281,12 +254,12 @@ where\n \n     #[inline]\n     default fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        fuse!(self.iter.next())\n+        and_then_or_clear(&mut self.iter, Iterator::next)\n     }\n \n     #[inline]\n     default fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        fuse!(self.iter.nth(n))\n+        and_then_or_clear(&mut self.iter, |iter| iter.nth(n))\n     }\n \n     #[inline]\n@@ -308,23 +281,23 @@ where\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        fuse!(self.iter.find(predicate))\n+        and_then_or_clear(&mut self.iter, |iter| iter.find(predicate))\n     }\n \n     #[inline]\n     default fn next_back(&mut self) -> Option<<I as Iterator>::Item>\n     where\n         I: DoubleEndedIterator,\n     {\n-        fuse!(self.iter.next_back())\n+        and_then_or_clear(&mut self.iter, |iter| iter.next_back())\n     }\n \n     #[inline]\n     default fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item>\n     where\n         I: DoubleEndedIterator,\n     {\n-        fuse!(self.iter.nth_back(n))\n+        and_then_or_clear(&mut self.iter, |iter| iter.nth_back(n))\n     }\n \n     #[inline]\n@@ -348,7 +321,7 @@ where\n         P: FnMut(&Self::Item) -> bool,\n         I: DoubleEndedIterator,\n     {\n-        fuse!(self.iter.rfind(predicate))\n+        and_then_or_clear(&mut self.iter, |iter| iter.rfind(predicate))\n     }\n }\n \n@@ -361,12 +334,12 @@ where\n {\n     #[inline]\n     fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        spec!(self.iter.next())\n+        self.iter.as_mut()?.next()\n     }\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        spec!(self.iter.nth(n))\n+        self.iter.as_mut()?.nth(n)\n     }\n \n     #[inline]\n@@ -387,23 +360,23 @@ where\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        spec!(self.iter.find(predicate))\n+        self.iter.as_mut()?.find(predicate)\n     }\n \n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item>\n     where\n         I: DoubleEndedIterator,\n     {\n-        spec!(self.iter.next_back())\n+        self.iter.as_mut()?.next_back()\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item>\n     where\n         I: DoubleEndedIterator,\n     {\n-        spec!(self.iter.nth_back(n))\n+        self.iter.as_mut()?.nth_back(n)\n     }\n \n     #[inline]\n@@ -426,6 +399,15 @@ where\n         P: FnMut(&Self::Item) -> bool,\n         I: DoubleEndedIterator,\n     {\n-        spec!(self.iter.rfind(predicate))\n+        self.iter.as_mut()?.rfind(predicate)\n+    }\n+}\n+\n+#[inline]\n+fn and_then_or_clear<T, U>(opt: &mut Option<T>, f: impl FnOnce(&mut T) -> Option<U>) -> Option<U> {\n+    let x = f(opt.as_mut()?);\n+    if x.is_none() {\n+        *opt = None;\n     }\n+    x\n }"}]}