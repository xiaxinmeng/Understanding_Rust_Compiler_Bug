{"sha": "a2d87d83bfdffe3d9ba78c93d5da2b39148b01e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyZDg3ZDgzYmZkZmZlM2Q5YmE3OGM5M2Q1ZGEyYjM5MTQ4YjAxZTE=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-12-03T16:24:00Z"}, "committer": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-12-03T16:24:00Z"}, "message": "Consistent parameter name for numeric \u2018checked\u2019 operations.\n\nSome checked operations use `rhs` as a parameter name, and some use\n`other`. For the sake of consistency, unify everything under the `rhs`\nname.\n\nFixes https://github.com/rust-lang/rust/issues/46308.", "tree": {"sha": "bbf49f9efe0f2ad832c90d6254dacea733d2f9a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbf49f9efe0f2ad832c90d6254dacea733d2f9a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2d87d83bfdffe3d9ba78c93d5da2b39148b01e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2d87d83bfdffe3d9ba78c93d5da2b39148b01e1", "html_url": "https://github.com/rust-lang/rust/commit/a2d87d83bfdffe3d9ba78c93d5da2b39148b01e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2d87d83bfdffe3d9ba78c93d5da2b39148b01e1/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9da2112238c565a7e36ada0a1f9c899961910131", "url": "https://api.github.com/repos/rust-lang/rust/commits/9da2112238c565a7e36ada0a1f9c899961910131", "html_url": "https://github.com/rust-lang/rust/commit/9da2112238c565a7e36ada0a1f9c899961910131"}], "stats": {"total": 138, "additions": 69, "deletions": 69}, "files": [{"sha": "7c7562eac5152e6de9a88c907ea40a0ccd37cc96", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/a2d87d83bfdffe3d9ba78c93d5da2b39148b01e1/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2d87d83bfdffe3d9ba78c93d5da2b39148b01e1/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a2d87d83bfdffe3d9ba78c93d5da2b39148b01e1", "patch": "@@ -380,7 +380,7 @@ macro_rules! int_impl {\n             if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n         }\n \n-        /// Checked integer addition. Computes `self + other`, returning `None`\n+        /// Checked integer addition. Computes `self + rhs`, returning `None`\n         /// if overflow occurred.\n         ///\n         /// # Examples\n@@ -393,12 +393,12 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_add(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_add(other);\n+        pub fn checked_add(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_add(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer subtraction. Computes `self - other`, returning\n+        /// Checked integer subtraction. Computes `self - rhs`, returning\n         /// `None` if underflow occurred.\n         ///\n         /// # Examples\n@@ -411,12 +411,12 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_sub(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_sub(other);\n+        pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_sub(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer multiplication. Computes `self * other`, returning\n+        /// Checked integer multiplication. Computes `self * rhs`, returning\n         /// `None` if underflow or overflow occurred.\n         ///\n         /// # Examples\n@@ -429,13 +429,13 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_mul(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_mul(other);\n+        pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_mul(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer division. Computes `self / other`, returning `None`\n-        /// if `other == 0` or the operation results in underflow or overflow.\n+        /// Checked integer division. Computes `self / rhs`, returning `None`\n+        /// if `rhs == 0` or the operation results in underflow or overflow.\n         ///\n         /// # Examples\n         ///\n@@ -448,16 +448,16 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_div(self, other: Self) -> Option<Self> {\n-            if other == 0 || (self == Self::min_value() && other == -1) {\n+        pub fn checked_div(self, rhs: Self) -> Option<Self> {\n+            if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                 None\n             } else {\n-                Some(unsafe { intrinsics::unchecked_div(self, other) })\n+                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n             }\n         }\n \n-        /// Checked integer remainder. Computes `self % other`, returning `None`\n-        /// if `other == 0` or the operation results in underflow or overflow.\n+        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n+        /// if `rhs == 0` or the operation results in underflow or overflow.\n         ///\n         /// # Examples\n         ///\n@@ -472,11 +472,11 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n-        pub fn checked_rem(self, other: Self) -> Option<Self> {\n-            if other == 0 || (self == Self::min_value() && other == -1) {\n+        pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n+            if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n                 None\n             } else {\n-                Some(unsafe { intrinsics::unchecked_rem(self, other) })\n+                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n             }\n         }\n \n@@ -559,7 +559,7 @@ macro_rules! int_impl {\n             }\n         }\n \n-        /// Saturating integer addition. Computes `self + other`, saturating at\n+        /// Saturating integer addition. Computes `self + rhs`, saturating at\n         /// the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -572,15 +572,15 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_add(self, other: Self) -> Self {\n-            match self.checked_add(other) {\n+        pub fn saturating_add(self, rhs: Self) -> Self {\n+            match self.checked_add(rhs) {\n                 Some(x) => x,\n-                None if other >= 0 => Self::max_value(),\n+                None if rhs >= 0 => Self::max_value(),\n                 None => Self::min_value(),\n             }\n         }\n \n-        /// Saturating integer subtraction. Computes `self - other`, saturating\n+        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n         /// at the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -593,15 +593,15 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_sub(self, other: Self) -> Self {\n-            match self.checked_sub(other) {\n+        pub fn saturating_sub(self, rhs: Self) -> Self {\n+            match self.checked_sub(rhs) {\n                 Some(x) => x,\n-                None if other >= 0 => Self::min_value(),\n+                None if rhs >= 0 => Self::min_value(),\n                 None => Self::max_value(),\n             }\n         }\n \n-        /// Saturating integer multiplication. Computes `self * other`,\n+        /// Saturating integer multiplication. Computes `self * rhs`,\n         /// saturating at the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -617,17 +617,17 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n-        pub fn saturating_mul(self, other: Self) -> Self {\n-            self.checked_mul(other).unwrap_or_else(|| {\n-                if (self < 0 && other < 0) || (self > 0 && other > 0) {\n+        pub fn saturating_mul(self, rhs: Self) -> Self {\n+            self.checked_mul(rhs).unwrap_or_else(|| {\n+                if (self < 0 && rhs < 0) || (self > 0 && rhs > 0) {\n                     Self::max_value()\n                 } else {\n                     Self::min_value()\n                 }\n             })\n         }\n \n-        /// Wrapping (modular) addition. Computes `self + other`,\n+        /// Wrapping (modular) addition. Computes `self + rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n@@ -646,7 +646,7 @@ macro_rules! int_impl {\n             }\n         }\n \n-        /// Wrapping (modular) subtraction. Computes `self - other`,\n+        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n@@ -666,7 +666,7 @@ macro_rules! int_impl {\n         }\n \n         /// Wrapping (modular) multiplication. Computes `self *\n-        /// other`, wrapping around at the boundary of the type.\n+        /// rhs`, wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n         ///\n@@ -684,7 +684,7 @@ macro_rules! int_impl {\n             }\n         }\n \n-        /// Wrapping (modular) division. Computes `self / other`,\n+        /// Wrapping (modular) division. Computes `self / rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// The only case where such wrapping can occur is when one\n@@ -712,7 +712,7 @@ macro_rules! int_impl {\n             self.overflowing_div(rhs).0\n         }\n \n-        /// Wrapping (modular) remainder. Computes `self % other`,\n+        /// Wrapping (modular) remainder. Computes `self % rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// Such wrap-around never actually occurs mathematically;\n@@ -1573,7 +1573,7 @@ macro_rules! uint_impl {\n             if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n         }\n \n-        /// Checked integer addition. Computes `self + other`, returning `None`\n+        /// Checked integer addition. Computes `self + rhs`, returning `None`\n         /// if overflow occurred.\n         ///\n         /// # Examples\n@@ -1586,12 +1586,12 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_add(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_add(other);\n+        pub fn checked_add(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_add(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer subtraction. Computes `self - other`, returning\n+        /// Checked integer subtraction. Computes `self - rhs`, returning\n         /// `None` if underflow occurred.\n         ///\n         /// # Examples\n@@ -1604,12 +1604,12 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_sub(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_sub(other);\n+        pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_sub(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer multiplication. Computes `self * other`, returning\n+        /// Checked integer multiplication. Computes `self * rhs`, returning\n         /// `None` if underflow or overflow occurred.\n         ///\n         /// # Examples\n@@ -1622,13 +1622,13 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_mul(self, other: Self) -> Option<Self> {\n-            let (a, b) = self.overflowing_mul(other);\n+        pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n+            let (a, b) = self.overflowing_mul(rhs);\n             if b {None} else {Some(a)}\n         }\n \n-        /// Checked integer division. Computes `self / other`, returning `None`\n-        /// if `other == 0` or the operation results in underflow or overflow.\n+        /// Checked integer division. Computes `self / rhs`, returning `None`\n+        /// if `rhs == 0` or the operation results in underflow or overflow.\n         ///\n         /// # Examples\n         ///\n@@ -1640,15 +1640,15 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_div(self, other: Self) -> Option<Self> {\n-            match other {\n+        pub fn checked_div(self, rhs: Self) -> Option<Self> {\n+            match rhs {\n                 0 => None,\n-                other => Some(unsafe { intrinsics::unchecked_div(self, other) }),\n+                rhs => Some(unsafe { intrinsics::unchecked_div(self, rhs) }),\n             }\n         }\n \n-        /// Checked integer remainder. Computes `self % other`, returning `None`\n-        /// if `other == 0` or the operation results in underflow or overflow.\n+        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n+        /// if `rhs == 0` or the operation results in underflow or overflow.\n         ///\n         /// # Examples\n         ///\n@@ -1660,11 +1660,11 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n-        pub fn checked_rem(self, other: Self) -> Option<Self> {\n-            if other == 0 {\n+        pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n+            if rhs == 0 {\n                 None\n             } else {\n-                Some(unsafe { intrinsics::unchecked_rem(self, other) })\n+                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n             }\n         }\n \n@@ -1724,7 +1724,7 @@ macro_rules! uint_impl {\n             if b {None} else {Some(a)}\n         }\n \n-        /// Saturating integer addition. Computes `self + other`, saturating at\n+        /// Saturating integer addition. Computes `self + rhs`, saturating at\n         /// the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -1737,14 +1737,14 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_add(self, other: Self) -> Self {\n-            match self.checked_add(other) {\n+        pub fn saturating_add(self, rhs: Self) -> Self {\n+            match self.checked_add(rhs) {\n                 Some(x) => x,\n                 None => Self::max_value(),\n             }\n         }\n \n-        /// Saturating integer subtraction. Computes `self - other`, saturating\n+        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n         /// at the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -1757,14 +1757,14 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_sub(self, other: Self) -> Self {\n-            match self.checked_sub(other) {\n+        pub fn saturating_sub(self, rhs: Self) -> Self {\n+            match self.checked_sub(rhs) {\n                 Some(x) => x,\n                 None => Self::min_value(),\n             }\n         }\n \n-        /// Saturating integer multiplication. Computes `self * other`,\n+        /// Saturating integer multiplication. Computes `self * rhs`,\n         /// saturating at the numeric bounds instead of overflowing.\n         ///\n         /// # Examples\n@@ -1779,11 +1779,11 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n-        pub fn saturating_mul(self, other: Self) -> Self {\n-            self.checked_mul(other).unwrap_or(Self::max_value())\n+        pub fn saturating_mul(self, rhs: Self) -> Self {\n+            self.checked_mul(rhs).unwrap_or(Self::max_value())\n         }\n \n-        /// Wrapping (modular) addition. Computes `self + other`,\n+        /// Wrapping (modular) addition. Computes `self + rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n@@ -1802,7 +1802,7 @@ macro_rules! uint_impl {\n             }\n         }\n \n-        /// Wrapping (modular) subtraction. Computes `self - other`,\n+        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n         /// wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n@@ -1822,7 +1822,7 @@ macro_rules! uint_impl {\n         }\n \n         /// Wrapping (modular) multiplication. Computes `self *\n-        /// other`, wrapping around at the boundary of the type.\n+        /// rhs`, wrapping around at the boundary of the type.\n         ///\n         /// # Examples\n         ///\n@@ -1840,7 +1840,7 @@ macro_rules! uint_impl {\n             }\n         }\n \n-        /// Wrapping (modular) division. Computes `self / other`.\n+        /// Wrapping (modular) division. Computes `self / rhs`.\n         /// Wrapped division on unsigned types is just normal division.\n         /// There's no way wrapping could ever happen.\n         /// This function exists, so that all operations\n@@ -1859,7 +1859,7 @@ macro_rules! uint_impl {\n             self / rhs\n         }\n \n-        /// Wrapping (modular) remainder. Computes `self % other`.\n+        /// Wrapping (modular) remainder. Computes `self % rhs`.\n         /// Wrapped remainder calculation on unsigned types is\n         /// just the regular remainder calculation.\n         /// There's no way wrapping could ever happen."}]}