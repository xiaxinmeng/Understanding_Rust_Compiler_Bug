{"sha": "b4c88cdcecbcf40e1b9a123dcb6056970e256e9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0Yzg4Y2RjZWNiY2Y0MGUxYjlhMTIzZGNiNjA1Njk3MGUyNTZlOWI=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-02-26T06:08:52Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-29T01:56:15Z"}, "message": "add uv::loop_delete()\n\nbecause of the last change, the loop ptr is no longer cleaned up\nwhen the loop exits. This api call addresses that. Sadly, the loop\nptr is not \"reusable\" across multiple calls to uv::run().", "tree": {"sha": "6b88cfaea3f23cb9323cc9402a7729b37d7349b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b88cfaea3f23cb9323cc9402a7729b37d7349b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4c88cdcecbcf40e1b9a123dcb6056970e256e9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4c88cdcecbcf40e1b9a123dcb6056970e256e9b", "html_url": "https://github.com/rust-lang/rust/commit/b4c88cdcecbcf40e1b9a123dcb6056970e256e9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4c88cdcecbcf40e1b9a123dcb6056970e256e9b/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b3a06ab2ca989ab0f0b9fa5fa8aa83a2ec13998", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3a06ab2ca989ab0f0b9fa5fa8aa83a2ec13998", "html_url": "https://github.com/rust-lang/rust/commit/0b3a06ab2ca989ab0f0b9fa5fa8aa83a2ec13998"}], "stats": {"total": 107, "additions": 75, "deletions": 32}, "files": [{"sha": "3988bd378d2cf5c4be2d736e8adb406514f799ed", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 67, "deletions": 30, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b4c88cdcecbcf40e1b9a123dcb6056970e256e9b/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4c88cdcecbcf40e1b9a123dcb6056970e256e9b/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=b4c88cdcecbcf40e1b9a123dcb6056970e256e9b", "patch": "@@ -1,5 +1,6 @@\n-export loop_new, run, close, run_in_bg, async_init, async_send,\n-       timer_init, timer_start, timer_stop;\n+export loop_new, loop_delete, run, close, run_in_bg;\n+export async_init, async_send;\n+export timer_init, timer_start, timer_stop;\n \n // these are processed solely in the\n // process_operation() crust fn below\n@@ -44,11 +45,14 @@ type uv_loop_data = {\n     rust_loop_chan: comm::chan<uv_msg>\n };\n \n-type uv_loop = comm::chan<uv_msg>;\n+enum uv_loop {\n+    uv_loop_new(comm::chan<uv_msg>, *ctypes::void)\n+}\n \n #[nolink]\n native mod rustrt {\n     fn rust_uv_loop_new() -> *ctypes::void;\n+    fn rust_uv_loop_delete(loop: *ctypes::void);\n     fn rust_uv_loop_set_data(\n         loop: *ctypes::void,\n         data: *uv_loop_data);\n@@ -103,7 +107,8 @@ fn loop_new() -> uv_loop unsafe {\n         let rust_loop_chan =\n             comm::chan::<uv_msg>(rust_loop_port);\n         // let the task-spawner return\n-        comm::send(ret_recv_chan, copy(rust_loop_chan));\n+        let user_uv_loop = uv_loop_new(rust_loop_chan, loop_handle);\n+        comm::send(ret_recv_chan, copy(user_uv_loop));\n \n         // create our \"special\" async handle that will\n         // allow all operations against libuv to be\n@@ -225,7 +230,7 @@ fn loop_new() -> uv_loop unsafe {\n                 handles.insert(id, async_handle);\n                 let after_cb = after_cbs.get(id);\n                 after_cbs.remove(id);\n-                let async = uv_async(id, rust_loop_chan);\n+                let async = uv_async(id, user_uv_loop);\n                 id_to_handle.insert(id, copy(async));\n                 task::spawn {||\n                     after_cb(async);\n@@ -239,7 +244,8 @@ fn loop_new() -> uv_loop unsafe {\n               uv_async_send(id) {\n                 let async_cb = async_cbs.get(id);\n                 task::spawn {||\n-                    async_cb(uv_async(id, rust_loop_chan));\n+                    let the_loop = user_uv_loop;\n+                    async_cb(uv_async(id, the_loop));\n                 };\n               }\n \n@@ -254,7 +260,7 @@ fn loop_new() -> uv_loop unsafe {\n                 handles.insert(id, handle);\n                 let after_cb = after_cbs.get(id);\n                 after_cbs.remove(id);\n-                let new_timer = uv_timer(id, rust_loop_chan);\n+                let new_timer = uv_timer(id, user_uv_loop);\n                 id_to_handle.insert(id, copy(new_timer));\n                 task::spawn {||\n                     after_cb(new_timer);\n@@ -310,29 +316,38 @@ fn loop_new() -> uv_loop unsafe {\n     ret comm::recv(ret_recv_port);\n }\n \n+fn loop_delete(loop: uv_loop) {\n+    let loop_ptr = get_loop_ptr_from_uv_loop(loop);\n+    rustrt::rust_uv_loop_delete(loop_ptr);\n+}\n+\n fn run(loop: uv_loop) {\n     let end_port = comm::port::<bool>();\n     let end_chan = comm::chan::<bool>(end_port);\n-    comm::send(loop, msg_run(end_chan));\n+    let loop_chan = get_loop_chan_from_uv_loop(loop);\n+    comm::send(loop_chan, msg_run(end_chan));\n     comm::recv(end_port);\n }\n \n fn run_in_bg(loop: uv_loop) {\n-    comm::send(loop, msg_run_in_bg);\n+    let loop_chan = get_loop_chan_from_uv_loop(loop);\n+    comm::send(loop_chan, msg_run_in_bg);\n }\n \n fn async_init (\n     loop: uv_loop,\n     async_cb: fn~(uv_handle),\n     after_cb: fn~(uv_handle)) {\n     let msg = msg_async_init(async_cb, after_cb);\n-    comm::send(loop, msg);\n+    let loop_chan = get_loop_chan_from_uv_loop(loop);\n+    comm::send(loop_chan, msg);\n }\n \n fn async_send(async: uv_handle) {\n     alt async {\n       uv_async(id, loop) {\n-        comm::send(loop, msg_async_send(id));\n+        let loop_chan = get_loop_chan_from_uv_loop(loop);\n+        comm::send(loop_chan, msg_async_send(id));\n       }\n       _ {\n         fail \"attempting to call async_send() with a\" +\n@@ -348,14 +363,16 @@ fn close(h: uv_handle, cb: fn~()) {\n \n fn timer_init(loop: uv_loop, after_cb: fn~(uv_handle)) {\n     let msg = msg_timer_init(after_cb);\n-    comm::send(loop, msg);\n+    let loop_chan = get_loop_chan_from_uv_loop(loop);\n+    comm::send(loop_chan, msg);\n }\n \n fn timer_start(the_timer: uv_handle, timeout: u32, repeat:u32,\n                timer_cb: fn~(uv_handle)) {\n     alt the_timer {\n-      uv_timer(id, loop_chan) {\n+      uv_timer(id, loop) {\n         let msg = msg_timer_start(id, timeout, repeat, timer_cb);\n+        let loop_chan = get_loop_chan_from_uv_loop(loop);\n         comm::send(loop_chan, msg);\n       }\n       _ {\n@@ -367,7 +384,8 @@ fn timer_start(the_timer: uv_handle, timeout: u32, repeat:u32,\n \n fn timer_stop(the_timer: uv_handle, after_cb: fn~(uv_handle)) {\n     alt the_timer {\n-      uv_timer(id, loop_chan) {\n+      uv_timer(id, loop) {\n+        let loop_chan = get_loop_chan_from_uv_loop(loop);\n         let msg = msg_timer_stop(id, after_cb);\n         comm::send(loop_chan, msg);\n       }\n@@ -397,15 +415,16 @@ fn get_handle_id_from(buf: *u8) -> [u8] unsafe {\n }\n \n fn get_loop_chan_from_data(data: *uv_loop_data)\n-        -> uv_loop unsafe {\n+        -> comm::chan<uv_msg> unsafe {\n     ret (*data).rust_loop_chan;\n }\n \n fn get_loop_chan_from_handle(handle: uv_handle)\n-    -> uv_loop {\n+    -> comm::chan<uv_msg> {\n     alt handle {\n       uv_async(id,loop) | uv_timer(id,loop) {\n-        ret loop;\n+        let loop_chan = get_loop_chan_from_uv_loop(loop);\n+        ret loop_chan;\n       }\n       _ {\n         fail \"unknown form of uv_handle for get_loop_chan_from \"\n@@ -414,6 +433,21 @@ fn get_loop_chan_from_handle(handle: uv_handle)\n     }\n }\n \n+fn get_loop_ptr_from_uv_loop(loop: uv_loop) -> *ctypes::void {\n+    alt loop {\n+      uv_loop_new(loop_chan, loop_ptr) {\n+        ret loop_ptr;\n+      }\n+    }\n+}\n+fn get_loop_chan_from_uv_loop(loop: uv_loop) -> comm::chan<uv_msg> {\n+    alt loop {\n+      uv_loop_new(loop_chan, loop_ptr) {\n+        ret loop_chan;\n+      }\n+    }\n+}\n+\n fn get_id_from_handle(handle: uv_handle) -> [u8] {\n     alt handle {\n       uv_async(id,loop) | uv_timer(id,loop) {\n@@ -548,41 +582,44 @@ crust fn process_close_timer(\n #[test]\n fn test_uv_new_loop_no_handles() {\n     let test_loop = uv::loop_new();\n-    run(test_loop); // this should return immediately\n+    uv::run(test_loop); // this should return immediately\n                     // since there aren't any handles..\n+    uv::loop_delete(test_loop);\n }\n \n #[test]\n fn test_uv_simple_async() {\n-    let test_loop = loop_new();\n+    let test_loop = uv::loop_new();\n     let exit_port = comm::port::<bool>();\n     let exit_chan = comm::chan::<bool>(exit_port);\n-    async_init(test_loop, {|new_async|\n-        close(new_async) {||\n+    uv::async_init(test_loop, {|new_async|\n+        uv::close(new_async) {||\n             comm::send(exit_chan, true);\n         };\n     }, {|new_async|\n-        async_send(new_async);\n+        uv::async_send(new_async);\n     });\n-    run(test_loop);\n+    uv::run(test_loop);\n     let result = comm::recv(exit_port);\n     assert result;\n+    uv::loop_delete(test_loop);\n }\n \n #[test]\n fn test_uv_timer() {\n-    let test_loop = loop_new();\n+    let test_loop = uv::loop_new();\n     let exit_port = comm::port::<bool>();\n     let exit_chan = comm::chan::<bool>(exit_port);\n-    timer_init(test_loop) {|new_timer|\n-        timer_start(new_timer, 1u32, 0u32) {|started_timer|\n-            timer_stop(started_timer) {|stopped_timer|\n-                close(stopped_timer) {||\n+    uv::timer_init(test_loop) {|new_timer|\n+        uv::timer_start(new_timer, 1u32, 0u32) {|started_timer|\n+            uv::timer_stop(started_timer) {|stopped_timer|\n+                uv::close(stopped_timer) {||\n                     comm::send(exit_chan, true);\n                 };\n             };\n         };\n     };\n-    run(test_loop);\n+    uv::run(test_loop);\n     assert comm::recv(exit_port);\n-}\n\\ No newline at end of file\n+    uv::loop_delete(test_loop);\n+}"}, {"sha": "096d40d22356092e251d223cf9252f9fc96c27de", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b4c88cdcecbcf40e1b9a123dcb6056970e256e9b/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b4c88cdcecbcf40e1b9a123dcb6056970e256e9b/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=b4c88cdcecbcf40e1b9a123dcb6056970e256e9b", "patch": "@@ -2,7 +2,8 @@\n #include \"uv.h\"\n \n // crust fn pointers\n-typedef void (*crust_async_op_cb)(uv_loop_t* loop, void* data);\n+typedef void (*crust_async_op_cb)(uv_loop_t* loop, void* data,\n+\t\t\t\t\t\t\t\t  uv_async_t* op_handle);\n typedef void (*crust_simple_cb)(uint8_t* id_buf, void* loop_data);\n typedef void (*crust_close_cb)(uint8_t* id_buf, void* handle,\n \t\t\t\t\t\t\t  void* data);\n@@ -43,7 +44,7 @@ static void\n native_crust_async_op_cb(uv_async_t* handle, int status) {\n     crust_async_op_cb cb = (crust_async_op_cb)handle->data;\n \tvoid* loop_data = handle->loop->data;\n-\tcb(handle->loop, loop_data);\n+\tcb(handle->loop, loop_data, handle);\n }\n \n static void\n@@ -78,6 +79,11 @@ rust_uv_loop_new() {\n     return (void*)uv_loop_new();\n }\n \n+extern \"C\" void\n+rust_uv_loop_delete(uv_loop_t* loop) {\n+    uv_loop_delete(loop);\n+}\n+\n extern \"C\" void\n rust_uv_loop_set_data(uv_loop_t* loop, void* data) {\n     loop->data = data;"}]}