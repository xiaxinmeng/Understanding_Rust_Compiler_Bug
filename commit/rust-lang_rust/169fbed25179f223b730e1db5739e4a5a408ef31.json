{"sha": "169fbed25179f223b730e1db5739e4a5a408ef31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2OWZiZWQyNTE3OWYyMjNiNzMwZTFkYjU3MzllNGE1YTQwOGVmMzE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T18:25:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T19:59:26Z"}, "message": "std: Revert stability of Entry-based APIs\n\nThere's been some debate over the precise form that these APIs should take, and\nthey've undergone some changes recently, so these APIs are going to be left\nunstable for now to be fleshed out during the next release cycle.", "tree": {"sha": "ede3c70a0485ced148af0d29ef181e0ed11e0373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ede3c70a0485ced148af0d29ef181e0ed11e0373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/169fbed25179f223b730e1db5739e4a5a408ef31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/169fbed25179f223b730e1db5739e4a5a408ef31", "html_url": "https://github.com/rust-lang/rust/commit/169fbed25179f223b730e1db5739e4a5a408ef31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/169fbed25179f223b730e1db5739e4a5a408ef31/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "url": "https://api.github.com/repos/rust-lang/rust/commits/25eada15740fbe12ee2cae7fc6fe8e2c228b699d", "html_url": "https://github.com/rust-lang/rust/commit/25eada15740fbe12ee2cae7fc6fe8e2c228b699d"}], "stats": {"total": 38, "additions": 17, "deletions": 21}, "files": [{"sha": "0a0bb5b876574e9fc797004849d7a1f1c01a533a", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/169fbed25179f223b730e1db5739e4a5a408ef31/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169fbed25179f223b730e1db5739e4a5a408ef31/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=169fbed25179f223b730e1db5739e4a5a408ef31", "patch": "@@ -128,24 +128,24 @@ pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n-#[stable]\n /// A view into a single entry in a map, which may either be vacant or occupied.\n+#[unstable = \"precise API still under development\"]\n pub enum Entry<'a, K:'a, V:'a> {\n     /// A vacant Entry\n     Vacant(VacantEntry<'a, K, V>),\n     /// An occupied Entry\n     Occupied(OccupiedEntry<'a, K, V>),\n }\n \n-#[stable]\n /// A vacant Entry.\n+#[unstable = \"precise API still under development\"]\n pub struct VacantEntry<'a, K:'a, V:'a> {\n     key: K,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n \n-#[stable]\n /// An occupied Entry.\n+#[unstable = \"precise API still under development\"]\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n     stack: stack::SearchStack<'a, K, V, node::handle::KV, node::handle::LeafOrInternal>,\n }\n@@ -1123,43 +1123,43 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n }\n \n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n-    #[stable]\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn insert(self, value: V) -> &'a mut V {\n         self.stack.insert(self.key, value)\n     }\n }\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n-    #[stable]\n     /// Gets a reference to the value in the entry.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn get(&self) -> &V {\n         self.stack.peek()\n     }\n \n-    #[stable]\n     /// Gets a mutable reference to the value in the entry.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.stack.peek_mut()\n     }\n \n-    #[stable]\n     /// Converts the entry into a mutable reference to its value.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn into_mut(self) -> &'a mut V {\n         self.stack.into_top()\n     }\n \n-    #[stable]\n     /// Sets the value of the entry with the OccupiedEntry's key,\n     /// and returns the entry's old value.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn insert(&mut self, mut value: V) -> V {\n         mem::swap(self.stack.peek_mut(), &mut value);\n         value\n     }\n \n-    #[stable]\n     /// Takes the value of the entry out of the map, and returns it.\n+    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     pub fn remove(self) -> V {\n         self.stack.remove()\n     }\n@@ -1361,7 +1361,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(count[\"a\"], 3u);\n     /// ```\n     /// The key must have the same ordering before or after `.to_owned()` is called.\n-    #[stable]\n+    #[unstable = \"precise API still under development\"]\n     pub fn entry<'a>(&'a mut self, mut key: K) -> Entry<'a, K, V> {\n         // same basic logic of `swap` and `pop`, blended together\n         let mut stack = stack::PartialSearchStack::new(self);"}, {"sha": "a01158fb1ed2759080e6a9945b626f8ed94eb7a4", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/169fbed25179f223b730e1db5739e4a5a408ef31/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169fbed25179f223b730e1db5739e4a5a408ef31/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=169fbed25179f223b730e1db5739e4a5a408ef31", "patch": "@@ -920,8 +920,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    #[stable]\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    #[unstable = \"precise API still being fleshed out\"]\n     pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V>\n     {\n         // Gotta resize now.\n@@ -1320,22 +1320,22 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n     >\n }\n \n-#[stable]\n /// A view into a single occupied location in a HashMap\n+#[unstable = \"precise API still being fleshed out\"]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n \n-#[stable]\n /// A view into a single empty location in a HashMap\n+#[unstable = \"precise API still being fleshed out\"]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n     key: K,\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n-#[stable]\n /// A view into a single location in a map, which may be vacant or occupied\n+#[unstable = \"precise API still being fleshed out\"]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied Entry\n     Occupied(OccupiedEntry<'a, K, V>),\n@@ -1406,8 +1406,8 @@ impl<'a, K: 'a, V: 'a> Iterator for Drain<'a, K, V> {\n     }\n }\n \n+#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n impl<'a, K, V> Entry<'a, K, V> {\n-    #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n         match self {\n@@ -1417,43 +1417,39 @@ impl<'a, K, V> Entry<'a, K, V> {\n     }\n }\n \n+#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n-    #[stable]\n     /// Gets a reference to the value in the entry\n     pub fn get(&self) -> &V {\n         self.elem.read().1\n     }\n \n-    #[stable]\n     /// Gets a mutable reference to the value in the entry\n     pub fn get_mut(&mut self) -> &mut V {\n         self.elem.read_mut().1\n     }\n \n-    #[stable]\n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n     /// with a lifetime bound to the map itself\n     pub fn into_mut(self) -> &'a mut V {\n         self.elem.into_mut_refs().1\n     }\n \n-    #[stable]\n     /// Sets the value of the entry, and returns the entry's old value\n     pub fn insert(&mut self, mut value: V) -> V {\n         let old_value = self.get_mut();\n         mem::swap(&mut value, old_value);\n         value\n     }\n \n-    #[stable]\n     /// Takes the value out of the entry, and returns it\n     pub fn remove(self) -> V {\n         pop_internal(self.elem).1\n     }\n }\n \n+#[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n-    #[stable]\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it\n     pub fn insert(self, value: V) -> &'a mut V {"}]}