{"sha": "46d1ee72ac0292adb3db66de23216b57a40a52b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZDFlZTcyYWMwMjkyYWRiM2RiNjZkZTIzMjE2YjU3YTQwYTUyYjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-03T03:06:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-03T03:06:12Z"}, "message": "auto merge of #16191 : DaGenix/rust/fix-aligned-access, r=alexcrichton\n\nWhen I originally wrote the read_u32v_be() and write_u32_be() functions, I didn't consider memory alignment requirements of various architectures. Unfortunately, the current implementations may result in unaligned reads and writes. This doesn't impact x86 / x86_64, but it can cause a compiler crash on ARM. This pull requests rewrites those functions to make sure that all memory access is always correctly aligned.\r\n\r\nThis fix is a little bit academic - due to the way that LLVM aligns the structures that are passed as arguments to these functions, I believe that the end result is that all memory access happens to be aligned anyway. However, there is nothing in that code that actually enforces that, at least not explicitly. The new implementations are definitely slower than the existing ones. However, I don't believe that these functions are all that significant when looking at the overall performance of the compiler. I think getting rid of some unsafe code and removing a potential portability landmine justifies a very slight decrease in raw performance.", "tree": {"sha": "6af501d5c1c76395556c269f3a2ffffe195b4f04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6af501d5c1c76395556c269f3a2ffffe195b4f04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46d1ee72ac0292adb3db66de23216b57a40a52b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46d1ee72ac0292adb3db66de23216b57a40a52b2", "html_url": "https://github.com/rust-lang/rust/commit/46d1ee72ac0292adb3db66de23216b57a40a52b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46d1ee72ac0292adb3db66de23216b57a40a52b2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12306da80ca4b881d784d6590f7d3fee36cf97ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/12306da80ca4b881d784d6590f7d3fee36cf97ac", "html_url": "https://github.com/rust-lang/rust/commit/12306da80ca4b881d784d6590f7d3fee36cf97ac"}, {"sha": "fd69365ead71e6ee0ca2990a926a163df5076f2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd69365ead71e6ee0ca2990a926a163df5076f2d", "html_url": "https://github.com/rust-lang/rust/commit/fd69365ead71e6ee0ca2990a926a163df5076f2d"}], "stats": {"total": 32, "additions": 17, "deletions": 15}, "files": [{"sha": "d24ff49c61558c0a8ca76a0982508c9c550c55d7", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/46d1ee72ac0292adb3db66de23216b57a40a52b2/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46d1ee72ac0292adb3db66de23216b57a40a52b2/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=46d1ee72ac0292adb3db66de23216b57a40a52b2", "patch": "@@ -22,26 +22,28 @@ use serialize::hex::ToHex;\n /// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n /// format.\n fn write_u32_be(dst: &mut[u8], input: u32) {\n-    use std::mem::to_be32;\n-    assert!(dst.len() == 4);\n-    unsafe {\n-        let x = dst.unsafe_mut_ref(0) as *mut _ as *mut u32;\n-        *x = to_be32(input);\n-    }\n+    dst[0] = (input >> 24) as u8;\n+    dst[1] = (input >> 16) as u8;\n+    dst[2] = (input >> 8) as u8;\n+    dst[3] = input as u8;\n+}\n+\n+/// Read the value of a vector of bytes as a u32 value in big-endian format.\n+fn read_u32_be(input: &[u8]) -> u32 {\n+    return\n+        (input[0] as u32) << 24 |\n+        (input[1] as u32) << 16 |\n+        (input[2] as u32) << 8 |\n+        (input[3] as u32);\n }\n \n /// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n-    use std::mem::to_be32;\n     assert!(dst.len() * 4 == input.len());\n-    unsafe {\n-        let mut x = dst.unsafe_mut_ref(0) as *mut _ as *mut u32;\n-        let mut y = input.unsafe_ref(0) as *const _ as *const u32;\n-        for _ in range(0, dst.len()) {\n-            *x = to_be32(*y);\n-            x = x.offset(1);\n-            y = y.offset(1);\n-        }\n+    let mut pos = 0u;\n+    for chunk in input.chunks(4) {\n+        dst[pos] = read_u32_be(chunk);\n+        pos += 1;\n     }\n }\n "}]}