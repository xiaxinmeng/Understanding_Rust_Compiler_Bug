{"sha": "9041d81f7880d1dbd2beee601cbc46d2889f31e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwNDFkODFmNzg4MGQxZGJkMmJlZWU2MDFjYmM0NmQyODg5ZjMxZTY=", "commit": {"author": {"name": "iancormac84", "email": "wilnathan@gmail.com", "date": "2018-05-08T13:38:29Z"}, "committer": {"name": "iancormac84", "email": "wilnathan@gmail.com", "date": "2018-05-17T20:41:29Z"}, "message": "Code structure edits.", "tree": {"sha": "7772d4695705bf71805a1e40cd142b2a7fe8c117", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7772d4695705bf71805a1e40cd142b2a7fe8c117"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9041d81f7880d1dbd2beee601cbc46d2889f31e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9041d81f7880d1dbd2beee601cbc46d2889f31e6", "html_url": "https://github.com/rust-lang/rust/commit/9041d81f7880d1dbd2beee601cbc46d2889f31e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9041d81f7880d1dbd2beee601cbc46d2889f31e6/comments", "author": {"login": "iancormac84", "id": 7167225, "node_id": "MDQ6VXNlcjcxNjcyMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/7167225?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iancormac84", "html_url": "https://github.com/iancormac84", "followers_url": "https://api.github.com/users/iancormac84/followers", "following_url": "https://api.github.com/users/iancormac84/following{/other_user}", "gists_url": "https://api.github.com/users/iancormac84/gists{/gist_id}", "starred_url": "https://api.github.com/users/iancormac84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iancormac84/subscriptions", "organizations_url": "https://api.github.com/users/iancormac84/orgs", "repos_url": "https://api.github.com/users/iancormac84/repos", "events_url": "https://api.github.com/users/iancormac84/events{/privacy}", "received_events_url": "https://api.github.com/users/iancormac84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iancormac84", "id": 7167225, "node_id": "MDQ6VXNlcjcxNjcyMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/7167225?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iancormac84", "html_url": "https://github.com/iancormac84", "followers_url": "https://api.github.com/users/iancormac84/followers", "following_url": "https://api.github.com/users/iancormac84/following{/other_user}", "gists_url": "https://api.github.com/users/iancormac84/gists{/gist_id}", "starred_url": "https://api.github.com/users/iancormac84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iancormac84/subscriptions", "organizations_url": "https://api.github.com/users/iancormac84/orgs", "repos_url": "https://api.github.com/users/iancormac84/repos", "events_url": "https://api.github.com/users/iancormac84/events{/privacy}", "received_events_url": "https://api.github.com/users/iancormac84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "659f164167221ccd9a686dab4fe22bddca471606", "url": "https://api.github.com/repos/rust-lang/rust/commits/659f164167221ccd9a686dab4fe22bddca471606", "html_url": "https://github.com/rust-lang/rust/commit/659f164167221ccd9a686dab4fe22bddca471606"}], "stats": {"total": 118, "additions": 61, "deletions": 57}, "files": [{"sha": "8ddefdf474fb1134de3faa9adbea378244e87ddf", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 61, "deletions": 57, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/9041d81f7880d1dbd2beee601cbc46d2889f31e6/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9041d81f7880d1dbd2beee601cbc46d2889f31e6/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=9041d81f7880d1dbd2beee601cbc46d2889f31e6", "patch": "@@ -97,19 +97,19 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use rustc::middle::weak_lang_items;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_mir::monomorphize::Instance;\n-use rustc_mir::monomorphize::item::{MonoItem, MonoItemExt, InstantiationMode};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map as hir_map;\n+use rustc::hir::map::definitions::DefPathData;\n use rustc::ich::NodeIdHashingMode;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::middle::weak_lang_items;\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::ty::maps::Providers;\n use rustc::ty::subst::Substs;\n-use rustc::hir::map::definitions::DefPathData;\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::record_time;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_mir::monomorphize::item::{InstantiationMode, MonoItem, MonoItemExt};\n+use rustc_mir::monomorphize::Instance;\n \n use syntax::attr;\n use syntax_pos::symbol::Symbol;\n@@ -125,25 +125,29 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn get_symbol_hash<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n-                             // the DefId of the item this name is for\n-                             def_id: DefId,\n+    // the DefId of the item this name is for\n+    def_id: DefId,\n \n-                             // instance this name will be for\n-                             instance: Instance<'tcx>,\n+    // instance this name will be for\n+    instance: Instance<'tcx>,\n \n-                             // type of the item, without any generic\n-                             // parameters substituted; this is\n-                             // included in the hash as a kind of\n-                             // safeguard.\n-                             item_type: Ty<'tcx>,\n+    // type of the item, without any generic\n+    // parameters substituted; this is\n+    // included in the hash as a kind of\n+    // safeguard.\n+    item_type: Ty<'tcx>,\n \n-                             // values for generic type parameters,\n-                             // if any.\n-                             substs: &'tcx Substs<'tcx>)\n-                             -> u64 {\n-    debug!(\"get_symbol_hash(def_id={:?}, parameters={:?})\", def_id, substs);\n+    // values for generic type parameters,\n+    // if any.\n+    substs: &'tcx Substs<'tcx>,\n+) -> u64 {\n+    debug!(\n+        \"get_symbol_hash(def_id={:?}, parameters={:?})\",\n+        def_id, substs\n+    );\n \n     let mut hasher = StableHasher::<u64>::new();\n     let mut hcx = tcx.create_stable_hashing_context();\n@@ -193,20 +197,20 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 if !def_id.is_local() && tcx.share_generics() {\n                     // If we are re-using a monomorphization from another crate,\n                     // we have to compute the symbol hash accordingly.\n-                    let upstream_monomorphizations =\n-                        tcx.upstream_monomorphizations_for(def_id);\n+                    let upstream_monomorphizations = tcx.upstream_monomorphizations_for(def_id);\n \n-                    upstream_monomorphizations.and_then(|monos| monos.get(&substs)\n-                                                                     .cloned())\n-                                              .unwrap_or(LOCAL_CRATE)\n+                    upstream_monomorphizations\n+                        .and_then(|monos| monos.get(&substs).cloned())\n+                        .unwrap_or(LOCAL_CRATE)\n                 } else {\n                     LOCAL_CRATE\n                 }\n             } else {\n                 LOCAL_CRATE\n             };\n \n-            (&tcx.original_crate_name(instantiating_crate).as_str()[..]).hash_stable(&mut hcx, &mut hasher);\n+            (&tcx.original_crate_name(instantiating_crate).as_str()[..])\n+                .hash_stable(&mut hcx, &mut hasher);\n             (&tcx.crate_disambiguator(instantiating_crate)).hash_stable(&mut hcx, &mut hasher);\n         }\n     });\n@@ -215,30 +219,25 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     hasher.finish()\n }\n \n-fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                             -> ty::SymbolName\n-{\n+fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n     let mut buffer = SymbolPathBuffer::new();\n     item_path::with_forced_absolute_paths(|| {\n         tcx.push_item_path(&mut buffer, def_id);\n     });\n     buffer.into_interned()\n }\n \n-fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>)\n-                         -> ty::SymbolName\n-{\n-    ty::SymbolName { name: Symbol::intern(&compute_symbol_name(tcx, instance)).as_interned_str() }\n+fn symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n+    ty::SymbolName {\n+        name: Symbol::intern(&compute_symbol_name(tcx, instance)).as_interned_str(),\n+    }\n }\n \n-fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>)\n-    -> String\n-{\n+fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance<'tcx>) -> String {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n-    debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n-           def_id, substs);\n+    debug!(\"symbol_name(def_id={:?}, substs={:?})\", def_id, substs);\n \n     let node_id = tcx.hir.as_local_node_id(def_id);\n \n@@ -258,7 +257,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     let is_foreign = if let Some(id) = node_id {\n         match tcx.hir.get(id) {\n             hir_map::NodeForeignItem(_) => true,\n-            _ => false\n+            _ => false,\n         }\n     } else {\n         tcx.is_foreign_item(def_id)\n@@ -295,8 +294,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     loop {\n         let key = tcx.def_key(ty_def_id);\n         match key.disambiguated_data.data {\n-            DefPathData::TypeNs(_) |\n-            DefPathData::ValueNs(_) => {\n+            DefPathData::TypeNs(_) | DefPathData::ValueNs(_) => {\n                 instance_ty = tcx.type_of(ty_def_id);\n                 break;\n             }\n@@ -305,8 +303,12 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n                 // to be a value or type-def or something in there\n                 // *somewhere*\n                 ty_def_id.index = key.parent.unwrap_or_else(|| {\n-                    bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                          parent\", def_id, ty_def_id);\n+                    bug!(\n+                        \"finding type for {:?}, encountered def-id {:?} with no \\\n+                         parent\",\n+                        def_id,\n+                        ty_def_id\n+                    );\n                 });\n             }\n         }\n@@ -336,14 +338,14 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n // use C++ name-mangling.\n struct SymbolPathBuffer {\n     result: String,\n-    temp_buf: String\n+    temp_buf: String,\n }\n \n impl SymbolPathBuffer {\n     fn new() -> Self {\n         let mut result = SymbolPathBuffer {\n             result: String::with_capacity(64),\n-            temp_buf: String::with_capacity(16)\n+            temp_buf: String::with_capacity(16),\n         };\n         result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n         result\n@@ -352,14 +354,16 @@ impl SymbolPathBuffer {\n     fn from_interned(symbol: ty::SymbolName) -> Self {\n         let mut result = SymbolPathBuffer {\n             result: String::with_capacity(64),\n-            temp_buf: String::with_capacity(16)\n+            temp_buf: String::with_capacity(16),\n         };\n         result.result.push_str(&symbol.name.as_str());\n         result\n     }\n \n     fn into_interned(self) -> ty::SymbolName {\n-        ty::SymbolName { name: Symbol::intern(&self.result).as_interned_str() }\n+        ty::SymbolName {\n+            name: Symbol::intern(&self.result).as_interned_str(),\n+        }\n     }\n \n     fn finish(mut self, hash: u64) -> String {\n@@ -378,7 +382,11 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     fn push(&mut self, text: &str) {\n         self.temp_buf.clear();\n         let need_underscore = sanitize(&mut self.temp_buf, text);\n-        let _ = write!(self.result, \"{}\", self.temp_buf.len() + (need_underscore as usize));\n+        let _ = write!(\n+            self.result,\n+            \"{}\",\n+            self.temp_buf.len() + (need_underscore as usize)\n+        );\n         if need_underscore {\n             self.result.push('_');\n         }\n@@ -409,16 +417,13 @@ pub fn sanitize(result: &mut String, s: &str) -> bool {\n             '-' | ':' => result.push('.'),\n \n             // These are legal symbols\n-            'a' ... 'z'\n-            | 'A' ... 'Z'\n-            | '0' ... '9'\n-            | '_' | '.' | '$' => result.push(c),\n+            'a'...'z' | 'A'...'Z' | '0'...'9' | '_' | '.' | '$' => result.push(c),\n \n             _ => {\n                 result.push('$');\n                 for c in c.escape_unicode().skip(1) {\n                     match c {\n-                        '{' => {},\n+                        '{' => {}\n                         '}' => result.push('$'),\n                         c => result.push(c),\n                     }\n@@ -428,7 +433,6 @@ pub fn sanitize(result: &mut String, s: &str) -> bool {\n     }\n \n     // Underscore-qualify anything that didn't start as an ident.\n-    !result.is_empty() &&\n-        result.as_bytes()[0] != '_' as u8 &&\n-        ! (result.as_bytes()[0] as char).is_xid_start()\n+    !result.is_empty() && result.as_bytes()[0] != '_' as u8\n+        && !(result.as_bytes()[0] as char).is_xid_start()\n }"}]}