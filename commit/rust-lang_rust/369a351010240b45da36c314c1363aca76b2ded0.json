{"sha": "369a351010240b45da36c314c1363aca76b2ded0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2OWEzNTEwMTAyNDBiNDVkYTM2YzMxNGMxMzYzYWNhNzZiMmRlZDA=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-07T12:04:19Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-10T10:05:16Z"}, "message": "Inline constructor_sub_pattern_tys\n\nIt was only used at a single location", "tree": {"sha": "5b2a9e679b66e899bdeb869f20f82ed3c7b6b49e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b2a9e679b66e899bdeb869f20f82ed3c7b6b49e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/369a351010240b45da36c314c1363aca76b2ded0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/369a351010240b45da36c314c1363aca76b2ded0", "html_url": "https://github.com/rust-lang/rust/commit/369a351010240b45da36c314c1363aca76b2ded0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/369a351010240b45da36c314c1363aca76b2ded0/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "098974dadd73902d6169e36eb1f57f48ce926b32", "url": "https://api.github.com/repos/rust-lang/rust/commits/098974dadd73902d6169e36eb1f57f48ce926b32", "html_url": "https://github.com/rust-lang/rust/commit/098974dadd73902d6169e36eb1f57f48ce926b32"}], "stats": {"total": 130, "additions": 63, "deletions": 67}, "files": [{"sha": "a494a5a95b752a0ececb313ad13d5c6021dc987c", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 63, "deletions": 67, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/369a351010240b45da36c314c1363aca76b2ded0/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/369a351010240b45da36c314c1363aca76b2ded0/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=369a351010240b45da36c314c1363aca76b2ded0", "patch": "@@ -779,8 +779,67 @@ impl<'tcx> Constructor<'tcx> {\n         &self,\n         cx: &MatchCheckCtxt<'a, 'tcx>,\n         ty: Ty<'tcx>,\n-    ) -> impl Iterator<Item = Pat<'tcx>> + DoubleEndedIterator {\n-        constructor_sub_pattern_tys(cx, self, ty).into_iter().map(Pat::wildcard_from_ty)\n+    ) -> Vec<Pat<'tcx>> {\n+        debug!(\"wildcard_subpatterns({:#?}, {:?})\", self, ty);\n+        match ty.kind {\n+            ty::Tuple(ref fs) => {\n+                fs.into_iter().map(|t| t.expect_ty()).map(Pat::wildcard_from_ty).collect()\n+            }\n+            ty::Slice(ty) | ty::Array(ty, _) => match *self {\n+                FixedLenSlice(length) => (0..length).map(|_| Pat::wildcard_from_ty(ty)).collect(),\n+                VarLenSlice(prefix, suffix) => {\n+                    (0..prefix + suffix).map(|_| Pat::wildcard_from_ty(ty)).collect()\n+                }\n+                ConstantValue(..) => vec![],\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n+            },\n+            ty::Ref(_, rty, _) => vec![Pat::wildcard_from_ty(rty)],\n+            ty::Adt(adt, substs) => {\n+                if adt.is_box() {\n+                    // Use T as the sub pattern type of Box<T>.\n+                    vec![Pat::wildcard_from_ty(substs.type_at(0))]\n+                } else {\n+                    let variant = &adt.variants[self.variant_index_for_adt(cx, adt)];\n+                    let is_non_exhaustive =\n+                        variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n+                    variant\n+                        .fields\n+                        .iter()\n+                        .map(|field| {\n+                            let is_visible =\n+                                adt.is_enum() || field.vis.is_accessible_from(cx.module, cx.tcx);\n+                            let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n+                            match (is_visible, is_non_exhaustive, is_uninhabited) {\n+                                // Treat all uninhabited types in non-exhaustive variants as `TyErr`.\n+                                (_, true, true) => cx.tcx.types.err,\n+                                // Treat all non-visible fields as `TyErr`. They can't appear in any\n+                                // other pattern from this match (because they are private), so their\n+                                // type does not matter - but we don't want to know they are\n+                                // uninhabited.\n+                                (false, ..) => cx.tcx.types.err,\n+                                (true, ..) => {\n+                                    let ty = field.ty(cx.tcx, substs);\n+                                    match ty.kind {\n+                                        // If the field type returned is an array of an unknown size\n+                                        // return an TyErr.\n+                                        ty::Array(_, len)\n+                                            if len\n+                                                .try_eval_usize(cx.tcx, cx.param_env)\n+                                                .is_none() =>\n+                                        {\n+                                            cx.tcx.types.err\n+                                        }\n+                                        _ => ty,\n+                                    }\n+                                }\n+                            }\n+                        })\n+                        .map(Pat::wildcard_from_ty)\n+                        .collect()\n+                }\n+            }\n+            _ => vec![],\n+        }\n     }\n \n     /// This computes the arity of a constructor. The arity of a constructor\n@@ -880,7 +939,7 @@ impl<'tcx> Constructor<'tcx> {\n \n     /// Like `apply`, but where all the subpatterns are wildcards `_`.\n     fn apply_wildcards<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Pat<'tcx> {\n-        let subpatterns = self.wildcard_subpatterns(cx, ty).rev();\n+        let subpatterns = self.wildcard_subpatterns(cx, ty).into_iter().rev();\n         self.apply(cx, ty, subpatterns)\n     }\n }\n@@ -1659,7 +1718,7 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n ) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n \n-    let ctor_wild_subpatterns_owned: Vec<_> = ctor.wildcard_subpatterns(cx, lty).collect();\n+    let ctor_wild_subpatterns_owned: Vec<_> = ctor.wildcard_subpatterns(cx, lty);\n     let ctor_wild_subpatterns: Vec<_> = ctor_wild_subpatterns_owned.iter().collect();\n     let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n     v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n@@ -1709,69 +1768,6 @@ fn pat_constructor<'tcx>(\n     }\n }\n \n-/// This computes the types of the sub patterns that a constructor should be\n-/// expanded to.\n-///\n-/// For instance, a tuple pattern (43u32, 'a') has sub pattern types [u32, char].\n-fn constructor_sub_pattern_tys<'a, 'tcx>(\n-    cx: &MatchCheckCtxt<'a, 'tcx>,\n-    ctor: &Constructor<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Vec<Ty<'tcx>> {\n-    debug!(\"constructor_sub_pattern_tys({:#?}, {:?})\", ctor, ty);\n-    match ty.kind {\n-        ty::Tuple(ref fs) => fs.into_iter().map(|t| t.expect_ty()).collect(),\n-        ty::Slice(ty) | ty::Array(ty, _) => match *ctor {\n-            FixedLenSlice(length) => (0..length).map(|_| ty).collect(),\n-            VarLenSlice(prefix, suffix) => (0..prefix + suffix).map(|_| ty).collect(),\n-            ConstantValue(..) => vec![],\n-            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty),\n-        },\n-        ty::Ref(_, rty, _) => vec![rty],\n-        ty::Adt(adt, substs) => {\n-            if adt.is_box() {\n-                // Use T as the sub pattern type of Box<T>.\n-                vec![substs.type_at(0)]\n-            } else {\n-                let variant = &adt.variants[ctor.variant_index_for_adt(cx, adt)];\n-                let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n-                variant\n-                    .fields\n-                    .iter()\n-                    .map(|field| {\n-                        let is_visible =\n-                            adt.is_enum() || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                        let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n-                        match (is_visible, is_non_exhaustive, is_uninhabited) {\n-                            // Treat all uninhabited types in non-exhaustive variants as `TyErr`.\n-                            (_, true, true) => cx.tcx.types.err,\n-                            // Treat all non-visible fields as `TyErr`. They can't appear in any\n-                            // other pattern from this match (because they are private), so their\n-                            // type does not matter - but we don't want to know they are\n-                            // uninhabited.\n-                            (false, ..) => cx.tcx.types.err,\n-                            (true, ..) => {\n-                                let ty = field.ty(cx.tcx, substs);\n-                                match ty.kind {\n-                                    // If the field type returned is an array of an unknown size\n-                                    // return an TyErr.\n-                                    ty::Array(_, len)\n-                                        if len.try_eval_usize(cx.tcx, cx.param_env).is_none() =>\n-                                    {\n-                                        cx.tcx.types.err\n-                                    }\n-                                    _ => ty,\n-                                }\n-                            }\n-                        }\n-                    })\n-                    .collect()\n-            }\n-        }\n-        _ => vec![],\n-    }\n-}\n-\n // checks whether a constant is equal to a user-written slice pattern. Only supports byte slices,\n // meaning all other types will compare unequal and thus equal patterns often do not cause the\n // second pattern to lint about unreachable match arms."}]}