{"sha": "90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwY2JlMGNhZDIwZDI3MzZjN2U3ZWJiZmZiMmMyZDg0MDE2ZjkzNDA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-09T14:54:34Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-17T07:53:07Z"}, "message": "De-@ ParseSess uses.", "tree": {"sha": "a0bee02f6e23b5b27a4606fbed7b32cd631b3e58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0bee02f6e23b5b27a4606fbed7b32cd631b3e58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "html_url": "https://github.com/rust-lang/rust/commit/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "555a239301cabeb20e45c9c3c3cf98588b8ec916", "url": "https://api.github.com/repos/rust-lang/rust/commits/555a239301cabeb20e45c9c3c3cf98588b8ec916", "html_url": "https://github.com/rust-lang/rust/commit/555a239301cabeb20e45c9c3c3cf98588b8ec916"}], "stats": {"total": 199, "additions": 90, "deletions": 109}, "files": [{"sha": "a4c99979b9bfd8dcaaeefca3c0b91b5616c2c18e", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -146,11 +146,10 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n fn parse_cfgspecs(cfgspecs: Vec<~str> )\n                   -> ast::CrateConfig {\n     cfgspecs.move_iter().map(|s| {\n-        let sess = parse::new_parse_sess();\n         parse::parse_meta_from_source_str(\"cfgspec\".to_str(),\n                                           s,\n                                           Vec::new(),\n-                                          sess)\n+                                          &parse::new_parse_sess())\n     }).collect::<ast::CrateConfig>()\n }\n \n@@ -175,13 +174,13 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n     let krate = time(sess.time_passes(), \"parsing\", (), |_| {\n         match *input {\n             FileInput(ref file) => {\n-                parse::parse_crate_from_file(&(*file), cfg.clone(), sess.parse_sess)\n+                parse::parse_crate_from_file(&(*file), cfg.clone(), &sess.parse_sess)\n             }\n             StrInput(ref src) => {\n                 parse::parse_crate_from_source_str(anon_src(),\n                                                    (*src).clone(),\n                                                    cfg.clone(),\n-                                                   sess.parse_sess)\n+                                                   &sess.parse_sess)\n             }\n         }\n     });\n@@ -241,7 +240,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             deriving_hash_type_parameter: sess.features.default_type_params.get(),\n             crate_id: crate_id.clone(),\n         };\n-        syntax::ext::expand::expand_crate(sess.parse_sess,\n+        syntax::ext::expand::expand_crate(&sess.parse_sess,\n                                           cfg,\n                                           krate)\n     });"}, {"sha": "acc92221539ce9322eb44c6139e9adf8643ec4ee", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -177,7 +177,7 @@ pub struct Session {\n     targ_cfg: @Config,\n     opts: @Options,\n     cstore: metadata::cstore::CStore,\n-    parse_sess: @ParseSess,\n+    parse_sess: ParseSess,\n     codemap: @codemap::CodeMap,\n     // For a library crate, this is always none\n     entry_fn: RefCell<Option<(NodeId, codemap::Span)>>,"}, {"sha": "cf5373fd17de7918a308eb5f0222569dc17de2ea", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -166,7 +166,7 @@ fn generate_test_harness(sess: &Session, krate: ast::Crate)\n     let loader = &mut Loader::new(sess);\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n-        ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone(),\n+        ext_cx: ExtCtxt::new(&sess.parse_sess, sess.opts.cfg.clone(),\n                              ExpansionConfig {\n                                  loader: loader,\n                                  deriving_hash_type_parameter: false,"}, {"sha": "4383f3f5933cb4a49980808f2d9850950d285d45", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -350,13 +350,13 @@ fn parse_crate_attrs(sess: &session::Session, input: &d::Input) ->\n         d::FileInput(ref ifile) => {\n             parse::parse_crate_attrs_from_file(ifile,\n                                                Vec::new(),\n-                                               sess.parse_sess)\n+                                               &sess.parse_sess)\n         }\n         d::StrInput(ref src) => {\n             parse::parse_crate_attrs_from_source_str(d::anon_src(),\n                                                      (*src).clone(),\n                                                      Vec::new(),\n-                                                     sess.parse_sess)\n+                                                     &sess.parse_sess)\n         }\n     };\n     result.move_iter().collect()"}, {"sha": "834e995756ec59257ffe0c5f5e6062bc1a3436c5", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -1446,17 +1446,17 @@ fn decode_item_ast(par_doc: ebml::Doc) -> @ast::Item {\n #[cfg(test)]\n trait fake_ext_ctxt {\n     fn cfg(&self) -> ast::CrateConfig;\n-    fn parse_sess(&self) -> @parse::ParseSess;\n+    fn parse_sess<'a>(&'a self) -> &'a parse::ParseSess;\n     fn call_site(&self) -> Span;\n     fn ident_of(&self, st: &str) -> ast::Ident;\n }\n \n #[cfg(test)]\n-impl fake_ext_ctxt for @parse::ParseSess {\n+impl fake_ext_ctxt for parse::ParseSess {\n     fn cfg(&self) -> ast::CrateConfig {\n         Vec::new()\n     }\n-    fn parse_sess(&self) -> @parse::ParseSess { *self }\n+    fn parse_sess<'a>(&'a self) -> &'a parse::ParseSess { self }\n     fn call_site(&self) -> Span {\n         codemap::Span {\n             lo: codemap::BytePos(0),\n@@ -1470,7 +1470,7 @@ impl fake_ext_ctxt for @parse::ParseSess {\n }\n \n #[cfg(test)]\n-fn mk_ctxt() -> @parse::ParseSess {\n+fn mk_ctxt() -> parse::ParseSess {\n     parse::new_parse_sess()\n }\n "}, {"sha": "80d48b8a8896f3f2819d200ec69a2b0bdfc9f972", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -30,10 +30,10 @@ pub fn highlight(src: &str, class: Option<&str>) -> ~str {\n     let sess = parse::new_parse_sess();\n     let handler = diagnostic::default_handler();\n     let span_handler = diagnostic::mk_span_handler(handler, sess.cm);\n-    let fm = parse::string_to_filemap(sess, src.to_owned(), ~\"<stdin>\");\n+    let fm = parse::string_to_filemap(&sess, src.to_owned(), ~\"<stdin>\");\n \n     let mut out = io::MemWriter::new();\n-    doit(sess,\n+    doit(&sess,\n          lexer::new_string_reader(span_handler, fm),\n          class,\n          &mut out).unwrap();\n@@ -47,7 +47,7 @@ pub fn highlight(src: &str, class: Option<&str>) -> ~str {\n /// it's used. All source code emission is done as slices from the source map,\n /// not from the tokens themselves, in order to stay true to the original\n /// source.\n-fn doit(sess: @parse::ParseSess, lexer: lexer::StringReader, class: Option<&str>,\n+fn doit(sess: &parse::ParseSess, lexer: lexer::StringReader, class: Option<&str>,\n         out: &mut Writer) -> io::IoResult<()> {\n     use syntax::parse::lexer::Reader;\n "}, {"sha": "a6f145a129ece19adba49fffd76371af4c0a0990", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -289,7 +289,7 @@ pub trait CrateLoader {\n // when a macro expansion occurs, the resulting nodes have the backtrace()\n // -> expn_info of their expansion context stored into their span.\n pub struct ExtCtxt<'a> {\n-    parse_sess: @parse::ParseSess,\n+    parse_sess: &'a parse::ParseSess,\n     cfg: ast::CrateConfig,\n     backtrace: Option<@ExpnInfo>,\n     ecfg: expand::ExpansionConfig<'a>,\n@@ -299,7 +299,7 @@ pub struct ExtCtxt<'a> {\n }\n \n impl<'a> ExtCtxt<'a> {\n-    pub fn new<'a>(parse_sess: @parse::ParseSess, cfg: ast::CrateConfig,\n+    pub fn new<'a>(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n                    ecfg: expand::ExpansionConfig<'a>) -> ExtCtxt<'a> {\n         ExtCtxt {\n             parse_sess: parse_sess,\n@@ -327,7 +327,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n-    pub fn parse_sess(&self) -> @parse::ParseSess { self.parse_sess }\n+    pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n     pub fn call_site(&self) -> Span {\n         match self.backtrace {"}, {"sha": "3ad1ea8f0da78c52f235bd3201083a0a0959e796", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -838,12 +838,12 @@ pub fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n     }\n }\n \n-pub struct MacroExpander<'a> {\n+pub struct MacroExpander<'a, 'b> {\n     extsbox: SyntaxEnv,\n-    cx: &'a mut ExtCtxt<'a>,\n+    cx: &'a mut ExtCtxt<'b>,\n }\n \n-impl<'a> Folder for MacroExpander<'a> {\n+impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     fn fold_expr(&mut self, expr: @ast::Expr) -> @ast::Expr {\n         expand_expr(expr, self)\n     }\n@@ -875,7 +875,7 @@ pub struct ExpansionConfig<'a> {\n     crate_id: CrateId,\n }\n \n-pub fn expand_crate(parse_sess: @parse::ParseSess,\n+pub fn expand_crate(parse_sess: &parse::ParseSess,\n                     cfg: ExpansionConfig,\n                     c: Crate) -> Crate {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n@@ -974,7 +974,7 @@ mod test {\n     use ext::mtwt;\n     use parse;\n     use parse::token;\n-    use util::parser_testing::{string_to_crate_and_sess};\n+    use util::parser_testing::{string_to_parser};\n     use util::parser_testing::{string_to_pat, strs_to_idents};\n     use visit;\n     use visit::Visitor;\n@@ -1126,15 +1126,16 @@ mod test {\n     //}\n \n     fn expand_crate_str(crate_str: ~str) -> ast::Crate {\n-        let (crate_ast,ps) = string_to_crate_and_sess(crate_str);\n+        let ps = parse::new_parse_sess();\n+        let crate_ast = string_to_parser(&ps, source_str).parse_crate_mod();\n         // the cfg argument actually does matter, here...\n         let mut loader = ErrLoader;\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             loader: &mut loader,\n             deriving_hash_type_parameter: false,\n             crate_id: from_str(\"test\").unwrap(),\n         };\n-        expand_crate(ps,cfg,crate_ast)\n+        expand_crate(&ps,cfg,crate_ast)\n     }\n \n     //fn expand_and_resolve(crate_str: @str) -> ast::crate {"}, {"sha": "e79e584ed5cc7161d11c9de2525e09d7b57755d5", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -35,8 +35,8 @@ enum Position {\n     Named(~str),\n }\n \n-struct Context<'a> {\n-    ecx: &'a mut ExtCtxt<'a>,\n+struct Context<'a, 'b> {\n+    ecx: &'a mut ExtCtxt<'b>,\n     fmtsp: Span,\n \n     // Parsed argument expressions and the types that we've found so far for\n@@ -142,7 +142,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     return (extra, Some((fmtstr, args, order, names)));\n }\n \n-impl<'a> Context<'a> {\n+impl<'a, 'b> Context<'a, 'b> {\n     /// Verifies one piece of a parse string. All errors are not emitted as\n     /// fatal so we can continue giving errors about this and possibly other\n     /// format strings."}, {"sha": "698bde4578c8d521b23daaaa2856340d446ec2fa", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -170,9 +170,9 @@ pub enum NamedMatch {\n     MatchedNonterminal(Nonterminal)\n }\n \n-pub fn nameize(p_s: @ParseSess, ms: &[Matcher], res: &[@NamedMatch])\n+pub fn nameize(p_s: &ParseSess, ms: &[Matcher], res: &[@NamedMatch])\n             -> HashMap<Ident, @NamedMatch> {\n-    fn n_rec(p_s: @ParseSess, m: &Matcher, res: &[@NamedMatch],\n+    fn n_rec(p_s: &ParseSess, m: &Matcher, res: &[@NamedMatch],\n              ret_val: &mut HashMap<Ident, @NamedMatch>) {\n         match *m {\n           codemap::Spanned {node: MatchTok(_), .. } => (),\n@@ -205,7 +205,7 @@ pub enum ParseResult {\n     Error(codemap::Span, ~str)\n }\n \n-pub fn parse_or_else<R: Reader>(sess: @ParseSess,\n+pub fn parse_or_else<R: Reader>(sess: &ParseSess,\n                                 cfg: ast::CrateConfig,\n                                 rdr: R,\n                                 ms: Vec<Matcher> )\n@@ -227,7 +227,7 @@ pub fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n     }\n }\n \n-pub fn parse<R: Reader>(sess: @ParseSess,\n+pub fn parse<R: Reader>(sess: &ParseSess,\n                         cfg: ast::CrateConfig,\n                         rdr: R,\n                         ms: &[Matcher])"}, {"sha": "4cacbfd6e5a32d633759699a017afdd1f5255e3f", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -30,11 +30,11 @@ use util::small_vector::SmallVector;\n use std::cell::RefCell;\n use std::vec_ng::Vec;\n \n-struct ParserAnyMacro {\n-    parser: RefCell<Parser>,\n+struct ParserAnyMacro<'a> {\n+    parser: RefCell<Parser<'a>>,\n }\n \n-impl ParserAnyMacro {\n+impl<'a> ParserAnyMacro<'a> {\n     /// Make sure we don't have any tokens left to parse, so we don't\n     /// silently drop anything. `allow_semi` is so that \"optional\"\n     /// semilons at the end of normal expressions aren't complained\n@@ -57,7 +57,7 @@ impl ParserAnyMacro {\n     }\n }\n \n-impl AnyMacro for ParserAnyMacro {\n+impl<'a> AnyMacro for ParserAnyMacro<'a> {\n     fn make_expr(&self) -> @ast::Expr {\n         let ret = {\n             let mut parser = self.parser.borrow_mut();"}, {"sha": "399648ef1d8810aefa72e6bd1f1a1f07d72702ff", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -28,7 +28,7 @@ pub trait ParserAttr {\n     fn parse_optional_meta(&mut self) -> Vec<@ast::MetaItem> ;\n }\n \n-impl ParserAttr for Parser {\n+impl<'a> ParserAttr for Parser<'a> {\n     // Parse attributes that appear before an item\n     fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute> {\n         let mut attrs: Vec<ast::Attribute> = Vec::new();"}, {"sha": "19291f721017fdbd1f5b03184b4114934d53ad9d", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -46,9 +46,9 @@ pub struct ParseSess {\n     included_mod_stack: RefCell<Vec<Path> >,\n }\n \n-pub fn new_parse_sess() -> @ParseSess {\n+pub fn new_parse_sess() -> ParseSess {\n     let cm = @CodeMap::new();\n-    @ParseSess {\n+    ParseSess {\n         cm: cm,\n         span_diagnostic: mk_span_handler(default_handler(), cm),\n         included_mod_stack: RefCell::new(Vec::new()),\n@@ -57,8 +57,8 @@ pub fn new_parse_sess() -> @ParseSess {\n \n pub fn new_parse_sess_special_handler(sh: @SpanHandler,\n                                       cm: @codemap::CodeMap)\n-                                      -> @ParseSess {\n-    @ParseSess {\n+                                      -> ParseSess {\n+    ParseSess {\n         cm: cm,\n         span_diagnostic: sh,\n         included_mod_stack: RefCell::new(Vec::new()),\n@@ -73,7 +73,7 @@ pub fn new_parse_sess_special_handler(sh: @SpanHandler,\n pub fn parse_crate_from_file(\n     input: &Path,\n     cfg: ast::CrateConfig,\n-    sess: @ParseSess\n+    sess: &ParseSess\n ) -> ast::Crate {\n     new_parser_from_file(sess, cfg, input).parse_crate_mod()\n     // why is there no p.abort_if_errors here?\n@@ -82,17 +82,17 @@ pub fn parse_crate_from_file(\n pub fn parse_crate_attrs_from_file(\n     input: &Path,\n     cfg: ast::CrateConfig,\n-    sess: @ParseSess\n+    sess: &ParseSess\n ) -> Vec<ast::Attribute> {\n     let mut parser = new_parser_from_file(sess, cfg, input);\n     let (inner, _) = parser.parse_inner_attrs_and_next();\n-    return inner;\n+    inner\n }\n \n pub fn parse_crate_from_source_str(name: ~str,\n                                    source: ~str,\n                                    cfg: ast::CrateConfig,\n-                                   sess: @ParseSess)\n+                                   sess: &ParseSess)\n                                    -> ast::Crate {\n     let mut p = new_parser_from_source_str(sess,\n                                            cfg,\n@@ -104,20 +104,20 @@ pub fn parse_crate_from_source_str(name: ~str,\n pub fn parse_crate_attrs_from_source_str(name: ~str,\n                                          source: ~str,\n                                          cfg: ast::CrateConfig,\n-                                         sess: @ParseSess)\n+                                         sess: &ParseSess)\n                                          -> Vec<ast::Attribute> {\n     let mut p = new_parser_from_source_str(sess,\n                                            cfg,\n                                            name,\n                                            source);\n     let (inner, _) = maybe_aborted(p.parse_inner_attrs_and_next(),p);\n-    return inner;\n+    inner\n }\n \n pub fn parse_expr_from_source_str(name: ~str,\n                                   source: ~str,\n                                   cfg: ast::CrateConfig,\n-                                  sess: @ParseSess)\n+                                  sess: &ParseSess)\n                                   -> @ast::Expr {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_expr(), p)\n@@ -126,7 +126,7 @@ pub fn parse_expr_from_source_str(name: ~str,\n pub fn parse_item_from_source_str(name: ~str,\n                                   source: ~str,\n                                   cfg: ast::CrateConfig,\n-                                  sess: @ParseSess)\n+                                  sess: &ParseSess)\n                                   -> Option<@ast::Item> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     let attrs = p.parse_outer_attributes();\n@@ -136,7 +136,7 @@ pub fn parse_item_from_source_str(name: ~str,\n pub fn parse_meta_from_source_str(name: ~str,\n                                   source: ~str,\n                                   cfg: ast::CrateConfig,\n-                                  sess: @ParseSess)\n+                                  sess: &ParseSess)\n                                   -> @ast::MetaItem {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_meta_item(),p)\n@@ -146,7 +146,7 @@ pub fn parse_stmt_from_source_str(name: ~str,\n                                   source: ~str,\n                                   cfg: ast::CrateConfig,\n                                   attrs: Vec<ast::Attribute> ,\n-                                  sess: @ParseSess)\n+                                  sess: &ParseSess)\n                                   -> @ast::Stmt {\n     let mut p = new_parser_from_source_str(\n         sess,\n@@ -160,7 +160,7 @@ pub fn parse_stmt_from_source_str(name: ~str,\n pub fn parse_tts_from_source_str(name: ~str,\n                                  source: ~str,\n                                  cfg: ast::CrateConfig,\n-                                 sess: @ParseSess)\n+                                 sess: &ParseSess)\n                                  -> Vec<ast::TokenTree> {\n     let mut p = new_parser_from_source_str(\n         sess,\n@@ -174,48 +174,48 @@ pub fn parse_tts_from_source_str(name: ~str,\n }\n \n // Create a new parser from a source string\n-pub fn new_parser_from_source_str(sess: @ParseSess,\n-                                  cfg: ast::CrateConfig,\n-                                  name: ~str,\n-                                  source: ~str)\n-                                  -> Parser {\n+pub fn new_parser_from_source_str<'a>(sess: &'a ParseSess,\n+                                     cfg: ast::CrateConfig,\n+                                     name: ~str,\n+                                     source: ~str)\n+                                     -> Parser<'a> {\n     filemap_to_parser(sess,string_to_filemap(sess,source,name),cfg)\n }\n \n /// Create a new parser, handling errors as appropriate\n /// if the file doesn't exist\n-pub fn new_parser_from_file(\n-    sess: @ParseSess,\n+pub fn new_parser_from_file<'a>(\n+    sess: &'a ParseSess,\n     cfg: ast::CrateConfig,\n     path: &Path\n-) -> Parser {\n+) -> Parser<'a> {\n     filemap_to_parser(sess,file_to_filemap(sess,path,None),cfg)\n }\n \n /// Given a session, a crate config, a path, and a span, add\n /// the file at the given path to the codemap, and return a parser.\n /// On an error, use the given span as the source of the problem.\n-pub fn new_sub_parser_from_file(\n-    sess: @ParseSess,\n+pub fn new_sub_parser_from_file<'a>(\n+    sess: &'a ParseSess,\n     cfg: ast::CrateConfig,\n     path: &Path,\n     sp: Span\n-) -> Parser {\n+) -> Parser<'a> {\n     filemap_to_parser(sess,file_to_filemap(sess,path,Some(sp)),cfg)\n }\n \n /// Given a filemap and config, return a parser\n-pub fn filemap_to_parser(sess: @ParseSess,\n-                         filemap: @FileMap,\n-                         cfg: ast::CrateConfig) -> Parser {\n+pub fn filemap_to_parser<'a>(sess: &'a ParseSess,\n+                             filemap: @FileMap,\n+                             cfg: ast::CrateConfig) -> Parser<'a> {\n     tts_to_parser(sess,filemap_to_tts(sess,filemap),cfg)\n }\n \n // must preserve old name for now, because quote! from the *existing*\n // compiler expands into it\n-pub fn new_parser_from_tts(sess: @ParseSess,\n-                     cfg: ast::CrateConfig,\n-                     tts: Vec<ast::TokenTree> ) -> Parser {\n+pub fn new_parser_from_tts<'a>(sess: &'a ParseSess,\n+                               cfg: ast::CrateConfig,\n+                               tts: Vec<ast::TokenTree>) -> Parser<'a> {\n     tts_to_parser(sess,tts,cfg)\n }\n \n@@ -224,7 +224,7 @@ pub fn new_parser_from_tts(sess: @ParseSess,\n \n /// Given a session and a path and an optional span (for error reporting),\n /// add the path to the session's codemap and return the new filemap.\n-pub fn file_to_filemap(sess: @ParseSess, path: &Path, spanopt: Option<Span>)\n+pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n     -> @FileMap {\n     let err = |msg: &str| {\n         match spanopt {\n@@ -250,13 +250,13 @@ pub fn file_to_filemap(sess: @ParseSess, path: &Path, spanopt: Option<Span>)\n \n // given a session and a string, add the string to\n // the session's codemap and return the new filemap\n-pub fn string_to_filemap(sess: @ParseSess, source: ~str, path: ~str)\n+pub fn string_to_filemap(sess: &ParseSess, source: ~str, path: ~str)\n                          -> @FileMap {\n     sess.cm.new_filemap(path, source)\n }\n \n // given a filemap, produce a sequence of token-trees\n-pub fn filemap_to_tts(sess: @ParseSess, filemap: @FileMap)\n+pub fn filemap_to_tts(sess: &ParseSess, filemap: @FileMap)\n     -> Vec<ast::TokenTree> {\n     // it appears to me that the cfg doesn't matter here... indeed,\n     // parsing tt's probably shouldn't require a parser at all.\n@@ -267,9 +267,9 @@ pub fn filemap_to_tts(sess: @ParseSess, filemap: @FileMap)\n }\n \n // given tts and cfg, produce a parser\n-pub fn tts_to_parser(sess: @ParseSess,\n-                     tts: Vec<ast::TokenTree> ,\n-                     cfg: ast::CrateConfig) -> Parser {\n+pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n+                         tts: Vec<ast::TokenTree>,\n+                         cfg: ast::CrateConfig) -> Parser<'a> {\n     let trdr = lexer::new_tt_reader(sess.span_diagnostic, None, tts);\n     Parser(sess, cfg, ~trdr)\n }\n@@ -594,7 +594,7 @@ mod test {\n     }\n \n     #[test] fn parse_ident_pat () {\n-        let mut parser = string_to_parser(~\"b\");\n+        let mut parser = string_to_parser(&new_parse_sess(), ~\"b\");\n         assert!(parser.parse_pat() ==\n                    @ast::Pat{id: ast::DUMMY_NODE_ID,\n                              node: ast::PatIdent("}, {"sha": "1d7bf2ef6da9db85da48e80e5398b9553267dd4c", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -59,7 +59,7 @@ pub trait ParserObsoleteMethods {\n     fn eat_obsolete_ident(&mut self, ident: &str) -> bool;\n }\n \n-impl ParserObsoleteMethods for Parser {\n+impl<'a> ParserObsoleteMethods for Parser<'a> {\n     /// Reports an obsolete syntax non-fatal error.\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {"}, {"sha": "d183eb44cc222ade0d40f2bcb4b0b0b99f5bc5e7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -284,8 +284,8 @@ struct ParsedItemsAndViewItems {\n \n /* ident is handled by common.rs */\n \n-pub fn Parser(sess: @ParseSess, cfg: ast::CrateConfig, rdr: ~Reader:)\n-              -> Parser {\n+pub fn Parser<'a>(sess: &'a ParseSess, cfg: ast::CrateConfig, rdr: ~Reader:)\n+              -> Parser<'a> {\n     let tok0 = rdr.next_token();\n     let span = tok0.sp;\n     let placeholder = TokenAndSpan {\n@@ -320,8 +320,8 @@ pub fn Parser(sess: @ParseSess, cfg: ast::CrateConfig, rdr: ~Reader:)\n     }\n }\n \n-pub struct Parser {\n-    sess: @ParseSess,\n+pub struct Parser<'a> {\n+    sess: &'a ParseSess,\n     cfg: CrateConfig,\n     // the current token:\n     token: token::Token,\n@@ -354,7 +354,7 @@ fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n     is_plain_ident(t) || *t == token::UNDERSCORE\n }\n \n-impl Parser {\n+impl<'a> Parser<'a> {\n     // convert a token to a string using self's reader\n     pub fn token_to_str(token: &token::Token) -> ~str {\n         token::to_str(token)"}, {"sha": "029486412ea1cc78fe259e87b4e28cffbcf09aea", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 7, "deletions": 26, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90cbe0cad20d2736c7e7ebbffb2c2d84016f9340/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=90cbe0cad20d2736c7e7ebbffb2c2d84016f9340", "patch": "@@ -17,32 +17,19 @@ use parse::token;\n \n use std::vec_ng::Vec;\n \n-// map a string to tts, using a made-up filename: return both the TokenTree's\n-// and the ParseSess\n-pub fn string_to_tts_and_sess (source_str : ~str) -> (Vec<ast::TokenTree> , @ParseSess) {\n-    let ps = new_parse_sess();\n-    (filemap_to_tts(ps,string_to_filemap(ps,source_str,~\"bogofile\")),ps)\n-}\n-\n // map a string to tts, using a made-up filename:\n-pub fn string_to_tts(source_str : ~str) -> Vec<ast::TokenTree> {\n-    let (tts,_) = string_to_tts_and_sess(source_str);\n-    tts\n-}\n-\n-pub fn string_to_parser_and_sess(source_str: ~str) -> (Parser,@ParseSess) {\n+pub fn string_to_tts(source_str: ~str) -> Vec<ast::TokenTree> {\n     let ps = new_parse_sess();\n-    (new_parser_from_source_str(ps,Vec::new(),~\"bogofile\",source_str),ps)\n+    filemap_to_tts(&ps, string_to_filemap(&ps, source_str,~\"bogofile\"))\n }\n \n // map string to parser (via tts)\n-pub fn string_to_parser(source_str: ~str) -> Parser {\n-    let (p,_) = string_to_parser_and_sess(source_str);\n-    p\n+pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: ~str) -> Parser<'a> {\n+    new_parser_from_source_str(ps, Vec::new(), ~\"bogofile\", source_str)\n }\n \n fn with_error_checking_parse<T>(s: ~str, f: |&mut Parser| -> T) -> T {\n-    let mut p = string_to_parser(s);\n+    let mut p = string_to_parser(&new_parse_sess(), s);\n     let x = f(&mut p);\n     p.abort_if_errors();\n     x\n@@ -55,12 +42,6 @@ pub fn string_to_crate (source_str : ~str) -> ast::Crate {\n     })\n }\n \n-// parse a string, return a crate and the ParseSess\n-pub fn string_to_crate_and_sess (source_str : ~str) -> (ast::Crate,@ParseSess) {\n-    let (mut p,ps) = string_to_parser_and_sess(source_str);\n-    (p.parse_crate_mod(),ps)\n-}\n-\n // parse a string, return an expr\n pub fn string_to_expr (source_str : ~str) -> @ast::Expr {\n     with_error_checking_parse(source_str, |p| {\n@@ -84,8 +65,8 @@ pub fn string_to_stmt(source_str : ~str) -> @ast::Stmt {\n \n // parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n // (currently) affect parsing.\n-pub fn string_to_pat(source_str : ~str) -> @ast::Pat {\n-    string_to_parser(source_str).parse_pat()\n+pub fn string_to_pat(source_str: ~str) -> @ast::Pat {\n+    string_to_parser(&new_parse_sess(), source_str).parse_pat()\n }\n \n // convert a vector of strings to a vector of ast::Ident's"}]}