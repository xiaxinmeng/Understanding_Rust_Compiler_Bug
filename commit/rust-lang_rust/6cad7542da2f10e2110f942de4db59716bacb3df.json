{"sha": "6cad7542da2f10e2110f942de4db59716bacb3df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjYWQ3NTQyZGEyZjEwZTIxMTBmOTQyZGU0ZGI1OTcxNmJhY2IzZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-08T03:46:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-08T03:46:56Z"}, "message": "Auto merge of #68358 - matthewjasper:spec-fix, r=nikomatsakis\n\nRemove some unsound specializations\n\nThis removes the unsound and exploitable specializations in the standard library\n\n* The `PartialEq` and `Hash` implementations for  `RangeInclusive` are changed to avoid specialization.\n* The `PartialOrd` specialization for slices now specializes on a limited set of concrete types.\n* Added some tests for the soundness problems.", "tree": {"sha": "c3344ccc601a6bbdebd9b69ee1a92e4e81cfceac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3344ccc601a6bbdebd9b69ee1a92e4e81cfceac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cad7542da2f10e2110f942de4db59716bacb3df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cad7542da2f10e2110f942de4db59716bacb3df", "html_url": "https://github.com/rust-lang/rust/commit/6cad7542da2f10e2110f942de4db59716bacb3df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cad7542da2f10e2110f942de4db59716bacb3df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "html_url": "https://github.com/rust-lang/rust/commit/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f"}, {"sha": "a81c59f9b84b6519785a4e0ae9234107d149f454", "url": "https://api.github.com/repos/rust-lang/rust/commits/a81c59f9b84b6519785a4e0ae9234107d149f454", "html_url": "https://github.com/rust-lang/rust/commit/a81c59f9b84b6519785a4e0ae9234107d149f454"}], "stats": {"total": 225, "additions": 168, "deletions": 57}, "files": [{"sha": "be9d832ed90f6b66800c7664640826110cb4dbbc", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cad7542da2f10e2110f942de4db59716bacb3df/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad7542da2f10e2110f942de4db59716bacb3df/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=6cad7542da2f10e2110f942de4db59716bacb3df", "patch": "@@ -385,12 +385,14 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n                 }\n                 Some(Equal) => {\n                     self.is_empty = Some(true);\n+                    self.start = plus_n.clone();\n                     return Some(plus_n);\n                 }\n                 _ => {}\n             }\n         }\n \n+        self.start = self.end.clone();\n         self.is_empty = Some(true);\n         None\n     }\n@@ -477,12 +479,14 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n                 }\n                 Some(Equal) => {\n                     self.is_empty = Some(true);\n+                    self.end = minus_n.clone();\n                     return Some(minus_n);\n                 }\n                 _ => {}\n             }\n         }\n \n+        self.end = self.start.clone();\n         self.is_empty = Some(true);\n         None\n     }"}, {"sha": "6c0bc6bbbad2266cfbb5ce1c945d43643f952117", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6cad7542da2f10e2110f942de4db59716bacb3df/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad7542da2f10e2110f942de4db59716bacb3df/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=6cad7542da2f10e2110f942de4db59716bacb3df", "patch": "@@ -343,38 +343,21 @@ pub struct RangeInclusive<Idx> {\n     pub(crate) is_empty: Option<bool>,\n     // This field is:\n     //  - `None` when next() or next_back() was never called\n-    //  - `Some(false)` when `start <= end` assuming no overflow\n-    //  - `Some(true)` otherwise\n+    //  - `Some(false)` when `start < end`\n+    //  - `Some(true)` when `end < start`\n+    //  - `Some(false)` when `start == end` and the range hasn't yet completed iteration\n+    //  - `Some(true)` when `start == end` and the range has completed iteration\n     // The field cannot be a simple `bool` because the `..=` constructor can\n     // accept non-PartialOrd types, also we want the constructor to be const.\n }\n \n-trait RangeInclusiveEquality: Sized {\n-    fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool;\n-}\n-\n-impl<T> RangeInclusiveEquality for T {\n-    #[inline]\n-    default fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {\n-        range.is_empty.unwrap_or_default()\n-    }\n-}\n-\n-impl<T: PartialOrd> RangeInclusiveEquality for T {\n-    #[inline]\n-    fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {\n-        range.is_empty()\n-    }\n-}\n-\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         self.start == other.start\n             && self.end == other.end\n-            && RangeInclusiveEquality::canonicalized_is_empty(self)\n-                == RangeInclusiveEquality::canonicalized_is_empty(other)\n+            && self.is_exhausted() == other.is_exhausted()\n     }\n }\n \n@@ -386,7 +369,8 @@ impl<Idx: Hash> Hash for RangeInclusive<Idx> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.start.hash(state);\n         self.end.hash(state);\n-        RangeInclusiveEquality::canonicalized_is_empty(self).hash(state);\n+        // Ideally we would hash `is_exhausted` here as well, but there's no\n+        // way for us to call it.\n     }\n }\n \n@@ -485,6 +469,14 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     }\n }\n \n+impl<Idx: PartialEq<Idx>> RangeInclusive<Idx> {\n+    // Returns true if this is a range that started non-empty, and was iterated\n+    // to exhaustion.\n+    fn is_exhausted(&self) -> bool {\n+        Some(true) == self.is_empty && self.start == self.end\n+    }\n+}\n+\n impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///"}, {"sha": "e79a775325f4ac09dd9e10ea56716b76778a5b16", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6cad7542da2f10e2110f942de4db59716bacb3df/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad7542da2f10e2110f942de4db59716bacb3df/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=6cad7542da2f10e2110f942de4db59716bacb3df", "patch": "@@ -5584,21 +5584,18 @@ where\n \n #[doc(hidden)]\n // intermediate trait for specialization of slice's PartialOrd\n-trait SlicePartialOrd<B> {\n-    fn partial_compare(&self, other: &[B]) -> Option<Ordering>;\n+trait SlicePartialOrd: Sized {\n+    fn partial_compare(left: &[Self], right: &[Self]) -> Option<Ordering>;\n }\n \n-impl<A> SlicePartialOrd<A> for [A]\n-where\n-    A: PartialOrd,\n-{\n-    default fn partial_compare(&self, other: &[A]) -> Option<Ordering> {\n-        let l = cmp::min(self.len(), other.len());\n+impl<A: PartialOrd> SlicePartialOrd for A {\n+    default fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n+        let l = cmp::min(left.len(), right.len());\n \n         // Slice to the loop iteration range to enable bound check\n         // elimination in the compiler\n-        let lhs = &self[..l];\n-        let rhs = &other[..l];\n+        let lhs = &left[..l];\n+        let rhs = &right[..l];\n \n         for i in 0..l {\n             match lhs[i].partial_cmp(&rhs[i]) {\n@@ -5607,36 +5604,61 @@ where\n             }\n         }\n \n-        self.len().partial_cmp(&other.len())\n+        left.len().partial_cmp(&right.len())\n     }\n }\n \n-impl<A> SlicePartialOrd<A> for [A]\n+// This is the impl that we would like to have. Unfortunately it's not sound.\n+// See `partial_ord_slice.rs`.\n+/*\n+impl<A> SlicePartialOrd for A\n where\n     A: Ord,\n {\n-    default fn partial_compare(&self, other: &[A]) -> Option<Ordering> {\n-        Some(SliceOrd::compare(self, other))\n+    default fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n+        Some(SliceOrd::compare(left, right))\n+    }\n+}\n+*/\n+\n+impl<A: AlwaysApplicableOrd> SlicePartialOrd for A {\n+    fn partial_compare(left: &[A], right: &[A]) -> Option<Ordering> {\n+        Some(SliceOrd::compare(left, right))\n+    }\n+}\n+\n+trait AlwaysApplicableOrd: SliceOrd + Ord {}\n+\n+macro_rules! always_applicable_ord {\n+    ($([$($p:tt)*] $t:ty,)*) => {\n+        $(impl<$($p)*> AlwaysApplicableOrd for $t {})*\n     }\n }\n \n+always_applicable_ord! {\n+    [] u8, [] u16, [] u32, [] u64, [] u128, [] usize,\n+    [] i8, [] i16, [] i32, [] i64, [] i128, [] isize,\n+    [] bool, [] char,\n+    [T: ?Sized] *const T, [T: ?Sized] *mut T,\n+    [T: AlwaysApplicableOrd] &T,\n+    [T: AlwaysApplicableOrd] &mut T,\n+    [T: AlwaysApplicableOrd] Option<T>,\n+}\n+\n #[doc(hidden)]\n // intermediate trait for specialization of slice's Ord\n-trait SliceOrd<B> {\n-    fn compare(&self, other: &[B]) -> Ordering;\n+trait SliceOrd: Sized {\n+    fn compare(left: &[Self], right: &[Self]) -> Ordering;\n }\n \n-impl<A> SliceOrd<A> for [A]\n-where\n-    A: Ord,\n-{\n-    default fn compare(&self, other: &[A]) -> Ordering {\n-        let l = cmp::min(self.len(), other.len());\n+impl<A: Ord> SliceOrd for A {\n+    default fn compare(left: &[Self], right: &[Self]) -> Ordering {\n+        let l = cmp::min(left.len(), right.len());\n \n         // Slice to the loop iteration range to enable bound check\n         // elimination in the compiler\n-        let lhs = &self[..l];\n-        let rhs = &other[..l];\n+        let lhs = &left[..l];\n+        let rhs = &right[..l];\n \n         for i in 0..l {\n             match lhs[i].cmp(&rhs[i]) {\n@@ -5645,19 +5667,19 @@ where\n             }\n         }\n \n-        self.len().cmp(&other.len())\n+        left.len().cmp(&right.len())\n     }\n }\n \n // memcmp compares a sequence of unsigned bytes lexicographically.\n // this matches the order we want for [u8], but no others (not even [i8]).\n-impl SliceOrd<u8> for [u8] {\n+impl SliceOrd for u8 {\n     #[inline]\n-    fn compare(&self, other: &[u8]) -> Ordering {\n+    fn compare(left: &[Self], right: &[Self]) -> Ordering {\n         let order =\n-            unsafe { memcmp(self.as_ptr(), other.as_ptr(), cmp::min(self.len(), other.len())) };\n+            unsafe { memcmp(left.as_ptr(), right.as_ptr(), cmp::min(left.len(), right.len())) };\n         if order == 0 {\n-            self.len().cmp(&other.len())\n+            left.len().cmp(&right.len())\n         } else if order < 0 {\n             Less\n         } else {"}, {"sha": "734b3ba7c6bbaea9ad3bbce7f9c76f54d6a9d058", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6cad7542da2f10e2110f942de4db59716bacb3df/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad7542da2f10e2110f942de4db59716bacb3df/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=6cad7542da2f10e2110f942de4db59716bacb3df", "patch": "@@ -12,7 +12,7 @@ use self::pattern::{DoubleEndedSearcher, ReverseSearcher, SearchStep, Searcher};\n use crate::char;\n use crate::fmt::{self, Write};\n use crate::iter::{Chain, FlatMap, Flatten};\n-use crate::iter::{Cloned, Filter, FusedIterator, Map, TrustedLen, TrustedRandomAccess};\n+use crate::iter::{Copied, Filter, FusedIterator, Map, TrustedLen, TrustedRandomAccess};\n use crate::mem;\n use crate::ops::Try;\n use crate::option;\n@@ -750,7 +750,7 @@ impl<'a> CharIndices<'a> {\n /// [`str`]: ../../std/primitive.str.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone, Debug)]\n-pub struct Bytes<'a>(Cloned<slice::Iter<'a, u8>>);\n+pub struct Bytes<'a>(Copied<slice::Iter<'a, u8>>);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for Bytes<'_> {\n@@ -2778,7 +2778,7 @@ impl str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn bytes(&self) -> Bytes<'_> {\n-        Bytes(self.as_bytes().iter().cloned())\n+        Bytes(self.as_bytes().iter().copied())\n     }\n \n     /// Splits a string slice by whitespace.\n@@ -3895,7 +3895,7 @@ impl str {\n             debug_assert_eq!(\n                 start, 0,\n                 \"The first search step from Searcher \\\n-                must include the first character\"\n+                 must include the first character\"\n             );\n             // SAFETY: `Searcher` is known to return valid indices.\n             unsafe { Some(self.get_unchecked(len..)) }\n@@ -3934,7 +3934,7 @@ impl str {\n                 end,\n                 self.len(),\n                 \"The first search step from ReverseSearcher \\\n-                must include the last character\"\n+                 must include the last character\"\n             );\n             // SAFETY: `Searcher` is known to return valid indices.\n             unsafe { Some(self.get_unchecked(..start)) }"}, {"sha": "5b41ef350657fe491dd7b6cbd34edb48ee3544b1", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6cad7542da2f10e2110f942de4db59716bacb3df/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad7542da2f10e2110f942de4db59716bacb3df/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=6cad7542da2f10e2110f942de4db59716bacb3df", "patch": "@@ -1956,11 +1956,19 @@ fn test_range_inclusive_exhaustion() {\n     assert_eq!(r.next(), None);\n     assert_eq!(r.next(), None);\n \n+    assert_eq!(*r.start(), 10);\n+    assert_eq!(*r.end(), 10);\n+    assert_ne!(r, 10..=10);\n+\n     let mut r = 10..=10;\n     assert_eq!(r.next_back(), Some(10));\n     assert!(r.is_empty());\n     assert_eq!(r.next_back(), None);\n \n+    assert_eq!(*r.start(), 10);\n+    assert_eq!(*r.end(), 10);\n+    assert_ne!(r, 10..=10);\n+\n     let mut r = 10..=12;\n     assert_eq!(r.next(), Some(10));\n     assert_eq!(r.next(), Some(11));\n@@ -2078,6 +2086,9 @@ fn test_range_inclusive_nth() {\n     assert_eq!((10..=15).nth(5), Some(15));\n     assert_eq!((10..=15).nth(6), None);\n \n+    let mut exhausted_via_next = 10_u8..=20;\n+    while exhausted_via_next.next().is_some() {}\n+\n     let mut r = 10_u8..=20;\n     assert_eq!(r.nth(2), Some(12));\n     assert_eq!(r, 13..=20);\n@@ -2087,6 +2098,7 @@ fn test_range_inclusive_nth() {\n     assert_eq!(ExactSizeIterator::is_empty(&r), false);\n     assert_eq!(r.nth(10), None);\n     assert_eq!(r.is_empty(), true);\n+    assert_eq!(r, exhausted_via_next);\n     assert_eq!(ExactSizeIterator::is_empty(&r), true);\n }\n \n@@ -2098,6 +2110,9 @@ fn test_range_inclusive_nth_back() {\n     assert_eq!((10..=15).nth_back(6), None);\n     assert_eq!((-120..=80_i8).nth_back(200), Some(-120));\n \n+    let mut exhausted_via_next_back = 10_u8..=20;\n+    while exhausted_via_next_back.next_back().is_some() {}\n+\n     let mut r = 10_u8..=20;\n     assert_eq!(r.nth_back(2), Some(18));\n     assert_eq!(r, 10..=17);\n@@ -2107,6 +2122,7 @@ fn test_range_inclusive_nth_back() {\n     assert_eq!(ExactSizeIterator::is_empty(&r), false);\n     assert_eq!(r.nth_back(10), None);\n     assert_eq!(r.is_empty(), true);\n+    assert_eq!(r, exhausted_via_next_back);\n     assert_eq!(ExactSizeIterator::is_empty(&r), true);\n }\n "}, {"sha": "923dec892e0805b7797c7cd38cb138ec39043503", "filename": "src/test/ui/specialization/soundness/partial_eq_range_inclusive.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6cad7542da2f10e2110f942de4db59716bacb3df/src%2Ftest%2Fui%2Fspecialization%2Fsoundness%2Fpartial_eq_range_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad7542da2f10e2110f942de4db59716bacb3df/src%2Ftest%2Fui%2Fspecialization%2Fsoundness%2Fpartial_eq_range_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fsoundness%2Fpartial_eq_range_inclusive.rs?ref=6cad7542da2f10e2110f942de4db59716bacb3df", "patch": "@@ -0,0 +1,35 @@\n+// run-pass\n+\n+use std::cell::RefCell;\n+use std::cmp::Ordering;\n+\n+struct Evil<'a, 'b> {\n+    values: RefCell<Vec<&'a str>>,\n+    to_insert: &'b String,\n+}\n+\n+impl<'a, 'b> PartialEq for Evil<'a, 'b> {\n+    fn eq(&self, _other: &Self) -> bool {\n+        true\n+    }\n+}\n+\n+impl<'a> PartialOrd for Evil<'a, 'a> {\n+    fn partial_cmp(&self, _other: &Self) -> Option<Ordering> {\n+        self.values.borrow_mut().push(self.to_insert);\n+        None\n+    }\n+}\n+\n+fn main() {\n+    let e;\n+    let values;\n+    {\n+        let to_insert = String::from(\"Hello, world!\");\n+        e = Evil { values: RefCell::new(Vec::new()), to_insert: &to_insert };\n+        let range = &e..=&e;\n+        let _ = range == range;\n+        values = e.values;\n+    }\n+    assert_eq!(*values.borrow(), Vec::<&str>::new());\n+}"}, {"sha": "b9e80a48d33d337500728af052f2b383d96881f8", "filename": "src/test/ui/specialization/soundness/partial_ord_slice.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6cad7542da2f10e2110f942de4db59716bacb3df/src%2Ftest%2Fui%2Fspecialization%2Fsoundness%2Fpartial_ord_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad7542da2f10e2110f942de4db59716bacb3df/src%2Ftest%2Fui%2Fspecialization%2Fsoundness%2Fpartial_ord_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fsoundness%2Fpartial_ord_slice.rs?ref=6cad7542da2f10e2110f942de4db59716bacb3df", "patch": "@@ -0,0 +1,42 @@\n+// Check that we aren't using unsound specialization in slice comparisons.\n+\n+// run-pass\n+\n+use std::cell::Cell;\n+use std::cmp::Ordering;\n+\n+struct Evil<'a, 'b>(Cell<(&'a [i32], &'b [i32])>);\n+\n+impl PartialEq for Evil<'_, '_> {\n+    fn eq(&self, _other: &Self) -> bool {\n+        true\n+    }\n+}\n+\n+impl Eq for Evil<'_, '_> {}\n+\n+impl PartialOrd for Evil<'_, '_> {\n+    fn partial_cmp(&self, _other: &Self) -> Option<Ordering> {\n+        Some(Ordering::Equal)\n+    }\n+}\n+\n+impl<'a> Ord for Evil<'a, 'a> {\n+    fn cmp(&self, _other: &Self) -> Ordering {\n+        let (a, b) = self.0.get();\n+        self.0.set((b, a));\n+        Ordering::Equal\n+    }\n+}\n+\n+fn main() {\n+    let x = &[1, 2, 3, 4];\n+    let u = {\n+        let a = Box::new([7, 8, 9, 10]);\n+        let y = [Evil(Cell::new((x, &*a)))];\n+        let _ = &y[..] <= &y[..];\n+        let [Evil(c)] = y;\n+        c.get().0\n+    };\n+    assert_eq!(u, &[1, 2, 3, 4]);\n+}"}]}