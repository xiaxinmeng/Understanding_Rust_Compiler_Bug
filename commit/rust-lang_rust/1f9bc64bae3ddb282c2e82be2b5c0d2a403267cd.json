{"sha": "1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmOWJjNjRiYWUzZGRiMjgyYzJlODJiZTJiNWMwZDJhNDAzMjY3Y2Q=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-03T00:08:49Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-07T04:41:58Z"}, "message": "adt.rs renaming: \"field\" rather than \"element\"; set_discr -> start_init.\n\nThis way \"field\" refers to the abstraction and \"element\" (as in get_elt,\n\"get element pointer\", etc.) refers to the low-level LLVM operations.", "tree": {"sha": "9a4494d53ff096cf9ebc33df2ad41ed0c40a4ed7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a4494d53ff096cf9ebc33df2ad41ed0c40a4ed7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd", "html_url": "https://github.com/rust-lang/rust/commit/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e13111fc5ab9a968d5668712bb75bc49350a7f25", "url": "https://api.github.com/repos/rust-lang/rust/commits/e13111fc5ab9a968d5668712bb75bc49350a7f25", "html_url": "https://github.com/rust-lang/rust/commit/e13111fc5ab9a968d5668712bb75bc49350a7f25"}], "stats": {"total": 81, "additions": 44, "deletions": 37}, "files": [{"sha": "3de1c35b65e9fa66e700343613a8d72124731507", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd", "patch": "@@ -838,7 +838,7 @@ pub fn extract_variant_args(bcx: block,\n     -> ExtractedBlock {\n     let _icx = bcx.insn_ctxt(\"match::extract_variant_args\");\n     let args = do vec::from_fn(adt::num_args(repr, disr_val)) |i| {\n-        adt::trans_GEP(bcx, repr, val, disr_val, i)\n+        adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n     };\n \n     ExtractedBlock { vals: args, bcx: bcx }\n@@ -1274,7 +1274,7 @@ pub fn compile_submatch(bcx: block,\n         do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n             let rec_vals = rec_fields.map(|field_name| {\n                 let ix = ty::field_idx_strict(tcx, *field_name, field_tys);\n-                adt::trans_GEP(bcx, pat_repr, val, discr, ix)\n+                adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n             });\n             compile_submatch(\n                 bcx,\n@@ -1293,7 +1293,7 @@ pub fn compile_submatch(bcx: block,\n           _ => ccx.sess.bug(~\"non-tuple type in tuple pattern\")\n         };\n         let tup_vals = do vec::from_fn(n_tup_elts) |i| {\n-            adt::trans_GEP(bcx, tup_repr, val, 0, i)\n+            adt::trans_field_ptr(bcx, tup_repr, val, 0, i)\n         };\n         compile_submatch(bcx, enter_tup(bcx, dm, m, col, val, n_tup_elts),\n                          vec::append(tup_vals, vals_left), chk);\n@@ -1315,7 +1315,7 @@ pub fn compile_submatch(bcx: block,\n \n         let struct_repr = adt::represent_type(bcx.ccx(), struct_ty);\n         let llstructvals = do vec::from_fn(struct_element_count) |i| {\n-            adt::trans_GEP(bcx, struct_repr, val, 0, i)\n+            adt::trans_field_ptr(bcx, struct_repr, val, 0, i)\n         };\n         compile_submatch(bcx,\n                          enter_tuple_struct(bcx, dm, m, col, val,\n@@ -1753,7 +1753,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                             // This is the tuple struct case.\n                             let repr = adt::represent_node(bcx, pat.id);\n                             for vec::eachi(elems) |i, elem| {\n-                                let fldptr = adt::trans_GEP(bcx, repr,\n+                                let fldptr = adt::trans_field_ptr(bcx, repr,\n                                                             val, 0, i);\n                                 bcx = bind_irrefutable_pat(bcx,\n                                                            *elem,\n@@ -1776,7 +1776,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n             do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n                 for vec::each(fields) |f| {\n                     let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n-                    let fldptr = adt::trans_GEP(bcx, pat_repr, val,\n+                    let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n                                                 discr, ix);\n                     bcx = bind_irrefutable_pat(bcx,\n                                                f.pat,\n@@ -1789,7 +1789,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n         ast::pat_tup(elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n             for vec::eachi(elems) |i, elem| {\n-                let fldptr = adt::trans_GEP(bcx, repr, val, 0, i);\n+                let fldptr = adt::trans_field_ptr(bcx, repr, val, 0, i);\n                 bcx = bind_irrefutable_pat(bcx,\n                                            *elem,\n                                            fldptr,"}, {"sha": "3d3b40e4ff2621123b0ad33400b855a6b4feae0a", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd", "patch": "@@ -301,10 +301,10 @@ pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n \n /**\n  * Begin initializing a new value of the given case of the given\n- * representation.  The fields should then be initialized with\n- * `trans_GEP` and stores.\n+ * representation.  The fields, if any, should then be initialized via\n+ * `trans_field_ptr`.\n  */\n-pub fn trans_set_discr(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n+pub fn trans_start_init(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n     match *r {\n         Unit(the_discr) => {\n             assert discr == the_discr;\n@@ -339,8 +339,8 @@ pub fn num_args(r: &Repr, discr: int) -> uint {\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_GEP(bcx: block, r: &Repr, val: ValueRef, discr: int, ix: uint)\n-    -> ValueRef {\n+pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n+                       ix: uint) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it will need to return a possibly-new bcx as well.\n@@ -354,16 +354,16 @@ pub fn trans_GEP(bcx: block, r: &Repr, val: ValueRef, discr: int, ix: uint)\n                 NonStruct => val,\n                 StructWithDtor | StructWithoutDtor => GEPi(bcx, val, [0, 0])\n             };\n-            struct_GEP(bcx, st, val, ix, false)\n+            struct_field_ptr(bcx, st, val, ix, false)\n         }\n         General(ref cases) => {\n-            struct_GEP(bcx, &cases[discr as uint],\n-                       GEPi(bcx, val, [0, 1]), ix, true)\n+            struct_field_ptr(bcx, &cases[discr as uint],\n+                                 GEPi(bcx, val, [0, 1]), ix, true)\n         }\n     }\n }\n \n-fn struct_GEP(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n+fn struct_field_ptr(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n               needs_cast: bool) -> ValueRef {\n     let ccx = bcx.ccx();\n \n@@ -501,10 +501,15 @@ pub fn const_get_discrim(ccx: @CrateContext, r: &Repr, val: ValueRef)\n     }\n }\n \n-/// Access a field of a constant value.\n-pub fn const_get_element(ccx: @CrateContext, r: &Repr, val: ValueRef,\n-                         _discr: int, ix: uint) -> ValueRef {\n-    // Not to be confused with common::const_get_elt.\n+/**\n+ * Extract a field of a constant value, as appropriate for its\n+ * representation.\n+ *\n+ * (Not to be confused with `common::const_get_elt`, which operates on\n+ * raw LLVM-level structs and arrays.)\n+ */\n+pub fn const_get_field(ccx: @CrateContext, r: &Repr, val: ValueRef,\n+                       _discr: int, ix: uint) -> ValueRef {\n     match *r {\n         Unit(*) | CEnum(*) => ccx.sess.bug(~\"element access in C-like enum \\\n                                              const\"),"}, {"sha": "8280243455d9b70322756fd79859d856928a4b87", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd", "patch": "@@ -630,7 +630,8 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         let mut cx = cx;\n \n         for variant.args.eachi |i, &arg| {\n-            cx = f(cx, adt::trans_GEP(cx, repr, av, variant.disr_val, i),\n+            cx = f(cx,\n+                   adt::trans_field_ptr(cx, repr, av, variant.disr_val, i),\n                    ty::subst_tps(tcx, tps, None, arg));\n         }\n         return cx;\n@@ -642,7 +643,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n           let repr = adt::represent_type(cx.ccx(), t);\n           do expr::with_field_tys(cx.tcx(), t, None) |discr, field_tys| {\n               for vec::eachi(field_tys) |i, field_ty| {\n-                  let llfld_a = adt::trans_GEP(cx, repr, av, discr, i);\n+                  let llfld_a = adt::trans_field_ptr(cx, repr, av, discr, i);\n                   cx = f(cx, llfld_a, field_ty.mt.ty);\n               }\n           }\n@@ -655,7 +656,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       ty::ty_tup(args) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           for vec::eachi(args) |i, arg| {\n-              let llfld_a = adt::trans_GEP(cx, repr, av, 0, i);\n+              let llfld_a = adt::trans_field_ptr(cx, repr, av, 0, i);\n               cx = f(cx, llfld_a, *arg);\n           }\n       }\n@@ -1864,9 +1865,10 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n                                 ty::node_id_to_type(ccx.tcx, enum_id));\n     let repr = adt::represent_type(ccx, enum_ty);\n \n-    adt::trans_set_discr(bcx, repr, fcx.llretptr, disr);\n+    adt::trans_start_init(bcx, repr, fcx.llretptr, disr);\n     for vec::eachi(args) |i, va| {\n-        let lldestptr = adt::trans_GEP(bcx, repr, fcx.llretptr, disr, i);\n+        let lldestptr = adt::trans_field_ptr(bcx, repr, fcx.llretptr,\n+                                             disr, i);\n \n         // If this argument to this function is a enum, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n@@ -1936,7 +1938,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n     let repr = adt::represent_type(ccx, tup_ty);\n \n     for fields.eachi |i, field| {\n-        let lldestptr = adt::trans_GEP(bcx, repr, fcx.llretptr, 0, i);\n+        let lldestptr = adt::trans_field_ptr(bcx, repr, fcx.llretptr, 0, i);\n         let llarg = match fcx.llargs.get(&field.node.id) {\n             local_mem(x) => x,\n             _ => {"}, {"sha": "d19ffe8cb211f73f1fc17442c232ba5ae367649b", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd", "patch": "@@ -245,7 +245,7 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n               let (bt, bv) = const_autoderef(cx, bt, bv);\n               do expr::with_field_tys(cx.tcx, bt, None) |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx, field, field_tys);\n-                  adt::const_get_element(cx, brepr, bv, discr, ix)\n+                  adt::const_get_field(cx, brepr, bv, discr, ix)\n               }\n           }\n "}, {"sha": "e6089914564179de1048f79b9d8282773e61524a", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd", "patch": "@@ -687,7 +687,7 @@ pub impl Datum {\n                         // rather than a ptr to the enum type.\n                         (\n                             Some(Datum {\n-                                val: adt::trans_GEP(bcx, repr, self.val,\n+                                val: adt::trans_field_ptr(bcx, repr, self.val,\n                                                     0, 0),\n                                 ty: ty,\n                                 mode: ByRef,\n@@ -729,7 +729,7 @@ pub impl Datum {\n                         // destructors.\n                         (\n                             Some(Datum {\n-                                val: adt::trans_GEP(bcx, repr, self.val,\n+                                val: adt::trans_field_ptr(bcx, repr, self.val,\n                                                     0, 0),\n                                 ty: ty,\n                                 mode: ByRef,"}, {"sha": "1dae9fccc62118829c302e0dc03a47f24a826f18", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd", "patch": "@@ -726,8 +726,8 @@ fn trans_def_dps_unadjusted(bcx: block, ref_expr: @ast::expr,\n                 // Nullary variant.\n                 let ty = expr_ty(bcx, ref_expr);\n                 let repr = adt::represent_type(ccx, ty);\n-                adt::trans_set_discr(bcx, repr, lldest,\n-                                     variant_info.disr_val);\n+                adt::trans_start_init(bcx, repr, lldest,\n+                                      variant_info.disr_val);\n                 return bcx;\n             }\n         }\n@@ -891,7 +891,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                 datum: do base_datum.get_element(bcx,\n                                                  field_tys[ix].mt.ty,\n                                                  ZeroMem) |srcval| {\n-                    adt::trans_GEP(bcx, repr, srcval, discr, ix)\n+                    adt::trans_field_ptr(bcx, repr, srcval, discr, ix)\n                 },\n                 bcx: bcx\n             }\n@@ -1240,9 +1240,9 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n         SaveIn(pos) => pos\n     };\n     let mut temp_cleanups = ~[];\n-    adt::trans_set_discr(bcx, repr, addr, discr);\n+    adt::trans_start_init(bcx, repr, addr, discr);\n     for fields.each |&(i, e)| {\n-        let dest = adt::trans_GEP(bcx, repr, addr, discr, i);\n+        let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n         let e_ty = expr_ty(bcx, e);\n         bcx = trans_into(bcx, e, SaveIn(dest));\n         add_clean_temp_mem(bcx, dest, e_ty);\n@@ -1254,9 +1254,9 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base.expr));\n         for base.fields.each |&(i, t)| {\n             let datum = do base_datum.get_element(bcx, t, ZeroMem) |srcval| {\n-                adt::trans_GEP(bcx, repr, srcval, discr, i)\n+                adt::trans_field_ptr(bcx, repr, srcval, discr, i)\n             };\n-            let dest = adt::trans_GEP(bcx, repr, addr, discr, i);\n+            let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n             bcx = datum.store_to(bcx, base.expr.id, INIT, dest);\n         }\n     }"}, {"sha": "b692ae67950ec98c6e75767057c36df202acd3af", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=1f9bc64bae3ddb282c2e82be2b5c0d2a403267cd", "patch": "@@ -507,7 +507,7 @@ pub fn trans_struct_drop(bcx: block,\n             ty::struct_mutable_fields(bcx.tcx(), class_did,\n                                               substs);\n         for vec::eachi(field_tys) |i, fld| {\n-            let llfld_a = adt::trans_GEP(bcx, repr, v0, 0, i);\n+            let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n             bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n         }\n "}]}