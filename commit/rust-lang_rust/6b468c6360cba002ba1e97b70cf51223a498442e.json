{"sha": "6b468c6360cba002ba1e97b70cf51223a498442e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiNDY4YzYzNjBjYmEwMDJiYTFlOTdiNzBjZjUxMjIzYTQ5ODQ0MmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-13T10:15:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-13T10:15:40Z"}, "message": "Auto merge of #60266 - albins:polonius-liveness, r=nikomatsakis\n\nFact generation for liveness calculations in Polonius\n\nThis PR tracks ongoing work to extend `rustc` with support for generating variable use, definition, and later also drop output for the Polonius solver, the whole of which is being tracked in [Polonius Issue #104](https://github.com/rust-lang/polonius/issues/104).", "tree": {"sha": "6af315a024a19f49c8a15242144ade988609a548", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6af315a024a19f49c8a15242144ade988609a548"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b468c6360cba002ba1e97b70cf51223a498442e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b468c6360cba002ba1e97b70cf51223a498442e", "html_url": "https://github.com/rust-lang/rust/commit/6b468c6360cba002ba1e97b70cf51223a498442e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b468c6360cba002ba1e97b70cf51223a498442e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a95e9704de0eeaecba55df102c1129e79a3a929", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a95e9704de0eeaecba55df102c1129e79a3a929", "html_url": "https://github.com/rust-lang/rust/commit/4a95e9704de0eeaecba55df102c1129e79a3a929"}, {"sha": "9d3c59d69750e07d9446339c4b733c925d3571bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3c59d69750e07d9446339c4b733c925d3571bc", "html_url": "https://github.com/rust-lang/rust/commit/9d3c59d69750e07d9446339c4b733c925d3571bc"}], "stats": {"total": 1077, "additions": 449, "deletions": 628}, "files": [{"sha": "5a20e6e102b55341023bbd81c758955d1062c972", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b468c6360cba002ba1e97b70cf51223a498442e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6b468c6360cba002ba1e97b70cf51223a498442e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6b468c6360cba002ba1e97b70cf51223a498442e", "patch": "@@ -2214,7 +2214,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"polonius-engine\"\n-version = \"0.7.0\"\n+version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"datafrog 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2686,7 +2686,7 @@ dependencies = [\n  \"measureme 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"polonius-engine 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"polonius-engine 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-rayon-core 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_apfloat 0.0.0\",\n@@ -3203,7 +3203,7 @@ dependencies = [\n  \"graphviz 0.0.0\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log_settings 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"polonius-engine 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"polonius-engine 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -4695,7 +4695,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum phf_generator 0.7.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09364cc93c159b8b06b1f4dd8a4398984503483891b0c26b867cf431fb132662\"\n \"checksum phf_shared 0.7.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"234f71a15de2288bcb7e3b6515828d22af7ec8598ee6d24c3b526fa0a80b67a0\"\n \"checksum pkg-config 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"676e8eb2b1b4c9043511a9b7bea0915320d7e502b0a079fb03f9635a5252b18c\"\n-\"checksum polonius-engine 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8b24942fee141ea45628484a453762bb7e515099c3ec05fbeb76b7bf57b1aeed\"\n+\"checksum polonius-engine 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f6b8a5defa2aef9ba4999aaa745fbc01c622ecea35964a306adc3e44be4f3b5b\"\n \"checksum precomputed-hash 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"925383efa346730478fb4838dbe9137d2a47675ad789c546d150a6e1dd4ab31c\"\n \"checksum pretty_assertions 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a029430f0d744bc3d15dd474d591bed2402b645d024583082b9f63bb936dac6\"\n \"checksum pretty_env_logger 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"df8b3f4e0475def7d9c2e5de8e5a1306949849761e107b360d03e98eafaffd61\""}, {"sha": "1677ef4b6079f03b2d17ee65ac296238e94678d2", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=6b468c6360cba002ba1e97b70cf51223a498442e", "patch": "@@ -19,9 +19,9 @@ lazy_static = \"1.0.0\"\n num_cpus = \"1.0\"\n scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n-polonius-engine = \"0.7.0\"\n rustc-rayon = \"0.2.0\"\n rustc-rayon-core = \"0.2.0\"\n+polonius-engine  = \"0.9.0\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_macros = { path = \"../librustc_macros\" }"}, {"sha": "783964c701ad5fec0db64581cda1d0c06a2629e5", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 225, "deletions": 511, "changes": 736, "blob_url": "https://github.com/rust-lang/rust/blob/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=6b468c6360cba002ba1e97b70cf51223a498442e", "patch": "@@ -9,6 +9,17 @@ use crate::hir::def_id::DefId;\n use crate::hir::{self, InlineAsm as HirInlineAsm};\n use crate::mir::interpret::{ConstValue, InterpError, Scalar};\n use crate::mir::visit::MirVisitable;\n+use crate::rustc_serialize as serialize;\n+use crate::ty::adjustment::PointerCast;\n+use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::layout::VariantIdx;\n+use crate::ty::print::{FmtPrinter, Printer};\n+use crate::ty::subst::{Subst, SubstsRef};\n+use crate::ty::{\n+    self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n+    UserTypeAnnotationIndex,\n+};\n+use polonius_engine::Atom;\n use rustc_data_structures::bit_set::BitMatrix;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n@@ -17,10 +28,9 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::sync::MappedReadGuard;\n use rustc_macros::HashStable;\n-use crate::rustc_serialize::{self as serialize};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n-use std::fmt::{self, Debug, Formatter, Write, Display};\n+use std::fmt::{self, Debug, Display, Formatter, Write};\n use std::iter::FusedIterator;\n use std::ops::{Index, IndexMut};\n use std::slice;\n@@ -29,15 +39,6 @@ use std::{iter, mem, option, u32};\n use syntax::ast::Name;\n use syntax::symbol::{InternedString, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n-use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use crate::ty::subst::{Subst, SubstsRef};\n-use crate::ty::layout::VariantIdx;\n-use crate::ty::{\n-    self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n-    UserTypeAnnotationIndex,\n-};\n-use crate::ty::print::{FmtPrinter, Printer};\n-use crate::ty::adjustment::{PointerCast};\n \n pub use crate::mir::interpret::AssertMessage;\n \n@@ -224,10 +225,7 @@ impl<'tcx> Body<'tcx> {\n     #[inline]\n     pub fn basic_blocks_and_local_decls_mut(\n         &mut self,\n-    ) -> (\n-        &mut IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n-        &mut LocalDecls<'tcx>,\n-    ) {\n+    ) -> (&mut IndexVec<BasicBlock, BasicBlockData<'tcx>>, &mut LocalDecls<'tcx>) {\n         self.cache.invalidate();\n         (&mut self.basic_blocks, &mut self.local_decls)\n     }\n@@ -259,16 +257,10 @@ impl<'tcx> Body<'tcx> {\n         let if_not_zero_locations = if loc.statement_index == 0 {\n             None\n         } else {\n-            Some(Location {\n-                block: loc.block,\n-                statement_index: loc.statement_index - 1,\n-            })\n+            Some(Location { block: loc.block, statement_index: loc.statement_index - 1 })\n         };\n \n-        if_zero_locations\n-            .into_iter()\n-            .flatten()\n-            .chain(if_not_zero_locations)\n+        if_zero_locations.into_iter().flatten().chain(if_not_zero_locations)\n     }\n \n     #[inline]\n@@ -406,10 +398,7 @@ impl<'tcx> Body<'tcx> {\n \n     /// Gets the location of the terminator for the given block\n     pub fn terminator_loc(&self, bb: BasicBlock) -> Location {\n-        Location {\n-            block: bb,\n-            statement_index: self[bb].statements.len(),\n-        }\n+        Location { block: bb, statement_index: self[bb].statements.len() }\n     }\n }\n \n@@ -508,8 +497,9 @@ impl From<Mutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd,\n-         Ord, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(\n+    Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, HashStable,\n+)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     Shared,\n@@ -600,6 +590,12 @@ newtype_index! {\n     }\n }\n \n+impl Atom for Local {\n+    fn index(self) -> usize {\n+        Idx::index(self)\n+    }\n+}\n+\n /// Classifies locals into categories. See `Body::local_kind`.\n #[derive(PartialEq, Eq, Debug, HashStable)]\n pub enum LocalKind {\n@@ -658,7 +654,7 @@ pub enum ImplicitSelfKind {\n     MutRef,\n     /// Represents when a function does not have a self argument or\n     /// when a function has a `self: X` argument.\n-    None\n+    None,\n }\n \n CloneTypeFoldableAndLiftImpls! { BindingForm<'tcx>, }\n@@ -889,8 +885,7 @@ impl<'tcx> LocalDecl<'tcx> {\n                 pat_span: _,\n             }))) => true,\n \n-            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(ImplicitSelfKind::Imm)))\n-                => true,\n+            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(ImplicitSelfKind::Imm))) => true,\n \n             _ => false,\n         }\n@@ -959,21 +954,13 @@ impl<'tcx> LocalDecl<'tcx> {\n     }\n \n     #[inline]\n-    fn new_local(\n-        ty: Ty<'tcx>,\n-        mutability: Mutability,\n-        internal: bool,\n-        span: Span,\n-    ) -> Self {\n+    fn new_local(ty: Ty<'tcx>, mutability: Mutability, internal: bool, span: Span) -> Self {\n         LocalDecl {\n             mutability,\n             ty,\n             user_ty: UserTypeProjections::none(),\n             name: None,\n-            source_info: SourceInfo {\n-                span,\n-                scope: OUTERMOST_SOURCE_SCOPE,\n-            },\n+            source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal,\n             is_user_variable: None,\n@@ -990,10 +977,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             mutability: Mutability::Mut,\n             ty: return_ty,\n             user_ty: UserTypeProjections::none(),\n-            source_info: SourceInfo {\n-                span,\n-                scope: OUTERMOST_SOURCE_SCOPE,\n-            },\n+            source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal: false,\n             is_block_tail: None,\n@@ -1025,10 +1009,7 @@ newtype_index! {\n \n impl BasicBlock {\n     pub fn start_location(self) -> Location {\n-        Location {\n-            block: self,\n-            statement_index: 0,\n-        }\n+        Location { block: self, statement_index: 0 }\n     }\n }\n \n@@ -1111,11 +1092,7 @@ pub enum TerminatorKind<'tcx> {\n     Unreachable,\n \n     /// Drop the Place\n-    Drop {\n-        location: Place<'tcx>,\n-        target: BasicBlock,\n-        unwind: Option<BasicBlock>,\n-    },\n+    Drop { location: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n \n     /// Drop the Place and assign the new value over it. This ensures\n     /// that the assignment to `P` occurs *even if* the destructor for\n@@ -1263,80 +1240,27 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | GeneratorDrop\n             | Return\n             | Unreachable\n-            | Call {\n-                destination: None,\n-                cleanup: None,\n-                ..\n-            } => None.into_iter().chain(&[]),\n+            | Call { destination: None, cleanup: None, .. } => None.into_iter().chain(&[]),\n             Goto { target: ref t }\n-            | Call {\n-                destination: None,\n-                cleanup: Some(ref t),\n-                ..\n-            }\n-            | Call {\n-                destination: Some((_, ref t)),\n-                cleanup: None,\n-                ..\n-            }\n-            | Yield {\n-                resume: ref t,\n-                drop: None,\n-                ..\n-            }\n-            | DropAndReplace {\n-                target: ref t,\n-                unwind: None,\n-                ..\n-            }\n-            | Drop {\n-                target: ref t,\n-                unwind: None,\n-                ..\n-            }\n-            | Assert {\n-                target: ref t,\n-                cleanup: None,\n-                ..\n+            | Call { destination: None, cleanup: Some(ref t), .. }\n+            | Call { destination: Some((_, ref t)), cleanup: None, .. }\n+            | Yield { resume: ref t, drop: None, .. }\n+            | DropAndReplace { target: ref t, unwind: None, .. }\n+            | Drop { target: ref t, unwind: None, .. }\n+            | Assert { target: ref t, cleanup: None, .. }\n+            | FalseUnwind { real_target: ref t, unwind: None } => Some(t).into_iter().chain(&[]),\n+            Call { destination: Some((_, ref t)), cleanup: Some(ref u), .. }\n+            | Yield { resume: ref t, drop: Some(ref u), .. }\n+            | DropAndReplace { target: ref t, unwind: Some(ref u), .. }\n+            | Drop { target: ref t, unwind: Some(ref u), .. }\n+            | Assert { target: ref t, cleanup: Some(ref u), .. }\n+            | FalseUnwind { real_target: ref t, unwind: Some(ref u) } => {\n+                Some(t).into_iter().chain(slice::from_ref(u))\n             }\n-            | FalseUnwind {\n-                real_target: ref t,\n-                unwind: None,\n-            } => Some(t).into_iter().chain(&[]),\n-            Call {\n-                destination: Some((_, ref t)),\n-                cleanup: Some(ref u),\n-                ..\n-            }\n-            | Yield {\n-                resume: ref t,\n-                drop: Some(ref u),\n-                ..\n-            }\n-            | DropAndReplace {\n-                target: ref t,\n-                unwind: Some(ref u),\n-                ..\n-            }\n-            | Drop {\n-                target: ref t,\n-                unwind: Some(ref u),\n-                ..\n-            }\n-            | Assert {\n-                target: ref t,\n-                cleanup: Some(ref u),\n-                ..\n-            }\n-            | FalseUnwind {\n-                real_target: ref t,\n-                unwind: Some(ref u),\n-            } => Some(t).into_iter().chain(slice::from_ref(u)),\n             SwitchInt { ref targets, .. } => None.into_iter().chain(&targets[..]),\n-            FalseEdges {\n-                ref real_target,\n-                ref imaginary_target,\n-            } => Some(real_target).into_iter().chain(slice::from_ref(imaginary_target)),\n+            FalseEdges { ref real_target, ref imaginary_target } => {\n+                Some(real_target).into_iter().chain(slice::from_ref(imaginary_target))\n+            }\n         }\n     }\n \n@@ -1348,84 +1272,29 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | GeneratorDrop\n             | Return\n             | Unreachable\n-            | Call {\n-                destination: None,\n-                cleanup: None,\n-                ..\n-            } => None.into_iter().chain(&mut []),\n+            | Call { destination: None, cleanup: None, .. } => None.into_iter().chain(&mut []),\n             Goto { target: ref mut t }\n-            | Call {\n-                destination: None,\n-                cleanup: Some(ref mut t),\n-                ..\n-            }\n-            | Call {\n-                destination: Some((_, ref mut t)),\n-                cleanup: None,\n-                ..\n+            | Call { destination: None, cleanup: Some(ref mut t), .. }\n+            | Call { destination: Some((_, ref mut t)), cleanup: None, .. }\n+            | Yield { resume: ref mut t, drop: None, .. }\n+            | DropAndReplace { target: ref mut t, unwind: None, .. }\n+            | Drop { target: ref mut t, unwind: None, .. }\n+            | Assert { target: ref mut t, cleanup: None, .. }\n+            | FalseUnwind { real_target: ref mut t, unwind: None } => {\n+                Some(t).into_iter().chain(&mut [])\n             }\n-            | Yield {\n-                resume: ref mut t,\n-                drop: None,\n-                ..\n+            Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut u), .. }\n+            | Yield { resume: ref mut t, drop: Some(ref mut u), .. }\n+            | DropAndReplace { target: ref mut t, unwind: Some(ref mut u), .. }\n+            | Drop { target: ref mut t, unwind: Some(ref mut u), .. }\n+            | Assert { target: ref mut t, cleanup: Some(ref mut u), .. }\n+            | FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) } => {\n+                Some(t).into_iter().chain(slice::from_mut(u))\n             }\n-            | DropAndReplace {\n-                target: ref mut t,\n-                unwind: None,\n-                ..\n+            SwitchInt { ref mut targets, .. } => None.into_iter().chain(&mut targets[..]),\n+            FalseEdges { ref mut real_target, ref mut imaginary_target } => {\n+                Some(real_target).into_iter().chain(slice::from_mut(imaginary_target))\n             }\n-            | Drop {\n-                target: ref mut t,\n-                unwind: None,\n-                ..\n-            }\n-            | Assert {\n-                target: ref mut t,\n-                cleanup: None,\n-                ..\n-            }\n-            | FalseUnwind {\n-                real_target: ref mut t,\n-                unwind: None,\n-            } => Some(t).into_iter().chain(&mut []),\n-            Call {\n-                destination: Some((_, ref mut t)),\n-                cleanup: Some(ref mut u),\n-                ..\n-            }\n-            | Yield {\n-                resume: ref mut t,\n-                drop: Some(ref mut u),\n-                ..\n-            }\n-            | DropAndReplace {\n-                target: ref mut t,\n-                unwind: Some(ref mut u),\n-                ..\n-            }\n-            | Drop {\n-                target: ref mut t,\n-                unwind: Some(ref mut u),\n-                ..\n-            }\n-            | Assert {\n-                target: ref mut t,\n-                cleanup: Some(ref mut u),\n-                ..\n-            }\n-            | FalseUnwind {\n-                real_target: ref mut t,\n-                unwind: Some(ref mut u),\n-            } => Some(t).into_iter().chain(slice::from_mut(u)),\n-            SwitchInt {\n-                ref mut targets, ..\n-            } => None.into_iter().chain(&mut targets[..]),\n-            FalseEdges {\n-                ref mut real_target,\n-                ref mut imaginary_target,\n-            } => Some(real_target)\n-                .into_iter()\n-                .chain(slice::from_mut(imaginary_target)),\n         }\n     }\n \n@@ -1440,14 +1309,8 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::SwitchInt { .. }\n             | TerminatorKind::FalseEdges { .. } => None,\n-            TerminatorKind::Call {\n-                cleanup: ref unwind,\n-                ..\n-            }\n-            | TerminatorKind::Assert {\n-                cleanup: ref unwind,\n-                ..\n-            }\n+            TerminatorKind::Call { cleanup: ref unwind, .. }\n+            | TerminatorKind::Assert { cleanup: ref unwind, .. }\n             | TerminatorKind::DropAndReplace { ref unwind, .. }\n             | TerminatorKind::Drop { ref unwind, .. }\n             | TerminatorKind::FalseUnwind { ref unwind, .. } => Some(unwind),\n@@ -1465,14 +1328,8 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | TerminatorKind::Yield { .. }\n             | TerminatorKind::SwitchInt { .. }\n             | TerminatorKind::FalseEdges { .. } => None,\n-            TerminatorKind::Call {\n-                cleanup: ref mut unwind,\n-                ..\n-            }\n-            | TerminatorKind::Assert {\n-                cleanup: ref mut unwind,\n-                ..\n-            }\n+            TerminatorKind::Call { cleanup: ref mut unwind, .. }\n+            | TerminatorKind::Assert { cleanup: ref mut unwind, .. }\n             | TerminatorKind::DropAndReplace { ref mut unwind, .. }\n             | TerminatorKind::Drop { ref mut unwind, .. }\n             | TerminatorKind::FalseUnwind { ref mut unwind, .. } => Some(unwind),\n@@ -1482,11 +1339,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n \n impl<'tcx> BasicBlockData<'tcx> {\n     pub fn new(terminator: Option<Terminator<'tcx>>) -> BasicBlockData<'tcx> {\n-        BasicBlockData {\n-            statements: vec![],\n-            terminator,\n-            is_cleanup: false,\n-        }\n+        BasicBlockData { statements: vec![], terminator, is_cleanup: false }\n     }\n \n     /// Accessor for terminator.\n@@ -1548,10 +1401,7 @@ impl<'tcx> BasicBlockData<'tcx> {\n         self.statements.resize(\n             gap.end,\n             Statement {\n-                source_info: SourceInfo {\n-                    span: DUMMY_SP,\n-                    scope: OUTERMOST_SOURCE_SCOPE,\n-                },\n+                source_info: SourceInfo { span: DUMMY_SP, scope: OUTERMOST_SOURCE_SCOPE },\n                 kind: StatementKind::Nop,\n             },\n         );\n@@ -1610,27 +1460,18 @@ impl<'tcx> TerminatorKind<'tcx> {\n         use self::TerminatorKind::*;\n         match *self {\n             Goto { .. } => write!(fmt, \"goto\"),\n-            SwitchInt {\n-                discr: ref place, ..\n-            } => write!(fmt, \"switchInt({:?})\", place),\n+            SwitchInt { discr: ref place, .. } => write!(fmt, \"switchInt({:?})\", place),\n             Return => write!(fmt, \"return\"),\n             GeneratorDrop => write!(fmt, \"generator_drop\"),\n             Resume => write!(fmt, \"resume\"),\n             Abort => write!(fmt, \"abort\"),\n             Yield { ref value, .. } => write!(fmt, \"_1 = suspend({:?})\", value),\n             Unreachable => write!(fmt, \"unreachable\"),\n             Drop { ref location, .. } => write!(fmt, \"drop({:?})\", location),\n-            DropAndReplace {\n-                ref location,\n-                ref value,\n-                ..\n-            } => write!(fmt, \"replace({:?} <- {:?})\", location, value),\n-            Call {\n-                ref func,\n-                ref args,\n-                ref destination,\n-                ..\n-            } => {\n+            DropAndReplace { ref location, ref value, .. } => {\n+                write!(fmt, \"replace({:?} <- {:?})\", location, value)\n+            }\n+            Call { ref func, ref args, ref destination, .. } => {\n                 if let Some((ref destination, _)) = *destination {\n                     write!(fmt, \"{:?} = \", destination)?;\n                 }\n@@ -1643,12 +1484,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 }\n                 write!(fmt, \")\")\n             }\n-            Assert {\n-                ref cond,\n-                expected,\n-                ref msg,\n-                ..\n-            } => {\n+            Assert { ref cond, expected, ref msg, .. } => {\n                 write!(fmt, \"assert(\")?;\n                 if !expected {\n                     write!(fmt, \"!\")?;\n@@ -1666,69 +1502,41 @@ impl<'tcx> TerminatorKind<'tcx> {\n         match *self {\n             Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n             Goto { .. } => vec![\"\".into()],\n-            SwitchInt {\n-                ref values,\n-                switch_ty,\n-                ..\n-            } => {\n-                ty::tls::with(|tcx| {\n-                    let param_env = ty::ParamEnv::empty();\n-                    let switch_ty = tcx.lift_to_global(&switch_ty).unwrap();\n-                    let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n-                    values\n-                        .iter()\n-                        .map(|&u| {\n-                            tcx.mk_const(ty::Const {\n-                                val: ConstValue::Scalar(\n-                                    Scalar::from_uint(u, size).into(),\n-                                ),\n-                                ty: switch_ty,\n-                            }).to_string().into()\n-                        }).chain(iter::once(\"otherwise\".into()))\n-                        .collect()\n-                })\n+            SwitchInt { ref values, switch_ty, .. } => ty::tls::with(|tcx| {\n+                let param_env = ty::ParamEnv::empty();\n+                let switch_ty = tcx.lift_to_global(&switch_ty).unwrap();\n+                let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n+                values\n+                    .iter()\n+                    .map(|&u| {\n+                        tcx.mk_const(ty::Const {\n+                            val: ConstValue::Scalar(Scalar::from_uint(u, size).into()),\n+                            ty: switch_ty,\n+                        })\n+                        .to_string()\n+                        .into()\n+                    })\n+                    .chain(iter::once(\"otherwise\".into()))\n+                    .collect()\n+            }),\n+            Call { destination: Some(_), cleanup: Some(_), .. } => {\n+                vec![\"return\".into(), \"unwind\".into()]\n             }\n-            Call {\n-                destination: Some(_),\n-                cleanup: Some(_),\n-                ..\n-            } => vec![\"return\".into(), \"unwind\".into()],\n-            Call {\n-                destination: Some(_),\n-                cleanup: None,\n-                ..\n-            } => vec![\"return\".into()],\n-            Call {\n-                destination: None,\n-                cleanup: Some(_),\n-                ..\n-            } => vec![\"unwind\".into()],\n-            Call {\n-                destination: None,\n-                cleanup: None,\n-                ..\n-            } => vec![],\n+            Call { destination: Some(_), cleanup: None, .. } => vec![\"return\".into()],\n+            Call { destination: None, cleanup: Some(_), .. } => vec![\"unwind\".into()],\n+            Call { destination: None, cleanup: None, .. } => vec![],\n             Yield { drop: Some(_), .. } => vec![\"resume\".into(), \"drop\".into()],\n             Yield { drop: None, .. } => vec![\"resume\".into()],\n             DropAndReplace { unwind: None, .. } | Drop { unwind: None, .. } => {\n                 vec![\"return\".into()]\n             }\n-            DropAndReplace {\n-                unwind: Some(_), ..\n+            DropAndReplace { unwind: Some(_), .. } | Drop { unwind: Some(_), .. } => {\n+                vec![\"return\".into(), \"unwind\".into()]\n             }\n-            | Drop {\n-                unwind: Some(_), ..\n-            } => vec![\"return\".into(), \"unwind\".into()],\n             Assert { cleanup: None, .. } => vec![\"\".into()],\n             Assert { .. } => vec![\"success\".into(), \"unwind\".into()],\n-            FalseEdges {\n-                ..\n-            } => {\n-                vec![\"real\".into(), \"imaginary\".into()]\n-            }\n-            FalseUnwind {\n-                unwind: Some(_), ..\n-            } => vec![\"real\".into(), \"cleanup\".into()],\n+            FalseEdges { .. } => vec![\"real\".into(), \"imaginary\".into()],\n+            FalseUnwind { unwind: Some(_), .. } => vec![\"real\".into(), \"cleanup\".into()],\n             FalseUnwind { unwind: None, .. } => vec![\"real\".into()],\n         }\n     }\n@@ -1778,10 +1586,7 @@ pub enum StatementKind<'tcx> {\n     FakeRead(FakeReadCause, Place<'tcx>),\n \n     /// Write the discriminant for a variant to the enum Place.\n-    SetDiscriminant {\n-        place: Place<'tcx>,\n-        variant_index: VariantIdx,\n-    },\n+    SetDiscriminant { place: Place<'tcx>, variant_index: VariantIdx },\n \n     /// Start a live range for the storage of the local.\n     StorageLive(Local),\n@@ -1878,24 +1683,25 @@ impl<'tcx> Debug for Statement<'tcx> {\n         match self.kind {\n             Assign(ref place, ref rv) => write!(fmt, \"{:?} = {:?}\", place, rv),\n             FakeRead(ref cause, ref place) => write!(fmt, \"FakeRead({:?}, {:?})\", cause, place),\n-            Retag(ref kind, ref place) =>\n-                write!(fmt, \"Retag({}{:?})\",\n-                    match kind {\n-                        RetagKind::FnEntry => \"[fn entry] \",\n-                        RetagKind::TwoPhase => \"[2phase] \",\n-                        RetagKind::Raw => \"[raw] \",\n-                        RetagKind::Default => \"\",\n-                    },\n-                    place,\n-                ),\n+            Retag(ref kind, ref place) => write!(\n+                fmt,\n+                \"Retag({}{:?})\",\n+                match kind {\n+                    RetagKind::FnEntry => \"[fn entry] \",\n+                    RetagKind::TwoPhase => \"[2phase] \",\n+                    RetagKind::Raw => \"[raw] \",\n+                    RetagKind::Default => \"\",\n+                },\n+                place,\n+            ),\n             StorageLive(ref place) => write!(fmt, \"StorageLive({:?})\", place),\n             StorageDead(ref place) => write!(fmt, \"StorageDead({:?})\", place),\n-            SetDiscriminant {\n-                ref place,\n-                variant_index,\n-            } => write!(fmt, \"discriminant({:?}) = {:?}\", place, variant_index),\n-            InlineAsm(ref asm) =>\n-                write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm.asm, asm.outputs, asm.inputs),\n+            SetDiscriminant { ref place, variant_index } => {\n+                write!(fmt, \"discriminant({:?}) = {:?}\", place, variant_index)\n+            }\n+            InlineAsm(ref asm) => {\n+                write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm.asm, asm.outputs, asm.inputs)\n+            }\n             AscribeUserType(ref place, ref variance, ref c_ty) => {\n                 write!(fmt, \"AscribeUserType({:?}, {:?}, {:?})\", place, variance, c_ty)\n             }\n@@ -1909,15 +1715,19 @@ impl<'tcx> Debug for Statement<'tcx> {\n \n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(\n+    Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n+)]\n pub enum Place<'tcx> {\n     Base(PlaceBase<'tcx>),\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n     Projection(Box<Projection<'tcx>>),\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(\n+    Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n+)]\n pub enum PlaceBase<'tcx> {\n     /// local variable\n     Local(Local),\n@@ -1933,7 +1743,9 @@ pub struct Static<'tcx> {\n     pub kind: StaticKind,\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, RustcEncodable, RustcDecodable)]\n+#[derive(\n+    Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, RustcEncodable, RustcDecodable,\n+)]\n pub enum StaticKind {\n     Promoted(Promoted),\n     Static(DefId),\n@@ -1945,15 +1757,17 @@ impl_stable_hash_for!(struct Static<'tcx> {\n });\n \n /// The `Projection` data structure defines things of the form `base.x`, `*b` or `b[index]`.\n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord,\n-         Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(\n+    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n+)]\n pub struct Projection<'tcx> {\n     pub base: Place<'tcx>,\n     pub elem: PlaceElem<'tcx>,\n- }\n+}\n \n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord,\n-         Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(\n+    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n+)]\n pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(Field, T),\n@@ -2026,7 +1840,8 @@ impl<'tcx> Place<'tcx> {\n     pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx) -> Place<'tcx> {\n         self.elem(ProjectionElem::Downcast(\n             Some(adt_def.variants[variant_index].ident.name),\n-            variant_index))\n+            variant_index,\n+        ))\n     }\n \n     pub fn downcast_unnamed(self, variant_index: VariantIdx) -> Place<'tcx> {\n@@ -2047,8 +1862,8 @@ impl<'tcx> Place<'tcx> {\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n         match self {\n-            Place::Base(PlaceBase::Local(local)) |\n-            Place::Projection(box Projection {\n+            Place::Base(PlaceBase::Local(local))\n+            | Place::Projection(box Projection {\n                 base: Place::Base(PlaceBase::Local(local)),\n                 elem: ProjectionElem::Deref,\n             }) => Some(*local),\n@@ -2083,13 +1898,9 @@ impl<'tcx> Place<'tcx> {\n         op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n     ) -> R {\n         match self {\n-            Place::Projection(interior) => interior.base.iterate2(\n-                &Projections::List {\n-                    projection: interior,\n-                    next,\n-                },\n-                op,\n-            ),\n+            Place::Projection(interior) => {\n+                interior.base.iterate2(&Projections::List { projection: interior, next }, op)\n+            }\n \n             Place::Base(base) => op(base, next.iter()),\n         }\n@@ -2119,10 +1930,7 @@ impl From<Local> for PlaceBase<'_> {\n pub enum Projections<'p, 'tcx> {\n     Empty,\n \n-    List {\n-        projection: &'p Projection<'tcx>,\n-        next: &'p Projections<'p, 'tcx>,\n-    }\n+    List { projection: &'p Projection<'tcx>, next: &'p Projections<'p, 'tcx> },\n }\n \n impl<'p, 'tcx> Projections<'p, 'tcx> {\n@@ -2181,16 +1989,15 @@ impl<'tcx> Debug for Place<'tcx> {\n             let projs_vec: Vec<_> = place_projections.collect();\n             for projection in projs_vec.iter().rev() {\n                 match projection.elem {\n-                    ProjectionElem::Downcast(_, _) |\n-                    ProjectionElem::Field(_, _) => {\n+                    ProjectionElem::Downcast(_, _) | ProjectionElem::Field(_, _) => {\n                         write!(fmt, \"(\").unwrap();\n                     }\n                     ProjectionElem::Deref => {\n                         write!(fmt, \"(*\").unwrap();\n                     }\n-                    ProjectionElem::Index(_) |\n-                    ProjectionElem::ConstantIndex { .. } |\n-                    ProjectionElem::Subslice { .. } => {}\n+                    ProjectionElem::Index(_)\n+                    | ProjectionElem::ConstantIndex { .. }\n+                    | ProjectionElem::Subslice { .. } => {}\n                 }\n             }\n         });\n@@ -2215,18 +2022,10 @@ impl<'tcx> Debug for Place<'tcx> {\n                     ProjectionElem::Index(ref index) => {\n                         write!(fmt, \"[{:?}]\", index)?;\n                     }\n-                    ProjectionElem::ConstantIndex {\n-                        offset,\n-                        min_length,\n-                        from_end: false,\n-                    } => {\n+                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } => {\n                         write!(fmt, \"[{:?} of {:?}]\", offset, min_length)?;\n                     }\n-                    ProjectionElem::ConstantIndex {\n-                        offset,\n-                        min_length,\n-                        from_end: true,\n-                    } => {\n+                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } => {\n                         write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n                     }\n                     ProjectionElem::Subslice { from, to } if to == 0 => {\n@@ -2251,21 +2050,11 @@ impl Debug for PlaceBase<'_> {\n         match *self {\n             PlaceBase::Local(id) => write!(fmt, \"{:?}\", id),\n             PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static(def_id) }) => {\n-                write!(\n-                    fmt,\n-                    \"({}: {:?})\",\n-                    ty::tls::with(|tcx| tcx.def_path_str(def_id)),\n-                    ty\n-                )\n-            },\n+                write!(fmt, \"({}: {:?})\", ty::tls::with(|tcx| tcx.def_path_str(def_id)), ty)\n+            }\n             PlaceBase::Static(box self::Static { ty, kind: StaticKind::Promoted(promoted) }) => {\n-                write!(\n-                    fmt,\n-                    \"({:?}: {:?})\",\n-                    promoted,\n-                    ty\n-                )\n-            },\n+                write!(fmt, \"({:?}: {:?})\", promoted, ty)\n+            }\n         }\n     }\n }\n@@ -2396,7 +2185,6 @@ pub enum Rvalue<'tcx> {\n     Aggregate(Box<AggregateKind<'tcx>>, Vec<Operand<'tcx>>),\n }\n \n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum CastKind {\n     Misc,\n@@ -2414,13 +2202,7 @@ pub enum AggregateKind<'tcx> {\n     /// active field number and is present only for union expressions\n     /// -- e.g., for a union expression `SomeUnion { c: .. }`, the\n     /// active field index would identity the field `c`\n-    Adt(\n-        &'tcx AdtDef,\n-        VariantIdx,\n-        SubstsRef<'tcx>,\n-        Option<UserTypeAnnotationIndex>,\n-        Option<usize>,\n-    ),\n+    Adt(&'tcx AdtDef, VariantIdx, SubstsRef<'tcx>, Option<UserTypeAnnotationIndex>, Option<usize>),\n \n     Closure(DefId, ClosureSubsts<'tcx>),\n     Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n@@ -2598,8 +2380,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n                         if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n-                            let name = format!(\"[generator@{:?}]\",\n-                                               tcx.hir().span(hir_id));\n+                            let name = format!(\"[generator@{:?}]\", tcx.hir().span(hir_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             if let Some(upvars) = tcx.upvars(def_id) {\n@@ -2690,30 +2471,26 @@ impl<'tcx> UserTypeProjections {\n         UserTypeProjections { contents: vec![] }\n     }\n \n-    pub fn from_projections(projs: impl Iterator<Item=(UserTypeProjection, Span)>) -> Self {\n+    pub fn from_projections(projs: impl Iterator<Item = (UserTypeProjection, Span)>) -> Self {\n         UserTypeProjections { contents: projs.collect() }\n     }\n \n-    pub fn projections_and_spans(&self) -> impl Iterator<Item=&(UserTypeProjection, Span)> {\n+    pub fn projections_and_spans(&self) -> impl Iterator<Item = &(UserTypeProjection, Span)> {\n         self.contents.iter()\n     }\n \n-    pub fn projections(&self) -> impl Iterator<Item=&UserTypeProjection> {\n+    pub fn projections(&self) -> impl Iterator<Item = &UserTypeProjection> {\n         self.contents.iter().map(|&(ref user_type, _span)| user_type)\n     }\n \n-    pub fn push_projection(\n-        mut self,\n-        user_ty: &UserTypeProjection,\n-        span: Span,\n-    ) -> Self {\n+    pub fn push_projection(mut self, user_ty: &UserTypeProjection, span: Span) -> Self {\n         self.contents.push((user_ty.clone(), span));\n         self\n     }\n \n     fn map_projections(\n         mut self,\n-        mut f: impl FnMut(UserTypeProjection) -> UserTypeProjection\n+        mut f: impl FnMut(UserTypeProjection) -> UserTypeProjection,\n     ) -> Self {\n         self.contents = self.contents.drain(..).map(|(proj, span)| (f(proj), span)).collect();\n         self\n@@ -2735,12 +2512,7 @@ impl<'tcx> UserTypeProjections {\n         self.map_projections(|pat_ty_proj| pat_ty_proj.leaf(field))\n     }\n \n-    pub fn variant(\n-        self,\n-        adt_def: &'tcx AdtDef,\n-        variant_index: VariantIdx,\n-        field: Field,\n-    ) -> Self {\n+    pub fn variant(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx, field: Field) -> Self {\n         self.map_projections(|pat_ty_proj| pat_ty_proj.variant(adt_def, variant_index, field))\n     }\n }\n@@ -2766,7 +2538,7 @@ pub struct UserTypeProjection {\n     pub projs: Vec<ProjectionKind>,\n }\n \n-impl Copy for ProjectionKind { }\n+impl Copy for ProjectionKind {}\n \n impl UserTypeProjection {\n     pub(crate) fn index(mut self) -> Self {\n@@ -2797,7 +2569,8 @@ impl UserTypeProjection {\n     ) -> Self {\n         self.projs.push(ProjectionElem::Downcast(\n             Some(adt_def.variants[variant_index].ident.name),\n-            variant_index));\n+            variant_index,\n+        ));\n         self.projs.push(ProjectionElem::Field(field, ()));\n         self\n     }\n@@ -2810,15 +2583,15 @@ impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection {\n         use crate::mir::ProjectionElem::*;\n \n         let base = self.base.fold_with(folder);\n-        let projs: Vec<_> = self.projs\n+        let projs: Vec<_> = self\n+            .projs\n             .iter()\n-            .map(|elem| {\n-                match elem {\n-                    Deref => Deref,\n-                    Field(f, ()) => Field(f.clone(), ()),\n-                    Index(()) => Index(()),\n-                    elem => elem.clone(),\n-                }})\n+            .map(|elem| match elem {\n+                Deref => Deref,\n+                Field(f, ()) => Field(f.clone(), ()),\n+                Index(()) => Index(()),\n+                elem => elem.clone(),\n+            })\n             .collect();\n \n         UserTypeProjection { base, projs }\n@@ -2911,20 +2684,14 @@ impl fmt::Debug for Location {\n }\n \n impl Location {\n-    pub const START: Location = Location {\n-        block: START_BLOCK,\n-        statement_index: 0,\n-    };\n+    pub const START: Location = Location { block: START_BLOCK, statement_index: 0 };\n \n     /// Returns the location immediately after this one within the enclosing block.\n     ///\n     /// Note that if this location represents a terminator, then the\n     /// resulting location would be out of bounds and invalid.\n     pub fn successor_within_block(&self) -> Location {\n-        Location {\n-            block: self.block,\n-            statement_index: self.statement_index + 1,\n-        }\n+        Location { block: self.block, statement_index: self.statement_index + 1 }\n     }\n \n     /// Returns `true` if `other` is earlier in the control flow graph than `self`.\n@@ -3114,8 +2881,19 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n /// order of the category, thereby influencing diagnostic output.\n ///\n /// See also [rustc_mir::borrow_check::nll::constraints]\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord,\n-         Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(\n+    Copy,\n+    Clone,\n+    Debug,\n+    Eq,\n+    PartialEq,\n+    PartialOrd,\n+    Ord,\n+    Hash,\n+    RustcEncodable,\n+    RustcDecodable,\n+    HashStable,\n+)]\n pub enum ConstraintCategory {\n     Return,\n     Yield,\n@@ -3278,56 +3056,27 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n \n         let kind = match self.kind {\n             Goto { target } => Goto { target },\n-            SwitchInt {\n-                ref discr,\n-                switch_ty,\n-                ref values,\n-                ref targets,\n-            } => SwitchInt {\n+            SwitchInt { ref discr, switch_ty, ref values, ref targets } => SwitchInt {\n                 discr: discr.fold_with(folder),\n                 switch_ty: switch_ty.fold_with(folder),\n                 values: values.clone(),\n                 targets: targets.clone(),\n             },\n-            Drop {\n-                ref location,\n-                target,\n-                unwind,\n-            } => Drop {\n-                location: location.fold_with(folder),\n-                target,\n-                unwind,\n-            },\n-            DropAndReplace {\n-                ref location,\n-                ref value,\n-                target,\n-                unwind,\n-            } => DropAndReplace {\n+            Drop { ref location, target, unwind } => {\n+                Drop { location: location.fold_with(folder), target, unwind }\n+            }\n+            DropAndReplace { ref location, ref value, target, unwind } => DropAndReplace {\n                 location: location.fold_with(folder),\n                 value: value.fold_with(folder),\n                 target,\n                 unwind,\n             },\n-            Yield {\n-                ref value,\n-                resume,\n-                drop,\n-            } => Yield {\n-                value: value.fold_with(folder),\n-                resume: resume,\n-                drop: drop,\n-            },\n-            Call {\n-                ref func,\n-                ref args,\n-                ref destination,\n-                cleanup,\n-                from_hir_call,\n-            } => {\n-                let dest = destination\n-                    .as_ref()\n-                    .map(|&(ref loc, dest)| (loc.fold_with(folder), dest));\n+            Yield { ref value, resume, drop } => {\n+                Yield { value: value.fold_with(folder), resume: resume, drop: drop }\n+            }\n+            Call { ref func, ref args, ref destination, cleanup, from_hir_call } => {\n+                let dest =\n+                    destination.as_ref().map(|&(ref loc, dest)| (loc.fold_with(folder), dest));\n \n                 Call {\n                     func: func.fold_with(folder),\n@@ -3337,13 +3086,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                     from_hir_call,\n                 }\n             }\n-            Assert {\n-                ref cond,\n-                expected,\n-                ref msg,\n-                target,\n-                cleanup,\n-            } => {\n+            Assert { ref cond, expected, ref msg, target, cleanup } => {\n                 let msg = if let InterpError::BoundsCheck { ref len, ref index } = *msg {\n                     InterpError::BoundsCheck {\n                         len: len.fold_with(folder),\n@@ -3352,72 +3095,42 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 } else {\n                     msg.clone()\n                 };\n-                Assert {\n-                    cond: cond.fold_with(folder),\n-                    expected,\n-                    msg,\n-                    target,\n-                    cleanup,\n-                }\n+                Assert { cond: cond.fold_with(folder), expected, msg, target, cleanup }\n             }\n             GeneratorDrop => GeneratorDrop,\n             Resume => Resume,\n             Abort => Abort,\n             Return => Return,\n             Unreachable => Unreachable,\n-            FalseEdges {\n-                real_target,\n-                imaginary_target,\n-            } => FalseEdges {\n-                real_target,\n-                imaginary_target,\n-            },\n-            FalseUnwind {\n-                real_target,\n-                unwind,\n-            } => FalseUnwind {\n-                real_target,\n-                unwind,\n-            },\n+            FalseEdges { real_target, imaginary_target } => {\n+                FalseEdges { real_target, imaginary_target }\n+            }\n+            FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n         };\n-        Terminator {\n-            source_info: self.source_info,\n-            kind,\n-        }\n+        Terminator { source_info: self.source_info, kind }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         use crate::mir::TerminatorKind::*;\n \n         match self.kind {\n-            SwitchInt {\n-                ref discr,\n-                switch_ty,\n-                ..\n-            } => discr.visit_with(visitor) || switch_ty.visit_with(visitor),\n+            SwitchInt { ref discr, switch_ty, .. } => {\n+                discr.visit_with(visitor) || switch_ty.visit_with(visitor)\n+            }\n             Drop { ref location, .. } => location.visit_with(visitor),\n-            DropAndReplace {\n-                ref location,\n-                ref value,\n-                ..\n-            } => location.visit_with(visitor) || value.visit_with(visitor),\n+            DropAndReplace { ref location, ref value, .. } => {\n+                location.visit_with(visitor) || value.visit_with(visitor)\n+            }\n             Yield { ref value, .. } => value.visit_with(visitor),\n-            Call {\n-                ref func,\n-                ref args,\n-                ref destination,\n-                ..\n-            } => {\n+            Call { ref func, ref args, ref destination, .. } => {\n                 let dest = if let Some((ref loc, _)) = *destination {\n                     loc.visit_with(visitor)\n                 } else {\n                     false\n                 };\n                 dest || func.visit_with(visitor) || args.visit_with(visitor)\n             }\n-            Assert {\n-                ref cond, ref msg, ..\n-            } => {\n+            Assert { ref cond, ref msg, .. } => {\n                 if cond.visit_with(visitor) {\n                     if let InterpError::BoundsCheck { ref len, ref index } = *msg {\n                         len.visit_with(visitor) || index.visit_with(visitor)\n@@ -3564,11 +3277,12 @@ impl<'tcx> TypeFoldable<'tcx> for Projection<'tcx> {\n     fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n         use crate::mir::ProjectionElem::*;\n \n-        self.base.visit_with(visitor) || match self.elem {\n-            Field(_, ref ty) => ty.visit_with(visitor),\n-            Index(ref v) => v.visit_with(visitor),\n-            _ => false,\n-        }\n+        self.base.visit_with(visitor)\n+            || match self.elem {\n+                Field(_, ref ty) => ty.visit_with(visitor),\n+                Index(ref v) => v.visit_with(visitor),\n+                _ => false,\n+            }\n     }\n }\n "}, {"sha": "2adbd03b24ff1ede13b96b157dce7e957d21dfee", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=6b468c6360cba002ba1e97b70cf51223a498442e", "patch": "@@ -15,7 +15,7 @@ either = \"1.5.0\"\n dot = { path = \"../libgraphviz\", package = \"graphviz\" }\n log = \"0.4\"\n log_settings = \"0.1.1\"\n-polonius-engine = \"0.7.0\"\n+polonius-engine  = \"0.9.0\"\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "bb217a1f965e260b7cdb5ba94a71f6a511af90b9", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=6b468c6360cba002ba1e97b70cf51223a498442e", "patch": "@@ -3,7 +3,7 @@\n //! FIXME: this might be better as a \"generic\" fixed-point combinator,\n //! but is not as ugly as it is right now.\n \n-use rustc::mir::{BasicBlock, Location};\n+use rustc::mir::{BasicBlock, Local, Location};\n use rustc::ty::RegionVid;\n use rustc_data_structures::bit_set::BitIter;\n \n@@ -15,35 +15,32 @@ use crate::dataflow::indexes::BorrowIndex;\n use crate::dataflow::move_paths::HasMoveData;\n use crate::dataflow::Borrows;\n use crate::dataflow::EverInitializedPlaces;\n-use crate::dataflow::{FlowAtLocation, FlowsAtLocation};\n use crate::dataflow::MaybeUninitializedPlaces;\n+use crate::dataflow::{FlowAtLocation, FlowsAtLocation};\n use either::Either;\n use std::fmt;\n use std::rc::Rc;\n \n+crate type PoloniusOutput = Output<RegionVid, BorrowIndex, LocationIndex, Local>;\n+\n // (forced to be `pub` due to its use as an associated type below.)\n crate struct Flows<'b, 'tcx> {\n     borrows: FlowAtLocation<'tcx, Borrows<'b, 'tcx>>,\n     pub uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'tcx>>,\n     pub ever_inits: FlowAtLocation<'tcx, EverInitializedPlaces<'b, 'tcx>>,\n \n     /// Polonius Output\n-    pub polonius_output: Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex>>>,\n+    pub polonius_output: Option<Rc<PoloniusOutput>>,\n }\n \n impl<'b, 'tcx> Flows<'b, 'tcx> {\n     crate fn new(\n         borrows: FlowAtLocation<'tcx, Borrows<'b, 'tcx>>,\n         uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'tcx>>,\n         ever_inits: FlowAtLocation<'tcx, EverInitializedPlaces<'b, 'tcx>>,\n-        polonius_output: Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex>>>,\n+        polonius_output: Option<Rc<PoloniusOutput>>,\n     ) -> Self {\n-        Flows {\n-            borrows,\n-            uninits,\n-            ever_inits,\n-            polonius_output,\n-        }\n+        Flows { borrows, uninits, ever_inits, polonius_output }\n     }\n \n     crate fn borrows_in_scope("}, {"sha": "05451cdfb83d8e2841a6c4645c02a48e44b38289", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "modified", "additions": 16, "deletions": 38, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=6b468c6360cba002ba1e97b70cf51223a498442e", "patch": "@@ -2,6 +2,7 @@ use crate::borrow_check::location::{LocationIndex, LocationTable};\n use crate::dataflow::indexes::BorrowIndex;\n use polonius_engine::AllFacts as PoloniusAllFacts;\n use polonius_engine::Atom;\n+use rustc::mir::Local;\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n use std::error::Error;\n@@ -10,7 +11,7 @@ use std::fs::{self, File};\n use std::io::Write;\n use std::path::Path;\n \n-crate type AllFacts = PoloniusAllFacts<RegionVid, BorrowIndex, LocationIndex>;\n+crate type AllFacts = PoloniusAllFacts<RegionVid, BorrowIndex, LocationIndex, Local>;\n \n crate trait AllFactsExt {\n     /// Returns `true` if there is a need to gather `AllFacts` given the\n@@ -27,8 +28,7 @@ crate trait AllFactsExt {\n impl AllFactsExt for AllFacts {\n     /// Return\n     fn enabled(tcx: TyCtxt<'_>) -> bool {\n-        tcx.sess.opts.debugging_opts.nll_facts\n-            || tcx.sess.opts.debugging_opts.polonius\n+        tcx.sess.opts.debugging_opts.nll_facts || tcx.sess.opts.debugging_opts.polonius\n     }\n \n     fn write_to_dir(\n@@ -60,6 +60,12 @@ impl AllFactsExt for AllFacts {\n                 outlives,\n                 region_live_at,\n                 invalidates,\n+                var_used,\n+                var_defined,\n+                var_drop_used,\n+                var_uses_region,\n+                var_drops_region,\n+                var_initialized_on_exit,\n             ])\n         }\n         Ok(())\n@@ -84,11 +90,7 @@ struct FactWriter<'w> {\n }\n \n impl<'w> FactWriter<'w> {\n-    fn write_facts_to_path<T>(\n-        &self,\n-        rows: &[T],\n-        file_name: &str,\n-    ) -> Result<(), Box<dyn Error>>\n+    fn write_facts_to_path<T>(&self, rows: &[T], file_name: &str) -> Result<(), Box<dyn Error>>\n     where\n         T: FactRow,\n     {\n@@ -102,19 +104,11 @@ impl<'w> FactWriter<'w> {\n }\n \n trait FactRow {\n-    fn write(\n-        &self,\n-        out: &mut File,\n-        location_table: &LocationTable,\n-    ) -> Result<(), Box<dyn Error>>;\n+    fn write(&self, out: &mut File, location_table: &LocationTable) -> Result<(), Box<dyn Error>>;\n }\n \n impl FactRow for RegionVid {\n-    fn write(\n-        &self,\n-        out: &mut File,\n-        location_table: &LocationTable,\n-    ) -> Result<(), Box<dyn Error>> {\n+    fn write(&self, out: &mut File, location_table: &LocationTable) -> Result<(), Box<dyn Error>> {\n         write_row(out, location_table, &[self])\n     }\n }\n@@ -124,11 +118,7 @@ where\n     A: FactCell,\n     B: FactCell,\n {\n-    fn write(\n-        &self,\n-        out: &mut File,\n-        location_table: &LocationTable,\n-    ) -> Result<(), Box<dyn Error>> {\n+    fn write(&self, out: &mut File, location_table: &LocationTable) -> Result<(), Box<dyn Error>> {\n         write_row(out, location_table, &[&self.0, &self.1])\n     }\n }\n@@ -139,11 +129,7 @@ where\n     B: FactCell,\n     C: FactCell,\n {\n-    fn write(\n-        &self,\n-        out: &mut File,\n-        location_table: &LocationTable,\n-    ) -> Result<(), Box<dyn Error>> {\n+    fn write(&self, out: &mut File, location_table: &LocationTable) -> Result<(), Box<dyn Error>> {\n         write_row(out, location_table, &[&self.0, &self.1, &self.2])\n     }\n }\n@@ -155,11 +141,7 @@ where\n     C: FactCell,\n     D: FactCell,\n {\n-    fn write(\n-        &self,\n-        out: &mut File,\n-        location_table: &LocationTable,\n-    ) -> Result<(), Box<dyn Error>> {\n+    fn write(&self, out: &mut File, location_table: &LocationTable) -> Result<(), Box<dyn Error>> {\n         write_row(out, location_table, &[&self.0, &self.1, &self.2, &self.3])\n     }\n }\n@@ -170,11 +152,7 @@ fn write_row(\n     columns: &[&dyn FactCell],\n ) -> Result<(), Box<dyn Error>> {\n     for (index, c) in columns.iter().enumerate() {\n-        let tail = if index == columns.len() - 1 {\n-            \"\\n\"\n-        } else {\n-            \"\\t\"\n-        };\n+        let tail = if index == columns.len() - 1 { \"\\n\" } else { \"\\t\" };\n         write!(out, \"{:?}{}\", c.to_string(location_table), tail)?;\n     }\n     Ok(())"}, {"sha": "a2c5ad202e8c9d96404ae9240c271a34f52091e7", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=6b468c6360cba002ba1e97b70cf51223a498442e", "patch": "@@ -11,7 +11,7 @@ use crate::transform::MirSource;\n use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n-use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Body};\n+use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Local, Body};\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc_errors::Diagnostic;\n use std::fmt::Debug;\n@@ -84,7 +84,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     errors_buffer: &mut Vec<Diagnostic>,\n ) -> (\n     RegionInferenceContext<'tcx>,\n-    Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex>>>,\n+    Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex, Local>>>,\n     Option<ClosureRegionRequirements<'tcx>>,\n ) {\n     let mut all_facts = if AllFacts::enabled(infcx.tcx) {"}, {"sha": "8970009b6ee9f9b145bdec5e71e3f60b721b0d99", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=6b468c6360cba002ba1e97b70cf51223a498442e", "patch": "@@ -7,14 +7,15 @@ use crate::borrow_check::nll::ToRegionVid;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n-use rustc::mir::{Local, Body};\n+use rustc::mir::{Body, Local};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use std::rc::Rc;\n \n use super::TypeChecker;\n \n mod local_use_map;\n+mod polonius;\n mod trace;\n \n /// Combines liveness analysis with initialization analysis to\n@@ -57,15 +58,9 @@ pub(super) fn generate<'tcx>(\n     };\n \n     if !live_locals.is_empty() {\n-        trace::trace(\n-            typeck,\n-            body,\n-            elements,\n-            flow_inits,\n-            move_data,\n-            live_locals,\n-            location_table,\n-        );\n+        trace::trace(typeck, body, elements, flow_inits, move_data, live_locals, location_table);\n+\n+        polonius::populate_var_liveness_facts(typeck, body, location_table);\n     }\n }\n "}, {"sha": "20d7ec55e3e84f0330bd9af69b5ad15f8854b493", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/polonius.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=6b468c6360cba002ba1e97b70cf51223a498442e", "patch": "@@ -0,0 +1,94 @@\n+use crate::borrow_check::location::{LocationIndex, LocationTable};\n+use crate::util::liveness::{categorize, DefUse};\n+use rustc::mir::visit::{PlaceContext, Visitor};\n+use rustc::mir::{Body, Local, Location};\n+use rustc::ty::subst::Kind;\n+use rustc::ty::Ty;\n+\n+use super::TypeChecker;\n+\n+type VarPointRelations = Vec<(Local, LocationIndex)>;\n+\n+struct LivenessPointFactsExtractor<'me> {\n+    var_defined: &'me mut VarPointRelations,\n+    var_used: &'me mut VarPointRelations,\n+    location_table: &'me LocationTable,\n+}\n+\n+// A Visitor to walk through the MIR and extract point-wise facts\n+impl LivenessPointFactsExtractor<'_> {\n+    fn location_to_index(&self, location: Location) -> LocationIndex {\n+        self.location_table.mid_index(location)\n+    }\n+\n+    fn insert_def(&mut self, local: Local, location: Location) {\n+        debug!(\"LivenessFactsExtractor::insert_def()\");\n+        self.var_defined.push((local, self.location_to_index(location)));\n+    }\n+\n+    fn insert_use(&mut self, local: Local, location: Location) {\n+        debug!(\"LivenessFactsExtractor::insert_use()\");\n+        self.var_used.push((local, self.location_to_index(location)));\n+    }\n+}\n+\n+impl Visitor<'tcx> for LivenessPointFactsExtractor<'_> {\n+    fn visit_local(&mut self, &local: &Local, context: PlaceContext, location: Location) {\n+        match categorize(context) {\n+            Some(DefUse::Def) => self.insert_def(local, location),\n+            Some(DefUse::Use) => self.insert_use(local, location),\n+            _ => (),\n+            // NOTE: Drop handling is now done in trace()\n+        }\n+    }\n+}\n+\n+fn add_var_uses_regions(typeck: &mut TypeChecker<'_, 'tcx>, local: Local, ty: Ty<'tcx>) {\n+    debug!(\"add_regions(local={:?}, type={:?})\", local, ty);\n+    typeck.tcx().for_each_free_region(&ty, |region| {\n+        let region_vid = typeck.borrowck_context.universal_regions.to_region_vid(region);\n+        debug!(\"add_regions for region {:?}\", region_vid);\n+        if let Some(facts) = typeck.borrowck_context.all_facts {\n+            facts.var_uses_region.push((local, region_vid));\n+        }\n+    });\n+}\n+\n+pub(super) fn populate_var_liveness_facts(\n+    typeck: &mut TypeChecker<'_, 'tcx>,\n+    mir: &Body<'tcx>,\n+    location_table: &LocationTable,\n+) {\n+    debug!(\"populate_var_liveness_facts()\");\n+\n+    if let Some(facts) = typeck.borrowck_context.all_facts.as_mut() {\n+        LivenessPointFactsExtractor {\n+            var_defined: &mut facts.var_defined,\n+            var_used: &mut facts.var_used,\n+            location_table,\n+        }\n+        .visit_body(mir);\n+    }\n+\n+    for (local, local_decl) in mir.local_decls.iter_enumerated() {\n+        add_var_uses_regions(typeck, local, local_decl.ty);\n+    }\n+}\n+\n+// For every potentially drop()-touched region `region` in `local`'s type\n+// (`kind`), emit a Polonius `var_drops_region(local, region)` fact.\n+pub(super) fn add_var_drops_regions(\n+    typeck: &mut TypeChecker<'_, 'tcx>,\n+    local: Local,\n+    kind: &Kind<'tcx>,\n+) {\n+    debug!(\"add_var_drops_region(local={:?}, kind={:?}\", local, kind);\n+    let tcx = typeck.tcx();\n+\n+    tcx.for_each_free_region(kind, |drop_live_region| {\n+        let region_vid = typeck.borrowck_context.universal_regions.to_region_vid(drop_live_region);\n+        if let Some(facts) = typeck.borrowck_context.all_facts.as_mut() {\n+            facts.var_drops_region.push((local, region_vid));\n+        };\n+    });\n+}"}, {"sha": "039ed939ada7c61a04b0682bf1052369282d08a2", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 94, "deletions": 51, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b468c6360cba002ba1e97b70cf51223a498442e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=6b468c6360cba002ba1e97b70cf51223a498442e", "patch": "@@ -1,13 +1,14 @@\n use crate::borrow_check::location::LocationTable;\n use crate::borrow_check::nll::region_infer::values::{self, PointIndex, RegionValueElements};\n use crate::borrow_check::nll::type_check::liveness::local_use_map::LocalUseMap;\n+use crate::borrow_check::nll::type_check::liveness::polonius;\n use crate::borrow_check::nll::type_check::NormalizeLocation;\n use crate::borrow_check::nll::type_check::TypeChecker;\n use crate::dataflow::indexes::MovePathIndex;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::{FlowAtLocation, FlowsAtLocation, MaybeInitializedPlaces};\n use rustc::infer::canonical::QueryRegionConstraints;\n-use rustc::mir::{BasicBlock, ConstraintCategory, Local, Location, Body};\n+use rustc::mir::{BasicBlock, Body, ConstraintCategory, Local, Location};\n use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc::traits::query::type_op::outlives::DropckOutlives;\n use rustc::traits::query::type_op::TypeOp;\n@@ -130,6 +131,12 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         for local in live_locals {\n             self.reset_local_state();\n             self.add_defs_for(local);\n+\n+            // FIXME: this is temporary until we can generate our own initialization\n+            if self.cx.typeck.borrowck_context.all_facts.is_some() {\n+                self.add_polonius_var_initialized_on_exit_for(local)\n+            }\n+\n             self.compute_use_live_points_for(local);\n             self.compute_drop_live_points_for(local);\n \n@@ -150,6 +157,63 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         }\n     }\n \n+    // WARNING: panics if self.cx.typeck.borrowck_context.all_facts != None\n+    //\n+    // FIXME: this analysis (the initialization tracking) should be\n+    // done in Polonius, but isn't yet.\n+    fn add_polonius_var_initialized_on_exit_for(&mut self, local: Local) {\n+        let move_path = self.cx.move_data.rev_lookup.find_local(local);\n+        let facts = self.cx.typeck.borrowck_context.all_facts.as_mut().unwrap();\n+        for block in self.cx.body.basic_blocks().indices() {\n+            debug!(\"polonius: generating initialization facts for {:?} in {:?}\", local, block);\n+\n+            // iterate through the block, applying the effects of each statement\n+            // up to and including location, and populate `var_initialized_on_exit`\n+            self.cx.flow_inits.reset_to_entry_of(block);\n+            let start_location = Location { block, statement_index: 0 };\n+            self.cx.flow_inits.apply_local_effect(start_location);\n+\n+            for statement_index in 0..self.cx.body[block].statements.len() {\n+                let current_location = Location { block, statement_index };\n+\n+                self.cx.flow_inits.reconstruct_statement_effect(current_location);\n+\n+                // statement has not yet taken effect:\n+                if self.cx.flow_inits.has_any_child_of(move_path).is_some() {\n+                    facts\n+                        .var_initialized_on_exit\n+                        .push((local, self.cx.location_table.start_index(current_location)));\n+                }\n+\n+                // statement has now taken effect\n+                self.cx.flow_inits.apply_local_effect(current_location);\n+\n+                if self.cx.flow_inits.has_any_child_of(move_path).is_some() {\n+                    facts\n+                        .var_initialized_on_exit\n+                        .push((local, self.cx.location_table.mid_index(current_location)));\n+                }\n+            }\n+\n+            let terminator_location = self.cx.body.terminator_loc(block);\n+\n+            if self.cx.flow_inits.has_any_child_of(move_path).is_some() {\n+                facts\n+                    .var_initialized_on_exit\n+                    .push((local, self.cx.location_table.start_index(terminator_location)));\n+            }\n+\n+            // apply the effects of the terminator and push it if needed\n+            self.cx.flow_inits.reset_to_exit_of(block);\n+\n+            if self.cx.flow_inits.has_any_child_of(move_path).is_some() {\n+                facts\n+                    .var_initialized_on_exit\n+                    .push((local, self.cx.location_table.mid_index(terminator_location)));\n+            }\n+        }\n+    }\n+\n     /// Clear the value of fields that are \"per local variable\".\n     fn reset_local_state(&mut self) {\n         self.defs.clear();\n@@ -183,9 +247,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n             }\n \n             if self.use_live_at.insert(p) {\n-                self.cx\n-                    .elements\n-                    .push_predecessors(self.cx.body, p, &mut self.stack)\n+                self.cx.elements.push_predecessors(self.cx.body, p, &mut self.stack)\n             }\n         }\n     }\n@@ -211,17 +273,19 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n             debug_assert_eq!(self.cx.body.terminator_loc(location.block), location,);\n \n             if self.cx.initialized_at_terminator(location.block, mpi) {\n+                // FIXME: this analysis (the initialization tracking) should be\n+                // done in Polonius, but isn't yet.\n+                if let Some(facts) = self.cx.typeck.borrowck_context.all_facts {\n+                    facts.var_drop_used.push((local, self.cx.location_table.mid_index(location)));\n+                }\n                 if self.drop_live_at.insert(drop_point) {\n                     self.drop_locations.push(location);\n                     self.stack.push(drop_point);\n                 }\n             }\n         }\n \n-        debug!(\n-            \"compute_drop_live_points_for: drop_locations={:?}\",\n-            self.drop_locations\n-        );\n+        debug!(\"compute_drop_live_points_for: drop_locations={:?}\", self.drop_locations);\n \n         // Reverse DFS. But for drops, we do it a bit differently.\n         // The stack only ever stores *terminators of blocks*. Within\n@@ -257,17 +321,11 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         // block.  One of them may be either a definition or use\n         // live point.\n         let term_location = self.cx.elements.to_location(term_point);\n-        debug_assert_eq!(\n-            self.cx.body.terminator_loc(term_location.block),\n-            term_location,\n-        );\n+        debug_assert_eq!(self.cx.body.terminator_loc(term_location.block), term_location,);\n         let block = term_location.block;\n         let entry_point = self.cx.elements.entry_point(term_location.block);\n         for p in (entry_point..term_point).rev() {\n-            debug!(\n-                \"compute_drop_live_points_for_block: p = {:?}\",\n-                self.cx.elements.to_location(p),\n-            );\n+            debug!(\"compute_drop_live_points_for_block: p = {:?}\", self.cx.elements.to_location(p));\n \n             if self.defs.contains(p) {\n                 debug!(\"compute_drop_live_points_for_block: def site\");\n@@ -286,10 +344,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         }\n \n         for &pred_block in self.cx.body.predecessors_for(block).iter() {\n-            debug!(\n-                \"compute_drop_live_points_for_block: pred_block = {:?}\",\n-                pred_block,\n-            );\n+            debug!(\"compute_drop_live_points_for_block: pred_block = {:?}\", pred_block,);\n \n             // Check whether the variable is (at least partially)\n             // initialized at the exit of this predecessor. If so, we\n@@ -320,18 +375,12 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n             // If the terminator of this predecessor either *assigns*\n             // our value or is a \"normal use\", then stop.\n             if self.defs.contains(pred_term_point) {\n-                debug!(\n-                    \"compute_drop_live_points_for_block: defined at {:?}\",\n-                    pred_term_loc\n-                );\n+                debug!(\"compute_drop_live_points_for_block: defined at {:?}\", pred_term_loc);\n                 continue;\n             }\n \n             if self.use_live_at.contains(pred_term_point) {\n-                debug!(\n-                    \"compute_drop_live_points_for_block: use-live at {:?}\",\n-                    pred_term_loc\n-                );\n+                debug!(\"compute_drop_live_points_for_block: use-live at {:?}\", pred_term_loc);\n                 continue;\n             }\n \n@@ -392,10 +441,7 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n         // \"just ahead\" of a terminator.\n         self.flow_inits.reset_to_entry_of(block);\n         for statement_index in 0..self.body[block].statements.len() {\n-            let location = Location {\n-                block,\n-                statement_index,\n-            };\n+            let location = Location { block, statement_index };\n             self.flow_inits.reconstruct_statement_effect(location);\n             self.flow_inits.apply_local_effect(location);\n         }\n@@ -462,12 +508,11 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n \n         if let Some(data) = &drop_data.region_constraint_data {\n             for &drop_location in drop_locations {\n-                self.typeck\n-                    .push_region_constraints(\n-                        drop_location.to_locations(),\n-                        ConstraintCategory::Boring,\n-                        data,\n-                    );\n+                self.typeck.push_region_constraints(\n+                    drop_location.to_locations(),\n+                    ConstraintCategory::Boring,\n+                    data,\n+                );\n             }\n         }\n \n@@ -487,6 +532,8 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n                 live_at,\n                 self.location_table,\n             );\n+\n+            polonius::add_var_drops_regions(&mut self.typeck, dropped_local, &kind);\n         }\n     }\n \n@@ -505,14 +552,15 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n \n         let tcx = typeck.tcx();\n         tcx.for_each_free_region(&value, |live_region| {\n-            let live_region_vid = typeck.borrowck_context\n-                .universal_regions\n-                .to_region_vid(live_region);\n-            typeck.borrowck_context\n+            let live_region_vid =\n+                typeck.borrowck_context.universal_regions.to_region_vid(live_region);\n+            typeck\n+                .borrowck_context\n                 .constraints\n                 .liveness_constraints\n                 .add_elements(live_region_vid, live_at);\n \n+            // FIXME: remove this when we can generate our own region-live-at reliably\n             if let Some(facts) = typeck.borrowck_context.all_facts {\n                 for point in live_at.iter() {\n                     let loc = elements.to_location(point);\n@@ -530,14 +578,9 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n         debug!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty,);\n \n         let param_env = typeck.param_env;\n-        let (dropck_result, region_constraint_data) = param_env\n-            .and(DropckOutlives::new(dropped_ty))\n-            .fully_perform(typeck.infcx)\n-            .unwrap();\n-\n-        DropData {\n-            dropck_result,\n-            region_constraint_data,\n-        }\n+        let (dropck_result, region_constraint_data) =\n+            param_env.and(DropckOutlives::new(dropped_ty)).fully_perform(typeck.infcx).unwrap();\n+\n+        DropData { dropck_result, region_constraint_data }\n     }\n }"}]}