{"sha": "de6e53a3274acf4a15e12be4c3a7b0108bd567a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlNmU1M2EzMjc0YWNmNGExNWUxMmJlNGMzYTdiMDEwOGJkNTY3YTg=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-11-30T11:15:25Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-01-18T08:31:14Z"}, "message": "BTreeMap: convert search functions to methods", "tree": {"sha": "d3ea4d074474a647c4cbb7431de89ab11d8911f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3ea4d074474a647c4cbb7431de89ab11d8911f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de6e53a3274acf4a15e12be4c3a7b0108bd567a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de6e53a3274acf4a15e12be4c3a7b0108bd567a8", "html_url": "https://github.com/rust-lang/rust/commit/de6e53a3274acf4a15e12be4c3a7b0108bd567a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de6e53a3274acf4a15e12be4c3a7b0108bd567a8/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93e0aedb0710f3636ccb7ab48690af9d3b8a87f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/93e0aedb0710f3636ccb7ab48690af9d3b8a87f8", "html_url": "https://github.com/rust-lang/rust/commit/93e0aedb0710f3636ccb7ab48690af9d3b8a87f8"}], "stats": {"total": 166, "additions": 83, "deletions": 83}, "files": [{"sha": "ecc2873187467a565439d555707e75f80246639a", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/de6e53a3274acf4a15e12be4c3a7b0108bd567a8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de6e53a3274acf4a15e12be4c3a7b0108bd567a8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=de6e53a3274acf4a15e12be4c3a7b0108bd567a8", "patch": "@@ -10,7 +10,7 @@ use core::ptr;\n \n use super::borrow::DormantMutRef;\n use super::node::{self, marker, ForceResult::*, Handle, NodeRef, Root};\n-use super::search::{self, SearchResult::*};\n+use super::search::SearchResult::*;\n use super::unwrap_unchecked;\n \n mod entry;\n@@ -230,7 +230,7 @@ where\n \n     fn get(&self, key: &Q) -> Option<&K> {\n         let root_node = self.root.as_ref()?.reborrow();\n-        match search::search_tree(root_node, key) {\n+        match root_node.search_tree(key) {\n             Found(handle) => Some(handle.into_kv().0),\n             GoDown(_) => None,\n         }\n@@ -239,7 +239,7 @@ where\n     fn take(&mut self, key: &Q) -> Option<K> {\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = map.root.as_mut()?.borrow_mut();\n-        match search::search_tree(root_node, key) {\n+        match root_node.search_tree(key) {\n             Found(handle) => {\n                 Some(OccupiedEntry { handle, dormant_map, _marker: PhantomData }.remove_kv().0)\n             }\n@@ -250,7 +250,7 @@ where\n     fn replace(&mut self, key: K) -> Option<K> {\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = Self::ensure_is_owned(&mut map.root).borrow_mut();\n-        match search::search_tree::<marker::Mut<'_>, K, (), K>(root_node, &key) {\n+        match root_node.search_tree::<K>(&key) {\n             Found(mut kv) => Some(mem::replace(kv.key_mut(), key)),\n             GoDown(handle) => {\n                 VacantEntry { key, handle, dormant_map, _marker: PhantomData }.insert(());\n@@ -526,7 +526,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         Q: Ord,\n     {\n         let root_node = self.root.as_ref()?.reborrow();\n-        match search::search_tree(root_node, key) {\n+        match root_node.search_tree(key) {\n             Found(handle) => Some(handle.into_kv().1),\n             GoDown(_) => None,\n         }\n@@ -554,7 +554,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         Q: Ord,\n     {\n         let root_node = self.root.as_ref()?.reborrow();\n-        match search::search_tree(root_node, k) {\n+        match root_node.search_tree(k) {\n             Found(handle) => Some(handle.into_kv()),\n             GoDown(_) => None,\n         }\n@@ -762,7 +762,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         Q: Ord,\n     {\n         let root_node = self.root.as_mut()?.borrow_mut();\n-        match search::search_tree(root_node, key) {\n+        match root_node.search_tree(key) {\n             Found(handle) => Some(handle.into_val_mut()),\n             GoDown(_) => None,\n         }\n@@ -858,7 +858,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     {\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = map.root.as_mut()?.borrow_mut();\n-        match search::search_tree(root_node, key) {\n+        match root_node.search_tree(key) {\n             Found(handle) => {\n                 Some(OccupiedEntry { handle, dormant_map, _marker: PhantomData }.remove_entry())\n             }\n@@ -1051,7 +1051,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = Self::ensure_is_owned(&mut map.root).borrow_mut();\n-        match search::search_tree(root_node, &key) {\n+        match root_node.search_tree(&key) {\n             Found(handle) => Occupied(OccupiedEntry { handle, dormant_map, _marker: PhantomData }),\n             GoDown(handle) => {\n                 Vacant(VacantEntry { key, handle, dormant_map, _marker: PhantomData })"}, {"sha": "45a8e0103a496eaaf015b41a1c5da8f9435f343e", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de6e53a3274acf4a15e12be4c3a7b0108bd567a8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de6e53a3274acf4a15e12be4c3a7b0108bd567a8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=de6e53a3274acf4a15e12be4c3a7b0108bd567a8", "patch": "@@ -5,7 +5,7 @@ use core::ops::RangeBounds;\n use core::ptr;\n \n use super::node::{marker, ForceResult::*, Handle, NodeRef};\n-use super::search::{self, SearchResult};\n+use super::search::SearchResult;\n use super::unwrap_unchecked;\n \n /// Finds the leaf edges delimiting a specified range in or underneath a node.\n@@ -42,14 +42,14 @@ where\n \n     loop {\n         let front = match (min_found, range.start_bound()) {\n-            (false, Included(key)) => match search::search_node(min_node, key) {\n+            (false, Included(key)) => match min_node.search_node(key) {\n                 SearchResult::Found(kv) => {\n                     min_found = true;\n                     kv.left_edge()\n                 }\n                 SearchResult::GoDown(edge) => edge,\n             },\n-            (false, Excluded(key)) => match search::search_node(min_node, key) {\n+            (false, Excluded(key)) => match min_node.search_node(key) {\n                 SearchResult::Found(kv) => {\n                     min_found = true;\n                     kv.right_edge()\n@@ -62,14 +62,14 @@ where\n         };\n \n         let back = match (max_found, range.end_bound()) {\n-            (false, Included(key)) => match search::search_node(max_node, key) {\n+            (false, Included(key)) => match max_node.search_node(key) {\n                 SearchResult::Found(kv) => {\n                     max_found = true;\n                     kv.right_edge()\n                 }\n                 SearchResult::GoDown(edge) => edge,\n             },\n-            (false, Excluded(key)) => match search::search_node(max_node, key) {\n+            (false, Excluded(key)) => match max_node.search_node(key) {\n                 SearchResult::Found(kv) => {\n                     max_found = true;\n                     kv.left_edge()"}, {"sha": "f62eae3f4d5a297b21fd21a12a9324d33e58849f", "filename": "library/alloc/src/collections/btree/search.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/de6e53a3274acf4a15e12be4c3a7b0108bd567a8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de6e53a3274acf4a15e12be4c3a7b0108bd567a8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs?ref=de6e53a3274acf4a15e12be4c3a7b0108bd567a8", "patch": "@@ -10,79 +10,79 @@ pub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n     GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>),\n }\n \n-/// Looks up a given key in a (sub)tree headed by the given node, recursively.\n-/// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n-/// returns a `GoDown` with the handle of the leaf edge where the key belongs.\n-///\n-/// The result is meaningful only if the tree is ordered by key, like the tree\n-/// in a `BTreeMap` is.\n-pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n-    mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-    key: &Q,\n-) -> SearchResult<BorrowType, K, V, marker::LeafOrInternal, marker::Leaf>\n-where\n-    Q: Ord,\n-    K: Borrow<Q>,\n-{\n-    loop {\n-        match search_node(node, key) {\n-            Found(handle) => return Found(handle),\n-            GoDown(handle) => match handle.force() {\n-                Leaf(leaf) => return GoDown(leaf),\n-                Internal(internal) => {\n-                    node = internal.descend();\n-                    continue;\n-                }\n-            },\n+pub enum IndexResult {\n+    KV(usize),\n+    Edge(usize),\n+}\n+\n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+    /// Looks up a given key in a (sub)tree headed by the node, recursively.\n+    /// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n+    /// returns a `GoDown` with the handle of the leaf edge where the key belongs.\n+    ///\n+    /// The result is meaningful only if the tree is ordered by key, like the tree\n+    /// in a `BTreeMap` is.\n+    pub fn search_tree<Q: ?Sized>(\n+        mut self,\n+        key: &Q,\n+    ) -> SearchResult<BorrowType, K, V, marker::LeafOrInternal, marker::Leaf>\n+    where\n+        Q: Ord,\n+        K: Borrow<Q>,\n+    {\n+        loop {\n+            self = match self.search_node(key) {\n+                Found(handle) => return Found(handle),\n+                GoDown(handle) => match handle.force() {\n+                    Leaf(leaf) => return GoDown(leaf),\n+                    Internal(internal) => internal.descend(),\n+                },\n+            }\n         }\n     }\n }\n \n-/// Looks up a given key in a given node, without recursion.\n-/// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n-/// returns a `GoDown` with the handle of the edge where the key might be found\n-/// (if the node is internal) or where the key can be inserted.\n-///\n-/// The result is meaningful only if the tree is ordered by key, like the tree\n-/// in a `BTreeMap` is.\n-pub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n-    node: NodeRef<BorrowType, K, V, Type>,\n-    key: &Q,\n-) -> SearchResult<BorrowType, K, V, Type, Type>\n-where\n-    Q: Ord,\n-    K: Borrow<Q>,\n-{\n-    match search_linear(&node, key) {\n-        (idx, true) => Found(unsafe { Handle::new_kv(node, idx) }),\n-        (idx, false) => GoDown(unsafe { Handle::new_edge(node, idx) }),\n+impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n+    /// Looks up a given key in the node, without recursion.\n+    /// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n+    /// returns a `GoDown` with the handle of the edge where the key might be found\n+    /// (if the node is internal) or where the key can be inserted.\n+    ///\n+    /// The result is meaningful only if the tree is ordered by key, like the tree\n+    /// in a `BTreeMap` is.\n+    pub fn search_node<Q: ?Sized>(self, key: &Q) -> SearchResult<BorrowType, K, V, Type, Type>\n+    where\n+        Q: Ord,\n+        K: Borrow<Q>,\n+    {\n+        match self.find_index(key) {\n+            IndexResult::KV(idx) => Found(unsafe { Handle::new_kv(self, idx) }),\n+            IndexResult::Edge(idx) => GoDown(unsafe { Handle::new_edge(self, idx) }),\n+        }\n     }\n-}\n \n-/// Returns either the KV index in the node at which the key (or an equivalent)\n-/// exists and `true`, or the edge index where the key belongs and `false`.\n-///\n-/// The result is meaningful only if the tree is ordered by key, like the tree\n-/// in a `BTreeMap` is.\n-fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n-    node: &NodeRef<BorrowType, K, V, Type>,\n-    key: &Q,\n-) -> (usize, bool)\n-where\n-    Q: Ord,\n-    K: Borrow<Q>,\n-{\n-    // This function is defined over all borrow types (immutable, mutable, owned).\n-    // Using `keys_at()` is fine here even if BorrowType is mutable, as all we return\n-    // is an index -- not a reference.\n-    let len = node.len();\n-    for i in 0..len {\n-        let k = unsafe { node.reborrow().key_at(i) };\n-        match key.cmp(k.borrow()) {\n-            Ordering::Greater => {}\n-            Ordering::Equal => return (i, true),\n-            Ordering::Less => return (i, false),\n+    /// Returns either the KV index in the node at which the key (or an equivalent)\n+    /// exists, or the edge index where the key belongs.\n+    ///\n+    /// The result is meaningful only if the tree is ordered by key, like the tree\n+    /// in a `BTreeMap` is.\n+    fn find_index<Q: ?Sized>(&self, key: &Q) -> IndexResult\n+    where\n+        Q: Ord,\n+        K: Borrow<Q>,\n+    {\n+        // This function is defined over all borrow types (immutable, mutable, owned).\n+        // Using `keys_at()` is fine here even if BorrowType is mutable, as all we return\n+        // is an index -- not a reference.\n+        let len = self.len();\n+        for i in 0..len {\n+            let k = unsafe { self.reborrow().key_at(i) };\n+            match key.cmp(k.borrow()) {\n+                Ordering::Greater => {}\n+                Ordering::Equal => return IndexResult::KV(i),\n+                Ordering::Less => return IndexResult::Edge(i),\n+            }\n         }\n+        IndexResult::Edge(len)\n     }\n-    (len, false)\n }"}, {"sha": "62c5e3a46d74dc20d9761349f67ba73af71aa08e", "filename": "library/alloc/src/collections/btree/split.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de6e53a3274acf4a15e12be4c3a7b0108bd567a8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de6e53a3274acf4a15e12be4c3a7b0108bd567a8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs?ref=de6e53a3274acf4a15e12be4c3a7b0108bd567a8", "patch": "@@ -1,6 +1,6 @@\n use super::map::MIN_LEN;\n use super::node::{ForceResult::*, Root};\n-use super::search::{search_node, SearchResult::*};\n+use super::search::SearchResult::*;\n use core::borrow::Borrow;\n \n impl<K, V> Root<K, V> {\n@@ -21,7 +21,7 @@ impl<K, V> Root<K, V> {\n             let mut right_node = right_root.borrow_mut();\n \n             loop {\n-                let mut split_edge = match search_node(left_node, key) {\n+                let mut split_edge = match left_node.search_node(key) {\n                     // key is going to the right tree\n                     Found(kv) => kv.left_edge(),\n                     GoDown(edge) => edge,"}]}