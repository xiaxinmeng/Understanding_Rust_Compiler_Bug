{"sha": "d5ad38cbb87103d8713855e0ec705fd957249afd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YWQzOGNiYjg3MTAzZDg3MTM4NTVlMGVjNzA1ZmQ5NTcyNDlhZmQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-02-11T22:11:12Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-02-13T19:10:46Z"}, "message": "Resolve 2015 style imports", "tree": {"sha": "3c414dafaa6e42cc11dd71f9f9b59291eff9832e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c414dafaa6e42cc11dd71f9f9b59291eff9832e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5ad38cbb87103d8713855e0ec705fd957249afd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5ad38cbb87103d8713855e0ec705fd957249afd", "html_url": "https://github.com/rust-lang/rust/commit/d5ad38cbb87103d8713855e0ec705fd957249afd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5ad38cbb87103d8713855e0ec705fd957249afd/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a9934e2c3280864877a90c5ced777bad898d73a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a9934e2c3280864877a90c5ced777bad898d73a", "html_url": "https://github.com/rust-lang/rust/commit/3a9934e2c3280864877a90c5ced777bad898d73a"}], "stats": {"total": 126, "additions": 118, "deletions": 8}, "files": [{"sha": "aa535ac4d381873b251a1a4151eea421b37535d4", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5ad38cbb87103d8713855e0ec705fd957249afd/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ad38cbb87103d8713855e0ec705fd957249afd/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=d5ad38cbb87103d8713855e0ec705fd957249afd", "patch": "@@ -119,6 +119,10 @@ impl CrateGraph {\n         self.arena[&crate_id].file_id\n     }\n \n+    pub fn edition(&self, crate_id: CrateId) -> Edition {\n+        self.arena[&crate_id].edition\n+    }\n+\n     // TODO: this only finds one crate with the given root; we could have multiple\n     pub fn crate_id_for_crate_root(&self, file_id: FileId) -> Option<CrateId> {\n         let (&crate_id, _) = self.arena.iter().find(|(_crate_id, data)| data.file_id == file_id)?;"}, {"sha": "fb7ad086754f8a674a11beffd5383dd842138b00", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5ad38cbb87103d8713855e0ec705fd957249afd/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ad38cbb87103d8713855e0ec705fd957249afd/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=d5ad38cbb87103d8713855e0ec705fd957249afd", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n \n use relative_path::RelativePathBuf;\n-use ra_db::{CrateId, FileId, SourceRootId};\n+use ra_db::{CrateId, FileId, SourceRootId, Edition};\n use ra_syntax::{ast::self, TreeArc, SyntaxNode};\n \n use crate::{\n@@ -38,13 +38,20 @@ impl Crate {\n     pub fn crate_id(&self) -> CrateId {\n         self.crate_id\n     }\n+\n     pub fn dependencies(&self, db: &impl PersistentHirDatabase) -> Vec<CrateDependency> {\n         self.dependencies_impl(db)\n     }\n+\n     pub fn root_module(&self, db: &impl PersistentHirDatabase) -> Option<Module> {\n         self.root_module_impl(db)\n     }\n \n+    pub fn edition(&self, db: &impl PersistentHirDatabase) -> Edition {\n+        let crate_graph = db.crate_graph();\n+        crate_graph.edition(self.crate_id)\n+    }\n+\n     // TODO: should this be in source_binder?\n     pub fn source_root_crates(\n         db: &impl PersistentHirDatabase,"}, {"sha": "028e2bee3370307591a613b568a32ec7ab9d680e", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d5ad38cbb87103d8713855e0ec705fd957249afd/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ad38cbb87103d8713855e0ec705fd957249afd/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=d5ad38cbb87103d8713855e0ec705fd957249afd", "patch": "@@ -18,9 +18,11 @@ pub(crate) mod lower;\n \n use std::{time, sync::Arc};\n \n+use rustc_hash::{FxHashMap, FxHashSet};\n+\n use ra_arena::map::ArenaMap;\n+use ra_db::Edition;\n use test_utils::tested_by;\n-use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     Module, ModuleDef,\n@@ -32,8 +34,9 @@ use crate::{\n \n /// `ItemMap` is the result of module name resolution. It contains, for each\n /// module, the set of visible items.\n-#[derive(Default, Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq)]\n pub struct ItemMap {\n+    edition: Edition,\n     /// The prelude module for this crate. This either comes from an import\n     /// marked with the `prelude_import` attribute, or (in the normal case) from\n     /// a dependency (`std` or `core`).\n@@ -180,7 +183,12 @@ where\n             module_tree,\n             processed_imports: FxHashSet::default(),\n             glob_imports: FxHashMap::default(),\n-            result: ItemMap::default(),\n+            result: ItemMap {\n+                edition: krate.edition(db),\n+                prelude: None,\n+                extern_prelude: FxHashMap::default(),\n+                per_module: ArenaMap::default(),\n+            },\n         }\n     }\n \n@@ -277,10 +285,14 @@ where\n         import_id: ImportId,\n         import: &ImportData,\n     ) -> ReachedFixedPoint {\n-        log::debug!(\"resolving import: {:?}\", import);\n+        log::debug!(\"resolving import: {:?} ({:?})\", import, self.result.edition);\n         let original_module = Module { krate: self.krate, module_id };\n-        let (def, reached_fixedpoint) =\n-            self.result.resolve_path_fp(self.db, original_module, &import.path);\n+        let (def, reached_fixedpoint) = self.result.resolve_path_fp(\n+            self.db,\n+            ResolveMode::Import,\n+            original_module,\n+            &import.path,\n+        );\n \n         if reached_fixedpoint != ReachedFixedPoint::Yes {\n             return reached_fixedpoint;\n@@ -417,6 +429,12 @@ where\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum ResolveMode {\n+    Import,\n+    Other,\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n enum ReachedFixedPoint {\n     Yes,\n@@ -445,7 +463,7 @@ impl ItemMap {\n         original_module: Module,\n         path: &Path,\n     ) -> PerNs<ModuleDef> {\n-        self.resolve_path_fp(db, original_module, path).0\n+        self.resolve_path_fp(db, ResolveMode::Other, original_module, path).0\n     }\n \n     fn resolve_in_prelude(\n@@ -484,23 +502,59 @@ impl ItemMap {\n         from_scope.or(from_extern_prelude).or(from_prelude)\n     }\n \n+    fn resolve_name_in_crate_root_or_extern_prelude(\n+        &self,\n+        db: &impl PersistentHirDatabase,\n+        module: Module,\n+        name: &Name,\n+    ) -> PerNs<ModuleDef> {\n+        let crate_root = module.crate_root(db);\n+        let from_crate_root =\n+            self[crate_root.module_id].items.get(name).map_or(PerNs::none(), |it| it.def);\n+        let from_extern_prelude =\n+            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n+\n+        from_crate_root.or(from_extern_prelude)\n+    }\n+\n     // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n     // the result.\n     fn resolve_path_fp(\n         &self,\n         db: &impl PersistentHirDatabase,\n+        mode: ResolveMode,\n         original_module: Module,\n         path: &Path,\n     ) -> (PerNs<ModuleDef>, ReachedFixedPoint) {\n         let mut segments = path.segments.iter().enumerate();\n         let mut curr_per_ns: PerNs<ModuleDef> = match path.kind {\n             PathKind::Crate => PerNs::types(original_module.crate_root(db).into()),\n             PathKind::Self_ => PerNs::types(original_module.into()),\n+            // plain import or absolute path in 2015: crate-relative with\n+            // fallback to extern prelude (with the simplification in\n+            // rust-lang/rust#57745)\n+            // TODO there must be a nicer way to write this condition\n+            PathKind::Plain | PathKind::Abs\n+                if self.edition == Edition::Edition2015\n+                    && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n+            {\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return (PerNs::none(), ReachedFixedPoint::Yes),\n+                };\n+                log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n+                self.resolve_name_in_crate_root_or_extern_prelude(\n+                    db,\n+                    original_module,\n+                    &segment.name,\n+                )\n+            }\n             PathKind::Plain => {\n                 let segment = match segments.next() {\n                     Some((_, segment)) => segment,\n                     None => return (PerNs::none(), ReachedFixedPoint::Yes),\n                 };\n+                log::debug!(\"resolving {:?} in module\", segment);\n                 self.resolve_name_in_module(db, original_module, &segment.name)\n             }\n             PathKind::Super => {"}, {"sha": "bee475c3acdfde1465aaf5dabaff307fd3790983", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d5ad38cbb87103d8713855e0ec705fd957249afd/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5ad38cbb87103d8713855e0ec705fd957249afd/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=d5ad38cbb87103d8713855e0ec705fd957249afd", "patch": "@@ -265,6 +265,51 @@ fn glob_across_crates() {\n     );\n }\n \n+#[test]\n+fn edition_2015_imports() {\n+    use ra_db::{CrateGraph, Edition};\n+    let mut db = MockDatabase::with_files(\n+        \"\n+        //- /main.rs\n+        mod foo;\n+        mod bar;\n+\n+        //- /bar.rs\n+        struct Bar;\n+\n+        //- /foo.rs\n+        use bar::Bar;\n+        use other_crate::FromLib;\n+\n+        //- /lib.rs\n+        struct FromLib;\n+    \",\n+    );\n+    let main_id = db.file_id_of(\"/main.rs\");\n+    let lib_id = db.file_id_of(\"/lib.rs\");\n+    let foo_id = db.file_id_of(\"/foo.rs\");\n+\n+    let mut crate_graph = CrateGraph::default();\n+    let main_crate = crate_graph.add_crate_root(main_id, Edition::Edition2015);\n+    let lib_crate = crate_graph.add_crate_root(lib_id, Edition::Edition2018);\n+    crate_graph.add_dep(main_crate, \"other_crate\".into(), lib_crate).unwrap();\n+\n+    db.set_crate_graph(Arc::new(crate_graph));\n+\n+    let module = crate::source_binder::module_from_file_id(&db, foo_id).unwrap();\n+    let krate = module.krate(&db).unwrap();\n+    let item_map = db.item_map(krate);\n+\n+    check_module_item_map(\n+        &item_map,\n+        module.module_id,\n+        \"\n+            Bar: t v\n+            FromLib: t v\n+        \",\n+    );\n+}\n+\n #[test]\n fn module_resolution_works_for_non_standard_filenames() {\n     let mut db = MockDatabase::with_files("}]}