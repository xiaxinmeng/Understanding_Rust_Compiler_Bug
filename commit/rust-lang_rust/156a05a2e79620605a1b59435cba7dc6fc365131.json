{"sha": "156a05a2e79620605a1b59435cba7dc6fc365131", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NmEwNWEyZTc5NjIwNjA1YTFiNTk0MzVjYmE3ZGM2ZmMzNjUxMzE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-12T15:32:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-12T15:32:11Z"}, "message": "Rollup merge of #69011 - foeb:document-unsafe-core-fmt, r=Mark-Simulacrum\n\nDocument unsafe blocks in core::fmt\n\nr? @RalfJung\nCC: @rust-lang/wg-unsafe-code-guidelines\n#66219\n\nSorry for the hiatus, but here's a few more files with the unsafe blocks documented! I think working on it smaller chunks like this will be easier for everyone.", "tree": {"sha": "46386e71b8a9badc02f3ab6705653e62e8a99a33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46386e71b8a9badc02f3ab6705653e62e8a99a33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/156a05a2e79620605a1b59435cba7dc6fc365131", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJealX7CRBK7hj4Ov3rIwAAdHIIAK3z046DxADyUmJo7uEpxG1s\nHiflnPA2La88Ezr7BNWYLbawLrqUTJNWv0Qz8twNOUEIEx1GIXrSKCwXugS8/9hK\n6kG4KopY7/dDU3RNStNuxo6hrecM0nwfNCE1zR1qSLDw3p2TGfq52SnhUjMJ7MBi\nGQDD9ZEuzqM3GAMWXtYhUGWCGSvtWsXo4PyDucbqesFbHLQ+TPoKZnGrm8EooB5M\nBM8H+W14PHaJ64BCimNFC7aKKGp9l2ZGAdhl1bmWmxLMxAbU5naPh5Gw8/6rhqHO\neMx0MCcfh+LMWH7tpk3qmsqPlEPtC72wjhh0fXjsnnCv7768/wewk6fv4xc7VBM=\n=zWs3\n-----END PGP SIGNATURE-----\n", "payload": "tree 46386e71b8a9badc02f3ab6705653e62e8a99a33\nparent 703dcff081aa9f4aef2e94fb25d6743692c2dd47\nparent 3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1584027131 +0100\ncommitter GitHub <noreply@github.com> 1584027131 +0100\n\nRollup merge of #69011 - foeb:document-unsafe-core-fmt, r=Mark-Simulacrum\n\nDocument unsafe blocks in core::fmt\n\nr? @RalfJung\nCC: @rust-lang/wg-unsafe-code-guidelines\n#66219\n\nSorry for the hiatus, but here's a few more files with the unsafe blocks documented! I think working on it smaller chunks like this will be easier for everyone.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/156a05a2e79620605a1b59435cba7dc6fc365131", "html_url": "https://github.com/rust-lang/rust/commit/156a05a2e79620605a1b59435cba7dc6fc365131", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/156a05a2e79620605a1b59435cba7dc6fc365131/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "703dcff081aa9f4aef2e94fb25d6743692c2dd47", "url": "https://api.github.com/repos/rust-lang/rust/commits/703dcff081aa9f4aef2e94fb25d6743692c2dd47", "html_url": "https://github.com/rust-lang/rust/commit/703dcff081aa9f4aef2e94fb25d6743692c2dd47"}, {"sha": "3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9", "html_url": "https://github.com/rust-lang/rust/commit/3d146a3d1a58d35fb9198472ab2ccfb5eef9d1c9"}], "stats": {"total": 51, "additions": 45, "deletions": 6}, "files": [{"sha": "52d8349bc9a8770567f4079c2651b205bdaeab73", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/156a05a2e79620605a1b59435cba7dc6fc365131/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156a05a2e79620605a1b59435cba7dc6fc365131/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=156a05a2e79620605a1b59435cba7dc6fc365131", "patch": "@@ -2,8 +2,6 @@ use crate::fmt::{Debug, Display, Formatter, LowerExp, Result, UpperExp};\n use crate::mem::MaybeUninit;\n use crate::num::flt2dec;\n \n-// ignore-tidy-undocumented-unsafe\n-\n // Don't inline this so callers don't use the stack space this function\n // requires unless they have to.\n #[inline(never)]\n@@ -16,6 +14,7 @@ fn float_to_decimal_common_exact<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n+    // SAFETY: Possible undefined behavior, see FIXME(#53491)\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 4]>::uninit();\n@@ -48,6 +47,7 @@ fn float_to_decimal_common_shortest<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n+    // SAFETY: Possible undefined behavior, see FIXME(#53491)\n     unsafe {\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();\n@@ -103,6 +103,7 @@ fn float_to_exponential_common_exact<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n+    // SAFETY: Possible undefined behavior, see FIXME(#53491)\n     unsafe {\n         let mut buf = MaybeUninit::<[u8; 1024]>::uninit(); // enough for f32 and f64\n         let mut parts = MaybeUninit::<[flt2dec::Part<'_>; 6]>::uninit();\n@@ -132,6 +133,7 @@ fn float_to_exponential_common_shortest<T>(\n where\n     T: flt2dec::DecodableFloat,\n {\n+    // SAFETY: Possible undefined behavior, see FIXME(#53491)\n     unsafe {\n         // enough for f32 and f64\n         let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninit();"}, {"sha": "a93b34fc46cb935294d5f304d18771e47eeb4dd4", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/156a05a2e79620605a1b59435cba7dc6fc365131/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156a05a2e79620605a1b59435cba7dc6fc365131/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=156a05a2e79620605a1b59435cba7dc6fc365131", "patch": "@@ -1,7 +1,5 @@\n //! Utilities for formatting and printing strings.\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\n@@ -281,6 +279,14 @@ impl<'a> ArgumentV1<'a> {\n     #[doc(hidden)]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n     pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n+        // SAFETY: `mem::transmute(x)` is safe because\n+        //     1. `&'b T` keeps the lifetime it originated with `'b`\n+        //              (so as to not have an unbounded lifetime)\n+        //     2. `&'b T` and `&'b Void` have the same memory layout\n+        //              (when `T` is `Sized`, as it is here)\n+        // `mem::transmute(f)` is safe since `fn(&T, &mut Formatter<'_>) -> Result`\n+        // and `fn(&Void, &mut Formatter<'_>) -> Result` have the same ABI\n+        // (as long as `T` is `Sized`)\n         unsafe { ArgumentV1 { formatter: mem::transmute(f), value: mem::transmute(x) } }\n     }\n \n@@ -1399,6 +1405,14 @@ impl<'a> Formatter<'a> {\n \n     fn write_formatted_parts(&mut self, formatted: &flt2dec::Formatted<'_>) -> Result {\n         fn write_bytes(buf: &mut dyn Write, s: &[u8]) -> Result {\n+            // SAFETY: This is used for `flt2dec::Part::Num` and `flt2dec::Part::Copy`.\n+            // It's safe to use for `flt2dec::Part::Num` since every char `c` is between\n+            // `b'0'` and `b'9'`, which means `s` is valid UTF-8.\n+            // It's also probably safe in practice to use for `flt2dec::Part::Copy(buf)`\n+            // since `buf` should be plain ASCII, but it's possible for someone to pass\n+            // in a bad value for `buf` into `flt2dec::to_shortest_str` since it is a\n+            // public function.\n+            // FIXME: Determine whether this could result in UB.\n             buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n         }\n "}, {"sha": "7d77e33d743785f1c6f795b51659d411865b684a", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/156a05a2e79620605a1b59435cba7dc6fc365131/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156a05a2e79620605a1b59435cba7dc6fc365131/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=156a05a2e79620605a1b59435cba7dc6fc365131", "patch": "@@ -1,7 +1,5 @@\n //! Integer and floating-point number formatting\n \n-// ignore-tidy-undocumented-unsafe\n-\n use crate::fmt;\n use crate::mem::MaybeUninit;\n use crate::num::flt2dec;\n@@ -84,6 +82,8 @@ trait GenericRadix {\n             }\n         }\n         let buf = &buf[curr..];\n+        // SAFETY: The only chars in `buf` are created by `Self::digit` which are assumed to be\n+        // valid UTF-8\n         let buf = unsafe {\n             str::from_utf8_unchecked(slice::from_raw_parts(MaybeUninit::first_ptr(buf), buf.len()))\n         };\n@@ -189,11 +189,19 @@ static DEC_DIGITS_LUT: &[u8; 200] = b\"0001020304050607080910111213141516171819\\\n macro_rules! impl_Display {\n     ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) => {\n         fn $name(mut n: $u, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            // 2^128 is about 3*10^38, so 39 gives an extra byte of space\n             let mut buf = [MaybeUninit::<u8>::uninit(); 39];\n             let mut curr = buf.len() as isize;\n             let buf_ptr = MaybeUninit::first_ptr_mut(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n+            // SAFETY: Since `d1` and `d2` are always less than or equal to `198`, we\n+            // can copy from `lut_ptr[d1..d1 + 1]` and `lut_ptr[d2..d2 + 1]`. To show\n+            // that it's OK to copy into `buf_ptr`, notice that at the beginning\n+            // `curr == buf.len() == 39 > log(n)` since `n < 2^128 < 10^39`, and at\n+            // each step this is kept the same as `n` is divided. Since `n` is always\n+            // non-negative, this means that `curr > 0` so `buf_ptr[curr..curr + 1]`\n+            // is safe to access.\n             unsafe {\n                 // need at least 16 bits for the 4-characters-at-a-time to work.\n                 assert!(crate::mem::size_of::<$u>() >= 2);\n@@ -206,6 +214,10 @@ macro_rules! impl_Display {\n                     let d1 = (rem / 100) << 1;\n                     let d2 = (rem % 100) << 1;\n                     curr -= 4;\n+\n+                    // We are allowed to copy to `buf_ptr[curr..curr + 3]` here since\n+                    // otherwise `curr < 0`. But then `n` was originally at least `10000^10`\n+                    // which is `10^40 > 2^128 > n`.\n                     ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                     ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n                 }\n@@ -232,6 +244,8 @@ macro_rules! impl_Display {\n                 }\n             }\n \n+            // SAFETY: `curr` > 0 (since we made `buf` large enough), and all the chars are valid\n+            // UTF-8 since `DEC_DIGITS_LUT` is\n             let buf_slice = unsafe {\n                 str::from_utf8_unchecked(\n                     slice::from_raw_parts(buf_ptr.offset(curr), buf.len() - curr as usize))\n@@ -304,6 +318,8 @@ macro_rules! impl_Exp {\n             };\n \n             // 39 digits (worst case u128) + . = 40\n+            // Since `curr` always decreases by the number of digits copied, this means\n+            // that `curr >= 0`.\n             let mut buf = [MaybeUninit::<u8>::uninit(); 40];\n             let mut curr = buf.len() as isize; //index for buf\n             let buf_ptr = MaybeUninit::first_ptr_mut(&mut buf);\n@@ -313,6 +329,8 @@ macro_rules! impl_Exp {\n             while n >= 100 {\n                 let d1 = ((n % 100) as isize) << 1;\n                 curr -= 2;\n+                // SAFETY: `d1 <= 198`, so we can copy from `lut_ptr[d1..d1 + 2]` since\n+                // `DEC_DIGITS_LUT` has a length of 200.\n                 unsafe {\n                     ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n                 }\n@@ -324,6 +342,7 @@ macro_rules! impl_Exp {\n             // decode second-to-last character\n             if n >= 10 {\n                 curr -= 1;\n+                // SAFETY: Safe since `40 > curr >= 0` (see comment)\n                 unsafe {\n                     *buf_ptr.offset(curr) = (n as u8 % 10_u8) + b'0';\n                 }\n@@ -333,11 +352,13 @@ macro_rules! impl_Exp {\n             // add decimal point iff >1 mantissa digit will be printed\n             if exponent != trailing_zeros || added_precision != 0 {\n                 curr -= 1;\n+                // SAFETY: Safe since `40 > curr >= 0`\n                 unsafe {\n                     *buf_ptr.offset(curr) = b'.';\n                 }\n             }\n \n+            // SAFETY: Safe since `40 > curr >= 0`\n             let buf_slice = unsafe {\n                 // decode last character\n                 curr -= 1;\n@@ -350,6 +371,8 @@ macro_rules! impl_Exp {\n             // stores 'e' (or 'E') and the up to 2-digit exponent\n             let mut exp_buf = [MaybeUninit::<u8>::uninit(); 3];\n             let exp_ptr = MaybeUninit::first_ptr_mut(&mut exp_buf);\n+            // SAFETY: In either case, `exp_buf` is written within bounds and `exp_ptr[..len]`\n+            // is contained within `exp_buf` since `len <= 3`.\n             let exp_slice = unsafe {\n                 *exp_ptr.offset(0) = if upper {b'E'} else {b'e'};\n                 let len = if exponent < 10 {"}]}