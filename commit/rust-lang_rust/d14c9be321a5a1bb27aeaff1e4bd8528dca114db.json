{"sha": "d14c9be321a5a1bb27aeaff1e4bd8528dca114db", "node_id": "C_kwDOAAsO6NoAKGQxNGM5YmUzMjFhNWExYmIyN2FlYWZmMWU0YmQ4NTI4ZGNhMTE0ZGI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-11T12:09:20Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-11T12:09:20Z"}, "message": "Show cargo check failures to the user", "tree": {"sha": "cbfa3a74f8e6a91845beac7e783e6254f4b3e3f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbfa3a74f8e6a91845beac7e783e6254f4b3e3f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d14c9be321a5a1bb27aeaff1e4bd8528dca114db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d14c9be321a5a1bb27aeaff1e4bd8528dca114db", "html_url": "https://github.com/rust-lang/rust/commit/d14c9be321a5a1bb27aeaff1e4bd8528dca114db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d14c9be321a5a1bb27aeaff1e4bd8528dca114db/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "079e9fe49645fab8cb20a8cfb2da81915f018b04", "url": "https://api.github.com/repos/rust-lang/rust/commits/079e9fe49645fab8cb20a8cfb2da81915f018b04", "html_url": "https://github.com/rust-lang/rust/commit/079e9fe49645fab8cb20a8cfb2da81915f018b04"}], "stats": {"total": 131, "additions": 61, "deletions": 70}, "files": [{"sha": "7256f07688c0b7f2dac28d322e00c8bfbb03292a", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 57, "deletions": 69, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/d14c9be321a5a1bb27aeaff1e4bd8528dca114db/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d14c9be321a5a1bb27aeaff1e4bd8528dca114db/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=d14c9be321a5a1bb27aeaff1e4bd8528dca114db", "patch": "@@ -2,17 +2,12 @@\n //! another compatible command (f.x. clippy) in a background thread and provide\n //! LSP diagnostics based on the output of the command.\n \n-use std::{\n-    fmt,\n-    io::{self, BufRead, BufReader},\n-    process::{self, Command, Stdio},\n-    time::Duration,\n-};\n+use std::{fmt, io, process::Command, time::Duration};\n \n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n use paths::AbsPathBuf;\n use serde::Deserialize;\n-use stdx::JodChild;\n+use stdx::process::streaming_output;\n \n pub use cargo_metadata::diagnostic::{\n     Applicability, Diagnostic, DiagnosticCode, DiagnosticLevel, DiagnosticSpan,\n@@ -162,13 +157,10 @@ impl FlycheckActor {\n \n                     self.cancel_check_process();\n \n-                    let mut command = self.check_command();\n+                    let command = self.check_command();\n                     tracing::info!(\"restart flycheck {:?}\", command);\n-                    command.stdout(Stdio::piped()).stderr(Stdio::null()).stdin(Stdio::null());\n-                    if let Ok(child) = command.spawn().map(JodChild) {\n-                        self.cargo_handle = Some(CargoHandle::spawn(child));\n-                        self.progress(Progress::DidStart);\n-                    }\n+                    self.cargo_handle = Some(CargoHandle::spawn(command));\n+                    self.progress(Progress::DidStart);\n                 }\n                 Event::CheckEvent(None) => {\n                     // Watcher finished, replace it with a never channel to\n@@ -258,53 +250,37 @@ impl FlycheckActor {\n }\n \n struct CargoHandle {\n-    child: JodChild,\n     #[allow(unused)]\n-    thread: jod_thread::JoinHandle<bool>,\n+    thread: jod_thread::JoinHandle<io::Result<()>>,\n     receiver: Receiver<CargoMessage>,\n }\n \n impl CargoHandle {\n-    fn spawn(mut child: JodChild) -> CargoHandle {\n-        let child_stdout = child.stdout.take().unwrap();\n+    fn spawn(command: Command) -> CargoHandle {\n         let (sender, receiver) = unbounded();\n-        let actor = CargoActor::new(child_stdout, sender);\n+        let actor = CargoActor::new(sender);\n         let thread = jod_thread::Builder::new()\n             .name(\"CargoHandle\".to_owned())\n-            .spawn(move || actor.run())\n+            .spawn(move || actor.run(command))\n             .expect(\"failed to spawn thread\");\n-        CargoHandle { child, thread, receiver }\n+        CargoHandle { thread, receiver }\n     }\n-    fn join(mut self) -> io::Result<()> {\n-        // It is okay to ignore the result, as it only errors if the process is already dead\n-        let _ = self.child.kill();\n-        let exit_status = self.child.wait()?;\n-        let read_at_least_one_message = self.thread.join();\n-        if !exit_status.success() && !read_at_least_one_message {\n-            // FIXME: Read the stderr to display the reason, see `read2()` reference in PR comment:\n-            // https://github.com/rust-analyzer/rust-analyzer/pull/3632#discussion_r395605298\n-            return Err(io::Error::new(\n-                io::ErrorKind::Other,\n-                format!(\n-                    \"Cargo watcher failed, the command produced no valid metadata (exit code: {:?})\",\n-                    exit_status\n-                ),\n-            ));\n-        }\n-        Ok(())\n+\n+    fn join(self) -> io::Result<()> {\n+        self.thread.join()\n     }\n }\n \n struct CargoActor {\n-    child_stdout: process::ChildStdout,\n     sender: Sender<CargoMessage>,\n }\n \n impl CargoActor {\n-    fn new(child_stdout: process::ChildStdout, sender: Sender<CargoMessage>) -> CargoActor {\n-        CargoActor { child_stdout, sender }\n+    fn new(sender: Sender<CargoMessage>) -> CargoActor {\n+        CargoActor { sender }\n     }\n-    fn run(self) -> bool {\n+\n+    fn run(self, command: Command) -> io::Result<()> {\n         // We manually read a line at a time, instead of using serde's\n         // stream deserializers, because the deserializer cannot recover\n         // from an error, resulting in it getting stuck, because we try to\n@@ -313,41 +289,53 @@ impl CargoActor {\n         // Because cargo only outputs one JSON object per line, we can\n         // simply skip a line if it doesn't parse, which just ignores any\n         // erroneus output.\n-        let stdout = BufReader::new(self.child_stdout);\n-        let mut read_at_least_one_message = false;\n-        for message in stdout.lines() {\n-            let message = match message {\n-                Ok(message) => message,\n-                Err(err) => {\n-                    tracing::error!(\"Invalid json from cargo check, ignoring ({})\", err);\n-                    continue;\n-                }\n-            };\n \n-            read_at_least_one_message = true;\n+        let mut error = String::new();\n+        let mut read_at_least_one_message = false;\n+        let output = streaming_output(\n+            command,\n+            &mut |line| {\n+                read_at_least_one_message = true;\n \n-            // Try to deserialize a message from Cargo or Rustc.\n-            let mut deserializer = serde_json::Deserializer::from_str(&message);\n-            deserializer.disable_recursion_limit();\n-            if let Ok(message) = JsonMessage::deserialize(&mut deserializer) {\n-                match message {\n-                    // Skip certain kinds of messages to only spend time on what's useful\n-                    JsonMessage::Cargo(message) => match message {\n-                        cargo_metadata::Message::CompilerArtifact(artifact) if !artifact.fresh => {\n-                            self.sender.send(CargoMessage::CompilerArtifact(artifact)).unwrap();\n+                // Try to deserialize a message from Cargo or Rustc.\n+                let mut deserializer = serde_json::Deserializer::from_str(&line);\n+                deserializer.disable_recursion_limit();\n+                if let Ok(message) = JsonMessage::deserialize(&mut deserializer) {\n+                    match message {\n+                        // Skip certain kinds of messages to only spend time on what's useful\n+                        JsonMessage::Cargo(message) => match message {\n+                            cargo_metadata::Message::CompilerArtifact(artifact)\n+                                if !artifact.fresh =>\n+                            {\n+                                self.sender.send(CargoMessage::CompilerArtifact(artifact)).unwrap();\n+                            }\n+                            cargo_metadata::Message::CompilerMessage(msg) => {\n+                                self.sender.send(CargoMessage::Diagnostic(msg.message)).unwrap();\n+                            }\n+                            _ => (),\n+                        },\n+                        JsonMessage::Rustc(message) => {\n+                            self.sender.send(CargoMessage::Diagnostic(message)).unwrap();\n                         }\n-                        cargo_metadata::Message::CompilerMessage(msg) => {\n-                            self.sender.send(CargoMessage::Diagnostic(msg.message)).unwrap();\n-                        }\n-                        _ => (),\n-                    },\n-                    JsonMessage::Rustc(message) => {\n-                        self.sender.send(CargoMessage::Diagnostic(message)).unwrap();\n                     }\n                 }\n+            },\n+            &mut |line| {\n+                error.push_str(line);\n+                error.push('\\n');\n+            },\n+        );\n+        match output {\n+            Ok(_) if read_at_least_one_message => Ok(()),\n+            Ok(output) if output.status.success() => {\n+                Err(io::Error::new(io::ErrorKind::Other, format!(\n+                    \"Cargo watcher failed, the command produced no valid metadata (exit code: {:?})\",\n+                    output.status\n+                )))\n             }\n+            Ok(_) => Err(io::Error::new(io::ErrorKind::Other, error)),\n+            Err(e) => Err(e),\n         }\n-        read_at_least_one_message\n     }\n }\n "}, {"sha": "9e1bac854d5e146bfdd8aac8f77a81236cd14a8a", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d14c9be321a5a1bb27aeaff1e4bd8528dca114db/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d14c9be321a5a1bb27aeaff1e4bd8528dca114db/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=d14c9be321a5a1bb27aeaff1e4bd8528dca114db", "patch": "@@ -394,7 +394,10 @@ impl GlobalState {\n                                 flycheck::Progress::DidCancel => (Progress::End, None),\n                                 flycheck::Progress::DidFinish(result) => {\n                                     if let Err(err) = result {\n-                                        tracing::error!(\"cargo check failed: {}\", err)\n+                                        self.show_message(\n+                                            lsp_types::MessageType::Error,\n+                                            format!(\"cargo check failed: {}\", err),\n+                                        );\n                                     }\n                                     (Progress::End, None)\n                                 }"}]}