{"sha": "038f9255863d4e07805d8bbefa25e0b61ddfcad0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzOGY5MjU1ODYzZDRlMDc4MDVkOGJiZWZhMjVlMGI2MWRkZmNhZDA=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-06T22:50:50Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-06T22:55:18Z"}, "message": "Be less eager about implicit borrowing when doing method resolution. Closes #2796.", "tree": {"sha": "22b50664cfc39ba741d974a2f6c5261e9f7e91e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22b50664cfc39ba741d974a2f6c5261e9f7e91e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/038f9255863d4e07805d8bbefa25e0b61ddfcad0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/038f9255863d4e07805d8bbefa25e0b61ddfcad0", "html_url": "https://github.com/rust-lang/rust/commit/038f9255863d4e07805d8bbefa25e0b61ddfcad0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/038f9255863d4e07805d8bbefa25e0b61ddfcad0/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ceac155211e8330782024f1c6e8e10cf03245a8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceac155211e8330782024f1c6e8e10cf03245a8d", "html_url": "https://github.com/rust-lang/rust/commit/ceac155211e8330782024f1c6e8e10cf03245a8d"}], "stats": {"total": 82, "additions": 67, "deletions": 15}, "files": [{"sha": "b91f9778e1c847f66ef3a7e0435352020975b0d1", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/038f9255863d4e07805d8bbefa25e0b61ddfcad0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/038f9255863d4e07805d8bbefa25e0b61ddfcad0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=038f9255863d4e07805d8bbefa25e0b61ddfcad0", "patch": "@@ -77,16 +77,20 @@ class lookup {\n             // loop for impls in scope.  Note: I don't love these\n             // semantics, but that's what we had so I am preserving\n             // it.\n-            if self.candidates.len() > 0u {\n-                break;\n-            }\n+            if self.candidates.len() > 0u { break; }\n+\n+            // now look for impls in scope, but don't look for impls that\n+            // would require doing an implicit borrow of the lhs.\n+            self.add_candidates_from_scope(false);\n \n-            self.add_candidates_from_scope();\n+            // if we found anything, stop before trying borrows\n+            if self.candidates.len() > 0u { break; }\n+\n+            // now look for impls in scope that might require a borrow\n+            self.add_candidates_from_scope(true);\n \n             // if we found anything, stop before attempting auto-deref.\n-            if self.candidates.len() > 0u {\n-                break;\n-            }\n+            if self.candidates.len() > 0u { break; }\n \n             // check whether we can autoderef and if so loop around again.\n             alt ty::deref(self.tcx(), self.self_ty, false) {\n@@ -290,7 +294,7 @@ class lookup {\n         */\n     }\n \n-    fn add_candidates_from_scope() {\n+    fn add_candidates_from_scope(use_assignability: bool) {\n         let impls_vecs = self.fcx.ccx.impl_map.get(self.expr.id);\n         let mut added_any = false;\n \n@@ -306,13 +310,18 @@ class lookup {\n                     let {substs: impl_substs, ty: impl_ty} =\n                         impl_self_ty(self.fcx, im.did);\n \n-                    // if we can assign the caller to the callee, that's a\n-                    // potential match.  Collect those in the vector.\n-                    let can_assign = self.fcx.can_mk_assignty(\n-                        self.self_expr, self.borrow_scope,\n-                        self.self_ty, impl_ty);\n-                    #debug[\"can_assign = %?\", can_assign];\n-                    alt can_assign {\n+                    // Depending on our argument, we find potential\n+                    // matches either by checking subtypability or\n+                    // type assignability. Collect the matches.\n+                    let matches = if use_assignability {\n+                        self.fcx.can_mk_assignty(\n+                            self.self_expr, self.borrow_scope,\n+                            self.self_ty, impl_ty)\n+                    } else {\n+                        self.fcx.can_mk_subty(self.self_ty, impl_ty)\n+                    };\n+                    #debug[\"matches = %?\", matches];\n+                    alt matches {\n                       result::err(_) { /* keep looking */ }\n                       result::ok(_) {\n                         if !self.candidate_impls.contains_key(im.did) {"}, {"sha": "47cf7535a6e08858178cecb96a31167db2c8f18c", "filename": "src/test/run-pass/assignability-iface.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/038f9255863d4e07805d8bbefa25e0b61ddfcad0/src%2Ftest%2Frun-pass%2Fassignability-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/038f9255863d4e07805d8bbefa25e0b61ddfcad0/src%2Ftest%2Frun-pass%2Fassignability-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-iface.rs?ref=038f9255863d4e07805d8bbefa25e0b61ddfcad0", "patch": "@@ -0,0 +1,43 @@\n+// Tests that type assignability is used to search for instances when\n+// making method calls, but only if there aren't any matches without\n+// it.\n+\n+iface iterable<A> {\n+    fn iterate(blk: fn(A) -> bool);\n+}\n+\n+impl vec/&<A> of iterable<A> for &[const A] {\n+    fn iterate(f: fn(A) -> bool) {\n+        vec::each(self, f);\n+    }\n+}\n+\n+impl vec<A> of iterable<A> for ~[const A] {\n+    fn iterate(f: fn(A) -> bool) {\n+        vec::each(self, f);\n+    }\n+}\n+\n+fn length<A, T: iterable<A>>(x: T) -> uint {\n+    let mut len = 0;\n+    for x.iterate() |_y| { len += 1 }\n+    ret len;\n+}\n+\n+fn main() {\n+    let x = ~[0,1,2,3];\n+    // Call a method\n+    for x.iterate() |y| { assert x[y] == y; }\n+    // Call a parameterized function\n+    assert length(x) == vec::len(x);\n+    // Call a parameterized function, with type arguments that require\n+    // a borrow\n+    assert length::<int, &[int]>(x) == vec::len(x);\n+\n+    // Now try it with a type that *needs* to be borrowed\n+    let z = [0,1,2,3]/_;\n+    // Call a method\n+    for z.iterate() |y| { assert z[y] == y; }\n+    // Call a parameterized function\n+    assert length::<int, &[int]>(z) == vec::len(z);\n+}"}]}