{"sha": "f0d4b571936d4072ed90ab7750636f68f1443b3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZDRiNTcxOTM2ZDQwNzJlZDkwYWI3NzUwNjM2ZjY4ZjE0NDNiM2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-16T12:10:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-16T12:10:59Z"}, "message": "Auto merge of #67342 - Centril:rollup-fl44n41, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #65778 (Stabilize `std::{rc,sync}::Weak::{weak_count, strong_count}`)\n - #66570 (stabilize Result::map_or)\n - #66735 (Add str::strip_prefix and str::strip_suffix)\n - #66771 (Stabilize the `core::panic` module)\n - #67317 (fix type_name_of_val doc comment)\n - #67324 (Fix repetition in matches/mod.rs)\n - #67325 (cleanup with push_fake_read)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "4fc99aa630f968c89e1baf45b39b30b09b01b59c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fc99aa630f968c89e1baf45b39b30b09b01b59c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0d4b571936d4072ed90ab7750636f68f1443b3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0d4b571936d4072ed90ab7750636f68f1443b3e", "html_url": "https://github.com/rust-lang/rust/commit/f0d4b571936d4072ed90ab7750636f68f1443b3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0d4b571936d4072ed90ab7750636f68f1443b3e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a605441e049f0b6d5f7715b94b8ac4662fd7fcf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a605441e049f0b6d5f7715b94b8ac4662fd7fcf6", "html_url": "https://github.com/rust-lang/rust/commit/a605441e049f0b6d5f7715b94b8ac4662fd7fcf6"}, {"sha": "71a9a993fbca86dd5144a9993d4658e360edccb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/71a9a993fbca86dd5144a9993d4658e360edccb5", "html_url": "https://github.com/rust-lang/rust/commit/71a9a993fbca86dd5144a9993d4658e360edccb5"}], "stats": {"total": 260, "additions": 146, "deletions": 114}, "files": [{"sha": "42a278de98befd7ccfedd347734e616bd31b6ac4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=f0d4b571936d4072ed90ab7750636f68f1443b3e", "patch": "@@ -1836,7 +1836,7 @@ impl<T: ?Sized> Weak<T> {\n     /// If `self` was created using [`Weak::new`], this will return 0.\n     ///\n     /// [`Weak::new`]: #method.new\n-    #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n+    #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn strong_count(&self) -> usize {\n         if let Some(inner) = self.inner() {\n             inner.strong()\n@@ -1847,20 +1847,16 @@ impl<T: ?Sized> Weak<T> {\n \n     /// Gets the number of `Weak` pointers pointing to this allocation.\n     ///\n-    /// If `self` was created using [`Weak::new`], this will return `None`. If\n-    /// not, the returned value is at least 1, since `self` still points to the\n-    /// allocation.\n-    ///\n-    /// [`Weak::new`]: #method.new\n-    #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n-    pub fn weak_count(&self) -> Option<usize> {\n+    /// If no strong pointers remain, this will return zero.\n+    #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n+    pub fn weak_count(&self) -> usize {\n         self.inner().map(|inner| {\n             if inner.strong() > 0 {\n                 inner.weak() - 1  // subtract the implicit weak ptr\n             } else {\n-                inner.weak()\n+                0\n             }\n-        })\n+        }).unwrap_or(0)\n     }\n \n     /// Returns `None` when the pointer is dangling and there is no allocated `RcBox`"}, {"sha": "bf5c85a5c59601af7a142a7483d419b723c66382", "filename": "src/liballoc/rc/tests.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Fliballoc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Fliballoc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc%2Ftests.rs?ref=f0d4b571936d4072ed90ab7750636f68f1443b3e", "patch": "@@ -114,28 +114,28 @@ fn test_weak_count() {\n \n #[test]\n fn weak_counts() {\n-    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), 0);\n     assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n \n     let a = Rc::new(0);\n     let w = Rc::downgrade(&a);\n     assert_eq!(Weak::strong_count(&w), 1);\n-    assert_eq!(Weak::weak_count(&w), Some(1));\n+    assert_eq!(Weak::weak_count(&w), 1);\n     let w2 = w.clone();\n     assert_eq!(Weak::strong_count(&w), 1);\n-    assert_eq!(Weak::weak_count(&w), Some(2));\n+    assert_eq!(Weak::weak_count(&w), 2);\n     assert_eq!(Weak::strong_count(&w2), 1);\n-    assert_eq!(Weak::weak_count(&w2), Some(2));\n+    assert_eq!(Weak::weak_count(&w2), 2);\n     drop(w);\n     assert_eq!(Weak::strong_count(&w2), 1);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 1);\n     let a2 = a.clone();\n     assert_eq!(Weak::strong_count(&w2), 2);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 1);\n     drop(a2);\n     drop(a);\n     assert_eq!(Weak::strong_count(&w2), 0);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 0);\n     drop(w2);\n }\n "}, {"sha": "a99564c0dac8a97f10beec0df3b74b54de4d181e", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=f0d4b571936d4072ed90ab7750636f68f1443b3e", "patch": "@@ -12,7 +12,7 @@ use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n use core::fmt;\n-use core::cmp::{self, Ordering};\n+use core::cmp::Ordering;\n use core::iter;\n use core::intrinsics::abort;\n use core::mem::{self, align_of, align_of_val, size_of_val};\n@@ -1529,7 +1529,7 @@ impl<T: ?Sized> Weak<T> {\n     /// If `self` was created using [`Weak::new`], this will return 0.\n     ///\n     /// [`Weak::new`]: #method.new\n-    #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n+    #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n     pub fn strong_count(&self) -> usize {\n         if let Some(inner) = self.inner() {\n             inner.strong.load(SeqCst)\n@@ -1541,9 +1541,8 @@ impl<T: ?Sized> Weak<T> {\n     /// Gets an approximation of the number of `Weak` pointers pointing to this\n     /// allocation.\n     ///\n-    /// If `self` was created using [`Weak::new`], this will return 0. If not,\n-    /// the returned value is at least 1, since `self` still points to the\n-    /// allocation.\n+    /// If `self` was created using [`Weak::new`], or if there are no remaining\n+    /// strong pointers, this will return 0.\n     ///\n     /// # Accuracy\n     ///\n@@ -1552,31 +1551,22 @@ impl<T: ?Sized> Weak<T> {\n     /// `Weak`s pointing to the same allocation.\n     ///\n     /// [`Weak::new`]: #method.new\n-    #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n-    pub fn weak_count(&self) -> Option<usize> {\n-        // Due to the implicit weak pointer added when any strong pointers are\n-        // around, we cannot implement `weak_count` correctly since it\n-        // necessarily requires accessing the strong count and weak count in an\n-        // unsynchronized fashion. So this version is a bit racy.\n+    #[stable(feature = \"weak_counts\", since = \"1.41.0\")]\n+    pub fn weak_count(&self) -> usize {\n         self.inner().map(|inner| {\n-            let strong = inner.strong.load(SeqCst);\n             let weak = inner.weak.load(SeqCst);\n+            let strong = inner.strong.load(SeqCst);\n             if strong == 0 {\n-                // If the last `Arc` has *just* been dropped, it might not yet\n-                // have removed the implicit weak count, so the value we get\n-                // here might be 1 too high.\n-                weak\n+                0\n             } else {\n-                // As long as there's still at least 1 `Arc` around, subtract\n-                // the implicit weak pointer.\n-                // Note that the last `Arc` might get dropped between the 2\n-                // loads we do above, removing the implicit weak pointer. This\n-                // means that the value might be 1 too low here. In order to not\n-                // return 0 here (which would happen if we're the only weak\n-                // pointer), we guard against that specifically.\n-                cmp::max(1, weak - 1)\n+                // Since we observed that there was at least one strong pointer\n+                // after reading the weak count, we know that the implicit weak\n+                // reference (present whenever any strong references are alive)\n+                // was still around when we observed the weak count, and can\n+                // therefore safely subtract it.\n+                weak - 1\n             }\n-        })\n+        }).unwrap_or(0)\n     }\n \n     /// Returns `None` when the pointer is dangling and there is no allocated `ArcInner`,"}, {"sha": "8f516129cd00f4a4eb8c6df315da2680413411e0", "filename": "src/liballoc/sync/tests.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=f0d4b571936d4072ed90ab7750636f68f1443b3e", "patch": "@@ -62,28 +62,28 @@ fn test_arc_get_mut() {\n \n #[test]\n fn weak_counts() {\n-    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), 0);\n     assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n \n     let a = Arc::new(0);\n     let w = Arc::downgrade(&a);\n     assert_eq!(Weak::strong_count(&w), 1);\n-    assert_eq!(Weak::weak_count(&w), Some(1));\n+    assert_eq!(Weak::weak_count(&w), 1);\n     let w2 = w.clone();\n     assert_eq!(Weak::strong_count(&w), 1);\n-    assert_eq!(Weak::weak_count(&w), Some(2));\n+    assert_eq!(Weak::weak_count(&w), 2);\n     assert_eq!(Weak::strong_count(&w2), 1);\n-    assert_eq!(Weak::weak_count(&w2), Some(2));\n+    assert_eq!(Weak::weak_count(&w2), 2);\n     drop(w);\n     assert_eq!(Weak::strong_count(&w2), 1);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 1);\n     let a2 = a.clone();\n     assert_eq!(Weak::strong_count(&w2), 2);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 1);\n     drop(a2);\n     drop(a);\n     assert_eq!(Weak::strong_count(&w2), 0);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 0);\n     drop(w2);\n }\n "}, {"sha": "7935c9b1b392d1eff46a453539d572cd50229b6e", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=f0d4b571936d4072ed90ab7750636f68f1443b3e", "patch": "@@ -476,7 +476,7 @@ pub const fn type_name<T: ?Sized>() -> &'static str {\n ///\n /// This is intended for diagnostic use. The exact contents and format of the\n /// string are not specified, other than being a best-effort description of the\n-/// type. For example, `type_name_of::<Option<String>>(None)` could return the\n+/// type. For example, `type_name_of::<Option<String>>(None)` could return\n /// `\"Option<String>\"` or `\"std::option::Option<std::string::String>\"`, but not\n /// `\"foobar\"`. In addition, the output may change between versions of the\n /// compiler."}, {"sha": "48bb504a73c3480c8fc818a3729b18565b325651", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=f0d4b571936d4072ed90ab7750636f68f1443b3e", "patch": "@@ -1,8 +1,6 @@\n //! Panic support in the standard library.\n \n-#![unstable(feature = \"core_panic_info\",\n-            reason = \"newly available in libcore\",\n-            issue = \"44489\")]\n+#![stable(feature = \"core_panic_info\", since = \"1.41.0\")]\n \n use crate::any::Any;\n use crate::fmt;\n@@ -39,10 +37,10 @@ pub struct PanicInfo<'a> {\n }\n \n impl<'a> PanicInfo<'a> {\n-    #![unstable(feature = \"panic_internals\",\n-                reason = \"internal details of the implementation of the `panic!` \\\n-                          and related macros\",\n-                issue = \"0\")]\n+    #[unstable(feature = \"panic_internals\",\n+               reason = \"internal details of the implementation of the `panic!` \\\n+                         and related macros\",\n+               issue = \"0\")]\n     #[doc(hidden)]\n     #[inline]\n     pub fn internal_constructor(\n@@ -57,6 +55,10 @@ impl<'a> PanicInfo<'a> {\n         }\n     }\n \n+    #[unstable(feature = \"panic_internals\",\n+               reason = \"internal details of the implementation of the `panic!` \\\n+                         and related macros\",\n+               issue = \"0\")]\n     #[doc(hidden)]\n     #[inline]\n     pub fn set_payload(&mut self, info: &'a (dyn Any + Send)) {\n@@ -90,7 +92,7 @@ impl<'a> PanicInfo<'a> {\n     /// returns that message ready to be used for example with [`fmt::write`]\n     ///\n     /// [`fmt::write`]: ../fmt/fn.write.html\n-    #[unstable(feature = \"panic_info_message\", issue = \"44489\")]\n+    #[unstable(feature = \"panic_info_message\", issue = \"66745\")]\n     pub fn message(&self) -> Option<&fmt::Arguments<'_>> {\n         self.message\n     }"}, {"sha": "fb4dc62d8c176dacdf653d00cd371d998a211195", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=f0d4b571936d4072ed90ab7750636f68f1443b3e", "patch": "@@ -520,15 +520,14 @@ impl<T, E> Result<T, E> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(result_map_or)]\n     /// let x: Result<_, &str> = Ok(\"foo\");\n     /// assert_eq!(x.map_or(42, |v| v.len()), 3);\n     ///\n     /// let x: Result<&str, _> = Err(\"bar\");\n     /// assert_eq!(x.map_or(42, |v| v.len()), 42);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"result_map_or\", issue = \"66293\")]\n+    #[stable(feature = \"result_map_or\", since = \"1.41.0\")]\n     pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {\n         match self {\n             Ok(t) => f(t),"}, {"sha": "763714e536edc04746142bddd78c431713946dc0", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=f0d4b571936d4072ed90ab7750636f68f1443b3e", "patch": "@@ -8,7 +8,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use self::pattern::Pattern;\n-use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n+use self::pattern::{Searcher, SearchStep, ReverseSearcher, DoubleEndedSearcher};\n \n use crate::char;\n use crate::fmt::{self, Write};\n@@ -3798,6 +3798,77 @@ impl str {\n         }\n     }\n \n+    /// Returns a string slice with the prefix removed.\n+    ///\n+    /// If the string starts with the pattern `prefix`, `Some` is returned with the substring where\n+    /// the prefix is removed. Unlike `trim_start_matches`, this method removes the prefix exactly\n+    /// once.\n+    ///\n+    /// If the string does not start with `prefix`, `None` is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(str_strip)]\n+    ///\n+    /// assert_eq!(\"foobar\".strip_prefix(\"foo\"), Some(\"bar\"));\n+    /// assert_eq!(\"foobar\".strip_prefix(\"bar\"), None);\n+    /// assert_eq!(\"foofoo\".strip_prefix(\"foo\"), Some(\"foo\"));\n+    /// ```\n+    #[must_use = \"this returns the remaining substring as a new slice, \\\n+                  without modifying the original\"]\n+    #[unstable(feature = \"str_strip\", reason = \"newly added\", issue = \"67302\")]\n+    pub fn strip_prefix<'a, P: Pattern<'a>>(&'a self, prefix: P) -> Option<&'a str> {\n+        let mut matcher = prefix.into_searcher(self);\n+        if let SearchStep::Match(start, len) = matcher.next() {\n+            debug_assert_eq!(start, 0, \"The first search step from Searcher \\\n+                must include the first character\");\n+            unsafe {\n+                // Searcher is known to return valid indices.\n+                Some(self.get_unchecked(len..))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns a string slice with the suffix removed.\n+    ///\n+    /// If the string ends with the pattern `suffix`, `Some` is returned with the substring where\n+    /// the suffix is removed. Unlike `trim_end_matches`, this method removes the suffix exactly\n+    /// once.\n+    ///\n+    /// If the string does not end with `suffix`, `None` is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(str_strip)]\n+    /// assert_eq!(\"barfoo\".strip_suffix(\"foo\"), Some(\"bar\"));\n+    /// assert_eq!(\"barfoo\".strip_suffix(\"bar\"), None);\n+    /// assert_eq!(\"foofoo\".strip_suffix(\"foo\"), Some(\"foo\"));\n+    /// ```\n+    #[must_use = \"this returns the remaining substring as a new slice, \\\n+                  without modifying the original\"]\n+    #[unstable(feature = \"str_strip\", reason = \"newly added\", issue = \"67302\")]\n+    pub fn strip_suffix<'a, P>(&'a self, suffix: P) -> Option<&'a str>\n+    where\n+        P: Pattern<'a>,\n+        <P as Pattern<'a>>::Searcher: ReverseSearcher<'a>,\n+    {\n+        let mut matcher = suffix.into_searcher(self);\n+        if let SearchStep::Match(start, end) = matcher.next_back() {\n+            debug_assert_eq!(end, self.len(), \"The first search step from ReverseSearcher \\\n+                must include the last character\");\n+            unsafe {\n+                // Searcher is known to return valid indices.\n+                Some(self.get_unchecked(..start))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Returns a string slice with all suffixes that match a pattern\n     /// repeatedly removed.\n     ///"}, {"sha": "6bd8d2f7c0792b36c1a1a9006d50b28ed268210e", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=f0d4b571936d4072ed90ab7750636f68f1443b3e", "patch": "@@ -59,6 +59,18 @@ impl<'tcx> CFG<'tcx> {\n         ));\n     }\n \n+    pub fn push_fake_read(\n+        &mut self,\n+        block: BasicBlock,\n+        source_info: SourceInfo,\n+        cause: FakeReadCause,\n+        place: Place<'tcx>,\n+    ) {\n+        let kind = StatementKind::FakeRead(cause, box place);\n+        let stmt = Statement { source_info, kind };\n+        self.push(block, stmt);\n+    }\n+\n     pub fn terminate(&mut self,\n                      block: BasicBlock,\n                      source_info: SourceInfo,"}, {"sha": "ddacda72e1e656b133aa60c02475adf9029741cb", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=f0d4b571936d4072ed90ab7750636f68f1443b3e", "patch": "@@ -484,24 +484,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     fn read_fake_borrows(\n         &mut self,\n-        block: BasicBlock,\n+        bb: BasicBlock,\n         fake_borrow_temps: &mut Vec<Local>,\n         source_info: SourceInfo,\n     ) {\n         // All indexes have been evaluated now, read all of the\n         // fake borrows so that they are live across those index\n         // expressions.\n         for temp in fake_borrow_temps {\n-            self.cfg.push(\n-                block,\n-                Statement {\n-                    source_info,\n-                    kind: StatementKind::FakeRead(\n-                        FakeReadCause::ForIndex,\n-                        Box::new(Place::from(*temp)),\n-                    )\n-                }\n-            );\n+            self.cfg.push_fake_read(bb, source_info, FakeReadCause::ForIndex, Place::from(*temp));\n         }\n     }\n }"}, {"sha": "bf0b2439c00b5924119452edd3dba08b2f96b519", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 10, "deletions": 39, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=f0d4b571936d4072ed90ab7750636f68f1443b3e", "patch": "@@ -69,8 +69,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// 3. Create the decision tree and record the places that we bind or test.\n     /// 4. Determine the fake borrows that are needed from the above places.\n     ///    Create the required temporaries for them.\n-    /// 5. Create everything else: Create everything else: the guards and the\n-    ///    arms.\n+    /// 5. Create everything else: the guards and the arms.\n     ///\n     /// ## Fake Reads and borrows\n     ///\n@@ -132,13 +131,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // check safety.\n \n         let source_info = self.source_info(scrutinee_span);\n-        self.cfg.push(block, Statement {\n-            source_info,\n-            kind: StatementKind::FakeRead(\n-                FakeReadCause::ForMatchedPlace,\n-                box(scrutinee_place.clone()),\n-            ),\n-        });\n+        let cause_matched_place = FakeReadCause::ForMatchedPlace;\n+        self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place.clone());\n \n         // Step 2. Create the otherwise and prebinding blocks.\n \n@@ -314,16 +308,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n                 unpack!(block = self.into(&place, block, initializer));\n \n-\n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let source_info = self.source_info(irrefutable_pat.span);\n-                self.cfg.push(\n-                    block,\n-                    Statement {\n-                        source_info,\n-                        kind: StatementKind::FakeRead(FakeReadCause::ForLet, box(place)),\n-                    },\n-                );\n+                self.cfg.push_fake_read(block, source_info, FakeReadCause::ForLet, place);\n \n                 self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n@@ -359,13 +346,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 // Inject a fake read, see comments on `FakeReadCause::ForLet`.\n                 let pattern_source_info = self.source_info(irrefutable_pat.span);\n-                self.cfg.push(\n-                    block,\n-                    Statement {\n-                        source_info: pattern_source_info,\n-                        kind: StatementKind::FakeRead(FakeReadCause::ForLet, box(place.clone())),\n-                    },\n-                );\n+                let cause_let = FakeReadCause::ForLet;\n+                self.cfg.push_fake_read(block, pattern_source_info, cause_let, place.clone());\n \n                 let ty_source_info = self.source_info(user_ty_span);\n                 let user_ty = pat_ascription_ty.user_ty(\n@@ -1516,13 +1498,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             );\n \n             for &(_, temp) in fake_borrows {\n-                self.cfg.push(post_guard_block, Statement {\n-                    source_info: guard_end,\n-                    kind: StatementKind::FakeRead(\n-                        FakeReadCause::ForMatchGuard,\n-                        box(Place::from(temp)),\n-                    ),\n-                });\n+                let cause = FakeReadCause::ForMatchGuard;\n+                self.cfg.push_fake_read(post_guard_block, guard_end, cause, Place::from(temp));\n             }\n \n             self.exit_scope(\n@@ -1565,14 +1542,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // place they refer to can't be modified by the guard.\n             for binding in by_value_bindings.clone() {\n                 let local_id = self.var_local_id(binding.var_id, RefWithinGuard);\n-                let place = Place::from(local_id);\n-                self.cfg.push(\n-                    post_guard_block,\n-                    Statement {\n-                        source_info: guard_end,\n-                        kind: StatementKind::FakeRead(FakeReadCause::ForGuardBinding, box(place)),\n-                    },\n-                );\n+                let cause = FakeReadCause::ForGuardBinding;\n+                self.cfg.push_fake_read(post_guard_block, guard_end, cause, Place::from(local_id));\n             }\n             self.bind_matched_candidate_for_arm_body(\n                 post_guard_block,"}, {"sha": "c4d89b1494d02812421360dee21b6423c2d0b757", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=f0d4b571936d4072ed90ab7750636f68f1443b3e", "patch": "@@ -517,7 +517,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     let left_bits = place_layout.size.bits();\n                     let right_size = r.layout.size;\n                     let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n-                    if r_bits.ok().map_or(false, |b| b >= left_bits as u128) {\n+                    if r_bits.map_or(false, |b| b >= left_bits as u128) {\n                         let lint_root = match &self.source_scopes[source_info.scope].local_data {\n                             ClearCrossCrate::Set(data) => data.lint_root,\n                             ClearCrossCrate::Clear => return None,"}, {"sha": "880ead0e3018a070e21e17f725dd196ae5eb241f", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=f0d4b571936d4072ed90ab7750636f68f1443b3e", "patch": "@@ -1456,7 +1456,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     pcx.method_name = Some(method_name);\n                     pcx.assemble_inherent_candidates();\n                     pcx.assemble_extension_candidates_for_traits_in_scope(hir::DUMMY_HIR_ID)\n-                        .ok().map_or(None, |_| {\n+                        .map_or(None, |_| {\n                             pcx.pick_core()\n                                 .and_then(|pick| pick.ok())\n                                 .and_then(|pick| Some(pick.item))"}, {"sha": "09bea80c95a93d5b2ecaa40fd9876092f7ff2aeb", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0d4b571936d4072ed90ab7750636f68f1443b3e/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=f0d4b571936d4072ed90ab7750636f68f1443b3e", "patch": "@@ -74,7 +74,7 @@ impl TermInfo {\n             Err(..) => return Err(Error::TermUnset),\n         };\n \n-        if term.is_err() && env::var(\"MSYSCON\").ok().map_or(false, |s| \"mintty.exe\" == s) {\n+        if term.is_err() && env::var(\"MSYSCON\").map_or(false, |s| \"mintty.exe\" == s) {\n             // msys terminal\n             Ok(msys_terminfo())\n         } else {"}]}