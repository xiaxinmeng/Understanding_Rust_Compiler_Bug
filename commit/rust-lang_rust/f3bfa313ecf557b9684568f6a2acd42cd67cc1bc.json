{"sha": "f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYmZhMzEzZWNmNTU3Yjk2ODQ1NjhmNmEyYWNkNDJjZDY3Y2MxYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-30T15:13:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-30T15:13:08Z"}, "message": "Auto merge of #33965 - Manishearth:rollup, r=Manishearth\n\nRollup of 5 pull requests\n\n- Successful merges: #33867, #33926, #33942, #33958, #33964\n- Failed merges:", "tree": {"sha": "4d000fa349659239a36d57c9215b400e5cdc9ef4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d000fa349659239a36d57c9215b400e5cdc9ef4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "html_url": "https://github.com/rust-lang/rust/commit/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5da602bda3f30a8943dd4d10383bae6d8a77575c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5da602bda3f30a8943dd4d10383bae6d8a77575c", "html_url": "https://github.com/rust-lang/rust/commit/5da602bda3f30a8943dd4d10383bae6d8a77575c"}, {"sha": "26c209897f4ae230828898551725cceced59e329", "url": "https://api.github.com/repos/rust-lang/rust/commits/26c209897f4ae230828898551725cceced59e329", "html_url": "https://github.com/rust-lang/rust/commit/26c209897f4ae230828898551725cceced59e329"}], "stats": {"total": 361, "additions": 196, "deletions": 165}, "files": [{"sha": "a5449b748dd5e98c2434bb2d86774f21bd9a62d4", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "patch": "@@ -117,6 +117,7 @@\n from htmlentitydefs import entitydefs\n entitydefs['larrb'] = u'\\u21e4'\n entitydefs['rarrb'] = u'\\u21e5'\n+entitydefs['nbsp'] = ' '\n \n # \"void elements\" (no closing tag) from the HTML Standard section 12.1.2\n VOID_ELEMENTS = set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',"}, {"sha": "d6d944fde5f5ef56669d6665209ffa928b42c4c8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "patch": "@@ -63,7 +63,7 @@ use syntax_ext;\n \n #[derive(Clone)]\n pub struct Resolutions {\n-    pub def_map: RefCell<DefMap>,\n+    pub def_map: DefMap,\n     pub freevars: FreevarMap,\n     pub trait_map: TraitMap,\n     pub maybe_unused_trait_imports: NodeSet,\n@@ -818,7 +818,7 @@ pub fn lower_and_resolve<'a>(sess: &Session,\n             name: &id,\n             glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n         }, Resolutions {\n-            def_map: RefCell::new(resolver.def_map),\n+            def_map: resolver.def_map,\n             freevars: resolver.freevars,\n             trait_map: resolver.trait_map,\n             maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n@@ -866,7 +866,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                 \"lifetime resolution\",\n                                 || middle::resolve_lifetime::krate(sess,\n                                                                    &hir_map,\n-                                                                   &resolutions.def_map.borrow()))?;\n+                                                                   &resolutions.def_map))?;\n \n     time(time_passes,\n          \"looking for entry point\",\n@@ -886,14 +886,14 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     time(time_passes,\n               \"static item recursion checking\",\n-              || static_recursion::check_crate(sess, &resolutions.def_map.borrow(), &hir_map))?;\n+              || static_recursion::check_crate(sess, &resolutions.def_map, &hir_map))?;\n \n     let index = stability::Index::new(&hir_map);\n \n     let trait_map = resolutions.trait_map;\n     TyCtxt::create_and_enter(sess,\n                              arenas,\n-                             resolutions.def_map,\n+                             RefCell::new(resolutions.def_map),\n                              named_region_map,\n                              hir_map,\n                              resolutions.freevars,"}, {"sha": "b1df80403c0637ab32c75ec6216cd2239d632113", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "patch": "@@ -29,6 +29,7 @@ use rustc_metadata::cstore::CStore;\n use rustc_metadata::creader::read_local_crates;\n use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n+use std::cell::RefCell;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi::Abi;\n@@ -134,12 +135,12 @@ fn test_env<F>(source_string: &str,\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(&sess, &ast_map);\n-    let named_region_map = resolve_lifetime::krate(&sess, &ast_map, &resolutions.def_map.borrow());\n+    let named_region_map = resolve_lifetime::krate(&sess, &ast_map, &resolutions.def_map);\n     let region_map = region::resolve_crate(&sess, &ast_map);\n     let index = stability::Index::new(&ast_map);\n     TyCtxt::create_and_enter(&sess,\n                              &arenas,\n-                             resolutions.def_map,\n+                             RefCell::new(resolutions.def_map),\n                              named_region_map.unwrap(),\n                              ast_map,\n                              resolutions.freevars,"}, {"sha": "b3f5f8e536052c09769d8bb246dcd68f8586d6ad", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "patch": "@@ -18,7 +18,9 @@ use std::path::Path;\n use std::slice;\n use std::str;\n \n-pub struct ArchiveRO { ptr: ArchiveRef }\n+pub struct ArchiveRO {\n+    ptr: ArchiveRef,\n+}\n \n pub struct Iter<'a> {\n     archive: &'a ArchiveRO,\n@@ -61,11 +63,16 @@ impl ArchiveRO {\n         }\n     }\n \n-    pub fn raw(&self) -> ArchiveRef { self.ptr }\n+    pub fn raw(&self) -> ArchiveRef {\n+        self.ptr\n+    }\n \n     pub fn iter(&self) -> Iter {\n         unsafe {\n-            Iter { ptr: ::LLVMRustArchiveIteratorNew(self.ptr), archive: self }\n+            Iter {\n+                ptr: ::LLVMRustArchiveIteratorNew(self.ptr),\n+                archive: self,\n+            }\n         }\n     }\n }\n@@ -86,7 +93,10 @@ impl<'a> Iterator for Iter<'a> {\n         if ptr.is_null() {\n             ::last_error().map(Err)\n         } else {\n-            Some(Ok(Child { ptr: ptr, _data: marker::PhantomData }))\n+            Some(Ok(Child {\n+                ptr: ptr,\n+                _data: marker::PhantomData,\n+            }))\n         }\n     }\n }\n@@ -107,8 +117,7 @@ impl<'a> Child<'a> {\n             if name_ptr.is_null() {\n                 None\n             } else {\n-                let name = slice::from_raw_parts(name_ptr as *const u8,\n-                                                 name_len as usize);\n+                let name = slice::from_raw_parts(name_ptr as *const u8, name_len as usize);\n                 str::from_utf8(name).ok().map(|s| s.trim())\n             }\n         }\n@@ -125,11 +134,15 @@ impl<'a> Child<'a> {\n         }\n     }\n \n-    pub fn raw(&self) -> ::ArchiveChildRef { self.ptr }\n+    pub fn raw(&self) -> ::ArchiveChildRef {\n+        self.ptr\n+    }\n }\n \n impl<'a> Drop for Child<'a> {\n     fn drop(&mut self) {\n-        unsafe { ::LLVMRustArchiveChildFree(self.ptr); }\n+        unsafe {\n+            ::LLVMRustArchiveChildFree(self.ptr);\n+        }\n     }\n }"}, {"sha": "250aafd77a82664e22a09b0b5503cafaa6d13dd2", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "patch": "@@ -21,20 +21,25 @@ fn main() {\n     println!(\"cargo:rustc-cfg=cargobuild\");\n \n     let target = env::var(\"TARGET\").unwrap();\n-    let llvm_config = env::var_os(\"LLVM_CONFIG\").map(PathBuf::from)\n-                           .unwrap_or_else(|| {\n-        match env::var_os(\"CARGO_TARGET_DIR\").map(PathBuf::from) {\n-            Some(dir) => {\n-                let to_test = dir.parent().unwrap().parent().unwrap()\n-                                 .join(&target).join(\"llvm/bin/llvm-config\");\n-                if Command::new(&to_test).output().is_ok() {\n-                    return to_test\n-                }\n-            }\n-            None => {}\n-        }\n-        PathBuf::from(\"llvm-config\")\n-    });\n+    let llvm_config = env::var_os(\"LLVM_CONFIG\")\n+                          .map(PathBuf::from)\n+                          .unwrap_or_else(|| {\n+                              match env::var_os(\"CARGO_TARGET_DIR\").map(PathBuf::from) {\n+                                  Some(dir) => {\n+                                      let to_test = dir.parent()\n+                                                       .unwrap()\n+                                                       .parent()\n+                                                       .unwrap()\n+                                                       .join(&target)\n+                                                       .join(\"llvm/bin/llvm-config\");\n+                                      if Command::new(&to_test).output().is_ok() {\n+                                          return to_test;\n+                                      }\n+                                  }\n+                                  None => {}\n+                              }\n+                              PathBuf::from(\"llvm-config\")\n+                          });\n \n     println!(\"cargo:rerun-if-changed={}\", llvm_config.display());\n \n@@ -63,20 +68,22 @@ fn main() {\n     let host = env::var(\"HOST\").unwrap();\n     let is_crossed = target != host;\n \n-    let optional_components = [\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\",\n-                               \"pnacl\"];\n+    let optional_components = [\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\", \"pnacl\"];\n \n     // FIXME: surely we don't need all these components, right? Stuff like mcjit\n     //        or interpreter the compiler itself never uses.\n-    let required_components = &[\"ipo\", \"bitreader\", \"bitwriter\", \"linker\",\n-                                \"asmparser\", \"mcjit\", \"interpreter\",\n+    let required_components = &[\"ipo\",\n+                                \"bitreader\",\n+                                \"bitwriter\",\n+                                \"linker\",\n+                                \"asmparser\",\n+                                \"mcjit\",\n+                                \"interpreter\",\n                                 \"instrumentation\"];\n \n     let components = output(Command::new(&llvm_config).arg(\"--components\"));\n     let mut components = components.split_whitespace().collect::<Vec<_>>();\n-    components.retain(|c| {\n-        optional_components.contains(c) || required_components.contains(c)\n-    });\n+    components.retain(|c| optional_components.contains(c) || required_components.contains(c));\n \n     for component in required_components {\n         if !components.contains(component) {\n@@ -96,7 +103,7 @@ fn main() {\n     for flag in cxxflags.split_whitespace() {\n         // Ignore flags like `-m64` when we're doing a cross build\n         if is_crossed && flag.starts_with(\"-m\") {\n-            continue\n+            continue;\n         }\n         cfg.flag(flag);\n     }\n@@ -131,7 +138,7 @@ fn main() {\n         } else if lib.starts_with(\"-\") {\n             &lib[1..]\n         } else {\n-            continue\n+            continue;\n         };\n \n         // Don't need or want this library, but LLVM's CMake build system\n@@ -140,10 +147,14 @@ fn main() {\n         // library and it otherwise may just pull in extra dependencies on\n         // libedit which we don't want\n         if name == \"LLVMLineEditor\" {\n-            continue\n+            continue;\n         }\n \n-        let kind = if name.starts_with(\"LLVM\") {\"static\"} else {\"dylib\"};\n+        let kind = if name.starts_with(\"LLVM\") {\n+            \"static\"\n+        } else {\n+            \"dylib\"\n+        };\n         println!(\"cargo:rustc-link-lib={}={}\", kind, name);\n     }\n "}, {"sha": "44e0156146402778af1269c26e9e339a6a7b792e", "filename": "src/librustc_llvm/diagnostic.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustc_llvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustc_llvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fdiagnostic.rs?ref=f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "patch": "@@ -16,7 +16,7 @@ pub use self::Diagnostic::*;\n use libc::{c_char, c_uint};\n use std::ptr;\n \n-use {ValueRef, TwineRef, DebugLocRef, DiagnosticInfoRef};\n+use {DebugLocRef, DiagnosticInfoRef, TwineRef, ValueRef};\n \n #[derive(Copy, Clone)]\n pub enum OptimizationDiagnosticKind {\n@@ -46,8 +46,9 @@ pub struct OptimizationDiagnostic {\n }\n \n impl OptimizationDiagnostic {\n-    unsafe fn unpack(kind: OptimizationDiagnosticKind, di: DiagnosticInfoRef)\n-            -> OptimizationDiagnostic {\n+    unsafe fn unpack(kind: OptimizationDiagnosticKind,\n+                     di: DiagnosticInfoRef)\n+                     -> OptimizationDiagnostic {\n \n         let mut opt = OptimizationDiagnostic {\n             kind: kind,\n@@ -58,10 +59,10 @@ impl OptimizationDiagnostic {\n         };\n \n         super::LLVMUnpackOptimizationDiagnostic(di,\n-            &mut opt.pass_name,\n-            &mut opt.function,\n-            &mut opt.debug_loc,\n-            &mut opt.message);\n+                                                &mut opt.pass_name,\n+                                                &mut opt.function,\n+                                                &mut opt.debug_loc,\n+                                                &mut opt.message);\n \n         opt\n     }\n@@ -75,8 +76,7 @@ pub struct InlineAsmDiagnostic {\n }\n \n impl InlineAsmDiagnostic {\n-    unsafe fn unpack(di: DiagnosticInfoRef)\n-            -> InlineAsmDiagnostic {\n+    unsafe fn unpack(di: DiagnosticInfoRef) -> InlineAsmDiagnostic {\n \n         let mut opt = InlineAsmDiagnostic {\n             cookie: 0,\n@@ -85,9 +85,9 @@ impl InlineAsmDiagnostic {\n         };\n \n         super::LLVMUnpackInlineAsmDiagnostic(di,\n-            &mut opt.cookie,\n-            &mut opt.message,\n-            &mut opt.instruction);\n+                                             &mut opt.cookie,\n+                                             &mut opt.message,\n+                                             &mut opt.instruction);\n \n         opt\n     }\n@@ -106,22 +106,25 @@ impl Diagnostic {\n         let kind = super::LLVMGetDiagInfoKind(di);\n \n         match kind {\n-            super::DK_InlineAsm\n-                => InlineAsm(InlineAsmDiagnostic::unpack(di)),\n+            super::DK_InlineAsm => InlineAsm(InlineAsmDiagnostic::unpack(di)),\n \n-            super::DK_OptimizationRemark\n-                => Optimization(OptimizationDiagnostic::unpack(OptimizationRemark, di)),\n+            super::DK_OptimizationRemark => {\n+                Optimization(OptimizationDiagnostic::unpack(OptimizationRemark, di))\n+            }\n \n-            super::DK_OptimizationRemarkMissed\n-                => Optimization(OptimizationDiagnostic::unpack(OptimizationMissed, di)),\n+            super::DK_OptimizationRemarkMissed => {\n+                Optimization(OptimizationDiagnostic::unpack(OptimizationMissed, di))\n+            }\n \n-            super::DK_OptimizationRemarkAnalysis\n-                => Optimization(OptimizationDiagnostic::unpack(OptimizationAnalysis, di)),\n+            super::DK_OptimizationRemarkAnalysis => {\n+                Optimization(OptimizationDiagnostic::unpack(OptimizationAnalysis, di))\n+            }\n \n-            super::DK_OptimizationFailure\n-                => Optimization(OptimizationDiagnostic::unpack(OptimizationFailure, di)),\n+            super::DK_OptimizationFailure => {\n+                Optimization(OptimizationDiagnostic::unpack(OptimizationFailure, di))\n+            }\n \n-            _ => UnknownDiagnostic(di)\n+            _ => UnknownDiagnostic(di),\n         }\n     }\n }"}, {"sha": "92401a5c55ffd058c06c963648d2d9d1589b9f7d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "patch": "@@ -111,27 +111,27 @@ impl fmt::Display for clean::Generics {\n \n         for (i, life) in self.lifetimes.iter().enumerate() {\n             if i > 0 {\n-                f.write_str(\", \")?;\n+                f.write_str(\",&nbsp;\")?;\n             }\n             write!(f, \"{}\", *life)?;\n         }\n \n         if !self.type_params.is_empty() {\n             if !self.lifetimes.is_empty() {\n-                f.write_str(\", \")?;\n+                f.write_str(\",&nbsp;\")?;\n             }\n             for (i, tp) in self.type_params.iter().enumerate() {\n                 if i > 0 {\n-                    f.write_str(\", \")?\n+                    f.write_str(\",&nbsp;\")?\n                 }\n                 f.write_str(&tp.name)?;\n \n                 if !tp.bounds.is_empty() {\n-                    write!(f, \": {}\", TyParamBounds(&tp.bounds))?;\n+                    write!(f, \":&nbsp;{}\", TyParamBounds(&tp.bounds))?;\n                 }\n \n                 match tp.default {\n-                    Some(ref ty) => { write!(f, \" = {}\", ty)?; },\n+                    Some(ref ty) => { write!(f, \"&nbsp;=&nbsp;{}\", ty)?; },\n                     None => {}\n                 };\n             }\n@@ -229,21 +229,21 @@ impl fmt::Display for clean::PathParameters {\n                     let mut comma = false;\n                     for lifetime in lifetimes {\n                         if comma {\n-                            f.write_str(\", \")?;\n+                            f.write_str(\",&nbsp;\")?;\n                         }\n                         comma = true;\n                         write!(f, \"{}\", *lifetime)?;\n                     }\n                     for ty in types {\n                         if comma {\n-                            f.write_str(\", \")?;\n+                            f.write_str(\",&nbsp;\")?;\n                         }\n                         comma = true;\n                         write!(f, \"{}\", *ty)?;\n                     }\n                     for binding in bindings {\n                         if comma {\n-                            f.write_str(\", \")?;\n+                            f.write_str(\",&nbsp;\")?;\n                         }\n                         comma = true;\n                         write!(f, \"{}\", *binding)?;"}, {"sha": "396f71173f83451a24d43b3c071f06299dafe30f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "patch": "@@ -2243,26 +2243,24 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     write!(w, \"</pre>\")?;\n \n     document(w, cx, it)?;\n-    let mut fields = s.fields.iter().filter(|f| {\n+    let mut fields = s.fields.iter().filter_map(|f| {\n         match f.inner {\n-            clean::StructFieldItem(..) => true,\n-            _ => false,\n+            clean::StructFieldItem(ref ty) => Some((f, ty)),\n+            _ => None,\n         }\n     }).peekable();\n     if let doctree::Plain = s.struct_type {\n         if fields.peek().is_some() {\n-            write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\")?;\n-            for field in fields {\n-                write!(w, \"<tr class='stab {stab}'>\n-                             <td id='{shortty}.{name}'>\\\n-                               <code>{name}</code></td><td>\",\n+            write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n+            for (field, ty) in fields {\n+                write!(w, \"<span id='{shortty}.{name}'><code>{name}: {ty}</code></span>\n+                           <span class='stab {stab}'></span>\",\n                        shortty = ItemType::StructField,\n                        stab = field.stability_class(),\n-                       name = field.name.as_ref().unwrap())?;\n+                       name = field.name.as_ref().unwrap(),\n+                       ty = ty)?;\n                 document(w, cx, field)?;\n-                write!(w, \"</td></tr>\")?;\n             }\n-            write!(w, \"</table>\")?;\n         }\n     }\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n@@ -2292,7 +2290,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                             write!(w, \"{}(\", name)?;\n                             for (i, ty) in tys.iter().enumerate() {\n                                 if i > 0 {\n-                                    write!(w, \", \")?\n+                                    write!(w, \",&nbsp;\")?\n                                 }\n                                 write!(w, \"{}\", *ty)?;\n                             }\n@@ -2324,40 +2322,47 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n     document(w, cx, it)?;\n     if !e.variants.is_empty() {\n-        write!(w, \"<h2 class='variants'>Variants</h2>\\n<table class='variants_table'>\")?;\n+        write!(w, \"<h2 class='variants'>Variants</h2>\\n\")?;\n         for variant in &e.variants {\n-            write!(w, \"<tr><td id='{shortty}.{name}'><code>{name}</code></td><td>\",\n+            write!(w, \"<span id='{shortty}.{name}' class='variant'><code>{name}\",\n                    shortty = ItemType::Variant,\n                    name = variant.name.as_ref().unwrap())?;\n+            if let clean::VariantItem(ref var) = variant.inner {\n+                if let clean::TupleVariant(ref tys) = var.kind {\n+                    write!(w, \"(\")?;\n+                    for (i, ty) in tys.iter().enumerate() {\n+                        if i > 0 {\n+                            write!(w, \",&nbsp;\")?;\n+                        }\n+                        write!(w, \"{}\", *ty)?;\n+                    }\n+                    write!(w, \")\")?;\n+                }\n+            }\n+            write!(w, \"</code></span>\")?;\n             document(w, cx, variant)?;\n \n             use clean::{Variant, StructVariant};\n             if let clean::VariantItem( Variant { kind: StructVariant(ref s) } ) = variant.inner {\n-                let fields = s.fields.iter().filter(|f| {\n-                    match f.inner {\n-                        clean::StructFieldItem(..) => true,\n-                        _ => false,\n-                    }\n-                });\n                 write!(w, \"<h3 class='fields'>Fields</h3>\\n\n                            <table>\")?;\n-                for field in fields {\n-                    write!(w, \"<tr><td \\\n-                               id='{shortty}.{v}.field.{f}'>\\\n-                               <code>{f}</code></td><td>\",\n-                           shortty = ItemType::Variant,\n-                           v = variant.name.as_ref().unwrap(),\n-                           f = field.name.as_ref().unwrap())?;\n-                    document(w, cx, field)?;\n-                    write!(w, \"</td></tr>\")?;\n+                for field in &s.fields {\n+                    use clean::StructFieldItem;\n+                    if let StructFieldItem(ref ty) = field.inner {\n+                        write!(w, \"<tr><td \\\n+                                   id='variant.{v}.field.{f}'>\\\n+                                   <code>{f}:&nbsp;{t}</code></td><td>\",\n+                               v = variant.name.as_ref().unwrap(),\n+                               f = field.name.as_ref().unwrap(),\n+                               t = *ty)?;\n+                        document(w, cx, field)?;\n+                        write!(w, \"</td></tr>\")?;\n+                    }\n                 }\n                 write!(w, \"</table>\")?;\n             }\n-            write!(w, \"</td><td>\")?;\n             render_stability_since(w, variant, it)?;\n-            write!(w, \"</td></tr>\")?;\n         }\n-        write!(w, \"</table>\")?;\n     }\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)?;\n     Ok(())"}, {"sha": "bfe3f7b8dd69d9bc55440b8cea402d11a34ce51f", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "patch": "@@ -265,6 +265,10 @@ nav.sub {\n .docblock h2 { font-size: 1.15em; }\n .docblock h3, .docblock h4, .docblock h5 { font-size: 1em; }\n \n+.docblock {\n+    margin-left: 24px;\n+}\n+\n .content .out-of-band {\n     font-size: 23px;\n     margin: 0px;\n@@ -640,6 +644,21 @@ span.since {\n     margin-right: 5px;\n }\n \n+.enum > .toggle-wrapper > .collapse-toggle, .struct > .toggle-wrapper > .collapse-toggle {\n+    left: 0;\n+    margin-top: 5px;\n+}\n+\n+.enum > .toggle-wrapper + .docblock, .struct > .toggle-wrapper + .docblock {\n+    margin-left: 30px;\n+    margin-bottom: 20px;\n+    margin-top: 5px;\n+}\n+\n+.enum > .collapsed, .struct > .collapsed {\n+    margin-bottom: 25px;\n+}\n+\n :target > code {\n    background: #FDFFD3;\n }"}, {"sha": "734f774043d6dd4bdcc194424adb9b42049a1b46", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "patch": "@@ -1338,10 +1338,10 @@ pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n ///\n /// // one possible implementation of walking a directory only visiting files\n /// fn visit_dirs(dir: &Path, cb: &Fn(&DirEntry)) -> io::Result<()> {\n-///     if try!(fs::metadata(dir)).is_dir() {\n+///     if dir.is_dir() {\n ///         for entry in try!(fs::read_dir(dir)) {\n ///             let entry = try!(entry);\n-///             if try!(fs::metadata(entry.path())).is_dir() {\n+///             if try!(entry.file_type()).is_dir() {\n ///                 try!(visit_dirs(&entry.path(), cb));\n ///             } else {\n ///                 cb(&entry);"}, {"sha": "d6adec84e8440787716ffbc04e1f14923b3a1847", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "patch": "@@ -201,7 +201,7 @@ use syntax::codemap::{self, respan, DUMMY_SP};\n use syntax::codemap::Span;\n use syntax::errors::Handler;\n use syntax::util::move_map::MoveMap;\n-use syntax::parse::token::{intern, keywords, InternedString};\n+use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n \n use self::ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};\n@@ -1420,31 +1420,13 @@ impl<'a> MethodDef<'a> {\n \n // general helper methods.\n impl<'a> TraitDef<'a> {\n-    fn set_expn_info(&self,\n-                     cx: &mut ExtCtxt,\n-                     mut to_set: Span) -> Span {\n-        let trait_name = match self.path.path.last() {\n-            None => cx.span_bug(self.span, \"trait with empty path in generic `derive`\"),\n-            Some(name) => *name\n-        };\n-        to_set.expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n-            call_site: to_set,\n-            callee: codemap::NameAndSpan {\n-                format: codemap::MacroAttribute(intern(&format!(\"derive({})\", trait_name))),\n-                span: Some(self.span),\n-                allow_internal_unstable: false,\n-            }\n-        });\n-        to_set\n-    }\n-\n     fn summarise_struct(&self,\n                         cx: &mut ExtCtxt,\n                         struct_def: &VariantData) -> StaticFields {\n         let mut named_idents = Vec::new();\n         let mut just_spans = Vec::new();\n         for field in struct_def.fields(){\n-            let sp = self.set_expn_info(cx, field.span);\n+            let sp = Span { expn_id: self.span.expn_id, ..field.span };\n             match field.ident {\n                 Some(ident) => named_idents.push((ident, sp)),\n                 _ => just_spans.push(sp),\n@@ -1486,7 +1468,7 @@ impl<'a> TraitDef<'a> {\n         let mut paths = Vec::new();\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n-            let sp = self.set_expn_info(cx, struct_field.span);\n+            let sp = Span { expn_id: self.span.expn_id, ..struct_field.span };\n             let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n             paths.push(codemap::Spanned{span: sp, node: ident});\n             let val = cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp,ident)));"}, {"sha": "6fb6dee94ed35af77cc9adba72888b10f2084ff6", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 21, "deletions": 39, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "patch": "@@ -16,7 +16,7 @@ use syntax::ext::base::{ExtCtxt, SyntaxEnv, Annotatable};\n use syntax::ext::base::{MultiDecorator, MultiItemDecorator, MultiModifier};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n-use syntax::codemap::Span;\n+use syntax::codemap::{self, Span};\n use syntax::parse::token::{intern, intern_and_get_ident};\n use syntax::ptr::P;\n \n@@ -94,37 +94,7 @@ fn expand_derive(cx: &mut ExtCtxt,\n             }\n \n             let mut found_partial_eq = false;\n-            let mut found_eq = false;\n-\n-            // This span is **very** sensitive and crucial to\n-            // getting the stability behavior we want. What we are\n-            // doing is marking the generated `#[derive_*]` with the\n-            // span of the `#[deriving(...)]` attribute (the\n-            // entire attribute, not just the `PartialEq` or `Eq`\n-            // part), but with the current backtrace. The current\n-            // backtrace will contain a topmost entry that IS this\n-            // `#[deriving(...)]` attribute and with the\n-            // \"allow-unstable\" flag set to true.\n-            //\n-            // Note that we do NOT use the span of the `Eq`\n-            // text itself. You might think this is\n-            // equivalent, because the `Eq` appears within the\n-            // `#[deriving(Eq)]` attribute, and hence we would\n-            // inherit the \"allows unstable\" from the\n-            // backtrace.  But in fact this is not always the\n-            // case. The actual source text that led to\n-            // deriving can be `#[$attr]`, for example, where\n-            // `$attr == deriving(Eq)`. In that case, the\n-            // \"#[derive_*]\" would be considered to\n-            // originate not from the deriving call but from\n-            // text outside the deriving call, and hence would\n-            // be forbidden from using unstable\n-            // content.\n-            //\n-            // See tests src/run-pass/rfc1445 for\n-            // examples. --nmatsakis\n-            let span = Span { expn_id: cx.backtrace(), .. span };\n-            assert!(cx.parse_sess.codemap().span_allows_unstable(span));\n+            let mut eq_span = None;\n \n             for titem in traits.iter().rev() {\n                 let tname = match titem.node {\n@@ -144,8 +114,19 @@ fn expand_derive(cx: &mut ExtCtxt,\n                     continue;\n                 }\n \n+                let span = Span {\n+                    expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n+                        call_site: titem.span,\n+                        callee: codemap::NameAndSpan {\n+                            format: codemap::MacroAttribute(intern(&format!(\"derive({})\", tname))),\n+                            span: Some(titem.span),\n+                            allow_internal_unstable: true,\n+                        },\n+                    }), ..titem.span\n+                };\n+\n                 if &tname[..] == \"Eq\" {\n-                    found_eq = true;\n+                    eq_span = Some(span);\n                 } else if &tname[..] == \"PartialEq\" {\n                     found_partial_eq = true;\n                 }\n@@ -157,12 +138,13 @@ fn expand_derive(cx: &mut ExtCtxt,\n \n             // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n             // `#[structural_match]` attribute.\n-            if found_partial_eq && found_eq {\n-                debug!(\"inserting structural_match with span {:?}\", span);\n-                let structural_match = intern_and_get_ident(\"structural_match\");\n-                item.attrs.push(cx.attribute(span,\n-                                             cx.meta_word(span,\n-                                                          structural_match)));\n+            if let Some(eq_span) = eq_span {\n+                if found_partial_eq {\n+                    let structural_match = intern_and_get_ident(\"structural_match\");\n+                    item.attrs.push(cx.attribute(eq_span,\n+                                                 cx.meta_word(eq_span,\n+                                                              structural_match)));\n+                }\n             }\n \n             item"}, {"sha": "5dfc41c8f4a48f8c4b405be460edbf76a342136a", "filename": "src/test/compile-fail/issue-33571.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Ftest%2Fcompile-fail%2Fissue-33571.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3bfa313ecf557b9684568f6a2acd42cd67cc1bc/src%2Ftest%2Fcompile-fail%2Fissue-33571.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-33571.rs?ref=f3bfa313ecf557b9684568f6a2acd42cd67cc1bc", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[derive(Clone,\n+         Sync, //~ ERROR this unsafe trait should be implemented explicitly\n+         Copy)]\n+enum Foo {}"}]}