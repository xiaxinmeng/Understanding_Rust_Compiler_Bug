{"sha": "abe1cc79d42f08ce935e2470e6b7b4c97923136b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZTFjYzc5ZDQyZjA4Y2U5MzVlMjQ3MGU2YjdiNGM5NzkyMzEzNmI=", "commit": {"author": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-06-11T13:39:20Z"}, "committer": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-08-07T04:51:17Z"}, "message": "run rustfmt on compiletest folder in src/tools/ folder", "tree": {"sha": "be8984051ad8170f13a7c9b5020054216d7a861e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be8984051ad8170f13a7c9b5020054216d7a861e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abe1cc79d42f08ce935e2470e6b7b4c97923136b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXpr5LAAoJEAkcWPS/w2VxtpMP/3dC4IhIyIHtoQv7lVq/+Rt8\nP4u0UHMRlz8wyAb8HD5YIe74BoXw/+g7QFFnp6wurt0UtOjRp59h/7k6lcf9e0df\nCSZyNZJxraRUcsmGbAhj/vD+WivVm7iyZVsZAa2BNrXuZK7oaDK079o2fkC910lU\n0kbCNZW5OKlWrxUhK91zyVNeIpARD7WfuTbW5S53cYqbPmgS3tThyrvDIMPDOG92\nQQl1PqGefmih08aS1fIOHMVm8ngAl7w3V/EjZAOobqq0AZuDNMmhnSo0VDbdyLsk\nuUHcB6Oa/Q00EinT8QWMSvdIyyQ2D0Kuxk5MZfWhfdNH8Xg230pwmbOKol72ncBs\naKgyu6p4nDkud/68+IJHcxFc5jp6k17IH/7kS4OCUEbeeAYZCm86pgXsg5gmqYOI\nSzLfmgP6JVZZrurcPTMU7ubHe/fjkHztoFoJO6/XK8zZC/ZN+0Zy9UfTCDPpw0gY\nKt1Lgc5UzE2gMyAhjBHvUzNGLzq3hb/JjLFHOefHphyyeAhUfDUPpMij2435JC9s\nOxQNR5bN5JEgrHmwrHB2CaF0EqpvgZV3lnc9MiFMPmge015NqTQiz2+7VxjDj99b\n8JCO7134tW4UYSbl5Du9PhOw+6qQhj4HVNcKViTmVAWIXuPnQhpIKUyt45xUUj2j\nGNQuueV5GV7Fk33N4DDZ\n=ymPh\n-----END PGP SIGNATURE-----", "payload": "tree be8984051ad8170f13a7c9b5020054216d7a861e\nparent ddf92ffae4b8fc74474241f064f41f09db585ed8\nauthor Srinivas Reddy Thatiparthy <thatiparthysreenivas@gmail.com> 1465652360 +0530\ncommitter Srinivas Reddy Thatiparthy <thatiparthysreenivas@gmail.com> 1470545477 +0530\n\nrun rustfmt on compiletest folder in src/tools/ folder\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abe1cc79d42f08ce935e2470e6b7b4c97923136b", "html_url": "https://github.com/rust-lang/rust/commit/abe1cc79d42f08ce935e2470e6b7b4c97923136b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abe1cc79d42f08ce935e2470e6b7b4c97923136b/comments", "author": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddf92ffae4b8fc74474241f064f41f09db585ed8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddf92ffae4b8fc74474241f064f41f09db585ed8", "html_url": "https://github.com/rust-lang/rust/commit/ddf92ffae4b8fc74474241f064f41f09db585ed8"}], "stats": {"total": 543, "additions": 273, "deletions": 270}, "files": [{"sha": "6090cb4f52725784789fb5904c7ffc850e334ef1", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=abe1cc79d42f08ce935e2470e6b7b4c97923136b", "patch": "@@ -36,45 +36,46 @@ impl FromStr for Mode {\n     type Err = ();\n     fn from_str(s: &str) -> Result<Mode, ()> {\n         match s {\n-          \"compile-fail\" => Ok(CompileFail),\n-          \"parse-fail\" => Ok(ParseFail),\n-          \"run-fail\" => Ok(RunFail),\n-          \"run-pass\" => Ok(RunPass),\n-          \"run-pass-valgrind\" => Ok(RunPassValgrind),\n-          \"pretty\" => Ok(Pretty),\n-          \"debuginfo-lldb\" => Ok(DebugInfoLldb),\n-          \"debuginfo-gdb\" => Ok(DebugInfoGdb),\n-          \"codegen\" => Ok(Codegen),\n-          \"rustdoc\" => Ok(Rustdoc),\n-          \"codegen-units\" => Ok(CodegenUnits),\n-          \"incremental\" => Ok(Incremental),\n-          \"run-make\" => Ok(RunMake),\n-          \"ui\" => Ok(Ui),\n-          \"mir-opt\" => Ok(MirOpt),\n-          _ => Err(()),\n+            \"compile-fail\" => Ok(CompileFail),\n+            \"parse-fail\" => Ok(ParseFail),\n+            \"run-fail\" => Ok(RunFail),\n+            \"run-pass\" => Ok(RunPass),\n+            \"run-pass-valgrind\" => Ok(RunPassValgrind),\n+            \"pretty\" => Ok(Pretty),\n+            \"debuginfo-lldb\" => Ok(DebugInfoLldb),\n+            \"debuginfo-gdb\" => Ok(DebugInfoGdb),\n+            \"codegen\" => Ok(Codegen),\n+            \"rustdoc\" => Ok(Rustdoc),\n+            \"codegen-units\" => Ok(CodegenUnits),\n+            \"incremental\" => Ok(Incremental),\n+            \"run-make\" => Ok(RunMake),\n+            \"ui\" => Ok(Ui),\n+            \"mir-opt\" => Ok(MirOpt),\n+            _ => Err(()),\n         }\n     }\n }\n \n impl fmt::Display for Mode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(match *self {\n-            CompileFail => \"compile-fail\",\n-            ParseFail => \"parse-fail\",\n-            RunFail => \"run-fail\",\n-            RunPass => \"run-pass\",\n-            RunPassValgrind => \"run-pass-valgrind\",\n-            Pretty => \"pretty\",\n-            DebugInfoGdb => \"debuginfo-gdb\",\n-            DebugInfoLldb => \"debuginfo-lldb\",\n-            Codegen => \"codegen\",\n-            Rustdoc => \"rustdoc\",\n-            CodegenUnits => \"codegen-units\",\n-            Incremental => \"incremental\",\n-            RunMake => \"run-make\",\n-            Ui => \"ui\",\n-            MirOpt => \"mir-opt\",\n-        }, f)\n+                              CompileFail => \"compile-fail\",\n+                              ParseFail => \"parse-fail\",\n+                              RunFail => \"run-fail\",\n+                              RunPass => \"run-pass\",\n+                              RunPassValgrind => \"run-pass-valgrind\",\n+                              Pretty => \"pretty\",\n+                              DebugInfoGdb => \"debuginfo-gdb\",\n+                              DebugInfoLldb => \"debuginfo-lldb\",\n+                              Codegen => \"codegen\",\n+                              Rustdoc => \"rustdoc\",\n+                              CodegenUnits => \"codegen-units\",\n+                              Incremental => \"incremental\",\n+                              RunMake => \"run-make\",\n+                              Ui => \"ui\",\n+                              MirOpt => \"mir-opt\",\n+                          },\n+                          f)\n     }\n }\n "}, {"sha": "29ca54fda8db9521eeb68b74686094bf84770a1b", "filename": "src/tools/compiletest/src/errors.rs", "status": "modified", "additions": 46, "deletions": 33, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs?ref=abe1cc79d42f08ce935e2470e6b7b4c97923136b", "patch": "@@ -64,7 +64,11 @@ pub struct Error {\n }\n \n #[derive(PartialEq, Debug)]\n-enum WhichLine { ThisLine, FollowPrevious(usize), AdjustBackward(usize) }\n+enum WhichLine {\n+    ThisLine,\n+    FollowPrevious(usize),\n+    AdjustBackward(usize),\n+}\n \n /// Looks for either \"//~| KIND MESSAGE\" or \"//~^^... KIND MESSAGE\"\n /// The former is a \"follow\" that inherits its target from the preceding line;\n@@ -91,60 +95,59 @@ pub fn load_errors(testfile: &Path, cfg: Option<&str>) -> Vec<Error> {\n \n     let tag = match cfg {\n         Some(rev) => format!(\"//[{}]~\", rev),\n-        None => format!(\"//~\")\n+        None => format!(\"//~\"),\n     };\n \n     rdr.lines()\n-       .enumerate()\n-       .filter_map(|(line_num, line)| {\n-           parse_expected(last_nonfollow_error,\n-                          line_num + 1,\n-                          &line.unwrap(),\n-                          &tag)\n-               .map(|(which, error)| {\n-                   match which {\n-                       FollowPrevious(_) => {}\n-                       _ => last_nonfollow_error = Some(error.line_num),\n-                   }\n-                   error\n-               })\n-       })\n-       .collect()\n+        .enumerate()\n+        .filter_map(|(line_num, line)| {\n+            parse_expected(last_nonfollow_error, line_num + 1, &line.unwrap(), &tag)\n+                .map(|(which, error)| {\n+                    match which {\n+                        FollowPrevious(_) => {}\n+                        _ => last_nonfollow_error = Some(error.line_num),\n+                    }\n+                    error\n+                })\n+        })\n+        .collect()\n }\n \n fn parse_expected(last_nonfollow_error: Option<usize>,\n                   line_num: usize,\n                   line: &str,\n                   tag: &str)\n                   -> Option<(WhichLine, Error)> {\n-    let start = match line.find(tag) { Some(i) => i, None => return None };\n+    let start = match line.find(tag) {\n+        Some(i) => i,\n+        None => return None,\n+    };\n     let (follow, adjusts) = if line[start + tag.len()..].chars().next().unwrap() == '|' {\n         (true, 0)\n     } else {\n         (false, line[start + tag.len()..].chars().take_while(|c| *c == '^').count())\n     };\n     let kind_start = start + tag.len() + adjusts + (follow as usize);\n     let (kind, msg);\n-    match\n-        line[kind_start..].split_whitespace()\n-                          .next()\n-                          .expect(\"Encountered unexpected empty comment\")\n-                          .parse::<ErrorKind>()\n-    {\n+    match line[kind_start..]\n+        .split_whitespace()\n+        .next()\n+        .expect(\"Encountered unexpected empty comment\")\n+        .parse::<ErrorKind>() {\n         Ok(k) => {\n             // If we find `//~ ERROR foo` or something like that:\n             kind = Some(k);\n             let letters = line[kind_start..].chars();\n             msg = letters.skip_while(|c| c.is_whitespace())\n-                         .skip_while(|c| !c.is_whitespace())\n-                         .collect::<String>();\n+                .skip_while(|c| !c.is_whitespace())\n+                .collect::<String>();\n         }\n         Err(_) => {\n             // Otherwise we found `//~ foo`:\n             kind = None;\n             let letters = line[kind_start..].chars();\n             msg = letters.skip_while(|c| c.is_whitespace())\n-                         .collect::<String>();\n+                .collect::<String>();\n         }\n     }\n     let msg = msg.trim().to_owned();\n@@ -155,15 +158,25 @@ fn parse_expected(last_nonfollow_error: Option<usize>,\n                                                     preceding //~^ line.\");\n         (FollowPrevious(line_num), line_num)\n     } else {\n-        let which =\n-            if adjusts > 0 { AdjustBackward(adjusts) } else { ThisLine };\n+        let which = if adjusts > 0 {\n+            AdjustBackward(adjusts)\n+        } else {\n+            ThisLine\n+        };\n         let line_num = line_num - adjusts;\n         (which, line_num)\n     };\n \n     debug!(\"line={} tag={:?} which={:?} kind={:?} msg={:?}\",\n-           line_num, tag, which, kind, msg);\n-    Some((which, Error { line_num: line_num,\n-                         kind: kind,\n-                         msg: msg, }))\n+           line_num,\n+           tag,\n+           which,\n+           kind,\n+           msg);\n+    Some((which,\n+          Error {\n+        line_num: line_num,\n+        kind: kind,\n+        msg: msg,\n+    }))\n }"}, {"sha": "af33d76be1b0db0f430b4dcc5a4ee774a2c0d08d", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 52, "deletions": 62, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=abe1cc79d42f08ce935e2470e6b7b4c97923136b", "patch": "@@ -32,24 +32,21 @@ impl EarlyProps {\n             should_fail: false,\n         };\n \n-        iter_header(testfile, None, &mut |ln| {\n+        iter_header(testfile,\n+                    None,\n+                    &mut |ln| {\n             props.ignore =\n-                props.ignore ||\n-                parse_name_directive(ln, \"ignore-test\") ||\n+                props.ignore || parse_name_directive(ln, \"ignore-test\") ||\n                 parse_name_directive(ln, &ignore_target(config)) ||\n                 parse_name_directive(ln, &ignore_architecture(config)) ||\n                 parse_name_directive(ln, &ignore_stage(config)) ||\n                 parse_name_directive(ln, &ignore_env(config)) ||\n-                (config.mode == common::Pretty &&\n-                 parse_name_directive(ln, \"ignore-pretty\")) ||\n+                (config.mode == common::Pretty && parse_name_directive(ln, \"ignore-pretty\")) ||\n                 (config.target != config.host &&\n                  parse_name_directive(ln, \"ignore-cross-compile\")) ||\n-                ignore_gdb(config, ln) ||\n-                ignore_lldb(config, ln);\n+                ignore_gdb(config, ln) || ignore_lldb(config, ln);\n \n-            props.should_fail =\n-                props.should_fail ||\n-                parse_name_directive(ln, \"should-fail\");\n+            props.should_fail = props.should_fail || parse_name_directive(ln, \"should-fail\");\n         });\n \n         return props;\n@@ -61,11 +58,11 @@ impl EarlyProps {\n             format!(\"ignore-{}\", util::get_arch(&config.target))\n         }\n         fn ignore_stage(config: &Config) -> String {\n-            format!(\"ignore-{}\",\n-                    config.stage_id.split('-').next().unwrap())\n+            format!(\"ignore-{}\", config.stage_id.split('-').next().unwrap())\n         }\n         fn ignore_env(config: &Config) -> String {\n-            format!(\"ignore-{}\", util::get_env(&config.target).unwrap_or(\"<unknown>\"))\n+            format!(\"ignore-{}\",\n+                    util::get_env(&config.target).unwrap_or(\"<unknown>\"))\n         }\n         fn ignore_gdb(config: &Config, line: &str) -> bool {\n             if config.mode != common::DebugInfoGdb {\n@@ -79,13 +76,12 @@ impl EarlyProps {\n             if let Some(ref actual_version) = config.gdb_version {\n                 if line.contains(\"min-gdb-version\") {\n                     let min_version = line.trim()\n-                                          .split(' ')\n-                                          .last()\n-                                          .expect(\"Malformed GDB version directive\");\n+                        .split(' ')\n+                        .last()\n+                        .expect(\"Malformed GDB version directive\");\n                     // Ignore if actual version is smaller the minimum required\n                     // version\n-                    gdb_version_to_int(actual_version) <\n-                        gdb_version_to_int(min_version)\n+                    gdb_version_to_int(actual_version) < gdb_version_to_int(min_version)\n                 } else {\n                     false\n                 }\n@@ -106,13 +102,12 @@ impl EarlyProps {\n             if let Some(ref actual_version) = config.lldb_version {\n                 if line.contains(\"min-lldb-version\") {\n                     let min_version = line.trim()\n-                                          .split(' ')\n-                                          .last()\n-                                          .expect(\"Malformed lldb version directive\");\n+                        .split(' ')\n+                        .last()\n+                        .expect(\"Malformed lldb version directive\");\n                     // Ignore if actual version is smaller the minimum required\n                     // version\n-                    lldb_version_to_int(actual_version) <\n-                        lldb_version_to_int(min_version)\n+                    lldb_version_to_int(actual_version) < lldb_version_to_int(min_version)\n                 } else {\n                     false\n                 }\n@@ -126,7 +121,7 @@ impl EarlyProps {\n #[derive(Clone, Debug)]\n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n-    pub error_patterns: Vec<String> ,\n+    pub error_patterns: Vec<String>,\n     // Extra flags to pass to the compiler\n     pub compile_flags: Vec<String>,\n     // Extra flags to pass when the compiled code is run (such as --bench)\n@@ -137,13 +132,13 @@ pub struct TestProps {\n     // Other crates that should be compiled (typically from the same\n     // directory as the test, but for backwards compatibility reasons\n     // we also check the auxiliary directory)\n-    pub aux_builds: Vec<String> ,\n+    pub aux_builds: Vec<String>,\n     // Environment settings to use for compiling\n-    pub rustc_env: Vec<(String,String)> ,\n+    pub rustc_env: Vec<(String, String)>,\n     // Environment settings to use during execution\n-    pub exec_env: Vec<(String,String)> ,\n+    pub exec_env: Vec<(String, String)>,\n     // Lines to check if they appear in the expected debugger output\n-    pub check_lines: Vec<String> ,\n+    pub check_lines: Vec<String>,\n     // Build documentation for all specified aux-builds as well\n     pub build_aux_docs: bool,\n     // Flag to force a crate to be built with the host architecture\n@@ -226,17 +221,17 @@ impl TestProps {\n     /// tied to a particular revision `foo` (indicated by writing\n     /// `//[foo]`), then the property is ignored unless `cfg` is\n     /// `Some(\"foo\")`.\n-    pub fn load_from(&mut self, testfile: &Path, cfg: Option<&str>)  {\n-        iter_header(testfile, cfg, &mut |ln| {\n+    pub fn load_from(&mut self, testfile: &Path, cfg: Option<&str>) {\n+        iter_header(testfile,\n+                    cfg,\n+                    &mut |ln| {\n             if let Some(ep) = parse_error_pattern(ln) {\n                 self.error_patterns.push(ep);\n             }\n \n             if let Some(flags) = parse_compile_flags(ln) {\n-                self.compile_flags.extend(\n-                    flags\n-                        .split_whitespace()\n-                        .map(|s| s.to_owned()));\n+                self.compile_flags.extend(flags.split_whitespace()\n+                    .map(|s| s.to_owned()));\n             }\n \n             if let Some(r) = parse_revisions(ln) {\n@@ -279,7 +274,7 @@ impl TestProps {\n                 self.pretty_compare_only = parse_pretty_compare_only(ln);\n             }\n \n-            if let  Some(ab) = parse_aux_build(ln) {\n+            if let Some(ab) = parse_aux_build(ln) {\n                 self.aux_builds.push(ab);\n             }\n \n@@ -291,7 +286,7 @@ impl TestProps {\n                 self.rustc_env.push(ee);\n             }\n \n-            if let Some(cl) =  parse_check_line(ln) {\n+            if let Some(cl) = parse_check_line(ln) {\n                 self.check_lines.push(cl);\n             }\n \n@@ -302,21 +297,20 @@ impl TestProps {\n \n         for key in vec![\"RUST_TEST_NOCAPTURE\", \"RUST_TEST_THREADS\"] {\n             match env::var(key) {\n-                Ok(val) =>\n+                Ok(val) => {\n                     if self.exec_env.iter().find(|&&(ref x, _)| *x == key).is_none() {\n                         self.exec_env.push((key.to_owned(), val))\n-                    },\n+                    }\n+                }\n                 Err(..) => {}\n             }\n         }\n     }\n }\n \n-fn iter_header(testfile: &Path,\n-               cfg: Option<&str>,\n-               it: &mut FnMut(&str)) {\n+fn iter_header(testfile: &Path, cfg: Option<&str>, it: &mut FnMut(&str)) {\n     if testfile.is_dir() {\n-        return\n+        return;\n     }\n     let rdr = BufReader::new(File::open(testfile).unwrap());\n     for ln in rdr.lines() {\n@@ -336,7 +330,7 @@ fn iter_header(testfile: &Path,\n                     None => false,\n                 };\n                 if matches {\n-                    it(&ln[close_brace+1..]);\n+                    it(&ln[close_brace + 1..]);\n                 }\n             } else {\n                 panic!(\"malformed condition directive: expected `//[foo]`, found `{}`\",\n@@ -409,18 +403,17 @@ fn parse_pretty_compare_only(line: &str) -> bool {\n fn parse_env(line: &str, name: &str) -> Option<(String, String)> {\n     parse_name_value_directive(line, name).map(|nv| {\n         // nv is either FOO or FOO=BAR\n-        let mut strs: Vec<String> = nv\n-                                      .splitn(2, '=')\n-                                      .map(str::to_owned)\n-                                      .collect();\n+        let mut strs: Vec<String> = nv.splitn(2, '=')\n+            .map(str::to_owned)\n+            .collect();\n \n         match strs.len() {\n-          1 => (strs.pop().unwrap(), \"\".to_owned()),\n-          2 => {\n-              let end = strs.pop().unwrap();\n-              (strs.pop().unwrap(), end)\n-          }\n-          n => panic!(\"Expected 1 or 2 strings, not {}\", n)\n+            1 => (strs.pop().unwrap(), \"\".to_owned()),\n+            2 => {\n+                let end = strs.pop().unwrap();\n+                (strs.pop().unwrap(), end)\n+            }\n+            n => panic!(\"Expected 1 or 2 strings, not {}\", n),\n         }\n     })\n }\n@@ -442,11 +435,10 @@ fn parse_name_directive(line: &str, directive: &str) -> bool {\n     line.contains(directive) && !line.contains(&(\"no-\".to_owned() + directive))\n }\n \n-pub fn parse_name_value_directive(line: &str, directive: &str)\n-                                  -> Option<String> {\n+pub fn parse_name_value_directive(line: &str, directive: &str) -> Option<String> {\n     let keycolon = format!(\"{}:\", directive);\n     if let Some(colon) = line.find(&keycolon) {\n-        let value = line[(colon + keycolon.len()) .. line.len()].to_owned();\n+        let value = line[(colon + keycolon.len())..line.len()].to_owned();\n         debug!(\"{}: {}\", directive, value);\n         Some(value)\n     } else {\n@@ -455,9 +447,8 @@ pub fn parse_name_value_directive(line: &str, directive: &str)\n }\n \n pub fn gdb_version_to_int(version_string: &str) -> isize {\n-    let error_string = format!(\n-        \"Encountered GDB version string with unexpected format: {}\",\n-        version_string);\n+    let error_string = format!(\"Encountered GDB version string with unexpected format: {}\",\n+                               version_string);\n     let error_string = error_string;\n \n     let components: Vec<&str> = version_string.trim().split('.').collect();\n@@ -473,9 +464,8 @@ pub fn gdb_version_to_int(version_string: &str) -> isize {\n }\n \n pub fn lldb_version_to_int(version_string: &str) -> isize {\n-    let error_string = format!(\n-        \"Encountered LLDB version string with unexpected format: {}\",\n-        version_string);\n+    let error_string = format!(\"Encountered LLDB version string with unexpected format: {}\",\n+                               version_string);\n     let error_string = error_string;\n     let major: isize = version_string.parse().ok().expect(&error_string);\n     return major;"}, {"sha": "d9da1bdc3485837d8024036f23ff5be81f5e7c71", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 40, "deletions": 50, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=abe1cc79d42f08ce935e2470e6b7b4c97923136b", "patch": "@@ -12,7 +12,7 @@ use errors::{Error, ErrorKind};\n use rustc_serialize::json;\n use std::str::FromStr;\n use std::path::Path;\n-use runtest::{ProcRes};\n+use runtest::ProcRes;\n \n // These structs are a subset of the ones found in\n // `syntax::json`.\n@@ -58,8 +58,8 @@ struct DiagnosticCode {\n \n pub fn parse_output(file_name: &str, output: &str, proc_res: &ProcRes) -> Vec<Error> {\n     output.lines()\n-          .flat_map(|line| parse_line(file_name, line, output, proc_res))\n-          .collect()\n+        .flat_map(|line| parse_line(file_name, line, output, proc_res))\n+        .collect()\n }\n \n fn parse_line(file_name: &str, line: &str, output: &str, proc_res: &ProcRes) -> Vec<Error> {\n@@ -73,9 +73,11 @@ fn parse_line(file_name: &str, line: &str, output: &str, proc_res: &ProcRes) ->\n                 expected_errors\n             }\n             Err(error) => {\n-                proc_res.fatal(Some(&format!(\n-                    \"failed to decode compiler output as json: `{}`\\noutput: {}\\nline: {}\",\n-                    error, line, output)));\n+                proc_res.fatal(Some(&format!(\"failed to decode compiler output as json: \\\n+                                              `{}`\\noutput: {}\\nline: {}\",\n+                                             error,\n+                                             line,\n+                                             output)));\n             }\n         }\n     } else {\n@@ -87,16 +89,15 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n                         diagnostic: &Diagnostic,\n                         default_spans: &[&DiagnosticSpan],\n                         file_name: &str) {\n-    let spans_in_this_file: Vec<_> =\n-        diagnostic.spans.iter()\n-                        .filter(|span| Path::new(&span.file_name) == Path::new(&file_name))\n-                        .collect();\n-\n-    let primary_spans: Vec<_> =\n-        spans_in_this_file.iter()\n-                          .cloned()\n-                          .filter(|span| span.is_primary)\n-                          .collect();\n+    let spans_in_this_file: Vec<_> = diagnostic.spans\n+        .iter()\n+        .filter(|span| Path::new(&span.file_name) == Path::new(&file_name))\n+        .collect();\n+\n+    let primary_spans: Vec<_> = spans_in_this_file.iter()\n+        .cloned()\n+        .filter(|span| span.is_primary)\n+        .collect();\n     let primary_spans = if primary_spans.is_empty() {\n         // subdiagnostics often don't have a span of their own;\n         // inherit the span from the parent in that case\n@@ -144,24 +145,20 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n         for span in primary_spans {\n             let msg = with_code(span, first_line);\n             let kind = ErrorKind::from_str(&diagnostic.level).ok();\n-            expected_errors.push(\n-                Error {\n-                    line_num: span.line_start,\n-                    kind: kind,\n-                    msg: msg,\n-                }\n-            );\n+            expected_errors.push(Error {\n+                line_num: span.line_start,\n+                kind: kind,\n+                msg: msg,\n+            });\n         }\n     }\n     for next_line in message_lines {\n         for span in primary_spans {\n-            expected_errors.push(\n-                Error {\n-                    line_num: span.line_start,\n-                    kind: None,\n-                    msg: with_code(span, next_line),\n-                }\n-            );\n+            expected_errors.push(Error {\n+                line_num: span.line_start,\n+                kind: None,\n+                msg: with_code(span, next_line),\n+            });\n         }\n     }\n \n@@ -170,33 +167,28 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n         let start_line = primary_spans.iter().map(|s| s.line_start).min().expect(\"\\\n             every suggestion should have at least one span\");\n         for (index, line) in rendered.lines().enumerate() {\n-            expected_errors.push(\n-                Error {\n-                    line_num: start_line + index,\n-                    kind: Some(ErrorKind::Suggestion),\n-                    msg: line.to_string()\n-                }\n-            );\n+            expected_errors.push(Error {\n+                line_num: start_line + index,\n+                kind: Some(ErrorKind::Suggestion),\n+                msg: line.to_string(),\n+            });\n         }\n     }\n \n     // Add notes for the backtrace\n     for span in primary_spans {\n         for frame in &span.expansion {\n-            push_backtrace(expected_errors,\n-                           frame,\n-                           file_name);\n+            push_backtrace(expected_errors, frame, file_name);\n         }\n     }\n \n     // Add notes for any labels that appear in the message.\n     for span in spans_in_this_file.iter()\n-                                  .filter(|span| span.label.is_some())\n-    {\n+        .filter(|span| span.label.is_some()) {\n         expected_errors.push(Error {\n             line_num: span.line_start,\n             kind: Some(ErrorKind::Note),\n-            msg: span.label.clone().unwrap()\n+            msg: span.label.clone().unwrap(),\n         });\n     }\n \n@@ -210,13 +202,11 @@ fn push_backtrace(expected_errors: &mut Vec<Error>,\n                   expansion: &DiagnosticSpanMacroExpansion,\n                   file_name: &str) {\n     if Path::new(&expansion.span.file_name) == Path::new(&file_name) {\n-        expected_errors.push(\n-            Error {\n-                line_num: expansion.span.line_start,\n-                kind: Some(ErrorKind::Note),\n-                msg: format!(\"in this expansion of {}\", expansion.macro_decl_name),\n-            }\n-        );\n+        expected_errors.push(Error {\n+            line_num: expansion.span.line_start,\n+            kind: Some(ErrorKind::Note),\n+            msg: format!(\"in this expansion of {}\", expansion.macro_decl_name),\n+        });\n     }\n \n     for previous_expansion in &expansion.span.expansion {"}, {"sha": "ed690c08a1ed27e08dc0c6e3ae334d933012fe0b", "filename": "src/tools/compiletest/src/procsrv.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs?ref=abe1cc79d42f08ce935e2470e6b7b4c97923136b", "patch": "@@ -12,7 +12,7 @@ use std::env;\n use std::ffi::OsString;\n use std::io::prelude::*;\n use std::path::PathBuf;\n-use std::process::{ExitStatus, Command, Child, Output, Stdio};\n+use std::process::{Child, Command, ExitStatus, Output, Stdio};\n \n pub fn dylib_env_var() -> &'static str {\n     if cfg!(windows) {\n@@ -29,7 +29,7 @@ fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     // search path for the child.\n     let var = dylib_env_var();\n     let mut path = env::split_paths(&env::var_os(var).unwrap_or(OsString::new()))\n-                       .collect::<Vec<_>>();\n+        .collect::<Vec<_>>();\n     if let Some(p) = aux_path {\n         path.insert(0, PathBuf::from(p))\n     }\n@@ -40,20 +40,25 @@ fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     cmd.env(var, newpath);\n }\n \n-pub struct Result {pub status: ExitStatus, pub out: String, pub err: String}\n+pub struct Result {\n+    pub status: ExitStatus,\n+    pub out: String,\n+    pub err: String,\n+}\n \n pub fn run(lib_path: &str,\n            prog: &str,\n            aux_path: Option<&str>,\n            args: &[String],\n-           env: Vec<(String, String)> ,\n-           input: Option<String>) -> Option<Result> {\n+           env: Vec<(String, String)>,\n+           input: Option<String>)\n+           -> Option<Result> {\n \n     let mut cmd = Command::new(prog);\n     cmd.args(args)\n-       .stdin(Stdio::piped())\n-       .stdout(Stdio::piped())\n-       .stderr(Stdio::piped());\n+        .stdin(Stdio::piped())\n+        .stdout(Stdio::piped())\n+        .stderr(Stdio::piped());\n     add_target_env(&mut cmd, lib_path, aux_path);\n     for (key, val) in env {\n         cmd.env(&key, &val);\n@@ -64,31 +69,31 @@ pub fn run(lib_path: &str,\n             if let Some(input) = input {\n                 process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n             }\n-            let Output { status, stdout, stderr } =\n-                process.wait_with_output().unwrap();\n+            let Output { status, stdout, stderr } = process.wait_with_output().unwrap();\n \n             Some(Result {\n                 status: status,\n                 out: String::from_utf8(stdout).unwrap(),\n-                err: String::from_utf8(stderr).unwrap()\n+                err: String::from_utf8(stderr).unwrap(),\n             })\n-        },\n-        Err(..) => None\n+        }\n+        Err(..) => None,\n     }\n }\n \n pub fn run_background(lib_path: &str,\n-           prog: &str,\n-           aux_path: Option<&str>,\n-           args: &[String],\n-           env: Vec<(String, String)> ,\n-           input: Option<String>) -> Option<Child> {\n+                      prog: &str,\n+                      aux_path: Option<&str>,\n+                      args: &[String],\n+                      env: Vec<(String, String)>,\n+                      input: Option<String>)\n+                      -> Option<Child> {\n \n     let mut cmd = Command::new(prog);\n     cmd.args(args)\n-       .stdin(Stdio::piped())\n-       .stdout(Stdio::piped())\n-       .stderr(Stdio::piped());\n+        .stdin(Stdio::piped())\n+        .stdout(Stdio::piped())\n+        .stderr(Stdio::piped());\n     add_target_env(&mut cmd, lib_path, aux_path);\n     for (key, val) in env {\n         cmd.env(&key, &val);\n@@ -101,7 +106,7 @@ pub fn run_background(lib_path: &str,\n             }\n \n             Some(process)\n-        },\n-        Err(..) => None\n+        }\n+        Err(..) => None,\n     }\n }"}, {"sha": "e2629ffd8f54a3e122b373462ed6b711cbb27661", "filename": "src/tools/compiletest/src/raise_fd_limit.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fraise_fd_limit.rs?ref=abe1cc79d42f08ce935e2470e6b7b4c97923136b", "patch": "@@ -34,14 +34,21 @@ pub unsafe fn raise_fd_limit() {\n     let mut mib: [libc::c_int; 2] = [CTL_KERN, KERN_MAXFILESPERPROC];\n     let mut maxfiles: libc::c_int = 0;\n     let mut size: libc::size_t = size_of_val(&maxfiles) as libc::size_t;\n-    if libc::sysctl(&mut mib[0], 2, &mut maxfiles as *mut _ as *mut _, &mut size,\n-              null_mut(), 0) != 0 {\n+    if libc::sysctl(&mut mib[0],\n+                    2,\n+                    &mut maxfiles as *mut _ as *mut _,\n+                    &mut size,\n+                    null_mut(),\n+                    0) != 0 {\n         let err = io::Error::last_os_error();\n         panic!(\"raise_fd_limit: error calling sysctl: {}\", err);\n     }\n \n     // Fetch the current resource limits\n-    let mut rlim = libc::rlimit{rlim_cur: 0, rlim_max: 0};\n+    let mut rlim = libc::rlimit {\n+        rlim_cur: 0,\n+        rlim_max: 0,\n+    };\n     if libc::getrlimit(libc::RLIMIT_NOFILE, &mut rlim) != 0 {\n         let err = io::Error::last_os_error();\n         panic!(\"raise_fd_limit: error calling getrlimit: {}\", err);"}, {"sha": "fca01029c44652ba87d542ed43e478f5a2d6313a", "filename": "src/tools/compiletest/src/uidiff.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Fuidiff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Fuidiff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fuidiff.rs?ref=abe1cc79d42f08ce935e2470e6b7b4c97923136b", "patch": "@@ -13,38 +13,35 @@\n \n pub fn diff_lines(actual: &str, expected: &str) -> Vec<String> {\n     // mega simplistic diff algorithm that just prints the things added/removed\n-    zip_all(actual.lines(), expected.lines()).enumerate().filter_map(|(i, (a,e))| {\n-        match (a, e) {\n-            (Some(a), Some(e)) => {\n-                if lines_match(e, a) {\n-                    None\n-                } else {\n-                    Some(format!(\"{:3} - |{}|\\n    + |{}|\\n\", i, e, a))\n+    zip_all(actual.lines(), expected.lines())\n+        .enumerate()\n+        .filter_map(|(i, (a, e))| {\n+            match (a, e) {\n+                (Some(a), Some(e)) => {\n+                    if lines_match(e, a) {\n+                        None\n+                    } else {\n+                        Some(format!(\"{:3} - |{}|\\n    + |{}|\\n\", i, e, a))\n+                    }\n                 }\n-            },\n-            (Some(a), None) => {\n-                Some(format!(\"{:3} -\\n    + |{}|\\n\", i, a))\n-            },\n-            (None, Some(e)) => {\n-                Some(format!(\"{:3} - |{}|\\n    +\\n\", i, e))\n-            },\n-            (None, None) => panic!(\"Cannot get here\")\n-        }\n-    }).collect()\n+                (Some(a), None) => Some(format!(\"{:3} -\\n    + |{}|\\n\", i, a)),\n+                (None, Some(e)) => Some(format!(\"{:3} - |{}|\\n    +\\n\", i, e)),\n+                (None, None) => panic!(\"Cannot get here\"),\n+            }\n+        })\n+        .collect()\n }\n \n fn lines_match(expected: &str, mut actual: &str) -> bool {\n     for (i, part) in expected.split(\"[..]\").enumerate() {\n         match actual.find(part) {\n             Some(j) => {\n                 if i == 0 && j != 0 {\n-                    return false\n+                    return false;\n                 }\n                 actual = &actual[j + part.len()..];\n             }\n-            None => {\n-                return false\n-            }\n+            None => return false,\n         }\n     }\n     actual.is_empty() || expected.ends_with(\"[..]\")\n@@ -55,20 +52,20 @@ struct ZipAll<I1: Iterator, I2: Iterator> {\n     second: I2,\n }\n \n-impl<T, I1: Iterator<Item=T>, I2: Iterator<Item=T>> Iterator for ZipAll<I1, I2> {\n+impl<T, I1: Iterator<Item = T>, I2: Iterator<Item = T>> Iterator for ZipAll<I1, I2> {\n     type Item = (Option<T>, Option<T>);\n     fn next(&mut self) -> Option<(Option<T>, Option<T>)> {\n         let first = self.first.next();\n         let second = self.second.next();\n \n         match (first, second) {\n             (None, None) => None,\n-            (a, b) => Some((a, b))\n+            (a, b) => Some((a, b)),\n         }\n     }\n }\n \n-fn zip_all<T, I1: Iterator<Item=T>, I2: Iterator<Item=T>>(a: I1, b: I2) -> ZipAll<I1, I2> {\n+fn zip_all<T, I1: Iterator<Item = T>, I2: Iterator<Item = T>>(a: I1, b: I2) -> ZipAll<I1, I2> {\n     ZipAll {\n         first: a,\n         second: b,"}, {"sha": "d2872a0a2b7caa18ef6d42a7c879a4297fde8018", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abe1cc79d42f08ce935e2470e6b7b4c97923136b/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=abe1cc79d42f08ce935e2470e6b7b4c97923136b", "patch": "@@ -12,54 +12,50 @@ use std::env;\n use common::Config;\n \n /// Conversion table from triple OS name to Rust SYSNAME\n-const OS_TABLE: &'static [(&'static str, &'static str)] = &[\n-    (\"android\", \"android\"),\n-    (\"bitrig\", \"bitrig\"),\n-    (\"darwin\", \"macos\"),\n-    (\"dragonfly\", \"dragonfly\"),\n-    (\"freebsd\", \"freebsd\"),\n-    (\"ios\", \"ios\"),\n-    (\"linux\", \"linux\"),\n-    (\"mingw32\", \"windows\"),\n-    (\"netbsd\", \"netbsd\"),\n-    (\"openbsd\", \"openbsd\"),\n-    (\"win32\", \"windows\"),\n-    (\"windows\", \"windows\"),\n-    (\"solaris\", \"solaris\"),\n-    (\"emscripten\", \"emscripten\"),\n-];\n+const OS_TABLE: &'static [(&'static str, &'static str)] = &[(\"android\", \"android\"),\n+                                                            (\"bitrig\", \"bitrig\"),\n+                                                            (\"darwin\", \"macos\"),\n+                                                            (\"dragonfly\", \"dragonfly\"),\n+                                                            (\"freebsd\", \"freebsd\"),\n+                                                            (\"ios\", \"ios\"),\n+                                                            (\"linux\", \"linux\"),\n+                                                            (\"mingw32\", \"windows\"),\n+                                                            (\"netbsd\", \"netbsd\"),\n+                                                            (\"openbsd\", \"openbsd\"),\n+                                                            (\"win32\", \"windows\"),\n+                                                            (\"windows\", \"windows\"),\n+                                                            (\"solaris\", \"solaris\"),\n+                                                            (\"emscripten\", \"emscripten\")];\n \n-const ARCH_TABLE: &'static [(&'static str, &'static str)] = &[\n-    (\"aarch64\", \"aarch64\"),\n-    (\"amd64\", \"x86_64\"),\n-    (\"arm\", \"arm\"),\n-    (\"arm64\", \"aarch64\"),\n-    (\"hexagon\", \"hexagon\"),\n-    (\"i386\", \"x86\"),\n-    (\"i686\", \"x86\"),\n-    (\"mips\", \"mips\"),\n-    (\"msp430\", \"msp430\"),\n-    (\"powerpc\", \"powerpc\"),\n-    (\"powerpc64\", \"powerpc64\"),\n-    (\"s390x\", \"systemz\"),\n-    (\"sparc\", \"sparc\"),\n-    (\"x86_64\", \"x86_64\"),\n-    (\"xcore\", \"xcore\"),\n-    (\"asmjs\", \"asmjs\"),\n-];\n+const ARCH_TABLE: &'static [(&'static str, &'static str)] = &[(\"aarch64\", \"aarch64\"),\n+                                                              (\"amd64\", \"x86_64\"),\n+                                                              (\"arm\", \"arm\"),\n+                                                              (\"arm64\", \"aarch64\"),\n+                                                              (\"hexagon\", \"hexagon\"),\n+                                                              (\"i386\", \"x86\"),\n+                                                              (\"i686\", \"x86\"),\n+                                                              (\"mips\", \"mips\"),\n+                                                              (\"msp430\", \"msp430\"),\n+                                                              (\"powerpc\", \"powerpc\"),\n+                                                              (\"powerpc64\", \"powerpc64\"),\n+                                                              (\"s390x\", \"systemz\"),\n+                                                              (\"sparc\", \"sparc\"),\n+                                                              (\"x86_64\", \"x86_64\"),\n+                                                              (\"xcore\", \"xcore\"),\n+                                                              (\"asmjs\", \"asmjs\")];\n \n pub fn get_os(triple: &str) -> &'static str {\n     for &(triple_os, os) in OS_TABLE {\n         if triple.contains(triple_os) {\n-            return os\n+            return os;\n         }\n     }\n     panic!(\"Cannot determine OS from triple\");\n }\n pub fn get_arch(triple: &str) -> &'static str {\n     for &(triple_arch, arch) in ARCH_TABLE {\n         if triple.contains(triple_arch) {\n-            return arch\n+            return arch;\n         }\n     }\n     panic!(\"Cannot determine Architecture from triple\");\n@@ -74,17 +70,21 @@ pub fn make_new_path(path: &str) -> String {\n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n     match env::var(lib_path_env_var()) {\n-        Ok(curr) => {\n-            format!(\"{}{}{}\", path, path_div(), curr)\n-        }\n-        Err(..) => path.to_owned()\n+        Ok(curr) => format!(\"{}{}{}\", path, path_div(), curr),\n+        Err(..) => path.to_owned(),\n     }\n }\n \n-pub fn lib_path_env_var() -> &'static str { \"PATH\" }\n-fn path_div() -> &'static str { \";\" }\n+pub fn lib_path_env_var() -> &'static str {\n+    \"PATH\"\n+}\n+fn path_div() -> &'static str {\n+    \";\"\n+}\n \n pub fn logv(config: &Config, s: String) {\n     debug!(\"{}\", s);\n-    if config.verbose { println!(\"{}\", s); }\n+    if config.verbose {\n+        println!(\"{}\", s);\n+    }\n }"}]}